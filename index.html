<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-CG/WHM-GAMES103/11" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/23/CG/WHM-GAMES103/11/" class="article-date">
  <time class="dt-published" datetime="2022-10-23T15:33:16.669Z" itemprop="datePublished">2022-10-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES103/">CG.GAMES103</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/23/CG/WHM-GAMES103/11/">GAMES103.王华民.11.Incompressible Fluid Dynamics and Eulerian Fluids</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili 课程链接</a></li>
</ul>
<h1 id="网格表示和有限差分"><a href="#网格表示和有限差分" class="headerlink" title="网格表示和有限差分"></a>网格表示和有限差分</h1><ul>
<li>A Grid Representation and Finite Differencing</li>
</ul>
<h2 id="规则网格表示"><a href="#规则网格表示" class="headerlink" title="规则网格表示"></a>规则网格表示</h2><ul>
<li>模拟二维的流体，需要使用一个二维数组来表示</li>
</ul>
<p>05：09</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/23/CG/WHM-GAMES103/11/" data-id="cl9lj749q008064tz48on2tg7" data-title="GAMES103.王华民.11.Incompressible Fluid Dynamics and Eulerian Fluids" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WHM/" rel="tag">WHM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/Papers/2021/bvh-survey-3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/23/CG/Papers/2021/bvh-survey-3/" class="article-date">
  <time class="dt-published" datetime="2022-10-23T15:33:16.621Z" itemprop="datePublished">2022-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/23/CG/Papers/2021/bvh-survey-3/">(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(4)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="BVH-Survey"><a href="#BVH-Survey" class="headerlink" title="BVH Survey"></a>BVH Survey</h1><ul>
<li><a href="/2022/04/06/CG/Papers/2021/bvh-survey-home/">目录</a></li>
</ul>
<h1 id="4-construct-bvh"><a href="#4-construct-bvh" class="headerlink" title="4. construct bvh"></a>4. construct bvh</h1><h2 id="4-5-Topology-Optimization"><a href="#4-5-Topology-Optimization" class="headerlink" title="4.5. Topology Optimization"></a>4.5. Topology Optimization</h2><ul>
<li>我们在构建 BVH 的过程中，无法知道子结点的代价函数值，因此都是做的局部优化（简化）<ul>
<li>例如将子节点的内部节点都当作叶子节点来考虑</li>
</ul>
</li>
<li>因此结构优化就是先建立好一个 BVH，然后对其进调整优化</li>
<li>这一部分的优化目标基于 SAH（内部节点的 BVH 表面积之和最小）</li>
</ul>
<h3 id="tree-rotation"><a href="#tree-rotation" class="headerlink" title="tree rotation"></a>tree rotation</h3><ul>
<li>树结点的旋转操作（二分查找树的旋转操作）</li>
<li>一共有 4 种旋转方式</li>
<li>论文提出了两种方法<ul>
<li>Hill Climbing</li>
<li>Simulated Annealing：避免陷入局部极值</li>
</ul>
</li>
</ul>
<h4 id="Hill-Climbing"><a href="#Hill-Climbing" class="headerlink" title="Hill Climbing"></a>Hill Climbing</h4><ul>
<li>按照<strong>中序遍历</strong>的方式一次检测每一个节点<ul>
<li>对每一个节点做如下操作</li>
<li>计算当前点的代价函数</li>
<li>应用上面的 4 种旋转（不行则不旋转），记录代价函数减小最多的旋转<ul>
<li>如果有减小，使用这个旋转更新，同时更新当前点的代价函数值</li>
<li>如果没有减小，则检测下一个节点</li>
</ul>
</li>
</ul>
</li>
<li>问题：可能会陷入局部极值（很多情况下）</li>
</ul>
<h4 id="Simulated-Annealing"><a href="#Simulated-Annealing" class="headerlink" title="Simulated Annealing"></a>Simulated Annealing</h4><ul>
<li>模拟退火</li>
<li>基本思想是，对于可能增加 SAH 的旋转，也有一定概率接受（可能会走向全局最优）</li>
</ul>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="/bvh-survey-3/image-20220414163629274.png"></p>
<h3 id="remove-and-reinsert"><a href="#remove-and-reinsert" class="headerlink" title="remove and reinsert"></a>remove and reinsert</h3><ul>
<li>Fast Insertion-Based Optimization of Bounding Volume Hierarchies.<ul>
<li>移除一棵子树，然后把这棵子树中的节点重新插入</li>
<li>查找空间很大，因此需要确定处理子树的顺序<ul>
<li>一个直观的顺序：按照 SAH 的代价函数值的大小（下图）</li>
</ul>
</li>
<li>查找新位置<ul>
<li>带剪枝的搜索算法（分支限界算法）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey-3/image-20220414171135623.png"></p>
<ul>
<li>T-SAH: Animation Optimized Bounding Volume Hierarchies<ul>
<li>使用 Metropolis-Hastings sampling 的方式优化先移除哪一棵子树</li>
</ul>
</li>
</ul>
<h3 id="PRBVH"><a href="#PRBVH" class="headerlink" title="PRBVH"></a>PRBVH</h3><ul>
<li><p>一个很重要的假设：**<span style="color:red">每个叶子节点只包含一个三角形</span>**</p>
</li>
<li><p>论文：Parallel Reinsertion for Bounding Volume Hierarchy Optimization</p>
</li>
<li><p>并行化，把上面的问题重新形式化成一个可以并行的问题</p>
<ul>
<li>最终结果：类似质量下，<strong>比原来串行化快两个数量级</strong></li>
</ul>
</li>
<li><p>The key insight：我们在计算 SA 缩减的时候不需要真正去移除子树，找到最优位置之后再进行移除</p>
</li>
<li><p>给很多个 node 并行的找最优的插入位置（SAH cost 减少最多）</p>
</li>
<li><p>思路：<span id="prbvh_alg">迭代算法</span></p>
<ul>
<li>输入为一个任意的 BVH，然后迭代优化，每一轮迭代并行执行一组 reinsertion  操作</li>
<li>each node searches for its best output node in parallel</li>
<li>the conflicts between nodes are resolved using the <em>locking scheme</em></li>
<li>The nodes with successful locks can be reinserted</li>
<li>After the reinsertion, we recompute the bounding boxes and the SAH cost</li>
</ul>
</li>
<li><p>SAH cost</p>
</li>
</ul>
<p>$$<br>c(N)&#x3D;\dfrac{1}{SA(N)}\left[c_T\sum_{N_i}SA(N_i)+c_I\sum_{N_l}SA(N_l)\vert{N_l}\vert\right]<br>$$</p>
<h4 id="Reinsertion-Operation"><a href="#Reinsertion-Operation" class="headerlink" title="Reinsertion Operation"></a>Reinsertion Operation</h4><ul>
<li>对每一个节点</li>
<li>将其所在的子树（绿色）连同它的父节点（蓝色）一起移除，然后将其兄弟节点（淡黄色）放到父节点原来的位置</li>
<li>将移除部分插入到找到的最优位置（红色），将这个位置原来的节点挂在兄弟节点的位置</li>
</ul>
<p><img src="/bvh-survey-3/image-20220418132910246.png"></p>
<h4 id="Parallel-Search"><a href="#Parallel-Search" class="headerlink" title="Parallel Search"></a>Parallel Search</h4><ul>
<li><strong>每一个叶子节点都只包含一个三角形</strong></li>
<li>此时优化 SAH cost，就等价于优化这个部分（其他都变为常数）</li>
</ul>
<p>$$<br>\sum_{N_i}SA(N_i)<br>$$</p>
<ul>
<li>形式化优化问题：maximization of the surface area decrease<ul>
<li>等价于最大化受影响的 BVH 的 SA 减小</li>
</ul>
</li>
<li>受影响的 BVH 只有<strong>输入、输出节点之间的路径</strong><ul>
<li>上图中的 <code>in-pivot-out</code></li>
<li>pivot：最近公共祖先节点</li>
<li>移除：$(pivot,in]$ 中的节点的 SA 的减小的非负的（一定减小或不变）</li>
<li>插入：$(pivot,out]$ 中的节点的 SA 的减小是非正的（一定增加或不变）</li>
</ul>
</li>
<li>可以按照 SA 是增加还是减小，将这些路径上的节点划分为几类<ul>
<li>路径不包括 in 节点、in 节点的父节点、output 节点</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey-3/image-20220419111023646.png"></p>
<ul>
<li>对一个输入节点 in，如何寻找输出节点 out？<ul>
<li>查找所有树上的节点（除了以 in 节点为根的子树内的节点）</li>
<li>利用 <em>parent</em> 指针可以不使用辅助的栈结构实现<ul>
<li>利用一个 bool 记录是上行还是下行，利用指针进行上下游走</li>
<li><a href="/utils/show_code/index.html?CG/Paper/2021/bvh-survey/preorder.py">python 代码</a></li>
</ul>
</li>
</ul>
</li>
<li>总的来说就是一个带剪枝的找最优 output 位置的算法</li>
<li>对于所有的节点，可以并行地找出最佳位置</li>
</ul>
<h5 id="算法细节"><a href="#算法细节" class="headerlink" title="算法细节"></a>算法细节</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://meistdan.github.io/publications/prbvh/slides.pdf">demo</a></p>
</li>
<li><p>初始化的最优 out 节点就是 in 节点的兄弟节点</p>
<ul>
<li>decrease&#x3D;0</li>
</ul>
</li>
<li><p>$d_{bound}$：整条路径的 SA 减小的上界</p>
<ul>
<li><strong>就是对 $d_{direct}$ 上界的估计</strong></li>
</ul>
</li>
<li><p>$\mathbf{b}_{pivot}$：去掉 in 节点之后的 pivot 的包围盒</p>
<ul>
<li>$\mathbf{b}<em>{pivot}$ 的计算：pivot 的右子节点的包围盒和 $\mathbf{b}</em>{pivot}$ 的并集</li>
<li>用于累计计算路径上 SA 的减小</li>
</ul>
</li>
<li><p>有些在算法运行过程中不变的量</p>
<ul>
<li>$\mathbf{b}<em>{parent},d</em>{bound}$</li>
</ul>
</li>
<li><p>整体是一个前序遍历的算法</p>
</li>
<li><p>$d$ 是进入到新的节点之后才被更新</p>
</li>
</ul>
<p><img src="/bvh-survey-3/image-20220419133042474.png"></p>
<h6 id="down-x3D-True"><a href="#down-x3D-True" class="headerlink" title="down&#x3D;True"></a>down&#x3D;True</h6><ul>
<li><p>down&#x3D;True</p>
</li>
<li><p>$d$：搜索到当前 out 节点为止，路径上的 SA <strong>减少值</strong></p>
<ul>
<li>粉红色路径的 SA 减小值</li>
<li>这里的更新是更新粉红色路径最后的节点的 SA，相当于在原来的子树内插入了 in 节点<ul>
<li>减少值就是 $SA(\mathbf{b}<em>{out})-SA(\mathbf{b}</em>{merge})$</li>
</ul>
</li>
</ul>
</li>
<li><p>$d_{direct}$：紫色路径（蓝色节点）的 SA 减小值（原来是 in 的父节点） </p>
<ul>
<li>因此这里的更新使用 $SA(\mathbf{b}<em>{parent})-SA(\mathbf{b}</em>{merge})$</li>
</ul>
</li>
<li><p>剪枝：由于 $d$ 在 down&#x3D;True 的遍历过程中是不增的</p>
<ul>
<li>$d_{max}\le d$（$d$ 表示当前计算得到的 $d$）</li>
</ul>
<p>$$<br>\begin{aligned}<br>d_{may_be_best}<br>&amp;&#x3D;d_{max}+d_{direct}\<br>&amp;\le d+d_{direct}\<br>&amp;&#x3D; d+SA(\mathbf{b}<em>{parent})-SA(\mathbf{b}</em>{merged})\<br>&amp;\le d+d_{bound}<br>\end{aligned}<br>$$</p>
</li>
<li><p>down 的更新</p>
<ul>
<li>剪枝向上回溯</li>
<li>如果没有左子节点，则向上回溯</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey-3/alg_1.png"></p>
<h6 id="down-x3D-False"><a href="#down-x3D-False" class="headerlink" title="down&#x3D;False"></a>down&#x3D;False</h6><ul>
<li>首先更新 $d$：去除最后一个结点的减小值</li>
<li>两种情况分类讨论：子树的前序遍历完成、还处于前序遍历的 up-phase</li>
<li>遍历完成<ul>
<li>更新 pivot 的包围盒值<ul>
<li>原来的 pivot 的包围盒记录的是 pivot 左子树的包围盒<ul>
<li>因为 in 插入到 pivot 子树中时，pivot 的 SA 变化为 0，不影响 $d$ 的计算</li>
</ul>
</li>
<li>不包含 in 节点</li>
</ul>
</li>
<li>27-29：out&#x3D;pivot</li>
<li>33-36：in 节点不能插入到父节点位置，除了父节点，都需要进行尝试</li>
<li>更新 $d$：pivot 减去 in 节点 SA 减小了多少</li>
<li>42-44：对兄弟子树进行遍历</li>
</ul>
</li>
<li>up-phase<ul>
<li>从左子节点上来，则继续遍历右子节点</li>
<li>从右子节点上来，则继续向上</li>
</ul>
</li>
</ul>
<h4 id="Parallel-Reinsertion"><a href="#Parallel-Reinsertion" class="headerlink" title="Parallel Reinsertion"></a>Parallel Reinsertion</h4><ul>
<li>解决可能存在的冲突问题</li>
<li>两种冲突<ul>
<li>topological conflicts</li>
<li>path conflicts</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey-3/image-20220419160520122.png"></p>
<ul>
<li>当发生冲突的时候，丢弃优先级小的</li>
<li>topological conflicts：同时修改树结构<ul>
<li>并发操作加锁，SA 减小更多的优先操作</li>
<li>锁定影响到的节点</li>
</ul>
</li>
<li>path conflicts：同时修改 BVH<ul>
<li>锁定路径上的所有节点</li>
</ul>
</li>
</ul>
<h5 id="Locking-Strategy"><a href="#Locking-Strategy" class="headerlink" title="Locking Strategy"></a>Locking Strategy</h5><ul>
<li>保守的：path+topological 都加锁<ul>
<li>一定能够保证 SA 减少的总量和所有成功加锁的 path 的 SA 减少之和相等</li>
</ul>
</li>
<li>激进的：topological 加锁<ul>
<li>不能保证总量和分量之和想的相等（可能多、少、相等）</li>
<li>实验表明，收敛更快</li>
</ul>
</li>
</ul>
<h5 id="激进策略分析"><a href="#激进策略分析" class="headerlink" title="激进策略分析"></a>激进策略分析</h5><ul>
<li>对于一个 AABB 包围盒来说，决定这个包围盒的内部包围盒最多只有 6 个（一个面一个）<ul>
<li>如果有两个包围盒决定了同一个面，选择一个即可</li>
</ul>
</li>
</ul>
<h6 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h6><ul>
<li><p>不同节点的内部节点移除</p>
<ul>
<li>只有决定了包围盒的面的节点移除才会有 positive SA decrease</li>
<li>如果和其它节点共同决定一个面，那么移除这个节点对这个面，SA 无变化</li>
<li>不决定面，则 SA 无变化</li>
</ul>
</li>
<li><p>同时对有 positive SA decrease 的节点进行移除，可能会导致总的减少比部分减少之和要小</p>
<ul>
<li>例如移除决定相邻的面的两个节点<ul>
<li>下图中的 1、2、3，虚线方框部分的在总的减少中只会被计算一次</li>
</ul>
</li>
</ul>
</li>
<li><p>同时移除也可能导致总的减少比部分减少要大</p>
<ul>
<li>决定面的节点的移除，使得本身不决定 bvh 面的节点决定面<ul>
<li>下图中的 4、5，本身不决定 bvh 面的节点变成决定面</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey-3/image-20220420111238432.png"></p>
<h6 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h6><ul>
<li>插入的时候也有类似的问题，本身所有的节点插入，都会有 negative SA decrease</li>
<li>总的增加 &lt; 分量增加之和<ul>
<li>1、2、3：图 3 的右下角虚线黑框只会被总的计算一次</li>
<li>5：内部有些红色节点的插入本身会导致 SA 增加，但是现在不会了</li>
</ul>
</li>
<li>总的增加 &gt; 分量增加之和<ul>
<li>3、4：一开始最左边红色块的插入不需要计算图 4 的两个黑色虚线黑框内的部分</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey-3/image-20220420112359213.png"></p>
<h5 id="最好最坏情况分析"><a href="#最好最坏情况分析" class="headerlink" title="最好最坏情况分析"></a>最好最坏情况分析</h5><ul>
<li>two path analysis</li>
<li>移除（下图中的绿色节点移除）<ul>
<li>最好：单个移除不影响 bvh，两个一起移除 SA $\to$ 0</li>
<li>最差：单个移除 SA $\to$ 0</li>
</ul>
</li>
<li>插入（下图中的红色节点插入）<ul>
<li>最好：单个插入 SA 的增加和两个插入一样</li>
<li>最差：单个插入 SA 的增加都为 0，但是两个插入让其变大<ul>
<li>红色为点（退化的 bvh）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey-3/image-20220420115022463.png"></p>
<ul>
<li>为什么激进策略更好呢？<ul>
<li>锁住的节点少，在一次迭代能够有更多操作同时进行（throughput）</li>
<li>一开始的时候，positive SA decrease 比 negative SA decrease 更多，因此总的效果来说是更好的</li>
<li>大量移除的节点都是不决定原来的 bvh 的<ul>
<li>可能会有更多的 SA decrease，在移除其他节点之后决定了 bvh</li>
</ul>
</li>
<li>大量插入的节点都是不决定最终的 bvh 的（不会导致 SA increase）</li>
</ul>
</li>
</ul>
<h4 id="完整算法"><a href="#完整算法" class="headerlink" title="完整算法"></a>完整算法</h4><ul>
<li><a href="#prbvh_alg">迭代算法</a></li>
</ul>
<p><img src="/bvh-survey-3/image-20220420124655823.png"></p>
<ul>
<li>sparse search<ul>
<li>算法瓶颈是在查找 search phase</li>
<li>相邻的节点搜索得到的路径引起冲突的可能性比较大，因此同一轮的搜索中，相邻的几个节点我们尽量只搜索少量几个</li>
<li>只有满足如下式子的 $i$ 才进行搜索，$I$ 表示迭代轮数，$\mu\in{4,\cdots,9}$</li>
</ul>
</li>
</ul>
<p>$$<br>I(\mod\mu)\equiv i(\mod\mu)<br>$$</p>
<ul>
<li>终止条件<ul>
<li>两次迭代的 SA cost 差异小于 $\epsilon$</li>
<li>实验值：$\epsilon&#x3D;0.1$</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://dcgi.fel.cvut.cz/projects/prbvh/">GPU 实现</a><ul>
<li>Find the best node</li>
<li>Lock nodes</li>
<li>Check locks</li>
<li>Reinsert</li>
<li>Recompute bounding boxes</li>
<li>Compute the SAH cost</li>
</ul>
</li>
</ul>
<h3 id="TRBVH"><a href="#TRBVH" class="headerlink" title="TRBVH"></a>TRBVH</h3><ul>
<li>treelet restructuring<ul>
<li>treelet：small subtrees of a fixed size</li>
</ul>
</li>
<li>基本思想是重构树形结构<ul>
<li>每次使用动态规划的方式重构一个 treelet</li>
<li>bottom-up</li>
</ul>
</li>
<li>改进<ul>
<li>使用 agglomerative clustering（聚集方法）代替动态规划，能够处理更大的 treelet</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/23/CG/Papers/2021/bvh-survey-3/" data-id="cl9lj74bw00mi64tz8svte5lw" data-title="(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(4)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BVH/" rel="tag">BVH</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EG/" rel="tag">EG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Paper/" rel="tag">Paper</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/occlusion/" rel="tag">occlusion</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/Kits/MIS-NEE" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/28/CG/Kits/MIS-NEE/" class="article-date">
  <time class="dt-published" datetime="2022-04-28T07:23:22.000Z" itemprop="datePublished">2022-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-Kits/">CG.Kits</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/28/CG/Kits/MIS-NEE/">NEE、MIS(多重重要性采样)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="NEE"><a href="#NEE" class="headerlink" title="NEE"></a>NEE</h1><ul>
<li>Next Event Estimation</li>
<li>参考资料<ul>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=FU1dbi827LY">Youtube</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cg.tuwien.ac.at/sites/default/files/course/4411/attachments/08_next%20event%20estimation.pdf">课件</a></li>
</ul>
</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>NEE 的概念非常简单，就是在做积分的时候，将<strong>直接光照</strong>和<strong>间接光照</strong>区分开<ul>
<li>相当于分块积分</li>
</ul>
</li>
</ul>
<p>$$<br>\begin{aligned}<br>I&amp;&#x3D;\int_{\Omega}g(X)\mathrm{d}\mu(X)\<br>&amp;&#x3D;\int_{\Omega_1}g(X)\mathrm{d}\mu(X)+\int_{\Omega_2}g(X)\mathrm{d}\mu(X)\<br>\end{aligned}<br>$$</p>
<p>$$<br>\Omega_1\cap\Omega_2&#x3D;\emptyset,\Omega_1\cup\Omega_1&#x3D;\Omega<br>$$</p>
<h2 id="直接光照采样"><a href="#直接光照采样" class="headerlink" title="直接光照采样"></a>直接光照采样</h2><p><img src="/MIS-NEE/image-20220428155924708.png"></p>
<ul>
<li>这里的一个细节，需要将对光源的采样转化为对立体角的采样</li>
</ul>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ul>
<li>首先在光源上采样，计算出贡献</li>
<li>计算可见性，如果不可见，则计算得到的值为 0</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="/MIS-NEE/image-20220428160114276.png"></p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><ul>
<li>结果肯定是有偏的，因为只有 1-bounce 的光路，需要配合其他方法<ul>
<li>因为积分区域没有覆盖整个 BRDF 的定义域</li>
</ul>
</li>
</ul>
<h2 id="NEE-1"><a href="#NEE-1" class="headerlink" title="NEE"></a>NEE</h2><ul>
<li>总体的思路是这样的</li>
</ul>
<p><img src="/MIS-NEE/image-20220428162944585.png"></p>
<h3 id="实现1"><a href="#实现1" class="headerlink" title="实现1"></a>实现1</h3><ul>
<li>在 path tracing 的框架中，每次求某一个点的 radiance 的时候，我们做两次采样，分别计算直接光照的和间接光照</li>
<li>重复计算问题</li>
</ul>
<p><img src="/MIS-NEE/image-20220428165331187.png"></p>
<ul>
<li>直接光照采样，就和上面一样<ul>
<li>光源上采样一个位置，判断可见性，计算贡献值</li>
</ul>
</li>
<li>间接光照采样<ul>
<li>如果直接按照 BSDF 采样，那么结果是有偏的（太亮了）</li>
<li>按照 BSDF 采样，这里的积分区域包含了上面光源的积分区域，导致重复计算</li>
<li>PPT 上给的一个实现，将第一次 bounce 之后的间接光照减半</li>
</ul>
</li>
</ul>
<p><img src="/MIS-NEE/image-20220428163330740.png"></p>
<ul>
<li>这种实现是无偏的吗？<ul>
<li><strong><span style="color:red">感觉不是无偏的</span></strong></li>
</ul>
</li>
</ul>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现 2"></a>实现 2</h3><ul>
<li>直接分离光照来源<ul>
<li>只有在直接光照采样的部分打到光源，才返回光源的 emission</li>
<li>如果在间接光照采样的部分打到光源，返回 0</li>
</ul>
</li>
<li>这是无偏的<ul>
<li>所有路径都会被计算，且只会被计算一次</li>
</ul>
</li>
</ul>
<p><img src="/MIS-NEE/image-20220428173622838.png"></p>
<ul>
<li>另外一种写法<ul>
<li>镜面特殊处理，因为镜面没有直接光源采样（采不到）</li>
</ul>
</li>
</ul>
<p><img src="/MIS-NEE/image-20220428173721033.png"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>我们使用 <code>NEE</code> 的原因是认识<strong>对光源采样</strong>比<strong>按照 BSDF 采样要好</strong></li>
<li>实际上对光源采样也会有问题<ul>
<li><strong>不能很好的采样大光源</strong></li>
</ul>
</li>
</ul>
<p><img src="/MIS-NEE/image-20220428174955945.png"></p>
<ul>
<li>BSDF：能够较好采样大光源，对小光源采样差</li>
<li>采样光源：能够较好采样小光源，对大光源采样差</li>
<li>原因如下<ul>
<li>对于大光源，直接采样光源（面积）的范围比采样 BSDF（立体角）更大</li>
<li>可以理解为立体角是面积采样的 Stratified Sampling<ul>
<li>面积采样有很多无效采样，例如一小部分面积内部可能一样</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/MIS-NEE/image-20220428175359024.png"></p>
<h3 id="经典老图"><a href="#经典老图" class="headerlink" title="经典老图"></a>经典老图</h3><ul>
<li><a href="/utils/image_compare/?/2022/04/28/CG/Kits/MIS-NEE/;brdf.png;light.png;mis.png">效果对比</a></li>
<li>Sampling the light sources</li>
</ul>
<p><img src="/MIS-NEE/light.png"></p>
<ul>
<li>Sampling the BRDF</li>
</ul>
<p><img src="/MIS-NEE/brdf.png"></p>
<ul>
<li>A combination of samples from (a) and (b)</li>
</ul>
<p><img src="/MIS-NEE/mis.png"></p>
<h1 id="MIS"><a href="#MIS" class="headerlink" title="MIS"></a>MIS</h1><ul>
<li>Multiple Importance Sampling<ul>
<li>多种重要性采样</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cg.tuwien.ac.at/sites/default/files/course/4411/attachments/08_mis.pdf">课件</a></li>
<li>结合多种采样方式，更准确地说，结合多个 <code>pdf</code></li>
</ul>
<h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><ul>
<li>如果 $\sum_{i&#x3D;0}^{n}w_i&#x3D;1$<ul>
<li>$X_{i,j}$ 表示使用第 $i$ 种采样方案采样到的第 $j$ 个样本</li>
<li>$p_i(X_{i,j})$ 表示这个方向在第 $i$ 个 pdf 中的返回值</li>
</ul>
</li>
</ul>
<p>$$<br>\begin{aligned}<br>E[F]&amp;&#x3D;\sum_{i&#x3D;0}^{n}w_iE[F_i]\<br>&amp;&#x3D;\sum_{i&#x3D;0}^{n}\dfrac{1}{n_i}\sum_{j&#x3D;0}^{n_i}w_iE\left[\dfrac{f(X_{i,j})}{p_i(X_{i,j})}\right]\<br>&amp;&#x3D;\int_{\Omega}f(x);\mathrm{d}x<br>\end{aligned}<br>$$</p>
<ul>
<li>使用上面的这种方式就可以结合不同的采样策略（不同的采样 pdf）</li>
</ul>
<h2 id="确定-w-i"><a href="#确定-w-i" class="headerlink" title="确定 $w_i$"></a>确定 $w_i$</h2><ul>
<li>如何确定 $w_i$</li>
<li>Balance heuristic<ul>
<li>You can’t do much better than that, i.e. it’s always within a bound of the best strategy</li>
<li><a target="_blank" rel="noopener" href="http://graphics.stanford.edu/papers/veach_thesis/">Veach</a></li>
<li>$c_i$ 表示使用第 $i$ 种采样策略的概率<ul>
<li>$\sum_{i&#x3D;0}^{n}c_i&#x3D;1$</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>$$<br>w_i(x)&#x3D;\dfrac{c_ip_i(x)}{\sum_{k&#x3D;0}^{n}c_kp_k(x)}<br>$$</p>
<ul>
<li>Power heuristic<ul>
<li>better if there is one strategy with very low variance</li>
</ul>
</li>
</ul>
<p>$$<br>w_i(x)&#x3D;\dfrac{p_i^{\beta}(x)}{\sum_{k&#x3D;0}^{n}p_k^{\beta}(x)}<br>$$</p>
<h2 id="Balance-heuristic"><a href="#Balance-heuristic" class="headerlink" title="Balance heuristic"></a>Balance heuristic</h2><ul>
<li>细节推导</li>
</ul>
<p>$$<br>\begin{aligned}<br>E[F]&amp;&#x3D;\sum_{i&#x3D;0}^{n}w_i(X_{i,j})E[F_i]\<br>&amp;&#x3D;\sum_{i&#x3D;0}^{n}\dfrac{1}{n_i}\sum_{j&#x3D;0}^{n_i}w_i(X_{i,j})E\left[\dfrac{f(X_{i,j})}{p_i(X_{i,j})}\right]\<br>&amp;&#x3D;\sum_{i&#x3D;0}^{n}\dfrac{1}{n_i}\sum_{j&#x3D;0}^{n_i}\dfrac{c_ip_i(X_{i,j})}{\sum_{k&#x3D;0}^{n}c_kp_k(X_{i,j})}E\left[\dfrac{f(X_{i,j})}{p_i(X_{i,j})}\right]\<br>&amp;&#x3D;\sum_{i&#x3D;0}^{n}\dfrac{c_i}{n_i}\sum_{j&#x3D;0}^{n_i}E\left[\dfrac{f(X_{i,j})}{\sum_{k&#x3D;0}^{n}c_kp_k(X_{i,j})}\right]\<br>&amp;&#x3D;\sum_{i&#x3D;0}^{n}\dfrac{1}{N}\sum_{j&#x3D;0}^{n_i}E\left[\dfrac{f(X_{i,j})}{\sum_{k&#x3D;0}^{n}c_kp_k(X_{i,j})}\right]\<br>&amp;&#x3D;\dfrac{1}{N}\sum_{i&#x3D;0}^{n}\sum_{j&#x3D;0}^{n_i}E\left[\dfrac{f(X_{i,j})}{\sum_{k&#x3D;0}^{n}c_kp_k(X_{i,j})}\right]\<br>&amp;&#x3D;\dfrac{1}{N}\sum_{i&#x3D;0}^{N}E\left[\dfrac{f(X_{i})}{\sum_{k&#x3D;0}^{n}c_kp_k(X_{i})}\right]\<br>\end{aligned}<br>$$</p>
<ul>
<li>使用 MC 的方式的话，相当于使用一个联合分布 $\bar{p}(x)$ 进行采样</li>
</ul>
<p>$$<br>\bar{p}(x)&#x3D;\sum_{k&#x3D;0}^{n}c_kp_k(x)<br>$$</p>
<ul>
<li>这样我们就可以很容易的将 BSDF 采样和对光源采样结合在一起</li>
<li>一般而言，很容易实现对多种 pdf 的采样</li>
</ul>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="/MIS-NEE/image-20220428175813841.png"></p>
<h1 id="效果图-1"><a href="#效果图-1" class="headerlink" title="效果图"></a>效果图</h1><ul>
<li>100spp</li>
<li><a href="/utils/image_compare/?/2022/04/28/CG/Kits/MIS-NEE/;brdf-100spp-18s.png;light-100spp-8s.png;brdf-with-light-100spp-12s.png;nee-100spp-37s.png;hemi-100ssp-19s.png">效果对比</a></li>
</ul>
<h2 id="法向半球采样"><a href="#法向半球采样" class="headerlink" title="法向半球采样"></a>法向半球采样</h2><ul>
<li>19s</li>
</ul>
<p><img src="/MIS-NEE/hemi-100ssp-19s.png"></p>
<h2 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h2><ul>
<li>18s</li>
</ul>
<p><img src="/MIS-NEE/brdf-100spp-18s.png"></p>
<h2 id="Light"><a href="#Light" class="headerlink" title="Light"></a>Light</h2><ul>
<li>8s</li>
</ul>
<p><img src="/MIS-NEE/light-100spp-8s.png"></p>
<h2 id="MIS-with-BRDF-and-Light"><a href="#MIS-with-BRDF-and-Light" class="headerlink" title="MIS with BRDF and Light"></a>MIS with BRDF and Light</h2><ul>
<li>12s</li>
</ul>
<p><img src="/MIS-NEE/brdf-with-light-100spp-12s.png"></p>
<h2 id="NEE-2"><a href="#NEE-2" class="headerlink" title="NEE"></a>NEE</h2><h3 id="实现1-1"><a href="#实现1-1" class="headerlink" title="实现1"></a>实现1</h3><ul>
<li>37s</li>
</ul>
<p><img src="/MIS-NEE/nee-implement1-100spp-37s.png"></p>
<ul>
<li>1000spp, 417s</li>
</ul>
<p><img src="/MIS-NEE/nee-implement1-1000spp-417s.png"></p>
<ul>
<li>可以看出来确实亮一些，是有偏的</li>
</ul>
<h3 id="实现2"><a href="#实现2" class="headerlink" title="实现2"></a>实现2</h3><p><img src="/MIS-NEE/nee-100spp-37s.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/28/CG/Kits/MIS-NEE/" data-id="cl9lj749a005364tzcqkd0jax" data-title="NEE、MIS(多重重要性采样)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MIS/" rel="tag">MIS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NEE/" rel="tag">NEE</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/WHM-GAMES103/10" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/18/CG/WHM-GAMES103/10/" class="article-date">
  <time class="dt-published" datetime="2022-04-18T11:34:53.000Z" itemprop="datePublished">2022-04-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES103/">CG.GAMES103</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/18/CG/WHM-GAMES103/10/">GAMES103.王华民.10.Surface Waves</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili 课程链接</a></li>
</ul>
<h1 id="流体模拟"><a href="#流体模拟" class="headerlink" title="流体模拟"></a>流体模拟</h1><ul>
<li>Waves: An introduction to fluid simulation</li>
<li>流体呈现的形态是各种各样的，因此很难有一个通用的模拟算法能够很有效率的、很好的模拟各种效果<ul>
<li>水、烟雾等</li>
</ul>
</li>
</ul>
<h2 id="两种视角"><a href="#两种视角" class="headerlink" title="两种视角"></a>两种视角</h2><ul>
<li>拉格朗日视角<ul>
<li>物理变量是定义在随物体运动而运动的一些物质点上的</li>
<li>之前做的刚体、弹性体的模拟可以认为是拉格朗日视角的</li>
</ul>
</li>
<li>欧拉视角<ul>
<li>物理变量定义在空间网格中（不随物体运动而运动）</li>
</ul>
</li>
</ul>
<img src="10/image-20220418201634518.png" style="zoom:80%;" />



<h2 id="高度场"><a href="#高度场" class="headerlink" title="高度场"></a>高度场</h2><ul>
<li>高度场 $h(x)$<ul>
<li>定义每一个点的高度值</li>
</ul>
</li>
<li>2D 中，一般认为高度场是 <strong>1.5D</strong> 的<ul>
<li>因为高度场只能够表达函数能够表示的形式，是受限制的</li>
<li>不能表示非函数形式，例如一个 $x$ 对应多个 $y$ 值</li>
</ul>
</li>
<li>速度（场）<ul>
<li>带方向，决定流体的流向</li>
</ul>
</li>
</ul>
<img src="10/image-20220418202303576.png" style="zoom:80%;" />





<h2 id="Shallow-Wave-Equation"><a href="#Shallow-Wave-Equation" class="headerlink" title="Shallow Wave Equation"></a>Shallow Wave Equation</h2><ul>
<li>论文：Kass and Miller. 1990. <em>Rapid, Stable Fluid Dynamics for Computer Graphics</em>. Computer Graphics.</li>
</ul>
<h3 id="高度场更新"><a href="#高度场更新" class="headerlink" title="高度场更新"></a>高度场更新</h3><p>$$<br>\dfrac{\mathrm{d}h(x)}{\mathrm{d}t}+\dfrac{\mathrm{d}(h(x)u(x))}{\mathrm{d}x}&#x3D;0<br>$$</p>
<ul>
<li>从微分的定义去理解<ul>
<li><strong>体积的减小</strong>等于<strong>这一个点向外输送的流体体积</strong></li>
</ul>
</li>
</ul>
<p>$$<br>\begin{aligned}<br>&amp;-\Big(h(x+\mathrm{d}x)u(x+\mathrm{d}x)\cdot\mathrm{d}t-h(x)u(x)\cdot\mathrm{d}t\Big)\<br>&#x3D;&amp;(h(x+\mathrm{d}x)-h(x))\cdot\mathrm{d}x\<br>\Longrightarrow&amp;-\mathrm{d}(h(x)u(x))\cdot\mathrm{d}t&#x3D;\mathrm{d}h(x)\cdot\mathrm{d}x\<br>\end{aligned}<br>$$</p>
<img src="10/image-20220418202658906.png" style="zoom:80%;" />



<h3 id="速度场更新"><a href="#速度场更新" class="headerlink" title="速度场更新"></a>速度场更新</h3><img src="10/image-20220418204200083.png" style="zoom:80%;" />

<ul>
<li>由好几个部分构成<ul>
<li>advection：水流的速度会随着自身的运动被带走<ul>
<li>想象某一个粒子，他的位置会随水流变化<ul>
<li>上一时刻 $x$ 的速度，直接计算得到的并不是这一时刻 $x$ 的速度（位置变了）</li>
</ul>
</li>
</ul>
</li>
<li>external：外力<ul>
<li>例如螺旋桨</li>
</ul>
</li>
<li>这里主要分析的部分</li>
</ul>
</li>
<li>不考虑 advection、external，我们得到如下的简化式子</li>
</ul>
<p>$$<br>\dfrac{\mathrm{d}u(x)}{\mathrm{d}t}&#x3D;-\dfrac{1}{\rho}\dfrac{\mathrm{d}P(x)}{\mathrm{d}x}<br>$$</p>
<ul>
<li>物理量<ul>
<li>$\rho$：密度</li>
<li>$P(x)$：压强</li>
</ul>
</li>
<li>直观理解<ul>
<li>$P(x+\mathrm{d}x)$ 大，则这个点的速度 $u(x)$ 减小 $\to$ 需要加一个负号</li>
<li>$\rho$ 越大，越难推动</li>
<li><strong>量纲</strong></li>
</ul>
</li>
</ul>
<img src="10/image-20220418204628090.png" style="zoom:80%;" />

<ul>
<li>具体物理推导：牛顿第二定律<ul>
<li>二维的，可以认为 $\mathrm{d}V&#x3D;h(x)\mathrm{d}x$</li>
</ul>
</li>
</ul>
<p>$$<br>P(x+\mathrm{d}x)&#x3D;\rho gh(x+\mathrm{d}x)<br>$$</p>
<p>$$<br>\begin{aligned}<br>\dfrac{\mathrm{d}u(x)}{\mathrm{d}t}&amp;&#x3D;a(x)\<br>&amp;&#x3D;-\dfrac{(\rho gh(x+\mathrm{d}x)-\rho gh(x))\cdot h(x)}{\rho h(x)\mathrm{d}x}\<br>&amp;&#x3D;-\dfrac{\mathrm{d}P(x)}{\rho \mathrm{d}x}\<br>\end{aligned}<br>$$</p>
<h3 id="Shallow-Wave-Equation-1"><a href="#Shallow-Wave-Equation-1" class="headerlink" title="Shallow Wave Equation"></a>Shallow Wave Equation</h3><ul>
<li>根据两个公式进行更新</li>
</ul>
<p>$$<br>\begin{array}{c}<br>\dfrac{\mathrm{d}h(x)}{\mathrm{d}t}+\dfrac{\mathrm{d}(h(x)u(x))}{\mathrm{d}x}&#x3D;0\<br>\dfrac{\mathrm{d}u(x)}{\mathrm{d}t}&#x3D;-\dfrac{1}{\rho}\dfrac{\mathrm{d}P(x)}<br>{\mathrm{d}x}<br>\end{array}<br>$$</p>
<ul>
<li>Shallow Wave Equation<ul>
<li>假设波很小，产生的都是小水波 $\Rightarrow\dfrac{\mathrm{d}h}{\mathrm{d}x}\approx0$</li>
<li>忽略高阶小项 $\dfrac{\mathrm{d}h}{\mathrm{d}t}\cdot\dfrac{\mathrm{d}u}{\mathrm{d}x}$</li>
</ul>
</li>
<li>链式法则展开</li>
</ul>
<img src="10/image-20220418210253952.png" style="zoom:80%;" />

<ul>
<li>合并得到 Shallow Wave Equation<ul>
<li>好处是不用管速度场了</li>
</ul>
</li>
</ul>
<img src="10/image-20220418210654078.png" style="zoom:80%;" />

<ul>
<li>此时问题转变成了对上述方程的离散化求解</li>
</ul>
<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><img src="10/image-20220418211308148.png" style="zoom:80%;" />

<ul>
<li>如何将上面的微分算子和离散化之后的高度对应起来？</li>
</ul>
<h3 id="有限差分"><a href="#有限差分" class="headerlink" title="有限差分"></a>有限差分</h3><h4 id="一阶导数"><a href="#一阶导数" class="headerlink" title="一阶导数"></a>一阶导数</h4><ul>
<li>finite differencing</li>
<li>一阶近似：前向差分、后向差分</li>
</ul>
<img src="10/image-20220418211540863.png" style="zoom:80%;" />

<ul>
<li>二阶近似：中心差分</li>
</ul>
<img src="10/image-20220418211649584.png" style="zoom:80%;" />



<h4 id="二阶导数"><a href="#二阶导数" class="headerlink" title="二阶导数"></a>二阶导数</h4><ul>
<li>先计算出来一阶导数，然后再计算二阶导数</li>
</ul>
<img src="10/image-20220418212102618.png" style="zoom:80%;" />

<ul>
<li>一维拉普拉斯算子：$[1,-2,1]$</li>
<li>类似的可以计算：$\dfrac{\mathrm{d}^2P(x)}{\mathrm{d}x^2}$</li>
</ul>
<h3 id="离散化的-SW-方程"><a href="#离散化的-SW-方程" class="headerlink" title="离散化的 SW 方程"></a>离散化的 SW 方程</h3><img src="10/image-20220418212502056.png" style="zoom:80%;" />

<ul>
<li>得到了一个离散化之后的 $h(x)$ 的更新函数</li>
</ul>
<h3 id="Volume-Preservation"><a href="#Volume-Preservation" class="headerlink" title="Volume Preservation"></a>Volume Preservation</h3><ul>
<li>保持水的体积不变（算法问题会导致体积变化）</li>
<li>保持水的体积不变：$\sum_{i}h_i(t)&#x3D;\sum_{i}h_i(t-\Delta t)$</li>
<li>算法问题：黄色部分不能保证为零</li>
</ul>
<img src="10/image-20220418212831018.png" style="zoom:80%;" />



<h4 id="solution1"><a href="#solution1" class="headerlink" title="solution1"></a>solution1</h4><img src="10/image-20220418213034386.png" style="zoom:80%;" />

<ul>
<li>直观理解：$h_{i}$ 和 $h_{i+1}$ 的交换量相同</li>
</ul>
<img src="10/image-20220418213200765.png" style="zoom:80%;" />





<h4 id="solution2"><a href="#solution2" class="headerlink" title="solution2"></a>solution2</h4><ul>
<li>使用常数替代 $h_i$</li>
</ul>
<img src="10/image-20220418221821541.png" style="zoom:80%;" />

<h3 id="压强"><a href="#压强" class="headerlink" title="压强"></a>压强</h3><p>$$<br>P_i&#x3D;\rho gh_i<br>$$</p>
<ul>
<li>替换 $p_i$</li>
</ul>
<img src="10/image-20220418222008762.png" style="zoom:80%;" />



<h3 id="Viscosity"><a href="#Viscosity" class="headerlink" title="Viscosity"></a>Viscosity</h3><ul>
<li>流体中的阻尼：粘滞</li>
<li>类似于阻尼控制动量的变化 $v_i(t_0)-v_i(t_0-\Delta t)$</li>
</ul>
<img src="10/image-20220418222211835.png" style="zoom:80%;" />



<h3 id="整体算法"><a href="#整体算法" class="headerlink" title="整体算法"></a>整体算法</h3><img src="10/image-20220418222433481.png" style="zoom:80%;" />



<h2 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h2><h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><ul>
<li>Dirichlet boundary<ul>
<li>模拟范围外的高度都为一个常数（<strong>空气墙</strong>）</li>
<li>一般用于模拟开放的水面（很大的海面）</li>
</ul>
</li>
<li>Neumann boundary<ul>
<li>边界上的一阶导数为 0，边界没有流体交换（<strong>实体墙</strong>）<ul>
<li>无限高的边界，水出不来</li>
</ul>
</li>
<li>一般用于模拟小的水面</li>
</ul>
</li>
</ul>
<h4 id="neumann-boundary-算法"><a href="#neumann-boundary-算法" class="headerlink" title="neumann boundary 算法"></a>neumann boundary 算法</h4><img src="10/image-20220418223206575.png" style="zoom:80%;" />



<h4 id="3D"><a href="#3D" class="headerlink" title="3D"></a>3D</h4><img src="10/image-20220418223445620.png" style="zoom:80%;" />



<h3 id="Two-Way-Coupling"><a href="#Two-Way-Coupling" class="headerlink" title="Two-Way Coupling"></a>Two-Way Coupling</h3><ul>
<li>如何处理流体和其他物体的交互？<ul>
<li>流体与刚体、流体与气泡</li>
</ul>
</li>
<li>Two-Way Coupling：影响是相互的<ul>
<li>液体对小方块有浮力</li>
<li>小方块会把水排出去</li>
</ul>
</li>
</ul>
<img src="10/image-20220418223722975.png" style="zoom:80%;" />



<h4 id="方块对流体"><a href="#方块对流体" class="headerlink" title="方块对流体"></a>方块对流体</h4><ul>
<li>关键问题：计算排水</li>
</ul>
<img src="10/image-20220418223847963.png" style="zoom:80%;" />

<ul>
<li>如何排水？<ul>
<li>直接加到周围邻居的格子（当小方块占据空间很大时，不容易计算周围格子）</li>
<li>添加虚拟高度（因为我们就是利用高度查进行水面模拟的）</li>
</ul>
</li>
</ul>
<img src="10/image-20220418224115486.png" style="zoom:80%;" />

<ul>
<li>虚拟高度如何确定？如何计算虚拟高度使其排出定量的水？<ul>
<li>$h_i^{\text{real_new}}&#x3D;h_i-e_i$</li>
<li>$e_i$：排水的高度（灰色部分）</li>
<li>$v_i$：增加的虚拟高度（绿色部分）</li>
<li>$h_i^{new}$：不添加虚拟高度模拟得到的结果</li>
</ul>
</li>
</ul>
<img src="10/image-20220418224357672.png" style="zoom:80%;" />

<ul>
<li>求解 $v_i,v_{i+1}$</li>
</ul>
<img src="10/image-20220418224943684.png" style="zoom:80%;" />

<ul>
<li>我们允许拖动小方块，因此需要排水的位置 $i$ 会变化，使用如下统一形式描述</li>
</ul>
<img src="10/image-20220418225304050.png" style="zoom:80%;" />

<ul>
<li>设置需要排水的位置的 $b_i$，添加需要排水位置的 mask&#x2F;tag</li>
<li>作业中使用共轭梯度法（PCG_Solver）求解</li>
<li>算法</li>
</ul>
<img src="10/image-20220418225557325.png" style="zoom:80%;" />

<ul>
<li>添加一个系数 $\gamma$<ul>
<li>当我们快速拖动小方块的时候，会发现水浪特别大</li>
<li>因为我们使用显示积分的方式计算，具有不稳定性</li>
<li>添加系数不是物理正确的，但是能够让模拟<strong>看上去稳定</strong></li>
</ul>
</li>
</ul>
<h4 id="流体对方块"><a href="#流体对方块" class="headerlink" title="流体对方块"></a>流体对方块</h4><ul>
<li>阿基米德定律：$F_{浮力}&#x3D;\rho gV_{排}$</li>
</ul>
<img src="10/image-20220418230306099.png" style="zoom:80%;" />

<ul>
<li>需要考虑不同小格子对小方块的力，考虑这些力对方块的作用<ul>
<li>移动、旋转（力矩）</li>
</ul>
</li>
<li>旋转的准确模拟可能需要使用<strong>隐式积分</strong>的方式<ul>
<li>高度场的隐式积分是可以做的</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/18/CG/WHM-GAMES103/10/" data-id="cl9lj749p007w64tz2b6c36ab" data-title="GAMES103.王华民.10.Surface Waves" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WHM/" rel="tag">WHM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/WHM-GAMES103/09-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/17/CG/WHM-GAMES103/09-1/" class="article-date">
  <time class="dt-published" datetime="2022-04-17T06:22:15.000Z" itemprop="datePublished">2022-04-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES103/">CG.GAMES103</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/17/CG/WHM-GAMES103/09-1/">GAMES103.王华民.09.Collision Handling(1)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili 课程链接</a></li>
</ul>
<h1 id="碰撞响应"><a href="#碰撞响应" class="headerlink" title="碰撞响应"></a>碰撞响应</h1><ul>
<li>检测到有碰撞之后如何处理？</li>
</ul>
<h1 id="CCD"><a href="#CCD" class="headerlink" title="CCD"></a>CCD</h1><ul>
<li>我们想要在当前时刻将所有的状态都更新为没有碰撞的状态</li>
</ul>
<h2 id="两种处理方法"><a href="#两种处理方法" class="headerlink" title="两种处理方法"></a>两种处理方法</h2><p><img src="/09-1/image-20220417142652017.png"></p>
<ul>
<li>当前时刻 $\mathbf{x}^{[0]}$ 不相交，模拟出来得到的下一时刻 $\mathbf{x}^{[1]}$ 是相交的</li>
<li>我们的目标：把 $\mathbf{x}^{[1]}$ 优化到不相交的地方 $\bar{\mathbf{x}}^{[0]}$<ul>
<li>内点法：从 $\mathbf{x}^{[0]}$ 出发，找到距离目标 $\mathbf{x}^{[1]}$ 最近的优化点<ul>
<li>整个查找过程中的点都保证是在安全区域内的</li>
</ul>
</li>
<li>Impact Zone Optimization：从 $\mathbf{x}^{[1]}$ 出发，是的最终回到安全区域内<ul>
<li>过程中的点是不安全的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><ul>
<li>内点法(Interior Point Methods)<ul>
<li>计算的慢<ul>
<li>一开始距离目标结果远</li>
<li>需要处理所有的顶点</li>
<li>小步长模拟</li>
</ul>
</li>
<li>永远都可以找到正确结果<ul>
<li>过程中的点都是安全的</li>
<li>可以找到一个可以接受的解，即使没有计算到收敛</li>
</ul>
</li>
</ul>
</li>
<li>Impact Zone Optimization<ul>
<li>计算的很快<ul>
<li>距离目标结果近</li>
<li>只需要处理部分点（碰撞的点占少数）</li>
<li>可以使用大步长</li>
</ul>
</li>
<li>不一定能够成功</li>
</ul>
</li>
</ul>
<h2 id="Interior-Point-Methods"><a href="#Interior-Point-Methods" class="headerlink" title="Interior Point Methods"></a>Interior Point Methods</h2><h3 id="Log-Barrier-Interior-Point-Methods"><a href="#Log-Barrier-Interior-Point-Methods" class="headerlink" title="Log-Barrier Interior Point Methods"></a>Log-Barrier Interior Point Methods</h3><ul>
<li>定义一个基于 log 的距离函数的能量<ul>
<li>距离为 0 的时候，力是无穷大的<ul>
<li>黄线表示截断，限制力的作用范围</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="09-1/image-20220417144205982.png" style="zoom:80%;" />

<ul>
<li>实现：定义一个优化的目标函数，优化它即可<ul>
<li>具体的优化方法，可以选择其他的方法（不一定是得梯度下降法）</li>
</ul>
</li>
</ul>
<img src="09-1/image-20220417144625122.png" style="zoom:80%;" />

<ul>
<li>步长 $\alpha$，需要保证没有碰撞发生<ul>
<li>需要碰撞检测</li>
</ul>
</li>
</ul>
<h2 id="Impact-Zone-Optimization-skip"><a href="#Impact-Zone-Optimization-skip" class="headerlink" title="Impact Zone Optimization(skip)"></a>Impact Zone Optimization(skip)</h2><ul>
<li>基于约束的优化</li>
<li>试图去将当前点更新到碰撞安全的区域（collision-free zone）<ul>
<li>可能会因为 tunneling issue 出现问题，但是不常见</li>
</ul>
</li>
<li>优化目标：到 $\mathbf{x}^{[1]}$ 距离最小</li>
<li>约束条件：不相交<ul>
<li>约束一：点在平面上方</li>
<li>约束二：一条边在另一条边上方，$\mathbf{N}$ 对应另一条边的法线</li>
</ul>
</li>
</ul>
<img src="09-1/image-20220417164630241.png" style="zoom:80%;" />

<ul>
<li>利用上面的约束条件一步步更新位置<ul>
<li>使用迭代方法更新：Jacobi &#x2F; Gauss-Seidel</li>
</ul>
</li>
</ul>
<img src="09-1/image-20220417171255629.png" style="zoom:80%;" />



<h3 id="Augmented-Lagrangian"><a href="#Augmented-Lagrangian" class="headerlink" title="Augmented Lagrangian"></a>Augmented Lagrangian</h3><ul>
<li>拉格朗日法<ul>
<li>Tang et al. 2018. <em>I-Cloth: Incremental Collision Handling for GPU-Based Interactive Cloth Simulation</em>. TOG. (SIGGRAPH Asia)</li>
<li><a target="_blank" rel="noopener" href="https://min-tang.github.io/home/ICloth/">主页</a></li>
</ul>
</li>
</ul>
<img src="09-1/image-20220417171525199.png" style="zoom:80%;" />

<ul>
<li>评价</li>
</ul>
<img src="09-1/image-20220417171627076.png" style="zoom:80%;" />

<ul>
<li>小步长促进收敛</li>
</ul>
<img src="09-1/image-20220417171729308.png" style="zoom:80%;" />





<h2 id="Rigid-Impact-Zone"><a href="#Rigid-Impact-Zone" class="headerlink" title="Rigid Impact Zone"></a>Rigid Impact Zone</h2><ul>
<li>经过前面的碰撞处理之后，发现还是有碰撞，那么就不处理<ul>
<li>不处理：保持和上一帧一样</li>
</ul>
</li>
<li>把整个区域当作刚体</li>
<li>很简单、很安全，但是会有可见的 artifacts</li>
<li>问题很多：现在的论文用的少</li>
</ul>
<h2 id="一个思路"><a href="#一个思路" class="headerlink" title="一个思路"></a>一个思路</h2><ul>
<li>先使用 Impace Zone Optimization，因为很快</li>
<li>如果解决不了，要么尝试内点法，要么就什么都不做</li>
</ul>
<img src="09-1/image-20220417145524092.png" style="zoom:80%;" />



<h1 id="DCD"><a href="#DCD" class="headerlink" title="DCD"></a>DCD</h1><ul>
<li>不关心碰撞，只是看相交</li>
<li>允许处理完后，在这一帧中还有相交存在，希望接下来几帧能够解决</li>
</ul>
<h2 id="Intersection-Elimination"><a href="#Intersection-Elimination" class="headerlink" title="Intersection  Elimination"></a>Intersection  Elimination</h2><ul>
<li>相交解除</li>
</ul>
<img src="09-1/image-20220417150205044.png" style="zoom:80%;" />

<ul>
<li>思路<ul>
<li>如果这一帧出现了相交，则试图去解除相交<ul>
<li>如果解除了，那么就完成了</li>
<li>如果解除不了，下一帧继续</li>
</ul>
</li>
</ul>
</li>
<li>前面的碰撞处理都失败了，这也可以作为一个后续方案</li>
<li>如果有一个是有体积的，则比较简单，将物体推到有体积的物体外部即可（可以定义一个 SDF 实现）<ul>
<li>例如：volume-volume，cloth-volume</li>
<li>示意图</li>
</ul>
</li>
</ul>
<img src="09-1/image-20220417150259259.png" style="zoom:80%;" />

<ul>
<li>布料的相交就没有办法使用上面的方法<ul>
<li>不是封闭曲面，无法定义 SDF</li>
<li>布料没有内外的概念</li>
</ul>
</li>
</ul>
<h2 id="Untangling-Cloth"><a href="#Untangling-Cloth" class="headerlink" title="Untangling Cloth"></a>Untangling Cloth</h2><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><ul>
<li>Baraff et al. 2003. Untangling Cloth. TOG (SIGGRAPH)</li>
<li>利用相交将布料分段，认为小的那一段时产生相交的区域，将其拉回来</li>
</ul>
<img src="09-1/image-20220417161347464.png" style="zoom:80%;" />

<ul>
<li>相交解除</li>
</ul>
<img src="09-1/image-20220417161421527.png" style="zoom:80%;" />

<ul>
<li>效果（2D 就是面积）</li>
</ul>
<img src="09-1/image-20220417161539666.png" style="zoom:80%;" />

<ul>
<li>问题<ul>
<li>对边界的处理不是很好</li>
<li>不容易在 GPU 上实现，分块的时候需要对整个面进行评估</li>
</ul>
</li>
</ul>
<h3 id="缩小相交曲线长度"><a href="#缩小相交曲线长度" class="headerlink" title="缩小相交曲线长度"></a>缩小相交曲线长度</h3><ul>
<li>论文<ul>
<li>Volino and Magnenat-Thalmann et al. 2006. <em>Resolving Surface Collisions through Intersection Contour Minimization. TOG (SIGGRAPH)</em>.</li>
</ul>
</li>
<li>思路<ul>
<li>两块布料相交的时候会形成一块区域，论文试图去减小围城这块区域的曲线的长度（周长）</li>
</ul>
</li>
</ul>
<img src="09-1/image-20220417163908319.png" style="zoom:80%;" />

<ul>
<li>GPU 友好</li>
<li>可以处理边界（但是不是都处理得很好）</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>处理摩擦<ul>
<li>一种方法是简单的先处理完碰撞，然后再处理摩擦，精度低，速度快</li>
<li>碰撞和摩擦一起处理，处理复杂</li>
</ul>
</li>
<li>刚体、不可形变的、有体积的物体的碰撞处理简单很多</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/17/CG/WHM-GAMES103/09-1/" data-id="cl9lj749p007o64tzc5dl4t0j" data-title="GAMES103.王华民.09.Collision Handling(1)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WHM/" rel="tag">WHM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/WHM-GAMES103/09" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/12/CG/WHM-GAMES103/09/" class="article-date">
  <time class="dt-published" datetime="2022-04-12T14:38:45.000Z" itemprop="datePublished">2022-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES103/">CG.GAMES103</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/12/CG/WHM-GAMES103/09/">GAMES103.王华民.09.Collision Handling</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili 课程链接</a></li>
</ul>
<h1 id="碰撞处理"><a href="#碰撞处理" class="headerlink" title="碰撞处理"></a>碰撞处理</h1><ul>
<li>理论不复杂，但是实际工程写起来不简单</li>
<li>衣服布料的碰撞处理是最复杂的</li>
<li>流程：<strong>碰撞检测</strong> $\to$ <strong>碰撞响应</strong></li>
<li><em>collision handling</em> &#x3D; <em>collision detection</em> + <em>collision response</em></li>
</ul>
<h1 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h1><ul>
<li>collision detection</li>
<li>笔记中的三角形只是一个代称，也可以是其他的几何原体、物体</li>
</ul>
<h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><ul>
<li>碰撞检测的 pipeline</li>
</ul>
<img src="09/image-20220412225604349.png" style="zoom:80%;" />

<ul>
<li>不可能两两的对所有的三角形做碰撞检测，复杂度太高了<ul>
<li>$O(n^2)$</li>
</ul>
</li>
<li>因此需要分成两个部分<ul>
<li>第一部分：Broad-Phase Collision Culling<ul>
<li>去除完全不可能产生碰撞的三角形对</li>
</ul>
</li>
<li>第二部分：Narrow-Phase Collision Test<ul>
<li>对候选的三角形对进行碰撞检测</li>
</ul>
</li>
</ul>
</li>
<li>碰撞检测结束之后，进一步处理碰撞</li>
<li>Collision Culling 的两种基本套路<ul>
<li>Spatial Hashing（空间划分）</li>
<li>BVH（层次包围盒）</li>
</ul>
</li>
</ul>
<h2 id="Collision-Culling"><a href="#Collision-Culling" class="headerlink" title="Collision Culling"></a>Collision Culling</h2><h3 id="Spatial-Hashing"><a href="#Spatial-Hashing" class="headerlink" title="Spatial Hashing"></a>Spatial Hashing</h3><ul>
<li>Spatial Partitioning</li>
<li>空间划分</li>
<li>将世界划分为格子，然后把三角形存到格子中<ul>
<li>如果三角形和这个格子有相交，则将其存入</li>
</ul>
</li>
<li>例子</li>
</ul>
<img src="09/image-20220412230413131.png" style="zoom:80%;" />

<ul>
<li>此时可能产生碰撞的三角形对，一定存储相同的格子中<ul>
<li>例如上面可能和 $t_3$ 产生碰撞的三角形只有 $t_0,t_5$</li>
</ul>
</li>
<li>如果三角形是在运动的话，将整个运动轨迹作为一个物体，如果格子和这个运动轨迹相交，则将其存入格子</li>
</ul>
<img src="09/image-20220412230848250.png" style="zoom:80%;" />

<ul>
<li>实际操作可以在空间划分中做层次扩展<ul>
<li>例如八叉树（Octree）</li>
</ul>
</li>
<li>问题：内存浪费严重<ul>
<li>划分的格子可能很多</li>
<li>每一个格子中保存的三角形数目不确定<ul>
<li>可能有少量格子中有大量三角形</li>
<li>绝大部分格子中都是空的</li>
</ul>
</li>
</ul>
</li>
<li>可以不事先分配内存，而是以三角形为基础建立（object-cell list）<ul>
<li>先列出三角形所在的格子，形成 pair（$t_i,\text{position}$），然后排序<ul>
<li>根据相同的格子 id 中找出可能产生碰撞的三角形对</li>
</ul>
</li>
<li>占用内存较小，和三角形的数目相当</li>
</ul>
</li>
</ul>
<img src="09/image-20220412234352198.png" style="zoom:80%;" />



<h4 id="Morton-Code"><a href="#Morton-Code" class="headerlink" title="Morton Code"></a>Morton Code</h4><ul>
<li>如何定义格子的 id</li>
<li>因为 cache 的存在，我们希望内存访问是相对连续的</li>
<li>morton code<ul>
<li>目的就是让两次内存访问的地址更加接近，更好的利用缓存的局部性（locality）</li>
</ul>
</li>
<li>以 <code>Z</code> 字形为基础，不断细分</li>
</ul>
<img src="09/image-20220412234804962.png" style="zoom:80%;" />

<ul>
<li>拼接 <code>XY</code> 轴，按照拼接形成的数字大小排序，形成一个顺序</li>
</ul>
<p><img src="/09/Z-curve.svg"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-32-broad-phase-collision-detection-cuda">cuda 上面的基于空间划分的碰撞检测</a></li>
</ul>
<h3 id="BVH"><a href="#BVH" class="headerlink" title="BVH"></a>BVH</h3><ul>
<li>Bounding Volume Hierarchy</li>
<li>根据物体的拓扑结构，对物体进行层次划分</li>
</ul>
<p><img src="/09/image-20220412235719846.png"></p>
<ul>
<li>使用包围盒的目的<ul>
<li>优化碰撞检测，如果包围盒都不相交，那么包围盒中的物体也不会相交</li>
</ul>
</li>
</ul>
<h4 id="包围盒类型"><a href="#包围盒类型" class="headerlink" title="包围盒类型"></a>包围盒类型</h4><ul>
<li>AABB：axis-aligned bounding box<ul>
<li>AABB 相交当且仅当每一个轴上都相交</li>
</ul>
</li>
<li>OBB：oriented bounding box</li>
<li>sphere</li>
</ul>
<h4 id="碰撞检测-1"><a href="#碰撞检测-1" class="headerlink" title="碰撞检测"></a>碰撞检测</h4><ul>
<li>物体和 BVH 的碰撞检测流程<ul>
<li>和根节点进行碰撞检测<ul>
<li>如果有碰撞，递归的对子结点进行碰撞检测</li>
<li>如果没有碰撞，则没有碰撞</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="09/image-20220417132144418.png" style="zoom:80%;" />



<h4 id="自相交的碰撞检测"><a href="#自相交的碰撞检测" class="headerlink" title="自相交的碰撞检测"></a>自相交的碰撞检测</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 A 为根节点的子树内部相交</span></span><br><span class="line"><span class="built_in">Process_Node</span>(A) &#123;</span><br><span class="line">    For every A’s child: <span class="function">B</span></span><br><span class="line"><span class="function">        <span class="title">Process_Node</span><span class="params">(B)</span></span>;</span><br><span class="line">    For every A’s children pair &lt;B, C&gt;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> B <span class="keyword">and</span> C intersect</span></span><br><span class="line"><span class="function">            <span class="title">Process_Pair</span><span class="params">(B, C)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 B,C 为根节点的子树之间相交</span></span><br><span class="line"><span class="built_in">Process_Pair</span>(B, C) &#123;</span><br><span class="line">    For every B’s child: B’</span><br><span class="line">        For every C’s child: C’</span><br><span class="line">            <span class="keyword">if</span> B’ <span class="keyword">and</span> C’ <span class="function">intersect</span></span><br><span class="line"><span class="function">                <span class="title">Process_Pair</span><span class="params">(B’, C’)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ul>
<li>虽然能够很快的提出远处不相交的物体，但是对周围的物体（靠的比较近）很难剔除</li>
<li>基于能量（形变）的碰撞检测<ul>
<li>Zheng and James. 2012. <em>Energy-based Self-Collision Culling for Arbitrary Mesh Deformations</em>. TOG (SIGGRAPH)</li>
</ul>
</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul>
<li>SH（Spatial Hashing）<ul>
<li>很容易实现</li>
<li>GPU 友好</li>
<li>当物体移动的时候需要重新计算</li>
</ul>
</li>
<li>BVH<ul>
<li>实现复杂</li>
<li>GPU 不友好（对树结构不太友好）</li>
<li>更新起来比较简单（只需要更新 BV）</li>
</ul>
</li>
</ul>
<h2 id="Collision-Test"><a href="#Collision-Test" class="headerlink" title="Collision Test"></a>Collision Test</h2><img src="09/image-20220417133958489.png" style="zoom:80%;" />

<ul>
<li>DCD：Discrete Collision Detection<ul>
<li>离散碰撞检测</li>
<li>基本检测单位为 <code>edge-triangles</code> 对</li>
</ul>
</li>
<li>CCD：Continuous Collision Detection<ul>
<li>连续碰撞检测</li>
<li>基本检测单位为 <code>vertex-triangle</code> 对和 <code>edge-edge</code> 对</li>
</ul>
</li>
</ul>
<h3 id="DCD"><a href="#DCD" class="headerlink" title="DCD"></a>DCD</h3><ul>
<li>在每一个离散的时刻上检测是否存在碰撞<ul>
<li>DCD tests if any intersection exists in each state at discrete time instant: $\mathbf{x}^{[0]},\mathbf{x}^{[1]},\cdots$</li>
</ul>
</li>
<li>基本检测：边——三角形<ul>
<li>检测边和三角形是否相交</li>
<li>线段 $\mathbf{x}<em>{a}\mathbf{x}</em>{b}$ 上任意一点可以表示为 $(1-t)\mathbf{x}<em>{a}+t\mathbf{x}</em>{b},t\in[0,1]$</li>
</ul>
</li>
</ul>
<img src="09/image-20220417134507721.png" style="zoom:80%;" />



<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li>问题：两个相邻的时刻 $\mathbf{x}^{[0]},\mathbf{x}^{[1]}$ 都不相交，但是实际上在这两个时刻之间发生了相交</li>
<li>上面这种情况的碰撞通过 DCD 检测不出来</li>
<li>示例：绿色三角形向下移动、蓝色三角形向上移动</li>
</ul>
<img src="09/image-20220417135546324.png" style="zoom:80%;" />

<ul>
<li>优点：高效、简单、稳定</li>
<li>问题：<ul>
<li>tunneling effects：隧穿效应</li>
<li>运动太快会出现这种问题<ul>
<li>尤其是比较小、比较薄的物体，例如布料穿墙</li>
</ul>
</li>
<li>解决：要求物体运动的不能太快、减小时间步长</li>
</ul>
</li>
</ul>
<h3 id="CCD"><a href="#CCD" class="headerlink" title="CCD"></a>CCD</h3><ul>
<li>检测任意的两个离散状态之间有没有相交（真正的碰撞检测）<ul>
<li>CCD tests if any intersection exists between two states: $\mathbf{x}^{[0]}$ and $\mathbf{x}^{[1]}$</li>
</ul>
</li>
<li>基本检测：点——三角形检测、边——边检测</li>
<li>点——三角形检测：<strong>四点共面检测</strong><ul>
<li>比 DCD 复杂，第一步需要求解一个一元三次方程<ul>
<li>求解尽量不要用求根公式，而使用<strong>二分法</strong>&#x2F;牛顿法等数值方法</li>
<li>求根公式中的 $x^{1&#x2F;3}$ 一项误差很大</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="09/image-20220417140128294.png" style="zoom:80%;" />

<ul>
<li>边——边检测<ul>
<li>先检测是否共面，在检测是否在内部相交</li>
</ul>
</li>
</ul>
<img src="09/image-20220417140731014.png" style="zoom:80%;" />

<ul>
<li>只做<strong>点——三角形</strong>检测不行<ul>
<li>六芒星：红色向屏幕内移动、蓝色向屏幕外移动</li>
</ul>
</li>
</ul>
<img src="09/image-20220417141446762.png" style="zoom:80%;" />



<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ul>
<li>实现相对困难</li>
<li>计算复杂度比 DCD 要大<ul>
<li>有些观点：瓶颈在 collision culling 部分</li>
</ul>
</li>
<li>浮点精度的问题，计算误差大<ul>
<li>可以使用 epsilon，放宽限制 $t\in[-\epsilon,1+\epsilon]$<ul>
<li>可能会导致 false positive</li>
</ul>
</li>
<li>游戏的 GPU 以单精度浮点数 float 为主</li>
</ul>
</li>
</ul>
<h3 id="课后阅读"><a href="#课后阅读" class="headerlink" title="课后阅读"></a>课后阅读</h3><ul>
<li>Bridson et al. 2002. <em>Robust Treatment of Collisions, Contact and Friction for Cloth Animation. TOG (SIGGRAPH)</em>.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/12/CG/WHM-GAMES103/09/" data-id="cl9lj749p007t64tz6haw88va" data-title="GAMES103.王华民.09.Collision Handling" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WHM/" rel="tag">WHM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/Papers/2021/bvh-survey-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/11/CG/Papers/2021/bvh-survey-2/" class="article-date">
  <time class="dt-published" datetime="2022-04-11T04:59:13.000Z" itemprop="datePublished">2022-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/11/CG/Papers/2021/bvh-survey-2/">(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(3)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="BVH-Survey"><a href="#BVH-Survey" class="headerlink" title="BVH Survey"></a>BVH Survey</h1><ul>
<li><a href="/2022/04/06/CG/Papers/2021/bvh-survey-home/">目录</a></li>
</ul>
<h1 id="4-construct-bvh"><a href="#4-construct-bvh" class="headerlink" title="4. construct bvh"></a>4. construct bvh</h1><h2 id="4-3-Incremental-Construction"><a href="#4-3-Incremental-Construction" class="headerlink" title="4.3. Incremental Construction"></a>4.3. Incremental Construction</h2><ul>
<li>论文：Automatic Creation of Object Hierarchies for Ray Tracing</li>
<li>在插入的时候增量更新</li>
<li>初始的时候为一个人空的 BVH，当插入新物体的时候，找到一个合适的叶子节点进行插入，如果插入之后节点过大则进行分裂</li>
<li>在初始的时候不知道场景中所有物体的时候很有用<ul>
<li>e.g., streaming the data through the network</li>
</ul>
</li>
<li>质量通常不是很高</li>
<li>在另一篇论文中改进了<ul>
<li>Incremental BVH Construction for Ray Tracing<ul>
<li>以优先队列的方式选择插入场景中的原体，同时贪心的最小化每次插入的代价，结合下面这篇论文的方法，防止插入的时候达到局部最小化</li>
</ul>
</li>
<li>Fast Insertion-Based Optimization of Bounding Volume Hierarchies</li>
</ul>
</li>
</ul>
<h2 id="4-4-LBVH"><a href="#4-4-LBVH" class="headerlink" title="4.4 LBVH"></a>4.4 LBVH</h2><ul>
<li>BVH 构建上的并行不是很直观</li>
<li>归约：BVH 的构建能够被归约为对场景原体在 Morton Curve 上的排序，顺序由定长（32&#x2F;64bit）的 Morton codes 决定<ul>
<li>排序则有很多并行算法</li>
<li>定长：可以使用基数排序的方式 $O(n)$ 实现</li>
</ul>
</li>
<li>Morton curve：space-filling curve subdividing space into a uniform grid<ul>
<li>每一个小的 grid 都会被分配一个唯一的 morton 码（容易计算）</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey-2/image-20220412112634150.png"></p>
<h3 id="LBVH"><a href="#LBVH" class="headerlink" title="LBVH"></a>LBVH</h3><ul>
<li>linear BVH (LBVH)<ul>
<li>使用 Morton Curve 构建 BVH，GPU-based</li>
<li>top-down</li>
<li>每一个 level 调用一次 kernel</li>
<li>lower level 的时候使用 SAH binning 算法</li>
</ul>
</li>
<li>论文：Fast BVH Construction on GPUs</li>
<li>算法整体思路<ul>
<li>linearizing：将输入的原体转化为一个长度为 $n$ 的定长序列</li>
<li>然后我们对所有区间进行递归划分，从而构建起 BVH，每一个节点都对应一段区间<ul>
<li>root：$[0,n)$</li>
</ul>
</li>
<li>每一个 BVH 上的几点就对应 $[l_i.r_i)$ 内的原体</li>
</ul>
</li>
<li>Morton curve：<em>space filling</em> curve<ul>
<li>又被称为 Lebesgue curve &#x2F; z-order curve</li>
</ul>
</li>
<li>假设<ul>
<li>使用 AABB 包围盒</li>
<li>每个原体的包围盒都是已知的</li>
<li>整个场景的包围盒是已知的</li>
</ul>
</li>
<li>使用每个原体的重心表示这个原体</li>
<li>将整个场景的包围盒划分为 $2^k\times2^k\times2^k$ 个格子，于是每一个格子能够使用 3 个 k bit 的整数来表示</li>
<li>morton code 例子如下图所示<ul>
<li>拼接，然后构成一个顺序</li>
</ul>
</li>
</ul>
<img src="bvh-survey-2/Z-curve.svg"  />

<ul>
<li>然后根据每一个原体重心的位置为其分配一个 Morton code，根据这个码进行排序</li>
<li>按照 Morton code 进行排序得到的结果，能够让相邻的原体在空间位置上也是相邻的</li>
<li>一个例子</li>
</ul>
<p><img src="/bvh-survey-2/image-20220412144306083.png"></p>
<ul>
<li>构建 BVH<ul>
<li>从最高位开始，将为 0&#x2F;1 的原体分别划分到两棵子树内<ul>
<li>如果全部相同，则看下一位</li>
</ul>
</li>
<li>递归处理子树，直到所有位都处理完毕</li>
</ul>
</li>
<li>构造过程等价于 MSD 的 2-基数排序（most-significant-bit radix-2 sort）<ul>
<li>泛化到 most-significant-bit radix-$2^b$ sort（每次比较 $2^b$ 位），则可以构造出 $2^b$ 叉树</li>
<li>radix-8：octree</li>
</ul>
</li>
<li>并行算法<ul>
<li>先排序（并行算法），然后从排好序的序列中构建出 BVH</li>
</ul>
</li>
<li>排序<ul>
<li>排序过程中由于高位可能全 0，使用 LSD 效果更好</li>
</ul>
</li>
</ul>
<h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><ul>
<li>每一个 morton code 都表示了一个从根节点到这个原体的唯一路径，他们的包围盒就是最近的公共祖先节点<ul>
<li>例如：<code>0000,0001,0011</code> $\Longrightarrow$ <code>00</code></li>
</ul>
</li>
<li>对每一组相邻的原体 $(i,i+1)$ 做如下处理<ul>
<li>如果这两个原体，从高位到低数，第 $h$ 位开始不一样，则它们在第 $h,h+1,\cdots,3k$  层将被隔开（处于不同的 BVH）节点中，因此我们记录如下的 pair</li>
</ul>
</li>
</ul>
<p>$$<br>\Big[(i,h),(i,h+1),\cdots,(i,3k)\Big]<br>$$</p>
<ul>
<li>我们将所有的 pair 合在一起，并将它们按照第二个关键字排序，则得到了在某一层的分裂信息</li>
<li>根据这个分裂信息，进行构建</li>
<li>勾结按结果可能存在只有一个儿子的父节点，需要收缩，对每个子结点都向上收缩一遍路径</li>
</ul>
<h4 id="构建例子"><a href="#构建例子" class="headerlink" title="构建例子"></a>构建例子</h4><p><img src="/bvh-survey-2/image-20220412144306083.png"></p>
<ul>
<li>所有的 Morton code 如下</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0: 0000</span><br><span class="line">1: 0001</span><br><span class="line">2: 0011</span><br><span class="line">3: 0100</span><br><span class="line">4: 0101</span><br><span class="line">5: 0111</span><br><span class="line">6: 1100</span><br><span class="line">7: 1110</span><br></pre></td></tr></table></figure>

<ul>
<li>得到的的 pair 如下</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(0, 4)</span><br><span class="line">(1, 3), (1, 4)</span><br><span class="line">(2, 2), (2, 3), (2, 4)</span><br><span class="line">(3, 4)</span><br><span class="line">(4, 3), (4, 4)</span><br><span class="line">(5, 1), (5, 2), (5, 3), (5, 4)</span><br><span class="line">(6, 3), (6, 4)</span><br></pre></td></tr></table></figure>

<ul>
<li>排序</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(5, 1)</span><br><span class="line">(2, 2), (5, 2)</span><br><span class="line">(1, 3), (2, 3), (4, 3), (5, 3), (6, 3)</span><br><span class="line">(0, 4), (1, 4), (2, 4), (3, 4), (4, 4), (5, 4), (6, 4)</span><br></pre></td></tr></table></figure>

<ul>
<li>构建顺序的示意图如下<ul>
<li>最后一行划分为单原体的包围盒没有画出来</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey-2/image-20220412160221156.png"></p>
<h3 id="HLBVH"><a href="#HLBVH" class="headerlink" title="HLBVH"></a>HLBVH</h3><ul>
<li><p>hierarchical LBVH</p>
<ul>
<li>combine LBVH with <em>SAH sweeping</em> for the <em>upper levels</em></li>
</ul>
</li>
<li><p>将 sweeping 改进为使用 binning</p>
<ul>
<li>使用 morton code 的前缀作为 bin 的下标</li>
<li>引入和很多同步（并行不友好）</li>
</ul>
</li>
</ul>
<h3 id="加速构建1"><a href="#加速构建1" class="headerlink" title="加速构建1"></a>加速构建1</h3><ul>
<li><p>论文</p>
<ul>
<li>Maximizing Parallelism in the Construction of BVHs, Octrees, and k-d Trees</li>
</ul>
</li>
<li><p>一次 kernel 的调用便构建好整棵 BVH</p>
<ul>
<li>之前 LBVH 的构建 level 与 level 之间有相互依赖，这里消除这个依赖</li>
</ul>
</li>
<li><p>idea：内部节点和叶子节点放在两个数组里面</p>
<ul>
<li>内部节点的位置和属于该区间的某个端点原体相一致（分裂时的端点）</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey-2/image-20220412163005057.png"></p>
<ul>
<li><p>加速从排好序的原体中构建出 BVH</p>
<ul>
<li>我们知道一定会有 $n-1$ 个内部节点</li>
</ul>
</li>
<li><p>$I,L$：内部节点、叶子节点</p>
</li>
<li><p>根节点 $I_0:[0,n-1]$</p>
<ul>
<li>左子节点 $[0,\gamma]$，右子节点 $[\gamma+1,n-1]$</li>
<li>如何确定 $\gamma$ ？</li>
</ul>
</li>
<li><p>$\delta(i,j)$：表示 $k_i,k_j$ 的最长公共前缀的长度</p>
<ul>
<li>如果 $j\notin[0,n-1]$ 等于 $-1$</li>
</ul>
</li>
<li><p>算法：确定节点 $I_i$ 的左右端点（至少含有两个原体）</p>
<ul>
<li>其中一个端点是确定的，$k_i\in I_i$<ul>
<li>直观的理解，<strong>每一对相邻的节点只会被分裂一次</strong>，因此可以有这种规定</li>
</ul>
</li>
<li>确定方向，左还是右（那一边公共前缀的长度更长）<ul>
<li>不存在 $a&lt;b&lt;c$ 的公共前缀长度相同（二进制表示），否则则有 $\text{x1,x2,x3}$（$\text{x}$ 表示前缀）</li>
</ul>
</li>
<li>$I_i$ 内部的最长公共前缀一定要大于 $\delta(k_i,k_{i-d})$，否则不是分裂点<ul>
<li>根据这个性质去找另外一个端点</li>
</ul>
</li>
<li>找端点，找端点只是为了更新 $\delta_{node}$ 的值<ul>
<li>6-8 行，先确定另外一个端点的最大返回<ul>
<li>倍增尝试</li>
</ul>
</li>
<li>10-14 行，找到端点之后，使用二分进行结果的查找<ul>
<li>原理：$\delta(a,b)\ge\delta(a,c),a&lt;b&lt;c$</li>
</ul>
</li>
</ul>
</li>
<li>接下来确定分裂点（左右子节点）<ul>
<li>二分查找（分裂点左右两段内部的 $\delta&gt;\delta_{node}$）</li>
</ul>
</li>
</ul>
</li>
<li><p>结果图</p>
</li>
</ul>
<p><img src="/bvh-survey-2/image-20220412164651792.png"></p>
<ul>
<li>伪代码如下</li>
</ul>
<p><img src="/bvh-survey-2/image-20220412164248380.png"></p>
<ul>
<li><a href="/utils/show_code/index.html?CG/Paper/2021/bvh-survey/LBVH-one-kernel-lauch.cpp">c++ 代码</a></li>
<li>这里的问题是，这个 pass 只是构建好了 BVH 的拓扑结构，实际上 BVH 中 AABB 包围盒的计算并没有算出来</li>
<li>计算 AABB 包围盒<ul>
<li>每一个叶子节点一个线程，从叶子节点出发向根节点移动计算 AABB 包围盒</li>
<li>使用全局的原子计数，记录到达每一个内部节点的线程数，当下一个线程处理到这个节点时，前一个处理过这个节点的线程马上终止</li>
<li>每一个节点只会被一个线程同时处理，时间复杂度是 $O(n)$ 的，<strong>同步问题</strong></li>
</ul>
</li>
</ul>
<h3 id="加速构建2"><a href="#加速构建2" class="headerlink" title="加速构建2"></a>加速构建2</h3><ul>
<li>论文<ul>
<li>Fast and Simple Agglomerative LBVH Construction</li>
</ul>
</li>
<li>在加速构建1的基础上进行优化</li>
<li>一次 kernel 调用便同时构建好拓扑结构和 AABB 包围盒<ul>
<li>必须是 <strong>bottom-up fashion</strong></li>
</ul>
</li>
<li>使用了另外一种分布方式</li>
</ul>
<p><img src="/bvh-survey-2/image-20220413160043840.png"></p>
<ul>
<li>如果某一个节点覆盖了范围 $[a,b]$ 之间的 keys，那么下标为 $a-1,b$ 的两个节点都是当前节点的祖先节点，其中有一个为当前节点的父节点</li>
<li>定义函数 $\delta(i)$，表示内部节点 $i$ 覆盖的 keys 的最不同位的下标<ul>
<li>例如节点 $i$ 包含的 keys 为 <code>0010,0011,0100,0101</code>，$\delta(i)&#x3D;2$</li>
<li>于是如果 x 节点是 y 节点的祖先节点的话，就有 $\delta(x)&gt;\delta(y)$<ul>
<li>根据这个性质，我们可以判断 $\delta(a-1),\delta(b)$ 的大小关系，来选择父节点</li>
</ul>
</li>
<li>实际实现可以使用两端点的 key 异或实现（偏序关系是一致的）</li>
</ul>
</li>
<li>如何计算 $\delta(i)$<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/shinjiogaki/bvh/blob/master/bvh_binary.cpp">一个实现</a></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delta function in sec3 of the paper</span></span><br><span class="line"><span class="comment">// &quot;Fast and Simple Agglomerative LBVH Construction&quot;</span></span><br><span class="line"><span class="function">__forceinline <span class="type">uint32_t</span> <span class="title">Delta</span><span class="params">(<span class="type">const</span> std::vector&lt;glm::uvec3&gt; &amp;leaves, <span class="type">const</span> <span class="type">uint32_t</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> leaves[id + <span class="number">1</span>].z ^ leaves[id].z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么可以这么做呢？<ul>
<li>上面的红线其实就表示了这两个节点在哪一层会被连接</li>
<li>$i$ 号内部节点一定包含叶子节点 $i$</li>
<li>因此这就成了判断：是 $i$ 号节点会先被加进来合并还是 $j$ 号节点会先被加进来合并<ul>
<li>同时一个内部节点必然包含至少两个 key</li>
<li>上面的计算其实就是算出了红线的位置</li>
</ul>
</li>
</ul>
</li>
<li>可以这么理解，内部节点 $i$ 的子节点必然是 $[x,i),[i,y)$<ul>
<li>这样就可以理解上面的计算了<ul>
<li>哪边差异小，哪边就会先被连接</li>
</ul>
</li>
<li>这么理解的话，内部节点的标号也就是肯定的了（不会有冲突），因为每一个相邻的位置只会被分裂一次</li>
</ul>
</li>
<li>构建包围盒的算法和<strong>加速构建1</strong>一致</li>
<li>感觉这里的优化似乎是省掉了<strong>加速构建1</strong>中的拓扑结构生成部分，把拓扑结构生成直接集成到构建包围盒中</li>
</ul>
<p><img src="/bvh-survey-2/image-20220413164630620.png"></p>
<h3 id="其他优化1"><a href="#其他优化1" class="headerlink" title="其他优化1"></a>其他优化1</h3><ul>
<li><strong>内存优化</strong>，紧凑表示，无冗余表达（指针）</li>
<li>This algorithm is the fastest construction algorithm to date.</li>
<li>pipeline</li>
</ul>
<p><img src="/bvh-survey-2/image-20220414113910521.png"></p>
<ul>
<li>ostensibly-implicit layout<ul>
<li>能够快速检测得到二叉树中的缺失部分，能让排布更紧凑</li>
<li>只需要保存包围盒的信息，其他信息都能够推断出来（不需要保存）</li>
</ul>
</li>
</ul>
<h4 id="ostensibly-implicit-layout"><a href="#ostensibly-implicit-layout" class="headerlink" title="ostensibly-implicit layout"></a>ostensibly-implicit layout</h4><p><img src="/bvh-survey-2/image-20220414114539385.png"></p>
<ul>
<li>数据结构<ul>
<li>完全二叉树：需要引入虚拟节点</li>
<li>堆结构：需要预处理，需要存储指针数据</li>
<li>ostensibly-implicit layout：不需要存储指针（多余的数据），同时不需要预处理</li>
</ul>
</li>
<li>idea：构造一棵隐式的完全二叉树，把虚拟节点都放在<strong>最右边</strong>，然后编码一系列的小的完全二叉树</li>
<li>物体个数为 $t$</li>
<li><strong>最深的一层</strong>需要引入的虚拟节点的个数 $L_v&#x3D;2^{\lceil \log_2t\rceil}-t$</li>
<li><strong>最深的一层</strong>总共的叶子结点数 $L_c&#x3D;t+L_v&#x3D;2^{\lceil \log_2t\rceil}$</li>
<li>因此树上总结点数 $N_c&#x3D;2L_c-1$</li>
<li>$N_c&#x3D;N_r+N_v$<ul>
<li>$N_v$：virtual node（树上的虚拟节点总数）</li>
<li>$N_r$：real node（树上真实的节点的总数）</li>
</ul>
</li>
<li>$L_v$ 可以表示成 2 的幂次方的和，定义如下集合<ul>
<li>$N$ 应该和二进制表示中 $1$ 的个数相等</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey-2/image-20220414133504567.png"></p>
<p><img src="/bvh-survey-2/image-20220414133521419.png"></p>
<ul>
<li>$N_v$ 和 $L_v$ 有如下关系<ul>
<li>叶子数为 $x_k&#x3D;2^{y_k}$ 构成的完全二叉树的总结点数为 $2x_k-1$</li>
<li>参考上图中的紫色部分，从右往左<ul>
<li>4（27,28,29,30）向上形成一棵完全二叉树</li>
<li>1（26）又向上形成一棵完全二叉树</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey-2/image-20220414140957300.png"></p>
<ul>
<li>$count_set\underline_bits(X)$ 表示计数 $X$ 的二进制表示中 $1$ 的个数</li>
<li>上面的式子 (5) 表示如下</li>
</ul>
<p>$$<br>N_v&#x3D;2L_v-count_set_bits(L_v)<br>$$</p>
<ul>
<li>更新</li>
</ul>
<p>$$<br>\begin{aligned}<br>N_r<br>&amp;&#x3D;N_c-N_v\<br>&amp;&#x3D;(2L_c-1)-(2L_v-count_set_bits(L_v))\<br>&amp;&#x3D;2t-1-count_set_bits(L_v)<br>\end{aligned}<br>$$</p>
<h4 id="建立映射"><a href="#建立映射" class="headerlink" title="建立映射"></a>建立映射</h4><ul>
<li>一个真实的节点，假设它对应的虚拟节点下标为 $i$</li>
<li>虚拟节点深度 $l_i&#x3D;\log_2(i+1)$，$0\le l_i\le \bar{l}&#x3D;\lceil{\log_2t}\rceil$</li>
<li>位于深度 $l$ 的虚拟节点个数如下</li>
</ul>
<p>$$<br>L_{vl}&#x3D;\left\lfloor{\dfrac{L_v}{2^{\bar{l}-l}}}\right\rfloor&#x3D;L_v\gg(\bar{l}-l)<br>$$</p>
<ul>
<li>因此这个节点在内存中的位置 $i_m$</li>
</ul>
<p><img src="/bvh-survey-2/image-20220414144444748.png"></p>
<ul>
<li>$N_{vl}$ 的计算如上面提到的一样</li>
</ul>
<p>$$<br>N_{vl}&#x3D;2L_{vl}-count_set_bits(L_{vl})<br>$$</p>
<h4 id="建立-BVH-算法"><a href="#建立-BVH-算法" class="headerlink" title="建立 BVH 算法"></a>建立 BVH 算法</h4><ul>
<li><p>我们获取到的是按照 Morton code 排序之后的原体序列</p>
</li>
<li><p>内部节点和叶子节点分开存储</p>
<ul>
<li>叶子节点的包围盒可以提前知道，之前已经算出来了</li>
</ul>
</li>
<li><p>[3] tNode：上面提到的 $j$</p>
<ul>
<li>需要通过上面 $eq(9)$ 的计算，得到真实的内存地址</li>
</ul>
</li>
<li><p>[23,24] 为了同步，第一个到达当前结点的线程不操作（和之前的优化方法类似）</p>
</li>
</ul>
<p><img src="/bvh-survey-2/image-20220414144306542.png"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Arieys/MonteCarloPathTracing/blob/main/MTPC/BVH.cpp">一个别人代码的实现</a></li>
<li>评价：质量可能不是很高，但是 BVH 构建很快，而且内存占用少（指针隐式表示）</li>
</ul>
<h3 id="其他优化2"><a href="#其他优化2" class="headerlink" title="其他优化2"></a>其他优化2</h3><ul>
<li>扩展了 Morton code，同时将场景中原体的大小编码进去了，能够提升 BVH 的质量</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/11/CG/Papers/2021/bvh-survey-2/" data-id="cl9lj74bv00m964tza1779rer" data-title="(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(3)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BVH/" rel="tag">BVH</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EG/" rel="tag">EG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Paper/" rel="tag">Paper</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/occlusion/" rel="tag">occlusion</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/WX-GAMES104/03" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/10/CG/WX-GAMES104/03/" class="article-date">
  <time class="dt-published" datetime="2022-04-10T14:54:09.000Z" itemprop="datePublished">2022-04-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES104/">CG.GAMES104</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/10/CG/WX-GAMES104/03/">GAMES104.王希.03.如何构建游戏世界</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://space.bilibili.com/512313464/channel/collectiondetail?sid=292637">Bilibili 课程链接</a></li>
</ul>
<h1 id="如何构建游戏世界"><a href="#如何构建游戏世界" class="headerlink" title="如何构建游戏世界"></a>如何构建游戏世界</h1><ul>
<li>How to Build a Game World</li>
<li>游戏世界由什么组成？</li>
<li>我们如何描述这些东西？</li>
<li>这些东西是如何组织的？</li>
</ul>
<h2 id="游戏世界中的物体"><a href="#游戏世界中的物体" class="headerlink" title="游戏世界中的物体"></a>游戏世界中的物体</h2><ul>
<li>Dynamic Game Object（动态的游戏物体）<ul>
<li>移动的 NPC</li>
<li>马</li>
</ul>
</li>
<li>Static Game Object（静态物）<ul>
<li>房子</li>
<li>树木</li>
</ul>
</li>
<li>Environments<ul>
<li>天空（sky）、地形（terrain）、植被（vegetation）</li>
<li>tod：time of the day</li>
</ul>
</li>
<li>Other Game Objects<ul>
<li>空气墙（air wall）</li>
<li>检测体（trigger area）<ul>
<li>例如巫师三检测玩家走到了世界的尽头</li>
<li>例如玩家走到特定区域才会触发剧情，走到特定区域的检测使用 trigger</li>
</ul>
</li>
<li>游戏规则</li>
</ul>
</li>
<li>任何东西都是游戏物体（Game Object）</li>
<li>GO：Game Object<ul>
<li>将游戏世界中的物体都抽象成 GO</li>
</ul>
</li>
</ul>
<img src="03/image-20220410233953487.png" style="zoom:80%;" />



<h2 id="如何描述-GO"><a href="#如何描述-GO" class="headerlink" title="如何描述 GO"></a>如何描述 GO</h2><ul>
<li>属性（property） + 行为（behavior）</li>
</ul>
<img src="03/image-20220410234248032.png" style="zoom:80%;" />

<ul>
<li>继承（inheritance）</li>
</ul>
<img src="03/image-20220410234438417.png" style="zoom:80%;" />

<ul>
<li>问题：当物体变多的时候，父子关系并不明显</li>
<li><strong>组件化</strong>（component base）</li>
</ul>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><img src="03/image-20220410234637034.png" style="zoom:80%;" />

<img src="03/image-20220410234658392.png" style="zoom:80%;" />

<ul>
<li>代码<ul>
<li><code>tick()</code> 用于更新组件的状态</li>
</ul>
</li>
</ul>
<img src="03/image-20220410235613126.png" style="zoom:80%;" />

<ul>
<li>无人机组件化</li>
</ul>
<img src="03/image-20220410234957263.png" style="zoom:80%;" />

<ul>
<li>现代游戏引擎架构的理念<ul>
<li>开发者好维护、好理解</li>
<li>要符合艺术家设计师对于游戏的理解（游戏引擎是生产力工具）</li>
</ul>
</li>
<li>商业引擎也是基于组件化的设计</li>
<li>unreal<ul>
<li>这里的 UObject 更像是 java 中的 Object 集类，用于内存管理、GC 之类的（生命周期控制），和我们上面讲的 GO 还有所不同，这里的 AActor 更像是 GO</li>
</ul>
</li>
</ul>
<p><img src="/03/unreal.jpg"></p>
<ul>
<li>unity</li>
</ul>
<p><img src="/03/unity.jpg"></p>
<h2 id="如何让世界动起来"><a href="#如何让世界动起来" class="headerlink" title="如何让世界动起来"></a>如何让世界动起来</h2><h3 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h3><ul>
<li>Object-based Tick</li>
<li>每一个 GO 里面的 component 调用 <code>tick()</code> 进行更新</li>
</ul>
<img src="03/image-20220411220525108.png" style="zoom:80%;" />

<ul>
<li>但是在实际的游戏引擎里面，一般是逐系统 <code>tick()</code>，而不是逐对象 <code>tick()</code><ul>
<li>为了效率（pipeline）</li>
<li>一个系统的数据通常放在一起（cache）</li>
</ul>
</li>
</ul>
<img src="03/image-20220411220837382.png" style="zoom:80%;" />

<ul>
<li>对比</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Object-based tick</th>
<th align="center">Component-based tick</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Simple and intuitive<br />Easy to debug</td>
<td align="center">Parallelized processing<br />Reduced cache miss</td>
</tr>
</tbody></table>
<h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><ul>
<li>GO 之间的交互<ul>
<li>例如我砍了你一刀，你要受伤</li>
</ul>
</li>
<li>hardcode<ul>
<li>效率很低，新加入 GO 则需要修改大量代码</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bomb::explode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span>(go_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> GoType.human_type : &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> GoType.drone_type : &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> GoType.tank_type : &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> GoType.stone_type : &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> : &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件机制（event）<ul>
<li>GO 和 component 的解耦合</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bomb::explode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">sendExplodeEvent</span>(go_id);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>商业引擎中的 event 机制</li>
<li>unity</li>
</ul>
<img src="03/unity_event.jpg" style="zoom: 50%;" />

<ul>
<li>unreal</li>
</ul>
<img src="03/unreal_event.jpg" style="zoom: 50%;" />

<ul>
<li>游戏引擎的工作<ul>
<li>允许用户定制事件</li>
<li>允许用户在组件中对事件进行处理</li>
</ul>
</li>
</ul>
<p>总结</p>
<h2 id="如何管理-GO"><a href="#如何管理-GO" class="headerlink" title="如何管理 GO"></a>如何管理 GO</h2><ul>
<li>GO 的查询<ul>
<li>通过 GO 的唯一标识（unique game object id）</li>
<li>通过 GO 的位置</li>
</ul>
</li>
</ul>
<h3 id="场景管理"><a href="#场景管理" class="headerlink" title="场景管理"></a>场景管理</h3><ul>
<li>不管理<ul>
<li>事件发生（例如爆炸），向场景中的所有 GO 都发一遍消息（全都扫描一遍）</li>
<li>$n^2$ 的挑战，场景中每个物体都扫描一遍其他物体<ul>
<li>对于场景中物体不多的情况下，还是可行的</li>
<li>场景中 GO 增加，则带来大量的计算负担</li>
</ul>
</li>
</ul>
</li>
<li>Grid<ul>
<li>只向周围 Grid 进行发送消息</li>
<li>当 GO 在场景中分散的不均匀的时候，又慢又浪费</li>
</ul>
</li>
</ul>
<img src="03/image-20220411223454788.png" style="zoom:80%;" />

<ul>
<li>四叉树（QuadTree）<ul>
<li>层级结构</li>
</ul>
</li>
</ul>
<img src="03/image-20220411223707121.png" style="zoom:80%;" />

<ul>
<li>其他空间数据结构<ul>
<li>BVH：层次包围盒<ul>
<li>子弹打中某个物体 $\Longleftrightarrow$ 光线和物体求交</li>
</ul>
</li>
<li>BSP：空间划分</li>
<li>Octree：八叉树</li>
<li>Scene Graph：场景图</li>
</ul>
</li>
</ul>
<img src="03/image-20220411223827832.png" style="zoom:80%;" />



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Everything is a game object in the game world<ul>
<li>游戏世界中的所有东西都是 GO</li>
</ul>
</li>
<li>Game object could be described in the component-based way<ul>
<li>GO 使用组件化的方式描述</li>
</ul>
</li>
<li>States of game objects are updated in tick loops<ul>
<li>GO 的状态通过调用 <code>tick()</code> 进行更新</li>
</ul>
</li>
<li>Game objects interact with each other via event mechanism<ul>
<li>GO 之间通过事件机制进行交互</li>
</ul>
</li>
<li>Game objects are managed in a scene with efficient strategies<ul>
<li>GO 在场景中使用搞笑的空间数据结构进行管理</li>
</ul>
</li>
</ul>
<h2 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h2><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><ul>
<li>Binding</li>
<li>物体之间的绑定、联动<ul>
<li>例如你骑上马之后，你和马之间应该有相同的移动</li>
</ul>
</li>
<li>更新的时候按照父子关系更新<ul>
<li>先更新父结点，子结点再更新（基于父节点更新）</li>
<li>顺序很重要</li>
</ul>
</li>
</ul>
<img src="03/image-20220411225311245.png" style="zoom:80%;" />



<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul>
<li>允许 GO 之间直接通信，可能会导致不一致情况的发生<ul>
<li>因为 <code>tick()</code> 可能是并行的，并行情况下执行顺序可能会不一致</li>
<li>精彩回放：只是记录了玩家的输入，由于游戏引擎保证了一致性，回放和之前的画面是完全相同的<ul>
<li>一致性：同样的用户输入，引擎运行之后得到的结果是相同的</li>
</ul>
</li>
</ul>
</li>
<li>引入第三方，用于控制时序</li>
</ul>
<img src="03/image-20220411225235133.png" style="zoom:80%;" />

<ul>
<li>解决时序问题<ul>
<li><code>pre_tick()</code>、<code>post_tick()</code></li>
</ul>
</li>
</ul>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul>
<li>玩家从走路变成跑步，此时速度会变化，如果此时玩家的动作影响了环境（例如腿碰到其他物体），环境会反过来影响玩家的状态</li>
</ul>
<img src="03/image-20220411225514073.png" style="zoom:80%;" />

<ul>
<li>如何更新？<ul>
<li>变化马上在这一帧更新？下一帧更新？</li>
<li>精妙的设计</li>
</ul>
</li>
</ul>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ul>
<li>一个 <code>tick()</code> 的时间过长怎么办？<ul>
<li>每一个 <code>tick()</code> 的时候传入步长，补偿计算</li>
<li>跳过一个 <code>tick()</code></li>
<li>更多的是去优化引擎设计<ul>
<li>例如保证突然产生很多物体，一帧处理不过来，可以分散到相邻几帧去做（人眼看不出来）</li>
</ul>
</li>
</ul>
</li>
<li>渲染线程和逻辑线程的同步<ul>
<li>一般而言，<code>tick_logic()</code> 会更早一点，<code>tick_logic(),tick_render()</code> 二者会放在不同的线程处理</li>
<li><strong>输入延迟</strong>，<code>tick_logic()</code> 比 <code>tick_render()</code> 早了几帧<ul>
<li><code>frame_buffer</code> 的交换还需要一帧</li>
</ul>
</li>
<li>如何实时响应是引擎设计中的一个重要问题</li>
</ul>
</li>
<li>空间划分如何处理动态的 GO<ul>
<li>BVH 比 BSP 更新效率更高</li>
<li>一般需要引擎支持多种空间划分的数据结构，用于适应不同的应用场景</li>
</ul>
</li>
<li>组件模式的缺点<ul>
<li>效率可能比 <code>class</code> 低（为了弥补讲相同组件的数据放到一起，快速更新）</li>
<li>组件之间越需要有通信机制，但是组件之间并不知道对方是否一定存在，因此需要询问，高频的询问会影响效率</li>
</ul>
</li>
<li>Debug<ul>
<li>逐帧分析</li>
<li>可视化 debug</li>
<li><code>Log</code></li>
</ul>
</li>
<li>物理和动画互相影响的时候如何处理？<ul>
<li>插值过渡：一开始更多地使用定义好的动画，后面一步步转向物理计算的结果</li>
<li>设计感 + 物理真实感</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/10/CG/WX-GAMES104/03/" data-id="cl9lj749g006964tzdobce1h7" data-title="GAMES104.王希.03.如何构建游戏世界" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WX/" rel="tag">WX</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/Papers/2021/bvh-survey-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/08/CG/Papers/2021/bvh-survey-1/" class="article-date">
  <time class="dt-published" datetime="2022-04-08T04:33:20.000Z" itemprop="datePublished">2022-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/08/CG/Papers/2021/bvh-survey-1/">(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(2)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="BVH-Survey"><a href="#BVH-Survey" class="headerlink" title="BVH Survey"></a>BVH Survey</h1><ul>
<li><a href="/2022/04/06/CG/Papers/2021/bvh-survey-home/">目录</a></li>
</ul>
<h1 id="4-construct-bvh"><a href="#4-construct-bvh" class="headerlink" title="4. construct bvh"></a>4. construct bvh</h1><h2 id="4-1-Top-Down-Construction"><a href="#4-1-Top-Down-Construction" class="headerlink" title="4.1 Top-Down Construction"></a>4.1 Top-Down Construction</h2><ul>
<li><p>借鉴 KD-tree 的建立过程</p>
<ul>
<li>On Fast Construction of SAH-based Bounding Volume Hierarchies.</li>
</ul>
</li>
<li><p>算法</p>
<ul>
<li>根节点包含场景中所有的原体</li>
<li>从根节点开始，将包含的原体划分为两个不相交的子集（对应两个子节点）</li>
<li>对子节点做递归的操作，直到遇到终止条件</li>
</ul>
</li>
<li><p>终止条件</p>
<ul>
<li>节点中包含的最大原体数目（叶子节点）</li>
<li>最大树深度</li>
<li>最大使用内存</li>
</ul>
</li>
<li><p>问题：划分为两个子集的方式很多，是<strong>指数级别</strong>的（NPC）</p>
<ul>
<li>Object partitioning considered harmful: space subdivision for BVHs<ul>
<li>AABB 包围盒 $O(n^6)$ 的方法</li>
<li>进一步可以利用 grid approximation 控制时间复杂度，同时受限于 grid 的分辨率，可能只是个局部最优</li>
</ul>
</li>
</ul>
</li>
<li><p>BVH 中，每一个原体只会被引用一次</p>
<ul>
<li>引入空间划分放宽这个限制（section 5.1）</li>
</ul>
</li>
<li><p>实际操作中，每一次的划分我们都使用一个轴对齐的平面（axis-aligned plane）</p>
<ul>
<li>对于场景的原体，我们使用一个点来代替<ul>
<li>可以是包围盒的中心</li>
</ul>
</li>
<li>这个点只会在选择平面的一侧</li>
</ul>
</li>
<li><p><strong>划分轴</strong></p>
<ul>
<li>首先我们选择一个轴（xyz）<ul>
<li>测试 3 个轴，选出最好的</li>
<li>启发式算法：round-robin，最长的轴<ul>
<li>rr：根据轴的长度依概率选择划分轴</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>划分平面</strong></p>
<ul>
<li>选择划分平面的 3 种基本方式<ul>
<li>恰好把包围盒空间划分为两半：spatial median split</li>
<li>恰好把原体数目换分为两半：object median split<ul>
<li><strong>实用</strong></li>
</ul>
</li>
<li>损失函数：split based on a cost model<ul>
<li>试图求得代价函数的局部最优解</li>
<li>因为我们在划分之前无法准确的知道子结点的代价（cost）</li>
<li>我们将子节点都当作叶子节点进行估计</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey-1/image-20220410134940328.png"></p>
<ul>
<li>推导</li>
</ul>
<p>$$<br>\begin{aligned}<br>c(N)<br>&amp;&#x3D;c(N)^{SAH}\<br>&amp;&#x3D;c_T+\sum_{N_c}\dfrac{SA(N_c)}{SA(N)}c(N_c)\<br>&amp;\approx\hat{c}(N)^{SAH}\<br>&amp;&#x3D;c_T+c_I\sum_{N_c}\dfrac{SA(N_c)}{SA(N)}\vert N_c\vert\<br>\end{aligned}<br>$$</p>
<ul>
<li>我们也可以把这个当作终止条件的判断标准，如果 $c_I\vert N\vert\le \hat{c}(N)$ 则停止划分<ul>
<li>也就是说，如果把当前节点当作叶子节点的代价比继续划分更小，则停止划分</li>
</ul>
</li>
<li>损失函数加上一项，希望子节点的 BVH 重合更少<ul>
<li>$V(N)$：节点 $N$ 的包围盒的体积</li>
<li>$c_O$：常数</li>
<li>很直观，就是重合的比例越小越好</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey-1/image-20220410135710171.png"></p>
<ul>
<li>这样的损失函数比 EPO 更容易实现，与渲染相关性小，在 BVH 构建的时候便很容易计算</li>
<li><strong>以下介绍一些寻找划分平面的算法</strong></li>
</ul>
<h3 id="sweeping"><a href="#sweeping" class="headerlink" title="sweeping"></a>sweeping</h3><ul>
<li>选择划分平面的时候，依次测试所有的可能平面<ul>
<li>$N-1$ 个在原体之间的平面</li>
</ul>
</li>
<li><strong>计算代价很大</strong>，尤其是在算法开始的时候，节点包含的原体数目很多</li>
</ul>
<h3 id="binning"><a href="#binning" class="headerlink" title="binning"></a>binning</h3><ul>
<li>将待划分的轴空间平均的划分为 $b$ 个区间</li>
<li>将所有原体映射到 $b$ 个区间内部</li>
<li>现在我们只需要在这 $b-1$ 个平面上测试损失函数即可</li>
<li>实验表明，一个较小的 $b(16&#x2F;32)$ 效果也不错<ul>
<li>加速了 bvh 的构建</li>
<li>求交的加速效果和 sweeping 方式差不多</li>
</ul>
</li>
<li>随着深度变深，可以使用更少数量的 bin</li>
</ul>
<h3 id="binning-并行"><a href="#binning-并行" class="headerlink" title="binning 并行"></a>binning 并行</h3><ul>
<li><p>两种并行方式：horizontal parallelization $\to$ vertical parallelization</p>
</li>
<li><p>深度较小：horizontal parallelization（<strong>感觉本质上就是并行的桶排序</strong>）</p>
<ul>
<li><p>少量的内部节点，但是都包含大量的原体</p>
</li>
<li><p>场景的原体被均等分配给不同的线程（$0\sim T-1$）</p>
</li>
<li><p>对于每一个线程，将自己的原体映射到 bin 中（$0\sim B-1$）</p>
<ul>
<li>可能存在不同的线程中的原体映射到相同的 bin，因此我们让每个线程新包含一个私有的 bin set，最后做完之后在进行合并<ul>
<li>合并过程如下</li>
</ul>
</li>
<li>同时每一个线程 $t$ 计算 $N_{L,i,t},N_{R,i,t}$<ul>
<li>$N_{L,i,t}$ 表示对于线程 $t$ 分到的原体，位于第 $i$ 个 bin 左边（包含 $i$ ）的原体数目</li>
</ul>
</li>
</ul>
</li>
<li><p>做完之后，计算得到 $t$ 个前缀和 $N_{L,i}^{t}$（对所有线程 $1\sim t$ 求和）</p>
</li>
<li><p>此时每一个线程再扫描一遍它的所有原体，将原体对应的 ID 写到原始的三角形列表中</p>
<ul>
<li>offset 可以从前缀中得到，例如线程 $t$ 中有 $a$ 个落在第 $m$ 个 bin 中，那么这 $a$ 个原体对应的在三角形列表中的偏移就是如下</li>
</ul>
<p>$$<br>\begin{aligned}<br>&amp;\Big[N_{L,m-1,T-1}+N_{L,m,t-1}, N_{L,m-1,T-1}+N_{L,m,t-1}+a\Big)\<br>&#x3D;&amp;\Big[N_{L,m-1,T-1}+N_{L,m,t-1},N_{L,m-1,T-1}+N_{L,m,t}\Big)<br>\end{aligned}<br>$$</p>
</li>
<li><p>遍历所有的平面，计算最佳划分平面</p>
</li>
</ul>
</li>
<li><p>深度较大：vertical parallelization</p>
<ul>
<li>子树数量和线程数目相当</li>
<li>每一棵子树分配给一个线程</li>
</ul>
</li>
</ul>
<h3 id="Bonsai-算法"><a href="#Bonsai-算法" class="headerlink" title="Bonsai 算法"></a>Bonsai 算法</h3><ul>
<li>Bonsai: Rapid Bounding Volume Hierarchy Generation using Mini Trees</li>
<li>算法<ul>
<li>首先利用 spatial median split 的方式，将所有的三角形划分为若干个相邻的区域（cluster）</li>
<li>对于每一个区域建立一个 mini-tree，mini-tree 使用 sweeping 的方式建立</li>
<li>之后，将这些区域都看成叶子节点，建立上层的 BVH<ul>
<li>论文还提出了剪枝优化</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey-1/image-20220410155941425.png"></p>
<h3 id="PHR-算法"><a href="#PHR-算法" class="headerlink" title="PHR 算法"></a>PHR 算法</h3><ul>
<li>progressive hierarchical refinement (PHR)<ul>
<li>Parallel BVH Construction Using Progressive Hierarchical Refinement</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey-1/image-20220410162650568.png"></p>
<ul>
<li>算法<ul>
<li>首先按照某种方式建立起 BVH（论文是 LBVH）</li>
<li>找到一个 cut（一组节点，这组节点能够将根节点和所有叶子节点分开）</li>
<li>要求这个 cut 满足如下性质<ul>
<li>包含的树上的节点数量最少</li>
<li>表面积之和小于一个设定的阈值</li>
</ul>
</li>
<li>对这个 cut，将其划分为两个集合<ul>
<li>遍历 3 个轴，使用 sweeping 算法得到最好的划分平面</li>
<li>算的很快，因为节点数目和场景中的原体数目相比很小</li>
</ul>
</li>
<li>此时我们得到两个新的 cut（此时我们建立起了一个两层的 bvh）</li>
<li>对这两个 cut 构建子树（把 cut 内部节点的所有子节点都挂到这个节点上形成一棵树），重复上面的算法（找 cut）<ul>
<li>阈值会根据细分的次数进行更新</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey-1/image-20220410161837153.png"></p>
<h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><ul>
<li>更好的近似 EPO 代价函数</li>
<li>a parallel on-demand construction on the GPU<ul>
<li>只构建在遍历过程中可能经过的部分</li>
</ul>
</li>
<li>随机采样划分平面<ul>
<li>Automatic Bounding Volume Hierarchy Generation Using Stochastic Search Methods</li>
</ul>
</li>
<li>GPU-based<ul>
<li><strong>binning</strong></li>
<li><strong>uniform grids of various resolutions</strong> to accelerate binning on GPUs</li>
</ul>
</li>
<li>其他的 binning 算法<ul>
<li>根据节点的大小进行分类（而不是位置）</li>
</ul>
</li>
<li>利用 k-means 的方式构造 BVH，形成 k-分叉的 BVH，然后再聚合</li>
</ul>
<p><img src="/bvh-survey-1/image-20220410163941431.png"></p>
<h2 id="4-2-Bottom-Up-Construction"><a href="#4-2-Bottom-Up-Construction" class="headerlink" title="4.2. Bottom-Up Construction"></a>4.2. Bottom-Up Construction</h2><ul>
<li>聚合算法<ul>
<li>最早提出：Fast Agglomerative Clustering for Rendering</li>
</ul>
</li>
<li>基本思路<ul>
<li>初始的时候，所有的原体都被当做是 clusters</li>
<li>每轮迭代的时候，最近的两个 cluster 会被合并<ul>
<li>距离函数：将两个 cluster 都包含的包围盒的表面积</li>
</ul>
</li>
<li>反复迭代，直至只剩下一个 cluster</li>
</ul>
</li>
<li>一般而言效果好，但是时间开销极大</li>
<li>从算法来看，很容易看出这里的优化主要集中在 bottom 的部分<ul>
<li>可能导致 top 部分的优化很差</li>
</ul>
</li>
<li>优化的难点：每次迭代都需要对每一个点找最近邻<ul>
<li>the <strong>nearest neighbor search</strong> has to be performed for <strong>each cluster</strong> to determine the closest cluster pair in <strong>each iteration</strong></li>
</ul>
</li>
</ul>
<h3 id="堆与-kd-tree"><a href="#堆与-kd-tree" class="headerlink" title="堆与 kd-tree"></a>堆与 kd-tree</h3><ul>
<li>论文：Fast Agglomerative Clustering for Rendering</li>
<li>数据结构<ul>
<li>堆：以距离为优先级函数保存最近邻</li>
<li>辅助的 kd-tree：加速最近邻的查找</li>
</ul>
</li>
<li>伪代码如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">KDTree kd = <span class="keyword">new</span> <span class="built_in">KDTree</span>(InputPoints);</span><br><span class="line">MinHeap heap = <span class="keyword">new</span> <span class="built_in">MinHeap</span>();</span><br><span class="line">foreach A in InputPoints <span class="keyword">do</span> &#123;</span><br><span class="line">    Cluster B = kd.<span class="built_in">findBestMatch</span>(A);</span><br><span class="line">    heap.<span class="built_in">add</span>(<span class="built_in">d</span>(A,B), <span class="keyword">new</span> <span class="built_in">Pair</span>(A,B));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( kd.<span class="built_in">size</span>() &gt; <span class="number">1</span> ) &#123;</span><br><span class="line">    Pair &lt;A,B&gt; = heap.<span class="built_in">removeMinPair</span>();</span><br><span class="line">    <span class="keyword">if</span> (! kd.<span class="built_in">contains</span>(A) ) &#123;</span><br><span class="line">        <span class="comment">// A was already clustered with somebody</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! kd.<span class="built_in">contains</span>(B) ) &#123;</span><br><span class="line">        <span class="comment">// B is invalid, find new best match for A</span></span><br><span class="line">        B = kd.<span class="built_in">findBestMatch</span>(A);</span><br><span class="line">        heap.<span class="built_in">add</span>(<span class="built_in">d</span>(A,B), <span class="keyword">new</span> <span class="built_in">Pair</span>(A,B));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        kd.<span class="built_in">remove</span>(A);</span><br><span class="line">        kd.<span class="built_in">remove</span>(B);</span><br><span class="line">        Cluster C = <span class="keyword">new</span> <span class="built_in">Cluster</span>(A,B);</span><br><span class="line">        kd.<span class="built_in">add</span>(C);</span><br><span class="line">        Cluster D = kd.<span class="built_in">findBestMatch</span>(C);</span><br><span class="line">        heap.<span class="built_in">add</span>(<span class="built_in">d</span>(C,D), <span class="keyword">new</span> <span class="built_in">Pair</span>(C,D));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>不太容易并行</strong>，kd-tree 在合并的过程中会被更新</li>
</ul>
<h3 id="AAC"><a href="#AAC" class="headerlink" title="AAC"></a>AAC</h3><ul>
<li>approximate agglomerative clustering (AAC)<ul>
<li>Efficient BVH Construction via Approximate Agglomerative Clustering</li>
</ul>
</li>
<li>idea：利用 Morton curve 来限制最近邻搜索的区域<ul>
<li>Morton curve，section 4.4</li>
</ul>
</li>
<li>首先，场景中的原体按照 <em>spatial median splits</em> based on <em>Morton codes</em> 的分割方式进行分割，直到每一棵子树包含的 cluster 数目都小于预先设定的一个值</li>
<li>在每一棵子树中对 cluster 进行合并<ul>
<li>利用聚合算法进行合并，直到数量比较小（可以不是 1）</li>
</ul>
</li>
<li>此时对还没有合并的 cluster 进行合并<ul>
<li>不是所有的 cluster 都放到一起合并，cluster 数目都小于预先设定的一个值，会先分成多个</li>
</ul>
</li>
<li>反复合并，直到树构建完成</li>
</ul>
<p><img src="/bvh-survey-1/image-20220410174645839.png"></p>
<ul>
<li>每一次合并，为了加速最近邻的查找，使用一个距离矩阵（$n^2$）进行 cache<ul>
<li>因为每次合并只有少量的距离会被影响</li>
</ul>
</li>
</ul>
<h3 id="PLOC"><a href="#PLOC" class="headerlink" title="PLOC"></a>PLOC</h3><ul>
<li>AAC 一开始划分的时候，栈深度较大（导致距离矩阵大）， GPU 不友好</li>
<li>parallel locally-ordered clustering(PLOC)<ul>
<li>GPU-based</li>
</ul>
</li>
<li>idea：距离函数是非减的<ul>
<li>如果两个 cluster 的最近邻是相互对应的，那么就可以马上合并</li>
<li>这带来了并行的可能，一次合并所有互相对应的 cluster pair</li>
</ul>
</li>
<li>cluster 保持在 Morton curve 上的有序性，每次查找最近邻，只查找旁边指定数量的邻居（不需要其他的数据结构，例如距离矩阵）</li>
<li>算法<ul>
<li>使用 Morton curve 找到每一个 cluster 的最近邻</li>
<li>合并所有的互相是最近邻的节点<ul>
<li>移除这些节点，并且将合并后的新节点放到第一个节点原来的位置</li>
</ul>
</li>
<li>使用 parallel prefix scan 的方式移除缺失的部分</li>
</ul>
</li>
<li>一般而言，少量几次迭代便能构建出 BVH</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/08/CG/Papers/2021/bvh-survey-1/" data-id="cl9lj74bv00mc64tz6a3scvzv" data-title="(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(2)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BVH/" rel="tag">BVH</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EG/" rel="tag">EG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Paper/" rel="tag">Paper</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/occlusion/" rel="tag">occlusion</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/Papers/2021/bvh-survey" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/06/CG/Papers/2021/bvh-survey/" class="article-date">
  <time class="dt-published" datetime="2022-04-06T05:18:20.000Z" itemprop="datePublished">2022-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/06/CG/Papers/2021/bvh-survey/">(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(1)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="BVH-Survey"><a href="#BVH-Survey" class="headerlink" title="BVH Survey"></a>BVH Survey</h1><ul>
<li><a href="/2022/04/06/CG/Papers/2021/bvh-survey-home/">目录</a></li>
</ul>
<h2 id="banner"><a href="#banner" class="headerlink" title="banner"></a>banner</h2><p><img src="/bvh-survey/a.jpg"></p>
<h2 id="1-introduction"><a href="#1-introduction" class="headerlink" title="1. introduction"></a>1. introduction</h2><ul>
<li>加速光追方式<ul>
<li>efficient sampling techniques</li>
<li>denoising methods</li>
<li>an efficient spatial data structure</li>
</ul>
</li>
<li>BVH<ul>
<li>Bounding Volume Hierarchy</li>
<li>层次包围盒</li>
</ul>
</li>
<li>问题：给定一条光线，找到它和场景原体最近的交点</li>
<li>光在均匀介质中沿<strong>直线</strong>传播</li>
</ul>
<h2 id="2-preliminaries"><a href="#2-preliminaries" class="headerlink" title="2. preliminaries"></a>2. preliminaries</h2><ul>
<li>前置知识</li>
<li>问题：给定一条光线，找到它和场景原体最近的交点<ul>
<li>光线：$\mathbf{o}+t\mathbf{d}$</li>
</ul>
</li>
<li><strong>暴力方法</strong>：求出光线和场景中所有原体的交点，取最近的<ul>
<li>时间复杂度：$O(n)$</li>
</ul>
</li>
</ul>
<h3 id="BVH"><a href="#BVH" class="headerlink" title="BVH"></a>BVH</h3><ul>
<li><strong>k叉有根树</strong><ul>
<li>叶子节点指向场景中的原体，是包含的原体的包围盒</li>
<li>父节点是子结点的包围盒</li>
<li>根节点是场景中所有原体的包围盒</li>
</ul>
</li>
<li>基于这样一个事实<ul>
<li><strong>光线和父节点不相交，那么一定和子节点不相交</strong></li>
</ul>
</li>
<li>包围盒<ul>
<li><strong>AABB</strong>：axis-aligned bounding boxes</li>
<li><strong>OBB</strong>：oriented bounding boxes</li>
<li>bounding spheres</li>
</ul>
</li>
<li>渲染中，场景几何原体一般是 3D 的</li>
</ul>
<h4 id="BVH-的优点"><a href="#BVH-的优点" class="headerlink" title="BVH 的优点"></a>BVH 的优点</h4><h5 id="Predictable-memory-footprint"><a href="#Predictable-memory-footprint" class="headerlink" title="Predictable memory footprint"></a>Predictable memory footprint</h5><ul>
<li>空间复杂度近似是叶子节点数目的 $2$ 倍</li>
<li>满 $k$ 叉树总节点 $N$ 和叶子节点数 $n$ 有如下关系</li>
</ul>
<p>$$<br>N&#x3D;n+\dfrac{n-1}{k-1}\le 2n-1<br>$$</p>
<h5 id="Robust-and-efficient-query"><a href="#Robust-and-efficient-query" class="headerlink" title="Robust and efficient query"></a>Robust and efficient query</h5><ul>
<li>平均时间复杂度是在 $\log(N)$ 级别的</li>
<li>大多数情况下性能能够和 KD-tree 差不多<ul>
<li>VINKLER M., HAVRAN V., BITTNER J.: Performance Comparison of Bounding Volume Hierarchies and Kd-Trees for GPU Ray Tracing. Computer Graphics Forum (2016)</li>
</ul>
</li>
</ul>
<h5 id="Scalable-construction"><a href="#Scalable-construction" class="headerlink" title="Scalable construction"></a>Scalable construction</h5><ul>
<li>有很多现成的方法</li>
<li>快速建立 $\longrightarrow$ 高度优化：trade-off<ul>
<li><em>construction speed</em></li>
<li><em>BVH quality</em><ul>
<li>MRays&#x2F;s</li>
</ul>
</li>
</ul>
</li>
<li>实时渲染中，由于时间的限制，只允许投射少量的光线，只能够建立中等质量的 BVH（够了）</li>
<li>离线渲染倾向于建立高度优化的 BVH</li>
<li>如下图<ul>
<li>斜率表示质量，截距表示建立的时间开销</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey/image-20220406143600980.png"></p>
<h5 id="Dynamic-geometry"><a href="#Dynamic-geometry" class="headerlink" title="Dynamic geometry"></a>Dynamic geometry</h5><ul>
<li>通过动态调整 BVH 节点实现，传统的 KD-tree 是实现不了的<ul>
<li>使用 fast BVH construction methods（质量？）</li>
</ul>
</li>
</ul>
<h4 id="建立-BVH"><a href="#建立-BVH" class="headerlink" title="建立 BVH"></a>建立 BVH</h4><ul>
<li>自顶向下建立 BVH 的伪代码如下</li>
</ul>
<p><img src="/bvh-survey/image-20220406144244562.png"></p>
<h4 id="求交"><a href="#求交" class="headerlink" title="求交"></a>求交</h4><ul>
<li>一般来说有两种需求<ul>
<li>求出交点：radiance ray</li>
<li>判断某一个点是否被遮挡：occlusion ray<ul>
<li>occlusion test</li>
</ul>
</li>
</ul>
</li>
<li>使用栈来保存可能有交点的树节点</li>
<li><strong>光线和父节点不相交，那么一定和子节点不相交</strong></li>
<li>记录当前已经求出来的最近节点位置，用于剪枝<ul>
<li>记录 $t$</li>
<li>如果一个包围盒的交点已经比记录的距离远，直接剪枝</li>
<li>这个位置必须是和几何原体求交得到的距离（不能是包围盒，可能不和几何原体相交）</li>
</ul>
</li>
<li>对于 occlusion test 而言，找到一个交点之后便可以提前停下了（early exit）</li>
<li>伪代码如下</li>
</ul>
<p><img src="/bvh-survey/image-20220406145541667.png"></p>
<ul>
<li>一次求交的过程</li>
</ul>
<p><img src="/bvh-survey/image-20220406150012040.png"></p>
<h2 id="3-cost-function"><a href="#3-cost-function" class="headerlink" title="3. cost function"></a>3. cost function</h2><ul>
<li>对于 BVH 质量的评估，可以使用如下的量表示<ul>
<li><strong>光线一次求交的平均操作次数</strong></li>
</ul>
</li>
<li>根节点的代价函数（递归定义）</li>
</ul>
<p><img src="/bvh-survey/image-20220406150419248.png"></p>
<ul>
<li>$\vert N\vert$：以当前节点为根节点的子树包含的几何原体数目</li>
<li>$P(N_c\vert N)$：光线和父节点相交的前提下，子结点 $N_c$ 和光线相交的概率</li>
<li>$c_{T}$：和一个 bvh 节点求交的平均代价</li>
<li>$c_I$：和一个几何原体求交的平均代价</li>
<li>$c_I,c_T$ 通常是粗略的估计，而不是汇编级的精确值指令数目<ul>
<li>实际操作很有用</li>
<li>$c_T$ 代价很大 $\Longrightarrow$ 使用更大的 $k$（更多分叉，更小深度）</li>
</ul>
</li>
</ul>
<h3 id="SAH"><a href="#SAH" class="headerlink" title="SAH"></a>SAH</h3><ul>
<li>Surface Area Heuristic</li>
<li>将上面的条件概率转化为几何概率（可计算）</li>
</ul>
<p>$$<br>P(N_c\vert N)^{SAH}&#x3D;\dfrac{SA(N_c)}{SA(N)}<br>$$</p>
<ul>
<li>$SA(\cdot)$ 表示 bvh 节点的表面积</li>
</ul>
<p><img src="/bvh-survey/image-20220406152831817.png"></p>
<ul>
<li>$N_i$：以当前节点为根节点的子树的<strong>内部节点</strong>数目</li>
<li>$N_l$：以当前节点为根节点的子树的<strong>叶子节点</strong>数目</li>
<li>SAH 的假设（理想的假设，unrealistic）<ul>
<li>光线的起点在场景包围盒外部均匀分布</li>
<li>光线的方向均匀分布</li>
<li>光线不会被遮挡</li>
</ul>
</li>
</ul>
<h3 id="RDH"><a href="#RDH" class="headerlink" title="RDH"></a>RDH</h3><ul>
<li>ray distribution heuristics</li>
<li>对 SAH 不现实的假设的修正，考虑实际光线的分布</li>
</ul>
<p>$$<br>P(N_c\vert N)^{RDH}&#x3D;\dfrac{R(N_c)}{R(N)}<br>$$</p>
<ul>
<li>$R(\cdot)$：击中 bvh 节点的光线数目</li>
<li>最早是在 KD-tree 中提出的</li>
</ul>
<h3 id="OH"><a href="#OH" class="headerlink" title="OH"></a>OH</h3><ul>
<li>occlusion heuristic</li>
<li>在高遮挡条件下，能过够有一个更好的性能</li>
</ul>
<p>$$<br>P(N_c\vert N)^{OH}&#x3D;\dfrac{OC(N_c)}{OC(N)}<br>$$</p>
<ul>
<li>$O(\cdot)$：以当前节点为根节点的子树包含的<strong>可见的</strong>几何原体的数目<ul>
<li>$O(N)$ is the number of visible scene primitives in a subtree with root $N$.</li>
</ul>
</li>
<li>这种方法试图将可见的原体和不可见的原体分在不同的 bvh 中<ul>
<li>如果一个 bvh 中只有（不）可见的原体，则使用 SAH 构建</li>
<li>细节见论文</li>
</ul>
</li>
<li>单独使用 RDH&#x2F;OH 可能为导致<strong>不稳定</strong><ul>
<li>由于欠采样、过采样导致的</li>
<li>论文中采用和 SAH 进行混合的方法</li>
</ul>
</li>
</ul>
<h3 id="光源在内部"><a href="#光源在内部" class="headerlink" title="光源在内部"></a>光源在内部</h3><ul>
<li>考虑光源在场景包围盒内部<ul>
<li>例如发反射光的起点便是在内部</li>
</ul>
</li>
<li>论文假设：Ray origins are uniformly distributed in space <strong>inside</strong> S</li>
</ul>
<p><img src="/bvh-survey/image-20220406164645979.png"></p>
<ul>
<li>$V(\cdot)$：包围盒的体积</li>
<li>$\alpha_{\mathrm{x}}$：对于 $S\backslash N$ 内部的点 $\mathrm{x}$，bvh 节点 $N$ 所占的立体角</li>
</ul>
<p><img src="/bvh-survey/image-20220406170215330.png"></p>
<ul>
<li>公式解释<ul>
<li>对于光源起点在 $N$ 内部的光线</li>
<li>对于光源起点 $\mathrm{x}$ 在 $N$ 外部的光线，可见性的比例就是 $\alpha_{\mathrm{x}}$<ul>
<li>我们假设方向也是均匀分布的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="EPO"><a href="#EPO" class="headerlink" title="EPO"></a>EPO</h3><ul>
<li>end-point overlap heuristic</li>
<li>动机：几乎大部分光线都是起源于场景中的某个原体<ul>
<li>多 bounce 情况下的散射</li>
</ul>
</li>
<li>如果光源的起点处在多个分支的包围盒中，那么我们需要全部遍历他们<ul>
<li>If a ray origin (or hit point) is inside multiple branches, we have to visit all of them.</li>
</ul>
</li>
<li>惩罚这样的表面，他的位置处于某个 bvh 节点中，但是它本身没有被划分在这个节点中</li>
<li>假设三角形可以被拆分（被划分到两个 bvh 中的时候拆分为多个）</li>
<li>理想情况下，我们期望没有重叠发生<ul>
<li>例如一棵所有三角形都被拆分到叶结点的八叉树（octree）</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey/image-20220406171835829.png"></p>
<ul>
<li>$S$：场景中所有几何原体的集合</li>
<li>$S_{N}&#x3D;N\cap S$：在 bvh 节点 N 内部的原体</li>
<li>分解惩罚<ul>
<li>$S^{\ast}_{N}$：位置在当前 bvh 节点内部，而且属于当前节点的原体</li>
<li>$S_{N}\backslash S^{\ast}_{N}$：位置在当前 bvh 节点内部，但是不属于当前节点的原体</li>
</ul>
</li>
</ul>
<p><img src="/bvh-survey/image-20220406174325229.png"></p>
<ul>
<li>实现的时候和 SAH 进行混合</li>
<li>如何将其直接用于 bvh 的构建，这个不是很直观</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/06/CG/Papers/2021/bvh-survey/" data-id="cl9lj74bx00ml64tz0bup1vas" data-title="(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(1)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BVH/" rel="tag">BVH</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EG/" rel="tag">EG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Paper/" rel="tag">Paper</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/occlusion/" rel="tag">occlusion</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/0/">0</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algebra/">Algebra</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-Kits/">C++.Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG/">CG</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Algorithm/">CG.Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES101/">CG.GAMES101</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES102/">CG.GAMES102</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES103/">CG.GAMES103</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES104/">CG.GAMES104</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES202/">CG.GAMES202</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES203/">CG.GAMES203</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Kits/">CG.Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-LS/">CG.LS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-PBRT/">CG.PBRT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Paper/">CG.Paper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CV/">CV</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Code/">Code</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-CLJ/">DB.CLJ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-MySQL/">DB.MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-SQLServer/">DB.SQLServer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DSA/">DSA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kits/">Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-CXQ/">OS.CXQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-OSTEP/">OS.OSTEP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-xv6-labs/">OS.xv6-labs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-xv6-source-code/">OS.xv6-source-code</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TODO/">TODO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/book-directory/">book.directory</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computation-pyr/">computation.pyr</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/csharp-kits/">csharp.kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/csharp-tds/">csharp.tds</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/images/">images</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/installation/">installation</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mitsuba/">mitsuba</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nothing/">nothing</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-Maya/">software.Maya</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-ps/">software.ps</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-vscode/">software.vscode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/win/">win</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algebra/" rel="tag">Algebra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS/" rel="tag">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BST/" rel="tag">BST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BVH/" rel="tag">BVH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CG-Algorithm/" rel="tag">CG-Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CV/" rel="tag">CV</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Code/" rel="tag">Code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB/" rel="tag">DB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/" rel="tag">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DSA/" rel="tag">DSA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dijkstra/" rel="tag">Dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EG/" rel="tag">EG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Floyd/" rel="tag">Floyd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GI/" rel="tag">GI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Glints/" rel="tag">Glints</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDR/" rel="tag">HDR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HQX/" rel="tag">HQX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Heap/" rel="tag">Heap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kits/" rel="tag">Kits</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCA/" rel="tag">LCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLG/" rel="tag">LLG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MCMC/" rel="tag">MCMC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MIS/" rel="tag">MIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MLT/" rel="tag">MLT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maya/" rel="tag">Maya</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NEE/" rel="tag">NEE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBRT/" rel="tag">PBRT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paper/" rel="tag">Paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Radiometry/" rel="tag">Radiometry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RayTracing/" rel="tag">RayTracing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SAH/" rel="tag">SAH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SDF/" rel="tag">SDF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SGJ/" rel="tag">SGJ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLServer/" rel="tag">SQLServer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shadow/" rel="tag">Shadow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WHM/" rel="tag">WHM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WX/" rel="tag">WX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/book/" rel="tag">book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/computation/" rel="tag">computation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csharp/" rel="tag">csharp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/images/" rel="tag">images</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/installation/" rel="tag">installation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/" rel="tag">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mitsuba/" rel="tag">mitsuba</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobaxterm/" rel="tag">mobaxterm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nothing/" rel="tag">nothing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/obs/" rel="tag">obs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/occlusion/" rel="tag">occlusion</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ps/" rel="tag">ps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/software/" rel="tag">software</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tree/" rel="tag">tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/win/" rel="tag">win</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xv6/" rel="tag">xv6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%83%E5%AE%87%E5%AE%99/" rel="tag">元宇宙</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%A0%E4%BD%95/" rel="tag">几何</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/" rel="tag">可见性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" rel="tag">拓扑排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%99%AE%E5%90%95%E5%85%8B%E5%9D%90%E6%A0%87/" rel="tag">普吕克坐标</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="tag">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algebra/" style="font-size: 10px;">Algebra</a> <a href="/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/tags/BST/" style="font-size: 10px;">BST</a> <a href="/tags/BVH/" style="font-size: 12.5px;">BVH</a> <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/CG/" style="font-size: 20px;">CG</a> <a href="/tags/CG-Algorithm/" style="font-size: 10px;">CG-Algorithm</a> <a href="/tags/CV/" style="font-size: 10.63px;">CV</a> <a href="/tags/Code/" style="font-size: 14.38px;">Code</a> <a href="/tags/DB/" style="font-size: 19.38px;">DB</a> <a href="/tags/DFS/" style="font-size: 12.5px;">DFS</a> <a href="/tags/DP/" style="font-size: 13.13px;">DP</a> <a href="/tags/DSA/" style="font-size: 11.25px;">DSA</a> <a href="/tags/Dijkstra/" style="font-size: 10px;">Dijkstra</a> <a href="/tags/EG/" style="font-size: 12.5px;">EG</a> <a href="/tags/Floyd/" style="font-size: 10.63px;">Floyd</a> <a href="/tags/GI/" style="font-size: 11.25px;">GI</a> <a href="/tags/Glints/" style="font-size: 10px;">Glints</a> <a href="/tags/HDR/" style="font-size: 10px;">HDR</a> <a href="/tags/HQX/" style="font-size: 10px;">HQX</a> <a href="/tags/Heap/" style="font-size: 10px;">Heap</a> <a href="/tags/Kits/" style="font-size: 13.75px;">Kits</a> <a href="/tags/LCA/" style="font-size: 10px;">LCA</a> <a href="/tags/LLG/" style="font-size: 12.5px;">LLG</a> <a href="/tags/MCMC/" style="font-size: 10.63px;">MCMC</a> <a href="/tags/MIS/" style="font-size: 10px;">MIS</a> <a href="/tags/MLT/" style="font-size: 10px;">MLT</a> <a href="/tags/Maya/" style="font-size: 10px;">Maya</a> <a href="/tags/MySQL/" style="font-size: 11.88px;">MySQL</a> <a href="/tags/NEE/" style="font-size: 10px;">NEE</a> <a href="/tags/OS/" style="font-size: 17.5px;">OS</a> <a href="/tags/PBRT/" style="font-size: 10px;">PBRT</a> <a href="/tags/Paper/" style="font-size: 15.63px;">Paper</a> <a href="/tags/Radiometry/" style="font-size: 10px;">Radiometry</a> <a href="/tags/RayTracing/" style="font-size: 10px;">RayTracing</a> <a href="/tags/SAH/" style="font-size: 10px;">SAH</a> <a href="/tags/SDF/" style="font-size: 10px;">SDF</a> <a href="/tags/SGJ/" style="font-size: 10.63px;">SGJ</a> <a href="/tags/SQL/" style="font-size: 13.13px;">SQL</a> <a href="/tags/SQLServer/" style="font-size: 10.63px;">SQLServer</a> <a href="/tags/STL/" style="font-size: 11.25px;">STL</a> <a href="/tags/Shadow/" style="font-size: 10px;">Shadow</a> <a href="/tags/WHM/" style="font-size: 16.88px;">WHM</a> <a href="/tags/WX/" style="font-size: 11.88px;">WX</a> <a href="/tags/YLQ/" style="font-size: 18.13px;">YLQ</a> <a href="/tags/book/" style="font-size: 10.63px;">book</a> <a href="/tags/computation/" style="font-size: 18.75px;">computation</a> <a href="/tags/csharp/" style="font-size: 16.25px;">csharp</a> <a href="/tags/images/" style="font-size: 10px;">images</a> <a href="/tags/installation/" style="font-size: 11.88px;">installation</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/linux/" style="font-size: 11.25px;">linux</a> <a href="/tags/math/" style="font-size: 10px;">math</a> <a href="/tags/mitsuba/" style="font-size: 11.88px;">mitsuba</a> <a href="/tags/mobaxterm/" style="font-size: 10px;">mobaxterm</a> <a href="/tags/nothing/" style="font-size: 10.63px;">nothing</a> <a href="/tags/obs/" style="font-size: 10px;">obs</a> <a href="/tags/occlusion/" style="font-size: 15px;">occlusion</a> <a href="/tags/ps/" style="font-size: 10px;">ps</a> <a href="/tags/software/" style="font-size: 10px;">software</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/tree/" style="font-size: 11.25px;">tree</a> <a href="/tags/vscode/" style="font-size: 10.63px;">vscode</a> <a href="/tags/win/" style="font-size: 10.63px;">win</a> <a href="/tags/xv6/" style="font-size: 16.25px;">xv6</a> <a href="/tags/%E4%BA%8C%E5%88%86/" style="font-size: 10.63px;">二分</a> <a href="/tags/%E5%85%83%E5%AE%87%E5%AE%99/" style="font-size: 10.63px;">元宇宙</a> <a href="/tags/%E5%87%A0%E4%BD%95/" style="font-size: 10px;">几何</a> <a href="/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/" style="font-size: 11.88px;">可见性</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 10.63px;">并查集</a> <a href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">拓扑排序</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%99%AE%E5%90%95%E5%85%8B%E5%9D%90%E6%A0%87/" style="font-size: 10px;">普吕克坐标</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 10px;">最小生成树</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" style="font-size: 13.13px;">最短路</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 10px;">线段树</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/23/CG/WHM-GAMES103/11/">GAMES103.王华民.11.Incompressible Fluid Dynamics and Eulerian Fluids</a>
          </li>
        
          <li>
            <a href="/2022/10/23/CG/Papers/2021/bvh-survey-3/">(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(4)</a>
          </li>
        
          <li>
            <a href="/2022/04/28/CG/Kits/MIS-NEE/">NEE、MIS(多重重要性采样)</a>
          </li>
        
          <li>
            <a href="/2022/04/18/CG/WHM-GAMES103/10/">GAMES103.王华民.10.Surface Waves</a>
          </li>
        
          <li>
            <a href="/2022/04/17/CG/WHM-GAMES103/09-1/">GAMES103.王华民.09.Collision Handling(1)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>