<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/21/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-DB/CLJ/03-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/02/DB/CLJ/03-1/" class="article-date">
  <time class="dt-published" datetime="2021-04-02T14:00:10.000Z" itemprop="datePublished">2021-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/02/DB/CLJ/03-1/">数据库概论.陈立军.03.关系模型(2)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><h2 id="关系代数的分类"><a href="#关系代数的分类" class="headerlink" title="关系代数的分类"></a>关系代数的分类</h2><ul>
<li>基本运算<ul>
<li>一元运算<ul>
<li>选择、投影、更名</li>
</ul>
</li>
<li>多元运算<ul>
<li>笛卡儿积、集合并、集合差</li>
</ul>
</li>
</ul>
</li>
<li>扩展运算<ul>
<li>集合交、$\theta$ 连接、自然连接、外连接</li>
</ul>
</li>
<li>其它运算<ul>
<li>赋值、广义投影、插入、删除、更新</li>
</ul>
</li>
</ul>
<h2 id="关系代数基本运算"><a href="#关系代数基本运算" class="headerlink" title="关系代数基本运算"></a>关系代数基本运算</h2><h3 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a>选择运算</h3><ul>
<li>在关系中选择满足给定条件的元组（行角度）</li>
</ul>
<p>$$<br>\sigma_F(R)&#x3D;\left{t|t\in R,F(t)&#x3D;true\right}<br>$$</p>
<ul>
<li><p>$F$ 是选择的条件，$\forall t\in R,F(t)$ 要么为真，要么为假</p>
</li>
<li><p>$F$ 由<strong>逻辑运算符</strong>连接<strong>算术表达式</strong>而成</p>
</li>
<li><p>逻辑运算符：$\land, \lor,\lnot$</p>
</li>
<li><p>算术表达式：$X\ \theta\ Y$</p>
<ul>
<li>$X,Y$是属性名、常量、或简单函数</li>
<li>$\theta$ 是比较算符<ul>
<li>$\theta\in\left{&gt;,\ge,&lt;,\le,&#x3D;,\ne\right}$</li>
</ul>
</li>
</ul>
</li>
<li><p>例子：找年龄不小于 20 的男学生</p>
<ul>
<li>表达上等效</li>
<li>实际查询中谁更高效？取决于数据库的设计<ul>
<li>如果索引中含有 age，则 （3） 可能最高效</li>
<li>一般不会是（2），性别这种二值属性不适于建索引</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>$$<br>\begin{aligned}<br>(1)\ &amp;\sigma_{age\ge20\land sex&#x3D;’M’}(S)\<br>(2)\ &amp;\sigma_{age\ge20}\left(\sigma_{sex&#x3D;’M’}(S)\right)\<br>(3)\ &amp;\sigma_{sex&#x3D;’M’}\left(\sigma_{age\ge20}(S)\right)\<br>\end{aligned}<br>$$</p>
<h3 id="投影运算"><a href="#投影运算" class="headerlink" title="投影运算"></a>投影运算</h3><ul>
<li>从关系中取若干列组成新的关系（从列的角度）</li>
</ul>
<p>$$<br>%% Π𝑨𝑨𝑹𝑹&#x3D;𝒕𝒕𝑨𝑨𝒕𝒕∈𝑹𝑹},𝑨𝑨⊆𝑹𝑹<br>\prod_A(R)\left{ t[A]|t\in R\right},A\subseteq R<br>$$</p>
<ul>
<li>注意：<strong>投影的结果中要去掉相同的行</strong></li>
<li>例子：给出所有学生的姓名和年龄<ul>
<li>$\prod_{sno,age}(S)$</li>
</ul>
</li>
</ul>
<h3 id="更名"><a href="#更名" class="headerlink" title="更名"></a>更名</h3><ul>
<li><p>将关系 $R$ 更名为 $S$</p>
<ul>
<li>$\rho_S(R)$</li>
<li>对现有的表进行更名</li>
</ul>
</li>
<li><p>将计算表达式 $E$ 更名为关系 $S$</p>
<ul>
<li>$\rho_{S(A_1,A_2,\cdots,A_n)}(E)$</li>
<li>将中间结果存储到自己定义的表里面</li>
</ul>
</li>
<li><p>更名运算的必要性</p>
<ul>
<li>将更名运算施加到关系上，得到具有不同名字的同一关系</li>
<li>当同一关系多次参与同一运算时需要更名</li>
</ul>
</li>
</ul>
<h3 id="并运算"><a href="#并运算" class="headerlink" title="并运算"></a>并运算</h3><ul>
<li>所有至少出现在两个关系中之一的元组集合</li>
</ul>
<p>$$<br>R\cup S&#x3D;\left{r|r\in R\lor r\in S\right}<br>$$</p>
<ul>
<li>关系 $R$ 和 $S$ 进行并运算的前提是它们必须是<strong>相容</strong>的<ul>
<li>关系 $R$ 和 $S$ 必须是<strong>同元</strong>的，其<strong>属性数目必须相同</strong></li>
<li>对 $\forall i$，$R$ 的第 $i$ 个属性和 $S$ 的第 $i$ 个属性的<strong>域</strong>必须相同</li>
</ul>
</li>
<li>简单地说，得具有相同的表结构</li>
<li>例子：求选修了 001 号或 002 号课程的学生号<ul>
<li>两种表示</li>
<li>$\prod_{sno}(\sigma_{cno&#x3D;001\lor cno&#x3D;002}(SC))$</li>
<li>$\prod_{sno}(\sigma_{cno&#x3D;001}(SC))\cup\prod_{sno}(\sigma_{cno&#x3D;001}(SC))$</li>
</ul>
</li>
</ul>
<h3 id="差运算"><a href="#差运算" class="headerlink" title="差运算"></a>差运算</h3><ul>
<li>所有出现在一个关系而不在另一关系中的元组集合</li>
</ul>
<p>$$<br>R-S&#x3D;\left{r|r\in R\land r\notin S\right}<br>$$</p>
<ul>
<li>$R,S$ 必须是<strong>相容</strong>的</li>
<li>例子：求选修了001号但未选修002号课程的学生号<ul>
<li>$\prod_{sno}(\sigma_{cno&#x3D;001}(SC))-\prod_{sno}(\sigma_{cno&#x3D;002}(SC))$</li>
<li>$\prod_{sno}(\sigma_{cno&#x3D;001\land cno\ne002}(SC))$<ul>
<li>这种表示是<span style="color:red;font-weight:bold">错误</span>的，一方面第二个条件是多余的，另一方面不适用于如下场景</li>
<li>每个人有多个行，表示选择了不同的课程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="交运算"><a href="#交运算" class="headerlink" title="交运算"></a>交运算</h3><ul>
<li>所有同时出现在两个关系中的元组集合<ul>
<li>交运算可以通过差运算来重写</li>
</ul>
</li>
</ul>
<p>$$<br>R\cap S&#x3D;R-(R-S)<br>$$</p>
<ul>
<li>是一种扩展运算，早期定义的时候把差运算定义成了基本运算</li>
<li>例子：求同时选修了 001 号和 002 号课程的学生号<ul>
<li>$\prod_{sno}(\sigma_{cno&#x3D;001}(SC))\cap\prod_{sno}(\sigma_{cno&#x3D;001}(SC))$</li>
<li>$\prod_{sno}(\sigma_{cno&#x3D;001\land cno&#x3D;002}(SC))$<ul>
<li>这种表示是<span style="color:red;font-weight:bold">错误</span>的，结果为空</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="笛卡尔积运算"><a href="#笛卡尔积运算" class="headerlink" title="笛卡尔积运算"></a>笛卡尔积运算</h3><ul>
<li>元组的连串（Concatenation）</li>
<li>$r&#x3D;(r_1,\cdots,r_n), s&#x3D;(s_1,\cdots,s_m)$</li>
<li>则 $r$ 与 $s$ 的连串定义为</li>
</ul>
<p>$$<br>\hat{rs}&#x3D;(r_1,\cdots,r_n,s_1,\cdots,s_m)<br>$$</p>
<ul>
<li>关系的笛卡尔积</li>
</ul>
<p>$$<br>R\times S&#x3D;\left{\hat{rs}|r\in R\land s\in S\right}<br>$$</p>
<ul>
<li>$R\times S$ 的度为 $R$ 与 $S$ 的度之和</li>
<li>$R\times S$ 的元组个数为 $R$ 与 $S$ 的元组个数的乘积</li>
<li>计算的一个例子</li>
</ul>
<img src="03-1/image-20210406155455129.png" style="zoom:80%;" />

<ul>
<li>包打天下：<strong>选择</strong>、<strong>投影</strong>、<strong>笛卡尔积</strong></li>
</ul>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h4><ul>
<li>求选修 c1 课程的学生姓名</li>
<li>两个表的连接</li>
<li>SN：student name</li>
</ul>
<p>$$<br>\prod_{SN}\left(\sigma_{S.sno&#x3D;SC.sno\land R.cno&#x3D;c1}(S\times SC)\right)<br>$$</p>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h4><ul>
<li>表 S</li>
</ul>
<table>
<thead>
<tr>
<th align="center">姓名</th>
<th align="center">课程</th>
<th align="center">成绩</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">a</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">b</td>
<td align="center">70</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">b</td>
<td align="center">90</td>
</tr>
</tbody></table>
<ul>
<li>另外一个例子：课程 b 成绩比 A 高的成员</li>
<li>自己和自己连接，更名</li>
</ul>
<p>$$<br>\prod_{S.姓名}\left(\sigma_{R.姓名&#x3D;A \land R.课程&#x3D;b\land S.课程&#x3D;b\land S.成绩&gt;R.成绩}(S\times\rho_R(S))\right)<br>$$</p>
<ul>
<li>如果要比较同一个表里的三行，则可能需要再乘一次</li>
</ul>
<h2 id="关系代数扩展运算"><a href="#关系代数扩展运算" class="headerlink" title="关系代数扩展运算"></a>关系代数扩展运算</h2><h3 id="theta-连接"><a href="#theta-连接" class="headerlink" title="$\theta$ 连接"></a>$\theta$ 连接</h3><ul>
<li>因为这个操作很常见，抽象成一个运算</li>
<li>从两个关系的<strong>广义笛卡尔积</strong>中选取给定<strong>属性间满足一定条件</strong>的元组</li>
</ul>
<p>$$<br>R{\bowtie\atop A\ \theta\ B}S&#x3D;\left{\hat{rs}|r\in R\land s\in S\land r[A]<br> \theta s[B]\ \right}<br>$$</p>
<ul>
<li>$\theta$ 为算术比较符，为<strong>等号</strong>时称为<strong>等值连接</strong></li>
<li>A, B 为 R 和 S 上度数相等且可比的属性列</li>
<li>例子：笛卡尔积运算的例子 2</li>
</ul>
<p>$$<br>\prod_{S.姓名}\left(\left(\sigma_{R.姓名&#x3D;A \land R.课程&#x3D;b}\right){\bowtie\atop R.成绩&lt;S.成绩}\left(\sigma_{S.课程&#x3D;b}\right)\right)<br>$$</p>
<h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><ul>
<li>从两个关系的广义笛卡儿积中选取在<strong>相同属性列 B 上取值相等</strong>的元组，并<strong>去掉重复的列</strong></li>
</ul>
<p>$$<br>R\bowtie S&#x3D;\left{\hat{rs}[\bar{B}]|r\in R\land s\in S\land r[B]&#x3D;s[B]\right}<br>$$</p>
<ul>
<li><p>自然连接与等值连接的不同</p>
<ul>
<li>自然连接中相等的分量必须是相同的属性组，并且要在结果中去掉重复的属性，而等值连接则不必</li>
<li>自然连接要求必须有公共的列，等值连接只要求可比</li>
</ul>
</li>
<li><p>自然连接非常有用</p>
<ul>
<li>实体之间的联系在自然连接之后能够合成一张表</li>
</ul>
</li>
<li><p>例子</p>
</li>
</ul>
<img src="03-1/image-20210406162724169.png" style="zoom:80%;" />

<ul>
<li>相同属性列的相同元素越多，结果行数越多<ul>
<li>如果全部相同，退化为笛卡尔积</li>
</ul>
</li>
<li>例子：求001号学生所在系的名称<ul>
<li>$\prod_{dname}(\sigma_{sno&#x3D;001}(S\bowtie dept))$</li>
<li>$\prod_{dname}((\sigma_{sno&#x3D;001}(S))\bowtie dept)$<ul>
<li>效率更高</li>
</ul>
</li>
</ul>
</li>
<li>一般而言，我们先做选择，再做连接<ul>
<li>先做连接可能出来很大的表</li>
</ul>
</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>关系 $R(A, B)$、$S(A, C)$、$R$ 与 $S$ 中元组个数分别为10，15</li>
<li><strong>不考虑空值的情况</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">条件</th>
<th align="center">表达式</th>
<th align="center">最小元组数</th>
<th align="center">最大元组数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">无任何条件</td>
<td align="center">$R\bowtie S$</td>
<td align="center">0<br/>（R 的 A 属性和 S 的 A 属性都不相等）</td>
<td align="center">150<br/>（都相等）</td>
</tr>
<tr>
<td align="center">无任何条件</td>
<td align="center">$\prod_{A}(R)\bigcup \prod_{A}(S)$</td>
<td align="center">1<br/>（都相等）</td>
<td align="center">25<br/>（都不相等）</td>
</tr>
<tr>
<td align="center">A 是 R 的主码</td>
<td align="center">$R\bowtie S$</td>
<td align="center">0<br />（R 的 A 属性和 S 的 A 属性都不相等）</td>
<td align="center">15<br />（S 里的一行最多只能够和 R 的一行连接）</td>
</tr>
<tr>
<td align="center">A 是 R 的主码</td>
<td align="center">$\prod_{A}(R)\bigcup \prod_{A}(S)$</td>
<td align="center">10</td>
<td align="center">25</td>
</tr>
<tr>
<td align="center">A 是 R 的主码<br />且 A 是 S 的外码</td>
<td align="center">$R\bowtie S$</td>
<td align="center">15<br />（外码）</td>
<td align="center">15<br />（S 里的一行最多只能够和 R 的一行连接）</td>
</tr>
<tr>
<td align="center">A 是 R 的主码<br />且 A 是 S 的外码</td>
<td align="center">$\prod_{A}(R)\bigcup \prod_{A}(S)$</td>
<td align="center">10<br />（外码 + 主码）</td>
<td align="center">10<br />（外码 + 主码）</td>
</tr>
</tbody></table>
<ul>
<li>A 是 R 的主码表示 A 中的 R 各不相同</li>
<li>A 是 S 的外码，则 S 在 A 上的取值必须在 R 的 A 上出现（参照完整性）</li>
</ul>
<h4 id="自然连接的问题"><a href="#自然连接的问题" class="headerlink" title="自然连接的问题"></a>自然连接的问题</h4><ul>
<li>如果某个元素在某个表中缺失的话，结果将会有些元素缺失</li>
<li>解决方案：<strong>外连接</strong></li>
</ul>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><ul>
<li><p>为避免自然连接时因失配而发生的信息丢失，可以<strong>假定往参与连接的一方表中附加一个取值全为空值的行</strong>，它和参与连接的另一方表中的任何一个未匹配上的元组都能匹配，称之为<strong>外连接</strong></p>
</li>
<li><p>外连接 &#x3D; 自然连接 + 未匹配元组（悬挂元组）</p>
</li>
<li><p>外连接的形式：<strong>左外连接</strong>、<strong>右外连接</strong>、<strong>全外连接</strong></p>
<ul>
<li>左外连接 &#x3D; 自然连接 + 左侧表中未匹配元组<ul>
<li>⟕</li>
</ul>
</li>
<li>右外连接 &#x3D; 自然连接 + 右侧表中未匹配元组<ul>
<li>⟖</li>
</ul>
</li>
<li>全外连接 &#x3D; 自然连接 + 两侧表中未匹配元组<ul>
<li>⟗</li>
</ul>
</li>
</ul>
</li>
<li><p>外连接不满足结合律</p>
</li>
</ul>
<h4 id="例子-1-1"><a href="#例子-1-1" class="headerlink" title="例子 1"></a>例子 1</h4><img src="03-1/image-20210406163333505.png" style="zoom:80%;" />



<h4 id="例子-2-1"><a href="#例子-2-1" class="headerlink" title="例子 2"></a>例子 2</h4><ul>
<li>外连接不满足结合律</li>
<li>这个例子的巧妙之处在于：AB、BC、CA</li>
</ul>
<img src="03-1/image-20210406170707244.png" style="zoom:80%;" />

<h3 id="半连接"><a href="#半连接" class="headerlink" title="半连接"></a>半连接</h3><ul>
<li>$R⋉S$<ul>
<li>提取出 R 里面<strong>能</strong>和 S 参与自然连接的那些行</li>
</ul>
</li>
<li>反半连接<ul>
<li>提取出 R 里面<strong>不能</strong>和 S 参与自然连接的那些行</li>
</ul>
</li>
</ul>
<img src="03-1/image-20210406171102917.png" style="zoom:80%;" />

<ul>
<li>反半连接的应用场景<ul>
<li>物理底层的 not in&#x2F;not exist 查询</li>
</ul>
</li>
<li>半连接的应用场景：<strong>减少分布式数据库的数据传输</strong></li>
</ul>
<img src="03-1/image-20210406171708087.png" style="zoom:80%;" />



<h3 id="外部并"><a href="#外部并" class="headerlink" title="外部并"></a>外部并</h3><ul>
<li>outer union</li>
<li>R(AB) outer join S(BC)<ul>
<li>在 B 上相同的行为合并成一行</li>
</ul>
</li>
</ul>
<img src="03-1/image-20210624162240468.png" style="zoom:50%;" />

<ul>
<li>子实体集合合并为父实体集合</li>
<li>例子：不同部门收集客户信息，然后将不同部门收集的信息整合起来</li>
<li>${\color{red}\mathrm{TODO}}$<ul>
<li>外部并和全外连接的区别？<strong>没啥区别</strong></li>
</ul>
</li>
</ul>
<h3 id="象集"><a href="#象集" class="headerlink" title="象集"></a>象集</h3><ul>
<li>除法</li>
<li>应用场景：找到选修了所有课程的同学<ul>
<li>涉及到<strong>所有</strong>、<strong>全部</strong>问题</li>
</ul>
</li>
<li>关系 $R(X,Z)$，$X,Z$ 是属性组，$x$ 是 $X$ 上的取值，定义 $x$ 在 $R$ 中的象集为</li>
</ul>
<p>$$<br>Z_x&#x3D;\left{t[Z]|t\in R\land t[X]&#x3D;x\right}<br>$$</p>
<ul>
<li>象集：先选择，后投影</li>
<li>从R 中选出在 X 上取值为 x 的元组，只留 Z 属性<ul>
<li>$Z_x$</li>
</ul>
</li>
</ul>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><ul>
<li>如何求得选修了全部课程的学生？</li>
</ul>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h5><ul>
<li>判断每个学生的课程象集是否包含了整个课程集合 C</li>
</ul>
<p>$$<br>\left{u|r\in SC\land u&#x3D;r[姓名]\land 课程名_{u}\supseteq C\right}<br>$$</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路 2"></a>思路 2</h5><ul>
<li>判断学生与课程集合构成的笛卡尔积是否完全包含在选课集合中</li>
</ul>
<p>$$<br>\left{u|u\in\prod_{姓名}(SC)\land\forall v\in C(\hat{uv}\in SC)\right}<br>$$</p>
<ul>
<li>理解图示</li>
</ul>
<img src="03-1/image-20210406175312104.png" style="zoom:80%;" />

<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><ul>
<li><strong>所有</strong>、<strong>全部</strong>、<strong>任意</strong>问题</li>
<li>定义表达式（2 种）<ul>
<li>上面提到的两种方式</li>
</ul>
</li>
</ul>
<p>$$<br>R(X,Y)\div S(Y)&#x3D;\left{x|r\in R\land x&#x3D;r[X]\land Y_x\supseteq S\right}<br>$$</p>
<p>$$<br>R(X,Y)\div S(Y)&#x3D;\left{u|u\in\prod_X(R)\land\forall v\in S(\hat{uv}\in R)\right}<br>$$</p>
<ul>
<li>计算表达式<ul>
<li>巧妙了</li>
<li>先计算出不存在的关系，如果有不存在的说明就不是完全</li>
</ul>
</li>
</ul>
<p>$$<br>R(X,Y)\div S(Y)&#x3D;\prod_X(R)-\prod_X\left(\prod_X(R)\times\prod_{Y}(S)-R\right)<br>$$</p>
<ul>
<li>减法计算<ul>
<li>补集：区分两类不同性质的子集</li>
<li>表结构必须相同</li>
</ul>
</li>
</ul>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><ul>
<li>SC(sno, cno, grade)</li>
<li>求选修了所有课程的学生<ul>
<li>方案1：$\prod_{sno,cno}(SC)\div \prod_{cno}(C)$</li>
<li>方案2：$\prod_{sno}(SC\div \prod_{cno}(C))$</li>
</ul>
</li>
<li><span style="color:red;font-weight:bold;">方案 2 是错误的</span><ul>
<li>除法的 X 表示 “课程+成绩”</li>
</ul>
</li>
</ul>
<img src="03-1/image-20210406231848054.png" style="zoom: 80%;" />



<h2 id="关系代数查询实例"><a href="#关系代数查询实例" class="headerlink" title="关系代数查询实例"></a>关系代数查询实例</h2><h3 id="求没有选修-c1-号课程的学生"><a href="#求没有选修-c1-号课程的学生" class="headerlink" title="求没有选修 c1 号课程的学生"></a>求没有选修 c1 号课程的学生</h3><ul>
<li><strong>没有</strong>：求补</li>
<li>所有学生 – 选修了c1号课程学生</li>
</ul>
<p>$$<br>\prod_{sno}(SC)-\prod_{sno}(\sigma_{cno&#x3D;c1}(SC))<br>$$</p>
<ul>
<li>$\prod_{sno}(\sigma_{cno\ne c1}(SC))$<ul>
<li>这是错误的</li>
<li>可能有人选了好几门课，注意这是对<strong>每条记录进行处理判断的</strong></li>
<li>这个表示的含义：仅选 c1 号课程之外的其他学生（类 2 + 类 3）<ul>
<li>选了其他不是 c1 的课的学生</li>
</ul>
</li>
<li>所有的人分为 3 类<ul>
<li>类1：只选了 c1（只选了一门课，就是 c1）</li>
<li>类2：没有选 c1 （选了课，但是没有选 c1）</li>
<li>类3：选了好几门课，其中有一门是 c1（至少选了两门课）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="求仅选修了-c1-号课程的学生号"><a href="#求仅选修了-c1-号课程的学生号" class="headerlink" title="求仅选修了 c1 号课程的学生号"></a>求仅选修了 c1 号课程的学生号</h3><ul>
<li>所有的学生－仅选 c1 号课程之外的学生<ul>
<li>所有的学生 - （类 2 + 类 3）</li>
</ul>
</li>
</ul>
<p>$$<br>\prod_{sno}(SC)-\prod_{sno}(\sigma_{cno\ne c1}(SC))<br>$$</p>
<ul>
<li>选修 c1 号课程的学生－仅选 c1 号课程之外的学生<ul>
<li>对上面的 3 类人进行判断</li>
</ul>
</li>
</ul>
<p>$$<br>\prod_{sno}(\sigma_{cno&#x3D;c1}(SC))-\prod_{sno}(SC-\sigma_{cno&#x3D;c1}(SC))<br>$$</p>
<ul>
<li>上面两个式子<strong>减去的部分</strong>等价</li>
</ul>
<h3 id="求选修-c1-课程比-s1-学生的该门课程成绩高的学生"><a href="#求选修-c1-课程比-s1-学生的该门课程成绩高的学生" class="headerlink" title="求选修 c1 课程比 s1 学生的该门课程成绩高的学生"></a>求选修 c1 课程比 s1 学生的该门课程成绩高的学生</h3><ul>
<li><p>sno, cno, G</p>
</li>
<li><p>笛卡尔积</p>
</li>
</ul>
<p>$$<br>\prod_{S.sno}\left(\sigma_{R.sno&#x3D;s1\land R.cno&#x3D;c1\land S.cno&#x3D;c1\land R.G&lt; S.G}\left(\rho_R(SC)\times\rho_S(SC)\right)\right)<br>$$</p>
<h3 id="求每门课程的先修课的先修课"><a href="#求每门课程的先修课的先修课" class="headerlink" title="求每门课程的先修课的先修课"></a>求每门课程的先修课的先修课</h3><ul>
<li>cno, pcno</li>
<li>递归查询</li>
</ul>
<p>$$<br>\prod_{C.cno,R.pcno}\left(\sigma_{C.pcno&#x3D;R.cno}\left(C\times\rho_R(C)\right)\right)<br>$$</p>
<ul>
<li>怎么查找所有的祖辈先修课？<ul>
<li>传递闭包</li>
<li>从关系完备性来讲，我们目前的关系运算符是不够完备的，不能够表示这种运算</li>
<li>现在的主流数据库是支持递归查询的</li>
</ul>
</li>
</ul>
<h3 id="求选修了至少两门课的学生"><a href="#求选修了至少两门课的学生" class="headerlink" title="求选修了至少两门课的学生"></a>求选修了至少两门课的学生</h3><ul>
<li>sno, cno, G</li>
</ul>
<p>$$<br>\prod_{R.sno}\left(\sigma_{R.sno&#x3D;S.sno\land R.cno\ne S.cno\left(\rho_R(SC)\times\rho_S(SC)\right)}\right)<br>$$</p>
<ul>
<li>求选修了至少 N 门课的学生<ul>
<li>${n \choose2}$ 个不等号</li>
</ul>
</li>
<li>求只选修了 1 门课的学生<ul>
<li>所有同学 - 至少选修了两门课的同学</li>
</ul>
</li>
</ul>
<h3 id="求最低的成绩"><a href="#求最低的成绩" class="headerlink" title="求最低的成绩"></a>求最低的成绩</h3><ul>
<li>sno, cno, G</li>
<li>笛卡尔积</li>
</ul>
<p>$$<br>\prod_G(SC)-\prod_{S.G}\left(\sigma_{R.G&lt;S.G}\left(\rho_R(SC)\times\rho_S(SC)\right)\right)<br>$$</p>
<ul>
<li>小于等于好像不行，多个值的时候会变成空集</li>
</ul>
<h3 id="求选修课程中包含了所有-S01-号学生所选修课程的学生号"><a href="#求选修课程中包含了所有-S01-号学生所选修课程的学生号" class="headerlink" title="求选修课程中包含了所有 S01 号学生所选修课程的学生号"></a>求选修课程中包含了所有 S01 号学生所选修课程的学生号</h3><ul>
<li>cno, sno</li>
<li>除法</li>
</ul>
<p>$$<br>\prod_{cno,sno}(SC)\div\prod_{cno}(\sigma_{sno&#x3D;S01}(SC))<br>$$</p>
<h3 id="找出一直上涨的股票"><a href="#找出一直上涨的股票" class="headerlink" title="找出一直上涨的股票"></a>找出一直上涨的股票</h3><ul>
<li>stock(sno, date, price)</li>
<li>上涨过的股票</li>
</ul>
<p>$$<br>\prod_{R,sno}\left(\sigma_{R.sno&#x3D;S.sno\land R.date&gt;S.date\land R.price&gt;S.price}\left(\rho_R(stock)\times\rho_S(stock)\right)\right)<br>$$</p>
<ul>
<li>一直上涨的股票<ul>
<li>持续上涨的股票 &#x3D; 所有股票 -下跌过的股票</li>
</ul>
</li>
</ul>
<h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><ul>
<li>guanxi(source,destination)</li>
<li>可交换的</li>
<li><strong>序列号可比</strong></li>
</ul>
<img src="03-1/image-20210407002232950.png" style="zoom:70%;" />
$$
guanxi-\prod_{S.S,S.D}\left(\sigma_{R.D=S.S\land R.S=S.D\land R.S<S.S}\left(\rho_R(guanxi)\times\rho_S(guanxi)\right)\right)
$$




<h2 id="关系代数更新运算"><a href="#关系代数更新运算" class="headerlink" title="关系代数更新运算"></a>关系代数更新运算</h2><h3 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h3><ul>
<li>为使查询表达简单、清晰，可以将一个复杂关系代数表达式分成几个部分</li>
<li>每一部分都赋予一个临时关系变量</li>
<li>该变量可被看作关系而在后续表达式中使用</li>
<li>临时关系变量 $\leftarrow$ 关系代数表达式</li>
<li>尽可能在一个表达式内写完</li>
</ul>
<h3 id="广义投影"><a href="#广义投影" class="headerlink" title="广义投影"></a>广义投影</h3><ul>
<li>在投影列表中使用算术表达式来对投影进行扩展</li>
</ul>
<p>$$<br>\prod_{F_1,F_2,\cdots,F_n}(E),\ F_i是算术表达式<br>$$</p>
<h3 id="数据库修改：删除"><a href="#数据库修改：删除" class="headerlink" title="数据库修改：删除"></a>数据库修改：删除</h3><ul>
<li>将满足条件的元组从关系中删除</li>
<li>$R\leftarrow R-E$</li>
<li>是对永久关系的赋值运算</li>
</ul>
<h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><ul>
<li>删除 001 号老师所担任的课程</li>
</ul>
<p>$$<br>PC\leftarrow PC-\sigma_{pno&#x3D;001}(PC)<br>$$</p>
<ul>
<li>删除没有选课的学生<ul>
<li>注意减法的表结构必须相同</li>
</ul>
</li>
</ul>
<p>$$<br>S\leftarrow S-\left(\prod_{sno}(S)-\prod_{sno}(SC)\right)\bowtie S<br>$$</p>
<h3 id="数据库修改：插入"><a href="#数据库修改：插入" class="headerlink" title="数据库修改：插入"></a>数据库修改：插入</h3><ul>
<li>插入一个指定的元组，或者插入一个查询结果</li>
</ul>
<p>$$<br>R\leftarrow R\ \bigcup E<br>$$</p>
<h4 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h4><ul>
<li>加入计算机系学生选修 “数据结构” 的信息</li>
<li>SC: sno,cno,G（学号、课程、成绩）</li>
</ul>
<p>$$<br>SC\leftarrow SC\bigcup\left(\prod_{sno}\left(S\bowtie\sigma_{dname&#x3D;”计算机系”}(DEPT)\right)\times \prod_{cno}\left(\sigma_{name&#x3D;”数据结构”}(C)\right)\times{\color{red}{null}}\right)<br>$$</p>
<ul>
<li>缺少成绩信息，一个 trick，和一个 <code>null</code> 属性相乘（笛卡尔积）</li>
</ul>
<h3 id="数据库修改：更新"><a href="#数据库修改：更新" class="headerlink" title="数据库修改：更新"></a>数据库修改：更新</h3><ul>
<li>利用广义投影改变元组的某些属性上的值</li>
</ul>
<p>$$<br>\prod_{F_1,F_2,\cdots,F_n}(E)<br>$$</p>
<h4 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h4><ul>
<li>给每位老师上调 10% 的工资</li>
</ul>
<p>$$<br>PROF\leftarrow \prod_{pno,pname,sal\leftarrow sal*1.1,dno}\left(PROF\right)<br>$$</p>
<ul>
<li>对工资超过 3000 的老师征收 5% 所得税</li>
</ul>
<p>$$<br>PROF\leftarrow \left(\prod_{pno,pname,sal\leftarrow sal*1.1,dno}\left(\sigma_{sal&gt;3000}PROF\right)\right){\color{red}\bigcup\left(\sigma_{sal\le 3000}(PROF)\right)}<br>$$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/02/DB/CLJ/03-1/" data-id="cl9lj74ar00eo64tzfbkn7rog" data-title="数据库概论.陈立军.03.关系模型(2)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/CLJ/03" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/02/DB/CLJ/03/" class="article-date">
  <time class="dt-published" datetime="2021-04-02T09:48:17.000Z" itemprop="datePublished">2021-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/02/DB/CLJ/03/">数据库概论.陈立军.03.关系模型(1)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><ul>
<li>简单即是有力</li>
</ul>
<h2 id="关系模型基本概念"><a href="#关系模型基本概念" class="headerlink" title="关系模型基本概念"></a>关系模型基本概念</h2><ul>
<li>Table<ul>
<li>An arrangement of words, numbers, orsigns, or combinations of them, as in parallel columns, to exhibit a set off acts or relations in a definite, compact, and comprehensive form; a synopsis or scheme.</li>
</ul>
</li>
</ul>
<h3 id="关系模型的诞生"><a href="#关系模型的诞生" class="headerlink" title="关系模型的诞生"></a>关系模型的诞生</h3><ul>
<li>E.F.Codd 于 70 年代初提出关系数据理论，他因此获得 1981 年的 ACM 图灵奖<ul>
<li>1970: “A Relational Model of data for Large Shared Data Banks”</li>
</ul>
</li>
<li>提出关系代数和关系演算</li>
<li>1972：1NF, 2NF, 3NF</li>
<li>1974：BCNF</li>
<li><strong>关系理论</strong>建立在<strong>集合代数理论基础</strong>之上，有着坚实的数学基础</li>
</ul>
<h3 id="早期代表系统"><a href="#早期代表系统" class="headerlink" title="早期代表系统"></a>早期代表系统</h3><ul>
<li>SystemＲ：由 IBM 研制</li>
<li>INGRES：由加州 Berkeley 分校研制</li>
</ul>
<h3 id="数据库与图灵奖"><a href="#数据库与图灵奖" class="headerlink" title="数据库与图灵奖"></a>数据库与图灵奖</h3><ul>
<li>数据库有 4 位获得图灵奖的人</li>
<li>Charles W. Bachman（查尔斯 • 巴赫曼）<ul>
<li>1973 主持设计与开发了最早的<strong>网状</strong>数据库管理系统 IDS</li>
</ul>
</li>
<li>Edgar F. Codd（埃德加 • 科德）<ul>
<li>1981 提出了<strong>关系数据库</strong></li>
</ul>
</li>
<li>James Gray（詹姆斯 • 格雷）<ul>
<li>1998 解决保障数据的完整性、安全性、并行性，以及从故障恢复方面发挥了十分关键的作用，提出并实现数据库事务处理</li>
</ul>
</li>
<li>Michael Stonebraker（迈克尔.斯通布雷克）<ul>
<li>2014 创造了数据库系统一系列奠基性基本概念和实际技术</li>
<li>基于 INGRES</li>
</ul>
</li>
</ul>
<h3 id="目前主流的商业数据库系统"><a href="#目前主流的商业数据库系统" class="headerlink" title="目前主流的商业数据库系统"></a>目前主流的商业数据库系统</h3><ul>
<li>Oracle, SQLServer, DB2</li>
<li>开源数据库：MySQL, PostgreSQL</li>
<li>OceanBase, GaussDB, 达梦<ul>
<li>GaussDB 基于 PostgreSQL：华为</li>
<li>达梦：武大</li>
<li>OceanBase：阿里</li>
</ul>
</li>
<li>Access, SQLite<ul>
<li>SOLite 装机量最大，手机上都有</li>
</ul>
</li>
</ul>
<h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><strong>域</strong>（Domain）<ul>
<li>具有相同数据类型的一组值的集合</li>
<li>如整数集合、字符串集合、全体学生集合</li>
</ul>
</li>
<li>一组域 $D_1,D_1,\cdots,D_n$ 的<strong>笛卡尔积</strong></li>
</ul>
<p>$$<br>D_1\times D_2\times\cdots\times D_n&#x3D;\left{(d_1,d_2,\cdots,d_n)|d_i\in D_i,i&#x3D;1,2,\cdots,n\right}<br>$$</p>
<ul>
<li>n <strong>元组</strong>（tuple）：笛卡尔积的元素 $(d_1,d_2,\cdots,d_n)$</li>
<li>元组的每个值 $d_i$ 称作<strong>分量</strong>（component）</li>
<li>若 $D_i$ 的基数为 $m_i$，则笛卡尔积的<strong>基数</strong>为 $\prod_{i&#x3D;1}^{n}m_i$</li>
<li>笛卡尔积可以表示为<strong>二维表</strong>的形式<ul>
<li>每一列表示一个分量</li>
</ul>
</li>
<li><strong>关系</strong>：笛卡尔积的子集<ul>
<li>笛卡尔积 $D_1\times D_2\times\cdots\times D_n$ 的<strong>子集</strong>称作在域  $D_1,D_2,\cdots,D_n$  上的<strong>关系</strong><br>  用 $R(D_1,D_2,\cdots,D_n)$ 表示</li>
<li>$R$ 是关系的名字，$n$ 是关系的<strong>度</strong>或<strong>目</strong></li>
</ul>
</li>
</ul>
<h4 id="笛卡尔积与关系"><a href="#笛卡尔积与关系" class="headerlink" title="笛卡尔积与关系"></a>笛卡尔积与关系</h4><ul>
<li>笛卡尔积：<strong>可能的世界</strong></li>
<li>关系：<strong>实际的世界</strong></li>
<li>关系是笛卡尔积中有意义的子集<ul>
<li>有意义：子集得有名字</li>
<li>名称不一样，反应的现实中的关系也不一样</li>
<li>例子<ul>
<li>Teach（老师、学生、课程）：老师教授课程</li>
<li>Assistant（老师、学生、课程）：学生给老师当助教</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h4><ul>
<li><p>$D_1,D_2,D_3$ 的基数分别为 $d_1,d_2.d_3$，则 $D_1\times D_2\times D_3$ 包含的关系数目</p>
<ul>
<li>笛卡尔积元组个数：$d_1\times d_2\times d_3$</li>
</ul>
</li>
<li><p>关系数目：$2^{d_1\times d_2\times d_3}$</p>
</li>
<li><p>13 个元素的集合，划分为多少个域，每个域多少个元素，使得笛卡尔积包含的关系数目最多</p>
<ul>
<li>4 x 3 x 3 x 3 &#x3D; 108</li>
<li>关系数目：$2^{108}$</li>
</ul>
</li>
</ul>
<h3 id="关系的性质"><a href="#关系的性质" class="headerlink" title="关系的性质"></a>关系的性质</h3><ul>
<li>列是<strong>同质</strong>的，是<strong>同一类型的数据</strong>，即每一列中的分量来自同一域</li>
<li>不同的列可以来自同一域，每列必须有不同的属性名<ul>
<li>一元联系</li>
</ul>
</li>
<li>行列的顺序无关紧要</li>
<li>任意两个元组不能完全相同（集合内不能有相同的两个元素）<ul>
<li>实际的数据库的表允许重复行的存在</li>
</ul>
</li>
<li><strong>每一分量必须是不可再分的数据</strong>，称其为作满足第一范式（1NF）的关系</li>
</ul>
<img src="03/image-20210402205215019.png" style="zoom:80%;" />

<ul>
<li>从查询的角度，深入分析嵌套关系的利弊<ul>
<li>如果查询某个学生选修的课程哪些<ul>
<li>嵌套关系性能更高，直接通过学号索引就行</li>
<li>1NF 关系需要先对学号过滤，再取出来课程</li>
</ul>
</li>
<li>如果查询选修的某个课程的学生有哪些<ul>
<li>嵌套关系没办法直接表达（无法使用声明式查询，需要编程进行路径式查询）</li>
<li>1NF 各种属性的查询没有区别</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="关系模型-3-要素"><a href="#关系模型-3-要素" class="headerlink" title="关系模型 3 要素"></a>关系模型 3 要素</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>单一的数据结构：<strong>关系</strong><ul>
<li>实体集、联系都表示成关系</li>
</ul>
</li>
<li>单一的数据结构好处是什么<ul>
<li>实现数据库的时候，只需要实现一种数据结构</li>
</ul>
</li>
</ul>
<h4 id="码"><a href="#码" class="headerlink" title="码"></a>码</h4><ul>
<li><strong>候选码</strong>（Candidate Key）<ul>
<li>关系中的一个属性组，其值能唯一标识一个元组</li>
<li>若从属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称作候选码</li>
</ul>
</li>
<li><strong>任何一个候选码</strong>中的属性称作<strong>主属性</strong><ul>
<li>主属性：<strong>存在</strong>一个候选码包含这个属性</li>
</ul>
</li>
<li><strong>主码</strong>（PK: Primary Key）<ul>
<li>进行数据库设计时，从一个关系的多个<strong>候选码</strong>中<strong>选定一个</strong>作为主码</li>
</ul>
</li>
<li><strong>外码</strong>（FK: Foreign Key）<ul>
<li>关系 R 中的一个属性组，它不是 R 的码，但它与另一个关系 S 的码相对应，称这个属性组为 R 的外码</li>
<li>反映实体之间的联系</li>
</ul>
</li>
</ul>
<h4 id="关系模式与关系"><a href="#关系模式与关系" class="headerlink" title="关系模式与关系"></a>关系模式与关系</h4><h5 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h5><ul>
<li>关系的描述，记作 $R(A_1,A_2,\cdots,A_n)$ 包括：<ul>
<li><strong>关系名</strong>、<strong>关系中的属性名</strong></li>
<li>属性向域的<strong>映象</strong>，通常说明为属性的类型、长度等</li>
<li>属性间的<strong>数据依赖</strong>关系<ul>
<li>比如在特定的时间和教室只能安排一门课</li>
</ul>
</li>
</ul>
</li>
<li><strong>关系模式</strong>是<strong>型</strong>，是<strong>稳定</strong>的</li>
</ul>
<h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><ul>
<li>某一时刻对应某个关系模式的内容（元组的集合）</li>
<li><strong>关系</strong>是<strong>某一时刻的值</strong>，是<strong>随时间不断变化</strong>的</li>
</ul>
<h4 id="关系数据库的构成"><a href="#关系数据库的构成" class="headerlink" title="关系数据库的构成"></a>关系数据库的构成</h4><ul>
<li>关系数据库的<strong>型</strong><ul>
<li>是<strong>关系模式</strong>的集合，即数据库描述</li>
<li>称作数据库的<strong>内涵</strong>（Intension）</li>
</ul>
</li>
<li>关系数据库的<strong>值</strong><ul>
<li>是<strong>某一时刻关系</strong>的集合</li>
<li>称作数据库的<strong>外延</strong>（Extension）</li>
</ul>
</li>
</ul>
<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><h4 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h4><ul>
<li>关系操作是<strong>集合操作</strong></li>
<li>操作的对象及结果都是集合</li>
<li>是<strong>一次一集合</strong>（Set-at-a-time）的方式<ul>
<li>非关系型的数据操作方式是<strong>一次一记录</strong> （Record-at-a-time）</li>
</ul>
</li>
</ul>
<h4 id="关系数据语言的特点"><a href="#关系数据语言的特点" class="headerlink" title="关系数据语言的特点"></a>关系数据语言的特点</h4><ul>
<li><strong>一体化</strong><ul>
<li>对象单一，都是关系，因此操作符也单一</li>
</ul>
</li>
<li><strong>非过程化</strong><ul>
<li>用户只需提出 “做什么”，无须说明 “怎么做”</li>
<li>存取路径的选择和操作过程由系统自动完成</li>
</ul>
</li>
<li><strong>面向集合的存取方式</strong><ul>
<li>操作对象是一个或多个关系，结果是一个新的关系（一次一关系）</li>
</ul>
</li>
</ul>
<h4 id="抽象的关系模型查询语言"><a href="#抽象的关系模型查询语言" class="headerlink" title="抽象的关系模型查询语言"></a>抽象的关系模型查询语言</h4><ul>
<li>关系代数（主流）</li>
<li>关系演算<ul>
<li>元组关系演算</li>
<li>域关系演算</li>
</ul>
</li>
</ul>
<h5 id="关系演算"><a href="#关系演算" class="headerlink" title="关系演算"></a>关系演算</h5><ul>
<li>用<strong>谓词</strong>来表达查询，只需描述所需信息的特性</li>
<li>元组关系演算<ul>
<li>谓词变元的<strong>基本对象</strong>是<strong>元组变量</strong></li>
</ul>
</li>
<li>域关系演算<ul>
<li>谓词变元的<strong>基本对象</strong>是<strong>域变量</strong></li>
</ul>
</li>
</ul>
<h5 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h5><ul>
<li>用<strong>对关系的运算</strong>来表达查询</li>
<li>需要指明所用操作</li>
<li>相比关系演算，关系代数是过程性操作语言<ul>
<li>这里的过程性指的是需要人为地把<strong>关系序列</strong>定义出来<ul>
<li>和之前的过程性查询不是一个概念</li>
</ul>
</li>
<li>而关系演算只是通过一系列谓词来描述</li>
</ul>
</li>
</ul>
<h5 id="具体系统中的关系操作语言"><a href="#具体系统中的关系操作语言" class="headerlink" title="具体系统中的关系操作语言"></a>具体系统中的关系操作语言</h5><ul>
<li>SQL<ul>
<li>介于关系代数和关系演算之间</li>
<li>由 IBM 公司在研制 System R 时提出</li>
</ul>
</li>
<li>QUEL<ul>
<li>基于 Codd 提出的<strong>元组关系演算</strong>语言 ALPHA</li>
<li>在 INGRES 上实现</li>
</ul>
</li>
<li>QBE<ul>
<li>基于<strong>域关系</strong>演算</li>
<li>由 IBM 公司研制</li>
</ul>
</li>
</ul>
<h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><ul>
<li><strong>实体完整性</strong>、<strong>参照完整性</strong>、<strong>用户定义完整性</strong></li>
</ul>
<h4 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h4><ul>
<li>关系的主码中的属性值不能为空值</li>
<li>意义：关系对应到现实世界中的实体集，元组对应到实体，<strong>实体是相互可区分的</strong>，通过主码来唯一标识，若主码为空，则出现不可标识的实体，这是不容许的</li>
<li>三值逻辑</li>
</ul>
<h4 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h4><ul>
<li>相对于外码而言的</li>
<li>如果关系 $R_2$ 的外码 $F_k$ 与关系 $R_1$ 的主码 $P_k$ 相对应，则 $R_2$ 中每个元组的 $F_k$ 值或者等于 <strong>$R_1$ 中某个元组的 $P_k$ 值</strong>，或者为<strong>空值</strong><ul>
<li>空值是允许的，可以认为是未分配、不知道</li>
</ul>
</li>
<li>如果关系 $R_2$ 的某个元组 $t_2$ 参照了关系 $R_1$ 的某个元组 $t_1$，则 $t_1$ 必须存在，也即必须与客观存在的实体发生联系</li>
</ul>
<h4 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h4><ul>
<li>用户针对具体应用环境定义的完整性约束条件</li>
<li>数据库应该支持这些功能，否则对应用程序言而言，就需要它自己去判断</li>
</ul>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul>
<li>实体完整性和参照完整性由系统自动支持</li>
<li>系统提供定义和检验用户定义的完整性的机制</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/02/DB/CLJ/03/" data-id="cl9lj74ar00ej64tzeascdgme" data-title="数据库概论.陈立军.03.关系模型(1)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/YLQ-GAMES202/03" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/02/CG/YLQ-GAMES202/03/" class="article-date">
  <time class="dt-published" datetime="2021-04-02T07:13:51.000Z" itemprop="datePublished">2021-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES202/">CG.GAMES202</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/02/CG/YLQ-GAMES202/03/">GAMES202.闫令琪.03.实时阴影(1)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY">https://www.bilibili.com/video/BV1YK4y1T7yY</a></li>
</ul>
<h1 id="Real-Time-Shadows"><a href="#Real-Time-Shadows" class="headerlink" title="Real-Time Shadows"></a>Real-Time Shadows</h1><ul>
<li>实时阴影</li>
</ul>
<h2 id="Shadow-Mapping"><a href="#Shadow-Mapping" class="headerlink" title="Shadow Mapping"></a>Shadow Mapping</h2><ul>
<li>SM</li>
<li>经典的两趟算法<ul>
<li>2-pass</li>
</ul>
</li>
</ul>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul>
<li>第一遍渲染，转换到以光源为视点的观察坐标系，记录下深度图</li>
<li>第二遍正常渲染，对每个点，转换到以光源为视点的观察坐标系中判断可见性<ul>
<li>判断可见性的时候深度一致即可，可以使用原来的线性距离或者投影之后的 z 值</li>
</ul>
</li>
</ul>
<h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><ul>
<li>图像空间的算法</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>绘制阴影的时候，不需要知道场景的几何信息</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>artifacts<ul>
<li>self occlusion 自遮挡</li>
<li>aliasing 走样</li>
</ul>
</li>
</ul>
<h3 id="自遮挡问题"><a href="#自遮挡问题" class="headerlink" title="自遮挡问题"></a>自遮挡问题</h3><ul>
<li>self occlusion</li>
</ul>
<img src="03/image-20210407160110616.png" style="zoom: 33%;" />

<ul>
<li>地板上的平面出现了自遮挡现象</li>
<li>由于数值精度造成的（分辨率）<ul>
<li>shadow map 精度有限，投射出去就是图中的红色小片</li>
<li>例如蓝色的视线应该是能看到红色的部分的，但是由于精度问题，shadow map 中记录的是橙色的值，导致我们判断红色部分不可见，从而产生自遮挡现象</li>
</ul>
</li>
</ul>
<img src="03/image-20210407160246926.png" style="zoom:67%;" />

<ul>
<li>如果光线和物体表面垂直，此时没有这个问题<ul>
<li>光线和法线重合</li>
</ul>
</li>
<li>如果光线和物体表面成一个很小的角度时，自遮挡问题很严重<ul>
<li>光线和法线夹角很大</li>
<li>grazing angle</li>
</ul>
</li>
</ul>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>增加一个 bias</li>
<li>中间的黄色那段我们不算<ul>
<li>也就是说我们对计算得到的深度减去一个 bias</li>
</ul>
</li>
</ul>
<img src="03/image-20210407161249651.png" style="zoom:50%;" />

<ul>
<li>一些技巧：动态的 bias<ul>
<li>当光线和物体表面法线夹角比较大时，bias 也需要比较大</li>
<li>当光线和物体表面法线夹角比较小时，bias 比较小即可</li>
</ul>
</li>
</ul>
<h4 id="引入-bias-带来的问题"><a href="#引入-bias-带来的问题" class="headerlink" title="引入 bias 带来的问题"></a>引入 bias 带来的问题</h4><ul>
<li>detached shadow<ul>
<li>不接触的阴影</li>
</ul>
</li>
<li>鞋子部分的阴影消失了</li>
</ul>
<img src="03/image-20210407161700013.png" style="zoom: 33%;" />

<ul>
<li>工业界 100% 解决这个问题的方法现在还没有<ul>
<li>解决方法还是通过找一个合适的 bias，让自遮挡和detached shadow 都不出现</li>
<li>最简单的方式</li>
</ul>
</li>
<li>学术界的方法（工业界用的人少）<ul>
<li>second-depth shadow mapping</li>
</ul>
</li>
</ul>
<h4 id="second-depth-shadow-mapping"><a href="#second-depth-shadow-mapping" class="headerlink" title="second-depth shadow mapping"></a>second-depth shadow mapping</h4><ul>
<li>不使用 bias</li>
<li>记录最小深度的同时，还记录第二小的深度</li>
<li>实际比较的时候使用这两个深度的平均值<ul>
<li>能够解决之前的问题</li>
</ul>
</li>
</ul>
<img src="03/image-20210407163438738.png" style="zoom:50%;" />

<ul>
<li>这个方法的问题<ul>
<li>每个物体都得是一个几何实体<ul>
<li>不能是一张平面，如果是一张纸的话，得描述成一个很扁的长方体</li>
</ul>
</li>
<li>实现这个算法很困难，复杂度没有变化，但是无法并行</li>
</ul>
</li>
<li>一些 trick<ul>
<li>如果是<strong>最外层</strong>的地板，在做第一趟渲染深度图的时候不渲染地板</li>
</ul>
</li>
<li>实时渲染不相信复杂度，只相信实时运行的速度<ul>
<li>RTR does not trust in COMPLEXITY</li>
<li>常数也很重要</li>
</ul>
</li>
</ul>
<h3 id="走样问题"><a href="#走样问题" class="headerlink" title="走样问题"></a>走样问题</h3><ul>
<li>阴影分辨率的问题</li>
<li>高端的做法<ul>
<li>给不同位置不同的分辨率</li>
</ul>
</li>
<li>软影</li>
</ul>
<h2 id="SM-的数学原理"><a href="#SM-的数学原理" class="headerlink" title="SM 的数学原理"></a>SM 的数学原理</h2><h3 id="常用不等式"><a href="#常用不等式" class="headerlink" title="常用不等式"></a>常用不等式</h3><ul>
<li>Schwarz Inequality<ul>
<li>施瓦茨不等式</li>
</ul>
</li>
</ul>
<p>$$<br>\left[\int_a^bf(x)g(x)dx\right]^2\le\int_a^bf^2(x)dx\cdot \int_a^bg^2(x)dx<br>$$</p>
<ul>
<li>Minkowski Inequality<ul>
<li>明可夫斯基不等式</li>
</ul>
</li>
</ul>
<p>$$<br>\left[\int_a^b\left[f(x)+g(x)\right]^2dx\right]^{\frac{1}{2}}\le\left[\int_a^bf^2(x)dx\right]^{\frac{1}{2}}\cdot \left[\int_a^bg^2(x)dx\right]^{\frac{1}{2}}<br>$$</p>
<ul>
<li>实时渲染中我们关心<strong>约等</strong>，而不是<strong>不等</strong><ul>
<li>在近似条件下<strong>约等</strong></li>
</ul>
</li>
</ul>
<h3 id="RTR-中的一个常用近似"><a href="#RTR-中的一个常用近似" class="headerlink" title="RTR 中的一个常用近似"></a>RTR 中的一个常用近似</h3><p>$$<br>{\color{red}\int_\Omega f(x)g(x)dx\approx \dfrac{\int_\Omega f(x)dx}{\int_\Omega dx}\cdot {\int_\Omega g(x)dx}}<br>$$</p>
<ul>
<li>分母的部分表示归一化常数<ul>
<li>例如 $f(x)&#x3D;2$</li>
</ul>
</li>
<li>什么时候近似正确呢？（满足一个条件即可）<ul>
<li>small support<ul>
<li>$g(x)$ 的积分域很小的时候</li>
</ul>
</li>
<li>smooth integrand<ul>
<li>$g(x)$ 在积分域内变化不大</li>
<li>图形学学术界中的 smooth：min、max 差别不大</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="应用于渲染方程"><a href="#应用于渲染方程" class="headerlink" title="应用于渲染方程"></a>应用于渲染方程</h4><ul>
<li>忽略自发光</li>
</ul>
<p>$$<br>L_o(p,\omega_o)&#x3D;<br>\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)V(p,\omega_i)\cos\theta_id\omega_i<br>$$</p>
<ul>
<li>利用上面的近似</li>
</ul>
<p>$$<br>L_o(p,\omega_o)\approx<br>\dfrac{\int_{\Omega^+}V(p,\omega_i)d\omega_i}{\int_{\Omega^+}d\omega_i}\cdot\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)\cos\theta_id\omega_i<br>$$</p>
<ul>
<li>这样子的近似把可见性从 shading 部分抽离出来了<ul>
<li>我们做 shadow mapping 方法的原理</li>
</ul>
</li>
</ul>
<h4 id="shadow-mapping-的原理"><a href="#shadow-mapping-的原理" class="headerlink" title="shadow mapping 的原理"></a>shadow mapping 的原理</h4><ul>
<li>什么时候是准确的？</li>
<li>small support<ul>
<li>积分范围只有一个点 $\to$ 点光源、方向光源</li>
<li>做硬阴影的数学基础</li>
</ul>
</li>
<li>smooth integrand<ul>
<li>diffuse bsdf &#x2F; constant radiance area lighting</li>
<li>diffuse BSDF + 面光源</li>
<li>解释 shadow mapping 算法不适合的场景<ul>
<li>环境光照（可以理解为超级大的面光源）+ glossy  BRDF</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="PCSS"><a href="#PCSS" class="headerlink" title="PCSS"></a>PCSS</h2><ul>
<li>Percentage Closer Soft Shadows</li>
<li>生成软阴影的一种算法</li>
</ul>
<h3 id="软阴影"><a href="#软阴影" class="headerlink" title="软阴影"></a>软阴影</h3><p><img src="/03/image-20210407171749439.png"></p>
<ul>
<li>生活中的现象：太阳<ul>
<li>半影</li>
</ul>
</li>
</ul>
<img src="03/image-20210407172053852.png" style="zoom:67%;" />



<h3 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h3><ul>
<li><p>Percentage Closer Filtering</p>
</li>
<li><p>这个技术是用于于抗锯齿的，而不是用于生成软阴影的（PCSS 是用于生成软阴影的）</p>
</li>
<li><p>Filtering the results of shadow comparisons</p>
<ul>
<li>先采样，后做平均（filter）</li>
</ul>
</li>
<li><p>为什么不能先对 SM 做 filter，后采样？</p>
<ul>
<li>Texture filtering just averages color components, i.e. you’ll get blurred shadow map first</li>
<li>Averaging depth values, then comparing, you still get a binary visibility</li>
<li>这样的操作最后得到的结果还是非 0 即 1 的，没有意义</li>
</ul>
</li>
<li><p>原来判断一个点的可见性是直接做一次判断</p>
<ul>
<li>shading point 和在深度图中对应位置记录的深度值作比较</li>
</ul>
</li>
<li><p>PCF 的想法是对其周围的几个点都做阴影判断，最后把得到的结果平均起来</p>
<ul>
<li>shading point 和在深度图中对应位置周围的几个点的深度作比较</li>
<li>最后得到的可见性是一个 0 - 1 之间的值</li>
<li><strong>可以加权</strong></li>
</ul>
</li>
</ul>
<img src="03/image-20210407173321583.png" style="zoom:50%;" />

<ul>
<li>PCF 的结果</li>
</ul>
<p><img src="/03/image-20210407173924706.png"></p>
<ul>
<li>时间开销：变成原来的 k 倍（k 为核的大小）</li>
<li>filter size<ul>
<li>small：sharper</li>
<li>large：softer</li>
<li>决定分辨率，核越大，量化越细</li>
</ul>
</li>
<li>核的大小应该怎么确定？</li>
<li>核的大小决定了阴影的软硬程度，根据阴影的软硬需求动态调整核的大小</li>
</ul>
<h3 id="PCSS-1"><a href="#PCSS-1" class="headerlink" title="PCSS"></a>PCSS</h3><ul>
<li>PCF 的思想，动态调整核的大小</li>
<li>什么地方需要硬阴影，什么地方需要硬阴影？</li>
<li><strong>遮挡物和阴影的距离</strong><ul>
<li>距离越大，阴影越软</li>
<li>距离越小，阴影越硬</li>
</ul>
</li>
</ul>
<img src="03/image-20210407175007126.png" style="zoom:50%;" />

<ul>
<li>根据上面的启发，定义一个距离函数，通过这个距离函数计算核的大小<ul>
<li>Filter size &lt;-&gt; blocker distance</li>
<li>More accurately, <strong>relative</strong> <strong>average</strong> projected blocker depth!</li>
</ul>
</li>
</ul>
<img src="03/image-20210407175256445.png" style="zoom: 40%;" />

<ul>
<li>根据相似三角形<ul>
<li>penumbra：半影</li>
</ul>
</li>
</ul>
<p>$$<br>w_{penumbra}&#x3D;\dfrac{d_{Receiver}-d_{Blocker}}{d_{Blocker}}\cdot w_{Light}<br>$$</p>
<ul>
<li>这个式子也符合我们生活中的观察<ul>
<li>Blocker 离 Receiver 越近，那么阴影越硬（$w_{penumbra}$ 越小）</li>
</ul>
</li>
<li>$d_{Blocker}$：average blocker depth<ul>
<li>blocker 可能并不是一个点，有一定的范围，计算他们的平均值</li>
<li>看 SM 中对应位置有多少个点能挡住 shading point，求他们的平均值</li>
</ul>
</li>
<li>面光源本身是没法生成一个 SM 的，我们模拟面光源的软阴影，用一个点光源代替它生成一个 SM</li>
</ul>
<h4 id="PCSS-流程"><a href="#PCSS-流程" class="headerlink" title="PCSS 流程"></a>PCSS 流程</h4><ul>
<li>Step 1: Blocker search<ul>
<li>getting the average blocker depth in a <strong>certain region</strong></li>
<li>将这些点在 SM 中的深度值和我们计算出来的深度值作比较<ul>
<li>感觉这个时候还是当作点光源操作</li>
</ul>
</li>
<li>考虑的是平均的 blocker 的深度，如果不是 blocker 则不管这个像素</li>
</ul>
</li>
</ul>
<ul>
<li>Step 2: Penumbra estimation<ul>
<li>use the average blocker depth to determine <strong>filter size</strong></li>
</ul>
</li>
<li>Step 3: Percentage Closer Filtering</li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li>怎么决定第一步搜索 blocker 的范围</li>
<li>可以设置为一个常数，例如 5x5</li>
<li>可以通过启发式计算出搜索范围</li>
</ul>
<img src="03/image-20210407181810295.png" style="zoom:40%;" />

<ul>
<li>比较慢，时间开销大</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>多光源，如果利用 SM，需要对每个光源计算一个 SM</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/02/CG/YLQ-GAMES202/03/" data-id="cl9lj749r008764tz8iuyfbj9" data-title="GAMES202.闫令琪.03.实时阴影(1)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/YLQ-GAMES101/13" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/01/CG/YLQ-GAMES101/13/" class="article-date">
  <time class="dt-published" datetime="2021-04-01T14:40:40.000Z" itemprop="datePublished">2021-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES101/">CG.GAMES101</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/01/CG/YLQ-GAMES101/13/">GAMES101.闫令琪.13.动画与模拟(2)(Lecture 22)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av90798049">https://www.bilibili.com/video/av90798049</a></li>
</ul>
<h1 id="动画与模拟"><a href="#动画与模拟" class="headerlink" title="动画与模拟"></a>动画与模拟</h1><h2 id="单个粒子的模拟"><a href="#单个粒子的模拟" class="headerlink" title="单个粒子的模拟"></a>单个粒子的模拟</h2><ul>
<li>假设单个粒子在速度场中运动<ul>
<li>理想，实际很难找到一个速度场</li>
</ul>
</li>
<li>解常微分方程<ul>
<li>ODE：Ordinary Differential Equation</li>
</ul>
</li>
</ul>
<p>$$<br>\dfrac{dx}{dt}&#x3D;\dot{x}&#x3D;v(x,t)<br>$$</p>
<h2 id="欧拉方法"><a href="#欧拉方法" class="headerlink" title="欧拉方法"></a>欧拉方法</h2><ul>
<li>前向欧拉方法，显式欧拉方法</li>
<li>简单的迭代方法</li>
<li>广泛的使用</li>
</ul>
<p>$$<br>\begin{aligned}<br>\boldsymbol{x}^{t+\Delta t}&#x3D;\boldsymbol{x}^{t}+\Delta t \dot{\boldsymbol{x}}^{t} \ \dot{\boldsymbol{x}}^{t+\Delta t}&#x3D;\dot{\boldsymbol{x}}^{t}+\Delta t \ddot{\boldsymbol{x}}^{t}<br>\end{aligned}<br>$$</p>
<ul>
<li>始终用上一个时刻的数据计算这一时刻的数据</li>
</ul>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><h4 id="不准确"><a href="#不准确" class="headerlink" title="不准确"></a>不准确</h4><ul>
<li>很不准确<ul>
<li>可以通过减小步长来解决</li>
</ul>
</li>
</ul>
<img src="13/image-20210402104312620.png" style="zoom: 70%;" />

<h4 id="不稳定"><a href="#不稳定" class="headerlink" title="不稳定"></a>不稳定</h4><ul>
<li>通常会趋于不稳定<ul>
<li>例如下面的两个场景<ul>
<li>场景1：只要有一小段步长，就会脱离螺旋线</li>
<li>场景2：不能汇聚到中心，反而离中心越来越远（正反馈）</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="13/image-20210402104639526.png" style="zoom:70%;" />

<h4 id="问题的比较"><a href="#问题的比较" class="headerlink" title="问题的比较"></a>问题的比较</h4><ul>
<li>Errors<ul>
<li>Errors at each time step accumulate. Accuracy decreases as simulation proceeds</li>
<li><strong>Accuracy may not be critical in graphics applications</strong><ul>
<li>CG 中，物理上不太准确没啥大关系，效果好就行</li>
</ul>
</li>
</ul>
</li>
<li>Instability<ul>
<li>Errors can compound, causing the simulation to <strong>diverge</strong> even when the underlying system does not<ul>
<li>你有一个模拟方法，但是不管你怎么模拟都不会收敛到实际的结果</li>
<li>发散的结果和真实的差的特别大</li>
</ul>
</li>
<li>Lack of stability is a fundamental problem in simulation, and cannot be ignored<ul>
<li>不稳定是个很严重的问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="对抗不稳定性"><a href="#对抗不稳定性" class="headerlink" title="对抗不稳定性"></a>对抗不稳定性</h2><h3 id="中点法"><a href="#中点法" class="headerlink" title="中点法"></a>中点法</h3><ul>
<li>Midpoint Method</li>
</ul>
<img src="13/image-20210402105237738.png" style="zoom:60%;" />

<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li>首先使用欧拉方法计算出下一个点的位置 a</li>
<li>取原始点和 a 点连线的中点 b</li>
<li>计算 b 点的方向</li>
<li>用 b 点的方向在原始点上移动一段距离</li>
</ul>
<p>$$<br>\begin{aligned}<br>x_{mid}&#x3D;x(t)+\dfrac{\Delta t}{2}\cdot v(x(t),t)\<br>x(t+\Delta t)&#x3D;x(t)+\Delta t\cdot v(x_{mid},t)<br>\end{aligned}<br>$$</p>
<h4 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h4><ul>
<li>思想：找一个更具代表性的速度</li>
<li>中点法为什么更优？<ul>
<li>比欧拉方法多了一个<strong>二次项</strong></li>
</ul>
</li>
<li>展开上述的公式</li>
</ul>
<p>$$<br>\begin{aligned}<br>\boldsymbol{x}^{t+\Delta t}&amp;&#x3D;\boldsymbol{x}^{t}+\Delta t\left(\boldsymbol{\dot{x}}^{t}+\dfrac{\Delta t}{2}\cdot\boldsymbol{\ddot{x}}^{t} \right)\<br>&amp;&#x3D;\boldsymbol{x}^{t}+\Delta t \dot{\boldsymbol{x}}^{t}+\dfrac{(\Delta t)^{2}}{2} \ddot{\boldsymbol{x}}^{t} \end{aligned}<br>$$</p>
<ul>
<li>是欧拉方法的一个改进</li>
</ul>
<h3 id="自适应步长"><a href="#自适应步长" class="headerlink" title="自适应步长"></a>自适应步长</h3><ul>
<li>Adaptive Step Size</li>
<li>通过估计的方式选择时间步长</li>
<li>很实用的方法</li>
<li>可能会导致使用很小的步长</li>
</ul>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ul>
<li>定义一个阈值 threshold</li>
<li>重复以下的步骤，直至误差小于阈值<ul>
<li>Compute $x_T$ an Euler step, size $T$</li>
<li>Compute $x_{T&#x2F;2}$ two Euler steps, size $\dfrac{T}{2}$<ul>
<li>把时间分成两段，使用两次欧拉方法</li>
</ul>
</li>
<li>Compute error $||x_{T}-x_{T&#x2F;2}||$</li>
<li>If (error &gt; threshold) reduce step size and try again<ul>
<li>重复减半 $\Delta T$，直至错误小于阈值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="隐式欧拉方法"><a href="#隐式欧拉方法" class="headerlink" title="隐式欧拉方法"></a>隐式欧拉方法</h3><ul>
<li>Implicit methods</li>
<li>后向欧拉方法</li>
<li>使用下一帧的数据来估计这一个时刻的数据<ul>
<li>解方程组</li>
</ul>
</li>
</ul>
<p>$$<br>\begin{aligned}<br>\boldsymbol{x}^{t+\Delta t}&#x3D;\boldsymbol{x}^{t}+\Delta t\ \dot{\boldsymbol{x}}^{t+\Delta t} \<br>\dot{\boldsymbol{x}}^{t+\Delta t}&#x3D;\dot{\boldsymbol{x}}^{t}+\Delta t\  \ddot{\boldsymbol{x}}^{t+\Delta t}<br>\end{aligned}<br>$$</p>
<ul>
<li>如果变量描述关系没有这么简单，解方程是一个很难的问题<ul>
<li>非线性方程组</li>
</ul>
</li>
<li>一般情况下会利用优化方法来解<ul>
<li>牛顿法求根公式</li>
</ul>
</li>
<li>结果稳定性非常好</li>
<li>怎么定义一个算法的稳定性<ul>
<li>局部每一步的误差：local truncation error (every step)</li>
<li>总的误差：total accumulated error (overall)</li>
</ul>
</li>
<li>评价的时候看误差的阶</li>
<li>隐式欧拉方法误差的阶是 $1$<ul>
<li>局部误差：$O(h^2)$</li>
<li>全局误差：$O(h)$</li>
<li>$h$ 表示步长，在这里是 $\Delta t$</li>
</ul>
</li>
<li>阶越高越好<ul>
<li>越高的话，我们可以通过减小步长的方法很快的把误差减小下来</li>
</ul>
</li>
</ul>
<h3 id="龙格库塔方法"><a href="#龙格库塔方法" class="headerlink" title="龙格库塔方法"></a>龙格库塔方法</h3><ul>
<li>Runge-Kutta</li>
<li>一类方法</li>
<li>擅长求解 ODE</li>
<li>一个用的比较多的方法：RK4（4阶）</li>
</ul>
<h4 id="RK4"><a href="#RK4" class="headerlink" title="RK4"></a>RK4</h4><ul>
<li>初始化<ul>
<li>初始状态、场</li>
</ul>
</li>
</ul>
<p>$$<br>\dfrac{dy}{dt}&#x3D;f(t,y),y(t_0)&#x3D;y_)<br>$$</p>
<ul>
<li>更新方式</li>
</ul>
<p>$$<br>y_{n+1}&#x3D;y_n+\dfrac{1}{6}h(k_1+2k_2+2k_3+k_4)<br>$$</p>
<p>$$<br>t_{n+1}&#x3D;t_n+h<br>$$</p>
<ul>
<li>其中</li>
</ul>
<p>$$<br>\begin{aligned}<br>k_1&amp;&#x3D;f(t_n,y_n)\<br>k_2&amp;&#x3D;f(t_n+\dfrac{h}{2},y_n+h\dfrac{k_1}2)\<br>k_3&amp;&#x3D;f(t_n+\dfrac{h}{2},y_n+h\dfrac{k_2}2)\<br>k_4&amp;&#x3D;f(t_n+h,y_n+hk_3)\<br>\end{aligned}<br>$$</p>
<ul>
<li>可以理解为中点法的扩展，精确设计</li>
</ul>
<h3 id="非物理的方法"><a href="#非物理的方法" class="headerlink" title="非物理的方法"></a>非物理的方法</h3><ul>
<li>Position-Based &#x2F; Verlet Integration<ul>
<li>只通过调整位置，使其最后满足某种性质</li>
</ul>
</li>
<li>在渲染上很好用</li>
<li>不是基于物理的，会不满足物理现象（）能量损失极快</li>
</ul>
<h2 id="刚体的模拟"><a href="#刚体的模拟" class="headerlink" title="刚体的模拟"></a>刚体的模拟</h2><ul>
<li>不会形变</li>
<li>类似粒子，但是需要考虑更多的物理量<ul>
<li>位置、角度、速度、角速度</li>
</ul>
</li>
</ul>
<img src="13/image-20210402114539986.png" style="zoom:60%;" />



<h2 id="流体的模拟"><a href="#流体的模拟" class="headerlink" title="流体的模拟"></a>流体的模拟</h2><ul>
<li>A Simple <strong>Position-Based</strong> Method</li>
<li>通过模拟整个形成水的体积的小球的位置来模拟整个谁的运动</li>
</ul>
<h3 id="key-idea"><a href="#key-idea" class="headerlink" title="key idea"></a>key idea</h3><ul>
<li>水体是由很多的不可压缩的刚体小球组成的</li>
<li>水是不可压缩的（水的密度是一样的）</li>
<li>从密度的角度出发，如果某个位置的密度发生了改变（和原来不一样），通过改变小球的运动将密度进行修正<ul>
<li>模拟水的运动</li>
</ul>
</li>
<li>需要知道密度对所有小球位置（粒子）的梯度<ul>
<li>很远的小球不影响，梯度为 0</li>
<li>比较近的小球的会影响</li>
</ul>
</li>
<li>怎么更新（调整小球位置）<ul>
<li>梯度下降方法</li>
<li>可能出来停不下来的现象<ul>
<li>可以人为加上运动损失</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="两大流派"><a href="#两大流派" class="headerlink" title="两大流派"></a>两大流派</h2><ul>
<li>Eulerian vs. Lagrangian</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=iDIzLkic1pY">https://www.youtube.com/watch?v=iDIzLkic1pY</a></li>
</ul>
<img src="13/image-20210402140922051.png" style="zoom:73%;" />

<h3 id="拉格朗日方法"><a href="#拉格朗日方法" class="headerlink" title="拉格朗日方法"></a>拉格朗日方法</h3><ul>
<li>质点法</li>
<li>跟踪每一个<strong>质点</strong>的信息</li>
</ul>
<h3 id="欧拉方法-1"><a href="#欧拉方法-1" class="headerlink" title="欧拉方法"></a>欧拉方法</h3><ul>
<li>网格法</li>
<li>将场景划分为若干网格</li>
<li>跟踪每个<strong>网格</strong>的信息变化</li>
</ul>
<h3 id="物质点方法"><a href="#物质点方法" class="headerlink" title="物质点方法"></a>物质点方法</h3><ul>
<li>Material Point Method (MPM)</li>
<li>两种方法的混合</li>
</ul>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li>Lagrangian: consider particles carrying material properties<ul>
<li>每一个点都带有一些属性</li>
</ul>
</li>
<li>Eulerian: use a grid to do numerical integration<ul>
<li>属性的计算是以网格为单位的计算</li>
</ul>
</li>
<li>Interaction: particles transfer properties to the grid, grid performs update, then interpolate back to particles<ul>
<li>网格计算完之后把这些信息写回每个点</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/01/CG/YLQ-GAMES101/13/" data-id="cl9lj74a500at64tzhsmmhf50" data-title="GAMES101.闫令琪.13.动画与模拟(2)(Lecture 22)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/YLQ-GAMES101/12" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/01/CG/YLQ-GAMES101/12/" class="article-date">
  <time class="dt-published" datetime="2021-04-01T07:16:52.000Z" itemprop="datePublished">2021-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES101/">CG.GAMES101</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/01/CG/YLQ-GAMES101/12/">GAMES101.闫令琪.12.动画与模拟(Lecture 21)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av90798049">https://www.bilibili.com/video/av90798049</a></li>
</ul>
<h1 id="动画与模拟"><a href="#动画与模拟" class="headerlink" title="动画与模拟"></a>动画与模拟</h1><ul>
<li>animation</li>
<li>内容<ul>
<li>History</li>
<li>Keyframe animation</li>
<li>Physical simulation</li>
<li>Kinematics</li>
<li>Rigging</li>
</ul>
</li>
</ul>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><ul>
<li>动画的动机：让物体动起来<ul>
<li>是一种交流的工具</li>
<li>更关注美学特征，物理上差不多对就行</li>
</ul>
</li>
<li>建模，几何的拓展<ul>
<li>时间轴上的扩展</li>
</ul>
</li>
<li>动画的形成：快速播放的图片序列<ul>
<li>电影：24 fps</li>
<li>视频：30 fps</li>
<li>VR：90 fps<ul>
<li>不晕的要求</li>
</ul>
</li>
<li>frames per second</li>
</ul>
</li>
</ul>
<h2 id="动画的历史"><a href="#动画的历史" class="headerlink" title="动画的历史"></a>动画的历史</h2><h3 id="早期的壁画"><a href="#早期的壁画" class="headerlink" title="早期的壁画"></a>早期的壁画</h3><ul>
<li>一些图片序列</li>
<li>我们将这些图片截取下来动态的播放，可以看到动态的狩猎图</li>
<li>这说明很早的时候，大家就已经知道动画就是一系列的图片序列而已，只是当时缺少播放设备罢了</li>
</ul>
<img src="12/image-20210401154620043.png" style="zoom:50%;" />



<h3 id="Phenakistoscope"><a href="#Phenakistoscope" class="headerlink" title="Phenakistoscope"></a>Phenakistoscope</h3><ul>
<li>1831</li>
<li>圆盘，边上画上画，但是你只能看到一部分区域</li>
<li>转起来则会有动画的效果</li>
<li>小时候玩的小人书，翻页动画</li>
</ul>
<img src="12/image-20210401155000489.png" style="zoom:50%;" />



<h3 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h3><ul>
<li>最早用于科学研究<ul>
<li>例如：捕捉马的运动形态</li>
</ul>
</li>
</ul>
<h3 id="动画-1"><a href="#动画-1" class="headerlink" title="动画"></a>动画</h3><ul>
<li>白雪公主和七个小矮人<ul>
<li>Disney, “Snow White and the Seven Dwarfs” (1937)</li>
<li>第一部手绘的长达 40 分钟的动画（电影长度）<ul>
<li>First Hand-Drawn Feature-Length (&gt;40 mins) Animation</li>
<li>feature length，时间大于等于 40 分钟，电影的长度</li>
</ul>
</li>
</ul>
</li>
<li>Ivan Sutherland, “Sketchpad” (1963) – Light pen, vector display<ul>
<li>First Digital-Computer-Generated Animation</li>
<li>可以支持用一根激光笔在显示屏上画出、移动简单的几何体</li>
</ul>
</li>
<li>早期的动画<ul>
<li>三维网格显示任务的面目表情</li>
<li>Ed Catmull &amp; Frederick Parke, “Computer Animated Faces” (1972)</li>
</ul>
</li>
<li>侏罗纪公园<ul>
<li>Jurassic Park (1993)</li>
<li>里程碑式的作品</li>
<li>真正把电脑生成的恐龙放到了电影里</li>
</ul>
</li>
<li>玩具总动员<ul>
<li>Pixar, “Toy Story” (1995)</li>
<li>First CG-Generated Feature-Length Film</li>
<li>第一部完全由电脑生成的电影</li>
<li>当时还是使用<strong>光栅化技术</strong>，没有光线跟踪</li>
</ul>
</li>
<li>天降美食<ul>
<li>Sony Pictures Animation, “Cloudy With a Chance of Meatballs” (2009)</li>
<li>东西掉进水里的模拟还不是很逼真<ul>
<li>涟漪</li>
</ul>
</li>
</ul>
</li>
<li>冰雪奇缘2<ul>
<li>Walt Disney Animation Studios, “Frozen 2” (2019)</li>
<li>充满大量细节：花瓣、草地、特效</li>
</ul>
</li>
</ul>
<h2 id="关键帧动画"><a href="#关键帧动画" class="headerlink" title="关键帧动画"></a>关键帧动画</h2><ul>
<li>keyframe animation</li>
</ul>
<img src="12/image-20210401200539173.png" style="zoom:67%;" />

<ul>
<li>首先绘制一些重要的位置的场景，这些重要的位置就被称为<strong>关键帧</strong></li>
<li>动画制作<ul>
<li>Animator (e.g. lead animator) creates keyframes<ul>
<li>负责人先画出关键帧</li>
</ul>
</li>
<li>Assistant (person or computer) creates in-between frames (“tweening”)<ul>
<li>助手在将中间的过程补全</li>
</ul>
</li>
</ul>
</li>
<li>flash<ul>
<li>简单的图案可以从关键帧自动生成</li>
</ul>
</li>
</ul>
<h3 id="关键帧插值"><a href="#关键帧插值" class="headerlink" title="关键帧插值"></a>关键帧插值</h3><ul>
<li>插值是一门学问，做到自然真实是很难的</li>
<li>连续性<ul>
<li>$C1,C2,\cdots$</li>
</ul>
</li>
</ul>
<h2 id="物理模拟"><a href="#物理模拟" class="headerlink" title="物理模拟"></a>物理模拟</h2><ul>
<li>physical simulation</li>
<li>牛顿定律 $F&#x3D;ma$<ul>
<li>Force &#x3D; Mass x Acceleration</li>
</ul>
</li>
<li>简单的匀加速运动</li>
</ul>
<p>$$<br>x^{t+\Delta t}&#x3D;x^t+\Delta tv^t+\dfrac{1}{2}(\Delta t)^2a^t<br>$$</p>
<ul>
<li>复杂的布料：如果考虑了所有力，就能很好的模拟出结果</li>
<li>模拟得对的话，则不会出现<strong>穿模</strong>现象</li>
<li>流体的模拟<ul>
<li>模拟水滴的位置</li>
<li>然后考虑怎么渲染得更真实</li>
</ul>
</li>
<li>割裂开模拟和真实感渲染这两步</li>
</ul>
<h2 id="质点弹簧系统"><a href="#质点弹簧系统" class="headerlink" title="质点弹簧系统"></a>质点弹簧系统</h2><ul>
<li>Mass Spring System</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="简单的弹簧绳"><a href="#简单的弹簧绳" class="headerlink" title="简单的弹簧绳"></a>简单的弹簧绳</h4><ul>
<li>Mass Spring Rope</li>
</ul>
<h4 id="头发"><a href="#头发" class="headerlink" title="头发"></a>头发</h4><ul>
<li>很复杂：摩擦力、重力、外力</li>
</ul>
<h4 id="布料"><a href="#布料" class="headerlink" title="布料"></a>布料</h4><ul>
<li>Mass Spring Mesh</li>
</ul>
<img src="12/image-20210401202146335.png" style="zoom:67%;" />

<ul>
<li>关于模拟布料的一篇论文</li>
<li>Huamin Wang, Ravi Ramamoorthi, and James F. O’Brien. “Data-Driven Elastic Models for Cloth: Modeling and Measurement”. ACM Transactions on Graphics, 30(4):71:1–11, July 2011. Proceedings of ACM SIGGRAPH 2011, Vancouver, BC Canada.</li>
</ul>
<h3 id="质点弹簧系统-1"><a href="#质点弹簧系统-1" class="headerlink" title="质点弹簧系统"></a>质点弹簧系统</h3><ul>
<li>一系列相互连接的质点和弹簧</li>
</ul>
<h4 id="理想的弹簧"><a href="#理想的弹簧" class="headerlink" title="理想的弹簧"></a>理想的弹簧</h4><ul>
<li>没有长度</li>
<li>被拉开多长，就产生多大的力</li>
</ul>
<img src="12/image-20210401202528815.png" style="zoom:100%;" />

<ul>
<li>弹簧力大小的计算<ul>
<li>胡克定律 Hooke’s Law</li>
<li>劲度系数 $k_s$</li>
</ul>
</li>
</ul>
<p>$$<br>\boldsymbol{f_{a\to b}}&#x3D;k_s(\mathbf{b}-\mathbf{a})<br>$$</p>
<p>$$<br>\boldsymbol{f_{b\to a}}&#x3D;-\boldsymbol{f_{a\to b}}<br>$$</p>
<h4 id="有长度的弹簧"><a href="#有长度的弹簧" class="headerlink" title="有长度的弹簧"></a>有长度的弹簧</h4><p>$$<br>\boldsymbol{f_{a\to b}}&#x3D;k_s(||\mathbf{b}-\mathbf{a}||-l)\dfrac{\mathbf{b}-\mathbf{a}}{||\mathbf{b}-\mathbf{a}||}<br>$$</p>
<ul>
<li>胡克定律<ul>
<li>$\dfrac{\mathbf{b}-\mathbf{a}}{||\mathbf{b}-\mathbf{a}||}$ 表示方向</li>
</ul>
</li>
<li>问题：由于能量守恒，永远不会停下来<ul>
<li><strong>加入一个摩擦力</strong></li>
</ul>
</li>
<li>记号</li>
</ul>
<p>$$<br>\begin{aligned}<br>&amp;\boldsymbol{x}\<br>&amp;\dot{\boldsymbol{x}}&#x3D;\boldsymbol{v}\<br>&amp;\ddot{\boldsymbol{x}}&#x3D;\boldsymbol{a}<br>\end{aligned}<br>$$</p>
<h4 id="阻尼"><a href="#阻尼" class="headerlink" title="阻尼"></a>阻尼</h4><ul>
<li>damping force</li>
</ul>
<img src="12/image-20210401204250184.png" style="zoom:80%;" />
$$
\boldsymbol{f}=-k_d\mathbf{\dot{b}}
$$

<ul>
<li>问题：会引起所有的运动都停下来（Slows down all motion）<ul>
<li>表现不了弹簧内部的损耗</li>
</ul>
</li>
<li>表现问题的例子<ul>
<li>两个质点和连接它们的弹簧，在光滑的水平面上同步的向右运动，理论上应该不会被停下来，而且弹簧之间应该没有相对运动</li>
<li>但是按照这个模型他们会被停下来</li>
</ul>
</li>
<li>阻尼应该加在弹簧上，即两个质点的相对运动上（相对速度在弹簧方向上的分量）</li>
</ul>
<img src="12/image-20210401205009298.png" style="zoom:80%;" />
$$
\boldsymbol{f_{b}}=-k_d\dfrac{\mathbf{b}-\mathbf{a}}{||\mathbf{b}-\mathbf{a}||}\cdot(\mathbf{\dot{b}}-\mathbf{\dot{a}})\cdot \dfrac{\mathbf{b}-\mathbf{a}}{||\mathbf{b}-\mathbf{a}||}
$$

<ul>
<li>式子含义的解释</li>
</ul>
<img src="12/image-20210401205354628.png" style="zoom:60%;" />

<ul>
<li>可以解释圆周运动，速度没有衰减的现象</li>
</ul>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><img src="12/image-20210401211126993.png" style="zoom:50%;" />



<h3 id="弹簧模拟布"><a href="#弹簧模拟布" class="headerlink" title="弹簧模拟布"></a>弹簧模拟布</h3><h4 id="问题1：切变"><a href="#问题1：切变" class="headerlink" title="问题1：切变"></a>问题1：切变</h4><img src="12/image-20210401211333098.png" style="zoom:50%;" />

<ul>
<li>布有抵抗切变的力，但是这个模型对角线一拉会形变</li>
</ul>
<h4 id="问题2：不成平面"><a href="#问题2：不成平面" class="headerlink" title="问题2：不成平面"></a>问题2：不成平面</h4><ul>
<li>如果有一个力让这个结构不成平面，这个结构可能不会恢复<ul>
<li>例如上面的结构沿着对角线对折</li>
</ul>
</li>
<li>但是现实的布料是会恢复的</li>
</ul>
<h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><ul>
<li>加对角线弹簧<ul>
<li>但是变得不对称了</li>
<li>解决不了问题 2</li>
</ul>
</li>
</ul>
<img src="12/image-20210401211837682.png" style="zoom:50%;" />

<ul>
<li>加两个对角线<ul>
<li>同样解决不了问题 2（竖直对折）</li>
</ul>
</li>
</ul>
<img src="12/image-20210401212105160.png" style="zoom:50%;" />

<ul>
<li>每一个点和它相隔一个点的点相连<ul>
<li>skip connection</li>
<li>这样不管如果你把这个结构折成不在一个平面内的结构的话，势必会影响某个弹簧（产生恢复力）</li>
<li>红线的连接相对较弱（劲度系数较小）</li>
</ul>
</li>
</ul>
<img src="12/image-20210401220905052.png" style="zoom:67%;" />

<h3 id="有限元方法模拟布料"><a href="#有限元方法模拟布料" class="headerlink" title="有限元方法模拟布料"></a>有限元方法模拟布料</h3><ul>
<li>FEM：Finite Element Method</li>
<li>广泛应用于汽车碰撞的模拟</li>
<li>力的作用会传导</li>
<li>FEM 写起来很复杂</li>
</ul>
<h2 id="粒子系统"><a href="#粒子系统" class="headerlink" title="粒子系统"></a>粒子系统</h2><ul>
<li><strong>Particle System</strong></li>
<li>把模型看成是很多个粒子的集合</li>
<li>每个粒子的动作都被（非）物理上的力定义</li>
<li>在现代图形学和游戏中广泛应用<ul>
<li>实现比较简单和方便</li>
<li>点越多，复杂度越高，模拟得越精细，执行越慢</li>
</ul>
</li>
<li>问题<ul>
<li>可能需要大量的粒子（流体）</li>
<li>可能需要一些其他的加速结构<ul>
<li>例如要求粒子之间的引力（需要有一个很快得找到周围的粒子的方法）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">For each frame <span class="keyword">in</span> animation</span><br><span class="line">    [If needed] Create new particles</span><br><span class="line">    Calculate forces on each particle</span><br><span class="line">    Update each particle’s position <span class="keyword">and</span> velocity</span><br><span class="line">    [If needed] Remove dead particles</span><br><span class="line">    Render particles</span><br></pre></td></tr></table></figure>

<ul>
<li>建模的部分确定有哪些相互作用力</li>
<li>怎么去解作用力<ul>
<li>学术界更关心</li>
<li>更难一些</li>
</ul>
</li>
<li>注意：<strong>模拟和渲染的过程是分开的</strong></li>
</ul>
<h3 id="粒子系统中力的作用"><a href="#粒子系统中力的作用" class="headerlink" title="粒子系统中力的作用"></a>粒子系统中力的作用</h3><ul>
<li>Attraction and repulsion forces（引力与斥力）<ul>
<li>Gravity, electromagnetism, …</li>
<li>Springs, propulsion, …</li>
</ul>
</li>
<li>Damping forces（阻尼）<ul>
<li>Friction, air drag, viscosity, …</li>
</ul>
</li>
<li>Collisions（碰撞）<ul>
<li>Walls, containers, fixed objects, …</li>
<li>Dynamic objects, character body parts, …</li>
</ul>
</li>
</ul>
<h3 id="粒子的扩展"><a href="#粒子的扩展" class="headerlink" title="粒子的扩展"></a>粒子的扩展</h3><ul>
<li>粒子：大规模范围内有很多小的重复的东西，这些东西可以理解为粒子</li>
</ul>
<h4 id="模拟鸟群"><a href="#模拟鸟群" class="headerlink" title="模拟鸟群"></a>模拟鸟群</h4><ul>
<li><a target="_blank" rel="noopener" href="http://www.red3d.com/cwr/boids/">http://www.red3d.com/cwr/boids/</a></li>
<li>引力：和邻居的中心有个引力（任何一只鸟都不想落单，并且试图融入到他们中间去）</li>
<li>斥力：和每只邻居中的鸟都有斥力（任何一只鸟都不希望和其他鸟离的太近）</li>
<li>朝向：邻居的朝向平均值（希望沿着和邻居相同的方向飞）</li>
</ul>
<img src="12/image-20210401234930535.png" style="zoom:60%;" />



<h4 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h4><ul>
<li>模拟分子结构<ul>
<li>Molecular Dynamics</li>
</ul>
</li>
<li>人群的模拟<ul>
<li>Crowds + “Rock” Dynamics</li>
</ul>
</li>
</ul>
<h3 id="其他笔记"><a href="#其他笔记" class="headerlink" title="其他笔记"></a>其他笔记</h3><ul>
<li><a href="/2021/02/03/CG/LS/07/">计算机图形学-李胜</a></li>
</ul>
<h2 id="正运动学"><a href="#正运动学" class="headerlink" title="正运动学"></a>正运动学</h2><ul>
<li>Forward Kinematics</li>
<li>做出一种动画，用于描述一个骨骼系统，能够表示和人类似的拓扑结构</li>
</ul>
<img src="12/image-20210401235801146.png" style="zoom:50%;" />

<ul>
<li>Articulated skeleton（铰接式骨架）<ul>
<li>Topology (what’s connected to what)<ul>
<li>拓扑结构，具体怎么连接</li>
</ul>
</li>
<li>Geometric relations from joints<ul>
<li>通过关节连接</li>
</ul>
</li>
<li>Tree structure (in absence of loops)<ul>
<li>树的结构（无环）</li>
</ul>
</li>
</ul>
</li>
<li>关节的类型<ul>
<li>Pin：允许 1D 的旋转</li>
<li>Ball：允许 2D 的旋转（像球一样旋转、可以转到平面外）</li>
<li>Prismatic joint：允许拉长</li>
</ul>
</li>
<li>Pin（被钉住一样）</li>
</ul>
<img src="12/image-20210401235842580.png" style="zoom:100%;" />

<ul>
<li>Prismatic joint（棱柱形关节）</li>
</ul>
<p><img src="/12/image-20210402000012688.png"></p>
<h3 id="关节的例子"><a href="#关节的例子" class="headerlink" title="关节的例子"></a>关节的例子</h3><img src="12/image-20210402000209841.png" style="zoom:67%;" />

<ul>
<li>Pin 关节连接</li>
</ul>
<p>$$<br>\begin{aligned}<br>&amp;p_x&#x3D;l_1\cos(\theta_1)+l_2\cos(\theta_1+\theta_2)\<br>&amp;p_y&#x3D;l_1\sin(\theta_1)+l_2\sin(\theta_1+\theta_2)\<br>\end{aligned}<br>$$</p>
<h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li>定义太过于物理</li>
<li>不适合与艺术家<ul>
<li>艺术家喜欢更加直观简单的定义，例如从哪里移动到哪里（而不是几个参数）</li>
</ul>
</li>
</ul>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul>
<li>方便计算模拟，实现简单</li>
</ul>
<h2 id="逆运动学"><a href="#逆运动学" class="headerlink" title="逆运动学"></a>逆运动学</h2><ul>
<li>告诉你运动的结果，然后计算出参数来模拟这个结果<ul>
<li>例如给出轨迹，然后计算参数</li>
</ul>
</li>
</ul>
<h3 id="关节的例子-1"><a href="#关节的例子-1" class="headerlink" title="关节的例子"></a>关节的例子</h3><ul>
<li>给你 $P$ 点的轨迹，求出中间的过程中的 $\theta_1,\theta_2$ 的值，从而模拟这个运动</li>
</ul>
<img src="12/image-20210402001325862.png" style="zoom:67%;" />

<ul>
<li>解起来很复杂</li>
</ul>
<img src="12/image-20210402001401828.png" style="zoom:30%;" />

<h3 id="评价-1"><a href="#评价-1" class="headerlink" title="评价"></a>评价</h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ul>
<li>关节多了很难算</li>
<li>解不唯一</li>
</ul>
<img src="12/image-20210402001550942.png" style="zoom: 70%;" />

<ul>
<li>可能无解<ul>
<li>解只可能出现实线的圆环上，其他地方无解</li>
</ul>
</li>
</ul>
<img src="12/image-20210402001723638.png" style="zoom:50%;" />



<h4 id="解决策略"><a href="#解决策略" class="headerlink" title="解决策略"></a>解决策略</h4><ul>
<li>优化方法求解（梯度下降）</li>
</ul>
<h3 id="逆运动学例子"><a href="#逆运动学例子" class="headerlink" title="逆运动学例子"></a>逆运动学例子</h3><ul>
<li>Grochow et al., Style Based Inverse Kinematics</li>
</ul>
<h2 id="Rigging"><a href="#Rigging" class="headerlink" title="Rigging"></a>Rigging</h2><ul>
<li>指对于形状的控制<ul>
<li>类似于木偶的控制</li>
</ul>
</li>
<li>Rigging is a set of higher level controls on a character that allow more rapid &amp; intuitive modification of pose, deformations, expression, etc</li>
<li>一定程度上可以说是对于逆运动学的一个应用</li>
<li>Rigging 本身很复杂<ul>
<li>建模很复杂</li>
</ul>
</li>
</ul>
<h3 id="Blend-Shape"><a href="#Blend-Shape" class="headerlink" title="Blend Shape"></a>Blend Shape</h3><ul>
<li>艺术家对同一个人物形象的两个动作已经做好了，不使用骨架，直接堆表面进行插值出中间的形态<ul>
<li>对于<strong>控制点进行插值</strong></li>
</ul>
</li>
</ul>
<h3 id="Motion-Capture"><a href="#Motion-Capture" class="headerlink" title="Motion Capture"></a>Motion Capture</h3><ul>
<li>动作捕捉</li>
<li>真人的控制点</li>
</ul>
<img src="12/image-20210402002734021.png" style="zoom:60%;" />



<ul>
<li>好处<ul>
<li>真实感非常强</li>
<li>实际动作不需要艺术家去调，很方便（快）</li>
</ul>
</li>
<li>缺点<ul>
<li>动作演员很辛苦</li>
<li>动画人物的动作和现实人做出的动作还是有差异的<ul>
<li>后期调整</li>
</ul>
</li>
<li>捕捉不到很好的数据</li>
<li>成本高<ul>
<li>需要很多个摄像机，才能捕捉到完整的信息</li>
</ul>
</li>
<li>人物动作自己遮挡到控制点</li>
</ul>
</li>
</ul>
<h4 id="其他的控制点模型"><a href="#其他的控制点模型" class="headerlink" title="其他的控制点模型"></a>其他的控制点模型</h4><img src="12/image-20210402003138064.png" style="zoom:67%;" />

<ul>
<li>光学的方法（不受遮挡的影响）<ul>
<li>应用相对广泛</li>
<li>需要很多相机高频捕捉</li>
</ul>
</li>
<li>机械的方法（直接输出数据）</li>
<li>得到的数据<ul>
<li>每一个控制点的位置随着时间变化的信息</li>
</ul>
</li>
<li>可以得到非常真实的动画</li>
<li><strong>恐怖谷效应</strong> Uncanny valley<ul>
<li>过于真实带来的问题</li>
</ul>
</li>
<li>阿凡达 Avatar<ul>
<li>使用了面部捕捉</li>
<li>里程碑式的作品</li>
</ul>
</li>
</ul>
<h2 id="动画产业的-pipeline"><a href="#动画产业的-pipeline" class="headerlink" title="动画产业的 pipeline"></a>动画产业的 pipeline</h2><img src="12/image-20210402003601782.png" style="zoom:100%;" />

<ul>
<li>VFX：visual effects</li>
<li>开销：美工的开销、渲染的开销<ul>
<li>动画电影的开销比请演员还高</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/01/CG/YLQ-GAMES101/12/" data-id="cl9lj74a400ak64tz7zim45fc" data-title="GAMES101.闫令琪.12.动画与模拟(Lecture 21)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/YLQ-GAMES101/11" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/01/CG/YLQ-GAMES101/11/" class="article-date">
  <time class="dt-published" datetime="2021-04-01T03:15:43.000Z" itemprop="datePublished">2021-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES101/">CG.GAMES101</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/01/CG/YLQ-GAMES101/11/">GAMES101.闫令琪.11.颜色与感知(Lecture 20)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av90798049">https://www.bilibili.com/video/av90798049</a></li>
</ul>
<h1 id="颜色与感知"><a href="#颜色与感知" class="headerlink" title="颜色与感知"></a>颜色与感知</h1><ul>
<li>color and perception</li>
</ul>
<h2 id="光谱"><a href="#光谱" class="headerlink" title="光谱"></a>光谱</h2><ul>
<li>spectrum</li>
</ul>
<img src="11/image-20210401112342353.png" style="zoom:80%;" />

<ul>
<li>可见光光谱：400 - 700nm（近似）</li>
</ul>
<h2 id="谱功率密度"><a href="#谱功率密度" class="headerlink" title="谱功率密度"></a>谱功率密度</h2><ul>
<li>SPD（Spectral Power Distribution）</li>
<li>在不同的波长强度是多少</li>
<li>单位<ul>
<li>radiometric units &#x2F; nanometer (e.g. watts &#x2F; nm)</li>
<li>Can also be unit-less</li>
</ul>
</li>
<li>当绝对单位不重要的时候，使用相对强度（相对最大值归一化）</li>
</ul>
<h3 id="一些不同场景的-SPD"><a href="#一些不同场景的-SPD" class="headerlink" title="一些不同场景的 SPD"></a>一些不同场景的 SPD</h3><img src="11/image-20210401112939365.png" alt="image-20210401112939365" style="zoom: 80%;" />



<h3 id="SPD-的性质"><a href="#SPD-的性质" class="headerlink" title="SPD 的性质"></a>SPD 的性质</h3><ul>
<li>线性：线性叠加</li>
</ul>
<img src="11/image-20210401113113148.png" style="zoom:67%;" />



<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><ul>
<li>Color is a phenomenon of human perception; it is not a universal property of light</li>
<li>颜色是人眼感知的一个结果，不是光本身的属性</li>
</ul>
<h2 id="人眼结构"><a href="#人眼结构" class="headerlink" title="人眼结构"></a>人眼结构</h2><img src="11/image-20210401113301779.png" style="zoom:40%;" />

<ul>
<li>pupil：瞳孔</li>
<li>lens：晶状体</li>
<li>Retinal Photoreceptor Cells：感光细胞<ul>
<li>Rods：视杆细胞<ul>
<li>感知光的强度（灰度图）</li>
</ul>
</li>
<li>Cones：视锥细胞<ul>
<li>感知光的颜色</li>
<li>分为 3 类（S、M、L）<ul>
<li><strong>响应曲线</strong>如下</li>
<li>不同人 3 种细胞的分布都不太一样，数量有严重的个体差异</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="11/image-20210401113656644.png" style="zoom:50%;" />



<h3 id="人眼感受颜色"><a href="#人眼感受颜色" class="headerlink" title="人眼感受颜色"></a>人眼感受颜色</h3><ul>
<li>光在不同波长上的强度 $s(\lambda)$</li>
</ul>
<p>$$<br>S&#x3D;\int r_S(\lambda)s(\lambda)d\lambda<br>$$</p>
<p>$$<br>M&#x3D;\int r_M(\lambda)s(\lambda)d\lambda<br>$$</p>
<p>$$<br>L&#x3D;\int r_L(\lambda)s(\lambda)d\lambda<br>$$</p>
<ul>
<li>人们看到的是这三个数，大脑处理形成感知的颜色<ul>
<li>每个人眼中的世界是不一样的，细胞分布不同</li>
</ul>
</li>
</ul>
<h2 id="同色异谱"><a href="#同色异谱" class="headerlink" title="同色异谱"></a>同色异谱</h2><ul>
<li>Metamerism</li>
<li>光不一样，但是形成的颜色相同</li>
</ul>
<h3 id="Metamers"><a href="#Metamers" class="headerlink" title="Metamers"></a>Metamers</h3><ul>
<li>Metamers are two different spectra ($\infty$-dim) that project to the same (S,M,L) (3-dim) response<ul>
<li>光谱不同，感知到的颜色相同</li>
</ul>
</li>
<li>很有用<ul>
<li>颜色匹配 color matching</li>
<li>我们可以通过调制光谱，得到我们想要的颜色，而这个调制的光谱不需要和原来的一模一样<ul>
<li>简单，不需要调制整个波段的光谱<ul>
<li>Don’t have to reproduce the <strong>full spectrum</strong> of a real world scene</li>
</ul>
</li>
<li>例子：我们可以见到那的通过 3 基色在显示屏上调至出我们想要的颜色</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="颜色匹配"><a href="#颜色匹配" class="headerlink" title="颜色匹配"></a>颜色匹配</h3><img src="11/image-20210401115855508.png" style="zoom:60%;" />



<h2 id="颜色生成-x2F-匹配"><a href="#颜色生成-x2F-匹配" class="headerlink" title="颜色生成 &#x2F; 匹配"></a>颜色生成 &#x2F; 匹配</h2><ul>
<li>计算机成像系统：<strong>加色系统</strong><ul>
<li>additive color</li>
<li>RGB 都调最大为<strong>白色</strong></li>
</ul>
</li>
</ul>
<img src="11/image-20210401120016916.png" style="zoom: 33%;" />

<ul>
<li>画画：<strong>减色系统</strong></li>
</ul>
<h3 id="加色系统"><a href="#加色系统" class="headerlink" title="加色系统"></a>加色系统</h3><ul>
<li>给定 3 基色：$s_R(\lambda),s_G(\lambda),s_B(\lambda)$</li>
<li>通过调整系数获得想要的颜色：$Rs_R(\lambda)+Gs_G(\lambda)+Bs_B(\lambda)$</li>
<li>使用 $R,G,B$ 来描述颜色即可</li>
</ul>
<h3 id="加色系统的匹配"><a href="#加色系统的匹配" class="headerlink" title="加色系统的匹配"></a>加色系统的匹配</h3><img src="11/image-20210401120455905.png" style="zoom:70%;" />

<ul>
<li>一边是目标颜色，一边是调制的颜色，通过调整 $R,G,B$ 的值，将调制颜色调制到目标颜色</li>
<li>调不出来？<ul>
<li>在目标颜色上加上一个颜色，好像就是在调制颜色把右边减去了某种颜色<ul>
<li>线性</li>
<li>也就是说我们调制颜色的时候，某些系数可以是是<strong>负的</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="CIE-RGB-匹配实验"><a href="#CIE-RGB-匹配实验" class="headerlink" title="CIE RGB 匹配实验"></a>CIE RGB 匹配实验</h3><ul>
<li>CIE：一个组织</li>
<li><strong>匹配函数</strong>结果<ul>
<li>如何混合单色光得到任意波长的光（感知颜色上的一致）</li>
</ul>
</li>
</ul>
<img src="11/image-20210401121101060.png" style="zoom:50%;" />

<ul>
<li>给定一个实际的 SPD 分布 $s(\lambda)$，怎么计算 $R,G,B$，是的感知上的光是一致的<br>$$<br>R_{CIE\ RGB}&#x3D;\int \bar{r}(\lambda)s(\lambda)d\lambda<br>$$</li>
</ul>
<p>$$<br>G_{CIE\ RGB}&#x3D;\int\bar{g}(\lambda)s(\lambda)d\lambda<br>$$</p>
<p>$$<br>B_{CIE\ RGB}&#x3D;\int\bar{b}(\lambda)s(\lambda)d\lambda<br>$$</p>
<h2 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h2><h3 id="sRGB"><a href="#sRGB" class="headerlink" title="sRGB"></a>sRGB</h3><ul>
<li>standardzed RGB</li>
<li>广泛应用于我们现在的显示设备</li>
<li>制造方式<ul>
<li>先制造一台标准的显示器，测定它的匹配函数</li>
<li>大家按照这个标准去制造，得到的结果就和标准的一致了</li>
</ul>
</li>
<li>形成的色域（gamut）是有限的</li>
</ul>
<h3 id="CIE-XYZ"><a href="#CIE-XYZ" class="headerlink" title="CIE XYZ"></a>CIE XYZ</h3><ul>
<li>科学上应用更广泛</li>
<li>人造的颜色匹配系统，不是实验测出来的</li>
<li>匹配函数曲线如下</li>
</ul>
<img src="11/image-20210401122610739.png" style="zoom:67%;" />

<ul>
<li>在设计上，由于绿色的曲线在可见光比较对称，覆盖范围基本全覆盖了，可以用其来表示图像的亮度<ul>
<li>Y is luminance (brightness regardless of color)</li>
</ul>
</li>
<li>这种设计的结果<ul>
<li>红色虽然有两个峰值，但是<strong>没有负数</strong></li>
<li>覆盖到所有的可见光颜色</li>
</ul>
</li>
</ul>
<h3 id="XYZ-可视化"><a href="#XYZ-可视化" class="headerlink" title="XYZ 可视化"></a>XYZ 可视化</h3><ul>
<li><strong>怎么在二维平面上可视化 XYZ</strong></li>
<li>Luminance：Y<ul>
<li>亮度</li>
</ul>
</li>
<li>Chromaticity：x，y，z<ul>
<li>色度</li>
</ul>
</li>
<li>归一化 $x+y+z&#x3D;1$</li>
</ul>
<p>$$<br>\begin{aligned}<br>x&amp;&#x3D;\dfrac{X}{X+Y+Z}\<br>y&amp;&#x3D;\dfrac{Y}{X+Y+Z}\<br>z&amp;&#x3D;\dfrac{Z}{X+Y+Z}\<br>\end{aligned}<br>$$</p>
<ul>
<li>然后显示 $(x,y)$ 坐标即可</li>
<li>但是实际上还是有 3 个变量，2 维本质只能显示 2 个变量<ul>
<li>由于 Y 表示的是亮度，我们固定 Y，通过改变 X、Z 来绘制出上图</li>
</ul>
</li>
</ul>
<img src="11/image-20210401144514274.png" style="zoom:50%;" />

<h3 id="色域"><a href="#色域" class="headerlink" title="色域"></a>色域</h3><ul>
<li><p>Gamut</p>
</li>
<li><p>所有一个颜色空间可以显示的颜色</p>
</li>
<li><p>上面这个图就是一个色域</p>
</li>
<li><p>色域中心：白色（最不纯的颜色）</p>
</li>
<li><p>边缘：纯色</p>
</li>
<li><p>不同颜色空间表示的色域不一样</p>
</li>
</ul>
<img src="11/image-20210401145403255.png" style="zoom:60%;" />

<h3 id="HSV"><a href="#HSV" class="headerlink" title="HSV"></a>HSV</h3><ul>
<li>Hue-Saturation-Value</li>
<li>色调、饱和度、颜色</li>
<li>色调：不同颜色</li>
<li>饱和度：接近单色还是白色</li>
<li>颜色：亮度（黑色到有色）</li>
</ul>
<img src="11/image-20210401145932979.png" style="zoom:50%;" />

<h4 id="标准定义"><a href="#标准定义" class="headerlink" title="标准定义"></a>标准定义</h4><ul>
<li>Hue<ul>
<li>the “<strong>kind</strong>” of color, regardless of attributes</li>
<li>colorimetric correlate: <strong>dominant wavelength</strong></li>
<li>artist’s correlate: the chosen pigment color</li>
</ul>
</li>
<li>Saturation<ul>
<li>the “<strong>colorfulness</strong>”</li>
<li>colorimetric correlate: <strong>purity</strong></li>
<li>artist’s correlate: fraction of paint from the colored tube</li>
</ul>
</li>
<li>Lightness (or value)<ul>
<li>the overall <strong>amount</strong> of light</li>
<li>colorimetric correlate: <strong>luminance</strong></li>
<li>artist’s correlate: tints are lighter, shades are darker</li>
</ul>
</li>
</ul>
<h3 id="CIELAB-Space"><a href="#CIELAB-Space" class="headerlink" title="CIELAB Space"></a>CIELAB Space</h3><ul>
<li>$L\ast a\ast b\ast$</li>
</ul>
<img src="11/image-20210401150304630.png" style="zoom:50%;" />

<ul>
<li>$L\ast$ is lightness (brightness)</li>
<li>$a\ast$ and $b\ast$ are color-opponent pairs<ul>
<li>$a\ast$ is red-green</li>
<li>$b\ast$ is blue-yellow</li>
</ul>
</li>
<li>互补色</li>
</ul>
<h2 id="互补色理论"><a href="#互补色理论" class="headerlink" title="互补色理论"></a>互补色理论</h2><ul>
<li>红绿互补，蓝黄互补</li>
<li>证据<ul>
<li>生活中有很多颜色，黄绿色、蓝绿色，但是没有听说过红绿色</li>
<li>视觉暂留，当你盯着一幅画面久了之后，撤去画面你会看到互补色</li>
</ul>
</li>
<li>视觉暂留一个很好玩的例子<ul>
<li>两幅相同的图片，第一幅图为上色颜色的互补色，第二幅图为灰度图</li>
<li>看第一张图久了之后，然后换成第二张，人眼会自动上色</li>
</ul>
</li>
</ul>
<h2 id="视错觉"><a href="#视错觉" class="headerlink" title="视错觉"></a>视错觉</h2><ul>
<li>人的感知是相对亮度<ul>
<li>A，B 是一样亮的</li>
</ul>
</li>
</ul>
<img src="11/image-20210401151224344.png" style="zoom:50%;" />



<h2 id="减色系统"><a href="#减色系统" class="headerlink" title="减色系统"></a>减色系统</h2><img src="11/image-20210401151354980.png" style="zoom:50%;" />

<ul>
<li>颜色混得越多越黑</li>
</ul>
<h3 id="CMYK"><a href="#CMYK" class="headerlink" title="CMYK"></a>CMYK</h3><ul>
<li>CMYK 是一个典型的减色系统<ul>
<li>Cyan, Magenta, Yellow, and Key</li>
<li>青色、品红色、黄色、黑色</li>
</ul>
</li>
<li>用于打印，墨水</li>
<li>CMY 可以混合出黑色，为什么一定要带上 K<ul>
<li>成本问题，黑色墨水便宜</li>
</ul>
</li>
</ul>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="颜色空间对比"><a href="#颜色空间对比" class="headerlink" title="颜色空间对比"></a>颜色空间对比</h3><ul>
<li>RGB 好用</li>
<li>XYZ 理论性质好，色域大</li>
<li>HSV 好调色</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/01/CG/YLQ-GAMES101/11/" data-id="cl9lj74a400an64tz8n9h2tu6" data-title="GAMES101.闫令琪.11.颜色与感知(Lecture 20)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/YLQ-GAMES101/10" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/31/CG/YLQ-GAMES101/10/" class="article-date">
  <time class="dt-published" datetime="2021-03-31T14:35:23.000Z" itemprop="datePublished">2021-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES101/">CG.GAMES101</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/31/CG/YLQ-GAMES101/10/">GAMES101.闫令琪.10.光场(Lecture 20)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av90798049">https://www.bilibili.com/video/av90798049</a></li>
</ul>
<h1 id="光场"><a href="#光场" class="headerlink" title="光场"></a>光场</h1><ul>
<li>Light Field &#x2F; Lumigraph<ul>
<li>同义词</li>
<li>历史遗留问题，两个组同时各自发现这个概念</li>
</ul>
</li>
</ul>
<h2 id="我们看到的世界"><a href="#我们看到的世界" class="headerlink" title="我们看到的世界"></a>我们看到的世界</h2><img src="10/image-20210331231257993.png" style="zoom:70%;" />

<ul>
<li>放上一块幕布，让我们看到的东西和原来一模一样</li>
</ul>
<img src="10/image-20210331231412185.png" style="zoom:70%;" />

<ul>
<li>虚拟现实技术的原理</li>
<li>我们只是看到各个方向的光线，看不到光线是多远来的、从什么地方来的</li>
</ul>
<h2 id="全光函数"><a href="#全光函数" class="headerlink" title="全光函数"></a>全光函数</h2><ul>
<li>The Plenoptic Function</li>
<li>描述我们往各个方向看看到的光线</li>
</ul>
<img src="10/image-20210331231735426.png" style="zoom:50%;" />

<ul>
<li>$P(\theta,\phi)$<ul>
<li>灰度图</li>
</ul>
</li>
<li>$P(\theta,\phi,\lambda)$<ul>
<li>彩色图</li>
</ul>
</li>
<li>$P(\theta,\phi,\lambda,t)$<ul>
<li>电影</li>
</ul>
</li>
<li>$P(\theta,\phi,\lambda,t,V_x,V_y,V_z)$<ul>
<li>人眼&#x2F;摄像机的位置可以改变</li>
<li>全息电影</li>
<li>我们能看到的所有东西</li>
<li>7 个维度的函数就可以描述我们看到的整个世界</li>
<li><strong>全光函数</strong></li>
</ul>
</li>
</ul>
<h2 id="光线"><a href="#光线" class="headerlink" title="光线"></a>光线</h2><ul>
<li>ray</li>
<li>$P(\theta,\phi,V_x,V_y,V_z)$<ul>
<li>起点和方向</li>
</ul>
</li>
<li>物体表面的话可以用 4D 表示</li>
</ul>
<h2 id="光场-1"><a href="#光场-1" class="headerlink" title="光场"></a>光场</h2><ul>
<li>光场：在任何一个位置，往任何一个方向去的光的强度</li>
<li>2D 的位置，2D 的方向</li>
<li>3D 物体的表面是在一个 2D 的空间中的<ul>
<li>纹理映射的思想</li>
</ul>
</li>
<li>2D 的方向<ul>
<li>$\theta,\phi$</li>
</ul>
</li>
<li>有个光场之后，可以得到任意位置对物体的观测<ul>
<li>对于观测相机，做出视线，求出在物体表面的反射光线，然后从光场中读出即可</li>
</ul>
</li>
<li>我们不需要知道光场描述的具体的物体，只需要知道在物体表面的任何位置、任何方向的光线强度即可<ul>
<li>可以当作黑盒</li>
<li>前提：观测点得在物体外面（我们记录的信息是往外的）</li>
</ul>
</li>
<li>取一个平面，对于平面上任意一个点、任意一个方向，记录光照强度，这样也可以描述光场</li>
<li>另外一种<strong>参数化方式</strong><ul>
<li>取两个平行的平面，然后在两个平面上各取一个点，这样也能描述光场</li>
<li>两个点相当于确定了一个方向</li>
<li>$u,v,s,t$ 描述</li>
</ul>
</li>
</ul>
<img src="10/image-20210331234206883.png" style="zoom:70%;" />

<ul>
<li>$u,v,s,t$ 的两种理解方式<ul>
<li>$u,v$ 不变，取遍 $s,t$<ul>
<li>能看到完整的物体图</li>
<li>相当于摄像机看向整个世界</li>
</ul>
</li>
<li>$s,t$ 不变，取遍 $u,v$<ul>
<li>能看到同一个点来自各个方向的光照</li>
<li>看的是同一个东西，但是是从各个不同的角度去看</li>
<li>相当于把记录的 irradiance 展开为 radiance</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="10/image-20210331233955685.png" style="zoom: 67%;" />



<h3 id="Stanford-camera-array"><a href="#Stanford-camera-array" class="headerlink" title="Stanford camera array"></a>Stanford camera array</h3><ul>
<li>利用上面的想法，从不同的 $u,v$ 看向整个世界，让后把记录到的结果整合出来</li>
</ul>
<img src="10/image-20210331234831316.png" style="zoom:70%;" />

<ul>
<li><strong>贵</strong></li>
</ul>
<h3 id="苍蝇的眼睛（复眼）"><a href="#苍蝇的眼睛（复眼）" class="headerlink" title="苍蝇的眼睛（复眼）"></a>苍蝇的眼睛（复眼）</h3><ul>
<li>就是一个光场</li>
</ul>
<img src="10/image-20210331235248647.png" style="zoom:67%;" />

<ul>
<li>lenslet：像素</li>
<li>把光分开，把来自各个方向上的光分到不同的位置上去<ul>
<li>把实际的感光元件放在背后，前面放置一个透镜，通过透镜将光分开</li>
<li>把 irradiance 分解为 radiance</li>
</ul>
</li>
</ul>
<h2 id="光场摄像机"><a href="#光场摄像机" class="headerlink" title="光场摄像机"></a>光场摄像机</h2><ul>
<li>Light Field Camera</li>
<li>上面提到的复眼的原理，透镜代替原来的像素，实际的感光元件放在背后</li>
<li><strong>支持重新聚焦</strong><ul>
<li>原理就是光场</li>
</ul>
</li>
<li>很实用，重要的照片拍糊了，没关系，重新调焦距</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>Each pixel (irradiance) is now stored as a block of pixels (radiance)</li>
</ul>
<img src="10/image-20210331235947435.png" style="zoom: 33%;" />



<ul>
<li><p>怎么获取从光场摄像机的结果中获取一张照片</p>
<ul>
<li>每个小透镜都选择一个相同的方向<ul>
<li>相当于摄像机朝着这个方向去拍</li>
</ul>
</li>
<li>方向可以任意选择</li>
<li>相当于可以虚拟的移动相机位置</li>
</ul>
</li>
<li><p>怎么生成给定对焦平面后的结果照片</p>
<ul>
<li>根据对焦平面计算出每一个光线的方向，在光场上查询出具体的强度</li>
<li>visually changing focal length, picking the refocused ray directions accordingly</li>
</ul>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>分辨率较低<ul>
<li>方向分辨率更高，空间分辨率更低</li>
<li>same film used for both spatial and directional information</li>
</ul>
</li>
<li>价格贵</li>
<li>微透镜的设计很麻烦</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/31/CG/YLQ-GAMES101/10/" data-id="cl9lj74a300ad64tz7k0qgm3j" data-title="GAMES101.闫令琪.10.光场(Lecture 20)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/CLJ/02-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/31/DB/CLJ/02-1/" class="article-date">
  <time class="dt-published" datetime="2021-03-31T02:49:54.000Z" itemprop="datePublished">2021-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/31/DB/CLJ/02-1/">数据库概论.陈立军.02.ER 模型(2)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ER-模型"><a href="#ER-模型" class="headerlink" title="ER 模型"></a>ER 模型</h1><h2 id="扩展-ER-特性"><a href="#扩展-ER-特性" class="headerlink" title="扩展 ER 特性"></a>扩展 ER 特性</h2><h3 id="弱实体集"><a href="#弱实体集" class="headerlink" title="弱实体集"></a>弱实体集</h3><h4 id="还款与贷款的关系建立"><a href="#还款与贷款的关系建立" class="headerlink" title="还款与贷款的关系建立"></a>还款与贷款的关系建立</h4><ul>
<li>还款：还款号，还款日期，金额</li>
<li>贷款：贷款号，金额</li>
<li>贷款对应多个还款</li>
</ul>
<h5 id="表示-1：把还款作为普通实体"><a href="#表示-1：把还款作为普通实体" class="headerlink" title="表示 1：把还款作为普通实体"></a>表示 1：把还款作为普通实体</h5><img src="02-1/image-20210331100724583.png" style="zoom:67%;" />

<ul>
<li>问题：还款的所有属性都不能作为主码<ul>
<li>不满足实体的条件</li>
</ul>
</li>
</ul>
<h5 id="表示-2：把贷款号借给还款实体"><a href="#表示-2：把贷款号借给还款实体" class="headerlink" title="表示 2：把贷款号借给还款实体"></a>表示 2：把贷款号借给还款实体</h5><img src="02-1/image-20210331100814603.png" style="zoom:67%;" />

<ul>
<li>问题：贷款号冗余</li>
</ul>
<h5 id="表示-3：把还款作为贷款的多值属性"><a href="#表示-3：把还款作为贷款的多值属性" class="headerlink" title="表示 3：把还款作为贷款的多值属性"></a>表示 3：把还款作为贷款的多值属性</h5><img src="02-1/image-20210331100943794.png" style="zoom:67%;" />

<ul>
<li>问题：还款概念消失了<ul>
<li>还款应当会和帐户发生支付联系</li>
</ul>
</li>
</ul>
<h5 id="表示-4：把还款作为复合属性"><a href="#表示-4：把还款作为复合属性" class="headerlink" title="表示 4：把还款作为复合属性"></a>表示 4：把还款作为复合属性</h5><ul>
<li>图上的还款应该是<strong>两个圈</strong>（复合属性）</li>
</ul>
<img src="02-1/image-20210331101201338.png" style="zoom:67%;" />

<ul>
<li>问题：还款作为复合<strong>属性</strong>，不能和帐户（<strong>实体</strong>）发生<strong>联系</strong></li>
</ul>
<h5 id="表示-5：还款作为弱实体"><a href="#表示-5：还款作为弱实体" class="headerlink" title="表示 5：还款作为弱实体"></a>表示 5：还款作为弱实体</h5><ul>
<li>下图少了个属性（还款日期）</li>
</ul>
<img src="02-1/image-20210331101458616.png" style="zoom:67%;" />

<ul>
<li>弱实体的表示<ul>
<li><strong>两层矩形框</strong></li>
</ul>
</li>
<li>标识性联系<ul>
<li><strong>两层菱形框</strong></li>
</ul>
</li>
</ul>
<h4 id="弱实体集-1"><a href="#弱实体集-1" class="headerlink" title="弱实体集"></a>弱实体集</h4><ul>
<li>弱实体集（Weak Entity Set）<ul>
<li>一个实体集的所有属性都不足以形成主码</li>
</ul>
</li>
<li>标识性联系（identifying relationship）<ul>
<li>弱实体集与其拥有者之间的联系</li>
<li>弱实体集与强实体集之间是一对多的联系</li>
</ul>
</li>
<li>弱实体集必然存在依赖于强实体集</li>
<li><strong>存在依赖并不总会导致一个弱实体集</strong>，从属实体集可以有自己的主码</li>
</ul>
<h4 id="弱实体集的分辨符"><a href="#弱实体集的分辨符" class="headerlink" title="弱实体集的分辨符"></a>弱实体集的分辨符</h4><ul>
<li>分辨符（Discriminator)<ul>
<li>弱实体集中用于区别依赖于某个特定强实体集的属性集合，也称作部分码（partial key)</li>
</ul>
</li>
<li><strong>弱实体集的主码 &#x3D; 强实体集的主码+ 弱实体集的分辨符</strong><ul>
<li>“还款” 主码＝贷款号＋还款号</li>
</ul>
</li>
</ul>
<h4 id="弱实体集在-ER-图中的表示"><a href="#弱实体集在-ER-图中的表示" class="headerlink" title="弱实体集在 ER 图中的表示"></a>弱实体集在 ER 图中的表示</h4><ul>
<li><strong>弱实体集</strong>以<strong>双边框的矩形</strong>表示</li>
<li><strong>标识性联系</strong>以<strong>双边框的菱形</strong>表示</li>
<li><strong>弱实体集的分辨符</strong>用<strong>下划虚线</strong>标明</li>
<li>从联系集用<strong>双线（全部参与）</strong>连接弱实体集，用<strong>箭头（一对多联系）</strong>指向强实体集</li>
</ul>
<h4 id="何时引入弱实体集"><a href="#何时引入弱实体集" class="headerlink" title="何时引入弱实体集"></a>何时引入弱实体集</h4><ul>
<li>作为<strong>层次结构</strong>的一部分<ul>
<li>cs.pku.edu.cn</li>
</ul>
</li>
<li>实体集的一些多值、复合属性可以抽取出来作为弱实体集<ul>
<li>贷款的还款属性</li>
</ul>
</li>
<li>如果弱实体集不但参与和强实体集之间的标识性联系，而且参与和其它实体集的联系，或者弱实体集本身含有很多属性，则将其表述为弱实体集</li>
</ul>
<h3 id="特化"><a href="#特化" class="headerlink" title="特化"></a>特化</h3><ul>
<li>实体集中某些子集具有区别于该实体集内其它实体的特性，可以根据这些差异特性对实体集进行分组，这一分组的过程称作特化<ul>
<li>类似细分</li>
</ul>
</li>
<li><strong>自顶向下</strong>、<strong>逐步求精</strong>的数据库设计过程</li>
<li>子类＝特例＝更小的实体集＝更多的属性</li>
<li>细化：父类 $\to$ 子类</li>
</ul>
<h4 id="特化在-ER-图中的表示"><a href="#特化在-ER-图中的表示" class="headerlink" title="特化在 ER 图中的表示"></a>特化在 ER 图中的表示</h4><ul>
<li>特化用标记为 <strong>ISA</strong> 的三角形来表示<ul>
<li>ISA &#x3D; “ isａ”</li>
<li>表示高层实体和低层实体之间的 “父类－子类” 联系</li>
</ul>
</li>
</ul>
<img src="02-1/image-20210331102621106.png" style="zoom:67%;" />



<ul>
<li>特化使得联系的对象更精确<ul>
<li>可以让一些属性精确定位到子类当中</li>
</ul>
</li>
</ul>
<h3 id="概化"><a href="#概化" class="headerlink" title="概化"></a>概化</h3><ul>
<li>各个实体集根据共有的性质，合成一个较高层的实体集。概化是一个高层实体集与若干个低层实体集之间的包含关系</li>
<li><strong>自底向上</strong>、<strong>逐步合成</strong>的数据库设计过程</li>
<li>泛化：子类 $\to$ 父类</li>
</ul>
<h4 id="概化与特化对比"><a href="#概化与特化对比" class="headerlink" title="概化与特化对比"></a>概化与特化对比</h4><ul>
<li>概化与特化是互逆的，在E-R图中的表示方法相同</li>
<li>特化强调同一实体集内不同实体之间的差异</li>
<li>概化强调不同实体集之间的相似性</li>
<li>反映了数据库设计的不同方法</li>
</ul>
<h4 id="概化中的属性继承"><a href="#概化中的属性继承" class="headerlink" title="概化中的属性继承"></a>概化中的属性继承</h4><ul>
<li>高层实体集的属性被低层实体集自动继承</li>
<li>低层实体集特有的性质仅适用于某个特定的低层实体集</li>
</ul>
<h5 id="两种继承结构"><a href="#两种继承结构" class="headerlink" title="两种继承结构"></a>两种继承结构</h5><ul>
<li>层次结构（Hierarchy）<ul>
<li>实体集作为低层实体集只能参与到一个 ISA 联系中</li>
</ul>
</li>
<li>格结构（Lattice）<ul>
<li>低层实体集可以参与到多个 ISA 联系中</li>
<li>例如下图中的博士参与了两个 ISA 联系</li>
</ul>
</li>
</ul>
<img src="02-1/image-20210331103140711.png" style="zoom:67%;" />

<ul>
<li>“博士” 继承了 “研究生” 与 “职工” 的所有属性</li>
<li>格结构的问题<ul>
<li>如果 “研究生” 与 “职工” 有相同名称的属性，如 “姓名”</li>
<li>可以在 “博士” 中用 “研究生.姓名”，“职工.姓名” 区别开来</li>
</ul>
</li>
</ul>
<h4 id="概化中的成员身份"><a href="#概化中的成员身份" class="headerlink" title="概化中的成员身份"></a>概化中的成员身份</h4><ul>
<li><strong>成员身份</strong>：同一个概化中，一个高层实体<strong>是否可以属于多个</strong>不同低层实体集</li>
</ul>
<h5 id="两种成员身份"><a href="#两种成员身份" class="headerlink" title="两种成员身份"></a>两种成员身份</h5><ul>
<li>不相交的 (Disjoint)<ul>
<li>一个实体至多属于一个低层实体集<ul>
<li>如一个学生只能参加一个项目组</li>
</ul>
</li>
</ul>
</li>
<li>有重叠的 (Overlapping)<ul>
<li>同一实体可同时属于同一概化的多个低层实体集<ul>
<li>如一个老师可以参加多个项目组</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="概化中的全部性约束"><a href="#概化中的全部性约束" class="headerlink" title="概化中的全部性约束"></a>概化中的全部性约束</h4><ul>
<li><strong>全部性约束</strong>：确定高层实体集中的一个实体<strong>是否必须属于至少一个</strong>低层实体集</li>
</ul>
<h5 id="两种全部性约束"><a href="#两种全部性约束" class="headerlink" title="两种全部性约束"></a>两种全部性约束</h5><ul>
<li>全部的 (Total)<ul>
<li>每个高层实体必须属于一个低层实体集<ul>
<li>如学生必须属于本科生或研究生的一种</li>
</ul>
</li>
<li>ER 图的设计中，一般用<strong>双线</strong>连接 ISA</li>
</ul>
</li>
<li>部分的 (Partial)<ul>
<li>允许一些高层实体不属于任何低层实体集<ul>
<li>如学生可以不属于任何项目组</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h3><ul>
<li>如何表达联系之间的联系</li>
<li>某些联系之间存在重叠</li>
</ul>
<h4 id="实例：职工参加项目，并在此过程中可能使用机器"><a href="#实例：职工参加项目，并在此过程中可能使用机器" class="headerlink" title="实例：职工参加项目，并在此过程中可能使用机器"></a>实例：职工参加项目，并在此过程中可能使用机器</h4><h5 id="表示为三元联系"><a href="#表示为三元联系" class="headerlink" title="表示为三元联系"></a>表示为三元联系</h5><img src="02-1/image-20210331104250886.png" style="zoom:67%;" />

<ul>
<li>问题<ul>
<li>作为三元联系，有些职工并不和机器发生联系</li>
<li>不雅驯的命名对于 ER 是个大问题</li>
</ul>
</li>
</ul>
<h5 id="表示为二元联系"><a href="#表示为二元联系" class="headerlink" title="表示为二元联系"></a>表示为二元联系</h5><img src="02-1/image-20210331104412625.png" style="zoom:70%;" />

<ul>
<li>问题<ul>
<li>看不出来职工在项目 A 使用什么机器</li>
</ul>
</li>
</ul>
<h4 id="聚集-1"><a href="#聚集-1" class="headerlink" title="聚集"></a>聚集</h4><img src="02-1/image-20210331104555488.png" style="zoom:67%;" />

<ul>
<li>一个看上去的三元联系实则是<strong>两个动作序列</strong></li>
<li>实体集 A 与 B 以及它们的联系可被看成实体集，然后与另一实体集 C 发生联系</li>
<li><strong>聚集是一种抽象</strong><ul>
<li>通过聚集联系被抽象为高层实体集</li>
</ul>
</li>
</ul>
<h2 id="ER-模型设计要点"><a href="#ER-模型设计要点" class="headerlink" title="ER 模型设计要点"></a>ER 模型设计要点</h2><h3 id="ER-模型设计中的选择问题"><a href="#ER-模型设计中的选择问题" class="headerlink" title="ER 模型设计中的选择问题"></a>ER 模型设计中的选择问题</h3><ul>
<li>实体 &#x2F; 属性</li>
<li>实体 &#x2F; 联系</li>
<li>二元 &#x2F; 多元</li>
<li>聚集 &#x2F; 三元</li>
</ul>
<h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h4><ul>
<li>目标</li>
<li>利弊</li>
</ul>
<h3 id="实体-x2F-属性"><a href="#实体-x2F-属性" class="headerlink" title="实体 &#x2F; 属性"></a>实体 &#x2F; 属性</h3><ul>
<li>实体有多方面性质，属性没有</li>
<li>属性通常是<strong>原子性</strong>的</li>
</ul>
<h3 id="实体-x2F-联系"><a href="#实体-x2F-联系" class="headerlink" title="实体 &#x2F; 联系"></a>实体 &#x2F; 联系</h3><ul>
<li>实体与联系：静态与动态</li>
<li>联系的属性一般是动态的，否则可以抽象成一个（弱）实体</li>
</ul>
<h3 id="二元-x2F-多元"><a href="#二元-x2F-多元" class="headerlink" title="二元 &#x2F; 多元"></a>二元 &#x2F; 多元</h3><ul>
<li>多元到二元的瓠瓜式通用转换方式<ul>
<li>新构建一个<strong>标识实体集</strong> $E$，构造三个新联系集 $R_A$，$R_B$，$B_C$，对每个 $(a_i,b_i,c_i)\in R$，在 $E$ 中创建一个 $e_i$，然后在 $R_A$，$R_B$，$B_C$ 中分别加入联系 $(e_i,a_i)$， $(e_i,b_i)$， $(e_i,c_i)$</li>
<li>但是这样子没有实际意义，单纯是一个标识</li>
</ul>
</li>
</ul>
<h3 id="能否用实体之间的二元联系替换三元联系"><a href="#能否用实体之间的二元联系替换三元联系" class="headerlink" title="能否用实体之间的二元联系替换三元联系"></a>能否用实体之间的二元联系替换三元联系</h3><img src="02-1/image-20210331110718065.png" style="zoom:67%;" />

<ul>
<li>多出来其他的元素 (4,2,3)</li>
<li>一般情况下很难</li>
</ul>
<h3 id="聚集-x2F-三元"><a href="#聚集-x2F-三元" class="headerlink" title="聚集 &#x2F; 三元"></a>聚集 &#x2F; 三元</h3><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul>
<li>一个项目由多个部门资助，一个部门资助多个项目，每个资助协议由一个或多个雇员监督<ul>
<li>监督有属性截至时间，资助有属性起始时间</li>
</ul>
</li>
<li>三元联系<ul>
<li>不明确，如果资助和监督有自己的属性则不能明确表示属性是属于资助的还是监督的</li>
<li>用词奇怪</li>
</ul>
</li>
</ul>
<img src="02-1/image-20210331110934320.png" style="zoom:67%;" />

<ul>
<li>聚集</li>
</ul>
<img src="02-1/image-20210331111102199.png" style="zoom:67%;" />



<h2 id="概念数据库设计过程"><a href="#概念数据库设计过程" class="headerlink" title="概念数据库设计过程"></a>概念数据库设计过程</h2><h3 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A[需求分析结果];</span><br><span class="line">B[局部 ER 模式设计];</span><br><span class="line">C[全局 ER 模式设计];</span><br><span class="line">D[全局 ER 模式优化];</span><br><span class="line">A---&gt;B---&gt;C---&gt;D;</span><br></pre></td></tr></table></figure>



<h3 id="局部-ER-模式设计"><a href="#局部-ER-模式设计" class="headerlink" title="局部 ER 模式设计"></a>局部 ER 模式设计</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">B[确定局部结构范围];</span><br><span class="line">C[实体定义];</span><br><span class="line">D[联系定义];</span><br><span class="line">E[属性分配];</span><br><span class="line">subgraph 局部 ER 模式设计</span><br><span class="line">B---&gt;C---&gt;D---&gt;E;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="全局-ER-模式设计"><a href="#全局-ER-模式设计" class="headerlink" title="全局 ER 模式设计"></a>全局 ER 模式设计</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">B[确定公共实体类型];</span><br><span class="line">C[合并两个局部 ER 模式];</span><br><span class="line">D[检查并消除冲突];</span><br><span class="line">E&#123;是否还有未合并的局部模式&#125;;</span><br><span class="line">F[全局 ER 模式优化];</span><br><span class="line">subgraph 全局 ER 模式设计</span><br><span class="line">B---&gt;C---&gt;D---&gt;E;</span><br><span class="line">E---&gt;|有|C;</span><br><span class="line">end</span><br><span class="line">E---&gt;|无|F;</span><br></pre></td></tr></table></figure>

<h4 id="消除冲突"><a href="#消除冲突" class="headerlink" title="消除冲突"></a>消除冲突</h4><h5 id="属性冲突"><a href="#属性冲突" class="headerlink" title="属性冲突"></a>属性冲突</h5><ul>
<li><strong>属性域的冲突</strong></li>
<li><strong>属性的类型、取值范围不同</strong><ul>
<li>如不同学校的学号编码方式不同</li>
</ul>
</li>
<li><strong>属性取值单位冲突</strong><ul>
<li>如重量分别采用磅、千克</li>
</ul>
</li>
</ul>
<h5 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h5><ul>
<li><strong>同名异义</strong><ul>
<li>不同意义的对象具有相同的名字</li>
</ul>
</li>
<li><strong>异名同义</strong><ul>
<li>同一意义的对象具有不同的名字</li>
</ul>
</li>
</ul>
<h5 id="结构冲突"><a href="#结构冲突" class="headerlink" title="结构冲突"></a>结构冲突</h5><ul>
<li>同一对象在不同应用中的抽象不同<ul>
<li>职工在某应用中是实体，在另一应用中则抽象为属性</li>
</ul>
</li>
<li>同一实体在不同 ER 图中属性组成不同<ul>
<li>有的职工实体有 email，有的职工实体则没有</li>
</ul>
</li>
<li>实体之间的联系在不同 ER 图中呈现不同的类型<ul>
<li>联系种类不同</li>
<li>参与联系的实体不同</li>
</ul>
</li>
</ul>
<h3 id="全局-ER-模式优化"><a href="#全局-ER-模式优化" class="headerlink" title="全局 ER 模式优化"></a>全局 ER 模式优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">subgraph 全局 ER 模式优化</span><br><span class="line">B[合并实体类型];</span><br><span class="line">C[消除冗余属性];</span><br><span class="line">D[消除冗余联系];</span><br><span class="line">B---&gt;C---&gt;D;</span><br><span class="line">end</span><br><span class="line">E[逻辑数据库设计]</span><br><span class="line">D---&gt;E;</span><br></pre></td></tr></table></figure>



<h2 id="ER-模型向关系模式的转换"><a href="#ER-模型向关系模式的转换" class="headerlink" title="ER 模型向关系模式的转换"></a>ER 模型向关系模式的转换</h2><ul>
<li>ER 模型：概念数据模型</li>
<li>关系模式：结构数据模型</li>
</ul>
<h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><ul>
<li>每个实体一张表</li>
<li>实体 $\to$ 关系</li>
<li>属性 $\to$ 关系的属性</li>
</ul>
<img src="02-1/image-20210331114247389.png" style="zoom:67%;" />



<h3 id="复合属性"><a href="#复合属性" class="headerlink" title="复合属性"></a>复合属性</h3><ul>
<li>将每个组合属性作为复合属性所在实体的属性<ul>
<li>复合属性拆解为原子属性</li>
</ul>
</li>
<li>复合属性定义为视图，或由应用定义</li>
</ul>
<img src="02-1/image-20210331114423388.png" style="zoom:67%;" />



<h3 id="多值属性"><a href="#多值属性" class="headerlink" title="多值属性"></a>多值属性</h3><ul>
<li>多值属性 $\to$ 新的关系 + 所在实体的码</li>
<li>单独放在一个表里，避免出现冗余</li>
</ul>
<img src="02-1/image-20210331114552570.png" style="zoom:67%;" />



<h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><h4 id="一对多联系"><a href="#一对多联系" class="headerlink" title="一对多联系"></a>一对多联系</h4><ul>
<li>将单方参与实体的码作为多方参与实体的属性</li>
</ul>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><ul>
<li>教师：教工号、姓名</li>
<li>学生：学生号、姓名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph RL;</span><br><span class="line">A[教师];</span><br><span class="line">B&#123;导师&#125;;</span><br><span class="line">C[学生];</span><br><span class="line">C---B---&gt;A</span><br></pre></td></tr></table></figure>

<ul>
<li>直接多开一个表存教工和学生之间的联系<ul>
<li>有些浪费</li>
</ul>
</li>
<li>简单的关系表</li>
</ul>
<img src="02-1/image-20210331114846206.png" style="zoom:70%;" />



<h4 id="多对多联系"><a href="#多对多联系" class="headerlink" title="多对多联系"></a>多对多联系</h4><ul>
<li>将联系定义为新的关系，属性为参与双方的码</li>
</ul>
<h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A[学生];</span><br><span class="line">B&#123;选修&#125;;</span><br><span class="line">C[课程];</span><br><span class="line">A---B---C;</span><br></pre></td></tr></table></figure>



<img src="02-1/image-20210331115240634.png" style="zoom:67%;" />



<h4 id="一对一联系"><a href="#一对一联系" class="headerlink" title="一对一联系"></a>一对一联系</h4><ul>
<li>若联系双方均部分参与，则将联系定义为一个新的关系，属性为参与双方的码<ul>
<li>新建一个表</li>
</ul>
</li>
<li>若联系一方全部参与，则将联系另一方的码作为全部参与一方的属性<ul>
<li>看成特殊的一对多联系</li>
</ul>
</li>
</ul>
<h3 id="弱实体"><a href="#弱实体" class="headerlink" title="弱实体"></a>弱实体</h3><ul>
<li>弱实体集所对应的关系的码由<strong>弱实体集本身的分辩符</strong>再加上<strong>所依赖的强实体集的码</strong></li>
<li>弱实体集一个表，同时加上其所依赖的强实体的一个码</li>
</ul>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><img src="02-1/image-20210402170643926.png" style="zoom:67%;" />

<ul>
<li>关系表有 3 个<ul>
<li>C（c，f）</li>
<li>B（b，c，e）</li>
<li>A（a，b，c，d）</li>
</ul>
</li>
</ul>
<h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><ul>
<li>概化和特化</li>
<li>高层实体集和低层实体集<strong>分别转为表</strong>，低层实体集所对应的关系包括<strong>高层实体集的码</strong><ul>
<li>低层实体集记录自己独有的属性，以及高层实体集的一个码</li>
<li>性能上不利的地方：如果需要查询低层实体的某些属性信息时（这些属性属于高层实体集时），需要和高层实体的表做一个连接操作</li>
</ul>
</li>
<li>如果概括是<strong>不相交</strong>并且是<strong>全部</strong>的，<strong>则可以不为高层实体集建立关系</strong>，低层实体集所对应的关系<strong>包括</strong>上层实体集的的<strong>所有属性</strong><ul>
<li>高层实体刚好可以<strong>不重不漏</strong>的划分为低层实体</li>
<li>获取所有高层实体的信息只需要两个表求并即可（求并很快）</li>
</ul>
</li>
</ul>
<h3 id="聚集-2"><a href="#聚集-2" class="headerlink" title="聚集"></a>聚集</h3><ul>
<li>实体集 A 与 B 及其联系 R 被抽象成实体集 C，C 与另一实体集 D 构成联系 S，则 S 的码由 C 和 D 的码构成</li>
<li>具体 C 的码是什么需要分情况考虑（看 S 怎么表示）<ul>
<li>参考上面的不同联系的码（一对一、多对多、一对多）</li>
</ul>
</li>
</ul>
<h2 id="逆向工程：关系模式向ER的转换"><a href="#逆向工程：关系模式向ER的转换" class="headerlink" title="逆向工程：关系模式向ER的转换"></a>逆向工程：关系模式向ER的转换</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li>描述<ul>
<li>已知有如下关系模式：R1(<strong>a1</strong>,a2,a3)，R2(<strong>a3</strong>,a4)，R3(<strong>a5</strong>,a6)，R4(<strong>a3</strong>,<strong>a5</strong>,a7)</li>
<li>其中加粗的属性标识为所在关系模式的主码，试画出合适的 ER 图，使得可以将该 ER 图转换为上述关系模式</li>
</ul>
</li>
<li>关键<ul>
<li><strong>重合属性体现了实体之间的联系</strong></li>
</ul>
</li>
<li>答案</li>
</ul>
<img src="02-1/image-20210402173109921.png" style="zoom:80%;" />



<h2 id="ER-模型总结"><a href="#ER-模型总结" class="headerlink" title="ER 模型总结"></a>ER 模型总结</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>概念模型：人脑中的信息世界</li>
<li>概念模型需要<strong>清晰</strong></li>
<li>数据组织必须契合处理需求</li>
<li>操作型应用：ER 模型</li>
<li>综合分析型应用，ER 模型则不太合适</li>
</ul>
<h3 id="符号总览"><a href="#符号总览" class="headerlink" title="符号总览"></a>符号总览</h3><img src="02-1/image-20210402173229472.png"  />

<p><img src="/02-1/image-20210402173718878.png"></p>
<p><img src="/02-1/image-20210402173728842.png"></p>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><ul>
<li>UML：Unified Modeling Language</li>
<li>UML 图谱系<ul>
<li>用例图（use case diagrams）：用户和系统的交互</li>
<li>顺序图（sequence diagram）：用例中活动者与系统其它模块之间交互的时间顺序图</li>
<li>状态图（state diagram）：系统中不同对象的行为</li>
<li>行为图（activity diagram）：说明行为是如何协同的</li>
<li>协作图（collaboration diagram）：描述组成一个复杂系统的不同对象之间的交互（即，消息交换）</li>
</ul>
</li>
</ul>
<h3 id="从-ER-模型到-UML"><a href="#从-ER-模型到-UML" class="headerlink" title="从 ER 模型到 UML"></a>从 ER 模型到 UML</h3><p><img src="/02-1/image-20210402174515751.png"></p>
<p><img src="/02-1/image-20210402174526831.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/31/DB/CLJ/02-1/" data-id="cl9lj74ap00e964tz6qxa7i4h" data-title="数据库概论.陈立军.02.ER 模型(2)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/CLJ/02" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/30/DB/CLJ/02/" class="article-date">
  <time class="dt-published" datetime="2021-03-30T08:04:34.000Z" itemprop="datePublished">2021-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/30/DB/CLJ/02/">数据库概论.陈立军.02.ER 模型(1)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ER-模型"><a href="#ER-模型" class="headerlink" title="ER 模型"></a>ER 模型</h1><ul>
<li>实体联系模型</li>
</ul>
<h2 id="数据库设计过程"><a href="#数据库设计过程" class="headerlink" title="数据库设计过程"></a>数据库设计过程</h2><h3 id="三阶段数据库设计过程"><a href="#三阶段数据库设计过程" class="headerlink" title="三阶段数据库设计过程"></a>三阶段数据库设计过程</h3><ul>
<li>三阶段：<strong>概念结构设计</strong>、<strong>逻辑结构设计</strong>、<strong>物理结构设计</strong><ul>
<li>出发点是基于需求分析</li>
</ul>
</li>
<li><strong>需求分析</strong><ul>
<li>确定存储哪些数据，建立哪些应用，常用的操作及对象有哪些等</li>
</ul>
</li>
<li><strong>概念数据库设计</strong><ul>
<li>对需求分析所得到数据的更高层的抽象描述</li>
<li><strong>ER 模型</strong>、<strong>UML</strong></li>
</ul>
</li>
<li><strong>逻辑数据库设计</strong><ul>
<li>将概念模型所描述的数据映射为某个特定的 DBMS 模式数据</li>
</ul>
</li>
<li><strong>物理数据库设计</strong></li>
</ul>
<h3 id="四阶段数据库设计过程"><a href="#四阶段数据库设计过程" class="headerlink" title="四阶段数据库设计过程"></a>四阶段数据库设计过程</h3><ul>
<li>把逻辑结构设计进行<strong>细分</strong></li>
<li><strong>概念阶段</strong><ul>
<li>发掘实体及其联系</li>
<li>发掘业务规则</li>
</ul>
</li>
<li><strong>逻辑阶段</strong><ul>
<li>规范化设计</li>
</ul>
</li>
<li><strong>实现阶段</strong><ul>
<li>选择数据类型、定义表、约束、触发器</li>
</ul>
</li>
<li><strong>物理阶段</strong><ul>
<li>索引、磁盘组织</li>
</ul>
</li>
</ul>
<h3 id="不同数据库设计阶段中的术语称谓"><a href="#不同数据库设计阶段中的术语称谓" class="headerlink" title="不同数据库设计阶段中的术语称谓"></a>不同数据库设计阶段中的术语称谓</h3><table>
<thead>
<tr>
<th align="center">阶段</th>
<th align="center">表术语</th>
<th align="center">列术语</th>
<th align="center">行术语</th>
</tr>
</thead>
<tbody><tr>
<td align="center">关系理论</td>
<td align="center">关系</td>
<td align="center">–</td>
<td align="center">元组</td>
</tr>
<tr>
<td align="center">概念&#x2F;逻辑</td>
<td align="center">实体</td>
<td align="center">属性</td>
<td align="center">实例</td>
</tr>
<tr>
<td align="center">实现</td>
<td align="center">行集、表</td>
<td align="center">列</td>
<td align="center">行</td>
</tr>
<tr>
<td align="center">物理</td>
<td align="center">文件</td>
<td align="center">字段</td>
<td align="center">记录</td>
</tr>
</tbody></table>
<h2 id="ER模型基本概念"><a href="#ER模型基本概念" class="headerlink" title="ER模型基本概念"></a>ER模型基本概念</h2><h3 id="ER-模型的重要性"><a href="#ER-模型的重要性" class="headerlink" title="ER 模型的重要性"></a>ER 模型的重要性</h3><ul>
<li>ER：<strong>最佳信息模型</strong><ul>
<li>能够很快速的向用户展示内部事务的逻辑</li>
</ul>
</li>
<li>启示：<strong>把 ER 设计作为数据库设计的第一步</strong></li>
</ul>
<h3 id="ER-模型的诞生"><a href="#ER-模型的诞生" class="headerlink" title="ER 模型的诞生"></a>ER 模型的诞生</h3><ul>
<li>Entity-Relationship Model</li>
<li>1976年，P.P.S.Chen提出 ER 模型，用 ER 图来描述概念模型</li>
<li>ER 模型眼中的世界<ul>
<li>世界是有一组称作实体的<strong>基本对象</strong>和这些对象之间的<strong>联系</strong>构成的</li>
</ul>
</li>
</ul>
<h3 id="ER-模型中的实体"><a href="#ER-模型中的实体" class="headerlink" title="ER 模型中的实体"></a>ER 模型中的实体</h3><ul>
<li><strong>实体</strong>（Entity）<ul>
<li><strong>客观存在</strong>并可<strong>相互区分</strong>的事物叫实体</li>
</ul>
</li>
<li><strong>属性</strong>（Attribute）<ul>
<li>实体所具有的某一<strong>特性</strong></li>
<li>一个实体可以由若干个属性来刻画</li>
</ul>
</li>
<li><strong>域</strong>（Domain）<ul>
<li>属性的<strong>取值范围</strong></li>
</ul>
</li>
</ul>
<h4 id="实体型与实体集"><a href="#实体型与实体集" class="headerlink" title="实体型与实体集"></a>实体型与实体集</h4><ul>
<li>实体型（Entity Type)<ul>
<li><strong>实体名</strong> + <strong>属性名</strong>集合</li>
<li>实体（值）是实体型的一个特例</li>
<li>抽象的概念</li>
</ul>
</li>
<li>实体集（Entity Set）<ul>
<li>同型实体的集合</li>
</ul>
</li>
<li>例子<ul>
<li>实体型：学生（姓名、性别）</li>
<li>实体：（张三，男）</li>
<li>实体集：全体学生</li>
</ul>
</li>
</ul>
<h3 id="ER-模型中的联系"><a href="#ER-模型中的联系" class="headerlink" title="ER 模型中的联系"></a>ER 模型中的联系</h3><ul>
<li><strong>联系</strong>（Relationship）<ul>
<li>实体之间的相互关联</li>
</ul>
</li>
<li><strong>联系也可以有属性</strong></li>
<li>联系的<strong>元</strong>（Degree）<ul>
<li>参与联系的<strong>实体集</strong>的个数</li>
<li><strong>一元联系</strong>又被称为<strong>递归联系</strong></li>
</ul>
</li>
<li>联系是发生在<strong>实体集</strong>之间的，而不是实体型</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>联系与联系的元<ul>
<li><strong>学生</strong>与<strong>老师</strong>间的授课联系<ul>
<li>二元联系</li>
</ul>
</li>
<li><strong>学生</strong>与<strong>学生</strong>间有班长联系<ul>
<li>可以是实体集内部的联系</li>
<li><strong>一元联系</strong>，只有一个实体集</li>
</ul>
</li>
</ul>
</li>
<li>联系的属性<ul>
<li>如学生与课程之间有选课联系，每个选课联系都有一个成绩作为其属性</li>
</ul>
</li>
</ul>
<h3 id="实体的码（Key）"><a href="#实体的码（Key）" class="headerlink" title="实体的码（Key）"></a>实体的码（Key）</h3><ul>
<li><strong>超码</strong>（superkey）<ul>
<li>能<strong>唯一标识</strong>实体的属性或属性组</li>
<li>超码的任意超集也是超码</li>
</ul>
</li>
<li><strong>候选码</strong>（candidate key）<ul>
<li>其任意真子集都不能成为超码的<strong>最小超码</strong></li>
</ul>
</li>
<li><strong>主码</strong>（primary key）<ul>
<li>从所有候选码中<strong>选定一个</strong>用来区别同一实体集中的不同实体</li>
<li>一个实体集中任意两个实体在主码上的取值不能相同</li>
<li>选择上一般越简单越好</li>
</ul>
</li>
</ul>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">6</td>
</tr>
</tbody></table>
<ul>
<li>超码<ul>
<li>C、AC、BC、ABC、AB</li>
</ul>
</li>
<li>候选码<ul>
<li>C、AB</li>
</ul>
</li>
</ul>
<h4 id="如何确定联系的码"><a href="#如何确定联系的码" class="headerlink" title="如何确定联系的码"></a>如何确定联系的码</h4><ul>
<li>联系的种类不一样的时候，联系的码也不一样</li>
<li>例子：实体集 A，实体集 B，AB 之间存在联系 C<ul>
<li>如果每个 A 只能和一个 B 发生联系 C<ul>
<li>联系的码：实体集 B 中的一个候选码即可</li>
</ul>
</li>
<li>如果每个 A 可以和多个 B 发生联系 C，多个 A 可以与一个相同的 B 发生联系<ul>
<li>联系的码：实体集 A 和实体集 B 中的各选一个候选码进行组合</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="码在-ER-图中的表示"><a href="#码在-ER-图中的表示" class="headerlink" title="码在 ER 图中的表示"></a>码在 ER 图中的表示</h4><ul>
<li>实体集属性中<strong>作为主码的一部分的属性</strong>用<strong>下划线</strong>来标明</li>
</ul>
<img src="02/image-20210330170242822.png" style="zoom:67%;" />



<h4 id="其他的码"><a href="#其他的码" class="headerlink" title="其他的码"></a>其他的码</h4><ul>
<li><strong>替代码</strong><ul>
<li>除去主码之外的候选码</li>
</ul>
</li>
<li><strong>自然码</strong><ul>
<li>一个与行中属性有逻辑联系的候选码，它是实体的 <strong>“真正的” 属性</strong></li>
</ul>
</li>
<li><strong>代理码</strong><ul>
<li><strong>人工码</strong>，<strong>只起唯一标识作用的序列号</strong>，不是实体本身的属性</li>
</ul>
</li>
<li><strong>智能码</strong><ul>
<li>经过编码的标识符</li>
<li>例如：身份证</li>
</ul>
</li>
</ul>
<h3 id="基本-ER-图要点"><a href="#基本-ER-图要点" class="headerlink" title="基本 ER 图要点"></a>基本 ER 图要点</h3><ul>
<li>一个例子：学生选修课程</li>
</ul>
<img src="02/image-20210330170654534.png" style="zoom:67%;" />

<ul>
<li>实体集<ul>
<li>用<strong>矩形</strong>表示实体集，在框内写上实体名</li>
</ul>
</li>
<li>实体的属性<ul>
<li>用<strong>椭圆</strong>表示实体的属性</li>
<li>用<strong>无向边</strong>把实体与其属性连接起来</li>
</ul>
</li>
<li>联系<ul>
<li>用<strong>菱形</strong>表示实体间的联系</li>
<li>将参与联系的实体用线段连接<ul>
<li>联系的数量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="一些-ER-图的例子"><a href="#一些-ER-图的例子" class="headerlink" title="一些 ER 图的例子"></a>一些 ER 图的例子</h3><ul>
<li><strong>一个实体集只能出现一次</strong></li>
<li>因此实体集内部的联系应该这么表示</li>
</ul>
<img src="02/image-20210330171253835.png" style="zoom:50%;" />

<ul>
<li>ER 图的连通性<ul>
<li>连通：可以进行一些探索性的查询</li>
<li>不连通：可以放在独立的数据库里</li>
</ul>
</li>
<li>联系是<strong>实体集</strong>之间的联系，而不是<strong>实体</strong>之间的联系</li>
</ul>
<h3 id="参与"><a href="#参与" class="headerlink" title="参与"></a>参与</h3><ul>
<li>参与（Participation）</li>
<li>实体集之间的关联称为参与，即<strong>实体参与联系</strong></li>
<li>例子<ul>
<li>王军选修 “数据库基础”</li>
<li>表示实体 “王军” 与 “数据库基础” 参与了联系 “选修”</li>
</ul>
</li>
<li>类型<ul>
<li>E <strong>全部参与</strong> R<ul>
<li>实体集 E 中的每个实体都参与到联系集 R 中的至少一个联系</li>
</ul>
</li>
<li>E <strong>部分参与</strong> R<ul>
<li>实体集 E 中只有部分实体参与参与到联系集 R 的联系中</li>
</ul>
</li>
</ul>
</li>
<li>一个联系的两个实体集可能一个完全参与，一个部分参与</li>
<li>参与在 ER 图中的表示<ul>
<li>用<strong>双线连接</strong>联系与完全参与的实体</li>
</ul>
</li>
</ul>
<img src="02/image-20210330171925043.png" style="zoom:60%;" />

<ul>
<li>识别联系的参与度有何作用？<ul>
<li>在设计关系表时可以确定更优的设计方式</li>
<li>例子：上面的职工、部门之间的管理联系<ul>
<li>设计的时候会把管理这个联系放在部门的表里，而不是放在职工的表里</li>
<li>放在职工的表里，空的地方太多</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="存在依赖"><a href="#存在依赖" class="headerlink" title="存在依赖"></a>存在依赖</h3><ul>
<li>存在依赖（Existence Dependency）</li>
<li>x 存在依赖于 y<ul>
<li>实体 x 的存在依赖于实体 y 的存在</li>
<li>y 称作<strong>支配实体</strong></li>
<li>x 称作<strong>从属实体</strong></li>
<li>如果 y 被删除，则 x 也要被删除</li>
</ul>
</li>
<li>例子</li>
</ul>
<img src="02/image-20210330172659994.png" style="zoom:60%;" />

<ul>
<li>存在依赖必是<strong>完全参与</strong><ul>
<li>还款存在依赖于贷款，则<strong>还款</strong>全部参与和贷款之间的属于联系</li>
</ul>
</li>
</ul>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul>
<li>角色（Role）</li>
<li>实体在联系中的作用称为实体的角色</li>
<li>多元联系中的角色是相对清晰的，一元联系需要显式注明</li>
<li>对于一元联系，为区别各实体参与联系的方式，需要显式指明其角色</li>
</ul>
<h4 id="角色在-ER-图中的表示"><a href="#角色在-ER-图中的表示" class="headerlink" title="角色在 ER 图中的表示"></a>角色在 ER 图中的表示</h4><ul>
<li>当需要显式区分角色时，在连接菱形和矩形的线上加上说明性标注以区别不同的角色</li>
</ul>
<img src="02/image-20210330173111443.png" style="zoom:50%;" />



<h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><h3 id="简单属性与复合属性"><a href="#简单属性与复合属性" class="headerlink" title="简单属性与复合属性"></a>简单属性与复合属性</h3><ul>
<li><strong>简单属性</strong><ul>
<li>不可再分的属性</li>
</ul>
</li>
<li><strong>复合属性</strong>（Composite）<ul>
<li>可以划分为更小的属性</li>
</ul>
</li>
<li>为什么使用复合属性？<ul>
<li>把相关属性聚集起来以反映更高层次的概念，可以使<strong>模型更清晰</strong></li>
</ul>
</li>
<li>例子</li>
</ul>
<img src="02/image-20210330173317919.png" style="zoom:70%;" />



<h3 id="单值属性与多值属性"><a href="#单值属性与多值属性" class="headerlink" title="单值属性与多值属性"></a>单值属性与多值属性</h3><ul>
<li><strong>单值属性</strong><ul>
<li>每一个特定的实体在该属性上的取值唯一</li>
</ul>
</li>
<li><strong>多值属性</strong><ul>
<li>某个特定实体在该属性上有多于一个的取值</li>
</ul>
</li>
<li>多值属性的问题<ul>
<li>拆开成表的时候，会产生<strong>冗余</strong>（其他的单值属性由于这个多值属性的展开而被多次存储）</li>
<li>一般会单独来存</li>
</ul>
</li>
</ul>
<h3 id="派生属性与基属性"><a href="#派生属性与基属性" class="headerlink" title="派生属性与基属性"></a>派生属性与基属性</h3><ul>
<li><strong>派生属性</strong>（Derived）<ul>
<li>可以从其他相关的属性或实体派生出来的属性值</li>
</ul>
</li>
<li>例子：学生的绩点可以由器所选课程的成绩计算出来<ul>
<li>绩点为<strong>派生属性</strong></li>
<li>成绩为<strong>基属性</strong>，或<strong>存储属性</strong></li>
</ul>
</li>
<li>数据库设计的时候，一般把基属性放在实际的表里，派生属性用<strong>视图</strong><ul>
<li>只存基属性值，而派生属性只存其定义或依赖关系，用时再从基属性中计算出来</li>
</ul>
</li>
</ul>
<h3 id="属性在-ER-图中的表示"><a href="#属性在-ER-图中的表示" class="headerlink" title="属性在 ER 图中的表示"></a>属性在 ER 图中的表示</h3><ul>
<li><strong>多值属性</strong>用<strong>双椭圆</strong>表示</li>
</ul>
<img src="02/image-20210330173936528.png" style="zoom:60%;" />

<ul>
<li><strong>派生属性</strong>用<strong>虚椭圆</strong>表示</li>
</ul>
<img src="02/image-20210330174008276.png" style="zoom:50%;" />



<h3 id="NULL-属性"><a href="#NULL-属性" class="headerlink" title="NULL 属性"></a>NULL 属性</h3><ul>
<li>null 表示 ”无意义“<ul>
<li>当实体在某个属性上没有值时设为 null</li>
<li>表示对于这个实体而言，这个属性是不合适的（不存在这个属性）</li>
</ul>
</li>
<li>null 表示 “值未知”<ul>
<li>值存在，但目前没有获得该信息</li>
</ul>
</li>
<li>三值逻辑：true、false、unkown</li>
<li><strong>实体完整性要求主码取值不能为 null</strong></li>
</ul>
<h2 id="联系的基数"><a href="#联系的基数" class="headerlink" title="联系的基数"></a>联系的基数</h2><h3 id="联系的种类"><a href="#联系的种类" class="headerlink" title="联系的种类"></a>联系的种类</h3><ul>
<li>实体之间的<strong>联系的数量</strong>，即<strong>一个实体</strong>通过<strong>一个联系集</strong>能与<strong>另一实体集相关联的实体</strong>的<strong>数目</strong></li>
<li>一对一（1：1）</li>
<li>一对多（1：m）</li>
<li>多对多（m：n）</li>
</ul>
<h3 id="联系种类在-ER-图中的表示"><a href="#联系种类在-ER-图中的表示" class="headerlink" title="联系种类在 ER 图中的表示"></a>联系种类在 ER 图中的表示</h3><h4 id="表示-1"><a href="#表示-1" class="headerlink" title="表示 1"></a>表示 1</h4><ul>
<li>用<strong>箭头</strong>或<strong>线段</strong>来表示联系的种类，<strong>箭头指向单方实体集</strong></li>
</ul>
<img src="02/image-20210330174728017.png" style="zoom:50%;" />

<ul>
<li>一个解释：A 同学，B 导师<ul>
<li>一个学生只能有一个导师</li>
<li>一个导师可以有多个学生</li>
</ul>
</li>
</ul>
<h4 id="表示-2"><a href="#表示-2" class="headerlink" title="表示 2"></a>表示 2</h4><ul>
<li><strong>多方实体的箭头指向联系集</strong></li>
</ul>
<img src="02/image-20210330175030298.png" style="zoom: 60%;" />

<ul>
<li>同样的理解<ul>
<li>一个同学只能参与到一个联系里面，一个老师可以参与到多个联系里面</li>
</ul>
</li>
</ul>
<h4 id="表示-3"><a href="#表示-3" class="headerlink" title="表示 3"></a>表示 3</h4><ul>
<li>在多方实体和联系之间的线段上标注字母</li>
<li>在单方实体和联系之间的线段上标注数字 1</li>
</ul>
<img src="02/image-20210330175427506.png" style="zoom:67%;" />



<h3 id="二元联系的种类"><a href="#二元联系的种类" class="headerlink" title="二元联系的种类"></a>二元联系的种类</h3><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><ul>
<li>两个实体集 $E_1$、$E_2$ 之间的<strong>一对一</strong>联系</li>
<li>$E_1$ 中的一个实体与 $E_2$ 中<strong>至多一个</strong>实体相联系，并且 $E_2$ 中的一个实体与 $E_1$ 中<strong>至多一个</strong>实体相联系</li>
<li><strong>一对一不是一一对应</strong><ul>
<li>可能有实体集中的实体不参与联系（如下图右边）</li>
</ul>
</li>
</ul>
<img src="02/image-20210330175742026.png" style="zoom:67%;" />





<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><ul>
<li>两个实体集 $E_1$、$E_2$ 之间的<strong>一对多</strong>联系</li>
<li>$E_1$ 中的一个实体与 $E_2$ 中 $n(n\ge0)$ 个实体相联系，并且 $E_2$ 中的一个实体与 $E_1$ 中<strong>至多一个</strong>实体相联系</li>
</ul>
<img src="02/image-20210330232018728.png" style="zoom: 67%;" />



<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><ul>
<li>两个实体集 $E_1$、$E_2$ 之间的<strong>多对多</strong>联系</li>
<li>$E_1$ 中的一个实体与 $E_2$ 中 $n(n\ge0)$ 个实体相联系，并且 $E_2$ 中的一个实体与 $E_1$ 中 $m(m\ge0)$ 个实体相联系</li>
</ul>
<img src="02/image-20210330232156769.png" style="zoom:67%;" />



<h3 id="一个实体集内的递归联系"><a href="#一个实体集内的递归联系" class="headerlink" title="一个实体集内的递归联系"></a>一个实体集内的递归联系</h3><ul>
<li>一对一</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph RL;</span><br><span class="line">B&#123;配偶&#125;;</span><br><span class="line">A[职工];</span><br><span class="line">B ---&gt;|妻子| A</span><br><span class="line">B ---&gt;|丈夫| A</span><br></pre></td></tr></table></figure>

<ul>
<li>一对多</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph RL;</span><br><span class="line">B&#123;领导&#125;;</span><br><span class="line">A[职工];</span><br><span class="line">B ---|属下| A</span><br><span class="line">B ---&gt;|上级| A</span><br></pre></td></tr></table></figure>

<ul>
<li>多对多</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph RL;</span><br><span class="line">B&#123;构成&#125;;</span><br><span class="line">A[零件];</span><br><span class="line">B ---|母零件| A</span><br><span class="line">B ---|子零件| A</span><br></pre></td></tr></table></figure>

<h3 id="多元联系"><a href="#多元联系" class="headerlink" title="多元联系"></a>多元联系</h3><h4 id="歧义"><a href="#歧义" class="headerlink" title="歧义"></a>歧义</h4><ul>
<li>如下的 ER 图可能会出现歧义<ul>
<li>每个职工只有一个工种</li>
<li>每个职工在每个部门只有一个工种</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A[工种];</span><br><span class="line">B[职工];</span><br><span class="line">C&#123;工作&#125;;</span><br><span class="line">D[部门];</span><br><span class="line">B --- C;</span><br><span class="line">D --- C;</span><br><span class="line">C ---&gt; A;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改为二元联系<ul>
<li>每个职工只有一个工种</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A[工种];</span><br><span class="line">B[职工];</span><br><span class="line">C&#123;工作&#125;;</span><br><span class="line">E&#123;分配&#125;;</span><br><span class="line">D[部门];</span><br><span class="line">B --- C;</span><br><span class="line">C --- D;</span><br><span class="line">B --- E;</span><br><span class="line">E ---&gt; A;</span><br></pre></td></tr></table></figure>

<h4 id="多元联系中最多允许出现一个箭头"><a href="#多元联系中最多允许出现一个箭头" class="headerlink" title="多元联系中最多允许出现一个箭头"></a>多元联系中最多允许出现一个箭头</h4><ul>
<li>否则可能会有歧义<ul>
<li>（学生，评估报告），老师</li>
<li>（学生，评估报告，项目），老师</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A[学生] --- B&#123;指导&#125; ---&gt; C[老师];</span><br><span class="line">D[评估报告] --- B ---&gt; E[项目];</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="联系的势"><a href="#联系的势" class="headerlink" title="联系的势"></a>联系的势</h4><ul>
<li>势表达了一个实体出现在联系中的次数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A[教师];</span><br><span class="line">B&#123;教授&#125;;</span><br><span class="line">C[课程];</span><br><span class="line">A ---|&quot;(0,2)&quot;| B;</span><br><span class="line">B ---|&quot;(1,4)&quot;| C;</span><br></pre></td></tr></table></figure>

<ul>
<li>0 表示教师可以不教授课程</li>
<li>区分<strong>强制性</strong>和<strong>可选性</strong>联系</li>
</ul>
<h3 id="复合实体"><a href="#复合实体" class="headerlink" title="复合实体"></a>复合实体</h3><ul>
<li>复合实体也称联合实体或<strong>桥接实体</strong></li>
<li><strong>过时了</strong><ul>
<li>早期由于图模型不能表示多对多的联系而产生的</li>
</ul>
</li>
<li>复合实体<ul>
<li>一个 M：N 联系分解成一个 1：M 和一个 1：N</li>
</ul>
</li>
<li>原来的联系</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A[学生]---B&#123;选修&#125;---C[课程];</span><br></pre></td></tr></table></figure>

<ul>
<li>复合实体<ul>
<li>由选修这个实体有关系衍生而来</li>
</ul>
</li>
</ul>
<img src="02/image-20210331095818361.png" style="zoom:67%;" />




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/30/DB/CLJ/02/" data-id="cl9lj74aq00ee64tzgn3xh4un" data-title="数据库概论.陈立军.02.ER 模型(1)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OS/xv6-labs/lab0-environment-utils" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/29/OS/xv6-labs/lab0-environment-utils/" class="article-date">
  <time class="dt-published" datetime="2021-03-29T04:00:00.000Z" itemprop="datePublished">2021-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OS-xv6-labs/">OS.xv6-labs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/29/OS/xv6-labs/lab0-environment-utils/">xv6-labs-2020.lab0.utils</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="lab0-环境配置及系统调用"><a href="#lab0-环境配置及系统调用" class="headerlink" title="lab0 环境配置及系统调用"></a>lab0 环境配置及系统调用</h1><ul>
<li>环境配置：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/tools.html">https://pdos.csail.mit.edu/6.828/2020/tools.html</a></li>
</ul>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>实验环境基于 WSL(windows linux subsystem)</p>
<ul>
<li>WSL 1.0</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 20.04.2 LTS</span><br><span class="line">Release:        20.04</span><br><span class="line">Codename:       focal</span><br></pre></td></tr></table></figure>



<h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><ul>
<li>打开文件 “&#x2F;etc&#x2F;apt&#x2F;sources.list”<ul>
<li>可以备份一下原始的文件</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.back</span><br><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<ul>
<li>修改文件为清华源<ul>
<li><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a></li>
<li>根据版本选择即可</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>



<h2 id="配置-VSCode-作为编辑器"><a href="#配置-VSCode-作为编辑器" class="headerlink" title="配置 VSCode 作为编辑器"></a>配置 VSCode 作为编辑器</h2><ul>
<li>安装好直接 <strong>code .</strong> 即可</li>
<li>权限问题</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mnt/c/Users/User/.vscode/extensions/ms-vscode-remote.remote-wsl-0.54.6/scripts/wslServer.sh: Permission denied</span><br></pre></td></tr></table></figure>

<ul>
<li>修改文件 <strong>&#x2F;etc&#x2F;wsl.conf</strong></li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/wsl.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[automount]</span><br><span class="line">enable = false</span><br></pre></td></tr></table></figure>

<ul>
<li>修改访问权限</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/c/Users/XXX/.vscode/extensions/ms-vscode-remote.remote-wsl-0.54.6/scripts/</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x *</span><br></pre></td></tr></table></figure>



<h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove qemu-system-misc</span><br><span class="line">sudo apt-get install qemu-system-misc=1:4.2-3ubuntu6</span><br></pre></td></tr></table></figure>

<ul>
<li>评分需要安装 python</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python</span><br></pre></td></tr></table></figure>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>例如写好了 <code>sleep.c</code> 之后需要修改 makefile 文件</li>
<li>Add your <code>sleep</code> program to <code>UPROGS</code> in Makefile</li>
</ul>
<h1 id="Lab0"><a href="#Lab0" class="headerlink" title="Lab0"></a>Lab0</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ul>
<li>pipe<ul>
<li>管道通信</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/skyroben/article/details/71513385">https://blog.csdn.net/skyroben/article/details/71513385</a></li>
</ul>
</li>
<li>linux 标准流<ul>
<li>标准输入流：0</li>
<li>标准输出流：1</li>
<li>标准错误流：2</li>
</ul>
</li>
<li>命令行中括号的含义<ul>
<li><code>[]</code>：可写可不写</li>
<li><code>&#123;&#125;</code>：那就必须要在 <code>&#123;&#125;</code> 内给出的选择里选一个</li>
<li><code>&lt;&gt;</code>：表示必选</li>
</ul>
</li>
</ul>
<h3 id="一些准备"><a href="#一些准备" class="headerlink" title="一些准备"></a>一些准备</h3><ul>
<li>修改 makefile</li>
<li>添加程序</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    $U/_sleep\</span><br><span class="line">    $U/_pingpong\</span><br><span class="line">    $U/_primes\</span><br><span class="line">    $U/_find\</span><br><span class="line">    $U/_xargs\</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>在 user 文件夹下新建文件</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sleep.c</span><br><span class="line">pingpong.c</span><br><span class="line">primes.c</span><br><span class="line">find.c</span><br><span class="line">xargs.c</span><br></pre></td></tr></table></figure>



<h3 id="函数封装"><a href="#函数封装" class="headerlink" title="函数封装"></a>函数封装</h3><ul>
<li>在 user&#x2F;user.h 中添加封装函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line"><span class="comment">// wrapped system call(printf.c)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pipe</span><span class="params">(<span class="type">int</span>*)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在某个文件中添加实现</li>
<li>这里我们为了不修改 makefile，直接在 user&#x2F;printf.c 中实现了</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/printf.c</span></span><br><span class="line"><span class="comment">// 放在这感觉不太合适, 但是这样不需要修改 makefile</span></span><br><span class="line"><span class="comment">// wrapped system call</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fork</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        unix_error(<span class="string">&quot;Fork Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pipe</span><span class="params">(<span class="type">int</span>* fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;Failed to creater a pipe!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><ul>
<li>通过系统调用 sleep 实现即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/sleep.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 输出到标准错误流</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Invalid args! Usage: sleep &lt;number&gt;!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sleepTime = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    sleep(sleepTime);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><ul>
<li>实现进程间通信</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/pingpong.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 变量定义</span></span><br><span class="line">    <span class="comment">// parent to child, child to parent</span></span><br><span class="line">    <span class="comment">// 使用一个管道会引发锁的问题</span></span><br><span class="line">    <span class="type">int</span> fdP2C[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> fdC2P[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> msg[ARRAY_SIZE];</span><br><span class="line">    <span class="type">int</span> readNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start</span></span><br><span class="line">    readNumber = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个管道</span></span><br><span class="line">    <span class="comment">// 返回两个文件描述符 fd[0] 读, fd[1] 写</span></span><br><span class="line">    <span class="comment">// fd[1] 的输出是 fd[0] 的输入</span></span><br><span class="line">    Pipe(fdP2C);</span><br><span class="line">    Pipe(fdC2P);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建父子进程</span></span><br><span class="line">    id = Fork();</span><br><span class="line">    <span class="keyword">if</span>(id != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// father</span></span><br><span class="line">        close(fdP2C[<span class="number">0</span>]);</span><br><span class="line">        close(fdC2P[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// write</span></span><br><span class="line">        write(fdP2C[<span class="number">1</span>], <span class="string">&quot;ping&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// read</span></span><br><span class="line">        readNumber = read(fdC2P[<span class="number">0</span>], msg, ARRAY_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(readNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received %s\n&quot;</span>, getpid(), msg);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fdP2C[<span class="number">1</span>]);</span><br><span class="line">        close(fdC2P[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        close(fdP2C[<span class="number">1</span>]);</span><br><span class="line">        close(fdC2P[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// read</span></span><br><span class="line">        readNumber = read(fdP2C[<span class="number">0</span>], msg, ARRAY_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(readNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received %s\n&quot;</span>, getpid(), msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// write</span></span><br><span class="line">        write(fdC2P[<span class="number">1</span>], <span class="string">&quot;pong&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        close(fdP2C[<span class="number">0</span>]);</span><br><span class="line">        close(fdC2P[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// sleep(10);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul>
<li>题目的设计很巧妙，如果是子进程先传消息的话可能出现如下的问题</li>
<li>pingpong 输出如下<ul>
<li>这个错误是子进程先写导致的</li>
<li>父进程结束了，但是子进程还在</li>
</ul>
</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pingpong</span><br><span class="line">3: received ping</span><br><span class="line">4: $r eceived pong</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>只需要等到父进程结束，shell 就可以输出<ul>
<li>linux 代码测试</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fork()!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Father!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><ul>
<li><a target="_blank" rel="noopener" href="https://swtch.com/~rsc/thread/">https://swtch.com/~rsc/thread/</a></li>
<li>保证这样一个性质：每一个进程接收到的一个数字序列的第一个数字一定是质数</li>
<li>主要想法如下<ul>
<li>第一个进程把数字 2-32 通过管道输出给下一个进程</li>
<li>之后每一个进程记录第一个数（记作 a），输出 a（a 是质数），将序列中的其他数字除以 a<ul>
<li>如果能够被 a 整除，说明是合数，丢弃</li>
<li>如果能够不被 a 整除，说明可能是质数，传递给下一个进程</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recurve</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> hasForked = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> firstNumber, num;</span><br><span class="line">    <span class="type">int</span> p1[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 输出第一个数</span></span><br><span class="line">        <span class="keyword">if</span>(first == <span class="number">1</span>) &#123;</span><br><span class="line">            firstNumber = num;</span><br><span class="line">            first = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逐个检查之后的数, 若不能被记录的数整除, 传至下一进程</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(num % firstNumber != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(hasForked == <span class="number">0</span>) &#123;</span><br><span class="line">                    Pipe(p1);</span><br><span class="line">                    <span class="keyword">if</span>(Fork() != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// father</span></span><br><span class="line">                        close(p1[<span class="number">0</span>]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// child</span></span><br><span class="line">                        close(fd);</span><br><span class="line">                        close(p1[<span class="number">1</span>]);</span><br><span class="line">                        recurve(p1[<span class="number">0</span>]);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 退出, 因为之后的代码都是父进程的</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    hasForked = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 写入管道</span></span><br><span class="line">                write(p1[<span class="number">1</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hasForked == <span class="number">1</span>) &#123;</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心问题就是每次只 write/read 一个 int</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 忽略错误处理</span></span><br><span class="line">    <span class="comment">// 第一个进程输出 2-32 到管道里</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> p1[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    Pipe(p1);</span><br><span class="line">    <span class="keyword">if</span> (Fork() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// father</span></span><br><span class="line">        close(p1[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt; <span class="number">35</span>; ++i) &#123;</span><br><span class="line">            write(p1[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 等待直到子进程全被回收</span></span><br><span class="line">        <span class="keyword">while</span>(wait(&amp;status) != <span class="number">-1</span>) &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        recurve(p1[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><ul>
<li>实现功能 xargs</li>
<li>具体功能见注释</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/xargs.c</span></span><br><span class="line"><span class="meta">#include &quot;kernel/types.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;kernel/stat.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;user/user.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;kernel/param.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFFER_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ARG_LENGTH 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// xargs: 将前一个命令的输出作为后面的输入的附加参数, 按照 &quot; &quot;(空格)分开</span></span><br><span class="line"><span class="comment">// 例如: 当前文件目录下有文件 a.txt, b.txt</span></span><br><span class="line"><span class="comment">// ls | xargs rm</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// rm a.txt b.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// echo -e : 字符转义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高级语法(未实现)</span></span><br><span class="line"><span class="comment">// TODO</span></span><br><span class="line"><span class="comment">// -n num 后面加次数, 表示命令在执行的时候一次用的参数的个数, 默认是用所有的</span></span><br><span class="line"><span class="comment">// (1)</span></span><br><span class="line"><span class="comment">// echo -e &quot;1\n2&quot; | xargs -n 1 echo line</span></span><br><span class="line"><span class="comment">// line 1</span></span><br><span class="line"><span class="comment">// line 2</span></span><br><span class="line"><span class="comment">// (2)</span></span><br><span class="line"><span class="comment">// echo -e &quot;1\n2&quot; | xargs echo line</span></span><br><span class="line"><span class="comment">// line 1 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单行读取, 每一行执行一次命令</span></span><br><span class="line"><span class="comment">// 将每一行按照空格分开, 作为参数传入</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="built_in">int</span> argc, <span class="built_in">char</span> **argv</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line">    <span class="built_in">int</span> status;</span><br><span class="line">    <span class="built_in">char</span> pass[MAXARG][MAX_ARG_LENGTH];</span><br><span class="line">    <span class="built_in">int</span> n;</span><br><span class="line">    <span class="built_in">char</span> buffer[MAX_BUFFER_SIZE + <span class="number">1</span>]; <span class="comment">// 多留一位</span></span><br><span class="line">    <span class="built_in">char</span> *start, *now, *last;</span><br><span class="line">    <span class="built_in">int</span> pos; <span class="comment">// 当前应该写入的参数位置</span></span><br><span class="line">    <span class="built_in">char</span> *passHelp[MAXARG]; <span class="comment">// 用于辅助传参</span></span><br><span class="line"></span><br><span class="line">    pos = argc - <span class="number">1</span>;</span><br><span class="line">    memset(pass, <span class="number">0</span>, <span class="keyword">sizeof</span>(pass));</span><br><span class="line">    memset(passHelp, <span class="number">0</span>, <span class="keyword">sizeof</span>(passHelp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制参数</span></span><br><span class="line">    <span class="comment">// xargs 这个参数不需要</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        strcpy(pass[i<span class="number">-1</span>], argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从标准输入流读取输出</span></span><br><span class="line">    <span class="keyword">while</span>((n = read(<span class="number">0</span>, buffer, MAX_BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        buffer[n] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//因为多保留了一位</span></span><br><span class="line">        last = buffer + n;</span><br><span class="line">        <span class="comment">// 将读取到的字符按照空格/回车分开</span></span><br><span class="line">        start = buffer;</span><br><span class="line">        <span class="keyword">for</span>(now = buffer; now &lt; last; ++now) &#123;</span><br><span class="line">            <span class="keyword">if</span>(*now == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                *now = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(pos == MAXARG) &#123;</span><br><span class="line">                    unix_error(<span class="string">&quot;To Many Args!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                strcpy(pass[pos++], start);</span><br><span class="line">                start = now + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(*now == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                *now = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(pos == MAXARG) &#123;</span><br><span class="line">                    unix_error(<span class="string">&quot;To Many Args!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                strcpy(pass[pos++], start);</span><br><span class="line">                start = now + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 每行执行一次</span></span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; pos; ++i) &#123;</span><br><span class="line">                    passHelp[i] = pass[i];</span><br><span class="line">                &#125;</span><br><span class="line">                passHelp[pos] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">                    exec(passHelp[<span class="number">0</span>], passHelp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    wait(&amp;status);</span><br><span class="line">                &#125;</span><br><span class="line">                pos = argc - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个参数</span></span><br><span class="line">        <span class="keyword">if</span>(pos == MAXARG) &#123;</span><br><span class="line">            unix_error(<span class="string">&quot;To Many Args!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        strcpy(pass[pos++], start);</span><br><span class="line">        <span class="comment">// 要求下一次复制的时候, 保留最后一个参数</span></span><br><span class="line">        <span class="comment">// 处理一个字符串被分割为两段</span></span><br><span class="line">        <span class="comment">// 事实上无法区分是两个还是一个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为我们不实现高级功能, 不需要使用 fork</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; pos; ++i) &#123;</span><br><span class="line">        passHelp[i] = pass[i];</span><br><span class="line">    &#125;</span><br><span class="line">    passHelp[pos] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        exec(passHelp[<span class="number">0</span>], passHelp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  echo 3 4 5 | xargs echo 1 2</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/29/OS/xv6-labs/lab0-environment-utils/" data-id="cl9lj74bb00ik64tz6fsy97wf" data-title="xv6-labs-2020.lab0.utils" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xv6/" rel="tag">xv6</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/20/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><a class="page-number" href="/page/23/">23</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/22/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/0/">0</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algebra/">Algebra</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-Kits/">C++.Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG/">CG</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Algorithm/">CG.Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES101/">CG.GAMES101</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES102/">CG.GAMES102</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES103/">CG.GAMES103</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES104/">CG.GAMES104</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES202/">CG.GAMES202</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES203/">CG.GAMES203</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Kits/">CG.Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-LS/">CG.LS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-PBRT/">CG.PBRT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Paper/">CG.Paper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CV/">CV</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Code/">Code</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-CLJ/">DB.CLJ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-MySQL/">DB.MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-SQLServer/">DB.SQLServer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DSA/">DSA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kits/">Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-CXQ/">OS.CXQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-OSTEP/">OS.OSTEP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-xv6-labs/">OS.xv6-labs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-xv6-source-code/">OS.xv6-source-code</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TODO/">TODO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/book-directory/">book.directory</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computation-pyr/">computation.pyr</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/csharp-kits/">csharp.kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/csharp-tds/">csharp.tds</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/images/">images</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/installation/">installation</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mitsuba/">mitsuba</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nothing/">nothing</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-Maya/">software.Maya</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-ps/">software.ps</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-vscode/">software.vscode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/win/">win</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algebra/" rel="tag">Algebra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS/" rel="tag">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BST/" rel="tag">BST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BVH/" rel="tag">BVH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CG-Algorithm/" rel="tag">CG-Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CV/" rel="tag">CV</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Code/" rel="tag">Code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB/" rel="tag">DB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/" rel="tag">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DSA/" rel="tag">DSA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dijkstra/" rel="tag">Dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EG/" rel="tag">EG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Floyd/" rel="tag">Floyd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GI/" rel="tag">GI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Glints/" rel="tag">Glints</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDR/" rel="tag">HDR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HQX/" rel="tag">HQX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Heap/" rel="tag">Heap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kits/" rel="tag">Kits</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCA/" rel="tag">LCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLG/" rel="tag">LLG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MCMC/" rel="tag">MCMC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MIS/" rel="tag">MIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MLT/" rel="tag">MLT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maya/" rel="tag">Maya</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NEE/" rel="tag">NEE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBRT/" rel="tag">PBRT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paper/" rel="tag">Paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Radiometry/" rel="tag">Radiometry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RayTracing/" rel="tag">RayTracing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SAH/" rel="tag">SAH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SDF/" rel="tag">SDF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SGJ/" rel="tag">SGJ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLServer/" rel="tag">SQLServer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shadow/" rel="tag">Shadow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WHM/" rel="tag">WHM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WX/" rel="tag">WX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/book/" rel="tag">book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/computation/" rel="tag">computation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csharp/" rel="tag">csharp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/images/" rel="tag">images</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/installation/" rel="tag">installation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/" rel="tag">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mitsuba/" rel="tag">mitsuba</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobaxterm/" rel="tag">mobaxterm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nothing/" rel="tag">nothing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/obs/" rel="tag">obs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/occlusion/" rel="tag">occlusion</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ps/" rel="tag">ps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/software/" rel="tag">software</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tree/" rel="tag">tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/win/" rel="tag">win</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xv6/" rel="tag">xv6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%83%E5%AE%87%E5%AE%99/" rel="tag">元宇宙</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%A0%E4%BD%95/" rel="tag">几何</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/" rel="tag">可见性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" rel="tag">拓扑排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%99%AE%E5%90%95%E5%85%8B%E5%9D%90%E6%A0%87/" rel="tag">普吕克坐标</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="tag">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algebra/" style="font-size: 10px;">Algebra</a> <a href="/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/tags/BST/" style="font-size: 10px;">BST</a> <a href="/tags/BVH/" style="font-size: 12.5px;">BVH</a> <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/CG/" style="font-size: 20px;">CG</a> <a href="/tags/CG-Algorithm/" style="font-size: 10px;">CG-Algorithm</a> <a href="/tags/CV/" style="font-size: 10.63px;">CV</a> <a href="/tags/Code/" style="font-size: 14.38px;">Code</a> <a href="/tags/DB/" style="font-size: 19.38px;">DB</a> <a href="/tags/DFS/" style="font-size: 12.5px;">DFS</a> <a href="/tags/DP/" style="font-size: 13.13px;">DP</a> <a href="/tags/DSA/" style="font-size: 11.25px;">DSA</a> <a href="/tags/Dijkstra/" style="font-size: 10px;">Dijkstra</a> <a href="/tags/EG/" style="font-size: 12.5px;">EG</a> <a href="/tags/Floyd/" style="font-size: 10.63px;">Floyd</a> <a href="/tags/GI/" style="font-size: 11.25px;">GI</a> <a href="/tags/Glints/" style="font-size: 10px;">Glints</a> <a href="/tags/HDR/" style="font-size: 10px;">HDR</a> <a href="/tags/HQX/" style="font-size: 10px;">HQX</a> <a href="/tags/Heap/" style="font-size: 10px;">Heap</a> <a href="/tags/Kits/" style="font-size: 13.75px;">Kits</a> <a href="/tags/LCA/" style="font-size: 10px;">LCA</a> <a href="/tags/LLG/" style="font-size: 12.5px;">LLG</a> <a href="/tags/MCMC/" style="font-size: 10.63px;">MCMC</a> <a href="/tags/MIS/" style="font-size: 10px;">MIS</a> <a href="/tags/MLT/" style="font-size: 10px;">MLT</a> <a href="/tags/Maya/" style="font-size: 10px;">Maya</a> <a href="/tags/MySQL/" style="font-size: 11.88px;">MySQL</a> <a href="/tags/NEE/" style="font-size: 10px;">NEE</a> <a href="/tags/OS/" style="font-size: 17.5px;">OS</a> <a href="/tags/PBRT/" style="font-size: 10px;">PBRT</a> <a href="/tags/Paper/" style="font-size: 15.63px;">Paper</a> <a href="/tags/Radiometry/" style="font-size: 10px;">Radiometry</a> <a href="/tags/RayTracing/" style="font-size: 10px;">RayTracing</a> <a href="/tags/SAH/" style="font-size: 10px;">SAH</a> <a href="/tags/SDF/" style="font-size: 10px;">SDF</a> <a href="/tags/SGJ/" style="font-size: 10.63px;">SGJ</a> <a href="/tags/SQL/" style="font-size: 13.13px;">SQL</a> <a href="/tags/SQLServer/" style="font-size: 10.63px;">SQLServer</a> <a href="/tags/STL/" style="font-size: 11.25px;">STL</a> <a href="/tags/Shadow/" style="font-size: 10px;">Shadow</a> <a href="/tags/WHM/" style="font-size: 16.88px;">WHM</a> <a href="/tags/WX/" style="font-size: 11.88px;">WX</a> <a href="/tags/YLQ/" style="font-size: 18.13px;">YLQ</a> <a href="/tags/book/" style="font-size: 10.63px;">book</a> <a href="/tags/computation/" style="font-size: 18.75px;">computation</a> <a href="/tags/csharp/" style="font-size: 16.25px;">csharp</a> <a href="/tags/images/" style="font-size: 10px;">images</a> <a href="/tags/installation/" style="font-size: 11.88px;">installation</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/linux/" style="font-size: 11.25px;">linux</a> <a href="/tags/math/" style="font-size: 10px;">math</a> <a href="/tags/mitsuba/" style="font-size: 11.88px;">mitsuba</a> <a href="/tags/mobaxterm/" style="font-size: 10px;">mobaxterm</a> <a href="/tags/nothing/" style="font-size: 10.63px;">nothing</a> <a href="/tags/obs/" style="font-size: 10px;">obs</a> <a href="/tags/occlusion/" style="font-size: 15px;">occlusion</a> <a href="/tags/ps/" style="font-size: 10px;">ps</a> <a href="/tags/software/" style="font-size: 10px;">software</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/tree/" style="font-size: 11.25px;">tree</a> <a href="/tags/vscode/" style="font-size: 10.63px;">vscode</a> <a href="/tags/win/" style="font-size: 10.63px;">win</a> <a href="/tags/xv6/" style="font-size: 16.25px;">xv6</a> <a href="/tags/%E4%BA%8C%E5%88%86/" style="font-size: 10.63px;">二分</a> <a href="/tags/%E5%85%83%E5%AE%87%E5%AE%99/" style="font-size: 10.63px;">元宇宙</a> <a href="/tags/%E5%87%A0%E4%BD%95/" style="font-size: 10px;">几何</a> <a href="/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/" style="font-size: 11.88px;">可见性</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 10.63px;">并查集</a> <a href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">拓扑排序</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%99%AE%E5%90%95%E5%85%8B%E5%9D%90%E6%A0%87/" style="font-size: 10px;">普吕克坐标</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 10px;">最小生成树</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" style="font-size: 13.13px;">最短路</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 10px;">线段树</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/23/CG/WHM-GAMES103/11/">GAMES103.王华民.11.Incompressible Fluid Dynamics and Eulerian Fluids</a>
          </li>
        
          <li>
            <a href="/2022/10/23/CG/Papers/2021/bvh-survey-3/">(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(4)</a>
          </li>
        
          <li>
            <a href="/2022/04/28/CG/Kits/MIS-NEE/">NEE、MIS(多重重要性采样)</a>
          </li>
        
          <li>
            <a href="/2022/04/18/CG/WHM-GAMES103/10/">GAMES103.王华民.10.Surface Waves</a>
          </li>
        
          <li>
            <a href="/2022/04/17/CG/WHM-GAMES103/09-1/">GAMES103.王华民.09.Collision Handling(1)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>