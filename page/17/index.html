<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/17/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-DB/CLJ/07" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/25/DB/CLJ/07/" class="article-date">
  <time class="dt-published" datetime="2021-05-25T08:35:15.000Z" itemprop="datePublished">2021-05-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/25/DB/CLJ/07/">数据库概论.陈立军.07.并发控制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><ul>
<li>并发问题</li>
<li>资源争用</li>
<li>关键：调度</li>
</ul>
<h2 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h2><h3 id="封锁的定义"><a href="#封锁的定义" class="headerlink" title="封锁的定义"></a>封锁的定义</h3><ul>
<li>封锁就是一个事务对某个数据对象加锁，取得对它一定的控制，限制其它事务对该数据对象使用</li>
<li>要访问一个数据项 $R$，事务 $T_i$ 必须先申请对 $R$ 的封锁，如果 $R$ 已经被事务 $T_j$ 加了不相容的锁，则 $T_i$ 需要等待，直至 $T_j$ 释放它的封锁</li>
<li>例子：信号灯</li>
<li>封锁性能<ul>
<li>事务吞吐量</li>
<li>TPC-C：测数据库事务性能<ul>
<li>目前的第一：Ocean Base（阿里）</li>
</ul>
</li>
</ul>
</li>
<li>一些其他的指标<ul>
<li>TPC-H：测数据库的大数据分析处理能力</li>
</ul>
</li>
<li>数据库追求的目标：在避免冲突的前提下，提高事务吞吐量（提高并发度）</li>
</ul>
<h3 id="锁持有期"><a href="#锁持有期" class="headerlink" title="锁持有期"></a>锁持有期</h3><ul>
<li>长锁：保持到事务结束时才释放的锁</li>
<li>短锁：在事务中途就可以释放的锁</li>
<li>例子<ul>
<li>read uncommitted：不申请锁</li>
<li>read committed：短 S 锁</li>
<li>repeatable read：长 S 锁</li>
</ul>
</li>
</ul>
<h3 id="两段锁协议-1"><a href="#两段锁协议-1" class="headerlink" title="两段锁协议"></a>两段锁协议</h3><ul>
<li>Two-Phase Locking Protocol</li>
<li>事务加锁和解锁过程是严格分开的</li>
<li><strong>增长阶段</strong>（Growing Phase）<ul>
<li>事务可以获得锁，但不能释放锁</li>
</ul>
</li>
<li><strong>缩减阶段</strong>（Shrinking Phase）<ul>
<li>事务可以释放锁，但不能获得锁</li>
</ul>
</li>
<li>图示</li>
</ul>
<img src="07/image-20210603213524078.png" style="zoom:60%;" />

<ul>
<li>哪个事务隔离性级别不满足 2PL（两段锁协议）<ul>
<li>read committed</li>
</ul>
</li>
</ul>
<h4 id="两阶段封锁协议的作用"><a href="#两阶段封锁协议的作用" class="headerlink" title="两阶段封锁协议的作用"></a>两阶段封锁协议的作用</h4><ul>
<li>若一组事务均服从两阶段封锁协议，则它们的调度一定是<strong>可串行化</strong>的</li>
<li><strong>封锁点</strong>：事务获得其最后封锁的时间<ul>
<li>获得最后一个锁的时间</li>
</ul>
</li>
<li><strong>事务调度等价于和其封锁点顺序一致的串行调度</strong></li>
<li>例子<ul>
<li>如下图，t1, t2, t3 满足 2PL 则等价的串行顺序是 t1, t3, t2</li>
</ul>
</li>
</ul>
<img src="07/image-20210603214644809.png" style="zoom: 67%;" />



<h4 id="为什么两阶段封锁协议保证可串行化？"><a href="#为什么两阶段封锁协议保证可串行化？" class="headerlink" title="为什么两阶段封锁协议保证可串行化？"></a>为什么两阶段封锁协议保证可串行化？</h4><ul>
<li>令 ${T_0,T_1,\cdots,T_n}$ 是参与调度 $S$ 的事务集</li>
<li>如果 $T_i$ 对数据项 $R$ 加 $A$ 型锁，$T_j$ 对数据项 $R$ 加 $B$ 型锁，且 $\mathrm{comp(A,B)&#x3D;false}$（不相容的锁），若 $T_i$ 先获得锁，则 $T_i$ 先于 $T_j$，记作 $T_i\to T_j$，得到一个优先图</li>
<li>设 $t_i$是 $T_i$ 的封锁点，若 $T_i\to T_j$，则必然有 $t_i&lt;t_j$<ul>
<li>事务 $T_j$ 需要等待 $T_i$ 释放不相容的锁之后，才能获得锁，不妨设这个时间为 $t_m$</li>
<li>$t_i&lt;t_m\le t_j$</li>
</ul>
</li>
<li>若 ${T_0,T_1,\cdots,T_n}$ 不可串行化，则在优先图中存在环，不妨设为 $T_0\to T_1\to\cdots\to T_n\to T_0$，则 $t_0&lt;t_1&lt;\cdots&lt;t_n&lt;t_0$，时间不可能成环，矛盾</li>
</ul>
<h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><ul>
<li>基本锁类型：X 锁、S 锁、U 锁</li>
<li>意向锁：IS、IX、IU、SIX</li>
<li>码范围锁：RangeS_S、RangeI_N…</li>
<li>其他锁：模式锁、闩锁、BU锁</li>
</ul>
<h3 id="基本锁类型（排他锁、共享锁、更新锁）"><a href="#基本锁类型（排他锁、共享锁、更新锁）" class="headerlink" title="基本锁类型（排他锁、共享锁、更新锁）"></a>基本锁类型（排他锁、共享锁、更新锁）</h3><h4 id="排他锁与共享锁"><a href="#排他锁与共享锁" class="headerlink" title="排他锁与共享锁"></a>排他锁与共享锁</h4><ul>
<li>排它锁（X 锁，eXclusive lock）<ul>
<li>lock-X(R)：又称写锁，持有 X 锁可以读写数据项</li>
<li>事务 T 对数据对象 R 加上 X 锁，则其它事务对 R 的<strong>任何封锁请求都不能成功</strong>，直至 T 释放 R 上的 X 锁</li>
</ul>
</li>
<li>共享锁（S 锁，Share lock）<ul>
<li>lock-S(R)：又称读锁，持有 S 锁只能读取数据项</li>
<li>事务 T 对数据对象 R 加上 S 锁，则其它事务对 R 的 <strong>X 锁请求不能成功</strong>，而对 R 的 <strong>S 锁请求可以成功</strong></li>
</ul>
</li>
<li>封锁的相容矩阵 $\mathrm{comp(A,B)}$</li>
</ul>
<table>
<thead>
<tr>
<th align="center">请求锁模式A \ 现有锁模式B</th>
<th align="center">S</th>
<th align="center">X</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S</td>
<td align="center">$\checkmark$</td>
<td align="center">$\times$</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
</tr>
</tbody></table>
<h4 id="先读后写场合中的锁转换"><a href="#先读后写场合中的锁转换" class="headerlink" title="先读后写场合中的锁转换"></a>先读后写场合中的锁转换</h4><ul>
<li>两个事务 T1, T2<ul>
<li>T1: read(a1); read(a2); …; read(an); write(a1)</li>
<li>T2: read(a1); …</li>
</ul>
</li>
<li>T1 需要对 a1 加 X 锁（因为后面要写）<ul>
<li>这样的方案是不好的，因为 T2 无法执行</li>
</ul>
</li>
<li>更好的并发方式<ul>
<li>T1 在 read(a1) 上加 S 锁，在执行 write(a1) 之前升级锁（upgrade）为  X 锁</li>
<li>升级的时候要求没有事务在 a1 上持有锁</li>
</ul>
</li>
<li>如下左图等价于串行调度 T1,T2，右图等价于串行调度 T2,T1</li>
</ul>
<p><img src="/07/image-20210603221848187.png"></p>
<h4 id="带有锁转换的两段锁协议"><a href="#带有锁转换的两段锁协议" class="headerlink" title="带有锁转换的两段锁协议"></a>带有锁转换的两段锁协议</h4><ul>
<li><strong>增长阶段</strong><ul>
<li>可获得 lock-S</li>
<li>可获得 lock-X</li>
<li><strong>可将 lock-S 升级为 lock-X（upgrade）</strong></li>
</ul>
</li>
<li><strong>缩减阶段</strong><ul>
<li>可释放 lock-S</li>
<li>可释放 lock-X</li>
<li><strong>可将 lock-X 降级为 lock-S（downgrade）</strong></li>
</ul>
</li>
</ul>
<h4 id="锁升级与重新申请锁"><a href="#锁升级与重新申请锁" class="headerlink" title="锁升级与重新申请锁"></a>锁升级与重新申请锁</h4><ul>
<li>升级锁和重新申请锁的区别<ul>
<li>申请锁是维护一个队列的<ul>
<li>重新申请锁则会排在队列的最后</li>
<li>升级锁则会排在队列的前面，可能更早考虑</li>
</ul>
</li>
</ul>
</li>
<li>在那个隔离性级别下会出现锁升级<ul>
<li>repeatable read</li>
<li>read committed 不会，因为是短 S 锁</li>
</ul>
</li>
</ul>
<h4 id="锁转化带来的问题"><a href="#锁转化带来的问题" class="headerlink" title="锁转化带来的问题"></a>锁转化带来的问题</h4><ul>
<li>死锁</li>
<li>两个事务都是<strong>先读后写</strong></li>
<li><span id="ex1">如下例子</span><ul>
<li>repeatable read 情况下（read 为长 S 锁）<ul>
<li>T1 在 write(a1) 时需要锁升级，但是如果此时 T2 已经执行到了 read(a1) 之后，此时 T1 等待</li>
<li>同样的道理 T2 也等待，导致死锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="07/image-20210603233000188.png" style="zoom:67%;" />



<h4 id="怎么避免锁转换导致的死锁"><a href="#怎么避免锁转换导致的死锁" class="headerlink" title="怎么避免锁转换导致的死锁"></a>怎么避免锁转换导致的死锁</h4><ul>
<li>引入更新锁（U 锁）</li>
</ul>
<h4 id="更新锁"><a href="#更新锁" class="headerlink" title="更新锁"></a>更新锁</h4><ul>
<li>U 锁，Update lock<ul>
<li><strong>只有读权限</strong></li>
</ul>
</li>
<li>当一个事务查询数据以便将来要进行修改时，可以对数据项施加更新锁<ul>
<li>先读后写的操作申请 U 锁</li>
<li>只读则申请 S 锁</li>
</ul>
</li>
<li>如果事务修改资源，需将更新锁转换为排它锁（X 锁）</li>
<li>一次只有一个事务可以获得资源上的更新锁<ul>
<li>这样就避免了死锁</li>
<li>U 锁和 U 锁不相容，因此<a href="#ex1">上面的例子</a></li>
</ul>
</li>
</ul>
<h5 id="更新锁的相容矩阵"><a href="#更新锁的相容矩阵" class="headerlink" title="更新锁的相容矩阵"></a>更新锁的相容矩阵</h5><table>
<thead>
<tr>
<th align="center">请求锁模式A \ 现有锁模式B</th>
<th align="center">S</th>
<th align="center">X</th>
<th align="center">U</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S</td>
<td align="center">$\checkmark$</td>
<td align="center">$\times$</td>
<td align="center">$\checkmark$</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
</tr>
<tr>
<td align="center">U</td>
<td align="center">$\checkmark$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
</tr>
</tbody></table>
<h3 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h3><ul>
<li>封锁对象<ul>
<li>属性值、属性值集合、元组、关系、索引项、整个索引、整个数据库、物理页、块</li>
</ul>
</li>
<li>不同封锁粒度<ul>
<li>封锁粒度大，则并发度低，开销小</li>
<li>封锁粒度小，则并发度高，开销高</li>
</ul>
</li>
<li>一个锁在数据库中大概占据 100 来个字节</li>
<li>事务的完整性相关域：<ul>
<li>只封锁与操作有关的的数据对象</li>
</ul>
</li>
</ul>
<h4 id="封锁粒度与查询性能"><a href="#封锁粒度与查询性能" class="headerlink" title="封锁粒度与查询性能"></a>封锁粒度与查询性能</h4><ul>
<li>一份早期的数据，数据表<strong>五道口技工学院</strong>中性别为女的记录非常少</li>
<li>满足条件的数据非常少时，最佳粒度为<strong>行锁</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> 五道口技工学院</span><br><span class="line"><span class="keyword">where</span> 性别<span class="operator">=</span><span class="string">&#x27;女&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>满足条件的数据非常多时，最佳粒度为<strong>表锁</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> 五道口技工学院</span><br><span class="line"><span class="keyword">where</span> 性别<span class="operator">=</span><span class="string">&#x27;男&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>系统必须支持多粒度锁，根据查询范围选择最佳粒度</li>
</ul>
<h4 id="多粒度封锁中的隐含冲突"><a href="#多粒度封锁中的隐含冲突" class="headerlink" title="多粒度封锁中的隐含冲突"></a>多粒度封锁中的隐含冲突</h4><ul>
<li>事务 T1（表锁）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> 五道口技工学院</span><br><span class="line"><span class="keyword">where</span> 性别<span class="operator">=</span><span class="string">&#x27;男&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>事务 T2（表锁）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 修改表的属性 */</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 五道口技工学院</span><br></pre></td></tr></table></figure>

<ul>
<li>事务 T3</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> 五道口技工学院</span><br><span class="line"><span class="keyword">where</span> 性别<span class="operator">=</span><span class="string">&#x27;女&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>T1 和 T2 的冲突是能够检测出来的<ul>
<li>锁表中有表的 id</li>
</ul>
</li>
<li>事务 T2 和 T3 的冲突无法检测<ul>
<li>锁表中只有行 id 和表 id，无法检测</li>
</ul>
</li>
<li>冲突无法检测的原因：大集合中包含小集合，存在包含冲突<ul>
<li>在分层封锁中，封锁了上层节点就意味着封锁了所有内层节点</li>
<li>如果有事务 T3 对某元组加了 S 锁，而事务 T2 对该元组所在的关系加了 X 锁，因而隐含地 X 封锁了该元组，从而造成矛盾</li>
</ul>
</li>
</ul>
<img src="07/image-20210604114515233.png" style="zoom: 50%;" />

<ul>
<li>在对某个粒度加锁的同时，在其父节点贴上告示条，表示被占用<ul>
<li>告示条和告示条之间不冲突</li>
<li>告示条告诉别人不能直接加锁</li>
<li>告示条只起到提示作用</li>
</ul>
</li>
<li>引入意向锁（起到告示条的作用）</li>
</ul>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><h4 id="意向锁-I（Intend）"><a href="#意向锁-I（Intend）" class="headerlink" title="意向锁 I（Intend）"></a>意向锁 I（Intend）</h4><ul>
<li>引入意向锁 I（Intend）</li>
<li>当为某节点加上 I 锁，表明其某些内层节点已发生事实上的封锁，防止其它事务再去显式封锁该节点</li>
<li>I 锁的实施是<strong>从封锁层次的根开始</strong>，依次占据路径上的所有节点，直至要真正进行显式封锁的节点的<strong>父节点</strong>为止</li>
</ul>
<h5 id="意向锁-I-的相容性"><a href="#意向锁-I-的相容性" class="headerlink" title="意向锁 I 的相容性"></a>意向锁 I 的相容性</h5><table>
<thead>
<tr>
<th align="center">请求锁模式A \ 现有锁模式B</th>
<th align="center">S</th>
<th align="center">X</th>
<th align="center">I</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S</td>
<td align="center">$\checkmark$</td>
<td align="center">$\times$</td>
<td align="center">${\color{red}\times}$</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">${\color{red}\times}$</td>
<td align="center">$\times$</td>
<td align="center">${\color{red}\checkmark}$</td>
</tr>
</tbody></table>
<h5 id="意向锁-I-的不足之处"><a href="#意向锁-I-的不足之处" class="headerlink" title="意向锁 I 的不足之处"></a>意向锁 I 的不足之处</h5><ul>
<li>能够防范读写冲突</li>
</ul>
<img src="07/image-20210604115935940.png" style="zoom: 67%;" />

<ul>
<li>让读读操作变成了不相容</li>
</ul>
<img src="07/image-20210604120016324.png" style="zoom:67%;" />

<ul>
<li>降低了并发度</li>
<li>根本原因：<strong>I 锁没有告诉我们内层加的锁的类型</strong></li>
<li>引入意向锁 IS 锁，IX 锁</li>
</ul>
<h4 id="更为精细化的意向锁（IS-锁，IX-锁）"><a href="#更为精细化的意向锁（IS-锁，IX-锁）" class="headerlink" title="更为精细化的意向锁（IS 锁，IX 锁）"></a>更为精细化的意向锁（IS 锁，IX 锁）</h4><ul>
<li><strong>IS 锁</strong>：如果对一个数据对象加 IS 锁，表示它的后裔节点拟（意向）加 S 锁</li>
<li><strong>IX 锁</strong>：如果对一个数据对象加 IX 锁，表示它的后裔节点拟（意向）加 X 锁</li>
<li>本质还是意向锁，起到告示条的作用</li>
</ul>
<h5 id="意向锁-IS-x2F-IX-的相容性"><a href="#意向锁-IS-x2F-IX-的相容性" class="headerlink" title="意向锁 IS&#x2F;IX 的相容性"></a>意向锁 IS&#x2F;IX 的相容性</h5><table>
<thead>
<tr>
<th align="center">请求锁模式A \ 现有锁模式B</th>
<th align="center">S</th>
<th align="center">X</th>
<th align="center">IS</th>
<th align="center">IX</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S</td>
<td align="center">$\checkmark$</td>
<td align="center">$\times$</td>
<td align="center">${\color{red}\checkmark}$</td>
<td align="center">${\color{red}\times}$</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">${\color{red}\times}$</td>
</tr>
<tr>
<td align="center">IS</td>
<td align="center">${\color{red}\checkmark}$</td>
<td align="center">$\times$</td>
<td align="center">${\color{red}\checkmark}$</td>
<td align="center">${\color{red}\checkmark}$</td>
</tr>
<tr>
<td align="center">IX</td>
<td align="center">${\color{red}\times}$</td>
<td align="center">${\color{red}\times}$</td>
<td align="center">${\color{red}\checkmark}$</td>
<td align="center">${\color{red}\checkmark}$</td>
</tr>
</tbody></table>
<h5 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h5><ul>
<li>能够防范读写冲突</li>
</ul>
<img src="07/image-20210604120643062.png" style="zoom:67%;" />

<ul>
<li>读读操作还是相容的<ul>
<li>解决了简单的意向锁 I 降低了并发度的问题</li>
</ul>
</li>
</ul>
<img src="07/image-20210604120726693.png" style="zoom:67%;" />



<h4 id="共享与意向排他锁-SIX"><a href="#共享与意向排他锁-SIX" class="headerlink" title="共享与意向排他锁 SIX"></a>共享与意向排他锁 SIX</h4><ul>
<li><strong>共享</strong>、<strong>意向排他</strong><ul>
<li><strong>S + IX</strong></li>
</ul>
</li>
<li>解决如下事务的加锁问题<ul>
<li>在表的级别应该加什么锁呢？</li>
<li>IX 和 S 单独都不能支持这个操作</li>
<li>X 锁并发性很低</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> transaction isolation level repeatable read</span><br><span class="line"><span class="keyword">begin</span> tran <span class="string">&#x27;audit&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> bigtable</span><br><span class="line"><span class="keyword">update</span> bigtable</span><br><span class="line"><span class="keyword">set</span> col <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">where</span> keycolumn <span class="operator">=</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在表上加 SIX 锁，则表示该事务要读整个表（S 锁），同时会更新个别元组（IX 锁）</li>
<li>SIX 锁只和 IS 锁相容<ul>
<li>找同时与 S 锁和 IX 锁相容的锁</li>
</ul>
</li>
</ul>
<h5 id="相容矩阵"><a href="#相容矩阵" class="headerlink" title="相容矩阵"></a>相容矩阵</h5><table>
<thead>
<tr>
<th align="center">请求锁模式A \ 现有锁模式B</th>
<th align="center">S</th>
<th align="center">X</th>
<th align="center">U</th>
<th align="center">IS</th>
<th align="center">IX</th>
<th align="center">SIX</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S</td>
<td align="center">$\checkmark$</td>
<td align="center">$\times$</td>
<td align="center">$\checkmark$</td>
<td align="center">${\color{red}\checkmark}$</td>
<td align="center">${\color{red}\times}$</td>
<td align="center">$\times$</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">${\color{red}\times}$</td>
<td align="center">$\times$</td>
</tr>
<tr>
<td align="center">U</td>
<td align="center">$\checkmark$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">$\checkmark$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
</tr>
<tr>
<td align="center">IS</td>
<td align="center">${\color{red}\checkmark}$</td>
<td align="center">$\times$</td>
<td align="center">$\checkmark$</td>
<td align="center">${\color{red}\checkmark}$</td>
<td align="center">${\color{red}\checkmark}$</td>
<td align="center">${\color{red}\checkmark}$</td>
</tr>
<tr>
<td align="center">IX</td>
<td align="center">${\color{red}\times}$</td>
<td align="center">${\color{red}\times}$</td>
<td align="center">$\times$</td>
<td align="center">${\color{red}\checkmark}$</td>
<td align="center">${\color{red}\checkmark}$</td>
<td align="center">$\times$</td>
</tr>
<tr>
<td align="center">SIX</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">${\color{red}\checkmark}$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
</tr>
</tbody></table>
<h3 id="SQL-Server-的锁模式"><a href="#SQL-Server-的锁模式" class="headerlink" title="SQL Server 的锁模式"></a>SQL Server 的锁模式</h3><img src="07/image-20210604135729531.png" style="zoom: 67%;" />

<h4 id="模式修改锁（Sch-M锁）"><a href="#模式修改锁（Sch-M锁）" class="headerlink" title="模式修改锁（Sch-M锁）"></a>模式修改锁（Sch-M锁）</h4><ul>
<li>执行表的 DDL 操作时使用模式修改锁</li>
<li>Sch-M 锁与所有锁模式都不相容</li>
</ul>
<h4 id="模式稳定锁（Sch-S锁）"><a href="#模式稳定锁（Sch-S锁）" class="headerlink" title="模式稳定锁（Sch-S锁）"></a>模式稳定锁（Sch-S锁）</h4><ul>
<li>当编译查询时，使用模式稳定锁</li>
<li>Sch-S 锁与除了 Sch-M 锁之外所有其它锁模式相容</li>
<li>此时其它事务都能继续运行，但不能对表执行 DDL 操作</li>
</ul>
<h4 id="SQL-Server中的大容量更新锁"><a href="#SQL-Server中的大容量更新锁" class="headerlink" title="SQL Server中的大容量更新锁"></a>SQL Server中的大容量更新锁</h4><ul>
<li>BU 锁，Bulk update lock</li>
<li>当使用 <code>bulk insert</code> 命令或 <code>bcp</code> 工具将数据大容量复制到表，且指定了 <code>TABLOCK</code> 提示或者使用 <code>sp_tableoption</code> 设置了 <code>table lock on bulk</code> 表选项时，将使用大容量更新锁</li>
<li>大容量更新锁允许多个进程将数据并行地大容量复制到同一表，同时防止其它不进行大容量复制数据的进程访问该表</li>
</ul>
<h3 id="SQL-Server-码范围锁"><a href="#SQL-Server-码范围锁" class="headerlink" title="SQL Server 码范围锁"></a>SQL Server 码范围锁</h3><ul>
<li>如何避免<strong>幻象</strong>的产生</li>
<li><strong>只封锁现有数据是无效的</strong></li>
<li>查询例子</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> R <span class="keyword">where</span> A<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> A<span class="operator">&lt;=</span><span class="number">20</span></span><br></pre></td></tr></table></figure>

<ul>
<li>应该防止其他事务往区间 $[10,20]$ 插入数据<ul>
<li>如何防止？</li>
</ul>
</li>
<li>如何找到这样一个区间？</li>
<li>表本身是无序的集合，只能用整个表覆盖这个区间，也即需要申请表级锁，并发度极低</li>
<li>数据库中什么对象是有序的？<ul>
<li>索引是有序的</li>
</ul>
</li>
<li>如果在 A 上存在索引，则可以找到一个紧凑区间</li>
</ul>
<h4 id="码范围锁：范围扫描查询"><a href="#码范围锁：范围扫描查询" class="headerlink" title="码范围锁：范围扫描查询"></a>码范围锁：范围扫描查询</h4><ul>
<li>码范围锁定原理解决了幻像并发问题</li>
<li>码范围锁通过覆盖索引行和索引行之间的范围来工作，因为第二个事务在该范围内进行任何行插入、更新或删除操作时均需要修改索引，而码范围锁覆盖了索引项，所以在第一个事务完成之前会阻塞第二个事务的进行</li>
<li>要求（同时满足）<ul>
<li>必须在查询项上存在索引</li>
<li>隔离性级别为 serializable</li>
</ul>
</li>
</ul>
<h4 id="码范围锁模式"><a href="#码范围锁模式" class="headerlink" title="码范围锁模式"></a>码范围锁模式</h4><ul>
<li>码范围锁包括<strong>范围组件</strong>和<strong>行组件</strong><ul>
<li>前者表示保护两个连续<strong>索引项之间范围的锁模式</strong>（RangeT）</li>
<li>后者表示保护<strong>索引项的锁模式</strong>（K），这两部分用下划线连接，如 RangeT_K</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">范围</th>
<th align="center">行</th>
<th align="center">模式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RangeS</td>
<td align="center">S</td>
<td align="center">RangeS_S</td>
<td align="center">共享范围，共享资源锁；可串行范围扫描</td>
</tr>
<tr>
<td align="center">RangeS</td>
<td align="center">U</td>
<td align="center">RangeS_U</td>
<td align="center">共享范围，更新资源锁；可串行更新扫描</td>
</tr>
<tr>
<td align="center">RangeI</td>
<td align="center">NULL</td>
<td align="center">RangeI_N</td>
<td align="center">插入范围，空资源锁；用于在索引中插入新码之前测试范围</td>
</tr>
<tr>
<td align="center">RangeX</td>
<td align="center">X</td>
<td align="center">RangeX_X</td>
<td align="center">排它范围，排它资源锁；用于更新范围中的码</td>
</tr>
</tbody></table>
<h4 id="码范围锁的相容矩阵"><a href="#码范围锁的相容矩阵" class="headerlink" title="码范围锁的相容矩阵"></a>码范围锁的相容矩阵</h4><table>
<thead>
<tr>
<th align="center">请求模式\现有的授权模式</th>
<th align="center">S</th>
<th align="center">U</th>
<th align="center">X</th>
<th align="center">RangeS_S</th>
<th align="center">RangeS_U</th>
<th align="center">RangeI_N</th>
<th>RangeX_X</th>
</tr>
</thead>
<tbody><tr>
<td align="center">共享(S)</td>
<td align="center">$\checkmark$</td>
<td align="center">$\checkmark$</td>
<td align="center">$\times$</td>
<td align="center">$\checkmark$</td>
<td align="center">$\checkmark$</td>
<td align="center">$\checkmark$</td>
<td>$\times$</td>
</tr>
<tr>
<td align="center">更新(U)</td>
<td align="center">$\checkmark$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">$\checkmark$</td>
<td align="center">$\times$</td>
<td align="center">$\checkmark$</td>
<td>$\times$</td>
</tr>
<tr>
<td align="center">排它(X)</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">$\checkmark$</td>
<td>$\times$</td>
</tr>
<tr>
<td align="center">RangeS_S</td>
<td align="center">$\checkmark$</td>
<td align="center">$\checkmark$</td>
<td align="center">$\times$</td>
<td align="center">$\checkmark$</td>
<td align="center">$\checkmark$</td>
<td align="center">$\times$</td>
<td>$\times$</td>
</tr>
<tr>
<td align="center">RangeS_U</td>
<td align="center">$\checkmark$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">$\checkmark$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td>$\times$</td>
</tr>
<tr>
<td align="center">RangeI_N</td>
<td align="center">${\color{red}\checkmark}$</td>
<td align="center">$\checkmark$</td>
<td align="center">${\color{red}\checkmark}$</td>
<td align="center">${\color{red}\times}$</td>
<td align="center">$\times$</td>
<td align="center">$\checkmark$</td>
<td>$\times$</td>
</tr>
<tr>
<td align="center">RangeX_X</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td align="center">$\times$</td>
<td>$\times$</td>
</tr>
</tbody></table>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><ul>
<li>employees 表上存在 last_name 上的索引</li>
</ul>
<img src="07/image-20210604142311541.png" style="zoom: 70%;" />

<ul>
<li>在 serializable 隔离性级别上执行如下查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> last_name <span class="keyword">between</span> <span class="string">&#x27;Delaney&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;DuLaney&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在索引上找到一个覆盖上面范围的最小区间 $\mathrm{(Dallas,Duluth)}$</li>
<li>如果 Dallas, Donovan 和 Duluth 是叶级的顺序索引码，前两个码将获得码范围锁 RangeS_S<ul>
<li>码范围锁防止任何向以这两个码结束的区间插入数据<ul>
<li>锁住了 Dallas 和 Donovan 后面的区间</li>
</ul>
</li>
<li>没有大于 Dallas 且小于等于 Donovan 的行可以插入，也没有大于 Donovan 且小于等于 Duluth 的行可以插入</li>
</ul>
</li>
<li>能否插入 Dashagua？<ul>
<li>**<span style="color:red">不能插入</span>**，虽然是在查询范围之外，但是在最小覆盖的索引范围内部</li>
</ul>
</li>
</ul>
<h3 id="SQL-Server-锁"><a href="#SQL-Server-锁" class="headerlink" title="SQL Server 锁"></a>SQL Server 锁</h3><img src="07/image-20210604143943619.png" style="zoom:130%;" />



<h3 id="MySQL-中的行锁模式"><a href="#MySQL-中的行锁模式" class="headerlink" title="MySQL 中的行锁模式"></a>MySQL 中的行锁模式</h3><ul>
<li>MySQL 的 innode 引擎，在建表的时候，默认会有一个隐含的自增字段，缺省的会在这个字段上建立聚簇索引</li>
<li>缺省的 MySQL 就是有序的表</li>
<li>MySQL 中的行锁模式<ul>
<li>lock_rec_not_gap：只锁记录</li>
<li>lock_gap：间隙锁，锁两个记录之间的gap，防止记录插入</li>
<li>lock_ordinary：也称为Next-KeyLock，锁一条记录及其之前的间隙</li>
<li>lock_insert_intension：插入意向gap锁，插入记录时使用，是lock_gap的一种特例</li>
</ul>
</li>
<li>图示</li>
</ul>
<p><img src="/07/image-20210604144317013.png"></p>
<ul>
<li>相容性</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RECORD</th>
<th align="center">GAP</th>
<th align="center">NEXT-KEY</th>
<th align="center">II GAP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RECORD</td>
<td align="center"></td>
<td align="center">$\checkmark$</td>
<td align="center"></td>
<td align="center">$\checkmark$</td>
</tr>
<tr>
<td align="center">GAP</td>
<td align="center">$\checkmark$</td>
<td align="center">$\checkmark$</td>
<td align="center">$\checkmark$</td>
<td align="center">$\checkmark$</td>
</tr>
<tr>
<td align="center">NEXT-KEY</td>
<td align="center"></td>
<td align="center">$\checkmark$</td>
<td align="center"></td>
<td align="center">$\checkmark$</td>
</tr>
<tr>
<td align="center">II GAP</td>
<td align="center">$\checkmark$</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">$\checkmark$</td>
</tr>
</tbody></table>
<h4 id="闩锁"><a href="#闩锁" class="headerlink" title="闩锁"></a>闩锁</h4><ul>
<li>lock：保护逻辑对象</li>
<li>latch：保护内存页</li>
<li>以下显示不对内存页加保护的结果<ul>
<li>页头的写入需要做保护</li>
</ul>
</li>
</ul>
<img src="07/image-20210604145703323.png" style="zoom:67%;" />

<ul>
<li>为什么不直接使用排他锁实现？<ul>
<li>太慢了，需要向锁管理器申请，锁表的处理慢</li>
</ul>
</li>
<li>闩锁是自旋锁（spinlock）</li>
<li>使用序列号锁聚簇索引码的问题<ul>
<li>由于自增 id，最新的页面会被很多进程同时写，闩锁竞争激烈</li>
</ul>
</li>
</ul>
<h4 id="MySQL-的自增器"><a href="#MySQL-的自增器" class="headerlink" title="MySQL 的自增器"></a>MySQL 的自增器</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SQL1 */</span></span><br><span class="line"><span class="comment">/* 已知条数 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span> (<span class="number">1</span>),(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SQL2 */</span></span><br><span class="line"><span class="comment">/* 未知条数 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1</span><br></pre></td></tr></table></figure>

<ul>
<li>已知行数用闩锁（mutex），未知行数使用自增锁（auto-inc locking）</li>
<li>为了保证同一个事务插入的数据，自增 id 是连续的</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/25/DB/CLJ/07/" data-id="cl9lj74ay00g464tz3q4w12f1" data-title="数据库概论.陈立军.07.并发控制" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/CLJ/04-8" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/24/DB/CLJ/04-8/" class="article-date">
  <time class="dt-published" datetime="2021-05-24T07:59:08.000Z" itemprop="datePublished">2021-05-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/24/DB/CLJ/04-8/">数据库概论.陈立军.04.非关系型数据</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SQL-非关系型数据"><a href="#SQL-非关系型数据" class="headerlink" title="SQL 非关系型数据"></a>SQL 非关系型数据</h1><ul>
<li>关系型数据库中的非关系数据</li>
<li>关系型数据库的目标：One Size Fits All</li>
<li>非关系数据<ul>
<li>序列、树、图、XML、JSON、RDF</li>
<li>…</li>
</ul>
</li>
</ul>
<h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><ul>
<li>股票走势的指标<ul>
<li>移动平均线</li>
<li>MACD：指数平滑异同平均线</li>
<li>KDJ</li>
<li>BOLL</li>
<li>K 线</li>
</ul>
</li>
<li><strong>需要窗口函数的支持</strong></li>
<li>移动方式<ul>
<li>滑动窗口：最近</li>
<li>跳动窗口：每隔</li>
</ul>
</li>
<li>窗口范围<ul>
<li>基于时间</li>
<li>基于行</li>
<li>基于值</li>
</ul>
</li>
<li>基于行的滑动窗口<ul>
<li>基准：current row</li>
</ul>
</li>
</ul>
<img src="04-8/image-20210524161712986.png" style="zoom:50%;" />

<h3 id="窗口函数声明"><a href="#窗口函数声明" class="headerlink" title="窗口函数声明"></a>窗口函数声明</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function_name(<span class="operator">&lt;</span>argument<span class="operator">&gt;</span>, <span class="operator">&lt;</span>argument<span class="operator">&gt;</span>, ...)</span><br><span class="line"><span class="keyword">over</span> (</span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">Partition</span> <span class="keyword">by</span> 子句<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">Order</span> <span class="keyword">by</span> 子句<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>Windowing 子句<span class="operator">&gt;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>Partition by：对表进行分区，类似group by</li>
<li>Order by：排序</li>
<li>Windowing：窗口函数</li>
</ul>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock(stock_id, trade_day, open_price, high_price, low_price, close_price)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> stock_id</span><br><span class="line"><span class="comment">-- 按照股票号分区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> trade_day</span><br><span class="line"><span class="comment">-- 按照交易日期排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">5</span> preceding <span class="keyword">and</span> <span class="number">3</span> following</span><br><span class="line"><span class="comment">-- 基于行</span></span><br><span class="line"><span class="comment">-- 每行对应的数据窗口是之前 5 行, 之后 3 行</span></span><br><span class="line"><span class="comment">-- 一共 9 行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> unbounded following(<span class="keyword">current</span> <span class="type">row</span>)</span><br><span class="line"><span class="comment">-- 基于行</span></span><br><span class="line"><span class="comment">-- 每行对应的数据窗口是从第一行到最后一行(当前行)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">range</span> <span class="keyword">between</span> <span class="number">50</span> preceding <span class="keyword">and</span> <span class="number">150</span> following</span><br><span class="line"><span class="comment">-- 基于值</span></span><br><span class="line"><span class="comment">-- 每行对应的数据窗口包含比当前行值大50以及小于150的行</span></span><br></pre></td></tr></table></figure>

<ul>
<li>应用例子<ul>
<li>下面例子的边界情况</li>
<li>第一行没有前一行，那么就是当前行和下一行两行的平均</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> stock_id,trade_day,close_price,</span><br><span class="line">       <span class="built_in">avg</span>(close_price) <span class="keyword">over</span>(</span><br><span class="line">           <span class="keyword">order</span> <span class="keyword">by</span> trade_day</span><br><span class="line">           <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> preceding <span class="keyword">and</span> <span class="number">1</span> following</span><br><span class="line">       ) <span class="keyword">as</span> avg_price</span><br><span class="line"><span class="keyword">from</span> stock</span><br></pre></td></tr></table></figure>



<h3 id="窗口函数类型"><a href="#窗口函数类型" class="headerlink" title="窗口函数类型"></a>窗口函数类型</h3><ul>
<li>传统聚集函数：sum,avg,count,max,min</li>
<li>排名函数：rank,dense_rank,row_number</li>
<li>分布函数：percent_rank,cume_dist</li>
<li>逆分布函数：percent_cont,percentile_disc</li>
<li>偏移函数：lag,lead</li>
</ul>
<h4 id="示例表"><a href="#示例表" class="headerlink" title="示例表"></a>示例表</h4><table>
<thead>
<tr>
<th align="center">testid</th>
<th align="center">studentid</th>
<th align="center">score</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Test ABC</td>
<td align="center">Student E</td>
<td align="center">50</td>
</tr>
<tr>
<td align="center">Test ABC</td>
<td align="center">Student C</td>
<td align="center">55</td>
</tr>
<tr>
<td align="center">Test ABC</td>
<td align="center">Student D</td>
<td align="center">55</td>
</tr>
<tr>
<td align="center">Test ABC</td>
<td align="center">Student H</td>
<td align="center">65</td>
</tr>
<tr>
<td align="center">Test ABC</td>
<td align="center">Student I</td>
<td align="center">75</td>
</tr>
<tr>
<td align="center">Test ABC</td>
<td align="center">Student B</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">Test ABC</td>
<td align="center">Student F</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">Test ABC</td>
<td align="center">Student A</td>
<td align="center">95</td>
</tr>
<tr>
<td align="center">Test ABC</td>
<td align="center">Student G</td>
<td align="center">95</td>
</tr>
<tr>
<td align="center">Test XYZ</td>
<td align="center">Student E</td>
<td align="center">50</td>
</tr>
<tr>
<td align="center">Test XYZ</td>
<td align="center">Student C</td>
<td align="center">55</td>
</tr>
<tr>
<td align="center">Test XYZ</td>
<td align="center">Student D</td>
<td align="center">55</td>
</tr>
<tr>
<td align="center">Test XYZ</td>
<td align="center">Student H</td>
<td align="center">65</td>
</tr>
<tr>
<td align="center">Test XYZ</td>
<td align="center">Student I</td>
<td align="center">75</td>
</tr>
<tr>
<td align="center">Test XYZ</td>
<td align="center">Student B</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">Test XYZ</td>
<td align="center">Student F</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">Test XYZ</td>
<td align="center">Student A</td>
<td align="center">95</td>
</tr>
<tr>
<td align="center">Test XYZ</td>
<td align="center">Student G</td>
<td align="center">95</td>
</tr>
<tr>
<td align="center">Test XYZ</td>
<td align="center">Student J</td>
<td align="center">95</td>
</tr>
</tbody></table>
<h4 id="一般聚合函数"><a href="#一般聚合函数" class="headerlink" title="一般聚合函数"></a>一般聚合函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> testid, studentid, score,</span><br><span class="line">       <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">over</span>(</span><br><span class="line">           <span class="keyword">partition</span> <span class="keyword">by</span> testid</span><br><span class="line">           <span class="keyword">order</span> <span class="keyword">by</span> score</span><br><span class="line">           <span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span></span><br><span class="line">       ) <span class="keyword">as</span> cnt</span><br><span class="line"><span class="keyword">from</span> Stats.Scores</span><br></pre></td></tr></table></figure>



<h4 id="排名函数对比"><a href="#排名函数对比" class="headerlink" title="排名函数对比"></a>排名函数对比</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> studentid, score,</span><br><span class="line">       <span class="built_in">rank</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> rk,</span><br><span class="line">       <span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>)<span class="keyword">as</span> drk,</span><br><span class="line">       <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>)<span class="keyword">as</span> rn</span><br><span class="line">fromStats.Scores</span><br></pre></td></tr></table></figure>

<ul>
<li>部分结果展示<ul>
<li>rank、dense_rank、row_number 区别如下</li>
</ul>
</li>
</ul>
<img src="04-8/image-20210524163924647.png" style="zoom:67%;" />



<h4 id="ntile"><a href="#ntile" class="headerlink" title="ntile"></a>ntile</h4><ul>
<li>划档，<strong>尽可能</strong>让每个档中的人数相同</li>
<li>每条记录的返回值就是一个序号</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> studentid, score,</span><br><span class="line">       <span class="built_in">ntile</span>(<span class="number">4</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> nt1,</span><br><span class="line">       <span class="built_in">ntile</span>(<span class="number">3</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> nt2</span><br><span class="line"><span class="keyword">from</span> Stats.Scores</span><br></pre></td></tr></table></figure>

<ul>
<li>参照效果如下（数据似乎和示例表有出入）</li>
</ul>
<img src="04-8/image-20210524164537316.png" style="zoom:60%;" />



<h4 id="percent-rank"><a href="#percent-rank" class="headerlink" title="percent_rank"></a>percent_rank</h4><ul>
<li>返回分位数</li>
<li>计算一个值在一组值当中的相对位置或排名</li>
<li>rk：rank 排名</li>
<li>nr：窗口内总行数</li>
<li>$\mathrm{percent_rank&#x3D;\dfrac{rk-1}{nr-1}}$</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> studentid, score,</span><br><span class="line">       <span class="built_in">percent_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> pr</span><br><span class="line"><span class="keyword">from</span> Stats.Scores</span><br></pre></td></tr></table></figure>

<img src="04-8/image-20210524165211519.png" style="zoom:67%;" />



<h4 id="cume-dist"><a href="#cume-dist" class="headerlink" title="cume_dist"></a>cume_dist</h4><ul>
<li>与 percent_rank 类似</li>
<li>计算某个值一组值内的累积分布，也即计算某指定值在一组值中的相对位置</li>
<li>对于值 r，假定采用升序，r 的 cume_dist 是值<strong>低于或等于</strong> r 的值的行数除以整个行数</li>
</ul>
<img src="04-8/image-20210524165328336.png" style="zoom:67%;" />





<h4 id="逆分布函数"><a href="#逆分布函数" class="headerlink" title="逆分布函数"></a>逆分布函数</h4><ul>
<li>percentile_disc：离散百分位<ul>
<li>找到的结果一定是数据中存在的</li>
</ul>
</li>
<li>percentile_cont：连续百分位<ul>
<li>找到的结果不一定是数据中存在的</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> testid,</span><br><span class="line">       <span class="built_in">percentile_disc</span>(<span class="number">0.5</span>) <span class="keyword">with</span> <span class="keyword">in</span> <span class="keyword">group</span>(<span class="keyword">order</span> <span class="keyword">by</span> score)</span><br><span class="line">           <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> testid) <span class="keyword">as</span> d_median,</span><br><span class="line">       <span class="built_in">percentile_cont</span>(<span class="number">0.5</span>) <span class="keyword">with</span> <span class="keyword">in</span> <span class="keyword">group</span>(<span class="keyword">order</span> <span class="keyword">by</span> score)</span><br><span class="line">           <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> testid) <span class="keyword">as</span> c_median,</span><br><span class="line">       <span class="built_in">percentile_disc</span>(<span class="number">0.25</span>) <span class="keyword">with</span> <span class="keyword">in</span> <span class="keyword">group</span>(<span class="keyword">order</span> <span class="keyword">by</span> score)</span><br><span class="line">           <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> testid) <span class="keyword">as</span> d_lower_quartile,</span><br><span class="line">       <span class="built_in">percentile_cont</span>(<span class="number">0.25</span>) <span class="keyword">with</span> <span class="keyword">in</span> <span class="keyword">group</span>(<span class="keyword">order</span> <span class="keyword">by</span> score)</span><br><span class="line">           <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> testid) <span class="keyword">as</span> c_lower_quartile,</span><br><span class="line">       <span class="built_in">percentile_disc</span>(<span class="number">0.75</span>) <span class="keyword">with</span> <span class="keyword">in</span> <span class="keyword">group</span>(<span class="keyword">order</span> <span class="keyword">by</span> score)</span><br><span class="line">           <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> testid) <span class="keyword">as</span> d_upper_quartile,</span><br><span class="line">       <span class="built_in">percentile_cont</span>(<span class="number">0.75</span>) <span class="keyword">with</span> <span class="keyword">in</span> <span class="keyword">group</span>(<span class="keyword">order</span> <span class="keyword">by</span> score)</span><br><span class="line">           <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> testid) <span class="keyword">as</span> c_upper_quartile</span><br><span class="line"><span class="keyword">from</span> Stats.Scores</span><br></pre></td></tr></table></figure>

<p><img src="/04-8/image-20210524165631469.png"></p>
<h4 id="偏移函数"><a href="#偏移函数" class="headerlink" title="偏移函数"></a>偏移函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lag</span>(表达式,偏移量,缺省值) <span class="keyword">over</span>(...)</span><br><span class="line"><span class="comment">-- 将当前行与同一值集中的先前行进行比较</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">lead</span>(表达式,偏移量,缺省值) <span class="keyword">over</span>(...)</span><br><span class="line"><span class="comment">-- 将当前行与同一值集中的后续行进行比较</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">lag</span>(score,<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">as</span> pre_score,</span><br><span class="line">       score,</span><br><span class="line">       <span class="built_in">lead</span>(score,<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">as</span> next_score</span><br><span class="line"><span class="keyword">from</span> Stats.Scores</span><br></pre></td></tr></table></figure>



<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><ul>
<li>数据结构<ul>
<li><strong>树</strong>：职工之间的领导联系</li>
<li><strong>有向图</strong>：零件之间的构成联系</li>
<li><strong>无向图</strong>：交通网络</li>
</ul>
</li>
<li>操作需求<ul>
<li>返回指定节点的所有子（父）节点，显示格式</li>
<li>改变隶属关系</li>
<li>环路检测</li>
<li>生成传递闭包</li>
<li>最短路径</li>
</ul>
</li>
</ul>
<h4 id="层次结构的例子"><a href="#层次结构的例子" class="headerlink" title="层次结构的例子"></a>层次结构的例子</h4><img src="04-8/image-20210524170430597.png" style="zoom:67%;" />

<h4 id="层次结构的关系表示方法"><a href="#层次结构的关系表示方法" class="headerlink" title="层次结构的关系表示方法"></a>层次结构的关系表示方法</h4><ul>
<li>对于树、图等数据结构，其关系存储有以下三种方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">A--&gt;B;</span><br><span class="line">A--&gt;C;</span><br><span class="line">B--&gt;D;</span><br><span class="line">B--&gt;E;</span><br><span class="line">C--&gt;F</span><br></pre></td></tr></table></figure>

<h5 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h5><ul>
<li>adjacent(child,parent)</li>
</ul>
<table>
<thead>
<tr>
<th align="center">child</th>
<th align="center">parent</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">A</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">A</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">B</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">B</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">C</td>
</tr>
</tbody></table>
<h5 id="物化路径"><a href="#物化路径" class="headerlink" title="物化路径"></a>物化路径</h5><ul>
<li>记录所有的路径</li>
<li>materialize_path(node,path)</li>
</ul>
<table>
<thead>
<tr>
<th align="center">node</th>
<th align="center">path</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">.A</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">.A.B</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">.A.C</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">.A.B.D</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">.A.B.E</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">.A.C.F</td>
</tr>
</tbody></table>
<h5 id="嵌套集合"><a href="#嵌套集合" class="headerlink" title="嵌套集合"></a>嵌套集合</h5><ul>
<li>子结点的范围是父结点的一个细分</li>
<li>nested_net(node,left_value,right_value)</li>
</ul>
<table>
<thead>
<tr>
<th align="center">node</th>
<th align="center">left_value</th>
<th align="center">right_value</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">1</td>
<td align="center">12</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">2</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">8</td>
<td align="center">11</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">5</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">9</td>
<td align="center">10</td>
</tr>
</tbody></table>
<img src="04-8/image-20210524171544028.png" style="zoom:50%;" />



<h4 id="应用需求"><a href="#应用需求" class="headerlink" title="应用需求"></a>应用需求</h4><ul>
<li>找到某个结点的所有子孙节点</li>
<li><strong>递归查询</strong></li>
</ul>
<h3 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h3><ul>
<li>内部实现，多次连接直到最终形成的表为空</li>
</ul>
<h4 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h4><ul>
<li>Connect By</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> part, subpart</span><br><span class="line"><span class="keyword">From</span> Components</span><br><span class="line"><span class="keyword">Start</span> <span class="keyword">with</span> part <span class="operator">=</span> <span class="string">&#x27;trike&#x27;</span></span><br><span class="line"><span class="keyword">Connect</span> <span class="keyword">by</span> prior subart<span class="operator">=</span>part</span><br><span class="line"><span class="comment">-- 上一条的 subpart 是本条的 part</span></span><br></pre></td></tr></table></figure>



<h4 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h4><ul>
<li>基本事实：儿子是孩子</li>
<li>规则：儿子的孩子还是孩子</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> RecursiveCTE</span><br><span class="line"><span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">-- 定位点成员 Anchor Member</span></span><br><span class="line">    <span class="keyword">SELECT</span> ...</span><br><span class="line">    <span class="keyword">FROM</span> BaseTable</span><br><span class="line"></span><br><span class="line">    UNIONALL</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 递归成员 Recursive Member</span></span><br><span class="line">    <span class="keyword">SELECT</span> ...</span><br><span class="line">    <span class="keyword">FROM</span> RecursiveCTE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">Recursive</span> CTE;</span><br></pre></td></tr></table></figure>

<ul>
<li>实际例子</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Components(part, subpart) <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> part, subpart</span><br><span class="line">    <span class="keyword">from</span> Assembly</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- C 的子零件也是 A 的子零件</span></span><br><span class="line">    <span class="keyword">select</span> A.part, C.subpart</span><br><span class="line">    <span class="keyword">from</span> Assembly A, Components C</span><br><span class="line">    <span class="keyword">where</span> A.subpart<span class="operator">=</span>C.part</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Components <span class="keyword">where</span> part<span class="operator">=</span><span class="string">&#x27;trike&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从最基础的语法出发实现的递归查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> dbo.fn_subordinates(<span class="variable">@root</span> <span class="keyword">as</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">returns</span> <span class="variable">@Subs</span> <span class="keyword">Table</span> (</span><br><span class="line">    empid <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,</span><br><span class="line">    level <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> <span class="variable">@lvl</span> <span class="keyword">as</span> <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">set</span> <span class="variable">@lvl</span><span class="operator">=</span><span class="number">0</span>; <span class="comment">--Initialize level counter with 0</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> <span class="variable">@Subs</span>(empid,level) <span class="comment">--Insertrootnodeto@Subs</span></span><br><span class="line">    <span class="keyword">select</span> empid, <span class="variable">@lvl</span></span><br><span class="line">    <span class="keyword">from</span> emp</span><br><span class="line">    <span class="keyword">where</span> empid<span class="operator">=</span><span class="variable">@root</span>;</span><br><span class="line">    while @<span class="variable">@rowcount</span><span class="operator">&gt;</span><span class="number">0</span> <span class="comment">--while previous level had rows</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">set</span> <span class="variable">@lvl</span> <span class="operator">=</span> <span class="variable">@lvl</span><span class="operator">+</span><span class="number">1</span>; <span class="comment">--Increment level counter</span></span><br><span class="line">        <span class="comment">--Insert next level of sub ordinates to@Subs</span></span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> <span class="variable">@Subs</span>(empid,level)</span><br><span class="line">        <span class="keyword">select</span> C.empid,<span class="variable">@lvl</span></span><br><span class="line">        <span class="keyword">from</span> <span class="variable">@Subs</span> <span class="keyword">AS</span> P <span class="comment">--P=Parent</span></span><br><span class="line">            <span class="keyword">join</span> emp <span class="keyword">AS</span> C <span class="comment">--C=Child</span></span><br><span class="line">            <span class="keyword">on</span> P.lvl<span class="operator">=</span><span class="variable">@lvl</span><span class="number">-1</span> <span class="comment">--Filter parents from previous level</span></span><br><span class="line">        <span class="keyword">and</span> C.mgrid<span class="operator">=</span>P.empid;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="Hierachyid：SQL-Server"><a href="#Hierachyid：SQL-Server" class="headerlink" title="Hierachyid：SQL Server"></a>Hierachyid：SQL Server</h4><ul>
<li>可以存储树的结点，存储树形结构</li>
<li>hierarchyid 表示层次结构中的位置，由应用程序来生成和分配 hierarchyid 值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp (</span><br><span class="line">    NodeID hierarchyid <span class="keyword">primary</span> key clustered,</span><br><span class="line">    NodeLevel <span class="keyword">as</span> NodeID.GetLevel(),</span><br><span class="line">    eno <span class="type">int</span>,</span><br><span class="line">    ename <span class="type">char</span>(<span class="number">20</span>),</span><br><span class="line">    title <span class="type">char</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable">@root</span> hierarchyid,</span><br><span class="line">        <span class="variable">@child1</span> hierarchyid,</span><br><span class="line">        <span class="variable">@child2</span> hierarchyid,</span><br><span class="line">        <span class="variable">@grandchild1</span> hierarchyid</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(NodeID,eno,ename,title)</span><br><span class="line"><span class="keyword">values</span>(hierarchyid::GetRoot(),<span class="number">1</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;CEO&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@root</span><span class="operator">=</span>hierarchyid::GetRoot()</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@child1</span><span class="operator">=</span><span class="variable">@root</span>.GetDescendant(<span class="keyword">null</span>,<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(NodeID,eno,ename,title)</span><br><span class="line"><span class="keyword">values</span>(<span class="variable">@child1</span>,<span class="number">2</span>,<span class="string">&#x27;bob&#x27;</span>,<span class="string">&#x27;VP&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@child2</span><span class="operator">=</span><span class="variable">@root</span>.GetDescendant(<span class="variable">@child1</span>,<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp (NodeID,eno,ename,title)</span><br><span class="line"><span class="keyword">values</span>(<span class="variable">@child2</span>,<span class="number">3</span>,<span class="string">&#x27;Arm&#x27;</span>,<span class="string">&#x27;MS&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@grandchild1</span><span class="operator">=</span><span class="variable">@child1</span>.GetDescendant(<span class="keyword">null</span>, <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(NodeID,eno,ename,title)</span><br><span class="line"><span class="keyword">values</span>(<span class="variable">@grandchild1</span>,<span class="number">4</span>,<span class="string">&#x27;jerry&#x27;</span>,<span class="string">&#x27;PM&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> NodeID.ToString() <span class="keyword">as</span> NodePath,<span class="operator">*</span> <span class="keyword">from</span> emp</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> NodeID.GetAncestor(<span class="number">2</span>) <span class="keyword">as</span> GrandPa,ename</span><br><span class="line"><span class="keyword">from</span> emp <span class="keyword">where</span> eno<span class="operator">=</span><span class="number">4</span></span><br></pre></td></tr></table></figure>



<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="SQL-Server-1"><a href="#SQL-Server-1" class="headerlink" title="SQL Server"></a>SQL Server</h3><ul>
<li>图 &#x3D; 顶点表 + 边表</li>
</ul>
<img src="04-8/image-20210524173555632.png" style="zoom:50%;" />

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> (...) <span class="keyword">as</span> NODE</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> (...) <span class="keyword">as</span> EDGE</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> ForumMembers(</span><br><span class="line">    MemberID <span class="type">int</span>,</span><br><span class="line">    MemberName <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">as</span> node</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> ForumPosts(</span><br><span class="line">    PostID <span class="type">int</span>,</span><br><span class="line">    PostTitle <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    Postbody <span class="type">varchar</span>(<span class="number">1000</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">as</span> node</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Written_By</span><br><span class="line"><span class="keyword">as</span> edge</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Likes</span><br><span class="line"><span class="keyword">as</span> edge</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Reply_To</span><br><span class="line"><span class="keyword">as</span> edge</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> ForumMembers <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Mike&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> ForumPosts <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;Intro&#x27;</span>,<span class="string">&#x27;I&#x27;&#x27;m Mike from Argentina&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> Written_By($to_id,$from_id) <span class="keyword">values</span>(</span><br><span class="line">    (<span class="keyword">select</span> $node_id <span class="keyword">from</span> ForumMembers <span class="keyword">where</span> MemberId<span class="operator">=</span><span class="number">1</span>),</span><br><span class="line">    (<span class="keyword">select</span> $node_id <span class="keyword">from</span> dbo.ForumPosts <span class="keyword">where</span> PostID<span class="operator">=</span><span class="number">8</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@xml</span><span class="operator">=</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">&lt;bibliography&gt;</span></span><br><span class="line"><span class="string">    &lt;book&gt;</span></span><br><span class="line"><span class="string">        &lt;title&gt;Foundations…&lt;/title&gt;</span></span><br><span class="line"><span class="string">        &lt;author&gt;Abiteboul&lt;/author&gt;</span></span><br><span class="line"><span class="string">        &lt;author&gt;Hull&lt;/author&gt;</span></span><br><span class="line"><span class="string">        &lt;author&gt;Vianu&lt;/author&gt;</span></span><br><span class="line"><span class="string">        &lt;publisher&gt;AddisonWesley&lt;/publisher&gt;</span></span><br><span class="line"><span class="string">        &lt;year&gt;1995&lt;/year&gt;</span></span><br><span class="line"><span class="string">    &lt;/book&gt;</span></span><br><span class="line"><span class="string">&lt;/bibliography&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ExtractValue(<span class="variable">@xml</span>, <span class="string">&#x27;//author&#x27;</span>)</span><br><span class="line"><span class="comment">-- Abiteboul,Hull,Vianu</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> ExtractValue(<span class="variable">@xml</span>, <span class="string">&#x27;//author[2]&#x27;</span>)</span><br><span class="line"><span class="comment">-- Hull</span></span><br></pre></td></tr></table></figure>



<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul>
<li>对象：{属性名：属性值，属性名：属性值 …}</li>
<li>数组：[ value, value, value …]</li>
</ul>
<h3 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL"></a>MySQL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 解析为一个 JSON 数组</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">json_array</span>(<span class="number">1</span>, &quot;abc&quot;, <span class="keyword">null</span>, <span class="literal">true</span>, curtime())</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解析成一个 JSON 对象</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">json_object</span>(<span class="string">&#x27;id&#x27;</span>, <span class="number">87</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;carrot&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tj10 (a json, b <span class="type">int</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tj10 <span class="keyword">values</span></span><br><span class="line">    (<span class="string">&#x27;[3,10,5,&quot;x&quot;,44]&#x27;</span>, <span class="number">33</span>),</span><br><span class="line">    (<span class="string">&#x27;[3,10,5,17,[22,&quot;y&quot;,66]]&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> a<span class="operator">-</span><span class="operator">&gt;</span>&quot;$[3]&quot;, a<span class="operator">-</span><span class="operator">&gt;</span>&quot;$[4][1]&quot; <span class="keyword">from</span> tj10</span><br><span class="line"><span class="comment">-- &quot;X&quot;, NULL</span></span><br><span class="line"><span class="comment">-- 17 , &quot;Y&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> jemp(</span><br><span class="line">    c json,</span><br><span class="line">    g <span class="type">int</span> generated always <span class="keyword">as</span>(c<span class="operator">-</span><span class="operator">&gt;</span>&quot;$.id&quot;),</span><br><span class="line">    index i(g)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> jemp(c) <span class="keyword">values</span></span><br><span class="line">    (<span class="string">&#x27;&#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;Fred&quot;&#125;&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;&#123;&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;Wilma&quot;&#125;&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;&#123;&quot;id&quot;:&quot;3&quot;,&quot;name&quot;:&quot;Barney&quot;&#125;&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;&#123;&quot;id&quot;:&quot;4&quot;,&quot;name&quot;:&quot;Betty&quot;&#125;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> c, json_extract(c,&quot;$.id&quot;),g</span><br><span class="line"><span class="keyword">from</span> jemp</span><br><span class="line"><span class="keyword">where</span> json_extract(c,&quot;$.id&quot;)<span class="operator">&gt;</span><span class="number">1</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> json_extract(c,&quot;$.name&quot;)</span><br></pre></td></tr></table></figure>



<h2 id="RDF"><a href="#RDF" class="headerlink" title="RDF"></a>RDF</h2><ul>
<li>资源描述框架 RDF</li>
</ul>
<p><img src="/04-8/image-20210524174716862.png"></p>
<ul>
<li>三元组<ul>
<li>&lt;标识符，属性名，属性值&gt;</li>
</ul>
</li>
</ul>
<p><img src="/04-8/image-20210524174749568.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/24/DB/CLJ/04-8/" data-id="cl9lj74av00fa64tz7baq5us6" data-title="数据库概论.陈立军.04.非关系型数据" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/CLJ/06-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/23/DB/CLJ/06-2/" class="article-date">
  <time class="dt-published" datetime="2021-05-23T13:39:28.000Z" itemprop="datePublished">2021-05-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/23/DB/CLJ/06-2/">数据库概论.陈立军.06.事务(3)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务冲突可串行化"><a href="#事务冲突可串行化" class="headerlink" title="事务冲突可串行化"></a>事务冲突可串行化</h2><ul>
<li>一个调度是否正确，看它执行的结果是否和某一个串行调度执行的结果相同</li>
<li>核心问题：<ul>
<li>如何判定一个调度是可串行化的？</li>
<li>如何判定两个调度是等价的？</li>
</ul>
</li>
<li>微观视角：<strong>交换非冲突指令</strong><ul>
<li>如何把一个调度转换为另一个等价调度？</li>
</ul>
</li>
<li>宏观视角：<strong>从读一致性</strong><ul>
<li>如何保证每个事务在两个调度中是相同的？</li>
<li>调度内部逻辑相同，因此对于每个事务，如果输入相同则结果一致</li>
</ul>
</li>
</ul>
<h3 id="指令顺序对调度结果的影响"><a href="#指令顺序对调度结果的影响" class="headerlink" title="指令顺序对调度结果的影响"></a>指令顺序对调度结果的影响</h3><ul>
<li>考虑一个调度 S 中的两条连续指令（仅限于 read 与 write 操作）Ii 与 Ij，分别属于事务 Ti 与 Tj</li>
<li>考虑如下四种情况<ul>
<li>A：Ii&#x3D;read(Q), Ij&#x3D;read(Q)</li>
<li>B：Ii&#x3D;read(Q), Ij&#x3D;write(Q)</li>
<li>C：Ii&#x3D;write(Q), Ij&#x3D;read(Q)</li>
<li>D：Ii&#x3D;write(Q), Ij&#x3D;write(Q)</li>
</ul>
</li>
<li>只有 A 操作可以交换，也就是说两条指令中存在写指令则不能交换</li>
<li>引出冲突指令的定义</li>
</ul>
<h3 id="调度中的冲突指令"><a href="#调度中的冲突指令" class="headerlink" title="调度中的冲突指令"></a>调度中的冲突指令</h3><ul>
<li><strong>冲突指令</strong><ul>
<li>两条指令是不同事务在<strong>相同数据项</strong>上的操作，并且其中<strong>至少有一个</strong>是 <strong>write</strong> 指令</li>
</ul>
</li>
<li>非冲突指令（满足一条即可）<ul>
<li>都是 read 操作</li>
<li>操作不同数据项</li>
</ul>
</li>
</ul>
<h3 id="冲突等价"><a href="#冲突等价" class="headerlink" title="冲突等价"></a>冲突等价</h3><ul>
<li>如果调度 S 可以经过交换一系列非冲突指令转换成调度 S’，则称调度 S 与 S’ 是冲突等价的</li>
</ul>
<h3 id="冲突可串行化的定义"><a href="#冲突可串行化的定义" class="headerlink" title="冲突可串行化的定义"></a>冲突可串行化的定义</h3><ul>
<li>当一个调度 S 与一个串行调度冲突等价时，则称该调度是冲突可串行化的</li>
</ul>
<h4 id="非冲突串行化的例子"><a href="#非冲突串行化的例子" class="headerlink" title="非冲突串行化的例子"></a>非冲突串行化的例子</h4><table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">read(A)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">write(A)</td>
</tr>
<tr>
<td align="center">write(A)</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="冲突可串行化的判定"><a href="#冲突可串行化的判定" class="headerlink" title="冲突可串行化的判定"></a>冲突可串行化的判定</h3><ul>
<li><strong>优先图</strong>（precedence graph）</li>
<li>调度 S 的优先图的构造方式<ul>
<li>它是一个有向图 G&#x3D;(V，E)，V是顶点集，E是边集</li>
<li>顶点集由所有参与调度的事务组成</li>
<li>边集由满足下述条件之一的边 Ti $\to$ Tj 组成（冲突指令）<ul>
<li>在 Tj 执行 read(Q) 之前，Ti 执行 write(Q)</li>
<li>在 Tj 执行 write(Q) 之前，Ti 执行 read(Q)</li>
<li>在 Tj 执行 write(Q) 之前，Ti 执行 write(Q)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="优先图构造例子"><a href="#优先图构造例子" class="headerlink" title="优先图构造例子"></a>优先图构造例子</h4><img src="06-2/image-20210525144122354.png" style="zoom:50%;" />

<ul>
<li>如果优先图中存在边 Ti $\to$ Tj，则在任何等价于 S 的串行调度 S’ 中，Ti 都必须出现在 Tj 之前</li>
<li>如果调度 S 的优先图中有环，则 S 是非冲突可串行化的</li>
<li>如果调度 S 的优先图中无环，则是冲突可串行化的<ul>
<li>拓扑排序</li>
</ul>
</li>
</ul>
<h4 id="与冲突可串行化等价的串行顺序"><a href="#与冲突可串行化等价的串行顺序" class="headerlink" title="与冲突可串行化等价的串行顺序"></a>与冲突可串行化等价的串行顺序</h4><ul>
<li>串行顺序可由拓扑排序得到，求出与优先图的偏序相一致的线序</li>
<li>优先图</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">T1--&gt;T2;</span><br><span class="line">T1--&gt;T3;</span><br><span class="line">T2--&gt;T4;</span><br><span class="line">T3--&gt;T4;</span><br></pre></td></tr></table></figure>

<ul>
<li>等价串行线序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">T1--&gt;T2;</span><br><span class="line">T2--&gt;T3;</span><br><span class="line">T3--&gt;T4;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">T1--&gt;T3;</span><br><span class="line">T3--&gt;T2;</span><br><span class="line">T2--&gt;T4;</span><br></pre></td></tr></table></figure>



<h3 id="可串行化但非冲突可串行化的调度"><a href="#可串行化但非冲突可串行化的调度" class="headerlink" title="可串行化但非冲突可串行化的调度"></a>可串行化但非冲突可串行化的调度</h3><ul>
<li>满足上面冲突可串行化判断的调度一定是可串行化的</li>
<li>不满足判断的调度不一定是不可串行化的</li>
<li>一个例子：转账<ul>
<li>在实际编写中应当尽量避免如下操作，应该按照相同的数据项的顺序进行处理</li>
<li>容易造成死锁等问题</li>
</ul>
</li>
</ul>
<img src="06-2/image-20210525145111210.png" alt="image-20210525145414073" style="zoom:50%;" />

<ul>
<li>冲突可串行化的要求太苛刻了，引入视图可串行化的判定</li>
</ul>
<h2 id="事务视图可串行化"><a href="#事务视图可串行化" class="headerlink" title="事务视图可串行化"></a>事务视图可串行化</h2><h3 id="从读一致性"><a href="#从读一致性" class="headerlink" title="从读一致性"></a>从读一致性</h3><ul>
<li>如果两个调度从读一致，则是等价的</li>
<li>把两个调度的 read 指令挑出来，看对应的 read 指令读到的数据是否相同</li>
<li>每个 read 指令往前找，离它最近的 write 相同数据项的指令，就是他读出来的值</li>
</ul>
<h4 id="例子-1：S1-和-S2-从读一致"><a href="#例子-1：S1-和-S2-从读一致" class="headerlink" title="例子 1：S1 和 S2 从读一致"></a>例子 1：S1 和 S2 从读一致</h4><img src="06-2/image-20210525145951520.png" style="zoom:67%;" />

<ul>
<li>S1 中的从读关系<ul>
<li>r1(A) 和 r1(B) 读取的是数据库中的初值</li>
<li>r2(A) 读取的是 w1(A)，r2(B) 读取 w1(B)</li>
</ul>
</li>
<li>S2 中的从读关系<ul>
<li>r1(A) 和 r1(B) 读取的是数据库中的初值</li>
<li>r2(A) 读取的是 w1(A)，r2(B) 读取 w1(B)</li>
</ul>
</li>
</ul>
<h4 id="例子-2：S1-和-S3-从读不一致"><a href="#例子-2：S1-和-S3-从读不一致" class="headerlink" title="例子 2：S1 和 S3 从读不一致"></a>例子 2：S1 和 S3 从读不一致</h4><img src="06-2/image-20210525150148422.png" style="zoom:67%;" />

<ul>
<li>S1 中的从读关系<ul>
<li>r1(A) 和 r1(B) 读取的是数据库中的初值</li>
<li>r2(A) 读取的是 w1(A)，r2(B) 读取 w1(B)</li>
</ul>
</li>
<li>S3 中的从读关系<ul>
<li>r1(A) 和 r1(B) 读取的是数据库中的初值</li>
<li>r2(A) 读取的是数据库中的初值</li>
<li>r2(B) 读取 w1(B)</li>
</ul>
</li>
</ul>
<h3 id="视图等价的调度"><a href="#视图等价的调度" class="headerlink" title="视图等价的调度"></a>视图等价的调度</h3><ul>
<li>考虑关于某个事务集的两个调度 S，S’，若调度 S，S’ 满足以下条件，则称它们是视图等价的<ul>
<li>数据库初值 ${\buildrel{S}\over\longrightarrow}$ ri(Q)，数据库初值 ${\buildrel{S’}\over\longrightarrow}$ ri(Q)</li>
<li>wj(Q) ${\buildrel{S}\over\longrightarrow}$ ri(Q)，wj(Q) ${\buildrel{S’}\over\longrightarrow}$ ri(Q)</li>
<li>wj(Q) ${\buildrel{S}\over\longrightarrow}$ 数据库终值，wj(Q) ${\buildrel{S’}\over\longrightarrow}$ 数据库终值</li>
</ul>
</li>
<li>前两条保证从读一致性</li>
<li>最后一条保证两个调度得到最终相同的系统状态</li>
</ul>
<h4 id="视图等价的例子"><a href="#视图等价的例子" class="headerlink" title="视图等价的例子"></a>视图等价的例子</h4><img src="06-2/image-20210525150856508.png" style="zoom:50%;" />



<h3 id="视图可串行化"><a href="#视图可串行化" class="headerlink" title="视图可串行化"></a>视图可串行化</h3><ul>
<li>如果某个调度视图等价于一个串行调度，则称该调度是视图可串行化的</li>
<li><strong>冲突可串行化调度一定是视图可串行化的</strong><ul>
<li>冲突可串行化的调度一定满足从读一致性</li>
<li>交换一系列非冲突指令，不会破坏从读一致性</li>
</ul>
</li>
<li><strong>存在视图可串行化但非冲突可串行化的调度</strong></li>
</ul>
<img src="06-2/image-20210525151342084.png" style="zoom:50%;" />

<ul>
<li>盲目写操作：不读就写</li>
</ul>
<h3 id="视图可串行化判定"><a href="#视图可串行化判定" class="headerlink" title="视图可串行化判定"></a>视图可串行化判定</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><ul>
<li>找出所有的从读关系</li>
<li>如果有其他事务对某个数据项有写操作，这个写操作不能破坏这个数据项的从读关系</li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li>设调度 S 包含了事务 {T1,T2, … ,Tn} ，设 Tb,Tf 是两个虚事务，其中 Tb 为 S 中所有 write(Q) 操作，Tf 为 S 中所有 read(Q) 操作。在调度 S 的开头插入 Tb ，在调度 S 的末尾插入 Tf，得到新的调度 S’<ul>
<li>如果 Tj 读取 Ti 写入的数据项的值，则加入边 Ti ${\buildrel{0}\over\longrightarrow}$ Tj</li>
<li>删除所有关联无用事务的边。如果在优先图中不存在从 Ti 到 Tf 的通路，则 Ti 是无用事务</li>
<li>对于每个数据项 Q，如果 Tj 读取 Ti 写入的 Q 值，Tk 执行 write(Q) 操作且 Tk $\ne$ Tb，则<ul>
<li>如果 Ti &#x3D; Tb 且 Tj $\ne$ Tf，则在带标记的优先图中插入边 Tj ${\buildrel{0}\over\longrightarrow}$ Tk</li>
<li>如果Ti $\ne$ Tb 且 Tj&#x3D;Tf，则在带标记的优先图中插入边 Tk ${\buildrel{0}\over\longrightarrow}$ Ti</li>
<li>如果 Ti $\ne$ Tb且 Tj $\ne$ Tf，则在带标记的优先图中插入边 Tk ${\buildrel{p}\over\longrightarrow}$ Ti 与 Tj ${\buildrel{p}\over\longrightarrow}$ Tk<ul>
<li>其中 p 是一个唯一的，在前面边的标记中未曾用过的大于 0 的整数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h4><ul>
<li>读数据库初值的，就是读取 Tb 的</li>
<li>最终加入一个 Tf，表示读数据库终值</li>
</ul>
<h4 id="简单的算法操作"><a href="#简单的算法操作" class="headerlink" title="简单的算法操作"></a>简单的算法操作</h4><ul>
<li>找到所有的从读关系，加边（包括读初值、写中止）</li>
<li>对剩下的写操作做分析，不能破坏上面的从读关系<ul>
<li>只能加前面 &#x2F; 只能加后面：标记 0</li>
<li>否则加两条边，并标记 p</li>
</ul>
</li>
</ul>
<h4 id="算法解释（例子1）"><a href="#算法解释（例子1）" class="headerlink" title="算法解释（例子1）"></a>算法解释（例子1）</h4><img src="06-2/image-20210525153235697.png" style="zoom:50%;" />

<ul>
<li>找出从读关系（红边）<ul>
<li>read(A) 读取数据库初值，加上一条边（Tb $\to$ T1）</li>
<li>write(A) 写数据库终值，加上一条边 （T1 $\to$ Tf）</li>
</ul>
</li>
<li>对从读关系进行判断，找到和从读关系操作数据项相同的 write 操作<ul>
<li>write(A) 不能破坏边（Tb $\to$ T1）的从读关系，因此 T2 只能在 Tb 的前面（这不允许，Tb是第一个事务）或者 T1 的后面</li>
<li>write(A) 不能破坏边（T1 $\to$ Tf）的从读关系，因此 T2 只能在 T1 的前面或者 Tf 的后面（这不允许，Tf 是最后一个事务）</li>
</ul>
</li>
<li>结果有环，不是视图可串行化的</li>
</ul>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h4><img src="06-2/image-20210525154116982.png" style="zoom:50%;" />

<ul>
<li>按照上面的算法构造优先图<ul>
<li>标号相同且不为 0 的边，有一条边成立即可</li>
</ul>
</li>
<li>判定<ul>
<li>每个优先图包含标号大于 1 的边对中的一条</li>
<li>判定准则：只要有一个优先图无环，则调度是视图可串行化的</li>
</ul>
</li>
</ul>
<img src="06-2/image-20210525154541252.png" style="zoom:60%;" />

<ul>
<li>左图无环，是视图可串行化的</li>
</ul>
<h3 id="视图可串行化判定示例"><a href="#视图可串行化判定示例" class="headerlink" title="视图可串行化判定示例"></a>视图可串行化判定示例</h3><ul>
<li>满足上面视图可串行化判断的调度一定是可串行化的</li>
<li>不满足判断的调度不一定是不可串行化的</li>
<li>例子<ul>
<li>另外一种判定方法：如下调度与任意一个串行调度都不是视图等价的<ul>
<li>T1, T2</li>
<li>T2, T1</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">read(A)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">A :&#x3D; A - 50</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">write(A)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">read(B)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">B :&#x3D; B - 10</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">write(B)</td>
</tr>
<tr>
<td align="center">read(B)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">B :&#x3D; B + 50</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">write(B)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">read(A)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">A :&#x3D; A + 10</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">write(A)</td>
</tr>
</tbody></table>
<h2 id="事务模型"><a href="#事务模型" class="headerlink" title="事务模型"></a>事务模型</h2><h3 id="平面事务"><a href="#平面事务" class="headerlink" title="平面事务"></a>平面事务</h3><ul>
<li><strong>一层结构</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> transaction ... <span class="keyword">commit</span></span><br></pre></td></tr></table></figure>

<ul>
<li>平面事务的缺点<ul>
<li><strong>不能部分回滚</strong></li>
</ul>
</li>
<li>某些应用场合有部分回滚的需求</li>
</ul>
<h4 id="部分回滚应用场合"><a href="#部分回滚应用场合" class="headerlink" title="部分回滚应用场合"></a>部分回滚应用场合</h4><ul>
<li>确定旅行路线<ul>
<li>某条线路不通应该回滚到上一个分支点，而不是回滚整个事务</li>
</ul>
</li>
<li>批量更新<ul>
<li>如银行结算利息，可以把更新每个帐号作为一个事务，也可以把更新所有帐号作为一个事务</li>
<li>一部分记录更新后，做 一个保存点</li>
</ul>
</li>
</ul>
<h4 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">begin_transaction()</span><br><span class="line">    S1;</span><br><span class="line">    sp1 :<span class="operator">=</span> create_savepoint();</span><br><span class="line">    ...</span><br><span class="line">    Sn;</span><br><span class="line">    spn:<span class="operator">=</span> create_savepoint();</span><br><span class="line">    ...</span><br><span class="line">    if(<span class="keyword">condition</span>)&#123;</span><br><span class="line">        <span class="keyword">rollback</span>(spi);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">commit</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>一个例子</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> tran</span><br><span class="line"><span class="comment">----转账部分</span></span><br><span class="line"><span class="keyword">update</span> accounts</span><br><span class="line"><span class="keyword">set</span> amounts<span class="operator">=</span>amounts<span class="number">-100</span></span><br><span class="line"><span class="keyword">where</span> account_id<span class="operator">=</span><span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">update</span> accounts</span><br><span class="line"><span class="keyword">set</span> amounts<span class="operator">=</span>amounts<span class="operator">+</span><span class="number">100</span></span><br><span class="line"><span class="keyword">where</span> account_id<span class="operator">=</span><span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">----结算利息, 然后撤销</span></span><br><span class="line">save tran add_interest <span class="comment">--保存点</span></span><br><span class="line"><span class="keyword">update</span> accounts</span><br><span class="line"><span class="keyword">set</span> amounts<span class="operator">=</span>amounts<span class="operator">*</span><span class="number">1.02</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> accounts</span><br><span class="line"><span class="keyword">rollback</span> tranadd_interest</span><br><span class="line"><span class="keyword">commit</span> tran</span><br></pre></td></tr></table></figure>



<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><img src="06-2/image-20210525163716093.png" style="zoom:67%;" />

<h3 id="Moss-的嵌套事务模型"><a href="#Moss-的嵌套事务模型" class="headerlink" title="Moss 的嵌套事务模型"></a>Moss 的嵌套事务模型</h3><ul>
<li>嵌套事务是一棵<strong>事务树</strong>，<strong>子树</strong>可以是<strong>嵌套</strong>的也可以是<strong>平面</strong>的</li>
<li><strong>叶结点事务是平面事务</strong>，从根结点到各个叶结点的距离可以是不同的</li>
<li>根结点事务称作<strong>顶层事务</strong>，其他称作<strong>子事务</strong></li>
<li>子事务可以提交也可以回滚，但它的提交并不起作用，除非它的父事务提交<ul>
<li><strong>只有根结点的提交才会使得所有子事务提交</strong></li>
</ul>
</li>
<li>树中任何一个事务的回滚导致它的所有子事务的回滚</li>
<li>子事务具有一般事务的 A,C,I 特性，但不具有 D 特性</li>
<li>实际工作只发生在叶结点事务中，只有它们可以访问数据库，发送消息等<ul>
<li>上层事务只是组织控制流以及决定什么时候该激活哪个子事务</li>
</ul>
</li>
</ul>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul>
<li>提交规则<ul>
<li>当子事务提交时，它的结果只能被它的父事务所访问</li>
<li>只有当一个子事务提交了，并且它的一直到根的所有祖先也都提交了，该子事务才最终提交</li>
<li>因此，只有根结点提交了，所有子事务才会提交</li>
</ul>
</li>
<li>回滚规则<ul>
<li>如果任何一个嵌套层次的事务回滚了，它的所有子事务也都要回滚，不管它们当前是否已经提交</li>
<li>因此，如果根结点回滚，整个嵌套事务也就回滚</li>
</ul>
</li>
<li>可见规则<ul>
<li>当子事务提交后，它的修改对其父事务是可见的，而对其兄弟是不可见的</li>
<li>父事务的任何对象对其子事务都是可访问的</li>
</ul>
</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> TestNestTrans(Col <span class="type">char</span>(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">create</span> proccedure TransProc <span class="variable">@CharCol</span> <span class="type">char</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span> transaction InProc</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> TestNestTrans <span class="keyword">values</span>(<span class="variable">@CharCol</span>)</span><br><span class="line"><span class="keyword">commit</span> transaction InProc</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span> transaction OutOfProc</span><br><span class="line">    <span class="keyword">exec</span> TransProc <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line"><span class="keyword">rollback</span> transaction OutOfProc</span><br><span class="line"></span><br><span class="line"><span class="keyword">exec</span> TransProc <span class="string">&#x27;bbb&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> TestTrans</span><br><span class="line"><span class="comment">--最终 TestNestTrans 表中只有元组 bbb</span></span><br></pre></td></tr></table></figure>



<h3 id="工作流（workflow）"><a href="#工作流（workflow）" class="headerlink" title="工作流（workflow）"></a>工作流（workflow）</h3><ul>
<li>实现某种商业目的的一组相关活动（或步骤）<ul>
<li>银行或保险公司的贷款申请或保险索赔</li>
<li>一次科技会议的规划(邀请、评论、通知等等)</li>
<li>购买房地产的行政程序</li>
<li>病人在医院中的“行程”</li>
</ul>
</li>
<li>工作流使得机构把他们重复的、一成不变的处理自动化，同时保持灵活性，根据不断变化的商业需求来很快调整处理过程</li>
<li>工作流可能跨越不同的负责人和不同的、独立的信息系统，甚至跨越不同的企业</li>
<li>银行借贷工作流</li>
</ul>
<img src="06-2/image-20210525164238665.png" style="zoom:60%;" />

<h4 id="工作流任务间的依赖关系"><a href="#工作流任务间的依赖关系" class="headerlink" title="工作流任务间的依赖关系"></a>工作流任务间的依赖关系</h4><ul>
<li>其他任务的执行状态<ul>
<li>任务 tj 结束了，任务 ti 才能开始</li>
</ul>
</li>
<li>其他任务的输出值<ul>
<li>如果任务 tj 返回一个大于 20 的值，则任务 ti 可以开始</li>
<li>如果秘书审批任务返回 OK，则经理审批任务可以开始</li>
</ul>
</li>
<li>外部时间修改的外部变量<ul>
<li>上午9点以后任务 ti 才能开始</li>
<li>在任务 tj 完成后的 24 小时内必须开始任务 ti</li>
</ul>
</li>
</ul>
<h4 id="工作流的执行"><a href="#工作流的执行" class="headerlink" title="工作流的执行"></a>工作流的执行</h4><ul>
<li>工作流执行<ul>
<li>提交的可接受终止状态</li>
<li>中止的可接受终止状态</li>
</ul>
</li>
<li>整个工作流作为一个事务？<ul>
<li>工作流持续时间很长</li>
<li>每个活动作为一个事务？</li>
</ul>
</li>
<li>如何取消一个活动？补偿事务</li>
</ul>
<h3 id="长事务"><a href="#长事务" class="headerlink" title="长事务"></a>长事务</h3><ul>
<li>运行时间过长，不能采用传统的封锁机制</li>
<li>业务事务：涉及多个相关步骤、运行较长时间</li>
<li>例如购物包括以下若干步骤<ul>
<li>订购商品、商议价格、确定发货日期、确认发货、开具发票、收到货款、发货、…</li>
</ul>
</li>
<li>不能用普通事务实现，否则锁死很久</li>
</ul>
<h4 id="典型例子"><a href="#典型例子" class="headerlink" title="典型例子"></a>典型例子</h4><ul>
<li>传统的 DBMS 应用<ul>
<li>计算所有银行账户余额</li>
</ul>
</li>
<li>设计系统<ul>
<li>设计被分为不同部分，不同设计者同时工作在不同部分上</li>
</ul>
</li>
<li>工作流系统</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>持续时间长</li>
<li>暴露未提交的数据</li>
<li>子任务<ul>
<li>中止其中某个子任务，而不必中止整个事务</li>
</ul>
</li>
<li>可恢复性<ul>
<li>不要将整个事务撤销，而恢复到系统崩溃之前的某一状态，使丢掉的工作尽量少</li>
</ul>
</li>
<li>性能<ul>
<li>响应时间 vs 事务吞吐量</li>
</ul>
</li>
</ul>
<h4 id="Saga"><a href="#Saga" class="headerlink" title="Saga"></a>Saga</h4><ul>
<li>Saga：构成长事务的一系列动作</li>
<li>一个图，其结点是动作或中止及完成结点，弧连接结点对<ul>
<li>中止及完成结点称为<strong>终止结点</strong></li>
</ul>
</li>
<li>关于动作从哪个结点开始的指示，称为<strong>开始节点</strong></li>
<li>Saga 的并发控制<ul>
<li>每个动作是一个一个短事务，采用传统的并发控制</li>
<li>整个事务的完整性由<strong>补偿事务</strong>来保证<ul>
<li>整个事务，即任何通向终止结点的路径通过补偿事务来管理，也即每个结点上短事务的逆（用于撤销回滚）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Service-Broker"><a href="#Service-Broker" class="headerlink" title="Service Broker"></a>Service Broker</h4><ul>
<li>转化为异步的消息队列</li>
<li>每个部门处理订单的一部分，每个部分处理完自己的短事务之后，打包成一个消息传递给下一个部门</li>
<li>可靠的（reliable）、有序的（in order）、异步的（asynchronous）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/23/DB/CLJ/06-2/" data-id="cl9lj74ax00fv64tzdnad0wpd" data-title="数据库概论.陈立军.06.事务(3)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/YLQ-GAMES202/11" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/22/CG/YLQ-GAMES202/11/" class="article-date">
  <time class="dt-published" datetime="2021-05-22T03:43:32.000Z" itemprop="datePublished">2021-05-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES202/">CG.GAMES202</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/22/CG/YLQ-GAMES202/11/">GAMES202.闫令琪.11.基于物理的材质与非真实感渲染</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY">https://www.bilibili.com/video/BV1YK4y1T7yY</a></li>
</ul>
<h1 id="基于物理的材质"><a href="#基于物理的材质" class="headerlink" title="基于物理的材质"></a>基于物理的材质</h1><ul>
<li>Shading Microfacet Models using Linearly Transformed Cosines (LTC)</li>
<li>使用 LTC 方法对微表面模型进行着色</li>
<li>LTC 方法可以用于简单反射叶（lobe）模型的着色<ul>
<li>lobe：固定入射方向的反射叶，2D sliced BRDF</li>
</ul>
</li>
</ul>
<h2 id="LTC"><a href="#LTC" class="headerlink" title="LTC"></a>LTC</h2><ul>
<li>Linearly Transformed Cosines</li>
<li>线性变换的余弦</li>
<li>主要针对的是 GGX 法线分布的模型（其他的模型也 OK）</li>
<li>不考虑 shadow</li>
<li>解决的是微表面模型下，<strong>多边形光源</strong>的 shading<ul>
<li>the split sum 做的是环境光下的 shading，和 LTC 不一样</li>
</ul>
</li>
</ul>
<img src="11/image-20210522153653136.png" style="zoom:50%;" />

<ul>
<li>如果没有 LTC 方法的话，如何做多边形光源下的 shading<ul>
<li>需要做采样</li>
<li>在多边形的光源上取很多采样点</li>
<li>然后将这些采样点和 shading point 连线，求出 shading</li>
</ul>
</li>
<li><strong>LTC 不需要采样</strong></li>
</ul>
<h3 id="LTC-的关键想法"><a href="#LTC-的关键想法" class="headerlink" title="LTC 的关键想法"></a>LTC 的关键想法</h3><img src="11/image-20210522161357852.png" style="zoom: 67%;" />

<ul>
<li>lobe 可以通过某种线性变换，变换成一个余弦函数</li>
<li>多边形的光源也可以有类似的变换<ul>
<li>例如上面的四边形，对四个顶点进行变换</li>
<li>然后用变换后的结果进行 shading</li>
</ul>
</li>
<li>原来做渲染方程的积分不好做，但是经过上面的变换之后是<strong>有解析解</strong>的<ul>
<li>将任意的 lobe 在任意的多边形光源下的积分问题转变为固定的 cosine 下对任意的多边形光源下进行积分的问题</li>
<li>假设多边形内部是均匀的，任意的点对 shading point 的 radiance 都是相同的</li>
</ul>
</li>
</ul>
<h3 id="具体的操作"><a href="#具体的操作" class="headerlink" title="具体的操作"></a>具体的操作</h3><ul>
<li>我们观察到 2D 的 BRDF lobe 可以变幻成一个余弦<ul>
<li>$\mathrm{BRDF;lobe}{\buildrel{M^{-1}}\over\longrightarrow}\mathrm{Cosine}$</li>
</ul>
</li>
</ul>
<img src="11/image-20210522162225689.png" style="zoom:67%;" />

<ul>
<li>我们需要对所有的方向进行一个变换<ul>
<li>$\omega_i{\buildrel{M^{-1}}\over\longrightarrow}\omega_i’$</li>
</ul>
</li>
<li>积分域发生变化<ul>
<li>$P{\buildrel{M^{-1}}\over\longrightarrow}P’$</li>
</ul>
</li>
<li>结果如下</li>
</ul>
<img src="11/image-20210522162343163.png" style="zoom:67%;" />



<h3 id="LTC-的推导"><a href="#LTC-的推导" class="headerlink" title="LTC 的推导"></a>LTC 的推导</h3><ul>
<li>我们所做的事情就是变换积分变量</li>
<li>我们在这里假设，多边形光源的 radiance 是相同（uniform）的（$L_i$ 相同）<ul>
<li>论文中可以通过其他的方法去掉这个假设</li>
</ul>
</li>
<li>新的方向经过 $M$ 变换，可以变成原来的方向<ul>
<li>注意我们上面用的符号是  $M^{-1}$</li>
<li>$w_i&#x3D;\dfrac{M\omega_i’}{\Vert M\omega_i’\Vert}$</li>
<li>归一化的原因是，单元球上的点我们的变换操作可能不在单位球上（长度发生变化）</li>
</ul>
</li>
<li>渲染方程的变化<ul>
<li>$F$ 变换到 Cosine 上<ul>
<li>具体怎么变换，在 Paper 中作了很多预计算</li>
<li>通过优化方法计算</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>$$<br>\begin{aligned}<br>L(\omega_o)&amp;&#x3D;L_i\cdot\int_PF(\omega_i);\mathrm{d}\omega_i\<br>&amp;&#x3D;L_i\cdot\int_{P’}\cos(\omega_i’);\mathrm{d}\dfrac{M\omega_i’}{\Vert M\omega_i’\Vert}\<br>&amp;&#x3D;L_i\cdot\int_{P’}\cos(\omega_i’)J;\mathrm{d}\omega_i’\<br>\end{aligned}<br>$$</p>
<h3 id="LTC-渲染结果"><a href="#LTC-渲染结果" class="headerlink" title="LTC 渲染结果"></a>LTC 渲染结果</h3><img src="11/image-20210522164229335.png"  />

<img src="11/image-20210522164237490.png" style="zoom: 67%;" />



<h3 id="LTC-总结"><a href="#LTC-总结" class="headerlink" title="LTC 总结"></a>LTC 总结</h3><ul>
<li>shadow 的问题<ul>
<li>可以先做 LTC，再通过其他方法计算 shadow</li>
</ul>
</li>
<li>如果多边形光源不是 uniform 的，比如光源带纹理<ul>
<li>这样 LTC 就不准确，但是也是一个好的近似</li>
</ul>
</li>
<li>各向异性的表面能不能变换到 Cosine<ul>
<li>是可以的，入射方向确定之后，出射方向就是一个 lobe</li>
</ul>
</li>
</ul>
<h2 id="Disney’s-Principled-BRDF"><a href="#Disney’s-Principled-BRDF" class="headerlink" title="Disney’s Principled BRDF"></a>Disney’s Principled BRDF</h2><ul>
<li>Disney 原则的 BRDF</li>
</ul>
<h3 id="动机-Motivation"><a href="#动机-Motivation" class="headerlink" title="动机 Motivation"></a>动机 Motivation</h3><ul>
<li>微表面模型对于真实的材质表示的不是很好<ul>
<li>例如 diffuse 项缺失<ul>
<li>虽然我们可以通过某些方法可以补上，但是还是存在一些其他问题</li>
</ul>
</li>
<li>微表面模型 fit 不了我们一些实测的材质<ul>
<li>例子：刷了清漆的桌子<ul>
<li>高光+diffuse</li>
<li>高光：清漆上的反射</li>
<li>diffuse：进入清漆之后打到木板上的反射</li>
<li>微表面模型模拟不了</li>
</ul>
</li>
<li>多层材质</li>
</ul>
</li>
<li>微表面模型表示不了所有的东西</li>
</ul>
</li>
<li>微表面模型不好用，对于艺术家们来说不友好<ul>
<li>例如金属的折射率是一个复数：$n-ik$，可能不好理解，不好调</li>
</ul>
</li>
</ul>
<h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><ul>
<li>Art directable，使用起来比较友好</li>
<li>物理上并不是很准确，只是在一定程度上保证正确</li>
<li>在实时渲染中，PBR 做了很多近似，因此还是认为这种方法是 PBR 的</li>
</ul>
<h3 id="一些设计原则"><a href="#一些设计原则" class="headerlink" title="一些设计原则"></a>一些设计原则</h3><ul>
<li>Intuitive rather than physical parameters should be used.<ul>
<li>使用的参数需要更直观一点，而不是生硬的物理参数</li>
</ul>
</li>
<li>There should be as few parameters as possible.<ul>
<li>参数越少越好（调起来方便）</li>
</ul>
</li>
<li>Parameters should be zero to one over their plausible range.<ul>
<li>参数设置为 0-1 的拖动条</li>
</ul>
</li>
<li>Parameters should be allowed to be pushed beyond their plausible range where it makes sense.<ul>
<li>有时候允许结果超出原始的范围（营造特殊的效果）</li>
</ul>
</li>
<li>All combinations of parameters should be as robust and plausible as possible.<ul>
<li>所有组合应该都是可以的（不会导致程序崩溃）</li>
</ul>
</li>
</ul>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><ul>
<li>某些参数及其效果<ul>
<li>表示能力很强大</li>
<li>参数可能有冗余</li>
</ul>
</li>
</ul>
<p><img src="/11/image-20210522171008715.png"></p>
<ul>
<li>subsurface：次表面散射<ul>
<li>用来描述光线穿过透明&#x2F;半透明表面时发生散射的照明现象，是指光从表面进入物体经过内部散射，然后又通过物体表面的其他顶点出射的光线传递过程</li>
<li>效果：比 diffuse 还要平的效果（求被按扁了的效果）</li>
</ul>
</li>
<li>metallic：金属性</li>
<li>specular：镜面反射的强度</li>
<li>specular Tint：镜面反射的颜色更偏向于白色（0）还是物体本身的颜色</li>
<li>roughness：粗糙程度</li>
<li>anisotropic：各向异性程度</li>
<li>sheen：天鹅绒的效果<ul>
<li>沿着法线长了很多绒毛，在 grazing angle 看过去会有一种雾化的效果</li>
</ul>
</li>
<li>sheen Tint：sheen 的颜色是偏白还是物体本身的颜色</li>
<li>clearcoat：木板上刷一层清漆的效果</li>
<li>clearcoat Gloss：清漆的光滑程度（粗糙程度反一下）</li>
</ul>
<h3 id="Pros-and-Cons"><a href="#Pros-and-Cons" class="headerlink" title="Pros and Cons"></a>Pros and Cons</h3><ul>
<li>容易理解和使用</li>
<li>表示能力很强大</li>
<li>实现是开源的，很多实现是对基于物理材质的近似</li>
<li>不是基于物理的<ul>
<li>牺牲了物理上的准确性</li>
<li>学术界和工业界的不同</li>
</ul>
</li>
<li>参数空间很大<ul>
<li>表示能力很强</li>
<li>可能有冗余</li>
<li>难以学习和训练</li>
</ul>
</li>
<li>模型本身是拟合能量守恒的</li>
</ul>
<h1 id="NPR"><a href="#NPR" class="headerlink" title="NPR"></a>NPR</h1><ul>
<li>非真实感渲染</li>
<li>Non-Photorealistic Rendering (NPR)</li>
<li>实时渲染中<ul>
<li>NPR &#x3D;&#x3D; fast and reliable stylization</li>
<li>这也是神经网络不能够应用于 NPR 中的原因，可能不满足其中的某个因素</li>
</ul>
</li>
</ul>
<h2 id="Photorealistic-Rendering"><a href="#Photorealistic-Rendering" class="headerlink" title="Photorealistic Rendering"></a>Photorealistic Rendering</h2><ul>
<li>照片级真实感渲染</li>
<li>正确的阴影、光照、几何、材质</li>
<li>目标是渲染出更加真实的图片，达到照片级的效果</li>
<li>左右，一半是渲染，一半是真实<ul>
<li>原作者记不清了，没有参考答案</li>
</ul>
</li>
</ul>
<img src="11/image-20210522174304452.png" style="zoom:50%;" />

<h2 id="NPR-目标"><a href="#NPR-目标" class="headerlink" title="NPR  目标"></a>NPR  目标</h2><ul>
<li>目标是营造一种艺术效果</li>
</ul>
<img src="11/image-20210522174600616.png" style="zoom:60%;" />

<h2 id="NPR-的思路"><a href="#NPR-的思路" class="headerlink" title="NPR 的思路"></a>NPR 的思路</h2><ul>
<li>从真实感渲染出发，将某些部分简化，将某些重要的部分加强<ul>
<li>Starts from photorealistic rendering</li>
<li>Exploits abstraction</li>
<li>Strengthens important parts</li>
</ul>
</li>
</ul>
<h2 id="NPR-的应用"><a href="#NPR-的应用" class="headerlink" title="NPR 的应用"></a>NPR 的应用</h2><ul>
<li>art、visualization、instruction、education、entertainment</li>
<li>艺术、可视化、说明书、教育（小孩子绘画）、娱乐</li>
<li>说明书中非真实的图片可能更能够说明问题</li>
</ul>
<p><img src="/11/image-20210522174952337.png"></p>
<ul>
<li>游戏应用<ul>
<li>[Atelier Ryza 2: Lost Legends &amp; the Secret Fairy]</li>
</ul>
</li>
<li>动漫<ul>
<li>[Attack on Titan, Season 4]</li>
<li>虽然是 NPR，同时保留了很多真实感渲染的部分</li>
</ul>
</li>
</ul>
<h2 id="哪些地方需要做风格化"><a href="#哪些地方需要做风格化" class="headerlink" title="哪些地方需要做风格化"></a>哪些地方需要做风格化</h2><ul>
<li>[Xenoblade Chronicles 2]<ul>
<li>焰、光</li>
</ul>
</li>
</ul>
<img src="11/image-20210522175250659.png" style="zoom:50%;" />

<ul>
<li>Borderlands 3</li>
</ul>
<img src="11/image-20210522175412405.png" style="zoom: 70%;" />

<ul>
<li>描边：Bold contours（outlines）</li>
<li>色块：Blocks of colors</li>
</ul>
<ul>
<li>素描的效果：Strokes on surfaces</li>
</ul>
<h3 id="Outline-Rendering"><a href="#Outline-Rendering" class="headerlink" title="Outline Rendering"></a>Outline Rendering</h3><h4 id="什么是边"><a href="#什么是边" class="headerlink" title="什么是边"></a>什么是边</h4><img src="11/image-20210522175622716.png" style="zoom:50%;" />

<ul>
<li>outlines 不仅仅是 contours<ul>
<li>[B]oundary &#x2F; border edge：边界</li>
</ul>
<ul>
<li>[C]rease：折痕</li>
<li>[M]aterial edge：材质的连接</li>
</ul>
<ul>
<li>[S]ilhouette edge：轮廓<ul>
<li>在物体的外面一圈的轮廓上（2D 最外边的轮廓）</li>
<li>得是多个面共享的边界</li>
<li>S 是 C 的子集</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="描边的思路"><a href="#描边的思路" class="headerlink" title="描边的思路"></a>描边的思路</h4><ul>
<li>shading 方法来做</li>
<li>修改几何</li>
<li>后期图像处理</li>
</ul>
<h4 id="Shading-方法描边"><a href="#Shading-方法描边" class="headerlink" title="Shading 方法描边"></a>Shading 方法描边</h4><ul>
<li>只能做 silhouette 的边</li>
<li>对于封闭的物体，什么样的边是 silhouette 边呢？<ul>
<li><strong>观察的方向和法线几乎垂直的边</strong></li>
<li>grazing angle</li>
</ul>
</li>
<li>渲染的时候可以为夹角设置一个阈值 threshold<ul>
<li>域值越小，被认为是边缘的点越多，最终形成的边缘越粗</li>
</ul>
</li>
</ul>
<img src="11/image-20210522202842564.png" style="zoom: 33%;" />

<ul>
<li>step：硬边界</li>
<li>smooth step：过渡的效果</li>
</ul>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul>
<li>不同位置的边的粗细不一致<ul>
<li>法线变换比较平滑的地方，边比较粗</li>
</ul>
</li>
</ul>
<h4 id="Geometry-方法描边"><a href="#Geometry-方法描边" class="headerlink" title="Geometry 方法描边"></a>Geometry 方法描边</h4><ul>
<li>Backface fattening</li>
<li>把所有的背向面扩大一圈渲染成黑的，正向面正常渲染</li>
</ul>
<img src="11/image-20210522203233929.png" style="zoom:50%;" />

<img src="11/image-20210522203244568.png" style="zoom:50%;" />



<h4 id="Image-方法描边"><a href="#Image-方法描边" class="headerlink" title="Image 方法描边"></a>Image 方法描边</h4><ul>
<li>后期图像处理</li>
<li>Edge detection（边缘检测）<ul>
<li>Sobel detector</li>
</ul>
</li>
<li>锐化操作：边界增强，找到边界，加回到原来的图上</li>
</ul>
<img src="11/image-20210522203533535.png" style="zoom:50%;" />

<ul>
<li>可以通过其他辅助图像找到边界<ul>
<li>法线、深度图</li>
</ul>
</li>
</ul>
<img src="11/image-20210522203740986.png" style="zoom: 33%;" />



<h3 id="Color-blocks"><a href="#Color-blocks" class="headerlink" title="Color blocks"></a>Color blocks</h3><ul>
<li>色块效果</li>
<li>下图：glossy、diffuse、color block</li>
</ul>
<img src="11/image-20210522203921025.png" style="zoom:50%;" />

<ul>
<li>实现方法<ul>
<li>Hard shading：thresholding on shading<ul>
<li>正常计算 shading，对计算出来的结果进行一个阈值化</li>
</ul>
</li>
<li>Posterization：thresholding on final image color<ul>
<li>在最终的图片上进行阈值化</li>
</ul>
</li>
</ul>
</li>
<li>阈值化可以是多值化，也可以是二值化<ul>
<li>Quantization（量化）</li>
</ul>
</li>
</ul>
<img src="11/image-20210522204142321.png" style="zoom:80%;" />

<ul>
<li>在不同的部分（specular、diffuse）上使用不同的阈值化方法</li>
</ul>
<img src="11/image-20210522204304560.png" style="zoom:67%;" />



<h3 id="Strokes-Surface-Stylization"><a href="#Strokes-Surface-Stylization" class="headerlink" title="Strokes Surface Stylization"></a>Strokes Surface Stylization</h3><ul>
<li>素描的效果</li>
</ul>
<img src="11/image-20210522212218788.png" style="zoom:50%;" />

<ul>
<li>什么是素描的效果？<ul>
<li>打格子</li>
<li>密度：使用<strong>格子的密度</strong>表示<strong>明暗效果</strong></li>
<li>连续性：使用纹理代替点的计算，保证笔触的连续性</li>
</ul>
</li>
<li>设计几种不同密度的纹理<ul>
<li>我们希望在远处，不会变得越来越暗，导致全黑</li>
<li>我们自己做一个 Mipmap，缩小之后不改变密度（相当于截取一部分）</li>
</ul>
</li>
<li>Tonal art maps (TAMs)<ul>
<li>Strokes of different densities</li>
</ul>
<ul>
<li>Each density has a MIPMAP</li>
</ul>
</li>
</ul>
<img src="11/image-20210522212429396.png" style="zoom:50%;" />

<ul>
<li>一些其他方法</li>
</ul>
<img src="11/image-20210522212758582.png" style="zoom:67%;" />



<h2 id="NPR-总结"><a href="#NPR-总结" class="headerlink" title="NPR 总结"></a>NPR 总结</h2><ul>
<li>NPR is art driven</li>
<li>怎么把艺术家的需求转化为具体的渲染实现才是有趣&#x2F;有挑战的</li>
<li>多和艺术家交流</li>
<li>NPR 很多时候是 if…else…<ul>
<li>每个场景</li>
<li>每个部分</li>
</ul>
</li>
<li>NPR 做的好与不好，很大程度上取决于原来的 photorealistic rendering 做的好坏<ul>
<li>Photorealistic models are super important in NPR</li>
<li>艺术是真实的抽象</li>
<li>NPR 与 PR 不能被分开来看待</li>
</ul>
</li>
<li>例如：布料（cloth）</li>
</ul>
<img src="11/image-20210522213943708.png" style="zoom:70%;" />
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/22/CG/YLQ-GAMES202/11/" data-id="cl9lj749v008u64tzhrxravz8" data-title="GAMES202.闫令琪.11.基于物理的材质与非真实感渲染" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/CLJ/06-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/22/DB/CLJ/06-1/" class="article-date">
  <time class="dt-published" datetime="2021-05-22T03:32:28.000Z" itemprop="datePublished">2021-05-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/22/DB/CLJ/06-1/">数据库概论.陈立军.06.事务(2) 事务隔离性</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务隔离性级别"><a href="#事务隔离性级别" class="headerlink" title="事务隔离性级别"></a>事务隔离性级别</h2><h3 id="SQL-中隔离性级别的定义"><a href="#SQL-中隔离性级别的定义" class="headerlink" title="SQL 中隔离性级别的定义"></a>SQL 中隔离性级别的定义</h3><ul>
<li>（事务隔离性级别从低到高）</li>
<li>read uncommitted<ul>
<li>允许读取未提交的记录</li>
</ul>
</li>
<li>read uncommitted<ul>
<li>只允许读取已提交的记录，但不要求可重复读</li>
</ul>
</li>
<li>repeatable read<ul>
<li>只允许读取已提交的记录，并且一个事务对同一记录的两次读取之间，其它事务不能对该记录进行更新</li>
</ul>
</li>
<li>serializable<ul>
<li>调度的执行必须等价于串行调度</li>
</ul>
</li>
</ul>
<h3 id="隔离性级别的内部实现"><a href="#隔离性级别的内部实现" class="headerlink" title="隔离性级别的内部实现"></a>隔离性级别的内部实现</h3><ul>
<li>在数据库内部，如果一个事务要对某个记录项进行读或写操作，要先获得这个数据项上的读锁或者写锁，这由<strong>锁管理器</strong>统一控制<ul>
<li>读 S 锁，写 X 锁</li>
<li>二者不兼容，只能有一个锁</li>
</ul>
</li>
<li>写事务 W，读事务 R，锁管理器 L<ul>
<li>以下是不同隔离性级别的内部实现</li>
</ul>
</li>
</ul>
<h4 id="read-uncommitted"><a href="#read-uncommitted" class="headerlink" title="read uncommitted"></a>read uncommitted</h4><ul>
<li>W：申请 X 锁</li>
<li>L：同意（X 锁被加上）</li>
<li>R：读取数据项（不需要申请 S 锁）</li>
</ul>
<h4 id="read-committed"><a href="#read-committed" class="headerlink" title="read committed"></a>read committed</h4><ul>
<li>W：申请 X 锁</li>
<li>L：同意（X 锁被加上）</li>
<li>R：申请 S 锁（阻塞），等待</li>
<li>W：提交（释放 X 锁）</li>
<li>L：同意 R 读（S 锁被加上）</li>
<li>R：读取数据项</li>
</ul>
<h5 id="read-commited-不能实现-repeatable-read"><a href="#read-commited-不能实现-repeatable-read" class="headerlink" title="read commited 不能实现 repeatable read"></a>read commited 不能实现 repeatable read</h5><ul>
<li>R：申请 S 锁</li>
<li>L：同意（S 锁被加上）</li>
<li>R：读取数据项（读完立刻释放 S 锁）</li>
<li>W：申请 X 锁</li>
<li>L：同意（X 锁被加上）</li>
<li>W：提交（X 锁被释放）</li>
<li>R：读取数据项，（<strong>读取到的数据与之前不一致</strong>）</li>
</ul>
<h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><ul>
<li><span style="color:red;font-weight:bold">read committed 的读锁是短锁</span><ul>
<li>短锁：操作一执行完，锁立即释放</li>
<li>长锁：长锁会一直到保持到事务结束，提交之后才释放</li>
</ul>
</li>
<li><strong>只有读事务有短锁和长锁的区别，写事务都是长锁</strong></li>
</ul>
<h4 id="repeatable-read"><a href="#repeatable-read" class="headerlink" title="repeatable read"></a>repeatable read</h4><ul>
<li>R：申请 S 锁</li>
<li>L：同意（S 锁被加上）</li>
<li>R：读取数据项（S 锁是长锁）</li>
<li>W：申请 X 锁（阻塞）等待</li>
<li>R：读取数据项（<strong>读取到的数据与之前一致</strong>）</li>
<li>R：提交（S 锁被释放）</li>
<li>L：同意（X 锁被加上）</li>
<li>W：提交（X 锁被释放）</li>
</ul>
<h3 id="隔离性级别与不一致现象的关系"><a href="#隔离性级别与不一致现象的关系" class="headerlink" title="隔离性级别与不一致现象的关系"></a>隔离性级别与不一致现象的关系</h3><table>
<thead>
<tr>
<th align="center">隔离性级别</th>
<th align="center">读脏数据</th>
<th align="center">不能重复读</th>
<th align="center">幻象</th>
<th align="center">丢失修改</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Read uncommitted</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">Read committed</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center"><span style="color:red;font-weight:bold">是</span></td>
</tr>
<tr>
<td align="center">Repeatable read</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><span style="color:red;font-weight:bold">是</span></td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">Serializable</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<h3 id="具体场景的演示"><a href="#具体场景的演示" class="headerlink" title="具体场景的演示"></a>具体场景的演示</h3><h4 id="read-uncommitted-下发生脏读"><a href="#read-uncommitted-下发生脏读" class="headerlink" title="read uncommitted 下发生脏读"></a>read uncommitted 下发生脏读</h4><table>
<thead>
<tr>
<th align="center">事务1</th>
<th align="center">事务2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">set transaction isolation level <span style="color:red;font-weight:bold">read uncommitted</span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">begin tran<br/>select sname from S<br/>where sname &#x3D; ‘王红’<br/>–只有一个学生名为王红</td>
</tr>
<tr>
<td align="center">begin tran<br/>update S<br/>set sname&#x3D; ‘王红’</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select sname from S<br/>where sname&#x3D; ‘王红’<br/>–所有学生姓名均为王红</td>
</tr>
<tr>
<td align="center">rollback tran</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select sname from S<br/>where sname&#x3D;’王红’<br/>–只有一个学生名为王红</td>
</tr>
</tbody></table>
<h4 id="read-committed-下避免脏读"><a href="#read-committed-下避免脏读" class="headerlink" title="read committed 下避免脏读"></a>read committed 下避免脏读</h4><table>
<thead>
<tr>
<th align="center">事务1</th>
<th align="center">事务2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">set transaction isolation level <span style="color:red;font-weight:bold">read committed</span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">begin tran</td>
</tr>
<tr>
<td align="center">begin tran<br/>update S<br/>set sname&#x3D; ‘王红’</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select sname from S<br/>where sname&#x3D;’王红’<br/>–阻塞，”正在执行批查询”</td>
</tr>
<tr>
<td align="center">commit tran</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">–所有学生姓名均为王红</td>
</tr>
</tbody></table>
<h4 id="read-committed-下发生不可重复读"><a href="#read-committed-下发生不可重复读" class="headerlink" title="read committed 下发生不可重复读"></a>read committed 下发生不可重复读</h4><table>
<thead>
<tr>
<th align="center">事务1</th>
<th align="center">事务2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">set transaction isolation level <span style="color:red;font-weight:bold">read committed</span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">begin tran<br/>select sname from S<br/>where sname&#x3D; ‘王红’<br/>–只有一个学生名为王红</td>
</tr>
<tr>
<td align="center">begin tran<br/>update S<br/>set sname&#x3D;’王红’<br/>commit tran</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select sname from S<br/>where sname&#x3D; ‘王红’<br/>–所有学生姓名均为王红</td>
</tr>
</tbody></table>
<h4 id="repeatable-read-下避免不可重复读"><a href="#repeatable-read-下避免不可重复读" class="headerlink" title="repeatable read 下避免不可重复读"></a>repeatable read 下避免不可重复读</h4><table>
<thead>
<tr>
<th align="center">事务1</th>
<th align="center">事务2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">set transaction isolation level <span style="color:red;font-weight:bold">repeatable read</span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">begin tran<br/>select sname from S<br/>where sname&#x3D; ‘王红’<br/>–有一个学生名为王红</td>
</tr>
<tr>
<td align="center">begin tran<br/>update S<br/>set sname&#x3D;’王明’<br/>where sname&#x3D;’王红’<br/>–<span style="color:red;font-weight:bold">阻塞</span></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select sname from S<br/>where sname&#x3D; ‘王红’<br/>–有一个学生名为王红</td>
</tr>
</tbody></table>
<h4 id="repeatable-read-下发生幻象"><a href="#repeatable-read-下发生幻象" class="headerlink" title="repeatable read 下发生幻象"></a>repeatable read 下发生幻象</h4><ul>
<li>对于其他事务的 insert 操作，无法阻塞</li>
</ul>
<table>
<thead>
<tr>
<th align="center">事务1</th>
<th align="center">事务2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">set transaction isolation level <span style="color:red;font-weight:bold">repeatable read</span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">begin tran<br/>select snamef rom S<br/>where sname&#x3D; ‘王%’<br/>–只有一个学生，名为王红</td>
</tr>
<tr>
<td align="center">insert into S values(‘s08’, ‘王明’, 23, 1)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select sname from S<br/>where sname&#x3D; ‘王%’<br/>–有两个学生，名为王红和王明</td>
</tr>
</tbody></table>
<h4 id="serializable-下避免幻象"><a href="#serializable-下避免幻象" class="headerlink" title="serializable 下避免幻象"></a>serializable 下避免幻象</h4><table>
<thead>
<tr>
<th align="center">事务1</th>
<th align="center">事务2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">set transaction isolation level <span style="color:red;font-weight:bold">serializable</span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">begin tran<br/>select snamef rom S<br/>where sname&#x3D; ‘王%’<br/>–只有一个学生，名为王红</td>
</tr>
<tr>
<td align="center">insert into S values(‘s08’, ‘王明’, 23, 1)<br/>–阻塞</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select sname from S<br/>where sname&#x3D; ‘王%’<br/>–只有一个学生，名为王红</td>
</tr>
</tbody></table>
<h4 id="read-committed-下的丢失修改"><a href="#read-committed-下的丢失修改" class="headerlink" title="read committed 下的丢失修改"></a>read committed 下的丢失修改</h4><ul>
<li>注意读和读不会发生不一致现象，允许多个事务同时申请读锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> chair(</span><br><span class="line">    seat_id <span class="type">int</span>,</span><br><span class="line">    host <span class="type">char</span>(<span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> chair <span class="keyword">values</span> (<span class="number">1</span>,<span class="keyword">null</span>),(<span class="number">2</span>,<span class="keyword">null</span>),(<span class="number">3</span>,<span class="keyword">null</span>),(<span class="number">4</span>,<span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">事务1</th>
<th align="center">事务2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">set transaction isolation level <span style="color:red;font-weight:bold">read committed</span></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">begin tran</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">set transaction isolation level <span style="color:red;font-weight:bold">read committed</span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">begin tran</td>
</tr>
<tr>
<td align="center">select seat_id from chair<br/>where host is null</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select seat_id from chair<br/>where host is null<br />–<span style="color:red;font-weight:bold">read committed 的读锁是短锁，操作完马上释放</span></td>
</tr>
<tr>
<td align="center">update chair set host&#x3D;’tom’<br/>where seat_id&#x3D;1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">commit</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">update chair set host&#x3D;’jerry’ where seat_id&#x3D;1<br/>update chair set host&#x3D;’bob’ where seat_id&#x3D;2</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">commit</td>
</tr>
</tbody></table>
<ul>
<li>将事务 2 的隔离性级别修改为 repeatable read<ul>
<li>这样事务 1 的 update 操作会被阻塞</li>
<li>但是事务 2 的 update 操作也会被阻塞，引发死锁</li>
<li>数据库中有专门的进程定期做死锁检测，检测到死锁会撤销一个事务，打开死锁</li>
</ul>
</li>
</ul>
<h3 id="不同隔离性级别下的可能调度"><a href="#不同隔离性级别下的可能调度" class="headerlink" title="不同隔离性级别下的可能调度"></a>不同隔离性级别下的可能调度</h3><ul>
<li>考虑关系 <code>Employee(ID,salary)</code>，有两个元组 <code>(A,20)</code> 和 <code>(B,30)</code></li>
<li>两个事务 T1，T2 如下</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- T1:</span></span><br><span class="line"><span class="keyword">begin</span> transaction;</span><br><span class="line"><span class="keyword">update</span> Employee <span class="keyword">set</span> salary <span class="operator">=</span> <span class="number">2</span><span class="operator">*</span>salary <span class="keyword">where</span> ID<span class="operator">=</span><span class="string">&#x27;A&#x27;</span>;  <span class="comment">-- t11</span></span><br><span class="line"><span class="keyword">update</span> Employee <span class="keyword">set</span> salary <span class="operator">=</span> salary<span class="operator">+</span><span class="number">10</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="string">&#x27;A&#x27;</span>; <span class="comment">-- t12</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- T2:</span></span><br><span class="line"><span class="keyword">begin</span> transaction;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(salary) <span class="keyword">as</span> sal1 <span class="keyword">from</span> Employee;            <span class="comment">-- t21</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(salary) <span class="keyword">as</span> sal2 <span class="keyword">from</span> Employee;            <span class="comment">-- t22</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>给出 T2 在不同隔离性级别下所返回的 sal1 与 sal2 所有可能的值的情况</li>
<li>思路：列出所有调度的可能性，在不同的隔离性级别下判断是否能够成立</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S1: t11, t12, t21, t22 -&gt; (sal1, sal2) = (80,80)</span><br><span class="line">S2: t11, t21, t12, t22 -&gt; (sal1, sal2) = (70,80)</span><br><span class="line">S3: t11, t21, t22, t12 -&gt; (sal1, sal2) = (70,70)</span><br><span class="line">S4: t21, t22, t11, t12 -&gt; (sal1, sal2) = (50,50)</span><br><span class="line">S5: t21, t11, t22, t12 -&gt; (sal1, sal2) = (50,70)</span><br><span class="line">S6: t21, t11, t12, t22 -&gt; (sal1, sal2) = (50,80)</span><br></pre></td></tr></table></figure>

<ul>
<li>read uncommitted<ul>
<li>S1,S2,S3,S4,S5,S6</li>
</ul>
</li>
<li>read committed（读短锁，写长锁）<ul>
<li>S1,S4,S6</li>
</ul>
</li>
<li>repeatable read<ul>
<li>S1,S4</li>
</ul>
</li>
<li>serializable<ul>
<li>S1,S4</li>
</ul>
</li>
</ul>
<h3 id="乐观锁定：快照隔离-SI"><a href="#乐观锁定：快照隔离-SI" class="headerlink" title="乐观锁定：快照隔离 SI"></a>乐观锁定：快照隔离 SI</h3><ul>
<li>Snapshot Isolation</li>
<li>上述的隔离性是通过<strong>内部封锁</strong>来实现的（锁管理器）</li>
<li>这样的设计是有代价的，<strong>锁请求</strong></li>
<li>如果在某个应用场景下，只有很多读事务，产生冲突的可能性很小，加锁的方式效率很低<ul>
<li>不必要加锁</li>
</ul>
</li>
<li>也就是说写操作比较多的时候，冲突较多的时候，加锁才是一个好的解决方法<ul>
<li>锁：悲观的态度，假定冲突概率很高</li>
</ul>
</li>
<li>乐观的态度：假定发生冲突的概率很小</li>
</ul>
<h4 id="快照隔离-SI"><a href="#快照隔离-SI" class="headerlink" title="快照隔离 SI"></a>快照隔离 SI</h4><ul>
<li><strong>一旦检测到冲突，把某个事务回滚</strong></li>
<li>通过<strong>多版本</strong>的方式实现的<ul>
<li>更新事务修改数据项的时候形成一个新的版本</li>
</ul>
</li>
<li>一些关系<ul>
<li>读不会阻塞写</li>
<li>写不会阻塞读</li>
<li><strong>写发生在提交时</strong></li>
<li>冲突时先提交者赢</li>
</ul>
</li>
<li>一个例子：左到右时间顺序<ul>
<li>T2 先提交，回滚 T4，因此 T3 保留下来了</li>
<li>T5 读取到的结果是一开始的，T5 开始的时候，T3 还没写（提交才写）<ul>
<li><strong>标准的快照隔离只能读取到事务一开始的版本</strong></li>
</ul>
</li>
<li>T1 事务无论在什么时候发出读命令，读取到的 X 都是一开始的</li>
<li>T7 读取的是 T6 更新的结果</li>
</ul>
</li>
</ul>
<img src="06-1/image-20210524150236052.png" style="zoom:67%;" />



<h4 id="快照隔离中的不一致现象"><a href="#快照隔离中的不一致现象" class="headerlink" title="快照隔离中的不一致现象"></a>快照隔离中的不一致现象</h4><ul>
<li>一致性要求：A+B &gt;&#x3D; 0</li>
<li>当前：A＋B＝5</li>
<li>调度：r1(x), r1(y), r2(x), r2(y), w1(y), w2(x)</li>
<li>T1、T2 分别将 x、y 减去 5，发生了什么？<ul>
<li>调度可以执行，但是最终的结果是不满足一致性的</li>
</ul>
</li>
<li>问题原因：<strong>写偏斜</strong><ul>
<li>两个事务写不同的数据项</li>
</ul>
</li>
<li>悲观锁定的情况下，repeatable read 会防止这种情况的发生<ul>
<li><strong>读长锁</strong>，后面的写操作阻塞</li>
</ul>
</li>
<li>写偏斜的另外一个例子<ul>
<li>初始值：x&#x3D;3, y&#x3D;5</li>
<li>T1: x :&#x3D; y；T2: y :&#x3D; x</li>
<li>SI 下 r1(x), r1(y), r2(x), r2(y), w1(y), w2(x) 的结果是什么？<ul>
<li>x&#x3D;5, y&#x3D;3</li>
</ul>
</li>
<li>串行的结果：(3,3) 或者 (5,5)</li>
</ul>
</li>
</ul>
<h4 id="SQL-Server-下的快照隔离"><a href="#SQL-Server-下的快照隔离" class="headerlink" title="SQL Server 下的快照隔离"></a>SQL Server 下的快照隔离</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database demo</span><br><span class="line">use demo</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> isolation_1 (</span><br><span class="line">    id1 <span class="type">int</span>,</span><br><span class="line">    des <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> isolation_1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;asdf&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="快照隔离SI：可重复读"><a href="#快照隔离SI：可重复读" class="headerlink" title="快照隔离SI：可重复读"></a>快照隔离SI：可重复读</h5><table>
<thead>
<tr>
<th align="center">连接1</th>
<th align="center">连接2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin tran<br/>update isolation_1<br/>set des &#x3D;’UPDATED’<br/>where id1&#x3D;1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">begin tran<br/>select * from isolation_1<br/>– 读到的结果是 asdf（事务起点的状态）</td>
</tr>
<tr>
<td align="center">commit tran</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select * from isolation_1<br/>commit tran<br />– 读到的结果是 asdf（事务起点的状态）</td>
</tr>
</tbody></table>
<h5 id="快照隔离SI：回滚"><a href="#快照隔离SI：回滚" class="headerlink" title="快照隔离SI：回滚"></a>快照隔离SI：回滚</h5><ul>
<li>发生冲突的时候，先提交者胜</li>
<li>右边事务会被回滚</li>
</ul>
<table>
<thead>
<tr>
<th align="center">连接1</th>
<th align="center">连接2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">SET TRANSACTION ISOLATION<br/>LEVEL SNAPSHOT</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">begin tran<br/>select id1 from isolation_1</td>
</tr>
<tr>
<td align="center">begin tran<br/>update isolation_1<br/>set id1 &#x3D; id1+10</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">update isolation_1<br/>set id1 &#x3D; id1+20</td>
</tr>
<tr>
<td align="center">commit tran</td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="SQL-Server：快照隔离-RCSI"><a href="#SQL-Server：快照隔离-RCSI" class="headerlink" title="SQL Server：快照隔离 RCSI"></a>SQL Server：快照隔离 RCSI</h4><ul>
<li>语句级别的快照隔离</li>
<li>当前语句操作的数据库是当前语句对应的数据库的状态<ul>
<li>而不是事务开始时的版本</li>
</ul>
</li>
</ul>
<h5 id="快照隔离-RCSI：不可重复读"><a href="#快照隔离-RCSI：不可重复读" class="headerlink" title="快照隔离 RCSI：不可重复读"></a>快照隔离 RCSI：不可重复读</h5><table>
<thead>
<tr>
<th align="center">连接1</th>
<th align="center">连接2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin tran<br/>update isolation_1<br/>set des &#x3D;’UPDATED’<br/>where id1&#x3D;1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">begin tran<br/>select * from isolation_1<br/>– 读到的结果是 asdf（语句开始的状态）</td>
</tr>
<tr>
<td align="center">commit tran</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select * from isolation_1<br/>commit tran<br />– 读到的结果是 UPDATED（语句开始的状态）</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/22/DB/CLJ/06-1/" data-id="cl9lj74aw00fo64tz6dle8lr8" data-title="数据库概论.陈立军.06.事务(2) 事务隔离性" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/CLJ/06" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/21/DB/CLJ/06/" class="article-date">
  <time class="dt-published" datetime="2021-05-21T05:04:27.000Z" itemprop="datePublished">2021-05-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/21/DB/CLJ/06/">数据库概论.陈立军.06.事务</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h2><ul>
<li>transaction（交易）</li>
<li>交易的核心：<strong>完整性</strong></li>
<li>Jim Gray：在事务处理方面做出巨大的贡献<ul>
<li>书籍：transaction processing: concept and techniques</li>
</ul>
</li>
<li>commitment<ul>
<li>事务包含了很多操作，commitment 指把所有的操作完整的提交到数据库上</li>
<li>It’s like bacon and eggs. The chicken participants. The pig commited.</li>
</ul>
</li>
<li><strong>一致性条件</strong><ul>
<li>银行转账，两个账户的总和在转账前后保持不变</li>
<li>存在两个操作，转出账户余额减去转账金额，转入账户余额加上转账金额<ul>
<li><strong>必须保证这组操作的整体性</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h3><ul>
<li>事务是由一系列操作序列构成的执行单元，这些操作<strong>要么都做，要么都不做</strong>，是一个<strong>不可分割</strong>的工作单位</li>
<li>${\color{red}\mathrm{All;or;None}}$</li>
</ul>
<h3 id="事务中的数据访问原语"><a href="#事务中的数据访问原语" class="headerlink" title="事务中的数据访问原语"></a>事务中的数据访问原语</h3><ul>
<li>read(X)：从数据库传送数据项 X 到事务的工作区中<ul>
<li><strong>从数据缓冲区读出来</strong></li>
</ul>
</li>
<li>write(X)：从事务的工作区中将数据项 X 写回数据库</li>
</ul>
<img src="06/image-20210521223649619.png" style="zoom:50%;" />



<h4 id="转账事务的原语表达"><a href="#转账事务的原语表达" class="headerlink" title="转账事务的原语表达"></a>转账事务的原语表达</h4><ul>
<li>事务 T 从 A 帐户过户 50 到 B 帐户</li>
</ul>
<p>$$<br>\begin{aligned}<br>&amp;read(A);\<br>&amp;A :&#x3D; A –50;\<br>&amp;write(A);\<br>&amp;read(B);\<br>&amp;B :&#x3D; B + 50;\<br>&amp;write(B);\<br>\end{aligned}<br>$$</p>
<ul>
<li>电子商务：<strong>事务是现代信息系统的基石</strong></li>
</ul>
<h3 id="SQL中事务的定义"><a href="#SQL中事务的定义" class="headerlink" title="SQL中事务的定义"></a>SQL中事务的定义</h3><ul>
<li>事务以 Begin transaction 开始，以 Commit transaction 或 Rollback transaction 结束<ul>
<li>Commit transaction 表示<strong>提交</strong>，<strong>事务正常结束</strong></li>
<li>Rollback transaction 表示事务非正常结束，<strong>撤消事务已做的操作</strong>，回滚到事务开始时状态</li>
</ul>
</li>
<li>具体的结束方式，通过加入某些条件判断</li>
<li>terminate 与 abort<ul>
<li>Terminate：终止（中性）</li>
<li>Abort：中止（失败，需要 rollback）</li>
</ul>
</li>
</ul>
<h3 id="事务执行模式"><a href="#事务执行模式" class="headerlink" title="事务执行模式"></a>事务执行模式</h3><h4 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h4><ul>
<li>以 begin transaction 开始，以 commit 或 rollback 结束</li>
</ul>
<h4 id="隐含事务"><a href="#隐含事务" class="headerlink" title="隐含事务"></a>隐含事务</h4><ul>
<li>事务自动开始，直到遇到 commit 或 rollback 时结束</li>
<li>set implicit_transactions{ ON | OFF }</li>
</ul>
<h4 id="自动事务"><a href="#自动事务" class="headerlink" title="自动事务"></a>自动事务</h4><ul>
<li>每个数据操作语句作为一个事务</li>
<li>update SC set GRADE &#x3D; GRADE+15</li>
</ul>
<h3 id="事务中的错误检查"><a href="#事务中的错误检查" class="headerlink" title="事务中的错误检查"></a>事务中的错误检查</h3><ul>
<li>GRADE 约束小于等于100，现在数据库中有两个 GRADE (80, 90)</li>
<li>事务 <code>update SC set GRADE = GRADE+15</code> 操作的结果<ul>
<li>(80,90)，事务出错，整个回滚</li>
</ul>
</li>
<li>如下事务操作的结果<ul>
<li>(85, 95)<ul>
<li>不做设置的前提下，会将第一个操作提交</li>
</ul>
</li>
<li>设置 <code>set XACT_ABORT ON</code> 之后结果为 (80,90)</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Begin</span> tran</span><br><span class="line"><span class="keyword">Update</span> SC</span><br><span class="line"><span class="keyword">Set</span> grade <span class="operator">=</span> grade<span class="operator">+</span><span class="number">5</span></span><br><span class="line"><span class="comment">--没有违反 grade&lt;=100 约束</span></span><br><span class="line"><span class="keyword">Update</span> SC</span><br><span class="line"><span class="keyword">Set</span> grade <span class="operator">=</span> grade<span class="operator">+</span><span class="number">20</span></span><br><span class="line"><span class="comment">--违反了 grade&lt;=100 约束</span></span><br><span class="line"><span class="keyword">Commit</span> tran</span><br></pre></td></tr></table></figure>

<ul>
<li>如下事务操作的结果<ul>
<li>(80, 90)</li>
<li>rollback 把整个事务回滚</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Begin</span> tran</span><br><span class="line"><span class="keyword">Update</span> SC</span><br><span class="line"><span class="keyword">Set</span> grade <span class="operator">=</span> grade<span class="operator">+</span><span class="number">5</span></span><br><span class="line"><span class="keyword">Update</span> SC</span><br><span class="line"><span class="keyword">Set</span> grade <span class="operator">=</span> grade<span class="operator">+</span><span class="number">20</span></span><br><span class="line">If @<span class="variable">@error</span><span class="operator">&lt;&gt;</span><span class="number">0</span> <span class="comment">-- 全局变量, 上一行语句操作设置</span></span><br><span class="line">    <span class="keyword">rollback</span> tran</span><br><span class="line"><span class="keyword">Commit</span> tran</span><br></pre></td></tr></table></figure>



<h3 id="事务基本特性ACID"><a href="#事务基本特性ACID" class="headerlink" title="事务基本特性ACID"></a>事务基本特性ACID</h3><ul>
<li>$\mathrm{ACID:Atomicity;Consistency;Isolation;Durability}$</li>
</ul>
<h4 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h4><ul>
<li>事务中包含的所有操作要么全做，要么全不做</li>
<li>原子性由<strong>恢复机制</strong>实现<ul>
<li>通过<strong>日志</strong>进行恢复</li>
</ul>
</li>
</ul>
<h4 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性(Consistency)"></a>一致性(Consistency)</h4><ul>
<li>事务的隔离执行必须保证数据库的一致性</li>
<li>事务开始前，数据库处于一致性的状态；事务结束后，数据库必须仍处于一致性状态</li>
<li><strong>数据库的一致性状态由用户来负责</strong></li>
<li>如银行转帐，转帐前后两个帐户金额之和应保持不变<ul>
<li>意大利香肠术，Salami technique</li>
<li>偷小钱的盗窃术被称为意大利香肠术（意大利香肠切得很薄，偷一片看不出来）</li>
</ul>
</li>
</ul>
<h4 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性(Isolation)"></a>隔离性(Isolation)</h4><ul>
<li>系统必须保证事务不受其它并发执行事务的影响</li>
<li>对任何一对事务 T1，T2，在 T1 看来，T2 要么在 T1 开始之前已经结束，要么在 T1 完成之后再开始执行<ul>
<li><strong>等价于串行执行的效果</strong></li>
</ul>
</li>
<li>隔离性通过<strong>并发控制机制</strong>实现</li>
</ul>
<h4 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性(Durability)"></a>持久性(Durability)</h4><ul>
<li>一个事务一旦提交之后，它对数据库的影响必须是永久的</li>
<li>系统发生故障不能改变事务的持久性<ul>
<li>系统的<strong>抗故障能力</strong></li>
<li>大企业的数据，备份，多个物理实体（物理上相隔较远，避免自然灾害的影响）</li>
</ul>
</li>
<li>持久性通过<strong>恢复机制</strong>实现</li>
<li>持久性：将来总能够再现这个事务</li>
</ul>
<h3 id="事务生命周期图"><a href="#事务生命周期图" class="headerlink" title="事务生命周期图"></a>事务生命周期图</h3><img src="06/image-20210521234852488.png" style="zoom:50%;" />

<ul>
<li>部分提交状态：事务的所有操作都做完了</li>
<li>一个事务的所有操作都做完了，并不意味着一定能成功提交，因为要保证持久性<ul>
<li>数据库在做完事务的所有操作之后，在向程序客户端发送成功消息之前，<strong>把这个事务对应的<span style="color:red">日志记录</span>从内存写入磁盘</strong></li>
<li>如果系统崩溃，内存中的数据丢失了，可以从日志记录恢复数据</li>
</ul>
</li>
</ul>
<h2 id="事务调度"><a href="#事务调度" class="headerlink" title="事务调度"></a>事务调度</h2><ul>
<li><strong>事务的执行顺序</strong>称为一个调度，表示事务的指令在系统中<strong>执行的时间顺序</strong></li>
<li>一组事务的调度必须保证<ul>
<li>包含了<strong>所有事务</strong>的操作指令</li>
<li><strong>一个事务中指令的顺序必须保持不变</strong></li>
</ul>
</li>
</ul>
<h3 id="事务调度例子"><a href="#事务调度例子" class="headerlink" title="事务调度例子"></a>事务调度例子</h3><ul>
<li>$T_1:i_{11},i_{12},T_2:i_{21},i_{22}$<ul>
<li>$S_1:i_{11},i_{12},i_{21}$</li>
<li>$S_2:i_{11},i_{22},i_{12},i_{21}$</li>
<li>$S_2:i_{11},i_{21},i_{12},i_{22}$</li>
</ul>
</li>
<li>$S_1,S_2$ 不是一个调度，$S_3$ 是一个调度</li>
</ul>
<h3 id="并行与串行"><a href="#并行与串行" class="headerlink" title="并行与串行"></a>并行与串行</h3><h4 id="串行调度"><a href="#串行调度" class="headerlink" title="串行调度"></a>串行调度</h4><ul>
<li>在串行调度中，属于同一事务的指令紧挨在一起</li>
<li>串行调度总是正确的</li>
<li>对于有 $n$个事务的事务组，可以有 $n!$ 个有效调度</li>
</ul>
<h4 id="并行调度"><a href="#并行调度" class="headerlink" title="并行调度"></a>并行调度</h4><ul>
<li>在并行调度中，来自不同事务的指令可以交叉执行</li>
<li><strong>当并行调度等价于某个串行调度时，则称它是正确的</strong></li>
<li>$n$ 个事务，$t_i$ 有 $k_i$ 条指令，则可能的并发调度有多少个<ul>
<li>$\dfrac{(\sum k_i)!}{\prod(k_i!)}$</li>
<li>事务内有序</li>
</ul>
</li>
</ul>
<h4 id="并行和串行的比较"><a href="#并行和串行的比较" class="headerlink" title="并行和串行的比较"></a>并行和串行的比较</h4><h5 id="基本比较"><a href="#基本比较" class="headerlink" title="基本比较"></a>基本比较</h5><ul>
<li>并行事务有可能破坏数据库的一致性</li>
<li>串行事务效率低</li>
</ul>
<h5 id="并行的优点"><a href="#并行的优点" class="headerlink" title="并行的优点"></a>并行的优点</h5><ul>
<li>一个事务由不同的步骤组成，所涉及的系统资源也不同。这些步骤可以并发执行，<strong>提高系统的吞吐量</strong></li>
<li>系统中存在着周期不等的各种事务，串行会导致难于预测的时延。如果各个事务所涉及的是数据库的不同部分，采用并发会<strong>减少平均响应时间</strong></li>
</ul>
<h3 id="事务调度例子-1"><a href="#事务调度例子-1" class="headerlink" title="事务调度例子"></a>事务调度例子</h3><ul>
<li>两个转账事务<ul>
<li>$T_1$：从 A 过户 50 到 B</li>
<li>$T_2$：从 A 过户存款的 10% 到 B</li>
</ul>
</li>
</ul>
<p>$$<br>\begin{aligned}<br>&amp;T1\<br>&amp;read(A);\<br>&amp;A :&#x3D; A −50;\<br>&amp;write(A);\<br>&amp;read(B);\<br>&amp;B :&#x3D; B + 50;\<br>&amp;write(B);\\<br>&amp;T2\<br>&amp;read(A);\<br>&amp;temp :&#x3D; A*0.1;\<br>&amp;A :&#x3D; A −temp;\<br>&amp;write(A);\<br>&amp;read(B);\<br>&amp;B :&#x3D; B + temp;\<br>&amp;write(B);\<br>\end{aligned}<br>$$</p>
<ul>
<li>开始状态：A&#x3D;1000，B&#x3D;2000，A+B&#x3D;3000</li>
</ul>
<h4 id="串行调度1"><a href="#串行调度1" class="headerlink" title="串行调度1"></a>串行调度1</h4><ul>
<li>$T_1,T_2$</li>
<li>结束状态：A&#x3D;855，B&#x3D;2145，A+B&#x3D;3000</li>
</ul>
<h4 id="串行调度2"><a href="#串行调度2" class="headerlink" title="串行调度2"></a>串行调度2</h4><ul>
<li>$T_2,T_1$</li>
<li>结束状态：A&#x3D;850，B&#x3D;2150，A+B&#x3D;3000</li>
<li>串行调度可能会有不同的结果，但是都满足一致性，都是正确的</li>
</ul>
<h4 id="并行调度1"><a href="#并行调度1" class="headerlink" title="并行调度1"></a>并行调度1</h4><p>$$<br>\begin{aligned}<br>&amp;T1:;read(A);\<br>&amp;T1:;A :&#x3D; A −50;\<br>&amp;T1:;write(A);\<br>&amp;T2:;read(A);\<br>&amp;T2:;temp :&#x3D; A*0.1;\<br>&amp;T2:;A :&#x3D; A −temp;\<br>&amp;T2:;write(A);\<br>&amp;T1:;read(B);\<br>&amp;T1:;B :&#x3D; B + 50;\<br>&amp;T1:;write(B);\<br>&amp;T2:;read(B);\<br>&amp;T2:;B :&#x3D; B + temp;\<br>&amp;T2:;write(B);\<br>\end{aligned}<br>$$</p>
<ul>
<li>需要保证操作 4 在操作 3 之后，否则是错误的</li>
<li>结束状态：A&#x3D;855，B&#x3D;2145，A+B&#x3D;3000</li>
<li>等价于串行调度 $T_1,T_2$</li>
</ul>
<h4 id="并行调度2"><a href="#并行调度2" class="headerlink" title="并行调度2"></a>并行调度2</h4><p>$$<br>\begin{aligned}<br>&amp;T1:;read(A);\<br>&amp;T1:;A :&#x3D; A −50;\<br>&amp;T2:;read(A);\<br>&amp;T1:;write(A);\<br>&amp;T2:;temp :&#x3D; A*0.1;\<br>&amp;T2:;A :&#x3D; A −temp;\<br>&amp;T2:;write(A);\<br>&amp;T1:;read(B);\<br>&amp;T1:;B :&#x3D; B + 50;\<br>&amp;T1:;write(B);\<br>&amp;T2:;read(B);\<br>&amp;T2:;B :&#x3D; B + temp;\<br>&amp;T2:;write(B);\<br>\end{aligned}<br>$$</p>
<ul>
<li>错误的</li>
<li>结束状态：A&#x3D;900，B&#x3D;2150，A+B&#x3D;3050</li>
</ul>
<h3 id="可恢复调度"><a href="#可恢复调度" class="headerlink" title="可恢复调度"></a>可恢复调度</h3><ul>
<li>事务的恢复<ul>
<li>一个事务失败了，应该能够撤消该事务对数据库的影响</li>
<li>如果有其它事务读取了失败事务写入的数据，则该事务应该撤消</li>
</ul>
</li>
<li>一个不可恢复调度的例子</li>
</ul>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">read(A)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">write(A)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">read(A)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">commit</td>
</tr>
<tr>
<td align="center">read(B)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">rollback</td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>回滚 T1 的时候，T2 已经提交了，如果 T2 被撤销了，那么就违反了事务的持久性<ul>
<li>在真实场景中， 会向 T2 发起一个<strong>补偿事务</strong></li>
</ul>
</li>
</ul>
<h4 id="可恢复调度定义"><a href="#可恢复调度定义" class="headerlink" title="可恢复调度定义"></a>可恢复调度定义</h4><ul>
<li>对于每对事务 T1 与 T2，如果 T2 读取了 T1 所写的数据，则 T1 必须先于 T2 提交</li>
</ul>
<h3 id="无级联调度"><a href="#无级联调度" class="headerlink" title="无级联调度"></a>无级联调度</h3><ul>
<li>级联调度<ul>
<li>由于一个事务故障而导致一系列事务回滚</li>
</ul>
</li>
<li>级联调度例子</li>
</ul>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
<th align="center">T3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">read(A)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">read(B)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">write(B)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">read(A)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">write(A)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">read(A)</td>
</tr>
<tr>
<td align="center">rollback</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="无级联调度定义"><a href="#无级联调度定义" class="headerlink" title="无级联调度定义"></a>无级联调度定义</h4><ul>
<li>对于每对事务 T1 与 T2，如果 T2 读取了 T1 所写的数据，则 T1 必须在 <strong>T2 读取</strong>之前提交</li>
<li><strong>无级联调度必是可恢复调度</strong><ul>
<li>要求比可恢复调度更加严格</li>
</ul>
</li>
</ul>
<h2 id="并发调度中的不一致现象"><a href="#并发调度中的不一致现象" class="headerlink" title="并发调度中的不一致现象"></a>并发调度中的不一致现象</h2><h3 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h3><ul>
<li>两个事务 T1 和 T2 读入同一数据并修改，T1 提交的结果破坏了 T2 提交的结果，导致 T2 的修改丢失</li>
<li>一个例子：售票窗口<ul>
<li>下面的操作只反映了售票窗口 T1 的结果，但是没有反应售票窗口 T2 的结果</li>
</ul>
</li>
</ul>
<img src="06/image-20210522110153105.png" style="zoom:50%;" />

<ul>
<li><strong>写 —— 写</strong>不一致</li>
</ul>
<h3 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h3><ul>
<li>事务 T1 修改某一数据，并将其写回磁盘，事务 T2 读取同一数据后，T1 由于某种原因被撤消，这时 T1 已修改过的数据恢复原值，T2 读到的数据与数据库中数据不一致，则 T2 读到的数据就是脏数据</li>
<li>一个例子</li>
</ul>
<img src="06/image-20210522110848800.png" style="zoom:50%;" />

<ul>
<li><strong>写 —— 读</strong>不一致</li>
</ul>
<h3 id="不能重复读"><a href="#不能重复读" class="headerlink" title="不能重复读"></a>不能重复读</h3><ul>
<li>事务 T2 读取某一数据后，事务 T1 对其做了修改，当 T2 再次读取该数据时，得到与前次不同的值</li>
</ul>
<img src="06/image-20210522111134680.png" style="zoom:50%;" />

<ul>
<li><strong>读 —— 写</strong>不一致</li>
<li>发生概率比读脏数据小</li>
<li>例子<ul>
<li>r1(list) r2(list) w2(list) r2(count) w2(count) commit(t2) r1(count)</li>
<li>r1(list) 和 r1(count) 不一致</li>
</ul>
</li>
</ul>
<h3 id="发生幻象-Phantom"><a href="#发生幻象-Phantom" class="headerlink" title="发生幻象(Phantom)"></a>发生幻象(Phantom)</h3><ul>
<li>事务 T2 按一定条件读取了某些数据后，事务 T1 插入了一些满足这些条件的数据，当 T2 再次按相同条件读取数据时，发现多了一些记录</li>
</ul>
<img src="06/image-20210522111831336.png" style="zoom:50%;" />

<ul>
<li>不可重复读是指对同一条记录出现不一致情况，幻象指的是多出来或者少掉某些记录<ul>
<li>防止幻象更难</li>
<li>例如<ul>
<li>防范不可重复读只需要将原来在数据库中的数据锁住</li>
<li>防范幻象则比较难，怎么处理新来的数据</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/21/DB/CLJ/06/" data-id="cl9lj74ax00fr64tz2x03hvuk" data-title="数据库概论.陈立军.06.事务" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/CLJ/05-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/19/DB/CLJ/05-2/" class="article-date">
  <time class="dt-published" datetime="2021-05-19T14:20:45.000Z" itemprop="datePublished">2021-05-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/19/DB/CLJ/05-2/">数据库概论.陈立军.05.关系规范化(3)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h1><ul>
<li>例子：给定一个关系模式，通过模式分解解决异常</li>
<li>关系模式：$R(ABCD;A\to B,B\to C)$</li>
<li>分解一<ul>
<li>$R_1(AB;A\to B),R_2(BC;B\to C)$</li>
<li>不是正确的分解，缺失了属性 $D$</li>
</ul>
</li>
<li>分解二<ul>
<li>$R_1(ABD;A\to B),R_2(BC;B\to C),R_3(BD)$</li>
<li>不是正确的分解，$R_3$ 包含在 $R_1$ 中，没必要</li>
</ul>
</li>
<li>分解三<ul>
<li>$R_1(AB;A\to B),R_2(AC),R_3(AD)$</li>
<li>不是正确的分解，和原来的关系模式函数依赖不等价（$A\to C$）</li>
</ul>
</li>
<li>分解四<ul>
<li>$R_1(AB;A\to B),R_2(AC;A\to C),R_3(AD)$</li>
<li>正确</li>
</ul>
</li>
</ul>
<h2 id="模式分解的定义"><a href="#模式分解的定义" class="headerlink" title="模式分解的定义"></a>模式分解的定义</h2><ul>
<li>属性上来看<ul>
<li>子模式的属性集的并集和原来相同</li>
<li>子模式的属性集之间不能有包含关系</li>
</ul>
</li>
<li>函数依赖上看<ul>
<li>原来函数依赖集要正确的投影到子模式的属性集上面</li>
</ul>
</li>
</ul>
<h3 id="函数依赖在属性集上的投影"><a href="#函数依赖在属性集上的投影" class="headerlink" title="函数依赖在属性集上的投影"></a>函数依赖在属性集上的投影</h3><ul>
<li>函数依赖集 $F$ 在属性集 $U_i$ 上的投影定义为：$F_i&#x3D;{X\to Y|X\to Y\in F^+\land XY\subseteq U_i}$</li>
</ul>
<h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><ul>
<li>求 $F&#x3D;{A\to B, B\to C, C\to D}$ 在 $S(ACD)$ 上的投影</li>
<li>先求出闭包<ul>
<li>$A_F^+&#x3D;ABCD,C_F^+&#x3D;CD,D_F^+&#x3D;D$</li>
</ul>
</li>
<li>写出函数依赖<ul>
<li>需要考虑二元（多元）<ul>
<li>$A_F^+$ 已经是全集了，于是不需要考虑 $A$ 和其他的组合</li>
<li>$(CD_F)^+&#x3D;CD$，于是也不需要了</li>
</ul>
</li>
<li>$A\to C,A\to D,C\to D$</li>
</ul>
</li>
<li>消除冗余依赖<ul>
<li>$A\to C,C\to D$</li>
</ul>
</li>
</ul>
<h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><ul>
<li>计算下面函数依赖集在 $S(ABC)$ 上的投影<ul>
<li>$F&#x3D;{AB\to DE,C\to E,D\to C,E\to A}$</li>
<li>$F&#x3D;{A\to D,BD\to E,AC\to E,DE\to B}$</li>
<li>$F&#x3D;{AB\to D,AC\to E,BC\to D,D\to A,E\to B}$</li>
</ul>
</li>
</ul>
<h5 id="1-F-x3D-AB-to-DE-C-to-E-D-to-C-E-to-A"><a href="#1-F-x3D-AB-to-DE-C-to-E-D-to-C-E-to-A" class="headerlink" title="$(1);F&#x3D;{AB\to DE,C\to E,D\to C,E\to A}$"></a>$(1);F&#x3D;{AB\to DE,C\to E,D\to C,E\to A}$</h5><ul>
<li><p>${\color{red}{C\to A,AB\to C,BC\to A}}$</p>
</li>
<li><p>$A_F^+&#x3D;A$</p>
</li>
<li><p>$B_F^+&#x3D;B$</p>
</li>
<li><p>$C_F^+&#x3D;CEA$</p>
</li>
<li><p>$(AB)_F^+&#x3D;ABDEC$</p>
</li>
<li><p>$(AC)_F^+&#x3D;ACE$</p>
</li>
<li><p>$(BC)_F^+&#x3D;BCEAD$</p>
</li>
</ul>
<h5 id="2-F-x3D-A-to-D-BD-to-E-AC-to-E-DE-to-B"><a href="#2-F-x3D-A-to-D-BD-to-E-AC-to-E-DE-to-B" class="headerlink" title="$(2);F&#x3D;{A\to D,BD\to E,AC\to E,DE\to B}$"></a>$(2);F&#x3D;{A\to D,BD\to E,AC\to E,DE\to B}$</h5><ul>
<li>${\color{red}{AC\to B}}$</li>
<li>$A_F^+&#x3D;AD$</li>
<li>$B_F^+&#x3D;B$</li>
<li>$C_F^+&#x3D;C$</li>
<li>$(AB)_F^+&#x3D;ABDE$</li>
<li>$(AC)_F^+&#x3D;ACDEB$</li>
<li>$(BC)_F^+&#x3D;BC$</li>
</ul>
<h5 id="3-F-x3D-AB-to-D-AC-to-E-BC-to-D-D-to-A-E-to-B"><a href="#3-F-x3D-AB-to-D-AC-to-E-BC-to-D-D-to-A-E-to-B" class="headerlink" title="$(3);F&#x3D;{AB\to D,AC\to E,BC\to D,D\to A,E\to B}$"></a>$(3);F&#x3D;{AB\to D,AC\to E,BC\to D,D\to A,E\to B}$</h5><ul>
<li>${\color{red}{AC\to B,BC\to A}}$</li>
<li>$A_F^+&#x3D;A$</li>
<li>$B_F^+&#x3D;B$</li>
<li>$C_F^+&#x3D;C$</li>
<li>$(AB)_F^+&#x3D;ABD$</li>
<li>$(AC)_F^+&#x3D;ACEBD$</li>
<li>$(BC)_F^+&#x3D;BCDAE$</li>
</ul>
<h3 id="模式分解的定义-1"><a href="#模式分解的定义-1" class="headerlink" title="模式分解的定义"></a>模式分解的定义</h3><ul>
<li>关系模式 $R(U , F)$ 的一个分解是指<ul>
<li>$\rho&#x3D;{R_1(U_1,F_1),\cdots,R_n(U_n,F_n)}$</li>
<li>其中 $U&#x3D;\bigcup_{i&#x3D;1}^{n}U_i$，并且没有 $U_i\subseteq U_j,1\le i,j\le n$</li>
<li>$F_i$ 是 $F$ 在 $U_i$ 上的投影</li>
</ul>
</li>
<li>模式分解的代数运算<ul>
<li>分解：投影</li>
<li>还原：自然连接</li>
</ul>
</li>
</ul>
<h3 id="模式分解的目标"><a href="#模式分解的目标" class="headerlink" title="模式分解的目标"></a>模式分解的目标</h3><ul>
<li>trade off<ul>
<li><strong>达到更高级的范式</strong></li>
<li><strong>无损连接分解</strong></li>
<li><strong>保持函数依赖</strong></li>
</ul>
</li>
</ul>
<h2 id="模式分解中的问题"><a href="#模式分解中的问题" class="headerlink" title="模式分解中的问题"></a>模式分解中的问题</h2><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>分解的过于完全：丢失信息</li>
</ul>
<img src="05-2/image-20210520000151424.png" style="zoom:50%;" />

<h3 id="违约-x2F-违章"><a href="#违约-x2F-违章" class="headerlink" title="违约&#x2F;违章"></a>违约&#x2F;违章</h3><ul>
<li>在分解之后的表中执行插入操作，重构的时候可能违反原始表的函数依赖<ul>
<li>问题是丢失了函数依赖</li>
<li>$A\to B,A\to C$ 推导不出原来的 $B\to C$</li>
</ul>
</li>
</ul>
<img src="05-2/image-20210520113036080.png" style="zoom:50%;" />



<h3 id="有损"><a href="#有损" class="headerlink" title="有损"></a>有损</h3><ul>
<li>有损分解：信息损失了</li>
</ul>
<img src="05-2/image-20210520113541161.png" style="zoom:50%;" />

<h3 id="正确的分解"><a href="#正确的分解" class="headerlink" title="正确的分解"></a>正确的分解</h3><img src="05-2/image-20210520113735780.png" style="zoom:50%;" />

<ul>
<li>有损比违章害处更大，违章的数据可以通过检查剔除</li>
</ul>
<h2 id="保持函数依赖的分解"><a href="#保持函数依赖的分解" class="headerlink" title="保持函数依赖的分解"></a>保持函数依赖的分解</h2><ul>
<li>设关系模式 $R(U , F)$ 的一个分解是<ul>
<li>$\rho&#x3D;{R_1(U_1,F_1),\cdots,R_n(U_n,F_n)}$</li>
<li>如果 $F^+&#x3D;(\bigcup_{i&#x3D;1}^nF_i)^+$</li>
<li>则称 $\rho$ 是保持函数依赖的分解</li>
</ul>
</li>
<li>等价于验证 $F\subseteq (\bigcup_{i&#x3D;1}^nF_i)^+,F_i\subseteq F$</li>
<li>由于 $F_i$ 都是由 $F$ 导出的，我们只需要验证 $F$ 中的函数依赖能够被 $\bigcup F_i$ 导出即可</li>
</ul>
<h3 id="丢失函数依赖的分解实例"><a href="#丢失函数依赖的分解实例" class="headerlink" title="丢失函数依赖的分解实例"></a>丢失函数依赖的分解实例</h3><ul>
<li>$U&#x3D;{CITY,ST,ZIP},F&#x3D;{(CITY,ST)\to ZIP,ZIP\to CITY}$</li>
<li>分解如下<ul>
<li>$U_1&#x3D;{ST,ZIP},F1&#x3D;{}$</li>
<li>$U_2&#x3D;{CITY,ZIP},F2&#x3D;{ZIP\to CITY}$</li>
</ul>
</li>
<li>丢失了函数依赖 $(CITY,ST)\to ZIP$</li>
<li>插入数据导致的问题</li>
</ul>
<img src="05-2/image-20210520114858895.png" style="zoom:50%;" />



<h3 id="有损分解的例子"><a href="#有损分解的例子" class="headerlink" title="有损分解的例子"></a>有损分解的例子</h3><ul>
<li>构造方法：公共属性上相同值多一些</li>
</ul>
<img src="05-2/image-20210520114954753.png" style="zoom:50%;" />



<h2 id="无损连接分解"><a href="#无损连接分解" class="headerlink" title="无损连接分解"></a>无损连接分解</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>设关系模式 $R(U , F)$ 的一个分解是<ul>
<li>$\rho&#x3D;{R_1(U_1,F_1),\cdots,R_n(U_n,F_n)}$</li>
<li>$r$ 是 $R$ 的任意一个关系实例</li>
<li>定义 $m_{\rho}(r)&#x3D;\prod_{U_i}(r)$</li>
<li>若 $m_{\rho}(r)&#x3D;r$，则称 $\rho$ 是 $R$ 的一个无损分解</li>
</ul>
</li>
</ul>
<h3 id="无损连接分解的判别算法"><a href="#无损连接分解的判别算法" class="headerlink" title="无损连接分解的判别算法"></a>无损连接分解的判别算法</h3><ul>
<li>$U&#x3D;{A_1,A_2,\cdots,A_n}$</li>
<li>$\rho&#x3D;{R_1(U_1,F_1),\cdots,R_k(U_k,F_k)}$</li>
</ul>
<h4 id="1-建立一个-n-列-k-行的矩阵-TB"><a href="#1-建立一个-n-列-k-行的矩阵-TB" class="headerlink" title="(1) 建立一个 $n$ 列 $k$ 行的矩阵 TB"></a>(1) 建立一个 $n$ 列 $k$ 行的矩阵 TB</h4><ul>
<li>填充矩阵</li>
<li>$TB&#x3D;{C_{ij}|若A_i\in U_i,C_{ij}&#x3D;a_j,否则C_{ij}&#x3D;b_{ij}}$</li>
</ul>
<h4 id="2-对-F-中每一个函数依赖-X-to-Y"><a href="#2-对-F-中每一个函数依赖-X-to-Y" class="headerlink" title="(2) 对 $F$ 中每一个函数依赖 $X\to Y$"></a>(2) 对 $F$ 中每一个函数依赖 $X\to Y$</h4><ul>
<li>若 TB 中存在元组 $t_1,t_2$，使得 $t_1[X]&#x3D;t_2[X],t_1[Y]\ne t_2[Y]$</li>
<li>则对每一个 $A_i\in Y$ 进行如下操作<ul>
<li>若 $t_1[A_i],t_2[A_i]$ 中有一个等于$a_j$，则另一个也改为 $a_j$</li>
<li>否则取 $t_1[A_i]&#x3D;t_2[A_i]$（$t_2$ 的行号小于 $t_1$）</li>
</ul>
</li>
</ul>
<h4 id="3-反复执行-2-，直至如下情况发生"><a href="#3-反复执行-2-，直至如下情况发生" class="headerlink" title="(3) 反复执行 (2)，直至如下情况发生"></a>(3) 反复执行 (2)，直至如下情况发生</h4><ul>
<li>TB 中出现一行全为 $a_1,a_2,\cdots,a_n$的一行（无损分解）</li>
<li>TB 不再变化，而且没有一行为 $a_1,a_2,\cdots,a_n$（有损分解）</li>
</ul>
<h4 id="一个算法的例子"><a href="#一个算法的例子" class="headerlink" title="一个算法的例子"></a>一个算法的例子</h4><img src="05-2/image-20210520121032976.png" style="zoom:50%;" />



<h3 id="分解为两个关系模式的无损分解"><a href="#分解为两个关系模式的无损分解" class="headerlink" title="分解为两个关系模式的无损分解"></a>分解为两个关系模式的无损分解</h3><ul>
<li>关系模式 $R(U),U_1\cup U_2 &#x3D; U$</li>
<li>$r$ 是 $R$ 上的任一关系，$r_1&#x3D;\prod_{U_1}(r),r_2&#x3D;\prod_{U_2}(r)$</li>
<li>若$r &#x3D; r_1\bowtie r_2$，则称 ${U_1,U_2}$ 是 $U$ 的一个无损连接分解</li>
</ul>
<h4 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h4><ul>
<li>$\rho$ 是无损连接分解 $\Leftrightarrow$ $U_1\cap U_2\to U_1−U_2$ 或 $U_1\cap U_2\to U_2−U_1$</li>
<li>使用之前的判定算法做一个简单的证明</li>
</ul>
<img src="05-2/image-20210520121911067.png" style="zoom:50%;" />

<ul>
<li>在这里没有证明， 如果是无损的，则能推出上述函数依赖</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>$R&#x3D;ABC,F&#x3D;{A\to B}$</li>
<li>分解一：$\rho_1&#x3D;{R_1(AB),R_2(AC)}$<ul>
<li>$R_1\cap R_2&#x3D;A,R_1-R_2&#x3D;B$</li>
<li>由 $A\to B$，得到 $\rho_1$</li>
<li>是无损连接分解</li>
</ul>
</li>
<li>分解二：$\rho_2&#x3D;{R_1(AB),R_2(BC)}$<ul>
<li>$R_1\cap R_2&#x3D;B,R_1-R_2&#x3D;A,R_2-R_1&#x3D;C$</li>
<li>$B\to A,B\to C$ 均不成立</li>
<li>不是无损连接分解</li>
</ul>
</li>
</ul>
<h3 id="达到-BCNF-无损连接分解算法"><a href="#达到-BCNF-无损连接分解算法" class="headerlink" title="达到 BCNF 无损连接分解算法"></a>达到 BCNF 无损连接分解算法</h3><ul>
<li>BCNF：对于每个子模式，所有的函数依赖的左边都是码</li>
</ul>
<h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><ul>
<li>给定关系模式 $R(U,F)$<ul>
<li>(1) 令 $\rho&#x3D;R(U,F)$</li>
<li>(2) 检查 $\rho$ 中各关系模式是否属于BCNF，若是，则算法终止</li>
<li>(3) 设 $\rho$ 中 $R_i(U_i,F_i)$ 不属于 BCNF<ul>
<li>则存在函数依赖 $X\to A\in F_i^+$，且 $X$ 不是 $R_i$ 的码</li>
<li>将 $R_i$ 分解为 $\sigma&#x3D;{S_1(U_1),S_2(U_2)}$</li>
<li>其中 $U_1&#x3D;XA,U_2&#x3D;U_i-A$</li>
<li>以 $\sigma$ 代替 $R_i$，返回到 (2)</li>
</ul>
</li>
</ul>
</li>
<li>结果一定能够达到 BCNF</li>
<li>结果一定是无损的，可以通过上面 ”分解为两个关系模式的无损分解算法“ 证明<ul>
<li>$U_1\cap U_2&#x3D;X$</li>
<li>$U_1-U_2&#x3D;A$</li>
<li>$X\to A$</li>
</ul>
</li>
</ul>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><ul>
<li>码是 AD，A 不是码，B 不是码</li>
</ul>
<img src="05-2/image-20210520151750073.png" style="zoom:50%;" />

<ul>
<li>当原来的关系模式中，存在多个函数依赖不满足 BCNF，处理的先后顺序会影响最终的结果</li>
<li>如何构造一个有 N 种 BCNF 分解结果的关系模式？<ul>
<li>一个例子：3</li>
<li>$A\to D,B\to D,C\to D$，码是 $ABC$</li>
</ul>
</li>
</ul>
<h4 id="关于BCNF分解的额外讨论"><a href="#关于BCNF分解的额外讨论" class="headerlink" title="关于BCNF分解的额外讨论"></a>关于BCNF分解的额外讨论</h4><ul>
<li>$R(ABCD),FD&#x3D;{A\to B,A\to C}$</li>
<li>码是 $AD$，分解为 BCNF<ul>
<li>分解结果为 $R_1(AB),R_2(AC),R_3(AD)$</li>
</ul>
</li>
<li>$R_1,R_2$ 没必要分开</li>
<li>优化方法：基于 $X\to A$ 的 BCNF 分解，<span style="font-weight:bold;color:red">将右边扩展为 $X$ 的闭包</span><ul>
<li>分解结果为 $R_1(ABC),R_2(AD)$</li>
</ul>
</li>
</ul>
<h3 id="达到-4NF-无损连接分解算法"><a href="#达到-4NF-无损连接分解算法" class="headerlink" title="达到 4NF 无损连接分解算法"></a>达到 4NF 无损连接分解算法</h3><ul>
<li><p>给定关系模式 $R(U,F)$</p>
<ul>
<li>(1) 令 $\rho&#x3D;R(U,F)$</li>
<li>(2) 检查 $\rho$ 中各关系模式是否属于BCNF，若是，则算法终止</li>
<li>(3) 设 $\rho$ 中 $R_i(U_i,F_i)$ 不属于 BCNF<ul>
<li>则存在非平凡多值依赖 $X\to\to A$，且 $X$ 不是 $R_i$ 的码</li>
<li>将 $R_i$ 分解为 $\sigma&#x3D;{S_1(U_1),S_2(U_2)}$</li>
<li>其中 $U_1&#x3D;XA,U_2&#x3D;U_i-A$</li>
<li>以 $\sigma$ 代替 $R_i$，返回到 (2)</li>
</ul>
</li>
</ul>
</li>
<li><p>一个例子</p>
</li>
</ul>
<img src="05-2/image-20210520152425047.png" style="zoom:50%;" />



<h3 id="丢失函数依赖的-BCNF-分解"><a href="#丢失函数依赖的-BCNF-分解" class="headerlink" title="丢失函数依赖的 BCNF 分解"></a>丢失函数依赖的 BCNF 分解</h3><ul>
<li>若要求分解保持函数依赖，那么分解后的模式总可以达到 3NF，但不一定能达到 BCNF</li>
<li>例子<ul>
<li>$U&#x3D;(sno, tno, cno),F&#x3D;{(sno, cno)\to tno, tno\to cno}$</li>
<li>不属于BCNF，分解为 $U_1&#x3D;(sno, tno),U_2&#x3D;(tno, cno),F_2&#x3D;{tno\to cno}$</li>
<li>丢失了函数依赖 $(sno, cno)\to tno$</li>
</ul>
</li>
</ul>
<h3 id="达到-3NF-保持函数依赖的分解"><a href="#达到-3NF-保持函数依赖的分解" class="headerlink" title="达到 3NF 保持函数依赖的分解"></a>达到 3NF 保持函数依赖的分解</h3><ul>
<li>求 $F$ 的最小覆盖 $F_{min}$</li>
<li>找出不在 $F_{min}$ 中出现的属性，将它们构成一个关系模式，并从 $U$ 中去掉它们（剩余属性仍记为$U$）</li>
<li>若有 $X\to A\in F_{min}$，且 $XA&#x3D;U$，$\rho&#x3D;{R}$，算法终止</li>
<li>对  $F_{min}$ 按具有相同左部的原则进行分组（设为 $k$ 组）<ul>
<li>每一组函数依赖所涉及的属性全体为 $U_i$</li>
<li>令 $F_i$ 为 $F_{min}$在 $U_i$上的投影</li>
<li>则 $\rho&#x3D;{R_1(U_1,F_1),\cdots,R_k(U_k,F_k)}$ 是 $R(U,F)$ 的一个保持函数依赖的分解</li>
<li>并且每个 $R_i(U_i,F_i)\in 3NF$</li>
</ul>
</li>
</ul>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><ul>
<li>$U&#x3D;{A,B,C,D,E},F&#x3D;{A\to B,B\to C,AD\to E}$</li>
<li>分组<ul>
<li>${(AB),A\to B}$</li>
<li>${(BC),B\to C}$</li>
<li>${(ADE),AD\to E}$</li>
</ul>
</li>
</ul>
<h3 id="同时保持函数依赖和无损连接的分解"><a href="#同时保持函数依赖和无损连接的分解" class="headerlink" title="同时保持函数依赖和无损连接的分解"></a>同时保持函数依赖和无损连接的分解</h3><ul>
<li>$R(ABC;A\to C, B\to C)$</li>
<li>按保持无损连接分解，码为 $AB$<ul>
<li>分解为 ${AC;A\to C},{AB}$</li>
<li>丢失了函数依赖 $B\to C$</li>
</ul>
</li>
<li>按保持函数依赖分解<ul>
<li>进行分组 ${AC;A\to C},{BC;B\to C}$</li>
<li>分解是有损的</li>
</ul>
</li>
</ul>
<img src="05-2/image-20210520155032495.png" style="zoom:50%;" />

<ul>
<li>如何在保持函数依赖的同时，进行无损分解？<ul>
<li>从重构的表中删除不在原来表里的行</li>
<li>怎么删除？和原来的表的码做一次连接</li>
</ul>
</li>
<li>上述分解为 ${AC;A\to C},{BC;B\to C},{AB}$</li>
</ul>
<h4 id="分解算法"><a href="#分解算法" class="headerlink" title="分解算法"></a>分解算法</h4><ul>
<li>设 $\rho&#x3D;{R_1(U_1,F_1),\cdots,R_k(U_k,F_k)}$ 是 $R(U,F)$ 的一个保持函数依赖的 3NF 分解</li>
<li>设 $X$ 是 $R(U,F)$ 的码，若有某个 $U_i,X\subseteq U_i$ 则 $\rho$ 即为所求</li>
<li>否则结果为 $\rho\cup {R^\ast(X,F_X)}$</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="其他分解方式"><a href="#其他分解方式" class="headerlink" title="其他分解方式"></a>其他分解方式</h3><ul>
<li>先将所有的关系模式打散，然后合并<ul>
<li>$R_1(AB;{A\to B})$</li>
<li>$R_2(AC;{A\to C})$</li>
<li>$R_3(AD; {A\to D})$</li>
<li>合并为 $R(ABCD;A\to B,A\to C;A\to D)$</li>
</ul>
</li>
</ul>
<h3 id="悬挂元组"><a href="#悬挂元组" class="headerlink" title="悬挂元组"></a>悬挂元组</h3><ul>
<li><strong>泛关系</strong><ul>
<li>$R$ 分解为 $R_1,\cdots,R_n$ ，则 $r_1\bowtie r_2\bowtie\cdots\bowtie r_n$ 称为泛关系</li>
</ul>
</li>
<li>在 $r_i$ 中出现，但在 $\prod_{R_i}(r_1\bowtie r_2\bowtie\cdots\bowtie r_n)$ 中没有出现的元组，称为<strong>悬挂元组</strong></li>
<li>悬挂元组代表了不完整信息</li>
</ul>
<img src="05-2/image-20210520162648780.png" style="zoom:50%;" />

<ul>
<li>模式分解允许一些不完整信息在数据库中的记录</li>
</ul>
<h3 id="模式调优"><a href="#模式调优" class="headerlink" title="模式调优"></a>模式调优</h3><ul>
<li>规范化为了消除异常，模式调优是追求性能</li>
<li>$R(XYZ)$ 还是 $R_1(XY)$ 和 $R_2(XZ)$<ul>
<li>一般情况下 $R$ 好于 $R_1$ 和 $R_2$，在下面情况下后者较好：<ul>
<li>大多数用户的存取分别在两个集合上<ul>
<li>$Y$ 经常访问，但是 $Z$ 很少访问</li>
</ul>
</li>
<li>属性 $Y$ 和 $Z$ 的值占用很大空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="冗余列"><a href="#冗余列" class="headerlink" title="冗余列"></a>冗余列</h3><ul>
<li>把一个表里的某一列，复制到另一个表中</li>
<li>反规范化的设计</li>
<li>冗余列的好处：避免表连接</li>
<li>模式1<ul>
<li>Order1(supplier_ID,part_ID,quantity,supplier_address)</li>
<li>Supplier(supplier_ID,supplier_name,supplier_address)</li>
</ul>
</li>
<li>模式2<ul>
<li>Order2(supplier_ID,part_ID,quantity)</li>
<li>Supplier(supplier_ID,supplier_name,supplier_address)</li>
</ul>
</li>
<li>冗余列可以减少复杂查询中的表连接操作</li>
<li>模式 1 有利于经常查询供应某种零件的供应商地址</li>
<li>模式 2 有利于新订单的插入</li>
</ul>
<h3 id="星形模式"><a href="#星形模式" class="headerlink" title="星形模式"></a>星形模式</h3><img src="05-2/image-20210520163507285.png" style="zoom: 67%;" />

<ul>
<li>对于每个产品而言，产品分类是有冗余的</li>
</ul>
<h3 id="雪花模式：星形模式的规范化"><a href="#雪花模式：星形模式的规范化" class="headerlink" title="雪花模式：星形模式的规范化"></a>雪花模式：星形模式的规范化</h3><ul>
<li>不是好的设计</li>
<li>虽然没有冗余，但是如果需要看某个类别的销售情况，需要通过好几步才能实现，不直观，速度慢</li>
</ul>
<img src="05-2/image-20210520163631550.png" style="zoom:50%;" />

<h3 id="冗余与分解"><a href="#冗余与分解" class="headerlink" title="冗余与分解"></a>冗余与分解</h3><ul>
<li>分解通常使得对复杂查询的回答的效率更差，因为在查询求值期间必须执行额外的连接</li>
<li>分解使得对简单查询的回答更有效，因为这种查询通常涉及相同关系的一小部分属性</li>
<li>分解通常使得简单的更新事务更有效</li>
<li>分解能降低存储空间的要求，因为它一般能消除冗余数据</li>
<li>如果冗余级别低，则分解会增加存储的需求</li>
</ul>
<h3 id="垂直划分"><a href="#垂直划分" class="headerlink" title="垂直划分"></a>垂直划分</h3><ul>
<li>将经常同时访问的属性放在同一个表里</li>
<li>对每个查询，我们统计不同属性之间被同时访问的次数</li>
<li><strong>事务-属性交叉矩阵</strong></li>
</ul>
<p><img src="/05-2/image-20210520164000533.png"></p>
<ul>
<li>统计结果</li>
<li><strong>属性关联矩阵</strong></li>
</ul>
<p><img src="/05-2/image-20210520164045282.png"></p>
<ul>
<li><strong>属性带权关联图</strong></li>
</ul>
<img src="05-2/image-20210520164113081.png" style="zoom:50%;" />

<ul>
<li><strong>图分割</strong></li>
</ul>
<img src="05-2/image-20210520164130508.png" style="zoom:67%;" />
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/19/DB/CLJ/05-2/" data-id="cl9lj74aw00fl64tzeg4s2usa" data-title="数据库概论.陈立军.05.关系规范化(3)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/CLJ/05-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/14/DB/CLJ/05-1/" class="article-date">
  <time class="dt-published" datetime="2021-05-14T06:14:42.000Z" itemprop="datePublished">2021-05-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/14/DB/CLJ/05-1/">数据库概论.陈立军.05.关系规范化(2)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="关系规范化"><a href="#关系规范化" class="headerlink" title="关系规范化"></a>关系规范化</h1><ul>
<li>如何判断关系模式的范式级别？<ul>
<li>看看其他属性有无对候选码的不良依赖</li>
</ul>
</li>
<li>如何求关系模式的候选码？</li>
<li>一般化这个问题<ul>
<li>给定一组函数依赖，是否能导出另外一些函数依赖，或另外的函数依赖是否成立？</li>
</ul>
</li>
</ul>
<h2 id="逻辑蕴涵"><a href="#逻辑蕴涵" class="headerlink" title="逻辑蕴涵"></a>逻辑蕴涵</h2><h3 id="逻辑蕴含定义"><a href="#逻辑蕴含定义" class="headerlink" title="逻辑蕴含定义"></a>逻辑蕴含定义</h3><ul>
<li>关系模式 $R(U,F)$ ，$F$ 是其函数依赖集，$X,Y\subseteq U$，如果从 $F$ 的函数依赖能够推出 $X\to Y$，则称 $F$ <span style="color:red;font-weight:bold">逻辑蕴涵</span> $X\to Y$ ,记作 $F\vdash X\to Y$</li>
<li>直观上的理解，$X\to Y$ 能通过 $F$ 的函数依赖推导出来</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li>被 $F$ 所逻辑蕴涵的函数依赖的全体所构成的集合称作 $F$ 的<span style="color:red;font-weight:bold">闭包</span>，记作 $F^+&#x3D;\left{X\to Y|F\vdash X\to Y\right}$</li>
<li><span id="ex1">一个例子</span></li>
</ul>
<p>$$<br>R(X,Y),F&#x3D;{X\to Y}<br>$$</p>
<p>$$<br>\begin{aligned}<br>F^+&#x3D;&amp;{\<br>&amp;X\to\Phi,X\to X,X\to Y,X\to XY\<br>&amp;Y\to\Phi,Y\to Y\<br>&amp;XY\to\Phi,XY\to X,XY\to Y,XY\to XY\<br>&amp;}<br>\end{aligned}<br>$$</p>
<ul>
<li>规模是指数级的</li>
</ul>
<h2 id="Armstrong-公理系统"><a href="#Armstrong-公理系统" class="headerlink" title="Armstrong 公理系统"></a>Armstrong 公理系统</h2><ul>
<li><strong>自反律（reflexivity）</strong><ul>
<li>若 $Y\subseteq X$ ，则 $X\to Y$</li>
</ul>
</li>
<li><strong>增广律（augmentation）</strong><ul>
<li>若 $X\to Y$，则 $XZ\to YZ$</li>
</ul>
</li>
<li><strong>传递律（transitivity）</strong><ul>
<li>若 $X\to Y,Y\to Z$ 则 $X\to Z$</li>
</ul>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>上面的<a href="#ex1">例子</a></li>
<li>$X\to XY$：增广律<ul>
<li>$X\to Y\Rightarrow XX\to XY\Leftrightarrow X\to XY$</li>
</ul>
</li>
</ul>
<h3 id="正确性及完备性"><a href="#正确性及完备性" class="headerlink" title="正确性及完备性"></a>正确性及完备性</h3><ul>
<li>$A&#x3D;{;f;|;用;\mathrm{Armstrong};公理从;F;中导出的函数依赖;f;}$</li>
<li>$B&#x3D;{;f;|;被;F;所逻辑蕴涵的函数依赖;f;}$</li>
<li><strong>完备性</strong><ul>
<li>$B\subseteq A$</li>
<li>$F$ 所蕴涵的函数依赖都能用 Armstrong 公理从 $F$ 中导出</li>
</ul>
</li>
<li><strong>正确性</strong><ul>
<li>$A\subseteq B$</li>
<li>用 Armstrong 公理从 $F$ 中导出的函数依赖必为 $F$ 所蕴涵</li>
</ul>
</li>
</ul>
<h3 id="Armstrong-公理正确性证明"><a href="#Armstrong-公理正确性证明" class="headerlink" title="Armstrong 公理正确性证明"></a>Armstrong 公理正确性证明</h3><h4 id="自反律"><a href="#自反律" class="headerlink" title="自反律"></a>自反律</h4><ul>
<li>设 $r$ 是 $R&lt;U, F&gt;$上的任一关系，$t,s\in r$</li>
</ul>
<p>$$<br>\begin{aligned}<br>&amp;t[X]&#x3D;s[X],Y\subseteq X\<br>\Rightarrow;&amp;t[Y]&#x3D;s[Y]\<br>\Rightarrow;&amp;X\to Y\<br>\end{aligned}<br>$$</p>
<ul>
<li>函数依赖 $X\to Y$ 的定义<ul>
<li>$t[X]&#x3D;s[X]\Rightarrow t[Y]&#x3D;s[Y]$</li>
</ul>
</li>
</ul>
<h4 id="增广律"><a href="#增广律" class="headerlink" title="增广律"></a>增广律</h4><p>$$<br>\begin{aligned}<br>&amp;t[XZ]&#x3D;s[XZ],X\to Y\<br>&amp;\<br>&amp;t[XZ]&#x3D;s[XZ],X\to Y\<br>\Rightarrow;&amp;t[X]&#x3D;s[X]\<br>\Rightarrow;&amp;t[Y]&#x3D;s[Y]\<br>&amp;\<br>&amp;t[XZ]&#x3D;s[XZ]\<br>\Rightarrow;&amp;t[Z]&#x3D;s[Z]\<br>&amp;\<br>&amp;t[Z]&#x3D;s[Z],t[Y]&#x3D;s[Y]\<br>\Rightarrow;&amp;t[YZ]&#x3D;s[YZ]\<br>\Rightarrow;&amp;XZ\to YZ\<br>\end{aligned}<br>$$</p>
<h4 id="传递律"><a href="#传递律" class="headerlink" title="传递律"></a>传递律</h4><p>$$<br>\begin{aligned}<br>&amp;t[X]&#x3D;s[X],X\to Y,Y\to Z\<br>&amp;\<br>&amp;t[X]&#x3D;s[X],X\to Y\<br>\Rightarrow;&amp;t[Y]&#x3D;s[Y]\<br>&amp;\<br>&amp;t[Y]&#x3D;s[Y],Y\to Z\<br>\Rightarrow;&amp;t[Z]&#x3D;s[Z]\<br>\Rightarrow;&amp;X\to Z\<br>\end{aligned}<br>$$</p>
<h3 id="导出的其他定理"><a href="#导出的其他定理" class="headerlink" title="导出的其他定理"></a>导出的其他定理</h3><ul>
<li>合并律（union rule）<ul>
<li>若 $X\to Y,X\to Z$ ,则 $X\to YZ$</li>
</ul>
</li>
<li>分解律（decomposition rule）<ul>
<li>若 $X\to YZ$ ,则 $X\to Y,X\to Z$</li>
</ul>
</li>
<li>伪传递律（pseudotransitivity rule）<ul>
<li>若 $X\to Y,WY\to Z$ 则 $WX\to Z$</li>
</ul>
</li>
</ul>
<h4 id="合并律"><a href="#合并律" class="headerlink" title="合并律"></a>合并律</h4><p>$$<br>\begin{aligned}<br>&amp;X\to Y,Y\to Z\<br>&amp;\<br>&amp;X\to Y\<br>\Rightarrow;&amp;X\to XY\<br>&amp;\<br>&amp;X\to Z\<br>\Rightarrow;&amp;XY\to YZ\<br>&amp;\<br>&amp;X\to XY,XY\to YZ\<br>\Rightarrow;&amp;X\to YZ\<br>\end{aligned}<br>$$</p>
<h4 id="分解律"><a href="#分解律" class="headerlink" title="分解律"></a>分解律</h4><p>$$<br>\begin{aligned}<br>&amp;X\to YZ\<br>&amp;\<br>&amp;Z\subseteq YZ\<br>\Rightarrow;&amp;YZ\to Z\<br>&amp;\<br>&amp;X\to YZ,YZ\to Z\<br>\Rightarrow;&amp;X\to Z\<br>&amp;\<br>&amp;同理,X\to Y\<br>\end{aligned}<br>$$</p>
<h4 id="伪传递律"><a href="#伪传递律" class="headerlink" title="伪传递律"></a>伪传递律</h4><p>$$<br>\begin{aligned}<br>&amp;X\to Y,WY\to Z\<br>&amp;\<br>&amp;X\to Y\<br>\Rightarrow;&amp;XW\to WY\<br>&amp;\<br>&amp;XW\to WY,WY\to Z\<br>\Rightarrow;&amp;XW\to Z\<br>\end{aligned}<br>$$</p>
<h3 id="公理应用示例"><a href="#公理应用示例" class="headerlink" title="公理应用示例"></a>公理应用示例</h3><ul>
<li>已知<ul>
<li>$R&lt; U, F &gt;$</li>
<li>$U &#x3D; (A, B, C, G, H, I)$</li>
<li>$F &#x3D; {A\to B, A\to C, CG\to H, CG\to I, B→H}$</li>
</ul>
</li>
<li>问如下函数依赖是否成立<ul>
<li>$A\to H$ <span style="color:red;font-weight:bold">成立</span></li>
<li>$CG\to HI$ <span style="color:red;font-weight:bold">成立</span></li>
<li>$AG\to I$ <span style="color:red;font-weight:bold">成立</span></li>
</ul>
</li>
</ul>
<h3 id="属性集的闭包"><a href="#属性集的闭包" class="headerlink" title="属性集的闭包"></a>属性集的闭包</h3><ul>
<li>将之前的一个<strong>证明</strong>的问题转化为<strong>计算</strong>的一个问题</li>
</ul>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>设 $F$ 为属性集 $U$ 上的一组函数依赖，$X\subseteq U$</li>
<li>$X_F^+&#x3D;{A|X\to A;能由;F;根据;\mathrm{Armstrong};公理导出}$</li>
<li>称 $X_F^+$ 为属性集 $X$ 关于函数依赖集 $F$ 的闭包</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>$U&#x3D;{A,B,C}$</li>
<li>$F&#x3D;{A\to B,B\to C}$</li>
<li>则属性集的闭包如下<ul>
<li>$A_F^+&#x3D;ABC$</li>
<li>$B_F^+&#x3D;BC$</li>
<li>$C_F^+&#x3D;C$</li>
</ul>
</li>
</ul>
<h3 id="求解属性集闭包的通用算法"><a href="#求解属性集闭包的通用算法" class="headerlink" title="求解属性集闭包的通用算法"></a>求解属性集闭包的通用算法</h3><ul>
<li>输入：$X, F$</li>
<li>输出：$X_F^+$</li>
<li>初始化为本身：$X_F^+:&#x3D;X$</li>
</ul>
<p>$$<br>\begin{aligned}<br>&amp;\mathrm{while};(X_F^+发生变化);\mathrm{do}\<br>&amp;\quad \mathrm{for;each};函数依赖;A\to B;\mathrm{in};\mathrm{do}\<br>&amp;\qquad \mathrm{begin}\<br>&amp;\qquad \quad \mathrm{if};A\subseteq X_F^+;\mathrm{then};X_F^+:&#x3D;X_F^+\cup B\<br>&amp;\qquad \mathrm{end}\<br>\end{aligned}<br>$$</p>
<h4 id="算法正确性"><a href="#算法正确性" class="headerlink" title="算法正确性"></a>算法正确性</h4><p>$$<br>\begin{aligned}<br>&amp;A\subseteq X_F^+\Rightarrow X\to A\<br>&amp;X\to A,A\to B\Rightarrow X\to B\<br>\end{aligned}<br>$$</p>
<h4 id="算法会终止"><a href="#算法会终止" class="headerlink" title="算法会终止"></a>算法会终止</h4><ul>
<li>最多 $|U-X|$ 步</li>
</ul>
<h4 id="算法示例"><a href="#算法示例" class="headerlink" title="算法示例"></a>算法示例</h4><ul>
<li><p>$U &#x3D; (A, B, C, G, H, I)$</p>
</li>
<li><p>$F &#x3D; {A\to B, A\to C, CG\to H, CG\to I, B\to H}$</p>
</li>
<li><p>计算 $(AG)_F^+$</p>
</li>
<li><p>算法流程</p>
<ul>
<li>$(AG)_F^+&#x3D;AG$</li>
<li>$(AG)_F^+&#x3D;ABCGHI$</li>
</ul>
</li>
<li><p>算法效率并不是很高</p>
<ul>
<li><strong>提高效率可以将函数依赖进行排列</strong></li>
</ul>
</li>
</ul>
<h3 id="闭包的封闭性"><a href="#闭包的封闭性" class="headerlink" title="闭包的封闭性"></a>闭包的封闭性</h3><ul>
<li>$(X^+)^+&#x3D;X^+$</li>
</ul>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><ul>
<li>证明他们互相包含</li>
<li>$(X^+)^+\supseteq X^+$ 显然</li>
<li>$(X^+)^+\subseteq X^+$<ul>
<li>$\forall A\in(X^+)^+\Rightarrow X^+\to A$</li>
<li>$X^+\to A,X\to X^+\Rightarrow X\to A\Rightarrow A\in X^+$</li>
<li>由任意性，$(X^+)^+\subseteq X^+$</li>
</ul>
</li>
</ul>
<h4 id="封闭的"><a href="#封闭的" class="headerlink" title="封闭的"></a>封闭的</h4><ul>
<li>如果 $X^+&#x3D;X$，则称 $X$ 是<strong>封闭</strong>的</li>
</ul>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><ul>
<li>$R(ABCD)$ 的封闭属性集只有 $\Phi$ 和 ${ABCD}$，求 $R$ 的函数依赖集<ul>
<li>每一个码都是候选码</li>
<li>$A\to B,B\to C,C\to D, D\to A$</li>
</ul>
</li>
<li>$R(ABCD)$ 的封闭属性集只有 $\Phi,{AB},{ABCD}$，求 $R$ 的函数依赖集<ul>
<li>$A\to B,B\to A,C\to D,D\to C,C\to A$</li>
</ul>
</li>
</ul>
<h3 id="闭包与函数依赖证明之间的关系"><a href="#闭包与函数依赖证明之间的关系" class="headerlink" title="闭包与函数依赖证明之间的关系"></a>闭包与函数依赖证明之间的关系</h3><ul>
<li>有没有一般性的算法判定 $X\to Y$ 是否能由 $F$ 根据 Armstrong 公理导出？</li>
<li>如果计算出 $F^+$，再判断 $X\to Y$ 是否属于 $F^+$，则由于 $F^+$ 的计算非常复杂，实际上是不可行的</li>
<li>通过属性集的闭包计算<ul>
<li>$X\to Y$ 能由 Armstrong 公理导出 $\Leftrightarrow$  $Y\subseteq X_F^+$</li>
</ul>
</li>
<li><strong>从几何证明到代数计算</strong></li>
</ul>
<h3 id="Armstrong-公理完备性证明"><a href="#Armstrong-公理完备性证明" class="headerlink" title="Armstrong 公理完备性证明"></a>Armstrong 公理完备性证明</h3><ul>
<li><strong>反证法</strong></li>
<li>假定存在函数依赖 $X\to Y$ 被 $F$ 逻辑蕴涵，但 $X\to Y$ 不能用 Armstrong 公理从 $F$ 中导出，则存在 $Y$ 的子集不属于 $X$ 的闭包，也即：$Y\not\subseteq X_F^+,Y-X^+_F\ne\Phi,U-X_F^+\ne\Phi$</li>
<li>构造 $R(U)$ 上的关系 $r$ 如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">$r$</th>
<th align="center">$X_F^+$</th>
<th align="center">$U-X_F^+$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$t$</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">$s$</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<ul>
<li>下面证明，由于 (1)(2) 本身是矛盾的，推出假设不成立<ul>
<li>(1) $r$ 满足 $F$</li>
<li>(2) $r$ 不满足 $X\to Y$</li>
</ul>
</li>
<li>$r$ 满足 $F$<ul>
<li>设 $W\to V$ 是 $F$ 的任意一个函数依赖，由下述推导得到 $r$ 满足 $W\to V$（$t[W]&#x3D;s[W]\Rightarrow t[V]&#x3D;s[V]$）</li>
<li>即 $r$ 是 $R(U,F)$ 上的关系</li>
</ul>
</li>
</ul>
<p>$$<br>\begin{aligned}<br>t[W]&#x3D;s[W]&amp;\Rightarrow W\subseteq X_F^+(构造决定,看关系;r)\<br>&amp;\Rightarrow X\to W\<br>X\to W,W\to V&amp;\Rightarrow X\to V\<br>&amp;\Rightarrow V\subseteq X_F^+\<br>&amp;\Rightarrow t[V]&#x3D;s[V]\<br>\end{aligned}<br>$$</p>
<ul>
<li>$r$ 不满足 $X\to Y$<ul>
<li>$Y-X^+_F\ne\Phi$</li>
<li>故 $Y$ 中存在一个属性 $A\notin X_F^+$</li>
<li>在 $r$ 中有 $t[X]&#x3D;s[X]$ ，而 $t[A]≠s[A]$</li>
<li>所以 $t[Y]\ne s[Y]$，即 $X\to Y$ 不成立</li>
</ul>
</li>
</ul>
<h2 id="候选码的计算"><a href="#候选码的计算" class="headerlink" title="候选码的计算"></a>候选码的计算</h2><ul>
<li>NP 的</li>
<li>我们期望通过一些约束条件，限制搜索范围</li>
</ul>
<h3 id="属性集的派性"><a href="#属性集的派性" class="headerlink" title="属性集的派性"></a>属性集的派性</h3><ul>
<li><strong>左部属性</strong>，<strong>只</strong>出现在 $F$ 左边的属性</li>
<li><strong>右部属性</strong>，<strong>只</strong>出现在 $F$ 右边的属性</li>
<li><strong>双部属性</strong>，出现在 $F$ 两边的属性</li>
<li><strong>外部属性</strong>，不出现在 $F$ 中的属性</li>
</ul>
<h4 id="不同派性的性质"><a href="#不同派性的性质" class="headerlink" title="不同派性的性质"></a>不同派性的性质</h4><ul>
<li><strong>左部属性</strong>一定<strong>出现</strong>在任何候选码中</li>
<li><strong>右部属性</strong>一定<strong>不出现</strong>在任何候选码中</li>
<li><strong>外部属性</strong>一定<strong>出现</strong>在任何候选码中</li>
</ul>
<h4 id="做题的-trick"><a href="#做题的-trick" class="headerlink" title="做题的 trick"></a>做题的 trick</h4><ul>
<li>出现在左边的属性加上划线，出现在右边的属性加下划线</li>
</ul>
<h3 id="候选码的计算-1"><a href="#候选码的计算-1" class="headerlink" title="候选码的计算"></a>候选码的计算</h3><ul>
<li>先求出左部属性和外部属性，再求属性集闭包</li>
<li>如果闭包已经是属性集全集，说明左部属性已经是候选码（<strong>唯一的候选码</strong>）</li>
<li>否则则需要和双部属性组合</li>
</ul>
<h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><ul>
<li>$U&#x3D;{C,T,H,R,S}$</li>
<li>$F&#x3D;{C\to T,HR\to C,HT\to R,HS\to R}$</li>
<li>左部属性+外部属性：$HS$</li>
<li>$(HS)_F^+&#x3D;HSRCT$</li>
<li>候选码唯一：$HS$</li>
<li>主属性 $HS$，非主属性 $CTR$</li>
<li>是 $2NF$：没有部分依赖（求出 $H_F^+,S_F^+$）</li>
<li>不是 $3NF$：$HS\to C,C\to T$</li>
</ul>
<h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><ul>
<li>$U &#x3D; {A，B，C，D，E}$</li>
<li>$F &#x3D; {AE\to C,AC\to D,CD\to B,D\to E}$</li>
<li>左部属性+外部属性：$A$</li>
<li>双部属性：$C,E,D$</li>
<li>$A_F^+&#x3D;A$ 不是候选码</li>
<li>和双部属性组合<ul>
<li>$(AC)_F^+&#x3D;ACDBE$  是候选码</li>
<li>$(AD)_F^+&#x3D;ADECB$  是候选码</li>
<li>$(AE)_F^+&#x3D;AECDB$  是候选码</li>
</ul>
</li>
<li>主属性 $ACDE$，非主属性 $B$</li>
<li>是 $2NF$</li>
<li>不是 $3NF$<ul>
<li>$AC\to CD, CD\to B$</li>
</ul>
</li>
</ul>
<h3 id="求一个候选码的一般算法"><a href="#求一个候选码的一般算法" class="headerlink" title="求一个候选码的一般算法"></a>求<span style="color:red;font-weight:bold">一个</span>候选码的一般算法</h3><ul>
<li>输入：关系模式 $&lt;U, F&gt;$</li>
<li>输出：一个候选码 $K$</li>
<li>思路：每次删除一个属性，看它的闭包是否还是整个属性集</li>
</ul>
<p>$$<br>\begin{aligned}<br>&amp;\mathrm{Key-Finding}(U, F)\<br>&amp;\mathrm{Begin}\<br>&amp;\quad(1);K:&#x3D; U\<br>&amp;\quad(2);构造一个;FD: K\to T,其中;T\notin U\<br>&amp;\quad(3);\mathrm{for};每一个属性;A\in K;\mathrm{do}\<br>&amp;\quad\qquad\mathrm{if;Membership}(F\cup{K\to T},(K-A)\to T)\<br>&amp;\quad\qquad\mathrm{then};K:&#x3D; K-A\<br>&amp;\quad\mathrm{return}(K)\<br>&amp;\mathrm{end}\<br>\end{aligned}<br>$$</p>
<ul>
<li>$\mathrm{Membership}(F, X\to Y)$： 判断 $X\to Y \in F^+$</li>
<li>上面算法为什么要这么构造？<ul>
<li>$K-A$ 是候选码 $\Leftrightarrow$ $(K-A)_F^+&#x3D;U$ $\Leftrightarrow$ $(K-A)\to K \in F^+$</li>
</ul>
</li>
</ul>
<h3 id="求全部候选码的算法：替换法"><a href="#求全部候选码的算法：替换法" class="headerlink" title="求全部候选码的算法：替换法"></a>求全部候选码的算法：替换法</h3><ul>
<li>输入：关系模式 $R&lt;U，F&gt;$</li>
<li>输出：$R&lt;U，F&gt;$ 的全部候选码 $W$</li>
<li>思路<ul>
<li>先找到一个候选码，这个候选码包括左部属性和双部属性（不考虑外部属性，考虑的话将其当作左部属性即可）</li>
<li>用其他的双部属性替代候选码中得到双部属性</li>
</ul>
</li>
</ul>
<p>$$<br>\begin{aligned}<br>&amp;\mathrm{begin}\<br>&amp;(1);K:&#x3D;\mathrm{Key-Finding}(U,F)\<br>&amp;(2);K;入队列;Q\<br>&amp;(3);\mathrm{while};队列;Q\ne\Phi;\mathrm{do}\<br>&amp;\qquad\quad K:&#x3D;队列;Q;的头\<br>&amp;\qquad\quad W:&#x3D;W\cup{K}\<br>&amp;\qquad\quad D:&#x3D;K;中全部双部属性\<br>&amp;\qquad\quad\mathrm{while};D\ne\Phi;\mathrm{do}\<br>&amp;\qquad\qquad A:&#x3D;D;中一个双部属性\<br>&amp;\qquad\qquad D:&#x3D;D-{A}\<br>&amp;\qquad\qquad\mathrm{for};每一个;X\to Y\in F;\mathrm{do}\<br>&amp;\qquad\qquad\quad \mathrm{if};A\in Y;\mathrm{then};K’:&#x3D;(K-A)\cup{X}\<br>&amp;\qquad\qquad\quad\mathrm{if};K’\notin Q;\mathrm{then};K’;入队列;Q\<br>&amp;\mathrm{end}\<br>\end{aligned}<br>$$</p>
<h3 id="求全部候选码的算法示例"><a href="#求全部候选码的算法示例" class="headerlink" title="求全部候选码的算法示例"></a>求全部候选码的算法示例</h3><ul>
<li>$U&#x3D;{A, B, C, D, E, G}$</li>
<li>$F&#x3D;{AB\to C, C\to A, C\to B, AD\to B, BE\to G, G\to A}$</li>
<li>所有候选码 &#x3D; ${EDC, EDA, EDG, EDB}$</li>
</ul>
<h2 id="函数依赖集的等价性"><a href="#函数依赖集的等价性" class="headerlink" title="函数依赖集的等价性"></a>函数依赖集的等价性</h2><ul>
<li>目的：利用等价性找到一个简化的函数依赖集</li>
<li>函数依赖越少，检查起来越简单</li>
</ul>
<h3 id="等价性的定义-闭包相同"><a href="#等价性的定义-闭包相同" class="headerlink" title="等价性的定义(闭包相同)"></a>等价性的定义(闭包相同)</h3><ul>
<li>对于函数依赖集 $F,G$ ,若 $F^+&#x3D;G^+$，则称 $F$ 与 $G$ 等价</li>
</ul>
<h3 id="如何判定两个函数依赖集等价"><a href="#如何判定两个函数依赖集等价" class="headerlink" title="如何判定两个函数依赖集等价"></a>如何判定两个函数依赖集等价</h3><ul>
<li>$F^+&#x3D;G^+\Leftrightarrow F\subseteq G^+,G\subseteq F^+$</li>
<li>证明起来还是挺复杂的</li>
</ul>
<h3 id="函数依赖集的最小覆盖"><a href="#函数依赖集的最小覆盖" class="headerlink" title="函数依赖集的最小覆盖"></a>函数依赖集的最小覆盖</h3><ul>
<li>函数依赖集 $F$ 的最小覆盖 $F_{min}$</li>
<li><strong>单属性化</strong>：对于 $F$ 中任一函数依赖 $X\to A$,  $A$ 必是单属性</li>
<li><strong>无冗余化</strong>：$F$ 中不存在这样的函数依赖 $X\to A$，使得 $F$ 与 $F−{X\to A}$ 等价</li>
<li><strong>既约化</strong>：$F$ 中不存在这样的函数依赖 $X\to A$, 在 $X$ 中有真子集 $Z$, 使得 $F$ 与 $(F−{X\to A})\cup{Z\to A}$ 等价<ul>
<li>消除冗余属性</li>
</ul>
</li>
</ul>
<h3 id="求解函数依赖集的最小覆盖"><a href="#求解函数依赖集的最小覆盖" class="headerlink" title="求解函数依赖集的最小覆盖"></a>求解函数依赖集的最小覆盖</h3><h4 id="单属性化"><a href="#单属性化" class="headerlink" title="单属性化"></a>单属性化</h4><ul>
<li>逐个检查 $F$ 中各函数依赖 $F_i:X\to Y$</li>
<li>若 $Y&#x3D;A_1A_2\cdots A_k,k\ge2$，则用诸 $X\to A_i$ 代替 $Y$</li>
</ul>
<h4 id="无冗余化"><a href="#无冗余化" class="headerlink" title="无冗余化"></a>无冗余化</h4><ul>
<li>逐个检查 $F$ 中各函数依赖 $X\to A$</li>
<li>令 $G&#x3D;F-{X\to A}$，若 $A\in X_G^+$，则从 $F$ 中去掉该函数依赖</li>
</ul>
<h4 id="既约化"><a href="#既约化" class="headerlink" title="既约化"></a>既约化</h4><ul>
<li>逐个检查 $F$ 中各函数依赖 $X\to A$</li>
<li>设 $X&#x3D;B_1\cdots B_m$，逐个考查 $B_i$</li>
<li>若 $A\in(X-B_i)_F^+$，则以 $X−B_i$ 取代 $X$</li>
</ul>
<h3 id="求最小覆盖例子"><a href="#求最小覆盖例子" class="headerlink" title="求最小覆盖例子"></a>求最小覆盖例子</h3><h4 id="无冗余化-1"><a href="#无冗余化-1" class="headerlink" title="无冗余化"></a>无冗余化</h4><ul>
<li>$F&#x3D;{A\to B,B\to A,A\to C,B\to C}$，求 $F_{min}$</li>
<li>$F_{min}&#x3D;{A\to B,B\to A,A\to C}$</li>
<li>$F_{min}&#x3D;{A\to B,B\to A,B\to C}$</li>
</ul>
<h4 id="既约化-1"><a href="#既约化-1" class="headerlink" title="既约化"></a>既约化</h4><ul>
<li>$F&#x3D;{C\to A,A\to G ,CG\to B,B\to A}$，求 $F_{min}$</li>
<li>$F$ 是无冗余的</li>
<li>$F_{min}&#x3D;{C\to A,A\to G ,C\to B,B\to A}$<ul>
<li>还得进一步无冗余化</li>
<li>$F_{min}&#x3D;{A\to G ,C\to B,B\to A}$</li>
</ul>
</li>
</ul>
<h4 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h4><ul>
<li>先既约化，再无冗余化</li>
</ul>
<h2 id="函数依赖和多值依赖的推理规则"><a href="#函数依赖和多值依赖的推理规则" class="headerlink" title="函数依赖和多值依赖的推理规则"></a>函数依赖和多值依赖的推理规则</h2><img src="05-1/image-20210514222913294.png" style="zoom:50%;" />

<h3 id="联合律的证明"><a href="#联合律的证明" class="headerlink" title="联合律的证明"></a>联合律的证明</h3><img src="05-1/image-20210514223139159.png" style="zoom:50%;" />

<ul>
<li>填表的方式证明</li>
</ul>
<img src="05-1/image-20210514224014953.png" style="zoom:50%;" />
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/14/DB/CLJ/05-1/" data-id="cl9lj74av00fd64tzhs5fa5jk" data-title="数据库概论.陈立军.05.关系规范化(2)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OS/xv6-labs/lab2-pagetable" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/13/OS/xv6-labs/lab2-pagetable/" class="article-date">
  <time class="dt-published" datetime="2021-05-13T04:00:00.000Z" itemprop="datePublished">2021-05-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OS-xv6-labs/">OS.xv6-labs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/13/OS/xv6-labs/lab2-pagetable/">xv6-labs-2020.lab2.pagetable</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="lab2-pagetable"><a href="#lab2-pagetable" class="headerlink" title="lab2 pagetable"></a>lab2 pagetable</h1><h2 id="1-作业链接"><a href="#1-作业链接" class="headerlink" title="1.作业链接"></a>1.作业链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html">https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html</a></li>
</ul>
<h2 id="2-实习内容"><a href="#2-实习内容" class="headerlink" title="2. 实习内容"></a>2. 实习内容</h2><h3 id="2-1-vmprint"><a href="#2-1-vmprint" class="headerlink" title="2.1 vmprint()"></a>2.1 vmprint()</h3><ul>
<li>实现一个函数 <code>vmprint(pagetable_t)</code>，实现输出页表的功能</li>
<li>输出格式如下<ul>
<li>第一行为输入的参数</li>
<li>接着输出 <code>valid</code> 的 <code>PTE</code> 以及指向的 <code>pa</code>（物理地址）</li>
</ul>
</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">page table 0x0000000087f6e000</span><br><span class="line">..0: pte 0x0000000021fda801 pa 0x0000000087f6a000</span><br><span class="line">.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000</span><br><span class="line">.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000</span><br><span class="line">.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000</span><br><span class="line">.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000</span><br><span class="line">..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000</span><br><span class="line">.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000</span><br><span class="line">.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000</span><br><span class="line">.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br></pre></td></tr></table></figure>



<h4 id="1-一些提示"><a href="#1-一些提示" class="headerlink" title="(1) 一些提示"></a>(1) 一些提示</h4><ul>
<li>可以在 <code>kernel/vm.c</code> 中实现 <code>vmprint()</code></li>
<li>使用在文件 <code> kernel/riscv.h.</code> 结尾定义的宏</li>
<li>参考 <code>freewalk()</code> 的实现</li>
<li>在 <code>kernel/defs.h</code> 中声明 <code>vmprint()</code></li>
<li>使用 <code>%p</code> 输出地址</li>
</ul>
<h4 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="(2) 准备工作"></a>(2) 准备工作</h4><ul>
<li>声明函数原型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"><span class="comment">// vm.c</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span>)</span>;</span><br><span class="line"><span class="comment">// 为了方便实现, 定义的辅助函数</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">vmprint_help</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>插入测试代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// kernel/exec.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pid==<span class="number">1</span>) vmprint(p-&gt;pagetable); <span class="comment">// Code Added</span></span><br><span class="line">    <span class="keyword">return</span> argc;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-实现"><a href="#3-实现" class="headerlink" title="(3) 实现"></a>(3) 实现</h4><ul>
<li>在 <code>vm.c</code> 中实现代码</li>
<li>实现上比较简单，只需要逐级输出即可</li>
<li>模仿 <code>freewalk()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span>* pgtbl_level[] = &#123;</span><br><span class="line">    <span class="string">&quot;..&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.. ..&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.. .. ..&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">    vmprint_help(pagetable, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint_help</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">        <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">        <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">            <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">            uint64 child = PTE2PA(pte);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s%d: pte %p pa %p\n&quot;</span>, pgtbl_level[level], i, pte, child);</span><br><span class="line">            <span class="keyword">if</span>(level != <span class="number">2</span>) &#123;</span><br><span class="line">                vmprint_help((<span class="type">pagetable_t</span>)child, level + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-回答问题"><a href="#4-回答问题" class="headerlink" title="(4) 回答问题"></a>(4) 回答问题</h4><blockquote>
<p>Explain the output of vmprint in terms of Fig 3-4 from the text.</p>
<p>What does page 0 contain?</p>
<p>What is in page 2?</p>
<p>When running in user mode, could the process read&#x2F;write the memory mapped by page 1?</p>
</blockquote>
<ul>
<li>xv6 的 3 级页表如下所示</li>
</ul>
<img src="lab2-pagetable/image-20210512193655832.png" style="zoom:67%;" />

<ul>
<li>page 0 中保存的是第 2 级页表的起始地址，以及权限位</li>
<li>page 2 中保存的是实际物理地址的页号，以及权限位</li>
<li>用户态下访问不到这里 page 1映射的地址空间，因为用户态和内核态使用的不是同一个页表，翻译得到的物理地址不同</li>
</ul>
<h3 id="2-2-a-kernel-page-table-per-process"><a href="#2-2-a-kernel-page-table-per-process" class="headerlink" title="2.2 a kernel page table per process"></a>2.2 a kernel page table per process</h3><ul>
<li>xv6 实现的时候<ul>
<li>所有的进程共享一个内核的 pagetable，是虚拟地址直接映射物理地址实现的</li>
<li>为每一个进程维护了一个 pagetable，利虚存技术实现的，虚拟地址从 0 开始</li>
<li>这样的话，进入内核之后用户态的页表就失效了，于是如果我们在内核态下想要直接访问用户态传过来的指针，必须要先进行额外的翻译操作，而不是直接去页表中翻译</li>
</ul>
</li>
<li>这一部分实验要求每一个进程都拥有一个自己的内核页表，这个内核页表需要和当前存在的全局内核页表一致</li>
</ul>
<h4 id="1-一些提示-1"><a href="#1-一些提示-1" class="headerlink" title="(1) 一些提示"></a>(1) 一些提示</h4><ul>
<li>在数据结构 <code>struct proc</code>  中增加一个字段，为每一个进程保存它的内核页表</li>
<li>在调用 <code>allocproc()</code> 的时候，为每个进程分配一个内核页表<ul>
<li>具体的实现参照 <code>kvminit()</code></li>
</ul>
</li>
<li>确保每个进程的内核栈都在其内核页表中有映射<ul>
<li>之前是都保存在内核页表中，在 <code>procinit()</code> 中实现的</li>
<li>每一个进程应该只需要保存他自己的内核栈的映射即可</li>
</ul>
</li>
<li>当进程调度的时候，需要切换页表<ul>
<li>参考 <code>kvminithart()</code> 的实现</li>
<li>先调用  <code>w_satp()</code>，设置第 1 级页表的基地址</li>
<li>再调用 <code>sfence_vma()</code> 清空 TLB（失效了）</li>
</ul>
</li>
<li>当没有其他进程运行的时候，<code>scheduler()</code> 需要使用 <code>kernel_pagetable</code></li>
<li><code>freeproc()</code> 进程释放的时候需要同时释放页表</li>
<li>当你释放页表的时候，不能够把最后对应的物理内存也释放了，因为他们是共享的<ul>
<li>因为他们都共享原来内核的代码之类的，这些不能释放</li>
<li>内核栈也不用释放，一次分配，多次使用</li>
</ul>
</li>
<li>之前实现的 <code>vmprint()</code> 用于 <code>DEBUG</code></li>
<li>用于 <code>DEBUG</code>，缺页异常导致的结果<ul>
<li>A missing page table mapping will likely cause the kernel to encounter a page fault. It will print an error that includes <code>sepc=0x00000000XXXXXXXX</code>. You can find out where the fault occurred by searching for <code>XXXXXXXX</code> in <code>kernel/kernel.asm</code>.</li>
</ul>
</li>
</ul>
<h4 id="2-实现"><a href="#2-实现" class="headerlink" title="(2) 实现"></a>(2) 实现</h4><ul>
<li><code>struct proc</code>  增加一个保存内核页表的字段</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pagetable_t</span> pagetable_k;     <span class="comment">// Kernel page table</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>allocproc()</code> 分配页表</li>
<li>在对页表进行映射的时候，我们需要对当前进程的内核页表进行映射</li>
<li>通过修改 <code>kvmmap()</code> 为 <code>kvmmap_k()</code> 实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> etext[];  <span class="comment">// 在进行页表映射的时候需要用到</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 分配内核页表</span></span><br><span class="line">    p-&gt;pagetable_k = proc_pagetable_k(p);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pagetable_k == <span class="number">0</span>)&#123;</span><br><span class="line">        freeproc(p);</span><br><span class="line">        release(&amp;p-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">    <span class="type">pagetable_t</span> pagetable;</span><br><span class="line">    pagetable = uvmcreate();</span><br><span class="line">    <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    kvmmap_k(pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">    kvmmap_k(pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">    kvmmap_k(pagetable, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">    kvmmap_k(pagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">    kvmmap_k(pagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">    kvmmap_k(pagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">    kvmmap_k(pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">    <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvmmap_k</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap_k&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>映射内核栈</li>
<li>只需要为每个进程映射自己的内核栈，同时在 <code>procinit()</code> 不需要分配栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 分配内核页表</span></span><br><span class="line">    <span class="type">char</span> *pa = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(pa == <span class="number">0</span>)&#123;</span><br><span class="line">        freeproc(p);</span><br><span class="line">        release(&amp;p-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    uint64 va = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">    kvmmap_k(p-&gt;pagetable_k, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">    p-&gt;kstack = va;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">    initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">        initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line">        p-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    kvminithart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调度的时候切换内核页表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    w_satp(MAKE_SATP(p-&gt;pagetable_k));</span><br><span class="line">    sfence_vma();</span><br><span class="line">    swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">    kvminithart();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>freeproc()</code> 的时候<ul>
<li>首先释放栈的映射</li>
<li>释放页表，但是不能释放第 3 级页表指向的物理页</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 还得释放栈的映射(在释放整个页表之前)</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;kstack != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// dofree = 1</span></span><br><span class="line">        uvmunmap(p-&gt;pagetable_k, p-&gt;kstack, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// uint64 pa = walkaddr(p-&gt;pagetable_k, p-&gt;kstack);</span></span><br><span class="line">        <span class="comment">// kfree((void*)pa);</span></span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pagetable_k)</span><br><span class="line">        proc_freepagetable_k(p-&gt;pagetable_k);</span><br><span class="line">    p-&gt;pagetable_k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除映射, 但是不释放内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_freepagetable_k</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">    uvmunmap(pagetable, UART0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, VIRTIO0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, CLINT, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, PLIC, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, KERNBASE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, (uint64)etext, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    freewalk_k(pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freewalk_k</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">    <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">        <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">        <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">            uint64 child = PTE2PA(pte);</span><br><span class="line">            freewalk_k((<span class="type">pagetable_t</span>)child);</span><br><span class="line">            pagetable[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是允许的</span></span><br><span class="line">        <span class="comment">// &#125; else if(pte &amp; PTE_V)&#123;</span></span><br><span class="line">        <span class="comment">//   panic(&quot;freewalk: leaf&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将上面的函数加入 <code>kernel/defs.h</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">pagetable_t</span>     <span class="title function_">proc_pagetable_k</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">proc_freepagetable_k</span><span class="params">(<span class="type">pagetable_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">kvmmap_k</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">freewalk_k</span><span class="params">(<span class="type">pagetable_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行完之后报错</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: virtio_disk_intr status</span><br></pre></td></tr></table></figure>

<ul>
<li>这是由于在 <code>kvmpa()</code> 中调用 <code>walk()</code> 的时候没有使用进程对应的内核页表导致的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line">uint64 <span class="title function_">kvmpa</span><span class="params">(uint64 va)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pte = walk(kernel_pagetable, va, <span class="number">0</span>);</span><br><span class="line">    pte = walk(myproc()-&gt;pagetable_k, va, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-一些细节"><a href="#3-一些细节" class="headerlink" title="(3) 一些细节"></a>(3) 一些细节</h4><ul>
<li>以上的解法会导致一些其他问题，例如资源申请，发现不够了，此时应该 <code>kill</code> 掉这个进程，而不是 <code>panic</code></li>
<li>例如 <code>kvmmap_k()</code> 的设计，我们将 <code>panic</code> 修改为检查返回值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kvmmap_k</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, va, sz, pa, perm) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// panic(&quot;kvmmap_k&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">static</span> uint64 addr_kernel[] = &#123;</span><br><span class="line">    UART0,</span><br><span class="line">    VIRTIO0,</span><br><span class="line">    CLINT,</span><br><span class="line">    PLIC,</span><br><span class="line">    KERNBASE,</span><br><span class="line">    (uint64)etext,</span><br><span class="line">    TRAMPOLINE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_proc_freepagetable_k</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num; ++i) &#123;</span><br><span class="line">        uvmunmap(pagetable, addr_kernel[i], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">proc_pagetable_k</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">    <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// An empty page table.</span></span><br><span class="line">    pagetable = uvmcreate();</span><br><span class="line">    <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模仿 kvminit()</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    ret = kvmmap_k(pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) <span class="keyword">goto</span> bad;</span><br><span class="line">    ++num;</span><br><span class="line">    ret = kvmmap_k(pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) <span class="keyword">goto</span> bad;</span><br><span class="line">    ++num;</span><br><span class="line">    ret = kvmmap_k(pagetable, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) <span class="keyword">goto</span> bad;</span><br><span class="line">    ++num;</span><br><span class="line">    ret = kvmmap_k(pagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) <span class="keyword">goto</span> bad;</span><br><span class="line">    ++num;</span><br><span class="line">    ret = kvmmap_k(pagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) <span class="keyword">goto</span> bad;</span><br><span class="line">    ++num;</span><br><span class="line">    ret = kvmmap_k(pagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) <span class="keyword">goto</span> bad;</span><br><span class="line">    ++num;</span><br><span class="line">    ret = kvmmap_k(pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) <span class="keyword">goto</span> bad;</span><br><span class="line">    ++num;</span><br><span class="line">    <span class="keyword">return</span> pagetable;</span><br><span class="line"></span><br><span class="line">    bad:</span><br><span class="line">    check_proc_freepagetable_k(pagetable, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(kvmmap_k(p-&gt;pagetable_k, va, (uint64)pa, PGSIZE, PTE_R | PTE_W) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pa);</span><br><span class="line">        freeproc(p);</span><br><span class="line">        release(&amp;p-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;kstack = va;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-Simplify-copyin-x2F-copyinstr"><a href="#2-3-Simplify-copyin-x2F-copyinstr" class="headerlink" title="2.3 Simplify copyin&#x2F;copyinstr"></a>2.3 Simplify copyin&#x2F;copyinstr</h3><ul>
<li><code>copyin()</code> 函数在读取用户空间的虚拟地址的时候，需要先使用用户空间的页表，将其翻译成物理地址</li>
<li>我们在这里需要实现将每个进程用户空间保存的页表映射存到内核页表中，从而可以直接翻译访问</li>
</ul>
<h4 id="1-一些提示-2"><a href="#1-一些提示-2" class="headerlink" title="(1) 一些提示"></a>(1) 一些提示</h4><ul>
<li>这个机制依赖于用户空间和内核空间的虚拟地址的范围没有交集<ul>
<li>于是我们需要让用户空间的地址增长小于最小的内核虚拟地址</li>
<li>xv6 启动正常工作之后的最低地址 PLIC（0C000000）</li>
<li>需要让用户空间的地址增长小于 PLIC</li>
<li>为什么不是 CLINT 呢？CLINT 都是在 M-Mode 中映射的</li>
</ul>
</li>
<li>先实现 <code>copyin()</code>，在 <code>copyin()</code> 中调用 <code>copyin_new()</code>，之后再去实现 <code>copyinstr_new()</code></li>
<li>每次对用户页表进行修改的时候，同时修改内核页表<ul>
<li><code>fork()</code>, <code>exec()</code>, <code>sbrk()</code></li>
</ul>
</li>
<li>不要忽略第一个用户进程，<code>usertint()</code> 中也需要将用户页表的映射加入到内核页表中</li>
<li>权限设置：A page with <code>PTE_U</code> set cannot be accessed in kernel mode.</li>
</ul>
<h4 id="2-实现-1"><a href="#2-实现-1" class="headerlink" title="(2) 实现"></a>(2) 实现</h4><h5 id="1-CLINT"><a href="#1-CLINT" class="headerlink" title="[1] CLINT"></a>[1] CLINT</h5><ul>
<li>去掉内核页表对于 <code>CLINT</code> 的映射，注释掉即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">static</span> uint64 addr_kernel[] = &#123;</span><br><span class="line">    UART0,</span><br><span class="line">    VIRTIO0,</span><br><span class="line">    <span class="comment">// CLINT,</span></span><br><span class="line">    PLIC,</span><br><span class="line">    KERNBASE,</span><br><span class="line">    (uint64)etext,</span><br><span class="line">    TRAMPOLINE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">proc_pagetable_k</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// ret = kvmmap_k(pagetable, CLINT, CLINT, 0x10000, PTE_R | PTE_W);</span></span><br><span class="line">    <span class="comment">// if(ret != 0) goto bad;</span></span><br><span class="line">    <span class="comment">// ++num;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用户虚拟地址的增长不能超过 <code>PLIC</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sz + n &gt;= PLIC) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-内核页表"><a href="#2-内核页表" class="headerlink" title="[2] 内核页表"></a>[2] 内核页表</h5><ul>
<li>在修改用户页表的同时修改内核页表，设置权限</li>
<li>注意在释放内核页表的时候，都不能释放物理页</li>
<li>找到 <code>uvmalloc()</code> 函数修改页表的地方</li>
<li>构造一个复制函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernek/defs.h</span></span><br><span class="line"><span class="comment">// vm.c</span></span><br><span class="line">uint64          <span class="title function_">uvmalloc_k</span> <span class="params">(<span class="type">pagetable_t</span> pgold, <span class="type">pagetable_t</span> pgnew, uint64 oldsz, uint64 newsz)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line">uint64 <span class="title function_">uvmalloc_k</span> <span class="params">(<span class="type">pagetable_t</span> pgnew, <span class="type">pagetable_t</span> pgold, uint64 oldsz, uint64 newsz)</span> &#123;</span><br><span class="line">    uint64 a;</span><br><span class="line">    <span class="type">pte_t</span> *pte_old, *pte_new;</span><br><span class="line">    <span class="keyword">if</span>(newsz &lt; oldsz) <span class="keyword">return</span> oldsz;</span><br><span class="line">    oldsz = PGROUNDUP(oldsz);</span><br><span class="line">    <span class="keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line">        <span class="comment">// 不分配</span></span><br><span class="line">        pte_old = walk(pgold, a, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(pte_old == <span class="number">0</span>) panic(<span class="string">&quot;uvmalloc_k: pte should exist!&quot;</span>);</span><br><span class="line">        <span class="comment">// 分配</span></span><br><span class="line">        pte_new = walk(pgnew, a, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(pte_new == <span class="number">0</span>) panic(<span class="string">&quot;uvmalloc_k: kalloc error!&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置映射</span></span><br><span class="line">        *pte_new = (*pte_old) &amp; (~PTE_U);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="userinit"><a href="#userinit" class="headerlink" title="userinit()"></a>userinit()</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">    p-&gt;sz = PGSIZE;</span><br><span class="line">    uvmalloc_k(p-&gt;pagetable_k, p-&gt;pagetable, <span class="number">0</span>, p-&gt;sz); <span class="comment">// Code Added</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 没有检查返回值</span></span><br><span class="line">    uvmalloc_k(np-&gt;pagetable_k, np-&gt;pagetable, <span class="number">0</span>, p-&gt;sz); <span class="comment">// Code Added</span></span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h6><ul>
<li>注意这里需要将原来内核页表中的映射关系解除（内核映射不需要）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/exec.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Load program into memory.</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 虚拟地址的大小</span></span><br><span class="line">        <span class="keyword">if</span>(sz1 &gt;= PLIC)</span><br><span class="line">            <span class="keyword">goto</span> bad;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 释放原来的页表(不需要释放内核原来的)</span></span><br><span class="line">    uvmunmap(p-&gt;pagetable_k, <span class="number">0</span>, PGROUNDUP(oldsz)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 全部都分配好了再复制</span></span><br><span class="line">    <span class="comment">// 没有检查返回值</span></span><br><span class="line">    uvmalloc_k(p-&gt;pagetable_k, p-&gt;pagetable, <span class="number">0</span>, sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pid==<span class="number">1</span>) vmprint(p-&gt;pagetable);</span><br><span class="line">    <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="sys-sbrk"><a href="#sys-sbrk" class="headerlink" title="sys_sbrk()"></a>sys_sbrk()</h6><ul>
<li>可能会解除映射关系，定义函数 <code>uvmdealloc_k()</code> 进行处理（不释放具体的物理页）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="comment">// 不释放物理内存</span></span><br><span class="line">uint64 <span class="title function_">uvmdealloc_k</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(newsz &gt;= oldsz)</span><br><span class="line">        <span class="keyword">return</span> oldsz;</span><br><span class="line">    <span class="keyword">if</span>(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz))&#123;</span><br><span class="line">        <span class="type">int</span> npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;</span><br><span class="line">        uvmunmap(pagetable, PGROUNDUP(newsz), npages, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 没有检查返回值</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        uvmalloc_k(p-&gt;pagetable_k, p-&gt;pagetable, addr, addr + n);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 不释放物理内存</span></span><br><span class="line">        uvmdealloc_k(p-&gt;pagetable_k, addr + n, addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-测试函数"><a href="#3-测试函数" class="headerlink" title="[3] 测试函数"></a>[3] 测试函数</h5><ul>
<li>最后修改测试函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> copyin_new(pagetable, dst, srcva, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> copyinstr_new(pagetable, dst, srcva, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-一些细节-1"><a href="#3-一些细节-1" class="headerlink" title="(3) 一些细节"></a>(3) 一些细节</h4><ul>
<li>同样是 <code>panic</code> 的问题，在设计上我们不应该让用户的操作造成操作系统的崩溃，因此 <code>uvmalloc_k()</code> 中的 <code>panic</code> 应该处理掉</li>
<li>其中 <code>panic(&quot;uvmalloc_k: pte should exist!&quot;);</code> 是合理的，因为用于页表的映射是存在</li>
<li><code>panic(&quot;uvmalloc_k: kalloc error!&quot;);</code> 这个需要操作系统处理，而不是报错崩溃</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">uvmalloc_k</span> <span class="params">(<span class="type">pagetable_t</span> pgnew, <span class="type">pagetable_t</span> pgold, uint64 oldsz, uint64 newsz)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pte_new = walk(pgnew, a, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte_new == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// panic(&quot;uvmalloc_k: kalloc error!&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>各处检查返回值即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/exec.c</span></span><br><span class="line"><span class="comment">// 进程还在, 不需要释放内核页表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(uvmalloc_k(p-&gt;pagetable_k, p-&gt;pagetable, <span class="number">0</span>, sz) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="comment">// 内核态, 只会调用一次, 第一个进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(uvmalloc_k(p-&gt;pagetable_k, p-&gt;pagetable, <span class="number">0</span>, p-&gt;sz) == <span class="number">-1</span>)</span><br><span class="line">        panic(<span class="string">&quot;usertinit error!&quot;</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 没有检查返回值</span></span><br><span class="line">    <span class="keyword">if</span>(uvmalloc_k(np-&gt;pagetable_k, np-&gt;pagetable, <span class="number">0</span>, p-&gt;sz) == <span class="number">-1</span>) &#123;</span><br><span class="line">        freeproc(np);</span><br><span class="line">        release(&amp;np-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 没有检查返回值</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(uvmalloc_k(p-&gt;pagetable_k, p-&gt;pagetable, addr, addr + n) == <span class="number">-1</span>) &#123;</span><br><span class="line">            growproc(-n);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-回答问题-1"><a href="#4-回答问题-1" class="headerlink" title="(4) 回答问题"></a>(4) 回答问题</h4><ul>
<li><code>copyin()</code> 中的 3 个测试</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(srcva &gt;= p-&gt;sz || srcva+len &gt;= p-&gt;sz || srcva+len &lt; srcva)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>前两个判断保证复制的整块内存区域是已经分配的，第三个判断保证 len 不为负</li>
<li>第三个判断是必要的，如果没有这个判断，<code>memmove()</code> 的第三个参数类型为 <code>uint</code>，会导致把大量的用户页表的内容带入内核，可能对造成内核代码修改崩溃</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">memmove</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, uint n)</span>;</span><br></pre></td></tr></table></figure>





<h2 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3. 实验结果"></a>3. 实验结果</h2><ul>
<li>在修改完 2.3 的 (3) 之后，有一次结果超时，后来都能通过测试</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">== Test pte printout ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">pte printout: OK (13.3s)</span><br><span class="line">== Test answers-pgtbl.txt == answers-pgtbl.txt: OK</span><br><span class="line">== Test count copyin ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">count copyin: OK (2.4s)</span><br><span class="line">    (Old xv6.out.count failure <span class="built_in">log</span> removed)</span><br><span class="line">== Test usertests ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(279.6s)</span><br><span class="line">== Test   usertests: copyin ==</span><br><span class="line">  usertests: copyin: OK</span><br><span class="line">== Test   usertests: copyinstr1 ==</span><br><span class="line">  usertests: copyinstr1: OK</span><br><span class="line">== Test   usertests: copyinstr2 ==</span><br><span class="line">  usertests: copyinstr2: OK</span><br><span class="line">== Test   usertests: copyinstr3 ==</span><br><span class="line">  usertests: copyinstr3: OK</span><br><span class="line">== Test   usertests: sbrkmuch ==</span><br><span class="line">  usertests: sbrkmuch: OK</span><br><span class="line">== Test   usertests: all tests ==</span><br><span class="line">  usertests: all tests: OK</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 66/66</span><br></pre></td></tr></table></figure>

<img src="lab2-pagetable/image-20210513193659174.png" style="zoom:80%;" />

<h2 id="4-遇到的困难以及收获"><a href="#4-遇到的困难以及收获" class="headerlink" title="4. 遇到的困难以及收获"></a>4. 遇到的困难以及收获</h2><ul>
<li>整体思路上不算是很难，而且提示给的很充足</li>
<li>但是由于测试需要跑的时间较长，整个 lab 也花了较多时间</li>
<li>做完这个 lab 之后对于操作系统内部的页表组织有了更深刻的理解，同时对比不同的组织方式，理解了它们之间的优劣<ul>
<li>每个进程拥有一个页表，整个内核态拥有一个页表</li>
<li>每个进程拥有一个内核页表和用户页表</li>
</ul>
</li>
<li>感觉系统性的东西，能够把想法正确实现就是很棒了</li>
</ul>
<h2 id="5-对课程或-lab-的意见和建议"><a href="#5-对课程或-lab-的意见和建议" class="headerlink" title="5. 对课程或 lab 的意见和建议"></a>5. 对课程或 lab 的意见和建议</h2><ul>
<li>暂时没有意见</li>
</ul>
<h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev1.pdf">https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev1.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html">https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/13/OS/xv6-labs/lab2-pagetable/" data-id="cl9lj74ba00if64tzdfixbavh" data-title="xv6-labs-2020.lab2.pagetable" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xv6/" rel="tag">xv6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/YLQ-GAMES202/10" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/12/CG/YLQ-GAMES202/10/" class="article-date">
  <time class="dt-published" datetime="2021-05-12T05:00:36.000Z" itemprop="datePublished">2021-05-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES202/">CG.GAMES202</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/12/CG/YLQ-GAMES202/10/">GAMES202.闫令琪.10.基于物理的材质(微表面模型)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY">https://www.bilibili.com/video/BV1YK4y1T7yY</a></li>
</ul>
<h1 id="基于物理的材质"><a href="#基于物理的材质" class="headerlink" title="基于物理的材质"></a>基于物理的材质</h1><h2 id="PBR-vs-PBR-Material"><a href="#PBR-vs-PBR-Material" class="headerlink" title="PBR vs PBR Material"></a>PBR vs PBR Material</h2><ul>
<li>PBR：Physically-Based Rendering（基于物理的渲染）<ul>
<li>所有在渲染中涉及到的东西都必须是物理的</li>
<li>材质、光照、相机、光线传播等<ul>
<li>material、light、camera、light transport</li>
<li>透镜、透镜组</li>
</ul>
</li>
<li><strong>PBR 不仅限于材质，但是实时渲染领域通常就是指材质</strong></li>
</ul>
</li>
<li>实时渲染材质的落后于离线渲染<ul>
<li>丰富程度<ul>
<li>实时渲染用的材质一般都是研究的比较透彻的，能够比较快的渲染</li>
</ul>
</li>
<li>准确度（质量）<ul>
<li>为了速度，牺牲质量</li>
<li><strong>头发</strong> 的渲染</li>
<li>实时渲染是在保证速度的前提下提高质量</li>
</ul>
</li>
<li>”PB“ 在实时渲染中并没有那么物理<ul>
<li>做了大量的简化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="实时渲染中的-PBR"><a href="#实时渲染中的-PBR" class="headerlink" title="实时渲染中的 PBR"></a>实时渲染中的 PBR</h2><ul>
<li>主要有两类：surface、volume</li>
<li>在表面上定义的、在体积上定义的</li>
</ul>
<h3 id="surface"><a href="#surface" class="headerlink" title="surface"></a>surface</h3><ul>
<li>在物体表面上定义的</li>
<li>microfacet models<ul>
<li>实际于物理的描述</li>
<li>但有时候不正确的使用，则不是 PBR</li>
</ul>
</li>
<li>disney principled BRDFS：基于 Disney 的原则设计的 BRDF<ul>
<li>发明的时候希望被用于离线渲染，但同时也能被用在实时渲染之中</li>
<li>轻量级的计算，实现简单</li>
<li>能够表示材质种类很多，效果也非常不错</li>
<li>不是 PBR 的</li>
<li>artist friendly：为了艺术家使用方便而设计的</li>
<li>总体而言描述的还是挺好的，但是在细节上还是不完美</li>
<li>一张效果图：左（照片）、右（渲染图）<ul>
<li>渲染器：Hyperion</li>
<li>最早的 Disney 工作室所在的街的名字</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="10/image-20210512132930074.png" style="zoom: 67%;" />



<h3 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h3><ul>
<li>在体积上定义的<ul>
<li>更加困难</li>
</ul>
</li>
<li>mostly focused on fast and approximate single scattering and multiple scattering</li>
<li><strong>cloud</strong>, <strong>hair</strong>, <strong>skin</strong>, etc<ul>
<li>烟雾、云、皮肤、头发</li>
</ul>
</li>
</ul>
<h3 id="实时渲染"><a href="#实时渲染" class="headerlink" title="实时渲染"></a>实时渲染</h3><ul>
<li>实时渲染中材质并没有很多其他的新理论</li>
<li>但是会有很多实现上的 hacks<ul>
<li>为了降低开销</li>
</ul>
</li>
<li>速度是前提<ul>
<li>speed、performance</li>
</ul>
</li>
</ul>
<h2 id="Microfacet-BRDF"><a href="#Microfacet-BRDF" class="headerlink" title="Microfacet BRDF"></a>Microfacet BRDF</h2><ul>
<li>微表面模型</li>
<li><a href="/2021/03/21/CG/YLQ-GAMES101/07/">GAMES101 中有所介绍</a></li>
<li>微表面的 BRDF：<strong>微观</strong><ul>
<li>微表面的法线各不相同</li>
<li>这些法线的不同分布造成最终渲染结果的不同</li>
</ul>
</li>
</ul>
<img src="10/image-20210512134827072.png" style="zoom: 50%;" />

<ul>
<li>F 项：菲涅尔项，从一个角度看过去有多少能量会被反射</li>
<li>G 项：shadowing masking</li>
<li>D 项：微表面的法线分布<ul>
<li><strong>半程向量</strong>和<strong>微表面的法线</strong>一致的情况下，才能把光线从入射方向反射到出射方向去</li>
</ul>
</li>
</ul>
<h3 id="菲涅尔项"><a href="#菲涅尔项" class="headerlink" title="菲涅尔项"></a>菲涅尔项</h3><ul>
<li>The Fresnel Term</li>
<li>反射的能量和入射角的方向有关</li>
</ul>
<img src="10/image-20210512140332729.png" style="zoom: 67%;" />

<ul>
<li>绝缘体（Dieletric）、导体（Conduct）的性质不太一样<ul>
<li><a href="/2021/03/21/CG/YLQ-GAMES101/07/">GAMES101</a></li>
</ul>
</li>
<li>Schlick’s approximation</li>
</ul>
<p>$$<br>R(\theta) &#x3D;R_{0}+\left(1-R_{0}\right)(1-\cos \theta)^{5}<br>$$</p>
<p>$$<br>R_{0} &#x3D;\left(\frac{n_{1}-n_{2}}{n_{1}+n_{2}}\right)^{2}<br>$$</p>
<h3 id="NDF"><a href="#NDF" class="headerlink" title="NDF"></a>NDF</h3><ul>
<li>Normal Distribution Function</li>
<li>微表面的法线分布函数</li>
</ul>
<img src="10/image-20210512141142682.png" style="zoom:67%;" />

<ul>
<li>分布比较集中：glossy -&gt; specular</li>
<li>分布比较散乱：diffuse</li>
<li>怎么让微表面在不同材质之间变化<ul>
<li>高度场上下做一个拉伸（scale）</li>
<li>上下做一个拉伸之后<ul>
<li>可以让法线的分布不再集中，从 glossy 转变为 diffuse</li>
<li>相当于把所有面变得倾斜过来了</li>
<li>微表面之间形成的沟壑变得越来越深，形成粗糙的表面</li>
</ul>
</li>
</ul>
</li>
<li>NDF：微表面的<strong>法线分布函数</strong><ul>
<li>二维</li>
</ul>
</li>
<li>有很多描述 NDF 的模型<ul>
<li>Beckmann, GGX, etc</li>
<li>Detailed models [Yan 2014, 2016, 2018, …]<ul>
<li>实时渲染中用的比较少，代价太大</li>
</ul>
</li>
</ul>
</li>
<li>怎么把一个 2D 的分布函数可视化在一个平面上？<ul>
<li>法线，半球面的分布（不能向下）</li>
<li>从上往下拍扁即可，projected solid angle</li>
</ul>
</li>
</ul>
<h4 id="Beckmann-NDF"><a href="#Beckmann-NDF" class="headerlink" title="Beckmann NDF"></a>Beckmann NDF</h4><p>$$<br>D(h)&#x3D;\dfrac{e^{-\dfrac{\tan^2\theta_h}{\alpha^2}}}{\pi\alpha^2\cos^4\theta_h}<br>$$</p>
<ul>
<li><p>和高斯函数很像</p>
</li>
<li><p>高斯函数</p>
<ul>
<li>高斯函数是对正态函数的一个更通用的抽象</li>
<li>表示一类中间高，往两边衰减的函数分布</li>
</ul>
</li>
<li><p>$\alpha$：一个参数，描述粗糙程度（正态函数中的方差 $\sigma$ ）</p>
<ul>
<li>$\alpha$ 越小，越趋向于镜面 specular</li>
</ul>
</li>
<li><p>$\theta_h$：法线（镜面：垂直表面）和半程向量所成的夹角</p>
</li>
<li><p><strong>各向同性的</strong>，不涉及 $\phi$</p>
<ul>
<li>复杂的 Beckmann NDF 是可以描述各向异性的材质的</li>
</ul>
</li>
<li><p>为什么分子中是 $\tan^2\theta_h$ 而不是 $\theta^2_h$ ？</p>
<ul>
<li>Beckmann NDF 是定义在坡度空间上的（<strong>slope space</strong>）</li>
<li>高斯函数本身的定义域是无限大的，定义在 $\tan\theta_h$ 上可以满足当 $\theta_h$ 取遍 $[0,\dfrac{\pi}{2}]$，满足这个无限大的条件</li>
<li>保证了<strong>不会有微表面的法线是朝下的</strong></li>
</ul>
</li>
</ul>
<img src="10/image-20210512145652158.png" style="zoom:50%;" />

<ul>
<li>分母项<ul>
<li>归一化项</li>
<li>让 NDF 在 projected solid angle 上积分为 1</li>
</ul>
</li>
</ul>
<h4 id="GGX-NDF"><a href="#GGX-NDF" class="headerlink" title="GGX NDF"></a>GGX NDF</h4><ul>
<li>GGX (or Trowbridge-Reitz) [Walter et al. 2007]</li>
<li>TR 模型</li>
<li>特点：长尾的（long tail）</li>
<li>GGX 会很快衰减没但是衰减到一定程度之后，速度会变慢，导致长尾<ul>
<li>grazing angle 还不会是 0</li>
</ul>
</li>
</ul>
<img src="10/image-20210512151311797.png" style="zoom:67%;" />

<ul>
<li>GGX 能够看到周围的光晕现象<ul>
<li>GGX 的效果更加自然</li>
</ul>
</li>
</ul>
<img src="10/image-20210512151536925.png" style="zoom:50%;" />



<h4 id="Extending-GGX"><a href="#Extending-GGX" class="headerlink" title="Extending GGX"></a>Extending GGX</h4><ul>
<li>Extending GGX [by <strong>Brent Burley</strong> from WDAS]</li>
<li>Walt Disney Animation Studios</li>
<li>迪士尼动画工作室</li>
<li><strong>GTR</strong> (Generalized Trowbridge-Reitz)</li>
</ul>
<ul>
<li>Even longer tails</li>
</ul>
<ul>
<li>定义了一个参数 $\gamma$，当 $\gamma&#x3D;2$ 的时候，就是 GGX<ul>
<li>当 $\gamma$ 取的比较大的时候，会接近于 Backmann 的效果（有趣）</li>
</ul>
</li>
</ul>
<img src="10/image-20210512152230598.png" style="zoom:50%;" />



<h3 id="Shadowing-Masking"><a href="#Shadowing-Masking" class="headerlink" title="Shadowing-Masking"></a>Shadowing-Masking</h3><ul>
<li>几何项 G</li>
<li>微表面之间的互相遮挡问题<ul>
<li>尤其是在 grazing angle 的时候</li>
</ul>
</li>
<li>入射光、反射光都可能被遮挡</li>
</ul>
<img src="10/image-20210512152705978.png" style="zoom:70%;" />

<ul>
<li>Shadowing：light（左）</li>
<li>Masking：eye（右）</li>
<li>体现由于遮挡导致的变暗的现象</li>
<li><span id="G_item_character">基本性质</span><ul>
<li>靠近 grazing angle 的时候，接近于 0</li>
<li>接近法线的时候，接近于 1</li>
</ul>
</li>
</ul>
<h4 id="G-term-的重要性"><a href="#G-term-的重要性" class="headerlink" title="G term 的重要性"></a>G term 的重要性</h4><img src="10/image-20210512153103820.png" style="zoom:50%;" />
$$
f(\mathbf{i}, \mathbf{o})=\frac{\mathbf{F}(\mathbf{i}, \mathbf{h}) \mathbf{G}(\mathbf{i}, \mathbf{o}, \mathbf{h}) \mathbf{D}(\mathbf{h})}{4(\mathbf{n}, \mathbf{i})(\mathbf{n}, \mathbf{o})}
$$

<ul>
<li>如果不考虑 G 项<ul>
<li>在边缘的地方，分母 $n\cdot i$ 接近于 0</li>
<li>导致结果巨大，渲染的结果就是边缘有白色的亮圈</li>
<li>这是不符合物理规律的</li>
</ul>
</li>
</ul>
<h4 id="The-Smith-shadowing-masking-term"><a href="#The-Smith-shadowing-masking-term" class="headerlink" title="The Smith shadowing-masking term"></a>The Smith shadowing-masking term</h4><ul>
<li>一个常用的 shadowing-masking 项</li>
<li>理论非常复杂</li>
<li>在具体的发现分布之下推导出一个 G 项</li>
<li>把 shadowing 和 masking 拆开考虑<ul>
<li>但实际上是有关的</li>
<li>$m$ 是半程向量</li>
</ul>
</li>
</ul>
<img src="10/image-20210512153704997.png" style="zoom: 33%;" />

<ul>
<li>一个例子</li>
</ul>
<img src="10/image-20210512153741268.png" style="zoom: 50%;" />

<ul>
<li><a href="#G_item_character">G 项的特征</a></li>
</ul>
<h3 id="Multiple-Bounces"><a href="#Multiple-Bounces" class="headerlink" title="Multiple Bounces"></a>Multiple Bounces</h3><ul>
<li>微表面模型还存在一个其他问题：<strong>能量损失</strong></li>
<li><a target="_blank" rel="noopener" href="https://fpsunflower.github.io/ckulla/data/s2017_pbs_imageworks_slides_v2.pdf">该部分链接</a></li>
</ul>
<p><img src="/10/image-20210512154111914.png"></p>
<ul>
<li>roughness 变化</li>
<li>存在的问题，从左到右结果越来越暗了<ul>
<li>高光到哑光，亮度应该是差不多的</li>
</ul>
</li>
</ul>
<h4 id="白炉测试"><a href="#白炉测试" class="headerlink" title="白炉测试"></a>白炉测试</h4><ul>
<li>The White Furnace Test</li>
</ul>
<p><img src="/10/image-20210512154553425.png"></p>
<ul>
<li>一个实验，空的背景，环境光照各处都是一样的，先保证在 roughness 比较低的情况下，反射出来的颜色和背景一样</li>
<li>随着 roughness 增大，颜色越来越暗，出现能量损失现象</li>
</ul>
<h4 id="为什么会有能量损失"><a href="#为什么会有能量损失" class="headerlink" title="为什么会有能量损失"></a>为什么会有能量损失</h4><ul>
<li>roughness 越大<ul>
<li>沟壑越多，光线越容易被挡住</li>
<li>多次弹射的光线占比的可能性越大</li>
<li>如果我们在使用微表面模型的时候只考虑单次 bounce，损失的能量就越多</li>
</ul>
</li>
</ul>
<p><img src="/10/image-20210512155104802.png"></p>
<h4 id="解决能量损失的问题"><a href="#解决能量损失的问题" class="headerlink" title="解决能量损失的问题"></a>解决能量损失的问题</h4><ul>
<li>基本思想，把损失的能量补回来<ul>
<li>Heitz et al. 2016</li>
<li>准确计算多次 bounce</li>
<li>很慢</li>
</ul>
</li>
<li>基本思想<ul>
<li>如果一束光被遮挡了，说明这一束光发生了下一次的反射</li>
</ul>
</li>
</ul>
<h4 id="The-Kulla-Conty-Approximation"><a href="#The-Kulla-Conty-Approximation" class="headerlink" title="The Kulla-Conty Approximation"></a>The Kulla-Conty Approximation</h4><ul>
<li>一个近似方法</li>
<li>经验性的方式补全丢失的能量</li>
<li>怎么求出丢失的能量？</li>
<li>先算出出射的总能量（这里求解的 BRDF 就是上面考虑了各种项的结果，因此计算出来的结果应该是有损失的）<ul>
<li>对所有的入射方向的入射光做一个积分</li>
<li>我们假设所有方向的入射光 radiance 都是 1，$L_i&#x3D;1$</li>
<li>这里的 $\cos\theta$ 项哪去了？<ul>
<li>$\mathrm{d}\omega&#x3D;\sin\theta;\mathrm{d}\theta;\mathrm{d}\phi$</li>
<li>$\cos\theta;\mathrm{d}\omega&#x3D;\sin\theta;\mathrm{d}\sin\theta;\mathrm{d}\phi$</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>$$<br>E(\mu_o)&#x3D;\int_{0}^{2\pi}\int_{0}^{1}f(\mu_o,\mu_i,\phi)\mu_i;\mathrm{d}\mu_i;\mathrm{d}\phi<br>$$</p>
<p>$$<br>\mu&#x3D;\sin\theta<br>$$</p>
<ul>
<li>那么损失的能量就是 $1-E(\mu_o)$<ul>
<li>损失的能量和观察方向是相关的</li>
</ul>
</li>
<li>关键思想就是把上面的能量补上</li>
</ul>
<h5 id="一种设计"><a href="#一种设计" class="headerlink" title="一种设计"></a>一种设计</h5><ul>
<li>补上另外一种 BDRF，使得最终积分的结果为 $1-E(\mu_o)$</li>
<li>考虑对称性，我们还有另外一项<ul>
<li>$c(1-E(\mu_o))(1-E(\mu_i))$</li>
<li>$c$ 为归一化项</li>
</ul>
</li>
<li><strong>我们可以设计其他的积分函数</strong>，使得积分结果为  $1-E(\mu_o)$ 即可</li>
<li>这种设计比较自然</li>
</ul>
<p>$$<br>c&#x3D;f_{ms}(\mu_o,\mu_i)&#x3D;\dfrac{(1-E(\mu_o))(1-E(\mu_i))}{\pi(1-E_{avg})}<br>$$</p>
<p>$$<br>E_{avg}&#x3D;\dfrac{\int_0^1E(\mu)\mu;\mathrm{d}\mu}{\int_0^1\mu;\mathrm{d}\mu}&#x3D;2\int_0^1E(\mu)\mu;\mathrm{d}\mu<br>$$</p>
<ul>
<li>验证</li>
</ul>
<img src="10/image-20210512161642746.png" style="zoom:50%;" />

<ul>
<li>新的问题，怎么计算我们的 $E_{avg}$</li>
<li>对于复杂积分的求解<ul>
<li>预计算 、打表</li>
<li>precompute、tabulate</li>
</ul>
</li>
<li>参数<ul>
<li>$\mu_o$</li>
<li>具体 BDRF 的参数<ul>
<li>简单的 NDF 可以用 roughness</li>
</ul>
</li>
</ul>
</li>
<li>打表</li>
</ul>
<img src="10/image-20210512162106796.png" style="zoom:50%;" />

<ul>
<li>结果</li>
</ul>
<p><img src="/10/image-20210512154111914.png"></p>
<p><img src="/10/image-20210512162437672.png"></p>
<h5 id="如果-BRDF-有颜色"><a href="#如果-BRDF-有颜色" class="headerlink" title="如果 BRDF 有颜色"></a>如果 BRDF 有颜色</h5><ul>
<li>Color &#x3D;&#x3D; absorption &#x3D;&#x3D; energy loss (as it should)</li>
<li>有颜色，表明有吸收，也就是存在能量损失（这些能量的损失是应该损失的，被吸收）</li>
<li>那么就导致原始的积分结果不是 1</li>
<li>我们先考虑没有颜色吸收，按照上面的思路计算出结果，然后再考虑由于颜色吸收导致的能量损失</li>
</ul>
<h6 id="the-average-Fresnel"><a href="#the-average-Fresnel" class="headerlink" title="the average Fresnel"></a>the average Fresnel</h6><ul>
<li>计算一个平均的 Fresnel 项，对不同的入射角进行积分</li>
<li>为什么这么做呢？因为颜色的吸收只会出现在 Fresnel 项中</li>
</ul>
<p>$$<br>F_{avg}&#x3D;\dfrac{\int_0^1F(\mu)\mu;\mathrm{d}\mu}{\int_0^1\mu;\mathrm{d}\mu}&#x3D;2\int_0^1F(\mu)\mu;\mathrm{d}\mu<br>$$</p>
<ul>
<li>$E_{avg}$ 项是不会参与大后续的多次 bounce 中的<ul>
<li>参与到后续 bounce 中的是 $1-E(\mu_o)$</li>
</ul>
</li>
</ul>
<h6 id="把最终能够看到的能量分类"><a href="#把最终能够看到的能量分类" class="headerlink" title="把最终能够看到的能量分类"></a>把最终能够看到的能量分类</h6><ul>
<li>直接能看到的能量：$F_{avg}E_{avg}$</li>
<li>1 次反射之后看到的能量：$F_{avg}(1-E_{avg})F_{avg}E_{avg}$</li>
<li>…</li>
<li>$k$ 次反射之后看到的能量：$F_{avg}^k(1-E_{avg})^kF_{avg}E_{avg}$</li>
<li>对上面的能量求和</li>
</ul>
<p>$$<br>\dfrac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}<br>$$</p>
<ul>
<li>我们将这个系数直接乘到直接计算出来的没有考虑吸收的结果之上即可<ul>
<li><strong>乘到增加的 BRDF 之上（而不是原来的）</strong></li>
</ul>
</li>
<li>RGB 3 通道是分开计算的</li>
</ul>
<h6 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h6><p><img src="/10/image-20210512170106198.png"></p>
<p><img src="/10/image-20210512170118253.png"></p>
<h4 id="不正确的-Hack"><a href="#不正确的-Hack" class="headerlink" title="不正确的 Hack"></a>不正确的 Hack</h4><ul>
<li>微表面模型比较暗，我们再直接加上一个 diffuse lobe 的结果</li>
</ul>
<p><img src="/10/image-20210512170357957.png"></p>
<ul>
<li>问题<ul>
<li>物理上完全错误</li>
<li>不能保证能量守恒<ul>
<li>如果加上一个 diffuse lobe 但是能够保证能量守恒，那是正确的</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/12/CG/YLQ-GAMES202/10/" data-id="cl9lj749u008q64tz24r58kgs" data-title="GAMES202.闫令琪.10.基于物理的材质(微表面模型)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/16/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><a class="page-number" href="/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/18/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/0/">0</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algebra/">Algebra</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-Kits/">C++.Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG/">CG</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Algorithm/">CG.Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES101/">CG.GAMES101</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES102/">CG.GAMES102</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES103/">CG.GAMES103</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES104/">CG.GAMES104</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES202/">CG.GAMES202</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES203/">CG.GAMES203</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Kits/">CG.Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-LS/">CG.LS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-PBRT/">CG.PBRT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Paper/">CG.Paper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CV/">CV</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Code/">Code</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-CLJ/">DB.CLJ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-MySQL/">DB.MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-SQLServer/">DB.SQLServer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DSA/">DSA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kits/">Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-CXQ/">OS.CXQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-OSTEP/">OS.OSTEP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-xv6-labs/">OS.xv6-labs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-xv6-source-code/">OS.xv6-source-code</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TODO/">TODO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/book-directory/">book.directory</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computation-pyr/">computation.pyr</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/csharp-kits/">csharp.kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/csharp-tds/">csharp.tds</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/images/">images</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/installation/">installation</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mitsuba/">mitsuba</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nothing/">nothing</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-Maya/">software.Maya</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-ps/">software.ps</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-vscode/">software.vscode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/win/">win</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algebra/" rel="tag">Algebra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS/" rel="tag">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BST/" rel="tag">BST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BVH/" rel="tag">BVH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CG-Algorithm/" rel="tag">CG-Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CV/" rel="tag">CV</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Code/" rel="tag">Code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB/" rel="tag">DB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/" rel="tag">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DSA/" rel="tag">DSA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dijkstra/" rel="tag">Dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EG/" rel="tag">EG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Floyd/" rel="tag">Floyd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GI/" rel="tag">GI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Glints/" rel="tag">Glints</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDR/" rel="tag">HDR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HQX/" rel="tag">HQX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Heap/" rel="tag">Heap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kits/" rel="tag">Kits</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCA/" rel="tag">LCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLG/" rel="tag">LLG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MCMC/" rel="tag">MCMC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MIS/" rel="tag">MIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MLT/" rel="tag">MLT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maya/" rel="tag">Maya</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NEE/" rel="tag">NEE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBRT/" rel="tag">PBRT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paper/" rel="tag">Paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Radiometry/" rel="tag">Radiometry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RayTracing/" rel="tag">RayTracing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SAH/" rel="tag">SAH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SDF/" rel="tag">SDF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SGJ/" rel="tag">SGJ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLServer/" rel="tag">SQLServer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shadow/" rel="tag">Shadow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WHM/" rel="tag">WHM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WX/" rel="tag">WX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/book/" rel="tag">book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/computation/" rel="tag">computation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csharp/" rel="tag">csharp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/images/" rel="tag">images</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/installation/" rel="tag">installation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/" rel="tag">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mitsuba/" rel="tag">mitsuba</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobaxterm/" rel="tag">mobaxterm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nothing/" rel="tag">nothing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/obs/" rel="tag">obs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/occlusion/" rel="tag">occlusion</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ps/" rel="tag">ps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/software/" rel="tag">software</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tree/" rel="tag">tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/win/" rel="tag">win</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xv6/" rel="tag">xv6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%83%E5%AE%87%E5%AE%99/" rel="tag">元宇宙</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%A0%E4%BD%95/" rel="tag">几何</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/" rel="tag">可见性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" rel="tag">拓扑排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%99%AE%E5%90%95%E5%85%8B%E5%9D%90%E6%A0%87/" rel="tag">普吕克坐标</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="tag">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algebra/" style="font-size: 10px;">Algebra</a> <a href="/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/tags/BST/" style="font-size: 10px;">BST</a> <a href="/tags/BVH/" style="font-size: 12.5px;">BVH</a> <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/CG/" style="font-size: 20px;">CG</a> <a href="/tags/CG-Algorithm/" style="font-size: 10px;">CG-Algorithm</a> <a href="/tags/CV/" style="font-size: 10.63px;">CV</a> <a href="/tags/Code/" style="font-size: 14.38px;">Code</a> <a href="/tags/DB/" style="font-size: 19.38px;">DB</a> <a href="/tags/DFS/" style="font-size: 12.5px;">DFS</a> <a href="/tags/DP/" style="font-size: 13.13px;">DP</a> <a href="/tags/DSA/" style="font-size: 11.25px;">DSA</a> <a href="/tags/Dijkstra/" style="font-size: 10px;">Dijkstra</a> <a href="/tags/EG/" style="font-size: 12.5px;">EG</a> <a href="/tags/Floyd/" style="font-size: 10.63px;">Floyd</a> <a href="/tags/GI/" style="font-size: 11.25px;">GI</a> <a href="/tags/Glints/" style="font-size: 10px;">Glints</a> <a href="/tags/HDR/" style="font-size: 10px;">HDR</a> <a href="/tags/HQX/" style="font-size: 10px;">HQX</a> <a href="/tags/Heap/" style="font-size: 10px;">Heap</a> <a href="/tags/Kits/" style="font-size: 13.75px;">Kits</a> <a href="/tags/LCA/" style="font-size: 10px;">LCA</a> <a href="/tags/LLG/" style="font-size: 12.5px;">LLG</a> <a href="/tags/MCMC/" style="font-size: 10.63px;">MCMC</a> <a href="/tags/MIS/" style="font-size: 10px;">MIS</a> <a href="/tags/MLT/" style="font-size: 10px;">MLT</a> <a href="/tags/Maya/" style="font-size: 10px;">Maya</a> <a href="/tags/MySQL/" style="font-size: 11.88px;">MySQL</a> <a href="/tags/NEE/" style="font-size: 10px;">NEE</a> <a href="/tags/OS/" style="font-size: 17.5px;">OS</a> <a href="/tags/PBRT/" style="font-size: 10px;">PBRT</a> <a href="/tags/Paper/" style="font-size: 15.63px;">Paper</a> <a href="/tags/Radiometry/" style="font-size: 10px;">Radiometry</a> <a href="/tags/RayTracing/" style="font-size: 10px;">RayTracing</a> <a href="/tags/SAH/" style="font-size: 10px;">SAH</a> <a href="/tags/SDF/" style="font-size: 10px;">SDF</a> <a href="/tags/SGJ/" style="font-size: 10.63px;">SGJ</a> <a href="/tags/SQL/" style="font-size: 13.13px;">SQL</a> <a href="/tags/SQLServer/" style="font-size: 10.63px;">SQLServer</a> <a href="/tags/STL/" style="font-size: 11.25px;">STL</a> <a href="/tags/Shadow/" style="font-size: 10px;">Shadow</a> <a href="/tags/WHM/" style="font-size: 16.88px;">WHM</a> <a href="/tags/WX/" style="font-size: 11.88px;">WX</a> <a href="/tags/YLQ/" style="font-size: 18.13px;">YLQ</a> <a href="/tags/book/" style="font-size: 10.63px;">book</a> <a href="/tags/computation/" style="font-size: 18.75px;">computation</a> <a href="/tags/csharp/" style="font-size: 16.25px;">csharp</a> <a href="/tags/images/" style="font-size: 10px;">images</a> <a href="/tags/installation/" style="font-size: 11.88px;">installation</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/linux/" style="font-size: 11.25px;">linux</a> <a href="/tags/math/" style="font-size: 10px;">math</a> <a href="/tags/mitsuba/" style="font-size: 11.88px;">mitsuba</a> <a href="/tags/mobaxterm/" style="font-size: 10px;">mobaxterm</a> <a href="/tags/nothing/" style="font-size: 10.63px;">nothing</a> <a href="/tags/obs/" style="font-size: 10px;">obs</a> <a href="/tags/occlusion/" style="font-size: 15px;">occlusion</a> <a href="/tags/ps/" style="font-size: 10px;">ps</a> <a href="/tags/software/" style="font-size: 10px;">software</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/tree/" style="font-size: 11.25px;">tree</a> <a href="/tags/vscode/" style="font-size: 10.63px;">vscode</a> <a href="/tags/win/" style="font-size: 10.63px;">win</a> <a href="/tags/xv6/" style="font-size: 16.25px;">xv6</a> <a href="/tags/%E4%BA%8C%E5%88%86/" style="font-size: 10.63px;">二分</a> <a href="/tags/%E5%85%83%E5%AE%87%E5%AE%99/" style="font-size: 10.63px;">元宇宙</a> <a href="/tags/%E5%87%A0%E4%BD%95/" style="font-size: 10px;">几何</a> <a href="/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/" style="font-size: 11.88px;">可见性</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 10.63px;">并查集</a> <a href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">拓扑排序</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%99%AE%E5%90%95%E5%85%8B%E5%9D%90%E6%A0%87/" style="font-size: 10px;">普吕克坐标</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 10px;">最小生成树</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" style="font-size: 13.13px;">最短路</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 10px;">线段树</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/23/CG/WHM-GAMES103/11/">GAMES103.王华民.11.Incompressible Fluid Dynamics and Eulerian Fluids</a>
          </li>
        
          <li>
            <a href="/2022/10/23/CG/Papers/2021/bvh-survey-3/">(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(4)</a>
          </li>
        
          <li>
            <a href="/2022/04/28/CG/Kits/MIS-NEE/">NEE、MIS(多重重要性采样)</a>
          </li>
        
          <li>
            <a href="/2022/04/18/CG/WHM-GAMES103/10/">GAMES103.王华民.10.Surface Waves</a>
          </li>
        
          <li>
            <a href="/2022/04/17/CG/WHM-GAMES103/09-1/">GAMES103.王华民.09.Collision Handling(1)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>