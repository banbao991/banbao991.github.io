<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/16/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-DB/CLJ/08" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/13/DB/CLJ/08/" class="article-date">
  <time class="dt-published" datetime="2021-06-13T05:03:05.000Z" itemprop="datePublished">2021-06-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/13/DB/CLJ/08/">数据库概论.陈立军.08.数据挖掘简述</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h1><ul>
<li>一个广为流传的例子：啤酒和尿布</li>
<li>数据挖掘是识别数据中<strong>有效的</strong>、<strong>新颖的</strong>、<strong>潜在有用的</strong>、<strong>最终可被理解的模式</strong>的非平凡过程</li>
</ul>
<h2 id="预测型工具"><a href="#预测型工具" class="headerlink" title="预测型工具"></a>预测型工具</h2><ul>
<li>有效的<ul>
<li>该模式具有足够的通用性，即对于新数据，该模式同样适用</li>
</ul>
</li>
<li>新颖的<ul>
<li>该模式是深层次的，事先无法预料的</li>
</ul>
</li>
<li>潜在有用的<ul>
<li>该模式可以指导一些有效的行为，不仅仅是检索有效的新颖的模式，可以指导决策人员进行科学决策</li>
</ul>
</li>
<li>最终可被理解的<ul>
<li>该模式必须简单易懂</li>
</ul>
</li>
</ul>
<h2 id="数据挖掘方法论"><a href="#数据挖掘方法论" class="headerlink" title="数据挖掘方法论"></a>数据挖掘方法论</h2><img src="08/image-20210613132636291.png" style="zoom: 67%;" />



<h2 id="数据挖掘的任务与方法"><a href="#数据挖掘的任务与方法" class="headerlink" title="数据挖掘的任务与方法"></a>数据挖掘的任务与方法</h2><table>
<thead>
<tr>
<th align="center">数据挖掘任务</th>
<th align="center">描述</th>
<th align="center">相关技术</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据划分</td>
<td align="center">聚类分析: 在预先没有确定类别的情况下，根据数据的不同属性，将数据分成不同的类别。<br/>分类分析：将数据映射到预先定义的数据类别中</td>
<td align="center">聚类分析<br/>Bayesian分类<br/>决策树或分类树<br/>人工神经网络</td>
</tr>
<tr>
<td align="center">依赖分析</td>
<td align="center">找出各个属性之间的依赖关系</td>
<td align="center">Bayesian网络<br/>关联分析</td>
</tr>
<tr>
<td align="center">奇异点分析</td>
<td align="center">找出与一般数据行为不一致的数据项</td>
<td align="center">聚类分析<br/>奇异点检测</td>
</tr>
<tr>
<td align="center">趋势检测</td>
<td align="center">通常在时间序列上，对数据库中的数据利用线性回归或曲线拟合等方式进行综合分析</td>
<td align="center">回归分析<br/>序列模式分析</td>
</tr>
</tbody></table>
<h2 id="查询分析"><a href="#查询分析" class="headerlink" title="查询分析"></a>查询分析</h2><ul>
<li>查询哪些商品经常被购买</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> item, <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">From</span> trans</span><br><span class="line"><span class="keyword">Where</span> <span class="keyword">condition</span></span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">by</span> item</span><br><span class="line"><span class="keyword">Having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查询哪两个商品经常一起被购买</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> t1.item, t2.item, <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">From</span> trans t1, trans t2</span><br><span class="line"><span class="keyword">Where</span> t1.bucket_id <span class="operator">=</span> t2.bucket_id</span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">by</span> t1.item, t2.item</span><br><span class="line"><span class="keyword">Having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面简单的连接，效果很差，运行很慢</li>
</ul>
<h2 id="关联分析"><a href="#关联分析" class="headerlink" title="关联分析"></a>关联分析</h2><ul>
<li>目的：发现数据间的相互关联</li>
<li>购物篮分析：给定一组商品，一个交易集合，通过分析交易记录集合，推导出商品间的相关性</li>
<li>基本形式<ul>
<li>给定：一组事务集，每一个事务中包含若干个数据项</li>
<li>挖掘：各个数据项之间的关联</li>
</ul>
</li>
<li>结论：98% 的顾客在购买电动剃须刀的同时会购买一些电池</li>
</ul>
<h3 id="关联分析支持度（support）"><a href="#关联分析支持度（support）" class="headerlink" title="关联分析支持度（support）"></a>关联分析支持度（support）</h3><ul>
<li>在关联分析中表示满足规则的记录数与总记录数的比</li>
<li>它表明了规则的模式在数据库中出现的频度</li>
<li>对于规则：$X\to Y$，其支持度表示为</li>
</ul>
<p>$$</p>
<p>$$</p>
<h3 id="关联分析置信度（confidence）"><a href="#关联分析置信度（confidence）" class="headerlink" title="关联分析置信度（confidence）"></a>关联分析置信度（confidence）</h3><ul>
<li>在关联分析中表示为满足规则的记录数与出现被分析数据项的记录数之比</li>
<li>对于规则：$X\to Y$，其置信度表示为</li>
</ul>
<p>$$<br>C&#x3D;\dfrac{同时购买商品;X;和;Y;的交易数}{购买商品;X;的交易数}<br>$$</p>
<h3 id="关联分析核心：发现频繁项集"><a href="#关联分析核心：发现频繁项集" class="headerlink" title="关联分析核心：发现频繁项集"></a>关联分析核心：发现频繁项集</h3><ul>
<li>频繁项集：出现频率超过<strong>预设支持度</strong>的项集</li>
<li><strong>关联分析就是发现频繁项集的过程</strong></li>
<li>不能够先生成商品组合然后逐一过滤，这样候选集太大了</li>
</ul>
<h4 id="先验（Apriori）法则"><a href="#先验（Apriori）法则" class="headerlink" title="先验（Apriori）法则"></a>先验（Apriori）法则</h4><ul>
<li><p><strong>一个频繁项集的任何非空子集肯定也是频繁项集</strong></p>
</li>
<li><p>${A,B}$ 为频繁项集，那么其子集 ${A}$、${B}$ 也都为频繁项集</p>
</li>
<li><p><strong>反单调</strong></p>
<ul>
<li>一个集合如果不是频繁的，则它的任何超集也不是频繁的</li>
</ul>
</li>
<li><p><strong>由低阶频繁项集构造高阶频繁项集</strong></p>
</li>
</ul>
<h3 id="关联分析示例"><a href="#关联分析示例" class="headerlink" title="关联分析示例"></a>关联分析示例</h3><ul>
<li>表格如下</li>
</ul>
<table>
<thead>
<tr>
<th align="center">TID</th>
<th align="center">项集</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">面包，牛奶</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">面包，啤酒，鸡蛋，尿布</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">牛奶，啤酒，尿布，可乐</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">面包，牛奶，啤酒，尿布</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">面包，牛奶，尿布，可乐</td>
</tr>
</tbody></table>
<ul>
<li>结果<ul>
<li>尿布 $\to$ 啤酒<br>  支持度 $\dfrac35$，置信度 $\dfrac34$<br>  啤酒 $\to$ 尿布<br>  支持度 $\dfrac35$，置信度 $\dfrac33$</li>
</ul>
</li>
</ul>
<h4 id="先验法则求解"><a href="#先验法则求解" class="headerlink" title="先验法则求解"></a>先验法则求解</h4><ul>
<li>设定最小支持度为 3</li>
<li>依次寻找一阶项、二阶项、三阶项</li>
</ul>
<table>
<thead>
<tr>
<th align="center">1阶项</th>
<th align="center">计数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">啤酒</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">面包</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">可乐</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">尿布</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">牛奶</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">鸡蛋</td>
<td align="center">1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">2阶项</th>
<th align="center">计数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">啤酒, 面包</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">啤酒, 尿布</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">啤酒, 牛奶</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">面包, 尿布</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">面包, 牛奶</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">尿布, 牛奶</td>
<td align="center">3</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">3阶项</th>
<th align="center">计数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">面包, 尿布, 牛奶</td>
<td align="center">3</td>
</tr>
</tbody></table>
<h3 id="关联分析算法过程"><a href="#关联分析算法过程" class="headerlink" title="关联分析算法过程"></a>关联分析算法过程</h3><h4 id="连接步"><a href="#连接步" class="headerlink" title="连接步"></a>连接步</h4><ul>
<li>对 K-1 阶频繁项集 Lk-1 做 Self-Join 操作，形成 K 阶频繁项集的候选集 Ck<ul>
<li>前 K-1 项相同，第 K 项 p&lt;q（避免重复）</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ck</span><br><span class="line"><span class="keyword">select</span> p.item1, p.item2, ... , p.itemk<span class="number">-1</span>, q.itemk<span class="number">-1</span></span><br><span class="line"><span class="keyword">from</span> Lk<span class="number">-1</span>p,Lk<span class="number">-1</span>q</span><br><span class="line"><span class="keyword">where</span> p.item1<span class="operator">=</span>q.item1, ... , p.itemk<span class="number">-2</span><span class="operator">=</span>q.itemk<span class="number">-2</span>, p.itemk<span class="number">-1</span><span class="operator">&lt;</span>q.itemk<span class="number">-1</span></span><br></pre></td></tr></table></figure>



<h4 id="剪枝步"><a href="#剪枝步" class="headerlink" title="剪枝步"></a>剪枝步</h4><ul>
<li>任何 K-1 阶非频繁项集，则其不可能为 K 阶频繁项集的子集</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">all</span> itemsets c <span class="keyword">in</span> Ck do:</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">all</span> (k-<span class="number">1</span>)-subsets s of c do:</span><br><span class="line">        <span class="keyword">if</span>(s <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> Lk-<span class="number">1</span>):</span><br><span class="line">            then delete c <span class="keyword">from</span> Ck</span><br></pre></td></tr></table></figure>



<h3 id="关联分析算法例子"><a href="#关联分析算法例子" class="headerlink" title="关联分析算法例子"></a>关联分析算法例子</h3><ul>
<li>3 阶高频项目集：L3&#x3D;{ abc, abd, acd, ace, bcd }</li>
<li>连接步<ul>
<li>Self-joining:L3*L3</li>
<li>abc, abd $\to$ abcd</li>
<li>acd, ace $\to$ acde</li>
</ul>
</li>
<li>剪枝步 acde 移出，因为 ade 不包含在 L3 中</li>
<li>4 阶候选集：C4&#x3D;{ abcd }<ul>
<li>还得在数据库中验证之后才能称为 4 阶高频项目集</li>
</ul>
</li>
</ul>
<h3 id="SQL-实现"><a href="#SQL-实现" class="headerlink" title="SQL 实现"></a>SQL 实现</h3><ul>
<li>最核心的问题：<strong>如何实现对候选集的计数</strong></li>
<li>论文：Integrating Association Rule Mining with Relational Database Systems: Alternatives and Implications</li>
</ul>
<h4 id="基于连接实现"><a href="#基于连接实现" class="headerlink" title="基于连接实现"></a>基于连接实现</h4><ul>
<li>K-ways joins</li>
<li>代码</li>
</ul>
<p><img src="/08/image-20210613140959356.png"></p>
<ul>
<li>图示</li>
</ul>
<p><img src="/08/image-20210613141012312.png"></p>
<h4 id="基于子查询实现"><a href="#基于子查询实现" class="headerlink" title="基于子查询实现"></a>基于子查询实现</h4><ul>
<li>subquery</li>
<li>代码</li>
</ul>
<p><img src="/08/image-20210613141317487.png"></p>
<ul>
<li>图示</li>
</ul>
<p><img src="/08/image-20210613141337247.png"></p>
<h4 id="基于面向对象的-SQL-实现"><a href="#基于面向对象的-SQL-实现" class="headerlink" title="基于面向对象的 SQL 实现"></a>基于面向对象的 SQL 实现</h4><ul>
<li>代码</li>
</ul>
<p><img src="/08/image-20210613141413985.png"></p>
<ul>
<li>图示</li>
</ul>
<p><img src="/08/image-20210613141506870.png"></p>
<h3 id="关联分析和相关性分析"><a href="#关联分析和相关性分析" class="headerlink" title="关联分析和相关性分析"></a>关联分析和相关性分析</h3><ul>
<li>实际可能是负相关</li>
</ul>
<img src="08/image-20210613142232147.png" style="zoom:67%;" />



<h3 id="关联分析的辛普森悖论"><a href="#关联分析的辛普森悖论" class="headerlink" title="关联分析的辛普森悖论"></a>关联分析的辛普森悖论</h3><ul>
<li>数据子集显示出来的结果和数据集本身相反</li>
<li>数据集</li>
</ul>
<img src="08/image-20210613142457403.png" style="zoom:67%;" />

<ul>
<li>数据子集</li>
</ul>
<img src="08/image-20210613142538884.png" alt="image-20210613142600824" style="zoom:67%;" />

<ul>
<li>原因</li>
</ul>
<p>$$<br>\begin{align}<br>\dfrac{a}{b}&amp;&lt;\dfrac{c}{d}\<br>\dfrac{p}{q}&amp;&lt;\dfrac{r}{s}\<br>\dfrac{a+p}{b+q}&amp;&lt;\dfrac{c+r}{d+s}\<br>\end{align}<br>$$</p>
<ul>
<li>提示：数据子集的划分要仔细，否则可能得出相反结论<ul>
<li>连锁超市的购物篮应按商店位置分层</li>
<li>病人医疗记录应按年龄、性别等分层</li>
</ul>
</li>
</ul>
<h4 id="序列关联分析"><a href="#序列关联分析" class="headerlink" title="序列关联分析"></a>序列关联分析</h4><h2 id="分类分析"><a href="#分类分析" class="headerlink" title="分类分析"></a>分类分析</h2><ul>
<li>决策树</li>
<li>朴素贝叶斯</li>
<li>支持向量机 SVM</li>
</ul>
<h2 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h2><ul>
<li>无监督学习</li>
<li>基于划分</li>
<li>K-means</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/13/DB/CLJ/08/" data-id="cl9lj74az00gb64tzefdsbhxt" data-title="数据库概论.陈立军.08.数据挖掘简述" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/CLJ/07-3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/13/DB/CLJ/07-3/" class="article-date">
  <time class="dt-published" datetime="2021-06-12T16:20:17.000Z" itemprop="datePublished">2021-06-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/13/DB/CLJ/07-3/">数据库概论.陈立军.07.并发控制(4)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><ul>
<li>传统的数据库，Oracle、SQL Server 都是基于封锁来实现的，但是也有其他的并发控制方式</li>
</ul>
<h2 id="基于时间戳的协议"><a href="#基于时间戳的协议" class="headerlink" title="基于时间戳的协议"></a>基于时间戳的协议</h2><ul>
<li><strong>时间戳</strong><ul>
<li>每个事务 Ti 进入系统被分配一个时间戳 TS(Ti)</li>
<li>如果 Tj 晚于 Ti 进入系统，TS(Ti)&lt;TS(Tj)</li>
<li>回滚的事务重新启动，分配新的时间戳</li>
</ul>
</li>
<li>时间戳顺序决定了串行化顺序，<strong>回滚违反发出串行性操作的事务</strong><ul>
<li><strong>整个调度必须和按照他们的时间戳顺序的串行调度等价</strong></li>
<li>检测冲突，一旦检测到冲突，则按照上述规则回滚某个事务</li>
</ul>
</li>
<li>每个数据项Q有两个时间戳与之联系<ul>
<li>数据项上的读写时间戳，数据项上的读写时间戳是所有操作该数据项的事务中最大的时间戳</li>
<li>WT(Q)：执行 write(Q) 的事务中最大的时间戳</li>
<li>RT(Q)：执行 read(Q) 的事务中最大的时间戳</li>
</ul>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="可能的脏读"><a href="#可能的脏读" class="headerlink" title="可能的脏读"></a>可能的脏读</h4><ul>
<li>start1, w1(R), start2, r2(R), abort_t1</li>
<li>T1 事务回滚了，T2 事务读到的 R 是 T1 写的 R，是脏读（不是正确的数据项）</li>
<li>解决方案：为每一个数据项设置一个提交位<ul>
<li><strong>提交位</strong> C(R)：拥有 R 上写时间戳的事务是否提交</li>
<li>r2(R) 发现 R 上的提交位没有被设置为 1（尚未被提交），此时等待</li>
</ul>
</li>
</ul>
<h4 id="跳过的写"><a href="#跳过的写" class="headerlink" title="跳过的写"></a>跳过的写</h4><ul>
<li>start1, start2, w2(R), w1(R)<ul>
<li>与时间戳顺序等价的串行调度为：start1, start2, w1(R), w2(R)</li>
<li>于是最后会检测到 w1(R) 不满足时间戳的协议，回滚掉事务 T1</li>
</ul>
</li>
<li>实际上我们没有必要回滚事务 T1，把 w1(R) 忽略掉即可<ul>
<li>满足时间戳的串行调度，w1(R) 在前面也会被覆盖，因此只需要把 w1(R) 忽略即可</li>
</ul>
</li>
</ul>
<h5 id="Thomas-写规则"><a href="#Thomas-写规则" class="headerlink" title="Thomas 写规则"></a>Thomas 写规则</h5><ul>
<li>写操作在更晚的写操作已经发生时可以跳过</li>
</ul>
<h3 id="执行时间戳协议"><a href="#执行时间戳协议" class="headerlink" title="执行时间戳协议"></a>执行时间戳协议</h3><h4 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4><ul>
<li>假定事务 Ti 发出 read(Q)</li>
</ul>
<h5 id="过晚的读"><a href="#过晚的读" class="headerlink" title="过晚的读"></a>过晚的读</h5><ul>
<li>本来应该是在别人写之前读，但是别人写完你才读</li>
<li>如果 TS(Ti)&lt;WT(Q)，则 Ti 需读入的值已经被覆盖，read 操作被拒绝，<strong>回滚 Ti</strong></li>
<li>start1, start2, w2(R), r1(R)<ul>
<li>此时 r1(R) 已经违反了时间戳协议，回滚事务 T1</li>
</ul>
</li>
</ul>
<h5 id="正常的读"><a href="#正常的读" class="headerlink" title="正常的读"></a>正常的读</h5><ul>
<li>正常的读 TS(Ti) $\ge$ WT(Q)</li>
<li>若 C(Q) 为真则执行 read 操作，RT(Q) &#x3D; max(RT(Q),TS(Ti))，若为假则推迟到 C(Q) 为真或写 Q 的事务中止</li>
<li>start2, start1, w2(R), r1(R)</li>
</ul>
<h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><ul>
<li>假定事务 Ti 发出 write(Q)</li>
</ul>
<h5 id="过晚的写"><a href="#过晚的写" class="headerlink" title="过晚的写"></a>过晚的写</h5><ul>
<li>本来应该是在别人读之前写，但是别人读完你才写</li>
<li>如果 TS(Ti)&lt;RT(Q)，则 Ti 产生的 Q 值是先前所需要的值，write 操作被拒绝，回滚Ti</li>
<li>start1, start2, r2(R), w1(R)<ul>
<li>此时 w1(R) 不满足时间戳协议，回滚事务 T1</li>
</ul>
</li>
</ul>
<h5 id="正常的写"><a href="#正常的写" class="headerlink" title="正常的写"></a>正常的写</h5><ul>
<li>正常的写：TS(Ti) &gt; RT(Q)</li>
<li>TS(Ti) &gt; RT(Q)，并且 TS(Ti) &gt; WT(Q)，执行write操作，WT(Q)＝TS(Ti)</li>
<li>start1, start2, start3, r1(R), w2(R), w3(R)</li>
</ul>
<h5 id="忽略的写"><a href="#忽略的写" class="headerlink" title="忽略的写"></a>忽略的写</h5><ul>
<li>Thomas 写规则</li>
<li>TS(Ti) &gt; RT(Q)，但是TS(Ti) &lt; WT(Q)，跳过 write 操作</li>
<li>start1, start2, start3, w2(R), r3(R), w1(R)</li>
<li>跳过 w1(R) 操作</li>
</ul>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
<th align="center">T3</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td align="center">150</td>
<td align="center">175</td>
<td align="center">RT&#x3D;0<br />WT&#x3D;0</td>
<td align="center">RT&#x3D;0<br />WT&#x3D;0</td>
<td align="center">RT&#x3D;0<br />WT&#x3D;0</td>
</tr>
<tr>
<td align="center">r1(B)</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">RT&#x3D;200</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">r2(A)</td>
<td align="center"></td>
<td align="center">RT&#x3D;150</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">r3(C)</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">RT&#x3D;175</td>
</tr>
<tr>
<td align="center">w1(B)</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">WT&#x3D;200</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">w1(A)</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">WT&#x3D;200</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">w2(C)</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">RT&#x3D;0</td>
<td align="center">过晚的写<br />回滚T2</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">中止</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">w3(A)</td>
<td align="center">忽略的写</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="有效性检查协议"><a href="#有效性检查协议" class="headerlink" title="有效性检查协议"></a>有效性检查协议</h2><ul>
<li>把事务的过程分为 3 个阶段<ul>
<li>读阶段、有效性检查阶段、写阶段</li>
</ul>
</li>
</ul>
<h3 id="三阶段"><a href="#三阶段" class="headerlink" title="三阶段"></a>三阶段</h3><h4 id="读阶段"><a href="#读阶段" class="headerlink" title="读阶段"></a>读阶段</h4><ul>
<li><p>事务 Ti 在这一阶段中执行</p>
</li>
<li><p>各数据项值被读入并保存在 Ti 的<strong>局部变量</strong>中</p>
</li>
<li><p><strong>所有 write 操作都是对局部临时变量进行的，并不对数据库进行真正的更新</strong></p>
</li>
</ul>
<h4 id="有效性检查阶段"><a href="#有效性检查阶段" class="headerlink" title="有效性检查阶段"></a>有效性检查阶段</h4><ul>
<li>Ti 进行有效性检查，通过与其他事务的读写集合进行比较，来判定是否可以将 write 操作所更新的临时局部变量值拷入数据库而不违反可串行性</li>
</ul>
<h4 id="写阶段"><a href="#写阶段" class="headerlink" title="写阶段"></a>写阶段</h4><ul>
<li>若 Ti 通过有效性检查，则进行实际的数据库更新，否则 Ti 回滚</li>
</ul>
<h3 id="三个时间戳"><a href="#三个时间戳" class="headerlink" title="三个时间戳"></a>三个时间戳</h3><ul>
<li>每个事务 Ti 有 <strong>3</strong> 个时间戳与之联系<ul>
<li>Start(Ti)：Ti <strong>开始</strong>执行的时间</li>
<li>Validation(Ti)：Ti <strong>进入</strong>其有效性检查阶段的时间</li>
<li>Finish(Ti)：Ti <strong>完成</strong>其写阶段的时间</li>
</ul>
</li>
<li>令TS(Ti) &#x3D; Validation(Ti)，等价的串行顺序与有效性确认时间戳一致</li>
</ul>
<h3 id="违反串行性的情况"><a href="#违反串行性的情况" class="headerlink" title="违反串行性的情况"></a>违反串行性的情况</h3><h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则 1"></a>规则 1</h4><ul>
<li>${\color{red}\mathrm{if}};\mathrm{finish(U)&gt;start(T)};{\color{red}\mathrm{then}};\mathrm{RS(T)\bigcap WS(U)&#x3D;\Phi}$</li>
<li>避免过早地读</li>
</ul>
<img src="07-3/image-20210613110906866.png" style="zoom:67%;" />



<h4 id="规则-2"><a href="#规则-2" class="headerlink" title="规则 2"></a>规则 2</h4><ul>
<li>${\color{red}\mathrm{if}};\mathrm{finish(U)&gt;validation(T)};{\color{red}\mathrm{then}};\mathrm{WS(T)\bigcap WS(U)&#x3D;\Phi}$</li>
<li>避免过早的写</li>
</ul>
<img src="07-3/image-20210613111322706.png" style="zoom:67%;" />



<h3 id="一个有效性检查的例子"><a href="#一个有效性检查的例子" class="headerlink" title="一个有效性检查的例子"></a>一个有效性检查的例子</h3><img src="07-3/image-20210613112124549.png" style="zoom:67%;" />

<ul>
<li>确认T2：在T1完成写入之前开始，可能先于T1的写入进行读写，需要判断T1的写集合与T2读集合的相交性，同时判断T1的写集合与T2的写集合的相交性<ul>
<li>写判断，防止 T2 的写在 T1 之前</li>
</ul>
</li>
<li>确认T3：在T1完成写入之后开始，不需要判定T3和T1的相交性；在T2完成写入之前开始，需要判断T2的写集合与T3读集合的相交性；T2在T3确认前完成，不需要判定T3的写集合和T2的写集合的相交性</li>
</ul>
<h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><img src="07-3/image-20210613112605153.png" style="zoom:67%;" />

<ul>
<li>确认 U<ul>
<li>最早的确认，通过</li>
</ul>
</li>
<li>确认 T<ul>
<li>U 写、T 读：通过</li>
<li>U 写、T 写：通过</li>
</ul>
</li>
<li>确认 V<ul>
<li>U 写、V 读：通过</li>
<li>T 写、V 读：通过</li>
<li>T 写、V 写：通过</li>
</ul>
</li>
<li>确认 W<ul>
<li>W 读之前，U 已经 finish，不需要比较</li>
<li>T 写、W 读：<strong>未通过</strong></li>
<li>V 写、W 写：通过</li>
<li>V 写、W 读：<strong>未通过</strong></li>
</ul>
</li>
</ul>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><ul>
<li>MVCC：Multiple Version Concurrent Control</li>
<li>以下是 MySQL 对于 MVCC 的实现</li>
</ul>
<h2 id="MySQL-一致性非锁定读"><a href="#MySQL-一致性非锁定读" class="headerlink" title="MySQL 一致性非锁定读"></a>MySQL 一致性非锁定读</h2><ul>
<li>一致性非锁定读（consistent nonlocking read）</li>
<li>多版本实现的并发控制</li>
</ul>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>在 read committed 和 repeatable read 下 InnoDB 使用非锁定的一致性读</li>
<li>read committed 的非一致性读总是读取被锁定行的<strong>最新</strong>一份快照数据<ul>
<li><strong>语句开始的版本</strong></li>
</ul>
</li>
<li>repeatable read 的非一致性读总是读取<strong>事务开始</strong>时的行数据版本</li>
</ul>
<h3 id="三个隐藏列"><a href="#三个隐藏列" class="headerlink" title="三个隐藏列"></a>三个隐藏列</h3><ul>
<li>InnoDB 为每行数据增加三个隐藏列用于实现 MVCC</li>
<li>DB_TRX_ID<ul>
<li>插入或更新行的<strong>最后一个事务的事务标识符（</strong>删除视为更新，将其标记为已删除）</li>
</ul>
</li>
<li>DB_ROLL_PTR<ul>
<li>写入回滚段的撤消日志记录（若行已更新，则撤消日志记录包含在更新行之前重建行内容所需的信息）</li>
<li>将所有的老版本通过一个指针串起来</li>
</ul>
</li>
<li>DB_ROW_ID：行标识（隐藏单调自增id）</li>
<li><strong>快照存放在日志 undo 段中</strong></li>
<li>InnoDB 新版本的数据是叶子结点的值，老版本的数据则通过 UNDO 记录存储在回滚段（Rollback Segment）中</li>
</ul>
<img src="07-3/image-20210613115931178.png" style="zoom: 40%;" />



<h3 id="可见性算法"><a href="#可见性算法" class="headerlink" title="可见性算法"></a>可见性算法</h3><ul>
<li>read-view：事务在进行快照读的时候会创建一个读视图</li>
<li>在执行读操作的时候，基于读视图判定当前行对于读操作是否可见</li>
<li>一些数据段<ul>
<li>alive_trx_list：读视图生成时刻系统中正在活跃的事务 id</li>
<li>up_limit_id：记录上面的 alive_trx_list 中的最小事务 id（最老的事务）</li>
<li>low_limit_id：读视图生成时刻，目前已出现的事务 ID 的最大值 +1</li>
</ul>
</li>
<li>判定<ul>
<li>判断这条记录的 DB_TRX_ID 是否是小于 up_limit_id 或者等于当前事务 id<ul>
<li>若是，则当前事务能看到这条记录</li>
</ul>
</li>
<li>判断这条记录的 DB_TRX_ID 是否大于等于 low-limit-id<ul>
<li>如果大于等于则说明此事务无法看见该条记录</li>
</ul>
</li>
<li>判断该条记录的 DB_TRX_ID 是否在活跃事务的数组中<ul>
<li>如果在则说明这条记录还未提交，对于当前操作的事务是不可见的</li>
<li>如果不在则说明已经提交，则是可见的<ul>
<li>这种情况是当前事务一开始之后很短的时间内，开始后很快就提交了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/07-3/image-20210613120615944.png"></p>
<ul>
<li>对于 read  committed 来说，每读一次都会生成新的读视图</li>
<li>对于 repeatable read 来说，读视图时是事务一开始就确定不变的</li>
</ul>
<h3 id="PG-与-MySQL-写操作的不同"><a href="#PG-与-MySQL-写操作的不同" class="headerlink" title="PG 与 MySQL 写操作的不同"></a>PG 与 MySQL 写操作的不同</h3><ul>
<li>PG 对写操作也是乐观并发控制<ul>
<li><strong>在表中保存同一行数据记录的多个不同版本</strong>，每次写操作，都是创建，而回避更新<ul>
<li>PG 有表膨胀的问题</li>
<li>MySQL 把老版本放在回滚段里</li>
</ul>
</li>
<li>在事务提交时，按版本号检查当前事务提交的数据是否存在写冲突，抛异常告知用户，回滚事务</li>
</ul>
</li>
<li>innodb 只对读无锁，写操作仍是上锁的悲观并发控制<ul>
<li>每行数据只在表中保留一份，在更新数据时上行锁，同时将旧版数据写入 undo log</li>
<li>表和 undo log 中行数据都记录着事务 ID，在检索时，只读取来自当前已提交的事务的行数据</li>
</ul>
</li>
</ul>
<h3 id="SQL-Server-中查看多版本"><a href="#SQL-Server-中查看多版本" class="headerlink" title="SQL Server 中查看多版本"></a>SQL Server 中查看多版本</h3><ul>
<li>tempdb</li>
</ul>
<img src="07-3/image-20210613122121649.png" style="zoom:50%;" />

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> database ljchen</span><br><span class="line"><span class="keyword">set</span> allow_snapshot_isolation <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> faculty</span><br><span class="line"><span class="keyword">set</span> salary<span class="operator">=</span>salary<span class="operator">*</span><span class="number">1.01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> sys.dm_tran_version_store</span><br></pre></td></tr></table></figure>



<h3 id="MVCC-论文"><a href="#MVCC-论文" class="headerlink" title="MVCC 论文"></a>MVCC 论文</h3><ul>
<li>An Empirical Evaluation of In-Memory Multi-Version Concurrency Control</li>
<li>设计要点<ul>
<li>并发控制 (ConcurrencyControl)</li>
<li>版本存储 (VersionStorage)</li>
<li>垃圾回收 (GarbageCollection)</li>
<li>索引管理 (Indexmanagement)</li>
</ul>
</li>
</ul>
<h2 id="MySQL-一致性锁定读"><a href="#MySQL-一致性锁定读" class="headerlink" title="MySQL 一致性锁定读"></a>MySQL 一致性锁定读</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对读取的行加 X 锁 */</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对读取的行加 S 锁 */</span></span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode</span><br></pre></td></tr></table></figure>

<img src="07-3/image-20210613121728756.png" style="zoom:67%;" />
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/13/DB/CLJ/07-3/" data-id="cl9lj74az00g764tzf5hk8yml" data-title="数据库概论.陈立军.07.并发控制(4)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/CLJ/07-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/12/DB/CLJ/07-2/" class="article-date">
  <time class="dt-published" datetime="2021-06-12T13:22:35.000Z" itemprop="datePublished">2021-06-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/12/DB/CLJ/07-2/">数据库概论.陈立军.07.并发控制(3)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><h2 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h2><ul>
<li><strong>锁管理器</strong>、<strong>锁表</strong></li>
<li>锁管理器<ul>
<li>事务向锁管理器发送封锁请求和释放请求</li>
<li>锁管理器维护一个锁表记录锁的授予情况和处于等待状态的封锁请求</li>
</ul>
</li>
<li>锁表<ul>
<li>锁表一般作为内存中的 hash 表，按被封锁对象的名字建立索引</li>
</ul>
</li>
</ul>
<h3 id="锁表结构"><a href="#锁表结构" class="headerlink" title="锁表结构"></a>锁表结构</h3><ul>
<li>内存中的哈希表</li>
</ul>
<img src="07-2/image-20210612214643658.png" style="zoom:67%;" />

<ul>
<li>黑矩形表示已被授予的锁，白色表示等待的封锁请求</li>
<li>锁表同时记录锁的类型<ul>
<li>需要检查锁是否想容</li>
</ul>
</li>
<li>新的封锁请求加到对应请求队列的<strong>末尾</strong>，当封锁请求与前面的锁相容时被批准</li>
<li><strong>释放</strong>封锁时请求从队列中<strong>删除</strong>并<strong>检查后续请求是否满足</strong></li>
<li>如果<strong>事务放弃</strong>，<strong>所有授予的和等待的锁请求都被删除</strong><ul>
<li>为提高效率，<strong>锁管理器会记录每个事务持有锁的情况</strong></li>
<li>红线：把一个事务所有的锁串成一个链</li>
</ul>
</li>
<li>封锁资源如下<ul>
<li>但是锁管理器对资源一无所知，它只是 ”memcmp()”</li>
<li>锁管理器不需要去区分被锁的是什么逻辑单元，只需要将这个字符串锁起来即可</li>
</ul>
</li>
</ul>
<img src="07-2/image-20210612215429062.png" style="zoom:67%;" />



<h3 id="锁升级（SQL-Server）"><a href="#锁升级（SQL-Server）" class="headerlink" title="锁升级（SQL Server）"></a>锁升级（SQL Server）</h3><ul>
<li>这里的锁升级不是强度上的升级（读锁升级为写锁），而是粒度上的升级（行锁升级为表锁）</li>
<li><strong>行锁太多的时候</strong>，我们可以把这些行锁升级为表锁</li>
<li>封锁开销与并发度的 trade off</li>
</ul>
<img src="07-2/image-20210612215648266.png" style="zoom:67%;" />

<ul>
<li>行锁代价高、并发度高</li>
<li>表锁代价低、并发度低</li>
</ul>
<h4 id="锁升级的定义与操作"><a href="#锁升级的定义与操作" class="headerlink" title="锁升级的定义与操作"></a>锁升级的定义与操作</h4><ul>
<li>锁升级是将<strong>众多细粒度锁</strong>转换为<strong>较少的粗粒度的锁</strong>的过程，以削减系统开销</li>
<li>当事务超过它的升级极限时，系统自动将行锁和页锁升级为表锁</li>
<li>当事务从表中请求行时，系统获取相应行上的锁，并在包含这些行的页和表上放置意向锁。当事务控制的锁数量超过其极限时，系统将表上的意向锁更改为更强的锁（如将IX锁更改为X锁），释放事务持有的所有页级锁和行级锁，从而削减锁的开销。</li>
</ul>
<h3 id="MySQL-没有锁升级"><a href="#MySQL-没有锁升级" class="headerlink" title="MySQL 没有锁升级"></a>MySQL 没有锁升级</h3><ul>
<li>InnoDB 不存在锁升级的问题</li>
<li>InnoDB 不是根据每个记录来产生行锁，而是<strong>根据页进行加锁，并采用位图方式定位到行</strong>，锁住页中一个记录还是多个记录，其开销是一样的</li>
</ul>
<h4 id="开销对比"><a href="#开销对比" class="headerlink" title="开销对比"></a>开销对比</h4><ul>
<li>假设一张表有 $3\times10^6$ 个数据页，每个页大约有 $100$ 条记录，那么总共有 $3\times10^8$ 条记录。</li>
<li>若有一个事务执行全表更新的 SQL 语句，则需要对所有记录加 X 锁</li>
<li>若根据每行记录产生锁对象进行加锁，并且每个锁占用 $10$ 字节，则仅对锁管理就需要差不多需要 $3\mathrm{GB}$ 的内存</li>
<li>而 InnoDB 存储引擎根据页进行加锁，并采用位图方式，假设每个页存储的锁信息占用 $30$ 个字节，则锁对象仅需 $90\mathrm{MB}$ 的内存<ul>
<li>$30$ 字节：位图 $\dfrac{100}{8}&#x3D;12.5$，加上一些其他信息</li>
</ul>
</li>
<li>由此可见两者对于锁资源开销的差距之大</li>
</ul>
<h2 id="封锁带来的问题"><a href="#封锁带来的问题" class="headerlink" title="封锁带来的问题"></a>封锁带来的问题</h2><h3 id="死锁-Deadlock"><a href="#死锁-Deadlock" class="headerlink" title="死锁(Deadlock)"></a>死锁(Deadlock)</h3><ul>
<li>两个事务都封锁了一些数据对象，并相互等待对方释放另一些数据对象以便对其封锁，结果两个事务都不能结束，则发生死锁</li>
</ul>
<img src="07-2/image-20210612221909284.png" style="zoom: 33%;" />

<ul>
<li><p>死锁发生的条件（4）</p>
<ul>
<li>(1) <strong>互斥条件</strong>：事务请求对资源的独占控制</li>
<li>(2) <strong>占有等待条件</strong>：事务已持有一定资源，又去申请并等待其它资源</li>
<li>(3) <strong>非抢占条件</strong>：直到资源被持有它的事务释放之前，不能将该资源强制从持有它的事务夺去</li>
<li>(4) <strong>循环等待条件</strong>：存在事务相互等待的等待圈</li>
</ul>
</li>
<li><p>定理：<strong>在条件 (1)(2)(3) 成立的前提下，条件 (4) 是死锁存在的充分必要条件</strong></p>
</li>
</ul>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><table>
<thead>
<tr>
<th align="center"><strong>事务号</strong></th>
<th align="center"><strong>占有资源号</strong></th>
<th align="center"><strong>请求资源号</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">T1</td>
<td align="center">R1</td>
<td align="center">R2</td>
</tr>
<tr>
<td align="center">T2</td>
<td align="center">R3</td>
<td align="center">R1，R2</td>
</tr>
<tr>
<td align="center">T3</td>
<td align="center">R2</td>
<td align="center">R3</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">T1[T1]---&gt;T3[T3]</span><br><span class="line">T2---&gt;T1</span><br><span class="line">T2---&gt;T3</span><br><span class="line">T3---&gt;T2</span><br></pre></td></tr></table></figure>

<ul>
<li>在数据库中定期扫描锁表，如果发现死锁，则破坏第 3 个条件（回滚某个事务）<ul>
<li>系统同时会向这个事务发送一个信号</li>
<li>SQL Server：<strong>1205</strong></li>
</ul>
</li>
</ul>
<h4 id="循环死锁例子"><a href="#循环死锁例子" class="headerlink" title="循环死锁例子"></a>循环死锁例子</h4><table>
<thead>
<tr>
<th align="center">事务1</th>
<th align="center">事务2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin tran<br/>update S<br/>set sname&#x3D; ‘张三’<br/>where sno&#x3D; ‘ S1’</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">begin tran<br/>update C<br/>set cname&#x3D; ‘数据库基础’<br/>where cno&#x3D; ‘ c1’</td>
</tr>
<tr>
<td align="center">update C<br/>set cname&#x3D; ‘数据库教程’<br/>WHERE cno&#x3D; ‘ c1’<br/>commit tran</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">update S<br/>set sname&#x3D; ‘李四’<br/>where sno&#x3D; ‘ S1’<br/>commit tran</td>
</tr>
</tbody></table>
<h4 id="转换死锁例子"><a href="#转换死锁例子" class="headerlink" title="转换死锁例子"></a>转换死锁例子</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> transaction isolation level repeatable read</span><br><span class="line"><span class="keyword">begin</span> tran</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> sno<span class="operator">=</span><span class="string">&#x27;S1&#x27;</span></span><br><span class="line">waitfor delay <span class="string">&#x27;00:00:10&#x27;</span></span><br><span class="line"><span class="keyword">update</span> S</span><br><span class="line"><span class="keyword">set</span> sname<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span></span><br><span class="line"><span class="keyword">where</span> sno<span class="operator">=</span><span class="string">&#x27;S1&#x27;</span></span><br><span class="line"><span class="keyword">commit</span> tran</span><br></pre></td></tr></table></figure>

<ul>
<li><p>两个事务都执行如上代码，都是先读后写，死锁</p>
</li>
<li><p>解决方案</p>
<ul>
<li>调整事务的隔离性级别</li>
<li>强制 SQL Server 使用更新锁</li>
</ul>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> S (UPDLOCK)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="因缺少索引而导致死锁"><a href="#因缺少索引而导致死锁" class="headerlink" title="因缺少索引而导致死锁"></a>因缺少索引而导致死锁</h4><ul>
<li>扫描全表导致的相互阻塞</li>
<li>可以通过显示锁表展示死锁信息</li>
</ul>
<table>
<thead>
<tr>
<th align="center">事务1</th>
<th align="center">事务2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin tran<br/>update T1<br/>set col1 &#x3D; ‘a’<br/>where id &#x3D; 101</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">begin tran<br/>update T2<br/>set col2 &#x3D; ‘a’<br/>where id &#x3D; 201</td>
</tr>
<tr>
<td align="center">select col2<br/>from T2<br/>where id &#x3D; 203</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select col1<br/>from T1<br/>where id &#x3D; 103</td>
</tr>
</tbody></table>
<h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><h4 id="破坏占有等待条件"><a href="#破坏占有等待条件" class="headerlink" title="破坏占有等待条件"></a>破坏占有等待条件</h4><ul>
<li>死锁根源：T1 持有 R1，申请 R2；T2 持有 R2，申请 R1</li>
<li><strong>预先占据所需的全部资源</strong><ul>
<li>要么一次全部封锁，要么全不封锁</li>
<li>缺点：<strong>难于预知需要封锁哪些数据并且数据使用率低</strong></li>
</ul>
</li>
<li><strong>所有资源预先排序，事务按规定顺序封锁数据</strong><ul>
<li>按照相同的资源顺序获取锁</li>
<li>不允许 T3 在没有获得资源 R1 时就去获取 R3</li>
</ul>
</li>
</ul>
<img src="07-2/image-20210612225653498.png" style="zoom:67%;" />



<h4 id="破坏非抢占条件"><a href="#破坏非抢占条件" class="headerlink" title="破坏非抢占条件"></a>破坏非抢占条件</h4><ul>
<li>人为规定一个优先级，将非抢占式转化为抢占式</li>
<li><strong>使用抢占与事务回滚</strong><ul>
<li><strong>规定老事务优先级高于新事务</strong></li>
</ul>
</li>
<li>下图为例，不允许两个箭头同时出现即可</li>
</ul>
<img src="07-2/image-20210612231229609.png" style="zoom:50%;" />

<ul>
<li>死锁序列<ul>
<li>start(T1), start(T2), w1(R1), w2(R2), r1(R2), r2(R1)</li>
</ul>
</li>
<li><strong>注意以下两种策略，在任何时候都是回滚优先级低的新事物</strong></li>
<li>策略1：<strong>wait-die</strong><ul>
<li>如果 T1 等待 T2，仅当 T1 的时间戳小于 T2 时，允许 T1 等待，否则回滚 T1</li>
<li>执行结果：r2(R1) 时触发，回滚 T2</li>
</ul>
</li>
</ul>
<img src="07-2/image-20210612231540349.png" style="zoom:50%;" />

<ul>
<li>策略2：<strong>wound-wait</strong><ul>
<li>如果 T1 等待 T2，仅当 T1 的时间戳大于 T2 时，允许 T1 等待，否则回滚 T2</li>
<li>r1(R2) 时触发，回滚 T2</li>
</ul>
</li>
</ul>
<img src="07-2/image-20210612231658264.png" style="zoom:50%;" />

<ul>
<li>在实际数据库中以上的预防方法都不适用，一般都是通过死锁检测找到死锁，然后接触死锁<ul>
<li><strong>超时法</strong>：如果等待封锁的时间超过限时，则撤消该事务</li>
<li><strong>等待图法</strong>：LOCK_MONITOR</li>
</ul>
</li>
</ul>
<h3 id="活锁-live-lock"><a href="#活锁-live-lock" class="headerlink" title="活锁(live lock)"></a>活锁(live lock)</h3><ul>
<li>可能存在某个事务永远处于等待状态，得不到执行，称之为<strong>活锁（饿死）</strong></li>
<li>饥饿例子：读者优先策略<ul>
<li>T2 持有对 R 的 S 锁，T1 申请对 R 的 X 锁，则 T1 必须等待 T2 释放 S 锁；若在 T2 完成之前有 T3 申请对 R 的 S 锁，则可以获得授权封锁，于是 T1 必须等待 T2、T3 释放 S 锁</li>
</ul>
</li>
<li>避免活锁的策略是遵从“<strong>先来先服务”</strong> 的原则，按请求封锁的顺序对各事务排队<ul>
<li>降低了系统的并发度（总吞吐量）</li>
</ul>
</li>
<li>先来先服务<ul>
<li>当事务 Ti 对数据项 R 加 M 型锁时，获得封锁的条件是<ul>
<li>不存在在 R 上持有与 M 型锁冲突的锁的其他事务</li>
<li>不存在等待对 R 加锁且先于 Ti 申请加锁的事务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="使用绑定连接"><a href="#使用绑定连接" class="headerlink" title="使用绑定连接"></a>使用绑定连接</h2><ul>
<li>一个事务对应多个连接的需求</li>
<li><strong>绑定连接</strong><ul>
<li>绑定连接允许两个或多个连接共享同一个事务和锁定</li>
<li>绑定连接可以对同一个数据进行操作，而不会有锁冲突</li>
</ul>
</li>
<li>把不同的连接上的操作绑定在同一个事务中<ul>
<li>sp_getbindtoken：返回事务的唯一标识符，将其作为绑定令牌</li>
<li>sp_bindsession：绑定与同一 SQL Server 实例中的其它事务的连接</li>
</ul>
</li>
</ul>
<h2 id="锁定提示"><a href="#锁定提示" class="headerlink" title="锁定提示"></a>锁定提示</h2><ul>
<li>一般而言，操作加的锁是由数据库系统本身决定的，但是我们可以添加一些要求加什么锁的提示</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> table_name[<span class="keyword">with</span> (lock hint)]</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">holdlock</td>
<td align="center">readuncommitted</td>
</tr>
<tr>
<td align="center">updlock</td>
<td align="center">readcommitted</td>
</tr>
<tr>
<td align="center">xlock</td>
<td align="center">repeatableread</td>
</tr>
<tr>
<td align="center">tablock</td>
<td align="center">serializable</td>
</tr>
<tr>
<td align="center">paglock</td>
<td align="center">readcommittedlock</td>
</tr>
<tr>
<td align="center">tablockx</td>
<td align="center">nolock</td>
</tr>
<tr>
<td align="center">rowlock</td>
<td align="center">readpast</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/12/DB/CLJ/07-2/" data-id="cl9lj74ay00g164tzdh4c2eca" data-title="数据库概论.陈立军.07.并发控制(3)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/YLQ-GAMES202/13" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/10/CG/YLQ-GAMES202/13/" class="article-date">
  <time class="dt-published" datetime="2021-06-10T07:18:41.000Z" itemprop="datePublished">2021-06-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES202/">CG.GAMES202</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/10/CG/YLQ-GAMES202/13/">GAMES202.闫令琪.13.实时光线追踪(2)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY">https://www.bilibili.com/video/BV1YK4y1T7yY</a></li>
</ul>
<h1 id="实时光线追踪"><a href="#实时光线追踪" class="headerlink" title="实时光线追踪"></a>实时光线追踪</h1><ul>
<li>空间滤波<ul>
<li>联合双边滤波</li>
<li>大 filter 的实现</li>
<li>outlier removal（离群值去除）</li>
</ul>
</li>
<li>RTRT 中的技术<ul>
<li>SVGF：Spatiotemporal Variance-Guided Filtering</li>
<li>RAE：Recurrent AutoEncoder</li>
</ul>
</li>
</ul>
<h2 id="空间滤波"><a href="#空间滤波" class="headerlink" title="空间滤波"></a>空间滤波</h2><h3 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h3><ul>
<li>实现的效果：降噪<ul>
<li>下图是椒盐噪声利用中值滤波实现的效果</li>
</ul>
</li>
</ul>
<img src="13/image-20210610164704899.png" style="zoom:80%;" />

<ul>
<li>这里我们想做的是低通滤波（low-pass）<ul>
<li>去除高频噪声<ul>
<li>高频中也有信号，同时会造成高频信号的丢失</li>
<li>还存在一些低频的噪声</li>
</ul>
</li>
<li>我们在空间域上进行</li>
</ul>
</li>
</ul>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><ul>
<li>一张带有噪声的图片 $\tilde{C}$</li>
<li>以可滤波核 $K$<ul>
<li>可以每个像素有不一样的滤波核</li>
</ul>
</li>
</ul>
<h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><ul>
<li>高斯滤波核<ul>
<li>周围值得贡献通过离中心点得距离决定</li>
<li>由高斯函数决定</li>
</ul>
</li>
</ul>
<p><img src="/13/image-20210610165435406.png"></p>
<ul>
<li>简单的伪代码实现<ul>
<li>注意高斯核 $K$ 的归一化（所有权值和为 1）<ul>
<li>伪代码中的 sum_of_weights</li>
<li>同样的我们之前学到的积分拆解，分母中有一个空积分，这也是为了归一化</li>
</ul>
</li>
<li>高斯核本身是无限大的，但是我们可以只考虑比较大贡献的值，例如 $3\sigma$ 截断</li>
<li>在有些算法实现的时候，会先判断一下 sum_of_weights 是否为 0（高斯这里不可能为 0，就不判断了）</li>
<li>颜色可以是多通道的，此时 sum_of_weights、sum_of_weighted_values 都是多通道的</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">For each pixel i:</span><br><span class="line">    sum_of_weights = sum_of_weighted_values = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># include i</span></span><br><span class="line">    For each pixel j around i:</span><br><span class="line">        Calculate the weight w_ij = G(|i - j|, sigma)</span><br><span class="line">        sum_of_weighted_values += w_ij * C^&#123;<span class="built_in">input</span>&#125;[j]</span><br><span class="line">        sum_of_weights += w_ij</span><br><span class="line">        C^&#123;output&#125;[I] = sum_of_weighted_values / sum_of_weights</span><br></pre></td></tr></table></figure>



<h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><ul>
<li>Bilateral Filtering</li>
<li>高斯滤波的问题<ul>
<li>图像一些高频细节也同时缺失了，例如边界也被模糊了</li>
<li>但是我们想要保留边界的信息</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.mathworks.com/help/images/ref/imgaussfilt.html">下图</a>是一个例子</li>
</ul>
<img src="13/image-20210610170430348.png" style="zoom: 67%;" />

<ul>
<li><p>双边滤波的目的就是在去噪的同时能够保持边界</p>
</li>
<li><p>基于我们生活中的观察</p>
<ul>
<li>边界：颜色变化非常剧烈</li>
</ul>
</li>
<li><p>idea：如何保持边界</p>
<ul>
<li>循环的时候我们看 j 点和 i 点的颜色是不是相差特别大<ul>
<li>如果相差不是特别大，我们使用原来高斯滤波的方式进行</li>
<li>如果相差特别大，我们就减小贡献值（减小权值）</li>
</ul>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.mathworks.com/help/images/ref/imgaussfilt.html">一种实现</a>如下</p>
<ul>
<li>两个点 $(i,j),(k,l)$</li>
<li>值差别过大的时候，那么贡献就会减小</li>
</ul>
</li>
</ul>
<p>$$<br>w(i,j,k,l)&#x3D;\exp\left(-\dfrac{(i-k)^2+(j-l)^2}{2\sigma_d^2}-\dfrac{\Vert I(i,j)-I(k,l)\Vert^2}{2\sigma_r^2}\right)<br>$$</p>
<ul>
<li>效果如下<ul>
<li>能够很好的保留边界信息</li>
<li>山内部的高频信息被抹掉了，但是边界信息保留了</li>
</ul>
</li>
</ul>
<p><img src="/13/image-20210610173346721.png"></p>
<ul>
<li>问题<ul>
<li>噪声很明显的图会出问题</li>
<li><strong>分不清噪声和边界</strong></li>
</ul>
</li>
</ul>
<h3 id="联合双边滤波"><a href="#联合双边滤波" class="headerlink" title="联合双边滤波"></a>联合双边滤波</h3><ul>
<li>Cross&#x2F;Joint Bilateral Filtering</li>
<li>观察<ul>
<li>高斯滤波：position distance</li>
<li>双边滤波：position distance + color distance</li>
</ul>
</li>
<li>于是我们可以用更多的标准，让结果更加接近我们想要的值</li>
<li>这就是联合双边滤波</li>
<li><strong>联合双边滤波对蒙特卡洛路径追踪算法得到图片的降噪效果很好</strong><ul>
<li><strong>Especially good at denoising path traced rendering results!</strong></li>
</ul>
</li>
<li>使用哪些信息呢？<ul>
<li><strong>G-Buffer</strong><ul>
<li>世界坐标</li>
<li>法向</li>
<li>albedo</li>
<li>object ID（每种物体标一个数字）：motion vector 中使用过</li>
</ul>
</li>
<li><strong>G-Buffer 本身是完全没有噪声的</strong><ul>
<li>和多次反射无关</li>
</ul>
</li>
</ul>
</li>
<li>和之前的滤波一样，不需要考虑归一化<ul>
<li>在实现的时候对滤波核进行归一化即可，函数不需要归一化</li>
</ul>
</li>
<li>也可以使用其他函数，不一定是高斯函数，只要随着距离有衰减就可以</li>
<li>高斯函数、指数函数、余弦函数</li>
</ul>
<img src="13/image-20210610205556276.png" style="zoom: 50%;" />

<ul>
<li>高斯也不需要是严格的高斯，系数什么的都可以变</li>
</ul>
<h4 id="联合双边滤波例子"><a href="#联合双边滤波例子" class="headerlink" title="联合双边滤波例子"></a>联合双边滤波例子</h4><ul>
<li>我们渲染得到了如下图片，同时得到了 G-Buffer 如下<ul>
<li>Depth</li>
<li>Normal</li>
<li>Color</li>
</ul>
</li>
</ul>
<img src="13/image-20210610205758226.png" style="zoom:67%;" />

<ul>
<li>如果我们需要保留边界，则可以使用如下信息作为标准（metric）</li>
<li>A-B：position + depth</li>
<li>B-C：position + normal</li>
<li>D-E：position + color<ul>
<li>有噪声的情况下可能会有些问题，color 可能是噪声</li>
</ul>
</li>
<li>具体哪一个标准占的权重大小由 $\sigma$ 调节<ul>
<li>比如上面双边滤波中的 $\sigma_d,\sigma_r$</li>
</ul>
</li>
</ul>
<h2 id="实现大的滤波核"><a href="#实现大的滤波核" class="headerlink" title="实现大的滤波核"></a>实现大的滤波核</h2><ul>
<li>Implementing Large Filters</li>
<li>我们在滤波的时候，<strong>如果滤波核特别大，计算开销就很大</strong></li>
</ul>
<h3 id="大滤波核的解决思路"><a href="#大滤波核的解决思路" class="headerlink" title="大滤波核的解决思路"></a>大滤波核的解决思路</h3><ul>
<li>FFT（快速傅里叶变化）在 GPU 上的优化做的并不好，因此还是基于空间域上的实现</li>
</ul>
<h4 id="1-拆分：Separate-Passes"><a href="#1-拆分：Separate-Passes" class="headerlink" title="(1) 拆分：Separate Passes"></a>(1) 拆分：Separate Passes</h4><ul>
<li>例如对一个高斯滤波，我们可以先水平方向做一次，然后在竖直方向做一次</li>
</ul>
<img src="13/image-20210610212405100.png" style="zoom: 67%;" />

<ul>
<li>对每一个像素，对周围点的查询次数由 $N^2$ 变成了 $2N$<ul>
<li>$N$ 为滤波核的大小</li>
</ul>
</li>
</ul>
<h5 id="高斯函数拆分的数学原理"><a href="#高斯函数拆分的数学原理" class="headerlink" title="高斯函数拆分的数学原理"></a>高斯函数拆分的数学原理</h5><ul>
<li>高斯滤波为什么能这么拆？数学原理如下</li>
<li>高斯函数有好的定义</li>
</ul>
<p>$$<br>G_{2D}(x,y)&#x3D;\exp\left(-\dfrac{x^2+y^2}{2\sigma^2}\right)<br>$$</p>
<p>$$<br>G_{1D}(x)&#x3D;\exp\left(-\dfrac{x^2}{2\sigma^2}\right)<br>$$</p>
<p>$$<br>G_{1D}(y)&#x3D;\exp\left(-\dfrac{y^2}{2\sigma^2}\right)<br>$$</p>
<p>$$<br>G_{2D}(x,y)&#x3D;G_{1D}(x)\cdot G_{1D}(y)<br>$$</p>
<ul>
<li>滤波就是卷积（filtering &#x3D;&#x3D; convolution）</li>
</ul>
<p>$$<br>\begin{aligned}<br>R(x_0,y_0)&amp;&#x3D;\iint{F(x_0,y_0)G_{2D}(x_0-x,y_0-y)};\mathrm{d}x\mathrm{d}y\<br>&amp;&#x3D;\iint{F(x_0,y_0)G_{1D}(x_0-x)G_{1D}(y_0-y)};\mathrm{d}x\mathrm{d}y\<br>&amp;&#x3D;\int\Big(F(x_0,y_0)G_{1D}(x_0-x);\mathrm{d}x\Big)G_{1D}(y_0-y)\mathrm{d}y<br>\end{aligned}<br>$$</p>
<ul>
<li>双边高斯滤波就不能这么拆分，因为不具备定义上 2D 拆分为 1D 的性质<ul>
<li>但是在实际工业实现上，都是这么强行拆分的</li>
</ul>
</li>
</ul>
<h4 id="2-逐步增大滤波核：Progressively-Growing-Sizes"><a href="#2-逐步增大滤波核：Progressively-Growing-Sizes" class="headerlink" title="(2) 逐步增大滤波核：Progressively Growing Sizes"></a>(2) 逐步增大滤波核：Progressively Growing Sizes</h4><ul>
<li>一个例子：a-trous wavelet</li>
<li>每一趟都是 $5\times5$ 的大小，但是每一趟像素间的间隔是不一样的</li>
<li>第 $i$ 趟考虑的点间隔 $2^{i}$<ul>
<li>第 $1$ 趟（$i&#x3D;0$）</li>
<li>考虑的点示例如下</li>
</ul>
</li>
</ul>
<img src="13/image-20210610214554336.png" style="zoom:50%;" />

<ul>
<li>因此我们对于原始 $64\times64$ 的滤波，对于<strong>每一个像素点</strong>访问周围点的次数从 $64\times64$ 降到了 $5^2\times5$<ul>
<li>第 $5(i&#x3D;4)$ 层的时候，间隔为 $2^4&#x3D;16$，一共 $5$ 个点，$4$ 个间隔，结果占据范围为 $64$</li>
<li>$4096\Rightarrow125$</li>
</ul>
</li>
</ul>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ul>
<li>为什么要一开始不直接使用大的 filter？<ul>
<li>使用更大的 filter &#x3D;&#x3D; 消除更低的频率</li>
</ul>
</li>
<li>跳过一些采样点为什么是可行的？<ul>
<li>更低的频率间隔更大</li>
<li>空间采样，频域上频谱的搬移<ul>
<li>如果采样频率太低（间隔太大），会导致走样</li>
<li>采样定理</li>
</ul>
</li>
<li>因为频率变低了，因此可以跳过一些采样点</li>
</ul>
</li>
</ul>
<img src="13/image-20210610232427566.png" style="zoom:60%;" />

<ul>
<li>根据上图<ul>
<li>第一个 pass，把<span style="font-weight:bold;color:#2E74BB">蓝色部分</span>的高频信息去掉了</li>
<li>第二个 pass 间隔较大，可以去掉<span style="font-weight:bold;color:#F59A24">黄色部分</span>的高频信息<ul>
<li>同时不会有走样现象，因为高频信息已经被去掉了</li>
<li>可以通过计算得到，频谱搬移的时候恰好不会有混叠</li>
</ul>
</li>
</ul>
</li>
<li>在实际中是有问题的，高频信息并不是完全被去掉（非理想滤波器）<ul>
<li>能看到一些格子状的 artifact</li>
</ul>
</li>
</ul>
<h2 id="Outlier-Removal"><a href="#Outlier-Removal" class="headerlink" title="Outlier Removal"></a>Outlier Removal</h2><ul>
<li>Outlier Removal (and temporal clamping)</li>
<li>离群值去除</li>
<li>我们在渲染的过程中可能会出现一些特别亮的点，如<a target="_blank" rel="noopener" href="https://clarissewiki.com/4.0/fireflies-filtering.html">下图</a></li>
</ul>
<img src="13/image-20210610234504044.png" style="zoom:67%;" />

<ul>
<li>这些点在滤波中很难处理，这个点很亮（值很大），在滤波之后会被扩散为一个光晕（比较大的亮斑）<ul>
<li>the filtered results are still noisy, even <strong>blocky</strong></li>
<li><strong>blocky artifact</strong></li>
</ul>
</li>
<li>这些特别亮的点就被称为是 outlier<ul>
<li>图形学中常被称为是 firefly（火萤）</li>
</ul>
</li>
<li>outlier removal 会导致<strong>能量不守恒</strong><ul>
<li>RTRT 为了提高效率，这么做是可以接受的</li>
</ul>
</li>
</ul>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul>
<li>在做滤波之前先处理掉（不处理掉会影响滤波）</li>
<li>outlier 检测<ul>
<li>对于每个像素，查看周围的一个小邻域（$7\times7$）</li>
<li>计算邻域内的均值、方差（也可以用中位数）<ul>
<li>简单计算</li>
<li>用一些数据结构</li>
</ul>
</li>
<li>如果一个点的值在均值加减若干个标准差范围内，如果超出这个范围，我们认为他们就是 outlier<ul>
<li>$[\mu-k\sigma,\mu+k\sigma]$</li>
<li>工业界 $k&#x3D;1\sim3$ 都有</li>
</ul>
</li>
</ul>
</li>
<li>outlier removal<ul>
<li>将 outlier 截断（clamp）</li>
<li>工业界 clamp 的实现比较复杂，可能不是一个简单的区间</li>
</ul>
</li>
</ul>
<h3 id="TAA-中的-outlier-removal"><a href="#TAA-中的-outlier-removal" class="headerlink" title="TAA 中的 outlier removal"></a>TAA 中的 outlier removal</h3><ul>
<li>$\bar{C}^{(i)}&#x3D;\alpha\bar{C}^{(i)}+(1-\alpha)\bar{C}^{i-1}$</li>
<li>我们对上一帧得到的 noise free 的结果进行截断<ul>
<li>如果上一帧的结果和这一帧相差太大，我们做一个截断的操作</li>
<li>这样的操作是一个 noise 和 lagging 的 tradeoff<ul>
<li>引入了更多噪声</li>
</ul>
</li>
<li>相当于调整 $\alpha$</li>
</ul>
</li>
<li>$\bar{C}^{(i)}&#x3D;\alpha\bar{C}^{(i)}+(1-\alpha)\cdot\mathrm{clamp}(\bar{C}^{i-1},\mu-k\sigma,k+k\sigma)$</li>
</ul>
<h2 id="SVGF"><a href="#SVGF" class="headerlink" title="SVGF"></a>SVGF</h2><ul>
<li>Nvidia 2017 年的论文<ul>
<li><a target="_blank" rel="noopener" href="https://research.nvidia.com/sites/default/files/pubs/2017-07_Spatiotemporal-Variance-Guided-Filtering%3A//svgf_preprint.pdf">Spatiotemporal Variance-Guided Filtering: Real-Time Reconstruction for Path-Traced Global Illumination</a></li>
</ul>
</li>
<li><strong>Spatiotemporal</strong> Variance-Guided Filtering<ul>
<li>和之前的基本的时空上的降噪方法类似</li>
<li>有一些额外的方差分析和 tricks<ul>
<li>每一个像素会记录一个 variance（方差）</li>
</ul>
</li>
</ul>
</li>
<li>1spp &#x2F; 滤波结果 &#x2F; ground truth<ul>
<li>ground truth 可以通过 path tracing  用一个较高的 spp 得到的基本收敛的结果</li>
</ul>
</li>
</ul>
<img src="13/image-20210613145752902.png" style="zoom: 50%;" />



<h3 id="3-个标准"><a href="#3-个标准" class="headerlink" title="3 个标准"></a>3 个标准</h3><h4 id="depth"><a href="#depth" class="headerlink" title="depth"></a>depth</h4><ul>
<li>深度</li>
<li>$q$ 对 $p$ 的贡献</li>
</ul>
<p>$$<br>w_z&#x3D;\exp\Big(-\dfrac{|z(p)-z(q)|}{\sigma_z|\nabla z_p\cdot(p-q)|+\epsilon}\Big)<br>$$</p>
<ul>
<li>不是高斯，分子是一次方（有衰减即可）</li>
<li>分母的 $\epsilon&#x3D;10^{-6}$ 防止除零的发生（$p&#x3D;q$）</li>
<li>$\nabla z$ is the gradient of clip-space depth with respect to <strong>screenspace coordinates</strong></li>
</ul>
<img src="13/image-20210614103832074.png" style="zoom:67%;" />

<ul>
<li>图上的 A、B 两点在同一个平面上，直观上感觉应该 A 对 B 的贡献不小<ul>
<li>但是由于这个平面是侧向我们的，深度上有差异，简单的使用深度值的话，计算得到的贡献偏小</li>
<li>我们使用<strong>深度在法线上差异</strong>作为一个标准（切平面上的深度差异）</li>
<li>分母计算出来的结果就是按照 $p$ 点的变化率，深度应该变化的值<ul>
<li>如果共平面，值和分子相同，计算得到的结果使得贡献值变大</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="normal"><a href="#normal" class="headerlink" title="normal"></a>normal</h4><ul>
<li>法线</li>
</ul>
<p>$$<br>w_n&#x3D;\max\Big(0,n(p)\cdot n(q)\Big)^{\sigma_n}<br>$$</p>
<ul>
<li>指数控制衰减的快慢（之前的 Blinn-Phong 模型的镜面叶）</li>
</ul>
<img src="13/image-20210614110024367.png" style="zoom:67%;" />

<ul>
<li>如果场景应用了法线贴图，我们使用的是没有法线贴图之前的法线（marco normals）<ul>
<li>法线贴图干扰很大</li>
</ul>
</li>
</ul>
<h4 id="luminance"><a href="#luminance" class="headerlink" title="luminance"></a>luminance</h4><ul>
<li>luminance（灰度的颜色值）</li>
<li>如果两个点的灰度值相差过大，则贡献值要减小<ul>
<li>例如：A 不应该贡献到 B，B 不应该贡献到 C</li>
</ul>
</li>
<li>但是由于噪声的存在，会让我们的判断有些干扰</li>
<li>我们通过方差来判断噪声<ul>
<li>如果方差较大（噪声严重），则不应该过多的相信这两个点之间的差异</li>
</ul>
</li>
</ul>
<img src="13/image-20210614110631154.png" style="zoom: 67%;" />

<ul>
<li>表达式如下</li>
</ul>
<p>$$<br>w_l&#x3D;\exp\Big(-\dfrac{|l_i(p)-l_i(q)|}{\sigma_l\sqrt{g_{3\times3}\Big(\mathrm{Var}\big(l_i(p)\big)\Big)}+\epsilon}\Big)<br>$$</p>
<ul>
<li>方差具体计算<ul>
<li>spatial：我们对当前帧待判断像素点周围 $7\times7$ 区域方差值（实际上的标准差）</li>
<li>temporal：通过 motion vector 找到上一帧中的对应点，求一个方差的平均（带权）</li>
<li>spatial：在使用的时候，我们在周围取一个 $3\times3$ 区域内求一个平均值</li>
</ul>
</li>
</ul>
<h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><ul>
<li>方差项会导致在做 over blur 和 noise 之间的 trade off 的时候，会倾向于 over blur</li>
<li>改进：ASVGF<ul>
<li>更加精准的判断 temporal上的连续情况</li>
<li>overblur 的不要这么厉害（相对噪声会严重些）</li>
</ul>
</li>
<li>motion vector 同样会导致拖尾的结果</li>
</ul>
<h2 id="RAE"><a href="#RAE" class="headerlink" title="RAE"></a>RAE</h2><ul>
<li>Nvidia 2017 年的论文<ul>
<li><a target="_blank" rel="noopener" href="https://research.nvidia.com/publication/interactive-reconstruction-monte-carlo-image-sequences-using-recurrent-denoising">Interactive Reconstruction of Monte Carlo Image Sequences using a Recurrent denoising AutoEncoder</a></li>
</ul>
</li>
<li>后处理的神经网络<ul>
<li>目标：noisy $\to$ clean</li>
<li>使用到一些 G-Buffer 的内容</li>
</ul>
</li>
<li>关键结构<ul>
<li>Recurrent block 的结构能够保存上一帧的信息</li>
<li>AutoEncoder（U-net）结构（漏斗形）</li>
</ul>
</li>
</ul>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="/13/image-20210614112743145.png"></p>
<ul>
<li>输入为 G-Buffer</li>
<li>AutoEncoder<ul>
<li>对称的</li>
<li>skip connection：faster and better training</li>
</ul>
</li>
<li>Recurrent Block<ul>
<li>实际跑的时候，保留前几帧的信息</li>
</ul>
</li>
</ul>
<img src="13/image-20210614140956345.png" style="zoom: 67%;" />

<ul>
<li>训练的时候也需要用一些连续帧（不能只有单张渲染结果）</li>
<li>没有使用 motion vector<ul>
<li>具体使用是什么内容，是神经网络学习出来的结果</li>
</ul>
</li>
<li>当时：50ms 一帧</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>overblur</li>
<li>残影</li>
<li>RAE 场景偏暗（亮了 artifacts 会增多）</li>
</ul>
<h3 id="SVGF-vs-RAE"><a href="#SVGF-vs-RAE" class="headerlink" title="SVGF vs RAE"></a>SVGF vs RAE</h3><ul>
<li>帧间抖动，一些低频噪声，看起来像沸腾的水，boiling artifacts</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Quality</th>
<th align="center">Artifact</th>
<th align="center">Performance</th>
<th align="center">Explanability</th>
<th align="center">Where did the paper go</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SVGF</td>
<td align="center"><strong>Clean</strong></td>
<td align="center">Ghosting</td>
<td align="center"><strong>Fast</strong></td>
<td align="center"><strong>Yes</strong></td>
<td align="center">HPG</td>
</tr>
<tr>
<td align="center">RAE <br />(when first invented)</td>
<td align="center">Overblur</td>
<td align="center">Ghosting</td>
<td align="center">Slow</td>
<td align="center">No</td>
<td align="center"><strong>SIGGRAPH</strong></td>
</tr>
</tbody></table>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>RAE 在不同输入情况下， performance 是固定的（网络固定、计算耗时固定）</li>
<li>Nvidia 把 RAE 中的 Recurrent Block 去掉了，放到了 Optix 的光追降噪中<ul>
<li>对于稍微高一点的 spp 降噪效果非常好</li>
<li>针对单张图片（去掉了 Recurrent Block）</li>
</ul>
</li>
<li>在 tensor core 提出之后，RAE 效果变好了</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/10/CG/YLQ-GAMES202/13/" data-id="cl9lj749y009b64tzfit5hn17" data-title="GAMES202.闫令琪.13.实时光线追踪(2)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OS/xv6-labs/lab9-mmap" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/10/OS/xv6-labs/lab9-mmap/" class="article-date">
  <time class="dt-published" datetime="2021-06-10T04:00:00.000Z" itemprop="datePublished">2021-06-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OS-xv6-labs/">OS.xv6-labs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/10/OS/xv6-labs/lab9-mmap/">xv6-labs-2020.lab9.mmap</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="lab9-mmap"><a href="#lab9-mmap" class="headerlink" title="lab9 mmap"></a>lab9 mmap</h1><h2 id="1-作业链接"><a href="#1-作业链接" class="headerlink" title="1. 作业链接"></a>1. 作业链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/labs/mmap.html">https://pdos.csail.mit.edu/6.828/2020/labs/mmap.html</a></li>
</ul>
<h2 id="2-实习内容"><a href="#2-实习内容" class="headerlink" title="2. 实习内容"></a>2. 实习内容</h2><ul>
<li>实现系统调用 mmap，munmap</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>linux 下通过让一下命令查看对 mmap、munmap 的解释</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 2 mmap</span><br></pre></td></tr></table></figure>

<ul>
<li>mmap()<ul>
<li>addr：起始地址<ul>
<li>如果为 NULL，则内核会选择一个页对齐的地址</li>
<li>如果不为 NULL，只是一个 hint，如果不可行则会选择其他地址</li>
</ul>
</li>
<li>length：申请的空间长度（字节）</li>
<li>prot：一些保护位<ul>
<li>PROT_EXEC  Pages may be executed.</li>
<li>PROT_READ  Pages may be read.</li>
<li>PROT_WRITE Pages may be written.</li>
<li>PROT_NONE  Pages may not be accessed.</li>
</ul>
</li>
<li>flag：设置的 flag，表示对这块区域的操作对其它进程的影响<ul>
<li>MAP_SHARED、MAP_SHARED、MAP_ANONYMOUS 等</li>
</ul>
</li>
<li>fd：建立映射的文件</li>
<li>offset：被映射对象内容的起点</li>
<li>返回值为起始地址，(void*)-1 表示失败</li>
</ul>
</li>
<li>munmap()<ul>
<li>addr：起始地址</li>
<li>length：空间长度（字节）</li>
</ul>
</li>
</ul>
<h3 id="2-1-说明"><a href="#2-1-说明" class="headerlink" title="2.1 说明"></a>2.1 说明</h3><ul>
<li>我们在这个实验中只需要实现简单功能即可</li>
<li>mmap<ul>
<li>addr 可以认为始终为 0<ul>
<li>表示起始地址由内核决定</li>
</ul>
</li>
<li>返回值为起始地址，或者 <code>0xffffffffffffffff</code> 表示失败</li>
<li>length 表示需要映射内容的长度<ul>
<li>可能和文件不等长</li>
</ul>
</li>
<li>prot 表示这块区域是否可读、可写、可执行<ul>
<li>我们可以假设只能是 <code>PROT_READ</code> 、<code>PROT_WRITE</code> 、二者都有</li>
<li>flags 只能是  <code>MAP_SHARED</code>（修改需要写回文件）、<code>MAP_PRIVATE</code>（不需要写回文件）</li>
</ul>
</li>
<li>fd 为文件描述符</li>
<li>offset 为 0</li>
</ul>
</li>
<li>我们允许 MAP_SHARED 的映射区域不对应相同的物理页</li>
<li>munmap<ul>
<li>解除映射</li>
<li>如果 flag 为 MAP_SHARED，则需要写回文件</li>
<li>解除的区域可以是映射区域的一个子集，但是我们可以假设接触区域只能是如下情况<ul>
<li>整个区域</li>
<li>start 和映射区域相同</li>
<li>end 和映射区域相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-提示"><a href="#2-2-提示" class="headerlink" title="2.2 提示"></a>2.2 提示</h3><ul>
<li>准备工作放在实现里面</li>
<li>mmap 本身不分配物理页，通过 page fault 分配物理页<ul>
<li>usertrap 就行了，mmap 只会被用户态调用分配</li>
<li>保证快速映射一块大区域，允许映射比实际物理内存更大的范围</li>
</ul>
</li>
<li>每个进程保存一个数据结构 VMA（virtual memory area），记录被 mmap 映射的区域<ul>
<li>简单的可以直接开一个定长的数组，16 就足够了</li>
<li>VMA 需要保存如下内容<ul>
<li>address, length, permissions, file 等</li>
</ul>
</li>
</ul>
</li>
<li>mmap 的实现<ul>
<li>首先在进程的空闲内存区与中找到一块区域分配空间</li>
<li>在 VMA 中找到一个空闲区域用于保存记录</li>
<li>VMA 中需要有一个 <code>struct file*</code>  指针，需要把 file 的引用计数+1（避免释放）<ul>
<li>可以看 <code>filedup</code> 的实现</li>
</ul>
</li>
<li><span id="Q1">注意权限的检查</span>，有 read-only 的测试样例<ul>
<li>如果把只读区域映射为可写的而且是 MAP_SHARED 则直接报错</li>
<li>MAP_PRIVATE 不会写</li>
</ul>
</li>
</ul>
</li>
<li>此时由于 lazy 的结果会导致 page fault</li>
<li>实现 page fault 时读取文件，分配物理页<ul>
<li>捕捉 page fault</li>
<li>通过 readi 读取文件中与访问地址相近的 4096 bytes，并建立映射关系<ul>
<li>readi 的时候需要给 inode 加锁</li>
</ul>
</li>
<li>正确设置权限位</li>
</ul>
</li>
<li>此时能够正确到达第一个 munmap 测试</li>
<li>实现 munmap<ul>
<li>遍历 VMA，找到对应的 VMA，释放对应的空间即可</li>
<li>如果是 MAP_SHARED 的话，需要将修改的内容写回文件<ul>
<li>参考 filewrite 实现</li>
</ul>
</li>
<li>如果是释放了整个映射区域的话，需要将文件的引用计数-1</li>
</ul>
</li>
<li>理论上，我们应该只写回真正被修改的页，也就是说 dirty 位设置为 1 的页<ul>
<li>但是这里没有检查，因此我们不做要求</li>
</ul>
</li>
<li>exit() 退出的时候，释放所有的 VMA 中没有解除映射的块</li>
<li>fork() 的时候，子进程拥有和父进程一样的 VMA，允许在子进程遇到 page fault 的时候分配一个不和父进程一样的物理页<ul>
<li>更好的方式是和父进程共用一个物理页，但是这里不要求</li>
</ul>
</li>
</ul>
<h3 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3 实现"></a>2.3 实现</h3><h4 id="1-添加系统调用"><a href="#1-添加系统调用" class="headerlink" title="(1) 添加系统调用"></a>(1) 添加系统调用</h4><ul>
<li><code>Makefile</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    $U/_mmaptest\</span><br></pre></td></tr></table></figure>

<ul>
<li>添加系统调用</li>
<li><code>user/usys.pl</code></li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entry(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;munmap&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>user/user.h</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>*, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/sysfile.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_mmap</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64 <span class="title function_">sys_munmap</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/syscall.h</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mmap   22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_munmap 23</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/syscall.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_munmap</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    [SYS_mmap]   sys_mmap,</span><br><span class="line">    [SYS_munmap]   sys_munmap,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="2-VMA"><a href="#2-VMA" class="headerlink" title="(2) VMA"></a>(2) VMA</h4><ul>
<li>添加数据结构 VMA</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> &#123;</span></span><br><span class="line">    uint64 start;  <span class="comment">// 起始地址</span></span><br><span class="line">    uint64 end;    <span class="comment">// 结束地址</span></span><br><span class="line">    uint64 length; <span class="comment">// 区域的长度</span></span><br><span class="line">    <span class="type">int</span> prot;      <span class="comment">// 权限</span></span><br><span class="line">    <span class="type">int</span> flags;     <span class="comment">// MAP_SHARED,MAP_PRIVATE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// 对应的文件</span></span><br><span class="line">    <span class="type">int</span> offset;    <span class="comment">// 可能释放了一个部分, 此时 offset 可能不是 0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>在 proc 中添加 VMA</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVMA 16</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> <span class="title">vma</span>[<span class="title">MAXVMA</span>];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-mmap"><a href="#3-mmap" class="headerlink" title="(3) mmap"></a>(3) mmap</h4><ul>
<li>按照提示的说明实现 mmap()</li>
<li>找到一个空闲区域，写入 VMA，修改当前进程的 sz</li>
<li>注意上面提到的一个<a href="#Q1">权限问题</a></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line">uint64 <span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// uint64 addr; // 都为 0</span></span><br><span class="line">    <span class="type">int</span> length, prot, flags, fd;</span><br><span class="line">    <span class="comment">// int offset; // 都为 0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">if</span>(argint(<span class="number">1</span>, &amp;length) &lt; <span class="number">0</span> || argint(<span class="number">2</span>, &amp;prot) &lt; <span class="number">0</span></span><br><span class="line">       || argint(<span class="number">3</span>, &amp;flags) &lt; <span class="number">0</span> || argfd(<span class="number">4</span>, &amp;fd, &amp;f) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果把只读区域映射为可写的而且是 MAP_SHARED 则直接报错</span></span><br><span class="line">    <span class="comment">// MAP_PRIVATE 不会写</span></span><br><span class="line">    <span class="comment">// 有 read-only 测试</span></span><br><span class="line">    <span class="keyword">if</span>(!f-&gt;writable &amp;&amp; (prot &amp; PROT_WRITE) &amp;&amp; (flags &amp; MAP_SHARED))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到空闲区域, 找到空闲 VMA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXVMA; ++i) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span>* <span class="title">v</span> =</span> &amp;(p-&gt;vma[i]);</span><br><span class="line">        <span class="keyword">if</span>(v-&gt;length == <span class="number">0</span>) &#123;</span><br><span class="line">            v-&gt;length = length;</span><br><span class="line">            v-&gt;start = p-&gt;sz;</span><br><span class="line">            v-&gt;prot = prot;</span><br><span class="line">            v-&gt;flags = flags;</span><br><span class="line">            v-&gt;offset = <span class="number">0</span>;</span><br><span class="line">            v-&gt;file = filedup(f); <span class="comment">// 引用计数+1</span></span><br><span class="line">            <span class="comment">// 地址必须是页对齐的</span></span><br><span class="line">            length = PGROUNDUP(length);</span><br><span class="line">            p-&gt;sz += length;</span><br><span class="line">            v-&gt;end = p-&gt;sz;</span><br><span class="line">            <span class="keyword">return</span> v-&gt;start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于这里并没有分配内存，因此会触发 usertrap()</li>
</ul>
<h4 id="4-usertrap"><a href="#4-usertrap" class="headerlink" title="(4) usertrap"></a>(4) usertrap</h4><ul>
<li>在 usertrap 中处理 page fault<ul>
<li>和 lab4-lazy 比较像</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c:usertrap</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">0xd</span> || r_scause() == <span class="number">0xf</span>) &#123;</span><br><span class="line">    <span class="comment">// 因为包含关系的问题, 我们直接把函数放到 sysfile.c 里面</span></span><br><span class="line">    <span class="comment">// printf(&quot;%p\n%p\n&quot;, r_stval(), PGROUNDDOWN(r_stval()));</span></span><br><span class="line">    <span class="keyword">if</span>(!map_mmap(p, r_stval())) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>因为头文件的包含问题，我们把 map_mmap() 的实现放在了 kernel&#x2F;sysfile.c 里面</li>
<li>kernel&#x2F;defs.h 里添加函数声明</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"><span class="comment">// sysfile.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">map_mmap</span><span class="params">(<span class="keyword">struct</span> proc*, uint64)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>kernel&#x2F;sysfile.c 中添加实现<ul>
<li>遍历 VMA，找到对应的文件</li>
<li>申请空间</li>
<li>建立映射</li>
<li>从文件中读入内存</li>
</ul>
</li>
<li>一些个问题<ul>
<li>申请空间是按页申请的，因此起始地址必须时页对齐的，申请长度必须是页的整数倍</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line"><span class="comment">// 1 成功, 0 失败</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">map_mmap</span><span class="params">(<span class="keyword">struct</span> proc *p, uint64 addr)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历 vma 找到具体的文件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXVMA; ++i) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span>* <span class="title">v</span> =</span> &amp;(p-&gt;vma[i]);</span><br><span class="line">        <span class="comment">// 左闭右开</span></span><br><span class="line">        <span class="keyword">if</span>(v-&gt;length != <span class="number">0</span> &amp;&amp; addr &lt; v-&gt;end &amp;&amp; addr &gt;= v-&gt;start) &#123;</span><br><span class="line">            uint64 start = PGROUNDDOWN(addr);</span><br><span class="line">            <span class="comment">// uint64 end = PGROUNDUP(addr);</span></span><br><span class="line">            <span class="comment">// 可能释放了一部分, 但是后面部分没有建立映射(offset)</span></span><br><span class="line">            uint64 offset = start - v-&gt;start + v-&gt;offset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 申请一块空间</span></span><br><span class="line">            <span class="type">char</span>* mem = kalloc();</span><br><span class="line">            <span class="keyword">if</span>(!mem) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// PROT_NONE       0x0   PTE_V (1L &lt;&lt; 0)</span></span><br><span class="line">            <span class="comment">// PROT_READ       0x1   PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line">            <span class="comment">// PROT_WRITE      0x2   PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line">            <span class="comment">// PROT_EXEC       0x4   PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line">            <span class="comment">//                       PTE_U (1L &lt;&lt; 4)</span></span><br><span class="line">            <span class="comment">// 建立映射关系</span></span><br><span class="line">            <span class="keyword">if</span>(mappages(p-&gt;pagetable, start, PGSIZE,</span><br><span class="line">                        (uint64)mem, (v-&gt;prot&lt;&lt;<span class="number">1</span>)|PTE_U) != <span class="number">0</span></span><br><span class="line">              )&#123;</span><br><span class="line">                kfree(mem);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取文件</span></span><br><span class="line">            ilock(v-&gt;file-&gt;ip);</span><br><span class="line">            <span class="comment">// 1 表示虚拟地址</span></span><br><span class="line">            readi(v-&gt;file-&gt;ip, <span class="number">1</span>, start, offset, PGSIZE);</span><br><span class="line">            iunlock(v-&gt;file-&gt;ip);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-munmap"><a href="#5-munmap" class="headerlink" title="(5) munmap"></a>(5) munmap</h4><ul>
<li>遍历 VMA，找到对应的映射</li>
<li>判断是否是从 start 开始释放，如果是，接着判断是否需要释放整个文件<ul>
<li>注意如果要释放只做标记，之后再释放，否则会出问题（不能提前释放文件）</li>
</ul>
</li>
<li>如果是 MAP_SHARED，则在释放之前需要进行写操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line">uint64 <span class="title function_">sys_munmap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;length) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXVMA; ++i) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span>* <span class="title">v</span> =</span> &amp;(p-&gt;vma[i]);</span><br><span class="line">    <span class="comment">// 左闭右开</span></span><br><span class="line">    <span class="keyword">if</span>(v-&gt;length != <span class="number">0</span> &amp;&amp; addr &lt; v-&gt;end &amp;&amp; addr &gt;= v-&gt;start) &#123;</span><br><span class="line">      <span class="type">int</span> should_close = <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> offset = v-&gt;offset;</span><br><span class="line">      addr = PGROUNDDOWN(addr);</span><br><span class="line">      length = PGROUNDUP(length);</span><br><span class="line">      <span class="comment">// 是否从 start 开始</span></span><br><span class="line">      <span class="keyword">if</span>(addr == v-&gt;start) &#123;</span><br><span class="line">        <span class="comment">// 是否释放整个文件</span></span><br><span class="line">        <span class="keyword">if</span>(length == v-&gt;length) &#123;</span><br><span class="line">          v-&gt;length = <span class="number">0</span>;</span><br><span class="line">          <span class="comment">// 不能在这个时候释放, 得在写回之后</span></span><br><span class="line">          should_close = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          v-&gt;start += length;</span><br><span class="line">          v-&gt;length -= length;</span><br><span class="line">          v-&gt;offset += length;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 根据要求这个时候只能是释放到结尾</span></span><br><span class="line">        v-&gt;length -= length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 处理 MAP_SHARED</span></span><br><span class="line">      <span class="keyword">if</span>(v-&gt;flags &amp; MAP_SHARED) &#123;</span><br><span class="line">        <span class="comment">// 一种简单的实现就是直接把整个文件写回去</span></span><br><span class="line">        <span class="comment">// !!!!(不行, 可能现在的映射已经不是整个文件)</span></span><br><span class="line">        filewrite_offset(v-&gt;file, addr, length, offset);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 解除映射</span></span><br><span class="line">      <span class="comment">// 这里还有些问题, 可能并没有映射</span></span><br><span class="line">      <span class="comment">// if(walkaddr(p-&gt;pagetable, addr) != 0)</span></span><br><span class="line">      uvmunmap(p-&gt;pagetable, addr, length/PGSIZE, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span>(should_close)</span><br><span class="line">        fileclose(v-&gt;file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>和 filewrite() 一样的实现，只是增加一个文件的 offset<ul>
<li>我们只实现了 FINODE 的写操作</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line"><span class="comment">// Write to file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address.</span></span><br><span class="line"><span class="comment">// 支持 offset</span></span><br><span class="line"><span class="comment">// 我们只进行 FINODE 的写操作</span></span><br><span class="line"><span class="comment">// n 表示写的字节数</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">    <span class="title function_">filewrite_offset</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;writable == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;type != FD_INODE) &#123;</span><br><span class="line">        panic(<span class="string">&quot;filewrite: only FINODE implemented!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = ((MAXOPBLOCKS<span class="number">-1</span><span class="number">-1</span><span class="number">-2</span>) / <span class="number">2</span>) * BSIZE;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">        <span class="type">int</span> n1 = n - i;</span><br><span class="line">        <span class="keyword">if</span>(n1 &gt; max)</span><br><span class="line">            n1 = max;</span><br><span class="line"></span><br><span class="line">        begin_op();</span><br><span class="line">        ilock(f-&gt;ip);</span><br><span class="line">        <span class="keyword">if</span> ((r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, offset, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">            offset += r;</span><br><span class="line">        iunlock(f-&gt;ip);</span><br><span class="line">        end_op();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r != n1) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i += r;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = (i == n ? n : <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-其他细节"><a href="#6-其他细节" class="headerlink" title="(6) 其他细节"></a>(6) 其他细节</h4><ul>
<li>在 exit() 退出的时候，需要释放映射的文件区域<ul>
<li>注意文件计数需要+1</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc/c:exit()</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXVMA; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">v</span> =</span> &amp;(p-&gt;vma[i]);</span><br><span class="line">    <span class="keyword">if</span>(v-&gt;length != <span class="number">0</span>)&#123;</span><br><span class="line">        uvmunmap(p-&gt;pagetable, v-&gt;start, v-&gt;length/PGSIZE, <span class="number">1</span>);</span><br><span class="line">        v-&gt;length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 fork 的时候，将父进程的映射内容拷贝到子进程<ul>
<li>注意文件计数需要+1</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc/c:fork()</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// VMA</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXVMA; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;vma[i].length) &#123;</span><br><span class="line">        memmove(&amp;(np-&gt;vma[i]), &amp;(p-&gt;vma[i]), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> VMA));</span><br><span class="line">        filedup(p-&gt;vma[i].file);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        np-&gt;vma[i].length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>因为 lazy 分配的原因，我们需要做一些特殊处理</li>
<li>uvmunmap()<ul>
<li>如果没有建立映射，则不需要释放</li>
<li>如果建立了映射，但是没有读入内存，则不需要调用 kfree()</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c:uvmunmap()</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//   panic(&quot;uvmunmap: walk&quot;);</span></span><br><span class="line">    <span class="comment">// if((*pte &amp; PTE_V) == 0)</span></span><br><span class="line">    <span class="comment">//   panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">        panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free &amp;&amp; (*pte &amp; PTE_V) != <span class="number">0</span>)&#123;</span><br><span class="line">        uint64 pa = PTE2PA(*pte);</span><br><span class="line">        kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>uvmcopy()<ul>
<li>如果尚未分配物理页，这是允许的</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c:uvmcopy()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后的代码</span></span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>



<h2 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3. 实验结果"></a>3. 实验结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">== Test running mmaptest ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(23.1s)</span><br><span class="line">== Test   mmaptest: mmap f ==</span><br><span class="line">  mmaptest: mmap f: OK</span><br><span class="line">== Test   mmaptest: mmap private ==</span><br><span class="line">  mmaptest: mmap private: OK</span><br><span class="line">== Test   mmaptest: mmap read-only ==</span><br><span class="line">  mmaptest: mmap read-only: OK</span><br><span class="line">== Test   mmaptest: mmap <span class="built_in">read</span>/write ==</span><br><span class="line">  mmaptest: mmap <span class="built_in">read</span>/write: OK</span><br><span class="line">== Test   mmaptest: mmap dirty ==</span><br><span class="line">  mmaptest: mmap dirty: OK</span><br><span class="line">== Test   mmaptest: not-mapped unmap ==</span><br><span class="line">  mmaptest: not-mapped unmap: OK</span><br><span class="line">== Test   mmaptest: two files ==</span><br><span class="line">  mmaptest: two files: OK</span><br><span class="line">== Test   mmaptest: fork_test ==</span><br><span class="line">  mmaptest: fork_test: OK</span><br><span class="line">== Test usertests ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">usertests: OK (272.3s)</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 140/140</span><br></pre></td></tr></table></figure>



<h2 id="4-遇到的困难以及收获"><a href="#4-遇到的困难以及收获" class="headerlink" title="4. 遇到的困难以及收获"></a>4. 遇到的困难以及收获</h2><ul>
<li>这个 lab 做起来很舒服，一方面提示给得很完整，另一方面我对文件系统的理解也更加深入了<ul>
<li>这个 lab 可以说是 lab4-lazy 的延伸，lazy 机制缺失在很多地方都很有用</li>
</ul>
</li>
<li>做完这个 lab，感觉自己对 xv6 -riscv 文件系统了解更深入了</li>
</ul>
<h2 id="5-对课程或-lab-的意见和建议"><a href="#5-对课程或-lab-的意见和建议" class="headerlink" title="5. 对课程或 lab 的意见和建议"></a>5. 对课程或 lab 的意见和建议</h2><ul>
<li>建议提供一些关于 lab 的 debug 功能的指导</li>
</ul>
<h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev1.pdf">https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev1.pdf</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/10/OS/xv6-labs/lab9-mmap/" data-id="cl9lj74be00j164tzgngz30um" data-title="xv6-labs-2020.lab9.mmap" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xv6/" rel="tag">xv6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OS/xv6-labs/lab8-file-system" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/09/OS/xv6-labs/lab8-file-system/" class="article-date">
  <time class="dt-published" datetime="2021-06-09T04:00:00.000Z" itemprop="datePublished">2021-06-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OS-xv6-labs/">OS.xv6-labs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/09/OS/xv6-labs/lab8-file-system/">xv6-labs-2020.lab8.file system</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="lab8-file-system"><a href="#lab8-file-system" class="headerlink" title="lab8 file system"></a>lab8 file system</h1><h2 id="1-作业链接"><a href="#1-作业链接" class="headerlink" title="1. 作业链接"></a>1. 作业链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/labs/fs.html">https://pdos.csail.mit.edu/6.828/2020/labs/fs.html</a></li>
</ul>
<h2 id="2-实习内容"><a href="#2-实习内容" class="headerlink" title="2. 实习内容"></a>2. 实习内容</h2><h3 id="2-1-Large-files"><a href="#2-1-Large-files" class="headerlink" title="2.1 Large files"></a>2.1 Large files</h3><h4 id="1-目标与描述"><a href="#1-目标与描述" class="headerlink" title="(1) 目标与描述"></a>(1) 目标与描述</h4><ul>
<li>xv6 的一个文件有 13 个数据项，前 12 个数据项直接索引到数据块，第 13 个数据项通过一级索引索引到数据块（先找到索引表，通过索引表找到数据块地址）<ul>
<li>一个数据项大小为 $4$ 字节，一个块的大小为 $1024$ 字节，因此一个块中最多可以放 $\dfrac{1024}{4}&#x3D;256$ 个数据项</li>
<li>因此支持的的文件最大为 $12+256&#x3D;268$ 块</li>
</ul>
</li>
<li>我们的目标是让 xv6 支持更大的文件，我们增加一个二级索引<ul>
<li>前 11 个数据项直接索引，第 12 个数据项一级索引，第 13 个数据项二级索引</li>
<li>这样支持的最大文件为 $11+256+256\times256&#x3D;65803$</li>
</ul>
</li>
</ul>
<img src="lab8-file-system/001.png" style="zoom:67%;" />

<ul>
<li>注意文件系统的每次修改代码都需要 <code>make clean</code>，否则 <code>fs.img</code> 中文件系统会出问题<ul>
<li>或者删除文件 <code>fs.img</code></li>
</ul>
</li>
</ul>
<h4 id="2-提示"><a href="#2-提示" class="headerlink" title="(2) 提示"></a>(2) 提示</h4><ul>
<li><code>fs.c</code> 中的<code>bmap()</code> 函数建立起对数据块的索引<ul>
<li>读操作如果没找到数据块，则报错返回</li>
<li>写操作如果没找到，则需要分配一块</li>
</ul>
</li>
<li>bmap() 中的参数 <code>bn</code> 是逻辑序号（文件内从 0 开始标的序号）</li>
</ul>
<h4 id="3-实现"><a href="#3-实现" class="headerlink" title="(3) 实现"></a>(3) 实现</h4><h5 id="1-修改宏"><a href="#1-修改宏" class="headerlink" title="[1] 修改宏"></a>[1] 修改宏</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX_NUM_1 (BSIZE/sizeof(uint))      <span class="comment">// 一级索引表数据个数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX_NUM_2 (INDEX_NUM_1*INDEX_NUM_1) <span class="comment">// 二级索引表数据个数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX_ENTRY_1 NDIRECT                 <span class="comment">// 一级索引表位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX_ENTRY_2 (NDIRECT+1)             <span class="comment">// 二级索引表位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (INDEX_NUM_1 + INDEX_NUM_2) <span class="comment">// 不能删除!!!!有其他地方引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT) <span class="comment">// 最大文件个数</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意所有的原来相关引用必须正确<ul>
<li>NINDIRECT<ul>
<li>mkfs&#x2F;mkfs.c：iappend() 正确</li>
</ul>
</li>
<li>NDIRECT</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/file.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uint addrs[NDIRECT+<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uint addrs[NDIRECT+<span class="number">2</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="2-二级索引表"><a href="#2-二级索引表" class="headerlink" title="[2] 二级索引表"></a>[2] 二级索引表</h5><ul>
<li>以下的代码修改都是 <code>kernel/fs.c</code></li>
<li>可以  <code>ctrl-f</code> 找找需要修改的地方（<code>addr</code>）</li>
<li>修改 bmap()，建立起新的映射关系<ul>
<li>判断如果是二级索引的话，需要先读入二级索引表，再读入一级索引表，最后读入数据块地址</li>
<li>最后需要释放二级索引表</li>
</ul>
</li>
<li>注意修改了内容就需要调用 log_write() 写到磁盘（write through）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint <span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span> &#123;</span><br><span class="line">    uint addr, *a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前 11 块直接索引</span></span><br><span class="line">    <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">        <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">            ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line">    bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一级索引</span></span><br><span class="line">    <span class="keyword">if</span>(bn &lt; INDEX_NUM_1)&#123;</span><br><span class="line">        <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">        <span class="keyword">if</span>((addr = ip-&gt;addrs[INDEX_ENTRY_1]) == <span class="number">0</span>)</span><br><span class="line">            ip-&gt;addrs[INDEX_ENTRY_1] = addr = balloc(ip-&gt;dev);</span><br><span class="line">        bp = bread(ip-&gt;dev, addr);</span><br><span class="line">        a = (uint*)bp-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">            a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">            log_write(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(bp);</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line">    bn -= INDEX_NUM_1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二级索引</span></span><br><span class="line">    <span class="keyword">if</span>(bn &lt; INDEX_NUM_2) &#123;</span><br><span class="line">        uint addr2, *a2, index;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">bp2</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载二级索引, 如果必要的话则为其分配空间</span></span><br><span class="line">        <span class="keyword">if</span>((addr2 = ip-&gt;addrs[INDEX_ENTRY_2]) == <span class="number">0</span>)</span><br><span class="line">            ip-&gt;addrs[INDEX_ENTRY_2] = addr2 = balloc(ip-&gt;dev);</span><br><span class="line"></span><br><span class="line">        bp2 = bread(ip-&gt;dev, addr2);</span><br><span class="line">        a2 = (uint*)bp2-&gt;data;</span><br><span class="line">        <span class="comment">// 计算出第几个索引项</span></span><br><span class="line">        index = bn / INDEX_NUM_1;</span><br><span class="line">        bn %= INDEX_NUM_1;</span><br><span class="line">        <span class="comment">// 加载一级索引</span></span><br><span class="line">        <span class="keyword">if</span>((addr = a2[index]) == <span class="number">0</span>) &#123;</span><br><span class="line">            a2[index] = addr = balloc(ip-&gt;dev);</span><br><span class="line">            log_write(bp2);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(bp2);</span><br><span class="line"></span><br><span class="line">        bp = bread(ip-&gt;dev, addr);</span><br><span class="line">        a = (uint*)bp-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">            a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">            log_write(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(bp);</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>itrunc() 丢弃 inode 的时候需要回收所有的数据块</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">    uint *a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接映射的数据块</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">            bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">            ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一级索引</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[INDEX_ENTRY_1])&#123;</span><br><span class="line">        bp = bread(ip-&gt;dev, ip-&gt;addrs[INDEX_ENTRY_1]);</span><br><span class="line">        a = (uint*)bp-&gt;data;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; INDEX_NUM_1; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j])</span><br><span class="line">                bfree(ip-&gt;dev, a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(bp);</span><br><span class="line">        bfree(ip-&gt;dev, ip-&gt;addrs[INDEX_ENTRY_1]);</span><br><span class="line">        ip-&gt;addrs[INDEX_ENTRY_1] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二级索引</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[INDEX_ENTRY_2]) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">bp2</span>;</span></span><br><span class="line">        uint* a2;</span><br><span class="line">        bp2 = bread(ip-&gt;dev, ip-&gt;addrs[INDEX_ENTRY_2]);</span><br><span class="line">        a2 = (uint*)bp2-&gt;data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐个查看一级索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; INDEX_NUM_1; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a2[k]) &#123;</span><br><span class="line">                bp = bread(ip-&gt;dev, a2[k]);</span><br><span class="line">                a = (uint*)bp-&gt;data;</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; INDEX_NUM_1; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[j])</span><br><span class="line">                        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                brelse(bp);</span><br><span class="line">                bfree(ip-&gt;dev, a2[k]);</span><br><span class="line">                <span class="comment">// a2[k] = 0; 有 bfree()</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收二级索引表</span></span><br><span class="line">        brelse(bp2);</span><br><span class="line">        bfree(ip-&gt;dev, ip-&gt;addrs[INDEX_ENTRY_2]);</span><br><span class="line">        ip-&gt;addrs[INDEX_ENTRY_2] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">    iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-Symbolic-links"><a href="#2-2-Symbolic-links" class="headerlink" title="2.2 Symbolic links"></a>2.2 Symbolic links</h3><h4 id="1-目标与描述-1"><a href="#1-目标与描述-1" class="headerlink" title="(1) 目标与描述"></a>(1) 目标与描述</h4><ul>
<li>实现软链接</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">symlink</span><span class="params">(<span class="type">char</span> *target, <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>软链接可以跨盘，硬链接不能跨盘</li>
</ul>
<h4 id="2-提示-1"><a href="#2-提示-1" class="headerlink" title="(2) 提示"></a>(2) 提示</h4><ul>
<li>一部分提示（准备工作）放在实现中</li>
<li><code>symlink(target, path)</code> 的 target 不存在也能成功<ul>
<li>你需要有一个地方保存 target 位置，可以保存在 inode 的数据块中</li>
<li>需要有返回值，0 成功，-1 失败（和 link&#x2F;unlink 一致）</li>
</ul>
</li>
<li>修改系统调用 open() 实现对软链接文件的处理<ul>
<li>如果文件不存在，则 open 失败</li>
<li>如果文件打开的 flag 中有 <code>O_NOFOLLOW</code>，则<strong>不需要</strong>打开软链接对应的文件</li>
</ul>
</li>
<li>如果软链接文件对应的文件还是软链接文件，需要递归打开，直至找到一个不是软链接的文件<ul>
<li>如果成环，则需要报错（简单使用一个递归深度阈值判断即可，10）</li>
</ul>
</li>
<li>其他系统调用（例如链接和取消链接）不需要打开到软链接最终链接的文件，只需要打开软链接文件本身即可</li>
<li>不需要处理软链接指向文件夹的情况<ul>
<li>不允许指向文件夹</li>
</ul>
</li>
</ul>
<h4 id="3-实现-1"><a href="#3-实现-1" class="headerlink" title="(3) 实现"></a>(3) 实现</h4><h5 id="1-添加一个新的系统调用-symlink"><a href="#1-添加一个新的系统调用-symlink" class="headerlink" title="[1] 添加一个新的系统调用 symlink"></a>[1] 添加一个新的系统调用 symlink</h5><ul>
<li><code>Makefile</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(LAB)</span>,fs)</span><br><span class="line">UPROGS += \</span><br><span class="line">    $U/_bigfile\</span><br><span class="line">    $U/_symlinktest</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>user/usys.pl</code></li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry(<span class="string">&quot;symlink&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>user/user.h</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span>*)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/sysfile.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_symlink</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/syscall.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    [SYS_symlink] sys_symlink,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/syscall.h</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_symlink 22</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/stat.h</code> 中添加文件类型，表示软链接（symbolic link）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_SYMLINK 4</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code> kernel/fcntl.h</code> 添加新的 flag，用于 open 系统调用，注意文件打开的 flag 是是使用 or 进行组合的，因此不能和已有的 flag 重合</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> O_NOFOLLOW 0x004</span></span><br></pre></td></tr></table></figure>



<h5 id="2-sys-symlink-具体实现"><a href="#2-sys-symlink-具体实现" class="headerlink" title="[2] sys_symlink() 具体实现"></a>[2] sys_symlink() 具体实现</h5><ul>
<li>注意一些小问题即可<ul>
<li>symlink 的 path 是可以存在的，测试数据中那个有这样的内容<ul>
<li>这个人感觉很不合理</li>
<li>没有做一些其他的处理，例如释放原来的文件数据块（感觉应该是要做，但是在这个lab中没有实现）</li>
</ul>
</li>
<li>namei() 返回 ip 不为 0 的情况下，ip 是不带锁，但是引用计数+1<ul>
<li>因此需要注意 iput() 的调用</li>
</ul>
</li>
<li>将 target 保存在 data 段的开始</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仿照 sys_link 实现即可</span></span><br><span class="line"><span class="comment">// 效果是将 old 指向 new</span></span><br><span class="line">uint64 <span class="title function_">sys_symlink</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[DIRSIZ], target[MAXPATH], path[MAXPATH];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dp</span>, *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    begin_op();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// target 可以不存在</span></span><br><span class="line">    <span class="comment">// if((ip = namei(path)) == 0)&#123;</span></span><br><span class="line">    <span class="comment">//   end_op();</span></span><br><span class="line">    <span class="comment">//   return -1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// target 的引用计数增加</span></span><br><span class="line">    <span class="keyword">if</span>((ip = namei(target)) != <span class="number">0</span>) &#123;</span><br><span class="line">        ilock(ip);</span><br><span class="line">        <span class="comment">// 不能是文件夹</span></span><br><span class="line">        <span class="comment">// 测试数据中没有文件夹的数据</span></span><br><span class="line">        <span class="keyword">if</span>(ip-&gt;type == T_DIR) &#123;</span><br><span class="line">            iunlockput(ip);</span><br><span class="line">            end_op();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ip-&gt;nlink++;</span><br><span class="line">        iupdate(ip);</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// link 的实现是 new 文件不存在, 因此直接使用 dirlink 即可</span></span><br><span class="line">    <span class="comment">// 在测试数据中, symlink 的 path 文件可以存在, 因此方法不太一样</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先检查 path 节点是否存在, 不存在则新建一个</span></span><br><span class="line">    <span class="keyword">if</span>((dp = namei(path)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// path 的父节点得存在</span></span><br><span class="line">        <span class="keyword">if</span>((dp = nameiparent(path, name)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            iput(dp);</span><br><span class="line">            <span class="comment">// 新建一个 path 节点</span></span><br><span class="line">            <span class="comment">// 返回的 dp 带锁且引用计数 +1</span></span><br><span class="line">            <span class="keyword">if</span>((dp = create(path, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad;</span><br><span class="line">            &#125;</span><br><span class="line">            iunlock(dp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ilock(dp);</span><br><span class="line">    <span class="comment">// 把 target 写入 dp 的 data 字段中</span></span><br><span class="line">    writei(dp, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, MAXPATH);</span><br><span class="line">    <span class="comment">// 设置 dp 类型</span></span><br><span class="line">    <span class="comment">// dp-&gt;type = T_SYMLINK;(已经设置了)</span></span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    <span class="comment">// iput(ip); 之前调用 iunlockput() 了</span></span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bad:</span><br><span class="line">    ilock(ip);</span><br><span class="line">    ip-&gt;nlink--;</span><br><span class="line">    iupdate(ip);</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-sys-open-的实现"><a href="#3-sys-open-的实现" class="headerlink" title="[3] sys_open() 的实现"></a>[3] sys_open() 的实现</h5><ul>
<li>在打开文件的时候进行一个判断，如果是软链接同时没有 <code>O_NOFOLLOW</code> flag 的话，就打开软链接对应的文件即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if((ip = namei(path)) == 0)&#123;</span></span><br><span class="line">    <span class="comment">//   end_op();</span></span><br><span class="line">    <span class="comment">//   return -1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">if</span>((ip = namei_check_symlink(path , <span class="number">0</span>, omode)) == <span class="number">0</span>) &#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>namei_check_symlink() 如下<ul>
<li>显式的递归深度检测</li>
<li>注意细节 iput()，因为切换到下一个文件，因此将引用计数-1</li>
<li>读取 target 的时候，注意是在 data 段的开头</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回如果不为 0, 计数 +1</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode* <span class="title function_">namei_check_symlink</span><span class="params">(<span class="type">char</span> *path, uint depth, <span class="type">int</span> omode)</span> &#123;</span><br><span class="line">    <span class="comment">// 利用一个显式的递归深度检测环</span></span><br><span class="line">    <span class="keyword">if</span>(depth &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">    <span class="comment">// 文件不存在(symlink 允许 target 不存在)</span></span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="comment">// 如果带有 O_NOFOLLOW flag, 则只需要打开软链接文件本身</span></span><br><span class="line">    <span class="keyword">if</span>(!(omode &amp; O_NOFOLLOW) &amp;&amp; ip-&gt;type == T_SYMLINK) &#123;</span><br><span class="line">        <span class="type">char</span> next[MAXPATH];</span><br><span class="line">        <span class="comment">// 保存在 data 的开始</span></span><br><span class="line">        <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)next, <span class="number">0</span>, MAXPATH) == <span class="number">0</span>) &#123;</span><br><span class="line">            iunlock(ip);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iunlock(ip);</span><br><span class="line">        iput(ip); <span class="comment">// 接着下一个文件了, 因此当前文件的引用计数-1</span></span><br><span class="line">        <span class="keyword">return</span> namei_check_symlink(next, depth + <span class="number">1</span> ,omode);</span><br><span class="line">    &#125;</span><br><span class="line">    iunlock(ip);</span><br><span class="line">    <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3. 实验结果"></a>3. 实验结果</h2><ul>
<li>bigfile 和 usertests 不能在规定时间内完成任务（电脑性能问题）</li>
<li>修改了 timeout</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@test(<span class="params"><span class="number">40</span>, <span class="string">&quot;running bigfile&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_bigfile</span>():</span><br><span class="line">    r.run_qemu(shell_script([</span><br><span class="line">        <span class="string">&#x27;bigfile&#x27;</span></span><br><span class="line">    ]), timeout=<span class="number">500</span>) <span class="comment"># 原来是 360, 最终耗时 381</span></span><br><span class="line">    r.<span class="keyword">match</span>(<span class="string">&#x27;^wrote 65803 blocks$&#x27;</span>)</span><br><span class="line">    r.<span class="keyword">match</span>(<span class="string">&#x27;^bigfile done; ok$&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@test(<span class="params"><span class="number">19</span>, <span class="string">&quot;usertests&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_usertests</span>():</span><br><span class="line">    r.run_qemu(shell_script([</span><br><span class="line">        <span class="string">&#x27;usertests&#x27;</span></span><br><span class="line">    ]), timeout=<span class="number">1000</span>) <span class="comment"># 原来是 360, 最终耗时 566.5</span></span><br><span class="line">    r.<span class="keyword">match</span>(<span class="string">&#x27;^ALL TESTS PASSED$&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu-gdb</span><br><span class="line">running bigfile: OK (381.0s)</span><br><span class="line">    (Old xv6.out.bigfile failure <span class="built_in">log</span> removed)</span><br><span class="line">== Test running symlinktest ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(3.0s)</span><br><span class="line">== Test   symlinktest: symlinks ==</span><br><span class="line">  symlinktest: symlinks: OK</span><br><span class="line">== Test   symlinktest: concurrent symlinks ==</span><br><span class="line">  symlinktest: concurrent symlinks: OK</span><br><span class="line">== Test usertests ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">  usertests: OK (566.5s)</span><br><span class="line">    (Old xv6.out.usertests failure <span class="built_in">log</span> removed)</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 100/100</span><br></pre></td></tr></table></figure>



<h2 id="4-遇到的困难以及收获"><a href="#4-遇到的困难以及收获" class="headerlink" title="4. 遇到的困难以及收获"></a>4. 遇到的困难以及收获</h2><ul>
<li>第一部分修改宏的时候，没有把所有引用宏的地方都对应上，因此报了奇怪的错误</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic : virtio_disk_intr status</span><br></pre></td></tr></table></figure>

<ul>
<li>以后得注意，在修改已有代码段的时候，需要注意所有引用在修改后还是正确的</li>
<li>文件系统的设计确实很巧妙，函数之间的相互调用需要符合一定的规范<ul>
<li>例如引用计数以及锁的设计，感觉都得好好思考才能做出答案</li>
</ul>
</li>
<li>感觉 symlink 的 path 可以存在这个设定确实不太合理</li>
</ul>
<h2 id="5-对课程或-lab-的意见和建议"><a href="#5-对课程或-lab-的意见和建议" class="headerlink" title="5. 对课程或 lab 的意见和建议"></a>5. 对课程或 lab 的意见和建议</h2><ul>
<li>建议提供一些关于 lab 的 debug 功能的指导</li>
</ul>
<h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev1.pdf">https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev1.pdf</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/09/OS/xv6-labs/lab8-file-system/" data-id="cl9lj74bf00j864tz4aem3ca8" data-title="xv6-labs-2020.lab8.file system" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xv6/" rel="tag">xv6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OS/xv6-source-code/05-FileSystem" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/07/OS/xv6-source-code/05-FileSystem/" class="article-date">
  <time class="dt-published" datetime="2021-06-07T05:00:00.000Z" itemprop="datePublished">2021-06-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OS-xv6-source-code/">OS.xv6-source-code</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/07/OS/xv6-source-code/05-FileSystem/">xv6-riscv-源代码阅读.文件系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="XV6-源代码阅读——文件系统"><a href="#XV6-源代码阅读——文件系统" class="headerlink" title="XV6 源代码阅读——文件系统"></a>XV6 源代码阅读——文件系统</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>阅读的代码是 <code>xv6-riscv</code> 版本的</li>
<li>涉及到的文件如下<ul>
<li><code>kernel</code><ul>
<li><code>buf.h</code>、<code>bio.c</code>、<code>param.h</code>、<code>log.c</code>、<code>fs.h</code>、<code>file.h</code>、<code>file.c</code>、<code>fs.c</code>、<code>stat.h</code>、<code>fcntl.h</code>、<code>sysfile.c</code>、<code>ide.c</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><ul>
<li>这一部分为阅读 <code>book-riscv-rec1</code> 的笔记</li>
</ul>
<h3 id="文件系统的目标"><a href="#文件系统的目标" class="headerlink" title="文件系统的目标"></a>文件系统的目标</h3><ul>
<li>文件系统需要解决的几个问题<ul>
<li>需要有一个保存在磁盘上的数据结构，保存文件的结构信息、文件本身、空闲的磁盘区域</li>
<li>需要支持故障重启（crash recovery）</li>
<li>多进程的并发访问</li>
<li>磁盘访问是慢速的，需要维护一个 cache，保存经常访问的块</li>
</ul>
</li>
</ul>
<h3 id="七层结构"><a href="#七层结构" class="headerlink" title="七层结构"></a>七层结构</h3><ul>
<li>xv6 的文件系统是七层结构</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Layers of the xv6 file system</th>
</tr>
</thead>
<tbody><tr>
<td align="center">File Discriptor</td>
</tr>
<tr>
<td align="center">Pathname</td>
</tr>
<tr>
<td align="center">Directory</td>
</tr>
<tr>
<td align="center">Inode</td>
</tr>
<tr>
<td align="center">Logging</td>
</tr>
<tr>
<td align="center">Buffer cache</td>
</tr>
<tr>
<td align="center">Disk</td>
</tr>
</tbody></table>
<ul>
<li>disk 层从一个虚拟硬盘（vitro hard drive）上读取 block</li>
<li>buffer cache 层缓存 block<ul>
<li>保证同一个 block 只能被一个内核进程同时访问</li>
</ul>
</li>
<li>logging 层记录一些日志信息，用于出错恢复</li>
<li>inode 层是一个独立的文件，唯一的 i-number 和一些存储数据的块</li>
<li>directory 层把文件夹封装称为一些特殊的 inode<ul>
<li>内容为一些列目录项，包括文件名和 i-number</li>
</ul>
</li>
<li>pathname 层提供一个层次化的树结构，处理了递归包含的情况</li>
<li>file descriptor 层把 pipes, devices, files 等都抽象为文件，使用统一的文件系统的接口</li>
</ul>
<h3 id="物理存放结构"><a href="#物理存放结构" class="headerlink" title="物理存放结构"></a>物理存放结构</h3><img src="05-FileSystem/image-20210604192843755.png" style="zoom: 80%;" />

<ul>
<li>第 0 块保留，用于存储引导扇区</li>
<li>第 1 块为超级块（superblock），保存着文件系统的元数据、一些用于构建初始操作系统的代码（称为 <code>mkfs</code>）<ul>
<li>元数据<ul>
<li>文件系统的大小（多少块）</li>
<li>数据有多少块</li>
<li>inode 有多少个</li>
<li>log 占多少块</li>
</ul>
</li>
</ul>
</li>
<li>从第 2 块开始，保存 log 信息<ul>
<li>大小为 <code>LOGSIZE+1=(MAXOPBLOCKS*3)+1=31</code></li>
</ul>
</li>
<li>接下来是 inode（每个块有多个 inode）</li>
<li>接着是 bitmap blocks，用来保存那些块是被使用或空闲的</li>
<li>最后是数据块（要么是文件夹或文件，要么在 bitmap 中标记为空闲）</li>
</ul>
<h3 id="Buffer-cache-层"><a href="#Buffer-cache-层" class="headerlink" title="Buffer cache 层"></a>Buffer cache 层</h3><ul>
<li>两个目标<ul>
<li>同步磁盘块，保证每个磁盘块在内存中最多只有一个拷贝，保证每一个磁盘块的拷贝只能被一个内核线程使用</li>
<li>缓存 popular blocks，减少访问磁盘导致的开销</li>
</ul>
</li>
<li>对上提供的接口如下<ul>
<li>bread()：获取一个磁盘块的拷贝到内存中</li>
<li>bwrite()：将缓存写入磁盘的对应块中</li>
<li>brelse()：释放缓存块（<strong>用完必须得释放</strong>）</li>
</ul>
</li>
<li>通过给每一个 buffer 分配一个 sleeplock 的方式实现一个磁盘块的拷贝只能被一个内核线程使用<ul>
<li>bread() 返回一个带锁的 buffer</li>
<li>brelse() 释放锁</li>
</ul>
</li>
<li>当需要的磁盘块没有读入内存的时候，通过 LRU 的方式回收一个 buffer，并从磁盘中将对应块读入内存<ul>
<li>通过 <code>virtio_disk_rw(b, 0)</code> 实现</li>
</ul>
</li>
</ul>
<h3 id="Buffer-cache-层（代码实现）"><a href="#Buffer-cache-层（代码实现）" class="headerlink" title="Buffer cache 层（代码实现）"></a>Buffer cache 层（代码实现）</h3><ul>
<li><code>kernel/bio.c</code></li>
<li>一共有 30 个 buffer<ul>
<li><code>NBUF=(MAXOPBLOCKS*3)=30</code></li>
</ul>
</li>
<li>通过 <code>binit()</code>  将，所有的 buffer 保存为一个静态的数组<ul>
<li>组织成一个双向循环链表（为了实现 LRU 的替换算法）</li>
<li>为了方便组织，这个双向链表带一个空的虚拟头结点</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/bio.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>

<ul>
<li>每一个 buffer 的数据结构如下<ul>
<li>valid 字段表示这个 buffer 是否对应磁盘上的某一个块（1 表示有对应）</li>
<li>disk 字段表示是否将 buffer 中的信息写回了磁盘上（1 表示修改了未写回）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/buf.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">    <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">    uint dev;</span><br><span class="line">    uint blockno;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">    uint refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">    uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>bread() 函数调用 bget() 获取一个 buffer<ul>
<li>如果返回一个 <code>valid=1</code> 的 buffer，说明待读取的 buffer 已经在内存中了</li>
<li>如果返回一个 <code>valid=0</code> 的 buffer，说明待读取的 buffer 尚未进入内存，通过调用 <code>virtio_disk_rw(b, 0)</code> 从磁盘中将其读入内存（buffer 中）</li>
</ul>
</li>
<li>bget() 的逻辑如下<ul>
<li>首先扫描整个链表，看需要读取的内容是否被缓存，若缓存了，直接返回</li>
<li>若未缓存，从链表开始扫描，找到一个空闲的 buffer（refcnt&#x3D;0） 返回<ul>
<li>注意此时需要把 valid 项置为 0，表明需要从磁盘中读取具体的内容</li>
</ul>
</li>
<li>如果还没找到，则报错 <code>panic()</code></li>
<li>注意返回的 buffer 是带锁的</li>
</ul>
</li>
<li>bget() 的整个过程都是持有锁 <code>bcache.lock</code> 的，因此保证了每一个磁盘块在 buffer 中最多只会有一个拷贝</li>
<li>如果修改了 buffer 中的内容，需要调用 bwrite() 将内容写回磁盘，内部调用 <code>virtio_disk_rw(b, 1)</code> 实现</li>
<li>最终需要调用 brelse() 进行释放缓存块，将 refcnt 减 1，同时得释放 buffer 上的锁<ul>
<li>如果 refcnt 为 0，将这个 buffer 插入到链表头的后面<ul>
<li>这就保证了 LRU 的实现，在逆向查找，找到的第一个空闲块一定是最老的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="logging-层"><a href="#logging-层" class="headerlink" title="logging 层"></a>logging 层</h3><ul>
<li>这一部分的设计主要是为了处理故障恢复的问题</li>
<li>例如在一个操作执行到一半的时候发生了故障，此时可能出现磁盘内容不一致的情况</li>
<li>当需要向磁盘写入内容的时候，xv6 先向磁盘上写一个日志记录，当把所有的写操作都计入日志之后，写一个 commit 表示日志记录完整，此时再进行系统调用将内容写入磁盘，当内容都写完之后，在磁盘上消去这个日志信息</li>
<li>系统崩溃重启之后的流程如下<ul>
<li>检查日志记录，如果有完整的操作，那么就执行，如果操作不完整，则直接忽略</li>
</ul>
</li>
<li>日志记录保证了这个操作是原子的（全或无）</li>
</ul>
<h3 id="log-的设计"><a href="#log-的设计" class="headerlink" title="log 的设计"></a>log 的设计</h3><ul>
<li>log 在磁盘中的位置是确定的，在 superblock 中能够找到</li>
<li>由一个头块（header block）和一些更新的块（logged blocks）组成</li>
<li>header block<ul>
<li>一个扇区编号的数组<ul>
<li>对应扇区磁盘内容写入<strong>下标+1</strong>所在的 log 块中，具体见下面的<a href="#code01">代码</a></li>
</ul>
</li>
<li>日志块的个数</li>
</ul>
</li>
<li>header block 占据一个块的大小，具体在 initlog() 有检查</li>
<li>计数要么为 0（没有需要处理的记录），要么非零（表示存在一个事务，即一组待处理的写操作）</li>
<li>一个事务可能包含一组系统调用，为了避免一个有关文件系统的系统调用被拆分为多个事务，因此 commit 只在没有有关文件系统的系统调用出现时进行</li>
<li>在日志处理中，log 块的空间是固定的，因此如果需要写的内容太多的话会出问题<ul>
<li>两个系统调用 write、unlink 写的内容可能会过大<ul>
<li>xv6 的实现可以把一个很多块的写操作拆分为若干个较少块的写操作，解决上述问题</li>
</ul>
</li>
<li>如果一个有关文件系统的系统调用写的内容超过了 log 区域中剩余块的大小，此时这个系统调用不会被执行</li>
</ul>
</li>
</ul>
<h3 id="logging-层（代码实现）"><a href="#logging-层（代码实现）" class="headerlink" title="logging 层（代码实现）"></a>logging 层（代码实现）</h3><ul>
<li><code>kernel/log.c</code></li>
<li>一个典型的在系统调用中使用 log 机制的方式如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin_op();</span><br><span class="line">...</span><br><span class="line">bp = bread(...);</span><br><span class="line">bp-&gt;data[...] = ...;</span><br><span class="line">log_write(bp);</span><br><span class="line">...</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure>



<h4 id="begin-op"><a href="#begin-op" class="headerlink" title="begin_op()"></a>begin_op()</h4><ul>
<li>等待，直到 log 系统没有 committing 而且有充足的 log blocks<ul>
<li>xv6 认为每个系统调用只会使用 MAXOPBLOCKS（10） 个 block</li>
</ul>
</li>
<li>满足条件后，系统调用数 +1 并返回<ul>
<li>log.outstanding 记录使用 log 系统的系统调用数</li>
</ul>
</li>
</ul>
<h4 id="log-write"><a href="#log-write" class="headerlink" title="log_write()"></a>log_write()</h4><ul>
<li>把 buffer 的磁盘块号保存到 log 中，同时做一个优化（absorbtion）<ul>
<li>找到一个同一磁盘块的拷贝时，用新的修改覆盖它即可（直接说使用原来留下的 slot）<ul>
<li>因为反正前一个修改会被覆盖</li>
</ul>
</li>
</ul>
</li>
<li>同时把 buffer 的 refcnt +1（避免被替换出去）</li>
</ul>
<h4 id="end-op"><a href="#end-op" class="headerlink" title="end_op()"></a>end_op()</h4><ul>
<li>首先将计数 log.outstanding -1（系统调用数 -1）</li>
<li>如果此时计数变成 0，则调用 commit() 进行 commit</li>
</ul>
<h5 id="commit"><a href="#commit" class="headerlink" title="commit()"></a>commit()</h5><ul>
<li>commit() 分为 4 个步骤</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/log.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">commit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write_log();     <span class="comment">// Write modified blocks from cache to log</span></span><br><span class="line">        write_head();    <span class="comment">// Write header to disk -- the real commit</span></span><br><span class="line">        install_trans(<span class="number">0</span>); <span class="comment">// Now install writes to home locations</span></span><br><span class="line">        <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">        write_head();    <span class="comment">// Erase the transaction from the log</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>write_log()：把具体的内容写入 log 对应的磁盘块里<ul>
<li>通过调用 bread() 读取磁盘块、memmove() 内存复制、bwrite() 写入磁盘完成<ul>
<li>需要写入的磁盘区域 $\to$ 对应的 log 块</li>
</ul>
</li>
<li><span id="code01">代码如下</span>，注意这里的 log 数组中记录的磁盘块写入对应<strong>下标+1</strong>的 log 块中，因为第一块留给了 log 的 head</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/log.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_log</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> tail;</span><br><span class="line">    <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">to</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// log block</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">from</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// cache block</span></span><br><span class="line">        memmove(to-&gt;data, from-&gt;data, BSIZE);</span><br><span class="line">        bwrite(to);  <span class="comment">// write the log</span></span><br><span class="line">        brelse(from);</span><br><span class="line">        brelse(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>write_head()：把 log 块的头信息写入磁盘<ul>
<li>log 块区域的第一块是 log 的 header 块</li>
<li>这一个区域完成之后就实现了 commit() 的功能，就来来执行真正的写操作</li>
</ul>
</li>
<li>install_trans()：执行原来要求的写操作<ul>
<li>通过调用 bread() 读取磁盘块、memmove() 内存复制、bwrite() 写入磁盘完成<ul>
<li>对应的 log 块 $\to$ 需要写入的磁盘区域</li>
</ul>
</li>
</ul>
</li>
<li>write_head()：将磁盘块中的头信息清空（将计数归零）</li>
</ul>
<h4 id="recover-from-log"><a href="#recover-from-log" class="headerlink" title="recover_from_log()"></a>recover_from_log()</h4><ul>
<li>这一部分是用于故障恢复的</li>
<li>很简单的实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/log.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">recover_from_log</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    read_head();</span><br><span class="line">    install_trans(<span class="number">1</span>); <span class="comment">// if committed, copy from log to disk</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">    write_head(); <span class="comment">// clear the log</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这部分代码会在系统启动的时候调用<ul>
<li>fsinit() $\to$ initlog() $\to$ recover_from_log()</li>
</ul>
</li>
<li>注意这里的 install_trans() 的参数 1<ul>
<li>因为如果不是恢复，log_write() 的操作为了不让墓表块释放，因此会将引用计数+1，此时在 install_trans() 中需要 -1，但是在恢复的时候没有进行这个操作，所以不需要 -1</li>
</ul>
</li>
</ul>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><ul>
<li>file.c 的 filewrite() 表示一个例子<ul>
<li>注意这里为了避免文件一次写的太大，把文件拆分为多个写操作</li>
</ul>
</li>
</ul>
<h3 id="块分配器（bitmap）"><a href="#块分配器（bitmap）" class="headerlink" title="块分配器（bitmap）"></a>块分配器（bitmap）</h3><ul>
<li>通过 bitmap 记录一个磁盘块是否空闲（0 表示空闲）<ul>
<li>在系统启动的时候，<code>mkfs</code> 代码会将 boot sector、superblock、log blocks、inode blocks、bitmap 对应在 bitmap 中的值设置为 1</li>
</ul>
</li>
<li>代码：<code>kernel/fs.c</code></li>
<li>balloc() 函数从磁盘中找一个空闲的磁盘块并返回（bitmap 中标记为 0）</li>
<li>bfree() 函数释放一个指定的磁盘块</li>
<li>读取 bitmap 的块</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp = bread(dev, BBLOCK(b, sb));</span><br></pre></td></tr></table></figure>

<ul>
<li>bitmap 只能被一个进程同时访问<ul>
<li>因为在最后需要调用 brelse()&#x2F;bread()，这已经隐式加上了锁，所以不需要对 bitmap 显式加锁</li>
</ul>
</li>
</ul>
<h3 id="Inode-层"><a href="#Inode-层" class="headerlink" title="Inode 层"></a>Inode 层</h3><ul>
<li>两种含义<ul>
<li>磁盘上的数据结构（on-disk），包含文件的大小和一个数据存放位置的列表</li>
<li>内存中的数据结构（in-memory），包括磁盘上数据结构的一个拷贝以及一些内核需要用到的内容</li>
</ul>
</li>
</ul>
<h4 id="on-disk"><a href="#on-disk" class="headerlink" title="on-disk"></a>on-disk</h4><ul>
<li>磁盘上的 inode 被放置在 inode blocks 中，大小都是相同的，给定一个 n（i-number）就能找到第 n 个 inode 的位置</li>
<li>数据结构如下<ul>
<li>type：file、directory、special files（devices）、0（表示空闲）</li>
<li>nlink：引用数（用于判断数据块是否该被释放）</li>
<li>size：文件所占据的字节数</li>
<li>addrs：文件所在数据块的地址</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.h</span></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">    <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">    <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">    <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">    uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">    uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="in-memory"><a href="#in-memory" class="headerlink" title="in-memory"></a>in-memory</h4><ul>
<li>数据结构如下，除了上面的 dinode 之外还有一些其他的字段<ul>
<li>ref 记录引用数（用于判断这个数据结构是否该被释放）<ul>
<li>iget()、iput() 增加和减少引用数</li>
<li>引用来源：文件描述符、当前工作目录、暂时的内核代码（exec 等）</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/file.h</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    uint dev;           <span class="comment">// Device number</span></span><br><span class="line">    uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">    <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">    <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">    <span class="type">short</span> major;</span><br><span class="line">    <span class="type">short</span> minor;</span><br><span class="line">    <span class="type">short</span> nlink;</span><br><span class="line">    uint size;</span><br><span class="line">    uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>有 4 种锁的机制<ul>
<li>icache.lock 保证一个 inode 只会在缓存中出现一次，保证引用计数 ref 的正确<ul>
<li>好像是 itable.lock</li>
</ul>
</li>
<li>每一个 inode 都有一个 sleeplock，用于保证其内部字段的独占访问</li>
<li>ref 不为 0 的时候这个 entry  不会被回收</li>
<li>nlink 字段表示这个文件的引用数（他不为 0，xv6 就不会释放 entry）</li>
</ul>
</li>
<li>iget() 返回一个 inode<ul>
<li>如果是新使用的，valid &#x3D; 0，之后使用的时候会从磁盘读入（ilock() 实现读入）</li>
</ul>
</li>
<li>ilock() 是加锁的，iget() 不加锁</li>
<li>inode cache 是 write-through（直写的），调用 iupdate() 直接反应到磁盘上</li>
</ul>
<h3 id="Inode-层（代码实现）"><a href="#Inode-层（代码实现）" class="headerlink" title="Inode 层（代码实现）"></a>Inode 层（代码实现）</h3><ul>
<li>分配一个新的 inode 结点（新建文件等）的流程如下</li>
<li>调用 ialloc()<ul>
<li>从标号为 1的 inode 的开始查找，找到一个空闲的 inode 之后，调用 iget() 返回<ul>
<li>标号为 0 是预留的？</li>
<li>根节点也是从 1 开始的（<code>#define ROOTINO 1 </code>）</li>
</ul>
</li>
</ul>
</li>
<li>iget()<ul>
<li>先看看有没有缓存，若有缓存，则引用数 ref +1，直接返回</li>
<li>如果没有找到，则将第一个空闲的 inode 返回</li>
</ul>
</li>
<li>ilock()<ul>
<li>想要对 inode 进行读写操作的时候，需要先对 inode 获取锁（调用 ilock）</li>
<li>同时 ilock 会检查这个内容有没有从磁盘冲读进内存，如果没有则读入</li>
</ul>
</li>
<li>iunlock()<ul>
<li>释放锁</li>
</ul>
</li>
<li>iput()<ul>
<li>引用数 ref -1</li>
<li>如果减完之后计数为 0，同时 valid&#x3D;1，nlink&#x3D;0 的话，释放数据块</li>
</ul>
</li>
<li>可能会出现这样一种情况，nlink&#x3D;0，ref 不为 0，此时 inode 没有被释放<ul>
<li>当 ref 被减为 0 的瞬间，系统崩溃了</li>
<li>重启的时候我们知道 nlink&#x3D;0 的文件是没有用的，但是我们在磁盘上这块空间并未被释放</li>
<li>xv6 没有针对这个问题进行补救，因此可能出现磁盘空间耗尽的情况</li>
</ul>
</li>
</ul>
<h3 id="Inode-的内容"><a href="#Inode-的内容" class="headerlink" title="Inode 的内容"></a>Inode 的内容</h3><ul>
<li>结构如下<ul>
<li>前 12 块是直接索引，后面 256 块是间接索引</li>
<li>文件最大大小为  268kB</li>
</ul>
</li>
</ul>
<img src="05-FileSystem/image-20210606150134024.png" style="zoom:80%;" />

<ul>
<li>bmap() 返回第 n 个数据块的地址<ul>
<li>按照上面的索引方式找出即可</li>
<li>越界 panic，如果没有则分配一个</li>
</ul>
</li>
<li>itruc() 释放数据块<ul>
<li>遍历所有索引，如果不为 0，就释放，最后把间接索引块也释放了</li>
</ul>
</li>
<li>stati() 将 inode 的元数据拷贝返回一个数据结构 <code>stat</code></li>
</ul>
<h3 id="Directory-层（代码实现）"><a href="#Directory-层（代码实现）" class="headerlink" title="Directory 层（代码实现）"></a>Directory 层（代码实现）</h3><ul>
<li>和文件相似，只不过 type&#x3D;T_DIR，内容为一组目录项，每一个目录项的结构如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    ushort inum;</span><br><span class="line">    <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>name 最长为 <code>DIRSIZ=14</code> 个字符</li>
<li>dirlookup()<ul>
<li>在一个目录中查找指定 name 的文件，返回 inode 指针</li>
</ul>
</li>
<li>dirlink()<ul>
<li>按照给定的 name，新建一个新的文件夹<ul>
<li>遍历 entry，找到一个空闲的返回</li>
<li>如果已经存在，则报错</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Pathname-层（代码实现）"><a href="#Pathname-层（代码实现）" class="headerlink" title="Pathname 层（代码实现）"></a>Pathname 层（代码实现）</h3><ul>
<li>通过一系列的 dirlookup() 实现</li>
<li>namei() 返回待查找文件的 inode</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.c</span></span><br><span class="line"><span class="keyword">struct</span> inode* <span class="title function_">namei</span><span class="params">(<span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>nameiparent() 返回待查找文件的父节点的 inode，同时返回文件名到 name 中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.c</span></span><br><span class="line"><span class="keyword">struct</span> inode* <span class="title function_">nameiparent</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面两个函数最终调用 namex() 实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode* <span class="title function_">namex</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> nameiparent, <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>namex() 逻辑如下<ul>
<li>首先判断是相对路径还是绝对路径，返回查找的起始 inode<ul>
<li><code>/</code> 从根目录开始的绝对路径</li>
<li>其他为相对路径</li>
</ul>
</li>
<li>接着就是一个递归查询，直到找到最终的结果，返回 inode</li>
</ul>
</li>
</ul>
<h3 id="File-descriptor-层"><a href="#File-descriptor-层" class="headerlink" title="File descriptor 层"></a>File descriptor 层</h3><ul>
<li>Unix 把很多东西都抽象为文件，</li>
<li>xv6 给每一个进程维护了一个文件描述符表</li>
<li>所有的打开文件保存在一个全局的文件表（file table <code>ftable</code>）里</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/file.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file</span>[<span class="title">NFILE</span>];</span> <span class="comment">// NFILE = 100</span></span><br><span class="line">&#125; ftable;</span><br></pre></td></tr></table></figure>

<ul>
<li>filealloc()<ul>
<li>从 ftable 中找一个引用为 0 （空闲）的文件返回</li>
</ul>
</li>
<li>filedup()<ul>
<li>引用计数 +1，返回</li>
</ul>
</li>
<li>fileclose()<ul>
<li>引用计数 -1，如果为 0，同设置 type 为 FD_NONE</li>
</ul>
</li>
<li>filestat()<ul>
<li>调用 stati() 获取文件元数据</li>
</ul>
</li>
<li>fileread()<ul>
<li>调用 readi() 读取文件数据</li>
</ul>
</li>
<li>filewrite()<ul>
<li>封装了 writei()</li>
</ul>
</li>
</ul>
<h3 id="系统调用（代码实现）"><a href="#系统调用（代码实现）" class="headerlink" title="系统调用（代码实现）"></a>系统调用（代码实现）</h3><h4 id="sys-link"><a href="#sys-link" class="headerlink" title="sys_link()"></a>sys_link()</h4><ul>
<li>过程见注释</li>
<li>效果是将 new 指向 old</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line"><span class="comment">// Create the path new as a link to the same inode as old.</span></span><br><span class="line">uint64 <span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[DIRSIZ], new[MAXPATH], old[MAXPATH];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dp</span>, *<span class="title">ip</span>;</span></span><br><span class="line">    <span class="comment">// 读取两个系统调用的参数</span></span><br><span class="line">    <span class="keyword">if</span>(argstr(<span class="number">0</span>, old, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, new, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// begin_op();</span></span><br><span class="line">    begin_op();</span><br><span class="line">    <span class="comment">// 判断 old 文件存在</span></span><br><span class="line">    <span class="keyword">if</span>((ip = namei(old)) == <span class="number">0</span>)&#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="comment">// 不能是文件夹</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_DIR)&#123;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 引用+1</span></span><br><span class="line">    ip-&gt;nlink++;</span><br><span class="line">    iupdate(ip);</span><br><span class="line">    iunlock(ip);</span><br><span class="line">    <span class="comment">// new 的父节点得存在</span></span><br><span class="line">    <span class="keyword">if</span>((dp = nameiparent(new, name)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    ilock(dp);</span><br><span class="line">    <span class="comment">// 得在同一设备上</span></span><br><span class="line">    <span class="comment">// link 得成功</span></span><br><span class="line">    <span class="keyword">if</span>(dp-&gt;dev != ip-&gt;dev || dirlink(dp, name, ip-&gt;inum) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        iunlockput(dp);</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="comment">// end_op();</span></span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    ilock(ip);</span><br><span class="line">    ip-&gt;nlink--;</span><br><span class="line">    iupdate(ip);</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h2><blockquote>
<p>了解UNIX 文件系统的主要组成部分：超级块（superblock），i 节点（inode），数据块（data block），目录块（directory block），间接块（indirection block）。分别解释它们的作用。。</p>
</blockquote>
<ul>
<li>超级块：指的是 Unix 文件系统存储的源信息，包括具体的物理内存分布情况，每一块区域占据的大小等</li>
<li>i 节点：保存文件系统的树形结构</li>
<li>数据块：保存文件的具体数据</li>
<li>Unix 文件系统的文件夹保存目录项，前 12 个目录项为直接索引，保存的是文件的起始块的地址，接着是一级索引块、二级索引块、三级索引块。<ul>
<li>目录块指的是文件夹保存的块，保存在 i 节点区</li>
<li>间接块指的是索引块，保存在文件和目录区</li>
</ul>
</li>
</ul>
<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h2><blockquote>
<p>阅读文件 ide.c。这是一个简单的 ide 硬盘驱动程序，对其内容作大致了解。</p>
</blockquote>
<ul>
<li>xv6-riscv 中没有这个文件</li>
<li><code>mkfs.c</code> 中是文件系统启动时运行的，保存在引导块中的代码<ul>
<li>主要是设置超级块中的元数据</li>
</ul>
</li>
<li>xv6-riscv 中由 7 层结构组成，每一层实现一些具体的功能，然后为上层结构提供一些接口<ul>
<li>具体的内容在上面不同层的设计中已经提到了</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Layers of the xv6 file system</th>
</tr>
</thead>
<tbody><tr>
<td align="center">File Discriptor</td>
</tr>
<tr>
<td align="center">Pathname</td>
</tr>
<tr>
<td align="center">Directory</td>
</tr>
<tr>
<td align="center">Inode</td>
</tr>
<tr>
<td align="center">Logging</td>
</tr>
<tr>
<td align="center">Buffer cache</td>
</tr>
<tr>
<td align="center">Disk</td>
</tr>
</tbody></table>
<h2 id="问题-3"><a href="#问题-3" class="headerlink" title="问题 3"></a>问题 3</h2><blockquote>
<p>阅读文件buf.h、bio.c。了解XV6 文件系统中buffer cache 层的内容和实现。描述 buffer 双链表数据结构及其初始化过程，了解 buffer 的状态，了解对 buffer 的各种操作。</p>
</blockquote>
<ul>
<li>xv6-riscv 的 buffer 一共 30 个，组织成一个双向链表的结构（虚拟头节点，虚拟头节点的 prev 指针指向最后一个节点）</li>
<li>初始化部分就是把 buffer 数组组织成一个双向链表，buffer 字段初始化为 0</li>
<li>更加细节的答案部分见上面的阅读笔记部分，以下是上面部分的超链接（点击可以跳转到上面）<ul>
<li>[逻辑部分](#Buffer cache 层)</li>
<li>[代码实现部分](#Buffer cache 层（代码实现）)</li>
</ul>
</li>
</ul>
<h2 id="问题-4"><a href="#问题-4" class="headerlink" title="问题 4"></a>问题 4</h2><blockquote>
<p>阅读文件 log.c，了解XV6 文件系统中的 logging 和 transaction 机制。</p>
</blockquote>
<ul>
<li>简单的来说，xv6-riscv 在磁盘中预留了一大块区域用于 log 机制，这是用于故障恢复的</li>
<li>主要过程如下<ul>
<li>对于磁盘块的写操作，我们不直接写磁盘，像将其写入 log 块中，写完之后将 log 的 header 信息写入磁盘</li>
<li>这个时候所有数据已经写入 log 磁盘了，此时可以进行真正的写操作</li>
<li>我们将这些块从 log 区域读取出来，接着将其写入原来要写入的磁盘块中</li>
</ul>
</li>
<li>以上的操作保证了对于磁盘块的写是全或无的，不会出现不一致性</li>
<li>更加细节的答案部分见上面的阅读笔记部分，以下是上面部分的超链接（点击可以跳转到上面）<ul>
<li>[逻辑部分](#logging 层)</li>
<li>[代码实现部分](#logging 层（代码实现）)</li>
</ul>
</li>
</ul>
<h2 id="问题-5"><a href="#问题-5" class="headerlink" title="问题 5"></a>问题 5</h2><blockquote>
<p>阅读文件 fs.h、fs.c，了解 XV6 文件系统的磁盘布局</p>
</blockquote>
<ul>
<li>磁盘布局如下</li>
</ul>
<img src="05-FileSystem/image-20210604192843755.png" style="zoom: 80%;" />

<ul>
<li>boot loader 占据一块</li>
<li>superblock 占据一块</li>
<li>log 占据 31 块（1 个头和 30 个log 块）</li>
<li>更加细节的答案部分见上面的阅读笔记部分，以下是上面部分的超链接（点击可以跳转到上面）<ul>
<li><a href="#%E7%89%A9%E7%90%86%E5%AD%98%E6%94%BE%E7%BB%93%E6%9E%84">物理存放结构</a></li>
</ul>
</li>
<li>大小（<code>make qemu</code> 输出）</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nmeta 70 (</span><br><span class="line">    boot,</span><br><span class="line">    super,</span><br><span class="line">    log blocks 30</span><br><span class="line">    inode blocks 13,</span><br><span class="line">    bitmap blocks 25</span><br><span class="line">)</span><br><span class="line">blocks 199930</span><br><span class="line">total 200000</span><br></pre></td></tr></table></figure>





<h2 id="问题-6"><a href="#问题-6" class="headerlink" title="问题 6"></a>问题 6</h2><blockquote>
<p>阅读文件 file.h、file.c，了解 XV6 的 “文件” 有哪些，以及文件、i 节点、设备相关的数据结构。了解 XV6 有哪些文件的基本操作？XV6 最多支持多少个文件？每个进程最多能打开多少个文件？</p>
</blockquote>
<ul>
<li>xv6-riscv 中的文件类型如下<ul>
<li>pipe、普通文件（文件、文件夹）、device</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/file.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br></pre></td></tr></table></figure>

<ul>
<li>文件的数据结构如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/file.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">    <span class="type">int</span> ref;           <span class="comment">// reference count</span></span><br><span class="line">    <span class="type">char</span> readable;</span><br><span class="line">    <span class="type">char</span> writable;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">    uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line">    <span class="type">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>inode 的数据结构有两个<ul>
<li>一个是保存在磁盘上的 inode，保存的是元数据</li>
<li>另一个是保存在内存中的数据结构，包含上面的部分，同时添加了一些内核为了管理文件需要维护的字段</li>
<li>[具体内容](#Inode 层)</li>
</ul>
</li>
<li>pipe 的数据结构如下<ul>
<li>内容很直白，两个 fd，两个数字记录读写的字节数，一个缓冲区</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/pipe.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">char</span> data[PIPESIZE];</span><br><span class="line">    uint nread;     <span class="comment">// number of bytes read</span></span><br><span class="line">    uint nwrite;    <span class="comment">// number of bytes written</span></span><br><span class="line">    <span class="type">int</span> readopen;   <span class="comment">// read fd is still open</span></span><br><span class="line">    <span class="type">int</span> writeopen;  <span class="comment">// write fd is still open</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>文件的基本操作<ul>
<li>filealloc()：分配一个新的文件 entry（打开或者新建文件使用）</li>
<li>filedup()：复制文件</li>
<li>fileclose()：关闭文件</li>
<li>filestat()：获取文件的元数据信息</li>
</ul>
</li>
<li>xv6-riscv 最多支持同时打开 100 个文件（NFILE）</li>
<li>每一个进程最多支持打开 16 个文件（NOFILE）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/param.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOFILE       16  <span class="comment">// open files per process</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFILE       100  <span class="comment">// open files per system</span></span></span><br></pre></td></tr></table></figure>



<h2 id="问题-7"><a href="#问题-7" class="headerlink" title="问题 7"></a>问题 7</h2><blockquote>
<p>阅读文件 sysfile.c，了解与文件系统相关的系统调用，简述各个系统调用的作用</p>
</blockquote>
<ul>
<li>一个具体实现的例子<a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%88%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%89">如上</a>（sys_link()）</li>
<li>一些与文件系统相关的系统调用的含义<ul>
<li>sys_pipe()：打开一个管道，并将结果保存到 proc 数据结构的 ofile 中</li>
<li>sys_chdir()：切换当前目录</li>
<li>sys_mknod()：创建字符设备文件和块设备文件</li>
<li>sys_mkdir()：新建文件夹</li>
<li>sys_open()：打开文件</li>
<li>sys_unlink()：删除这个文件引用</li>
<li>sys_link()：将 new 指向 old，指向同一个文件</li>
<li>sys_fstat()：获取文件元数据信息</li>
<li>sys_close()：关闭文件</li>
<li>sys_write()：王文件中写数据</li>
<li>sys_read()：从文件中读取数据</li>
<li>sys_dup()：复制文件</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv">https://github.com/mit-pdos/xv6-riscv</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/07/OS/xv6-source-code/05-FileSystem/" data-id="cl9lj74ba00ib64tzgfiihfxr" data-title="xv6-riscv-源代码阅读.文件系统" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xv6/" rel="tag">xv6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/CLJ/07-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/04/DB/CLJ/07-1/" class="article-date">
  <time class="dt-published" datetime="2021-06-04T07:00:04.000Z" itemprop="datePublished">2021-06-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/04/DB/CLJ/07-1/">数据库概论.陈立军.07.并发控制(2)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><h2 id="显示锁类型"><a href="#显示锁类型" class="headerlink" title="显示锁类型"></a>显示锁类型</h2><h3 id="SQL-Server-查询"><a href="#SQL-Server-查询" class="headerlink" title="SQL Server 查询"></a>SQL Server 查询</h3><ul>
<li>使用 sp_lock 或者查询 sys.dm_tran_locks 视图</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> DBlocks <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> request_session_id <span class="keyword">as</span> spid,</span><br><span class="line">    db_name(resource_database_id) <span class="keyword">as</span> dbname,</span><br><span class="line">    <span class="keyword">CASE</span> <span class="keyword">WHEN</span> resource_type<span class="operator">=</span><span class="string">&#x27;OBJECT&#x27;</span></span><br><span class="line">            <span class="keyword">THEN</span> object_name(resource_associated_entity_id)</span><br><span class="line">        <span class="keyword">WHEN</span> resource_associated_entity_id<span class="operator">=</span><span class="number">0</span></span><br><span class="line">            <span class="keyword">THEN</span><span class="string">&#x27;n/a&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> object_name(p.object_id) <span class="keyword">END</span> <span class="keyword">as</span> entity_name,</span><br><span class="line">    index_id,resource_type <span class="keyword">as</span> resource, resource_description <span class="keyword">as</span> description,</span><br><span class="line">    request_mode <span class="keyword">as</span> mode,</span><br><span class="line">    request_status <span class="keyword">as</span> status</span><br><span class="line"><span class="keyword">FROM</span> sys.dm_tran_locks t LEFTJOIN sys.partitions p</span><br><span class="line">    <span class="keyword">ON</span> p.hobt_id <span class="operator">=</span> t.resource_associated_entity_id</span><br><span class="line"><span class="keyword">WHERE</span> resource_database_id<span class="operator">=</span>db_id()</span><br></pre></td></tr></table></figure>



<h4 id="repeatable-read"><a href="#repeatable-read" class="headerlink" title="repeatable read"></a>repeatable read</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">USE student</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL REPEATABLE READ</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> AGE<span class="operator">&gt;</span><span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询当前进程的锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Dblocks</span><br><span class="line"><span class="keyword">WHERE</span> spid<span class="operator">=</span>@<span class="variable">@spid</span></span><br><span class="line"><span class="keyword">AND</span> entity_name<span class="operator">=</span><span class="string">&#x27;S&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN</span><br></pre></td></tr></table></figure>



<h4 id="read-committed"><a href="#read-committed" class="headerlink" title="read committed"></a>read committed</h4><ul>
<li>read committed 是短锁，执行完就释放了</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">USE student</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> AGE<span class="operator">&gt;</span><span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_lock@<span class="variable">@spid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN</span><br></pre></td></tr></table></figure>

<ul>
<li>只有数据库上有一个读锁</li>
</ul>
<table>
<thead>
<tr>
<th align="center">spid</th>
<th align="center">Database</th>
<th align="center">ObjId</th>
<th align="center">IndId</th>
<th align="center">Type</th>
<th align="center">Resource</th>
<th align="center">Mode</th>
<th align="center">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">DB</td>
<td align="center"></td>
<td align="center">S</td>
<td align="center">GRANT</td>
</tr>
</tbody></table>
<h4 id="repeatabel-read"><a href="#repeatabel-read" class="headerlink" title="repeatabel read"></a>repeatabel read</h4><ul>
<li>长锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">USE student</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL REPEATABLE READ</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> AGE<span class="operator">&gt;</span><span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_lock @<span class="variable">@spid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN</span><br></pre></td></tr></table></figure>

<ul>
<li>自己加读锁，祖先节点加意向读锁<ul>
<li>聚簇索引，主码上有索引，KEY 来标一条记录</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">spid</th>
<th align="center">Database</th>
<th align="center">ObjId</th>
<th align="center">IndId</th>
<th align="center">Type</th>
<th align="center">Resource</th>
<th align="center">Mode</th>
<th align="center">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">DB</td>
<td align="center"></td>
<td align="center">S</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">2</td>
<td align="center">PAG</td>
<td align="center">1:31</td>
<td align="center">IS</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">1</td>
<td align="center">PAG</td>
<td align="center">1:30</td>
<td align="center">IS</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">1</td>
<td align="center">KEY</td>
<td align="center">(930085dfee46)</td>
<td align="center">S</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">0</td>
<td align="center">TAB</td>
<td align="center"></td>
<td align="center">IS</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">2</td>
<td align="center">KEY</td>
<td align="center">(a8007c139223)</td>
<td align="center">S</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">2</td>
<td align="center">KEY</td>
<td align="center">(ab008cdbe580)</td>
<td align="center">S</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">1</td>
<td align="center">KEY</td>
<td align="center">(930022f0d614)</td>
<td align="center">S</td>
<td align="center">GRANT</td>
</tr>
</tbody></table>
<h4 id="serializable"><a href="#serializable" class="headerlink" title="serializable"></a>serializable</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">USE student</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> AGE<span class="operator">&gt;</span><span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_lock@<span class="variable">@spid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN</span><br></pre></td></tr></table></figure>

<ul>
<li>为了防止幻象，得加码范围锁</li>
</ul>
<table>
<thead>
<tr>
<th align="center">spid</th>
<th align="center">Database</th>
<th align="center">ObjId</th>
<th align="center">IndId</th>
<th align="center">Type</th>
<th align="center">Resource</th>
<th align="center">Mode</th>
<th align="center">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">DB</td>
<td align="center"></td>
<td align="center">S</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">2</td>
<td align="center">PAG</td>
<td align="center">1:31</td>
<td align="center">IS</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">1</td>
<td align="center">PAG</td>
<td align="center">1:30</td>
<td align="center">IS</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">1</td>
<td align="center">KEY</td>
<td align="center">(930085dfee46)</td>
<td align="center">S</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">0</td>
<td align="center">TAB</td>
<td align="center"></td>
<td align="center">IS</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">2</td>
<td align="center">KEY</td>
<td align="center">(a8007c139223)</td>
<td align="center">RangeS-S</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">2</td>
<td align="center">KEY</td>
<td align="center">(ab008cdbe580)</td>
<td align="center">RangeS-S</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">2</td>
<td align="center">KEY</td>
<td align="center">(ffffffffffff)</td>
<td align="center">RangeS-S</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">1</td>
<td align="center">KEY</td>
<td align="center">(930022f0d614)</td>
<td align="center">S</td>
<td align="center">GRANT</td>
</tr>
</tbody></table>
<h3 id="SQL-Server-更新"><a href="#SQL-Server-更新" class="headerlink" title="SQL Server 更新"></a>SQL Server 更新</h3><h4 id="read-committed-1"><a href="#read-committed-1" class="headerlink" title="read committed"></a>read committed</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">USE student</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> S</span><br><span class="line"><span class="keyword">SET</span> SEX<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">WHERE</span> AGE<span class="operator">&gt;</span><span class="number">20</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_lock@<span class="variable">@spid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span> TRAN</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">spid</th>
<th align="center">Database</th>
<th align="center">ObjId</th>
<th align="center">IndId</th>
<th align="center">Type</th>
<th align="center">Resource</th>
<th align="center">Mode</th>
<th align="center">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="center">52</td>
<td align="center">student</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">DB</td>
<td align="center"></td>
<td align="center">S</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">52</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">1</td>
<td align="center">PAG</td>
<td align="center">1:30</td>
<td align="center">IX</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">52</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">1</td>
<td align="center">KEY</td>
<td align="center">(930085dfee46)</td>
<td align="center">X</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">52</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">0</td>
<td align="center">TAB</td>
<td align="center"></td>
<td align="center">IX</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">52</td>
<td align="center">student</td>
<td align="center">2025058250</td>
<td align="center">1</td>
<td align="center">KEY</td>
<td align="center">(930022f0d614)</td>
<td align="center">X</td>
<td align="center">GRANT</td>
</tr>
</tbody></table>
<h3 id="SQL-Server-创建表"><a href="#SQL-Server-创建表" class="headerlink" title="SQL Server 创建表"></a>SQL Server 创建表</h3><h4 id="read-committed-2"><a href="#read-committed-2" class="headerlink" title="read committed"></a>read committed</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">USE student</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">INTO</span> OldS</span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> AGE<span class="operator">&gt;</span><span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_lock2@<span class="variable">@spid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN</span><br></pre></td></tr></table></figure>

<ul>
<li>创建表加写锁</li>
<li>Sch-M 模式修改锁，避免在建表的时候其他事务访问它</li>
</ul>
<table>
<thead>
<tr>
<th align="center">spid</th>
<th align="center">Database</th>
<th align="center">ObjId</th>
<th align="center">IndId</th>
<th align="center">Type</th>
<th align="center">Resource</th>
<th align="center">Mode</th>
<th align="center">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="center">54</td>
<td align="center">student</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center"><strong>EXT</strong></td>
<td align="center">1:112</td>
<td align="center">X</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">student</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">PAG</td>
<td align="center">1:127</td>
<td align="center">X</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">student</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">PAG</td>
<td align="center">1:124</td>
<td align="center">X</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">student</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">PAG</td>
<td align="center">1:125</td>
<td align="center">X</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">student</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">PAG</td>
<td align="center">1:122</td>
<td align="center">X</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">student</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">PAG</td>
<td align="center">1:123</td>
<td align="center">X</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">student</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">PAG</td>
<td align="center">1:120</td>
<td align="center">X</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">student</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">PAG</td>
<td align="center">1:121</td>
<td align="center">X</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">student</td>
<td align="center">2041058307</td>
<td align="center">0</td>
<td align="center"><strong>TAB</strong></td>
<td align="center"></td>
<td align="center"><strong>Sch-M</strong></td>
<td align="center">GRANT</td>
</tr>
</tbody></table>
<h3 id="SQL-Server-行锁"><a href="#SQL-Server-行锁" class="headerlink" title="SQL Server 行锁"></a>SQL Server 行锁</h3><h4 id="read-committed-3"><a href="#read-committed-3" class="headerlink" title="read committed"></a>read committed</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">USE student</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"><span class="keyword">UPDATE</span> OldS</span><br><span class="line"><span class="keyword">SET</span> SNAME<span class="operator">=</span><span class="string">&#x27;王非&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> S# <span class="operator">=</span> <span class="string">&#x27;s1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_lock@<span class="variable">@spid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN</span><br></pre></td></tr></table></figure>

<ul>
<li>SQL Server 没有指定主码，则不会建立聚簇索引，是一个无序的堆表<ul>
<li>Row ID<ul>
<li>文件号：文件里面的页面号：页面内的偏移</li>
</ul>
</li>
<li>MySQL 会默认有一个自增的字段</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">spid</th>
<th align="center">Database</th>
<th align="center">ObjId</th>
<th align="center">IndId</th>
<th align="center">Type</th>
<th align="center">Resource</th>
<th align="center">Mode</th>
<th align="center">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="center">52</td>
<td align="center">student</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">DB</td>
<td align="center"></td>
<td align="center">S</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">52</td>
<td align="center">student</td>
<td align="center">2073058421</td>
<td align="center">0</td>
<td align="center">PAG</td>
<td align="center">1:96</td>
<td align="center">IX</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">52</td>
<td align="center">student</td>
<td align="center">2073058421</td>
<td align="center">0</td>
<td align="center"><strong><span style="color:red">RID</span></strong></td>
<td align="center">1:96:0</td>
<td align="center">X</td>
<td align="center">GRANT</td>
</tr>
<tr>
<td align="center">52</td>
<td align="center">student</td>
<td align="center">2073058421</td>
<td align="center">0</td>
<td align="center">TAB</td>
<td align="center"></td>
<td align="center">IX</td>
<td align="center">GRANT</td>
</tr>
</tbody></table>
<h3 id="MySQL-的锁字典表"><a href="#MySQL-的锁字典表" class="headerlink" title="MySQL 的锁字典表"></a>MySQL 的锁字典表</h3><h4 id="innodb-trx"><a href="#innodb-trx" class="headerlink" title="innodb_trx"></a>innodb_trx</h4><table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">trx_id</td>
<td align="center">事务id</td>
</tr>
<tr>
<td align="center">trx_state</td>
<td align="center">事务状态</td>
</tr>
<tr>
<td align="center">trx_started</td>
<td align="center">事务开始时间</td>
</tr>
<tr>
<td align="center">trx_requested_lock_id</td>
<td align="center">等待事务的锁id</td>
</tr>
<tr>
<td align="center">trx_wait_started</td>
<td align="center">事务等待开始的时间</td>
</tr>
<tr>
<td align="center">trx_weight</td>
<td align="center">事务的权重，锁住的行数，死锁时回滚权重最小的事务</td>
</tr>
<tr>
<td align="center">trx_mysql_thread_id</td>
<td align="center">线程id</td>
</tr>
<tr>
<td align="center">trx_query</td>
<td align="center">事务运行的sql语句</td>
</tr>
</tbody></table>
<h4 id="innodb-locks"><a href="#innodb-locks" class="headerlink" title="innodb_locks"></a>innodb_locks</h4><table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">lock_id</td>
<td align="center">锁id</td>
</tr>
<tr>
<td align="center">lock_trx_id</td>
<td align="center">事务id</td>
</tr>
<tr>
<td align="center">lock_mode</td>
<td align="center">锁模式</td>
</tr>
<tr>
<td align="center">lock_type</td>
<td align="center">锁类型，表锁还是行锁</td>
</tr>
<tr>
<td align="center">lock_table</td>
<td align="center">锁定的表</td>
</tr>
<tr>
<td align="center">lock_index</td>
<td align="center">锁定的索引</td>
</tr>
<tr>
<td align="center">lock_space</td>
<td align="center">锁对象的space id</td>
</tr>
<tr>
<td align="center">lock_page</td>
<td align="center">锁定的页</td>
</tr>
<tr>
<td align="center">lock_rec</td>
<td align="center">锁定的行</td>
</tr>
<tr>
<td align="center">lock_data</td>
<td align="center">锁定行的主码</td>
</tr>
</tbody></table>
<h4 id="innodb-lock-waits"><a href="#innodb-lock-waits" class="headerlink" title="innodb_lock_waits"></a>innodb_lock_waits</h4><table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">requesting_trx_id</td>
<td align="center">申请锁资源的事务id</td>
</tr>
<tr>
<td align="center">requesting_lock_id</td>
<td align="center">事务正在申请的锁的id</td>
</tr>
<tr>
<td align="center">blocking_trx_id</td>
<td align="center">阻塞的事务id</td>
</tr>
<tr>
<td align="center">blocking_lock_id</td>
<td align="center">阻塞的锁的id</td>
</tr>
</tbody></table>
<h2 id="各种操作下的锁授予"><a href="#各种操作下的锁授予" class="headerlink" title="各种操作下的锁授予"></a>各种操作下的锁授予</h2><ul>
<li>以查询为例<ul>
<li>当你发出一个查询请求之后，数据库会先经过一个查询优化器，确定一个执行计划（直接扫描表&#x2F;借助某个索引），系统会对执行计划的每一个路径加锁</li>
</ul>
</li>
</ul>
<h3 id="聚簇表和堆表的不同（SQL-Server）"><a href="#聚簇表和堆表的不同（SQL-Server）" class="headerlink" title="聚簇表和堆表的不同（SQL Server）"></a>聚簇表和堆表的不同（SQL Server）</h3><ul>
<li>ClusterOrders：基于 OrderID 的聚簇表<ul>
<li>在 ClusterOrders 的 ShipName 上建有非聚簇索引</li>
</ul>
</li>
<li>HeapOrders：堆表<ul>
<li>在 HeapOrders 的 EmployeeID 上建有非聚簇索引</li>
</ul>
</li>
</ul>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><h5 id="聚簇表：基于聚簇索引的查找"><a href="#聚簇表：基于聚簇索引的查找" class="headerlink" title="聚簇表：基于聚簇索引的查找"></a>聚簇表：基于聚簇索引的查找</h5><ul>
<li>索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> ClusterOrders</span><br><span class="line"><span class="keyword">where</span> OrderID<span class="operator">=</span><span class="number">10250</span></span><br></pre></td></tr></table></figure>

<img src="07-1/image-20210612173334329.png" style="zoom:150%;" />



<h5 id="堆表：基于非索引项的查找"><a href="#堆表：基于非索引项的查找" class="headerlink" title="堆表：基于非索引项的查找"></a>堆表：基于非索引项的查找</h5><ul>
<li>RID</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> HeapOrders</span><br><span class="line"><span class="keyword">where</span> OrderID<span class="operator">=</span><span class="number">10250</span></span><br></pre></td></tr></table></figure>

<img src="07-1/image-20210612173417287.png" style="zoom:150%;" />



<h5 id="堆表：基于非聚簇索引的查找"><a href="#堆表：基于非聚簇索引的查找" class="headerlink" title="堆表：基于非聚簇索引的查找"></a>堆表：基于非聚簇索引的查找</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> HeapOrders</span><br><span class="line"><span class="keyword">where</span> EmploeeID <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行计划如下<ul>
<li>先在非聚簇索引上查找，找到满足条件的索引码之后再到原表中查找</li>
<li>现在满足条件的非聚簇索引上加锁，然后在 RID 上加锁</li>
</ul>
</li>
</ul>
<img src="07-1/image-20210612173903573.png" style="zoom:150%;" />

<img src="07-1/image-20210612173624408.png" style="zoom:150%;" />



<ul>
<li>当修改查询语句如下时，查询计划改变了<ul>
<li>为什么？</li>
<li>系统发现在索引中有很多满足条件的项，基于索引反而是低效的</li>
<li>转变为基于<strong>表扫描</strong>的查找</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> HeapOrders</span><br><span class="line"><span class="keyword">where</span> EmploeeID<span class="operator">=</span><span class="number">4</span></span><br></pre></td></tr></table></figure>

<img src="07-1/image-20210612174447634.png" style="zoom:150%;" />

<img src="07-1/image-20210612174503222.png" style="zoom:150%;" />



<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h5 id="堆表：删除行操作（非索引）"><a href="#堆表：删除行操作（非索引）" class="headerlink" title="堆表：删除行操作（非索引）"></a>堆表：删除行操作（非索引）</h5><ul>
<li>RID 加写锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> HeapOrders</span><br><span class="line"><span class="keyword">where</span> orderID<span class="operator">=</span><span class="number">10253</span></span><br></pre></td></tr></table></figure>

<img src="07-1/image-20210612174657367.png" style="zoom:150%;" />





<h5 id="堆表：删除行操作（索引、非聚簇索引）"><a href="#堆表：删除行操作（索引、非聚簇索引）" class="headerlink" title="堆表：删除行操作（索引、非聚簇索引）"></a>堆表：删除行操作（索引、非聚簇索引）</h5><ul>
<li>索引码、原表中对应的行都得加写锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> HeapOrders</span><br><span class="line"><span class="keyword">where</span> EmployeeID <span class="operator">=</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<img src="07-1/image-20210612174853968.png" style="zoom:150%;" />



<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><h5 id="堆表：基于非聚簇索引的更新操作"><a href="#堆表：基于非聚簇索引的更新操作" class="headerlink" title="堆表：基于非聚簇索引的更新操作"></a>堆表：基于非聚簇索引的更新操作</h5><ul>
<li>索引、RID 加写锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> HeapOrders</span><br><span class="line"><span class="keyword">set</span> ShipVia <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">where</span> EmployeeID <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<img src="07-1/image-20210612195145842.png" style="zoom:150%;" />

<img src="07-1/image-20210612195357141.png" style="zoom:150%;" />



<h5 id="聚簇表：更新操作"><a href="#聚簇表：更新操作" class="headerlink" title="聚簇表：更新操作"></a>聚簇表：更新操作</h5><ul>
<li>只有索引表需要加锁<ul>
<li>因为 ShipName 上有非聚簇索引，同时需要给这些记录加写锁</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> ClusterOrders</span><br><span class="line"><span class="keyword">set</span> ShipName <span class="operator">=</span> <span class="string">&#x27;tatatata&#x27;</span></span><br><span class="line"><span class="keyword">where</span> OrderID <span class="operator">=</span> <span class="number">10255</span></span><br></pre></td></tr></table></figure>

<img src="07-1/image-20210612195530118.png" style="zoom:150%;" />



<h3 id="缺少索引而引起的阻塞（SQL-Server）"><a href="#缺少索引而引起的阻塞（SQL-Server）" class="headerlink" title="缺少索引而引起的阻塞（SQL Server）"></a>缺少索引而引起的阻塞（SQL Server）</h3><ul>
<li><strong>建立索引能够减少减少阻塞的情况，能够提高索引的并发度</strong></li>
</ul>
<h4 id="没有索引的情况"><a href="#没有索引的情况" class="headerlink" title="没有索引的情况"></a>没有索引的情况</h4><ul>
<li>建立两个表 T1、T2</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T1(id <span class="type">int</span>, col1 <span class="type">char</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T2(id <span class="type">int</span>, col2 <span class="type">char</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T1 <span class="keyword">values</span> (<span class="number">101</span>,<span class="string">&#x27;A&#x27;</span>), (<span class="number">102</span>,<span class="string">&#x27;B&#x27;</span>), (<span class="number">103</span>,<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T2 <span class="keyword">values</span> (<span class="number">201</span>,<span class="string">&#x27;A&#x27;</span>), (<span class="number">202</span>,<span class="string">&#x27;B&#x27;</span>), (<span class="number">203</span>,<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>事务 1</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> tran</span><br><span class="line"><span class="keyword">update</span> T1</span><br><span class="line"><span class="keyword">set</span> col1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> <span class="number">101</span></span><br></pre></td></tr></table></figure>

<ul>
<li>事务 2</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> tran</span><br><span class="line"><span class="keyword">update</span> T1</span><br><span class="line"><span class="keyword">set</span> col1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> <span class="number">103</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实际过程中，事务 2 被事务 1 阻塞了<ul>
<li>事务 1 加了写锁，更新事务在更新完整个表之后才会释放所有的锁<ul>
<li>这样的原因如下<ul>
<li>举个例子，如果更新完一条记录就释放这条记录上的锁，事务 1 更新完 A 记录后马上释放锁，此时事务 2 也更新 A 记录，但是事务 2 出现错误，需要回滚，此时出现问题，回滚之后把事务 2 的更新也回滚掉了</li>
</ul>
</li>
<li>SQL Server 的更新操作<ul>
<li>先把所有满足条件的行找出来，此时会申请 U 锁（先读后写），满足条件的行被更新时升级为写锁</li>
</ul>
</li>
</ul>
</li>
<li>事务 2 在通过 where 查询整个表的时候，查询被事务 1 锁住的记录的时候，被阻塞</li>
</ul>
</li>
<li>输出两个进程持有锁的情况</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 事务 1 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Dblocks</span><br><span class="line"><span class="keyword">WHERE</span> spid<span class="operator">=</span><span class="number">52</span></span><br><span class="line"><span class="keyword">AND</span> entity_name<span class="operator">=</span><span class="string">&#x27;T1&#x27;</span></span><br></pre></td></tr></table></figure>

<img src="07-1/image-20210612200436574.png" style="zoom: 67%;" />

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 事务 2 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Dblocks</span><br><span class="line"><span class="keyword">WHERE</span> spid<span class="operator">=</span><span class="number">54</span></span><br><span class="line"><span class="keyword">AND</span> entity_name<span class="operator">=</span><span class="string">&#x27;T1&#x27;</span></span><br></pre></td></tr></table></figure>

<img src="07-1/image-20210612201349846.png" style="zoom:67%;" />

<ul>
<li>注意上面事务 2 的行探查阶段申请的是 U 锁</li>
</ul>
<h4 id="在-id-上建立索引"><a href="#在-id-上建立索引" class="headerlink" title="在 id 上建立索引"></a>在 id 上建立索引</h4><ul>
<li>在更新的时候不需要扫描所有行，可以通过索引直接定位到行</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_T1_id <span class="keyword">on</span> T1(id)</span><br></pre></td></tr></table></figure>

<ul>
<li>此时不会出现事务 2 被事务 1 挂起的情况，锁持有情况如下<ul>
<li>先加 U 锁，更新的时候再升级为写锁</li>
</ul>
</li>
</ul>
<img src="07-1/image-20210612203132870.png" style="zoom:150%;" />

<img src="07-1/image-20210612203151601.png" style="zoom:150%;" />



<h3 id="MySQL-的当前读"><a href="#MySQL-的当前读" class="headerlink" title="MySQL 的当前读"></a>MySQL 的当前读</h3><ul>
<li><strong>当前读</strong>：特殊的读操作，需要加锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? lock <span class="keyword">in</span> share mode</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">values</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> ? <span class="keyword">where</span> ?</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?</span><br></pre></td></tr></table></figure>



<h3 id="MySQL-加锁处理分析"><a href="#MySQL-加锁处理分析" class="headerlink" title="MySQL 加锁处理分析"></a>MySQL 加锁处理分析</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SQL1 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SQL2 */</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>前提<ul>
<li>前提一：id列是不是主键？</li>
<li>前提二：当前系统的隔离级别是什么？</li>
<li>前提三：id列如果不是主键，那么id列上有索引吗？</li>
<li>前提四：id列上如果有二级索引，这个索引是唯一索引吗？</li>
<li>前提五：两个SQL的执行计划是什么？索引扫描？全表扫描？</li>
</ul>
</li>
<li>通过对前提的不同组合会有不同的结果</li>
<li>组合<ul>
<li>组合一：id列是主键，RC隔离级别</li>
<li>组合二：id列是二级唯一索引，RC隔离级别</li>
<li>组合三：id列是二级非唯一索引，RC隔离级别</li>
<li>组合四：id列上没有索引，RC隔离级别</li>
<li>组合五：id列是主键，RR隔离级别</li>
<li>组合六：id列是二级唯一索引，RR隔离级别</li>
<li>组合七：id列是二级非唯一索引，RR隔离级别</li>
<li>组合八：id列上没有索引，RR隔离级别</li>
<li>组合九：Serializable隔离级别</li>
</ul>
</li>
</ul>
<h4 id="组合一：id主键-RC"><a href="#组合一：id主键-RC" class="headerlink" title="组合一：id主键+RC"></a>组合一：id主键+RC</h4><img src="07-1/image-20210612205745033.png" style="zoom: 67%;" />



<h4 id="组合二：id唯一索引-RC"><a href="#组合二：id唯一索引-RC" class="headerlink" title="组合二：id唯一索引+RC"></a>组合二：id唯一索引+RC</h4><img src="07-1/image-20210612210128618.png" style="zoom:67%;" />





<h4 id="组合三：id非唯一索引-RC"><a href="#组合三：id非唯一索引-RC" class="headerlink" title="组合三：id非唯一索引+RC"></a>组合三：id非唯一索引+RC</h4><img src="07-1/image-20210612210240187.png" style="zoom: 80%;" />



<h4 id="组合四：id无索引-RC"><a href="#组合四：id无索引-RC" class="headerlink" title="组合四：id无索引+RC"></a>组合四：id无索引+RC</h4><img src="07-1/image-20210612210313852.png" style="zoom:67%;" />



<h4 id="组合七：id非唯一索引-RR"><a href="#组合七：id非唯一索引-RR" class="headerlink" title="组合七：id非唯一索引+RR"></a>组合七：id非唯一索引+RR</h4><img src="07-1/image-20210612210408732.png" style="zoom:80%;" />



<h4 id="组合八：id无索引-RR"><a href="#组合八：id无索引-RR" class="headerlink" title="组合八：id无索引+RR"></a>组合八：id无索引+RR</h4><img src="07-1/image-20210612210600528.png" style="zoom:80%;" />
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/04/DB/CLJ/07-1/" data-id="cl9lj74ay00fz64tzgw9of3hb" data-title="数据库概论.陈立军.07.并发控制(2)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OS/xv6-labs/lab7-lock" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/03/OS/xv6-labs/lab7-lock/" class="article-date">
  <time class="dt-published" datetime="2021-06-03T04:00:00.000Z" itemprop="datePublished">2021-06-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OS-xv6-labs/">OS.xv6-labs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/03/OS/xv6-labs/lab7-lock/">xv6-labs-2020.lab7.lock</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="lab7-lock"><a href="#lab7-lock" class="headerlink" title="lab7 lock"></a>lab7 lock</h1><h2 id="1-作业链接"><a href="#1-作业链接" class="headerlink" title="1. 作业链接"></a>1. 作业链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/labs/lock.html">https://pdos.csail.mit.edu/6.828/2020/labs/lock.html</a></li>
</ul>
<h2 id="2-实习内容"><a href="#2-实习内容" class="headerlink" title="2. 实习内容"></a>2. 实习内容</h2><h3 id="2-1-Memory-allocator"><a href="#2-1-Memory-allocator" class="headerlink" title="2.1 Memory allocator"></a>2.1 Memory allocator</h3><h4 id="1-实验目标"><a href="#1-实验目标" class="headerlink" title="(1) 实验目标"></a>(1) 实验目标</h4><ul>
<li>在内存管理上，由于只有一个 <code>freelist</code>，在多 CPU 的情况下，如果多个 CPU 同时申请内存，则可能出现剧烈的 <code>race</code> 现象</li>
<li>一个解决的方案就是为每一个 CPU 维护一个 <code>kmem</code> 的锁，从而减少 <code>race</code></li>
<li>在这一部分，就是实现这样的策略</li>
</ul>
<h4 id="2-提示"><a href="#2-提示" class="headerlink" title="(2) 提示"></a>(2) 提示</h4><ul>
<li><code>kernel/param.h</code> 中定义了常数 <code>NCPU</code> （CPU 个数）</li>
<li>在 <code>freerange</code> 中将所有的可分配物理内存分配给每个 CPU</li>
<li><code>cpuid()</code> 返回当前 CPU 的 id，但是这只有在关闭中断的时候才是安全的<ul>
<li>因此需要在调用前后关开中断（<code>push_off()</code>、<code>pop_off()</code>）</li>
</ul>
</li>
<li>可以简单地将锁命名为 <code>kmem</code>，或者使用 <code>snprintf()</code> 函数进行命名（这个没什么用，DEBUG）</li>
</ul>
<h4 id="3-实现"><a href="#3-实现" class="headerlink" title="(3) 实现"></a>(3) 实现</h4><h5 id="1-锁的声明与初始化"><a href="#1-锁的声明与初始化" class="headerlink" title="[1] 锁的声明与初始化"></a>[1] 锁的声明与初始化</h5><ul>
<li>找到原来的定义修改为数组即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem[NCPU];</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化的时候初始化整个数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kinit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 为了方便, 我们直接把名字命名为 `kmem`</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; NCPU; ++i)</span><br><span class="line">        initlock(&amp;kmem[i].lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">    freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-初始化可分配的物理内存"><a href="#2-初始化可分配的物理内存" class="headerlink" title="[2] 初始化可分配的物理内存"></a>[2] 初始化可分配的物理内存</h5><ul>
<li>在 <code>freerange()</code> 中实现</li>
<li>依次给每个 CPU 分配物理内存即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// kfree(p);</span></span><br><span class="line">        <span class="comment">// 模仿 kfree 实现</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">1</span>, PGSIZE);</span><br><span class="line">        r = (<span class="keyword">struct</span> run*)p;</span><br><span class="line">        acquire(&amp;kmem[id].lock);</span><br><span class="line">        r-&gt;next = kmem[id].freelist;</span><br><span class="line">        kmem[id].freelist = r;</span><br><span class="line">        release(&amp;kmem[id].lock);</span><br><span class="line">        ++id;</span><br><span class="line">        <span class="keyword">if</span>(id == NCPU) &#123;</span><br><span class="line">            id = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-kalloc-x2F-kfree"><a href="#3-kalloc-x2F-kfree" class="headerlink" title="[3] kalloc &#x2F; kfree"></a>[3] kalloc &#x2F; kfree</h5><ul>
<li>在分配物理内存的时候，需要在当前 CPU 的 freelist 中分配</li>
<li>当不够的时候，可以取其他 CPU 的 freelist 中的物理内存</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">    push_off();</span><br><span class="line">    <span class="type">int</span> id = cpuid();</span><br><span class="line">    pop_off();</span><br><span class="line">    <span class="comment">// 尝试分配内存</span></span><br><span class="line">    acquire(&amp;kmem[id].lock);</span><br><span class="line">    r = kmem[id].freelist;</span><br><span class="line">    <span class="keyword">if</span>(r)</span><br><span class="line">        kmem[id].freelist = r-&gt;next;</span><br><span class="line">    release(&amp;kmem[id].lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从其他 CPU 那里获取</span></span><br><span class="line">    <span class="keyword">if</span>(!r) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; NCPU; ++i) &#123;</span><br><span class="line">            acquire(&amp;kmem[i].lock);</span><br><span class="line">            r = kmem[i].freelist;</span><br><span class="line">            <span class="keyword">if</span>(r)</span><br><span class="line">                kmem[i].freelist = r-&gt;next;</span><br><span class="line">            release(&amp;kmem[i].lock);</span><br><span class="line">            <span class="keyword">if</span>(r)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(r)</span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在释放物理内存的时候，将其释放到当前 CPU 的 freelist 中去</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    push_off();</span><br><span class="line">    <span class="type">int</span> id = cpuid();</span><br><span class="line">    pop_off();</span><br><span class="line"></span><br><span class="line">    acquire(&amp;kmem[id].lock);</span><br><span class="line">    r-&gt;next = kmem[id].freelist;</span><br><span class="line">    kmem[id].freelist = r;</span><br><span class="line">    release(&amp;kmem[id].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-Buffer-cache"><a href="#2-2-Buffer-cache" class="headerlink" title="2.2 Buffer cache"></a>2.2 Buffer cache</h3><ul>
<li>由于 buffer 只有一个锁，因此存在大量的冲突，修改锁实现更少的冲突</li>
</ul>
<h4 id="1-提示"><a href="#1-提示" class="headerlink" title="(1) 提示"></a>(1) 提示</h4><ul>
<li>修改 <code>bget</code> 和 <code>brelse</code>，以便 <code>bcache</code> 中不同块的并发查找和释放不太可能在锁上发生冲突（例如，不必都等待 <code>bcache.lock</code>）<ul>
<li>每个块最多缓存一个副本</li>
</ul>
</li>
<li>新加的锁命名为 <code>bcache</code></li>
<li>建议使用哈希表在查找每个块号，然后每个哈希表项<ul>
<li>可以使用固定大小的哈希表（例如一个质数：13）</li>
</ul>
</li>
<li>允许存在以下的冲突（conflict）<ul>
<li>两个进程并发的使用相同块号的块（<code>bcachetest</code> <code>test0</code> 不测试这个）</li>
<li>两个进程同时 miss，需要找一个新的块（<code>bcachetest</code> <code>test0</code> 不测试这个）</li>
<li>通过调整块和锁不可避免的冲突（例如两个块的哈希值相同，但是可以通过调整哈希表的大小减小冲突）</li>
</ul>
</li>
<li>在哈希表中找 buffer 但是没找到，需要重新分配一个 buffer 的入口的时候得是原子操作</li>
<li>移除 buffer 链表（<code>bcache.head</code> 等），使用带最后一次使用时间戳的 buffer 代替（使用 <code>kernel/trap.c</code> 中的 <code>ticks</code> ）<ul>
<li>这样修改以后，<code>brelse</code> 就不需要申请 <code>bcache</code> 的锁了，而且 <code>bget</code> 能够通过时间戳选出 LRU 的 buffer</li>
</ul>
</li>
<li><code>bget</code> 可以中可以是序列化驱逐（满了）</li>
<li>注意避免死锁，当驱逐的时候你需要同时持有 <code>bcache</code> 和哈希表中某一项的锁</li>
<li>当替换块的时候，如果没有映射到同一个哈希表项中，需要移动 <code>struct buf</code> 结构<ul>
<li>注意死锁（哈希值相同时）</li>
</ul>
</li>
</ul>
<h4 id="2-实现"><a href="#2-实现" class="headerlink" title="(2) 实现"></a>(2) 实现</h4><ul>
<li>只需要把链表修改为哈希桶即可<ul>
<li>对于每一个哈希桶内部，我们使用带虚拟头结点的单向链表实现</li>
</ul>
</li>
<li>只需要修改文件 <code>kernel/bio.c</code> 和 <code>kernel/buf.h</code></li>
</ul>
<h5 id="1-修改链表为开链哈希桶"><a href="#1-修改链表为开链哈希桶" class="headerlink" title="[1] 修改链表为开链哈希桶"></a>[1] 修改链表为开链哈希桶</h5><ul>
<li>一些宏定义<ul>
<li>哈希桶个数为 13</li>
<li><code>buf</code> 的个数就按照原来给的，30 个</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUCKET_NUM 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_NUM NBUF</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>struct buf</code>，我们不需要 <code>prev</code> 指针了，通过 <code>timestamp</code> 时间戳去实现 LRU 算法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">    <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">    uint dev;</span><br><span class="line">    uint blockno;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">    uint refcnt;</span><br><span class="line">    <span class="comment">// struct buf *prev; // 删除字段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">    uchar data[BSIZE];</span><br><span class="line">    uint timestamp;      <span class="comment">// 添加字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改数据结构 <code>bcache</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/bio.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line">    <span class="comment">// 修改为哈希桶(开链法)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">buckets</span>[<span class="title">BUCKET_NUM</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">bucketslock</span>[<span class="title">BUCKET_NUM</span>];</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化中修改初始化方式<ul>
<li>初始化锁</li>
<li>初始化 buffer，主要是将 <code>buf</code> 均匀分配到哈希桶中<ul>
<li>每个哈希桶中内容为带虚拟头结点的单向链表</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化锁</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; BUCKET_NUM; ++i) &#123;</span><br><span class="line">        initlock(&amp;bcache.lock[i], <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    initlock(&amp;bcache.lock_global, <span class="string">&quot;bcache_global&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化初始引用(初始化虚拟头结点)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; BUCKET_NUM; ++i) &#123;</span><br><span class="line">        bcache.buckets[i].next = &amp;bcache.buckets[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 buffer</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; BUF_NUM; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> id = hash(i);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">now</span> =</span> &amp;bcache.buf[i];</span><br><span class="line">        now-&gt;blockno = id;</span><br><span class="line">        now-&gt;refcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// now-&gt;timestamp = ticks;</span></span><br><span class="line">        initsleeplock(&amp;now-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">        <span class="comment">// 插入</span></span><br><span class="line">        now-&gt;next = bcache.buckets[id].next;</span><br><span class="line">        bcache.buckets[id].next = now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-修改-bget-函数"><a href="#2-修改-bget-函数" class="headerlink" title="[2] 修改 bget 函数"></a>[2] 修改 bget 函数</h5><ul>
<li>按照原来链表的寻找方式，我们在每个哈希桶的链表中查找<ul>
<li>如果已经缓存的话，直接返回即可</li>
<li>如果没有缓存的话，先在对应的哈希桶中找看看有没有空 buffer<ul>
<li>对应的哈希桶内 LRU 查找</li>
</ul>
</li>
<li>如果没有的话再到其他哈希桶中找空的 buffer<ul>
<li>其他的所有哈希桶 LRU 查找</li>
</ul>
</li>
</ul>
</li>
<li>这样子的实现并不是标准的 LRU</li>
<li>具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf* <span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id = hash(blockno);</span><br><span class="line">    acquire(&amp;bcache.lock[id]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 查找这个块是否被缓存, 如果被缓存直接返回即可</span></span><br><span class="line">    <span class="keyword">for</span>(b = bcache.buckets[id].next; b != &amp;bcache.buckets[id]; b = b-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">            b-&gt;refcnt++;</span><br><span class="line">            release(&amp;bcache.lock[id]);</span><br><span class="line">            acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 先在自己的桶里寻找</span></span><br><span class="line">    uint timestamp_min = <span class="number">0x8fffffff</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">res</span> =</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(b = bcache.buckets[id].next; b != &amp;bcache.buckets[id]; b = b-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span> &amp;&amp; b-&gt;timestamp &lt; timestamp_min) &#123;</span><br><span class="line">            timestamp_min = b-&gt;timestamp;</span><br><span class="line">            res = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res) &#123;</span><br><span class="line">        res-&gt;dev = dev;</span><br><span class="line">        res-&gt;blockno = blockno;</span><br><span class="line">        res-&gt;valid = <span class="number">0</span>;</span><br><span class="line">        res-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">        release(&amp;bcache.lock[id]);</span><br><span class="line">        acquiresleep(&amp;res-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 没有被缓存, 需要进行驱逐(其他桶中找)</span></span><br><span class="line">    <span class="comment">// 注意这里需要加全局锁</span></span><br><span class="line">    <span class="comment">// 不然可能出现两个进程同时找到同一个空块的情况</span></span><br><span class="line">    acquire(&amp;bcache.lock_global);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1) 找到最早的时间戳</span></span><br><span class="line">    <span class="comment">// 可以直接对 buf 循环</span></span><br><span class="line">    timestamp_min = <span class="number">0x8fffffff</span>;</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; BUF_NUM; ++i) &#123;</span><br><span class="line">        b = &amp;bcache.buf[i];</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span> &amp;&amp; b-&gt;timestamp &lt; timestamp_min) &#123;</span><br><span class="line">            timestamp_min = b-&gt;timestamp;</span><br><span class="line">            res = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没找到直接 panic</span></span><br><span class="line">    <span class="keyword">if</span>(!res) &#123;</span><br><span class="line">        release(&amp;bcache.lock[id]);</span><br><span class="line">        release(&amp;bcache.lock_global);</span><br><span class="line">        panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id_new = hash(res-&gt;blockno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要移动块到目标哈希桶中</span></span><br><span class="line">    <span class="comment">// 从原桶中删除</span></span><br><span class="line">    acquire(&amp;bcache.lock[id_new]);</span><br><span class="line">    <span class="keyword">for</span>(b = &amp;bcache.buckets[id_new]; b-&gt;next != &amp;bcache.buckets[id_new]; b = b-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;next == res) &#123;</span><br><span class="line">            b-&gt;next = res-&gt;next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入新桶</span></span><br><span class="line">    res-&gt;next = bcache.buckets[id].next;</span><br><span class="line">    bcache.buckets[id].next = res;</span><br><span class="line">    res-&gt;dev = dev;</span><br><span class="line">    res-&gt;blockno = blockno;</span><br><span class="line">    res-&gt;valid = <span class="number">0</span>;</span><br><span class="line">    res-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">    release(&amp;bcache.lock[id_new]); <span class="comment">// 具体释放位置应该在哪里?</span></span><br><span class="line">    release(&amp;bcache.lock[id]);</span><br><span class="line">    release(&amp;bcache.lock_global);</span><br><span class="line">    acquiresleep(&amp;res-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3. 实验结果"></a>3. 实验结果</h2><ul>
<li>在我的电脑上第一个测试 <code>kalloctest</code> ，给的时间是 200s，但是我的电脑跑起来要 210s 左右，修改了一下时间限制才能过</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grade-lab-lock</span></span><br><span class="line"><span class="comment"># line 12: timeout=300</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">== Test running kalloctest ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(211.1s)</span><br><span class="line">== Test   kalloctest: test1 ==</span><br><span class="line">  kalloctest: test1: OK</span><br><span class="line">== Test   kalloctest: test2 ==</span><br><span class="line">  kalloctest: test2: OK</span><br><span class="line">== Test kalloctest: sbrkmuch ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">kalloctest: sbrkmuch: OK (19.2s)</span><br><span class="line">== Test running bcachetest ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(14.5s)</span><br><span class="line">== Test   bcachetest: test0 ==</span><br><span class="line">  bcachetest: test0: OK</span><br><span class="line">== Test   bcachetest: test1 ==</span><br><span class="line">  bcachetest: test1: OK</span><br><span class="line">== Test usertests ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">usertests: OK (222.9s)</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 70/70</span><br></pre></td></tr></table></figure>



<h2 id="4-遇到的困难以及收获"><a href="#4-遇到的困难以及收获" class="headerlink" title="4. 遇到的困难以及收获"></a>4. 遇到的困难以及收获</h2><ul>
<li>一开始利用双向链表、单向链表实现，不知道为什么都会报错 <code>panic</code>，现在也没找到问题，后来改用带虚拟头结点的单向链表之后通过了，感觉很奇怪，有时间再回来看看具体的问题</li>
<li>做完 lab 之后了解到了一种在高并发场景下常用的优化手段<ul>
<li>将锁进行细分，从而能够减小冲突，最终实现性能的提升</li>
</ul>
</li>
<li>感觉在实际的操作系统设计的过程中，锁的控制确实是一个很精细的过程，一不小心就会写成死锁，而且这些问题一般都很难发现</li>
<li>设计过程中很多时候应该使用保守的设计，比如在这个例子中，我们在找不到缓存，同时在哈希桶中找不到空闲 buffer 的时候，加上全局锁，此时虽然降低了性能，但是最终能够保证结果的正确</li>
</ul>
<h2 id="5-对课程或-lab-的意见和建议"><a href="#5-对课程或-lab-的意见和建议" class="headerlink" title="5. 对课程或 lab 的意见和建议"></a>5. 对课程或 lab 的意见和建议</h2><ul>
<li>建议提供一些关于 lab 的 debug 功能的指导</li>
</ul>
<h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev1.pdf">https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev1.pdf</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/03/OS/xv6-labs/lab7-lock/" data-id="cl9lj74bc00iu64tzf2ym2org" data-title="xv6-labs-2020.lab7.lock" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xv6/" rel="tag">xv6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/YLQ-GAMES202/12" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/31/CG/YLQ-GAMES202/12/" class="article-date">
  <time class="dt-published" datetime="2021-05-31T11:01:59.000Z" itemprop="datePublished">2021-05-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES202/">CG.GAMES202</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/31/CG/YLQ-GAMES202/12/">GAMES202.闫令琪.12.实时光线追踪</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY">https://www.bilibili.com/video/BV1YK4y1T7yY</a></li>
</ul>
<h1 id="Real-Time-Ray-Tracing"><a href="#Real-Time-Ray-Tracing" class="headerlink" title="Real-Time Ray Tracing"></a>Real-Time Ray Tracing</h1><ul>
<li>一些复杂的材质在这门课上不讲了</li>
<li>Volumetric &#x2F; scattering materials<ul>
<li>人脸<ul>
<li>《最终幻想七 重制版》 [Final Fantasy VII Remake]</li>
</ul>
</li>
<li>毛发<ul>
<li>《黑神话：悟空》 [Black Myth: Wukong]</li>
</ul>
</li>
</ul>
</li>
<li>背景知识比较多<ul>
<li>RTE：散射介质中光线的传播</li>
<li>BSSRDF：次表面散射<ul>
<li>出射点和入射点可以不同的 BRDF</li>
</ul>
</li>
<li>毛发内部的一次、多次散射</li>
</ul>
</li>
<li>离线渲染课程<ul>
<li>更复杂的光线传播方法<ul>
<li>delta tracking：在散射介质中做光线的步进</li>
</ul>
</li>
<li>复杂的材质<ul>
<li>dual scattering：毛发渲染的一种方法</li>
<li>layered materials：分层的材质</li>
</ul>
</li>
</ul>
</li>
<li>UE5 发布<ul>
<li>一些技术的可能实现</li>
<li>Nanite</li>
<li>Lumen</li>
</ul>
</li>
</ul>
<h2 id="RTX"><a href="#RTX" class="headerlink" title="RTX"></a>RTX</h2><ul>
<li>实时光线追踪</li>
<li>早期的观点<ul>
<li>“Ray tracing is the futureand ever will be.”</li>
</ul>
</li>
<li>2018 RTX 系列硬件的推出使得实时光线追踪成为可能<ul>
<li>图灵架构</li>
<li>NVIDIA announced GeForce RTX series (Turing architecture)</li>
</ul>
</li>
<li>RTRT 的应用场景<ul>
<li>设计：汽车渲染</li>
<li>影视动画</li>
<li>…</li>
</ul>
</li>
</ul>
<img src="12/image-20210531212121853.png" alt="image-20210531212121853" style="zoom: 40%;" />

<ul>
<li>RTX 做了什么<ul>
<li>做了很多 demo 展示效果：Impressive demos of RTRT<ul>
<li>主要是高亮的场景（glossy）<ul>
<li>一方面 glossy 材质方便求反射光线</li>
<li>另一方面 diffuse 材质你看不出来与传统方法的区别</li>
</ul>
</li>
</ul>
</li>
<li>Advanced ray traced effects：能够实现很多之前比较难做的效果<ul>
<li>Shadows</li>
<li>Reflections &amp; Specular</li>
<li>Ambient Occlusion</li>
<li>Global Illumination</li>
</ul>
</li>
<li>RTX 是一种架构，允许我们 trace 光线</li>
<li>RTX 是一种硬件上的突破，计算的很快<ul>
<li>tensor core：加速神经网络</li>
<li>rt core：针对 ray tracing 做的优化</li>
<li>10 Giga rays per second<ul>
<li>帧数、其他计算的考虑，最终的效果留给 RTRT 的时间能够达到 1spp<ul>
<li>1 sample per pixel (2080Ti)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>RTX 支持降噪<ul>
<li>1SPP 噪声严重</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="SPP"><a href="#SPP" class="headerlink" title="SPP"></a>SPP</h3><ul>
<li>1 SPP path tracing：为了实现全局光照效果，至少 4 条光线<ul>
<li>1 rasterization (primary) +</li>
</ul>
<ul>
<li>1 ray (primary visibility) +</li>
</ul>
<ul>
<li>1 ray (secondary bounce) +</li>
<li>1 ray (secondary visibility)</li>
</ul>
</li>
<li>primary hitpoint：第一次打中的点</li>
<li>shadow ray：判断这个点对光源是否可见</li>
<li>one bounce<ul>
<li>secondary hitpoint</li>
<li>shadow ray</li>
</ul>
</li>
</ul>
<img src="12/image-20210531213131561.png" style="zoom:50%;" />

<ul>
<li>一种优化<ul>
<li>没必要对所有的像素进行一次 ray tracing</li>
<li>先进行光栅化，可以更快</li>
</ul>
</li>
<li>这样 1SPP 需要考虑的光线少了 1 条（找到 primary hitpoint 的光线光栅化做了）</li>
<li>1 SPP 效果很差，噪声很严重</li>
</ul>
<p><img src="/12/image-20210531214157842.png"></p>
<h3 id="RTX-的-denoising"><a href="#RTX-的-denoising" class="headerlink" title="RTX 的 denoising"></a>RTX 的 denoising</h3><ul>
<li>State of the Art* Denoising Solution</li>
</ul>
<img src="12/image-20210531214248561.png" style="zoom:50%;" />

<ul>
<li>1SPP 变成这样的效果<ul>
<li>震惊但是这是真的</li>
</ul>
</li>
</ul>
<h2 id="降噪-Denosing"><a href="#降噪-Denosing" class="headerlink" title="降噪 Denosing"></a>降噪 Denosing</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>目标<ul>
<li>输入为 1SPP 的渲染结果</li>
<li>没有模糊、没有 artifacts、保持所有的细节<ul>
<li>overblur（高斯滤波的结果）</li>
</ul>
</li>
<li>速度要快，降噪只是实时渲染的一小部分<ul>
<li>每一帧降噪所花费的是时间小于 2ms</li>
</ul>
</li>
</ul>
</li>
<li>不可能，传统的方法都不行<ul>
<li>Sheared filtering series (SF, AAF, FSF, MAAF, …)</li>
<li>Other offline filtering methods (IPP, BM3D, APR, …)</li>
<li>Deep learning series (CNN, Autoencoder, …)<ul>
<li>现在来看，速度太慢了</li>
<li>跑一个神经网络花费时间在 100 ms 左右</li>
</ul>
</li>
</ul>
</li>
<li>Optix：Nvidia 的光追 API</li>
</ul>
<h3 id="工业界的解法"><a href="#工业界的解法" class="headerlink" title="工业界的解法"></a>工业界的解法</h3><ul>
<li><p><strong>Temporal</strong>：时间上的滤波</p>
</li>
<li><p>关键想法：</p>
<ul>
<li>递归的思维</li>
<li>需要滤波当前帧，我们认为<strong>前一帧是已经滤波好了的</strong></li>
<li>假设场景的运动是连续的<ul>
<li>利用上一帧的 shading 结果</li>
</ul>
</li>
<li><strong>motion vector</strong>：用于找到对应的 shading point 在上一帧的位置</li>
<li>结果相当于增加了 SPP（由于递归，SPP的增加是很多的）</li>
</ul>
</li>
<li><p>motion vector</p>
</li>
</ul>
<img src="12/image-20210531223422938.png" style="zoom:67%;" />

<ul>
<li>空间上的降噪<ul>
<li>下一节课</li>
</ul>
</li>
</ul>
<h3 id="G-Buffer"><a href="#G-Buffer" class="headerlink" title="G-Buffer"></a>G-Buffer</h3><ul>
<li>Geometry Buffer<ul>
<li>光栅化得到的</li>
</ul>
</li>
</ul>
<p><img src="/12/image-20210531223725649.png"></p>
<ul>
<li>需要什么，保存什么<ul>
<li>可以保存深度、法向、世界坐标系位置等各种信息</li>
<li>保存的是屏幕空间的信息</li>
</ul>
</li>
<li>生成 G-Buffer 通常认为是轻量级的</li>
<li>使用 G-Buffer 是很快的</li>
</ul>
<h3 id="Back-Projection"><a href="#Back-Projection" class="headerlink" title="Back Projection"></a>Back Projection</h3><ul>
<li>找对应点</li>
<li>当前帧 $i$ 中的像素点 $x$，找到这个像素中的内容在上一帧 $i-1$ 中的位置 $x’$<ul>
<li>$x,x’$ 在世界坐标系中具有相同的世界坐标系坐标</li>
</ul>
</li>
</ul>
<img src="12/image-20210531224126028.png" style="zoom:67%;" />

<ul>
<li>求出世界坐标系位置 $s$<ul>
<li>如果有 G-Buffer 中，直接取出 $s$ 即可</li>
<li>如果没有 G-Buffer，计算得到 $s &#x3D; M^{-1}V^{-1}P^{-1}E^{-1}x$<ul>
<li>$E$ 视口变换，带 $’$ 表示上一帧结果</li>
<li>需要用到深度信息，屏幕空间是 2D 的，变换是 3D 的</li>
</ul>
</li>
</ul>
</li>
<li>计算上一帧世界坐标系坐标  $s’$ 的位置（已经得到了世界坐标 $s$）<ul>
<li>我们是知道物体怎么运动的，计算即可，我们拥有整个场景的运动信息</li>
<li>$s’{\buildrel{T}\over\longrightarrow} s,s{\buildrel{T^{-1}}\over\longrightarrow} s’$</li>
</ul>
</li>
<li>计算在上一帧中的位置 $x’$<ul>
<li>$x’&#x3D;E’P’V’M’s’$</li>
</ul>
</li>
<li>光流：找像素和像素在不同时间上的一个对应 optical flow<ul>
<li>算 motion vector 本质上也是一种 optical flow</li>
<li>motion vector 是完全物理正确的</li>
<li>光流是根据内容推理，但是深度学习能够做的很好</li>
</ul>
</li>
</ul>
<h3 id="blending"><a href="#blending" class="headerlink" title="blending"></a>blending</h3><ul>
<li>怎么结合得到的两张图</li>
<li>符号定义（象形hhh）<ul>
<li>$\sim$ ：unfiltered</li>
<li>$-$：filtered</li>
</ul>
</li>
<li>步骤<ul>
<li>当前帧自己先做一次降噪（空间）<ul>
<li>$\bar{C}^{(i)}&#x3D;Filter[\tilde{C}^{(i)}]$</li>
<li>1SPP 情况下只依赖当前帧的结果，降噪效果是不可能很好的</li>
</ul>
</li>
<li>Temporal（时间）<ul>
<li>$\bar{C}^{(i)}&#x3D;\alpha\bar{C}^{(i)}+(1-\alpha)\bar{C}^{i-1}$</li>
<li>对应像素而不是同一个像素</li>
<li>通常 $\alpha\in[0.1,0.2]$</li>
<li>说明用的内容主要是上一帧的内容，大胆的设想</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ul>
<li>1spp Ray Traced Global Illumination</li>
</ul>
<p><img src="/12/image-20210531234208290.png"></p>
<ul>
<li>1spp Ray Traced Global Illumination + Denoising</li>
</ul>
<p><img src="/12/image-20210531234218006.png"></p>
<ul>
<li>Ground Truth</li>
</ul>
<p><img src="/12/image-20210531234300669.png"></p>
<ul>
<li>滤波绝对不可能让一张有噪声的图变亮或者变暗，保持能量守恒<ul>
<li>带噪声的图，很多噪点的能量可能是很高的，但是会被显示器给截断</li>
<li>原始的 exr 图片，在 HDR 显示器上显示的结果，denoising 前后亮度应该相差不大</li>
</ul>
</li>
<li>一些问题<ul>
<li>缺失了一些信息，例如左上角圆台体中间条带的 contact shadow</li>
<li>一些细节由于降噪变得模糊</li>
</ul>
</li>
<li>1SPP 的效果!!!!!!</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>场景的第一帧怎么渲染？切换了场景？突变的光源（蹦迪）？<ul>
<li>burn-in period：场景突变需要一段时间累计信息</li>
<li>这是上面的方法是做不到的</li>
</ul>
</li>
<li>向后走场景做不了<ul>
<li>walking backwards in a hallway</li>
<li>很多点上一帧还不在渲染结果内</li>
<li>屏幕空间的问题</li>
</ul>
</li>
<li>disocclusion：在新的一帧中从遮挡状态转变为不被遮挡的状态<ul>
<li>这一帧的点在上一帧中被遮挡</li>
<li>于是在上一帧中找到的对应点并不是真正的对应点，而是<strong>挡住对应点的点</strong></li>
<li>屏幕空间的问题</li>
</ul>
</li>
<li>detached&#x2F;lagging shadows<ul>
<li>阴影的拖尾问题（shading 的问题）</li>
<li>如下场景，场景、像机都不移动，于是任何一个像素 motion vector 为 0</li>
<li>此时移动光源，造成阴影拖尾的现象</li>
</ul>
</li>
</ul>
<p><img src="/12/image-20210601000529916.png"></p>
<ul>
<li>glossy 反射的问题<ul>
<li>反射的拖尾（shading 的问题）</li>
<li>如下场景中，相机、地板、光源保持不动，于是地板的 motin vector 为 0</li>
<li>移动椅子，我们发现，地板上的反射效果得过一会才能跟上物体的运动</li>
<li>快速移动有延迟，滞后问题</li>
</ul>
</li>
</ul>
<p><img src="/12/image-20210601000906122.png"></p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题 3"></a>问题 3</h4><ul>
<li>不能用，但是强行使用<ul>
<li>Lagging：拖尾效果，鬼影</li>
</ul>
</li>
</ul>
<img src="12/image-20210531235727923.png" style="zoom:60%;" />

<ul>
<li>巧妙的使用</li>
<li>Clamping<ul>
<li>把上一帧的值先拉近到这一帧的结果</li>
</ul>
</li>
<li>Detection<ul>
<li>如果检测到不对应，则不使用上一帧的信息</li>
<li>例如给物体标 ID，如果上一帧的 ID 不一致，则调整 $\alpha$ 的值（使用更少的上一帧信息）</li>
</ul>
</li>
<li>这样的问题：引入了噪声（降噪效果变差）</li>
</ul>
<img src="12/image-20210601000246930.png" style="zoom:60%;" />



<h2 id="TAA"><a href="#TAA" class="headerlink" title="TAA"></a>TAA</h2><ul>
<li>The temporal accumulation is inspired by Temporal Anti-Aliasing (TAA)</li>
<li>类似的想法</li>
<li>论文<ul>
<li>Temporally Reliable Motion Vectors for Real-time Ray Tracing</li>
<li>[Eurographics]</li>
<li>实用，能够解决一些问题，更多挖掘可用信息</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/31/CG/YLQ-GAMES202/12/" data-id="cl9lj749w009164tz3r3w5ebk" data-title="GAMES202.闫令琪.12.实时光线追踪" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/15/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/17/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/0/">0</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algebra/">Algebra</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-Kits/">C++.Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG/">CG</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Algorithm/">CG.Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES101/">CG.GAMES101</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES102/">CG.GAMES102</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES103/">CG.GAMES103</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES104/">CG.GAMES104</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES202/">CG.GAMES202</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES203/">CG.GAMES203</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Kits/">CG.Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-LS/">CG.LS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-PBRT/">CG.PBRT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Paper/">CG.Paper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CV/">CV</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Code/">Code</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-CLJ/">DB.CLJ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-MySQL/">DB.MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-SQLServer/">DB.SQLServer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DSA/">DSA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kits/">Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-CXQ/">OS.CXQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-OSTEP/">OS.OSTEP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-xv6-labs/">OS.xv6-labs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-xv6-source-code/">OS.xv6-source-code</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TODO/">TODO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/book-directory/">book.directory</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computation-pyr/">computation.pyr</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/csharp-kits/">csharp.kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/csharp-tds/">csharp.tds</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/images/">images</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/installation/">installation</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mitsuba/">mitsuba</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nothing/">nothing</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-Maya/">software.Maya</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-ps/">software.ps</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-vscode/">software.vscode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/win/">win</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algebra/" rel="tag">Algebra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS/" rel="tag">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BST/" rel="tag">BST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BVH/" rel="tag">BVH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CG-Algorithm/" rel="tag">CG-Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CV/" rel="tag">CV</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Code/" rel="tag">Code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB/" rel="tag">DB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/" rel="tag">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DSA/" rel="tag">DSA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dijkstra/" rel="tag">Dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EG/" rel="tag">EG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Floyd/" rel="tag">Floyd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GI/" rel="tag">GI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Glints/" rel="tag">Glints</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDR/" rel="tag">HDR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HQX/" rel="tag">HQX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Heap/" rel="tag">Heap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kits/" rel="tag">Kits</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCA/" rel="tag">LCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLG/" rel="tag">LLG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MCMC/" rel="tag">MCMC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MIS/" rel="tag">MIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MLT/" rel="tag">MLT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maya/" rel="tag">Maya</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NEE/" rel="tag">NEE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBRT/" rel="tag">PBRT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paper/" rel="tag">Paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Radiometry/" rel="tag">Radiometry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RayTracing/" rel="tag">RayTracing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SAH/" rel="tag">SAH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SDF/" rel="tag">SDF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SGJ/" rel="tag">SGJ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLServer/" rel="tag">SQLServer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shadow/" rel="tag">Shadow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WHM/" rel="tag">WHM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WX/" rel="tag">WX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/book/" rel="tag">book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/computation/" rel="tag">computation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csharp/" rel="tag">csharp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/images/" rel="tag">images</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/installation/" rel="tag">installation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/" rel="tag">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mitsuba/" rel="tag">mitsuba</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobaxterm/" rel="tag">mobaxterm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nothing/" rel="tag">nothing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/obs/" rel="tag">obs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/occlusion/" rel="tag">occlusion</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ps/" rel="tag">ps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/software/" rel="tag">software</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tree/" rel="tag">tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/win/" rel="tag">win</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xv6/" rel="tag">xv6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%83%E5%AE%87%E5%AE%99/" rel="tag">元宇宙</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%A0%E4%BD%95/" rel="tag">几何</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/" rel="tag">可见性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" rel="tag">拓扑排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%99%AE%E5%90%95%E5%85%8B%E5%9D%90%E6%A0%87/" rel="tag">普吕克坐标</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="tag">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algebra/" style="font-size: 10px;">Algebra</a> <a href="/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/tags/BST/" style="font-size: 10px;">BST</a> <a href="/tags/BVH/" style="font-size: 12.5px;">BVH</a> <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/CG/" style="font-size: 20px;">CG</a> <a href="/tags/CG-Algorithm/" style="font-size: 10px;">CG-Algorithm</a> <a href="/tags/CV/" style="font-size: 10.63px;">CV</a> <a href="/tags/Code/" style="font-size: 14.38px;">Code</a> <a href="/tags/DB/" style="font-size: 19.38px;">DB</a> <a href="/tags/DFS/" style="font-size: 12.5px;">DFS</a> <a href="/tags/DP/" style="font-size: 13.13px;">DP</a> <a href="/tags/DSA/" style="font-size: 11.25px;">DSA</a> <a href="/tags/Dijkstra/" style="font-size: 10px;">Dijkstra</a> <a href="/tags/EG/" style="font-size: 12.5px;">EG</a> <a href="/tags/Floyd/" style="font-size: 10.63px;">Floyd</a> <a href="/tags/GI/" style="font-size: 11.25px;">GI</a> <a href="/tags/Glints/" style="font-size: 10px;">Glints</a> <a href="/tags/HDR/" style="font-size: 10px;">HDR</a> <a href="/tags/HQX/" style="font-size: 10px;">HQX</a> <a href="/tags/Heap/" style="font-size: 10px;">Heap</a> <a href="/tags/Kits/" style="font-size: 13.75px;">Kits</a> <a href="/tags/LCA/" style="font-size: 10px;">LCA</a> <a href="/tags/LLG/" style="font-size: 12.5px;">LLG</a> <a href="/tags/MCMC/" style="font-size: 10.63px;">MCMC</a> <a href="/tags/MIS/" style="font-size: 10px;">MIS</a> <a href="/tags/MLT/" style="font-size: 10px;">MLT</a> <a href="/tags/Maya/" style="font-size: 10px;">Maya</a> <a href="/tags/MySQL/" style="font-size: 11.88px;">MySQL</a> <a href="/tags/NEE/" style="font-size: 10px;">NEE</a> <a href="/tags/OS/" style="font-size: 17.5px;">OS</a> <a href="/tags/PBRT/" style="font-size: 10px;">PBRT</a> <a href="/tags/Paper/" style="font-size: 15.63px;">Paper</a> <a href="/tags/Radiometry/" style="font-size: 10px;">Radiometry</a> <a href="/tags/RayTracing/" style="font-size: 10px;">RayTracing</a> <a href="/tags/SAH/" style="font-size: 10px;">SAH</a> <a href="/tags/SDF/" style="font-size: 10px;">SDF</a> <a href="/tags/SGJ/" style="font-size: 10.63px;">SGJ</a> <a href="/tags/SQL/" style="font-size: 13.13px;">SQL</a> <a href="/tags/SQLServer/" style="font-size: 10.63px;">SQLServer</a> <a href="/tags/STL/" style="font-size: 11.25px;">STL</a> <a href="/tags/Shadow/" style="font-size: 10px;">Shadow</a> <a href="/tags/WHM/" style="font-size: 16.88px;">WHM</a> <a href="/tags/WX/" style="font-size: 11.88px;">WX</a> <a href="/tags/YLQ/" style="font-size: 18.13px;">YLQ</a> <a href="/tags/book/" style="font-size: 10.63px;">book</a> <a href="/tags/computation/" style="font-size: 18.75px;">computation</a> <a href="/tags/csharp/" style="font-size: 16.25px;">csharp</a> <a href="/tags/images/" style="font-size: 10px;">images</a> <a href="/tags/installation/" style="font-size: 11.88px;">installation</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/linux/" style="font-size: 11.25px;">linux</a> <a href="/tags/math/" style="font-size: 10px;">math</a> <a href="/tags/mitsuba/" style="font-size: 11.88px;">mitsuba</a> <a href="/tags/mobaxterm/" style="font-size: 10px;">mobaxterm</a> <a href="/tags/nothing/" style="font-size: 10.63px;">nothing</a> <a href="/tags/obs/" style="font-size: 10px;">obs</a> <a href="/tags/occlusion/" style="font-size: 15px;">occlusion</a> <a href="/tags/ps/" style="font-size: 10px;">ps</a> <a href="/tags/software/" style="font-size: 10px;">software</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/tree/" style="font-size: 11.25px;">tree</a> <a href="/tags/vscode/" style="font-size: 10.63px;">vscode</a> <a href="/tags/win/" style="font-size: 10.63px;">win</a> <a href="/tags/xv6/" style="font-size: 16.25px;">xv6</a> <a href="/tags/%E4%BA%8C%E5%88%86/" style="font-size: 10.63px;">二分</a> <a href="/tags/%E5%85%83%E5%AE%87%E5%AE%99/" style="font-size: 10.63px;">元宇宙</a> <a href="/tags/%E5%87%A0%E4%BD%95/" style="font-size: 10px;">几何</a> <a href="/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/" style="font-size: 11.88px;">可见性</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 10.63px;">并查集</a> <a href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">拓扑排序</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%99%AE%E5%90%95%E5%85%8B%E5%9D%90%E6%A0%87/" style="font-size: 10px;">普吕克坐标</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 10px;">最小生成树</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" style="font-size: 13.13px;">最短路</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 10px;">线段树</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/23/CG/WHM-GAMES103/11/">GAMES103.王华民.11.Incompressible Fluid Dynamics and Eulerian Fluids</a>
          </li>
        
          <li>
            <a href="/2022/10/23/CG/Papers/2021/bvh-survey-3/">(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(4)</a>
          </li>
        
          <li>
            <a href="/2022/04/28/CG/Kits/MIS-NEE/">NEE、MIS(多重重要性采样)</a>
          </li>
        
          <li>
            <a href="/2022/04/18/CG/WHM-GAMES103/10/">GAMES103.王华民.10.Surface Waves</a>
          </li>
        
          <li>
            <a href="/2022/04/17/CG/WHM-GAMES103/09-1/">GAMES103.王华民.09.Collision Handling(1)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>