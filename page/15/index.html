<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/15/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-OS/CXQ/Review-3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/21/OS/CXQ/Review-3/" class="article-date">
  <time class="dt-published" datetime="2021-06-21T07:55:35.000Z" itemprop="datePublished">2021-06-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OS-CXQ/">OS.CXQ</a>►<a class="article-category-link" href="/categories/TODO/">TODO</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/21/OS/CXQ/Review-3/">操作系统复习.陈向群（文件系统）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="操作系统复习"><a href="#操作系统复习" class="headerlink" title="操作系统复习"></a>操作系统复习</h1><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><ul>
<li>文件系统、文件、文件分类、文件控制块 FCB、文件目录、目录文件、文件系统布局 、文件逻辑结构、文件物理结构、文件描述符 &#x2F; 文件句柄、FAT &#x2F; UNIX、文件基本操作、内存结构、文件共享、磁盘空间管理</li>
</ul>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><ul>
<li>怎样理解 “文件是对磁盘的抽象”？</li>
<li>文件系统提供了哪些 “接口” </li>
<li>怎样实现 “文件的按名存取” ？</li>
<li>文件系统的 “最后一公里”是什么？</li>
<li>怎样设计 “文件的属性”？</li>
<li>怎样理解 “文件的逻辑结构和物理结构” ？</li>
<li>文件目录、目录文件和目录项之间的关联？目录项和文件控制块(FCB)的区别和相同点？</li>
<li>实现文件系统需要考虑磁盘与内存中的内容布局，UNIX、FAT 和 NTFS几个文件系统都是怎样设计的？</li>
<li>怎样理解 “目录文件的组织方式：顺序、散列、B+树” ？</li>
<li>“文件目录检索” 的步骤有哪两步？每一步达到什么目的？如何加快这一步骤？</li>
<li>文件系统在内存中需要数据结构，为什么？</li>
<li>FAT16文件系统的局限性是什么？</li>
<li>怎样实现系统调用rename (给文件重命名) ？</li>
<li>怎样实现系统调用copy (复制文件) ？</li>
<li>为什么提供 “硬链接” 和 “软链接” ？</li>
</ul>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="文件系统基本概念"><a href="#文件系统基本概念" class="headerlink" title="文件系统基本概念"></a>文件系统基本概念</h4><ul>
<li>文件是什么<ul>
<li>文件是对磁盘的抽象</li>
<li>所谓文件是指一组带标识（标识即为文件名）的、在逻辑上有完整意义的<strong>信息项的序列</strong></li>
<li><strong>信息项</strong></li>
<li>文件内容的意义：<strong>由文件建立者和使用者解释</strong></li>
</ul>
</li>
<li>文件系统</li>
<li>文件的分类：普通文件、目录文件、特殊文件(设备文件)、管道文件、套接字、符号链接文件</li>
<li>文件的逻辑结构<ul>
<li>字节序列（流式文件）、记录序列（记录式文件）、树</li>
<li>堆、顺序、索引、散列、索引顺序</li>
</ul>
</li>
<li>文件存取方式<ul>
<li>顺序访问、随机存取</li>
</ul>
</li>
<li>存储介质</li>
<li>磁盘：扇区 $\to$ 物理块</li>
<li>磁盘结构</li>
</ul>
<img src="Review-3/image-20210621161552239.png" style="zoom:67%;" />

<ul>
<li>磁盘访问<ul>
<li><strong>寻道</strong>（时间）：磁头移动定位到指定磁道</li>
<li><strong>旋转延迟</strong>（时间）：等待指定扇区从磁头下旋转经过</li>
<li><strong>数据传输</strong>（时间）：数据在磁盘与内存之间的实际传输</li>
</ul>
</li>
<li>文件属性<ul>
<li>文件控制块 FCB</li>
<li>常用属性</li>
</ul>
</li>
<li>文件操作<ul>
<li>create、delete、open、…</li>
</ul>
</li>
</ul>
<p><span style="color:red;font-weight:bold">TODO</span></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/21/OS/CXQ/Review-3/" data-id="cl9lj74b400h464tz9l8fa3xg" data-title="操作系统复习.陈向群（文件系统）" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OS/CXQ/Review-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/OS/CXQ/Review-2/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T13:13:00.000Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OS-CXQ/">OS.CXQ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/20/OS/CXQ/Review-2/">操作系统复习.陈向群（06-07）（存储管理）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="操作系统复习（06-07）"><a href="#操作系统复习（06-07）" class="headerlink" title="操作系统复习（06-07）"></a>操作系统复习（06-07）</h1><h2 id="Chapter-06：存储管理概述"><a href="#Chapter-06：存储管理概述" class="headerlink" title="Chapter 06：存储管理概述"></a>Chapter 06：存储管理概述</h2><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><ul>
<li>地址重定位、逻辑地址、物理地址、存储保护、存储共享、单一连续区、固定分区、覆盖技术、可变分区、页式、段式、虚拟内存、虚拟存储空间、虚拟地址、物理地址、页表&#x2F;页表项、快表 TLB、驻留集、工作集、页面置换算法、清除策略、交换技术、段页式、Page Fault、加载控制、页缓冲技术、地址转换、地址变换、地址翻译、地址映射</li>
</ul>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><ul>
<li>怎样理解 “进程地址空间是对内存的抽象” 这句话？</li>
<li>结合课件 21 页的图、 22 页上的图说明采用的是哪一种内存分配算法？</li>
<li>课件 32 页上提到紧缩时要考虑的问题包括系统开销和移动时机两方面，请具体说明为什么要考虑这两个问题？</li>
<li>采用交换技术后，被换出内存后再换入内存的进程是否必须回到原处？如果不是，通过什么方式(技术或机制)可以做到</li>
<li>请给出一种管理磁盘交换区的方案。</li>
<li>课件 50 页上提出了两种解决进程空间增长的解决方案，请比较它们。你倾向哪一种解决方案，为什么？</li>
</ul>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ul>
<li>连续性 — 离散性</li>
<li>驻留性 — 交换性</li>
<li>一次性 — 多次性</li>
<li>地址重定位：将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址的过程<ul>
<li>静态地址重定位：加载到内存时</li>
<li>动态地址重定位：逐条指令执行时<ul>
<li>MMU</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="物理内存管理方案"><a href="#物理内存管理方案" class="headerlink" title="物理内存管理方案"></a>物理内存管理方案</h4><ul>
<li>空闲物理内存管理<ul>
<li>位图、空闲区表（已分配区表）、空闲块链表</li>
</ul>
</li>
<li>内存分配算法<ul>
<li>首次适配（first fit）</li>
<li>下次适配（next fit）<ul>
<li>从上次找到的空闲区处接着查找，其他和首次适配相同</li>
</ul>
</li>
<li>最佳适配（best fit）</li>
<li>最差适配（worst ft）</li>
</ul>
</li>
<li>回收问题<ul>
<li>合并空闲块</li>
<li>上相邻、下相邻、上下都相邻、上下都不相邻</li>
</ul>
</li>
</ul>
<h5 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h5><ul>
<li>Linux 底层内存管理采用</li>
<li>例子<ul>
<li>整块分配</li>
<li>只有伙伴才合并</li>
<li>最佳适配</li>
</ul>
</li>
</ul>
<img src="Review-2/image-20210621102110784.png" style="zoom:67%;" />



<h4 id="基本内存管理方案"><a href="#基本内存管理方案" class="headerlink" title="基本内存管理方案"></a>基本内存管理方案</h4><ul>
<li>单一用户连续区</li>
<li>固定分区</li>
<li>可变分区<ul>
<li>碎片<ul>
<li>紧缩技术（memory compaction）：在内存移动程序，将所有小的空闲区合并为较大的空闲区</li>
</ul>
</li>
</ul>
</li>
<li>页式<ul>
<li>内存块（物理页面、页框、页帧、page frame）</li>
<li>页表、页表项</li>
<li>逻辑地址：页号、页内偏移</li>
<li><strong>内碎片</strong></li>
</ul>
</li>
<li>段式<ul>
<li>段内连续，段间可以不连续</li>
<li><strong>用户程序地址空间</strong>：按程序自身的<strong>逻辑关系</strong>划分为若干个程序段，每个程序段都有一个段名</li>
<li><strong>内存空间</strong>被<strong>动态</strong>的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定</li>
<li>逻辑地址：段号、段内地址</li>
</ul>
</li>
<li>段页式<ul>
<li>用户程序划分：按段式划分（对用户来讲，按段的逻辑关系进行划分；对系统讲，按页划分每一段）</li>
<li><strong>每一段有一个页表</strong></li>
</ul>
</li>
</ul>
<h4 id="内存-“扩充”"><a href="#内存-“扩充”" class="headerlink" title="内存 “扩充”"></a>内存 “扩充”</h4><ul>
<li>覆盖技术（Overlaying）：早期操作系统<ul>
<li>程序执行过程中，<strong>程序的不同部分在内存中相互替代</strong><ul>
<li>按照其自身的逻辑结构将那些不会同时执行的程序段共享同一块内存区域</li>
<li>要求程序各模块之间有明确的调用结构</li>
</ul>
</li>
<li>程序员声明覆盖结构，操作系统完成自动覆盖</li>
</ul>
</li>
</ul>
<img src="Review-2/image-20210621105758541.png" style="zoom: 50%;" />

<ul>
<li>交换技术（Swapping）<ul>
<li>交换区：一般系统会指定一块<strong>特殊的磁盘区域</strong>作为交换空间（swap space），包含<strong>连续的磁道</strong>，操作系统可以使用底层的磁盘读写操作对其<strong>高效访问</strong></li>
</ul>
</li>
</ul>
<h2 id="Chapter-07：虚拟存储管理"><a href="#Chapter-07：虚拟存储管理" class="headerlink" title="Chapter 07：虚拟存储管理"></a>Chapter 07：虚拟存储管理</h2><h3 id="关键词-1"><a href="#关键词-1" class="headerlink" title="关键词"></a>关键词</h3><ul>
<li>虚拟存储管理、硬件机制（地址转换）、页表&#x2F;页表项、页错误处理、各种软件策略（读取策略、放置策略、置换策略、驻留集策略、清除策略、装载控制策略）</li>
</ul>
<h3 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h3><ul>
<li>进程地址空间是对内存的抽象，请解读一下课件第 3 页上的图</li>
<li>虚拟内存、虚拟地址空间、虔拟地址、虔拟存储技术四个术语的解释</li>
<li>怎样理解操作系统中的资源转换技术？举例说明</li>
<li>结合课件 23-24 页的内容和图，梳理一下 CPU 取到虚拟地址并把转换为物理地址的过程</li>
<li>课件 30 页的图表示的是什么流程？请总结一下该流程的每一个步骤</li>
<li>OPT 置换算法的作用是什么？在什么条件下可以实现它？</li>
<li>请比较老化算法（Aging）与 LRU 算法</li>
<li>课件 36 页上给出了设计页面置换算法时的典型思路:基于过去的行为来预测将来的行为。请列举日常生活中运用这一思路的例子</li>
<li>课件第 48 页的置换算法是一种简单的使用特殊硬件实现 LRU 的方法，请解释理由</li>
<li>实现工作集模型需要考虑哪些因素？开放性探讨一下：是否可以采用机器学习等方法实现工作集模型？有没有使用场录？利弊各是什么？</li>
<li>TLB 什么时候刷新？怎么刷新？</li>
</ul>
<h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><ul>
<li>主要是虚拟页式存储管理</li>
<li>概念区分<ul>
<li><strong>虚拟内存</strong>：物理内存和磁盘</li>
<li><strong>虚拟地址空间</strong>：分配给进程的虚拟内存</li>
<li><strong>虚拟地址</strong>：虚拟内存中某一位置的地址</li>
<li><strong>虚拟存储技术</strong>：当进程运行时，先将其一部分装入内存，另一部分暂时保存在磁盘；当要执行的指令或访问的数据不在内存时，由操作系统自动完成将它们从磁盘调入内存的工作</li>
</ul>
</li>
<li>lazy allocation</li>
<li>交换技术</li>
<li>请求调页（demand paging）、预先调页（prepaging）</li>
<li>MMU</li>
</ul>
<img src="Review-2/image-20210621114558663.png" style="zoom:50%;" />

<ul>
<li>页表表项设计<ul>
<li>页框号</li>
<li>有效位（valid、present）</li>
<li>访问位（referenced、accessed）</li>
<li>修改位（dirty、modified）</li>
<li>保护位：读 &#x2F; 写 &#x2F; 执行（protection）</li>
</ul>
</li>
</ul>
<img src="Review-2/image-20210621115053925.png" style="zoom: 45%;" />

<ul>
<li><strong>多级页表</strong></li>
<li>二级页表<ul>
<li>页目录</li>
</ul>
</li>
<li>四级页表示例</li>
</ul>
<img src="Review-2/image-20210509193047497.png" alt="image-20210621120928868" style="zoom: 67%;" />

<ul>
<li>反转页表（节省内存）<ul>
<li>从物理地址空间出发，系统建立一张页表</li>
<li>页表项记录进程i的某虚拟地址(虚页号) 与页框号的映射关系</li>
<li>虚拟地址翻译：哈希表（拉链法解决冲突问题）</li>
</ul>
</li>
<li>地址转换<ul>
<li>虚拟页面不在内存、页面非法、或者被保护 $\Rightarrow$ Page Fault</li>
</ul>
</li>
<li>快表 TLB<ul>
<li>相联存储器</li>
<li>保存正在运行进程的页表的子集（部分表项）</li>
</ul>
</li>
</ul>
<img src="Review-2/image-20210621125731348.png" style="zoom:80%;" />

<ul>
<li>TLB 和 高速缓存</li>
</ul>
<img src="Review-2/image-20210621125923726.png" style="zoom:80%;" />

<ul>
<li>缺页异常：一种 page fault</li>
<li>驻留集管理<ul>
<li>固定分配策略、可变分配策略（通过缺页率评估）</li>
</ul>
</li>
</ul>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ul>
<li>置换策略<ul>
<li>局部置换策略：缺页进程的驻留集</li>
<li>全局置换策略：内存中所有未锁定的页框</li>
</ul>
</li>
<li>置换策略<ul>
<li>目标：<strong>置换最近最不可能访问的页</strong></li>
<li>局部性原理：基于过去预测未来</li>
</ul>
</li>
<li>页框锁定<ul>
<li>操作系统核心代码、关键数据结构、<strong>I&#x2F;O 缓冲区</strong></li>
</ul>
</li>
</ul>
<h5 id="页面置换算法-replacement"><a href="#页面置换算法-replacement" class="headerlink" title="页面置换算法 replacement"></a>页面置换算法 replacement</h5><h6 id="理想（最佳、最优）置换算法（OPT）"><a href="#理想（最佳、最优）置换算法（OPT）" class="headerlink" title="理想（最佳、最优）置换算法（OPT）"></a>理想（最佳、最优）置换算法（OPT）</h6><h6 id="先进先出页面置换算法（FIFO）"><a href="#先进先出页面置换算法（FIFO）" class="headerlink" title="先进先出页面置换算法（FIFO）"></a>先进先出页面置换算法（FIFO）</h6><ul>
<li>页面链表实现</li>
</ul>
<h6 id="第二次机会置换算法（SCR）"><a href="#第二次机会置换算法（SCR）" class="headerlink" title="第二次机会置换算法（SCR）"></a>第二次机会置换算法（SCR）</h6><ul>
<li>按照先进先出算法选择某一页面，检查其访问位 R<ul>
<li>如果为 0，则置换该页</li>
<li>如果为 1，则给第二次机会，并将访问位置 0，把该页面放到链表的尾端（新放入一样）</li>
</ul>
</li>
</ul>
<h6 id="时钟算法（Clock）"><a href="#时钟算法（Clock）" class="headerlink" title="时钟算法（Clock）"></a>时钟算法（Clock）</h6><ul>
<li>循环链表</li>
<li>不移动页面位置</li>
</ul>
<h6 id="最近未使用算法（NRU）"><a href="#最近未使用算法（NRU）" class="headerlink" title="最近未使用算法（NRU）"></a>最近未使用算法（NRU）</h6><ul>
<li>选择在最近一段时间内未使用过的一页并置换</li>
<li>算法<ul>
<li>访问位（R）、修改位（M）</li>
<li>分类<ul>
<li>第 0 类：无访问，无修改</li>
<li>第 1 类：无访问，有修改</li>
<li>第 2 类：有访问，无修改</li>
<li>第 3 类：有访问，有修改</li>
</ul>
</li>
<li>随机从编号最小的非空类中选择一页置换</li>
</ul>
</li>
<li>实现<ul>
<li>(1) 从指针的当前位置开始，扫描页框缓冲区，选择遇到的第一个页框（r&#x3D;0；m&#x3D;0）用于置换（本扫描过程中，对访问位不做任何修改）</li>
<li>(2) 如果第 1 步失败，则重新扫描，选择第一个（r&#x3D;0；m&#x3D;1）的页框（本次扫描过程中，对每个跳过的页框，将其访问位设置成 0）</li>
<li>(3) 如果第 2 步失败，指针将回到它的最初位置，并且集合中所有页框的访问位均为 0。重复第 1 步，并且，如果有必要，重复第 2 步</li>
</ul>
</li>
<li>实现的区别就是修改了访问位<ul>
<li>如果只跑一次这个算法结果是一样的</li>
</ul>
</li>
<li><strong>NRU 不带时间戳</strong></li>
</ul>
<h6 id="最近少使用算法-LRU"><a href="#最近少使用算法-LRU" class="headerlink" title="最近少使用算法 (LRU)"></a>最近少使用算法 (LRU)</h6><ul>
<li>LRU 性能接近 OPT</li>
<li>实现：时间戳、维护一个访问页的栈<ul>
<li>开销大</li>
</ul>
</li>
<li>一种硬件实现<ul>
<li>访问：行置为 1，列置为 0</li>
<li>置换：把和最小的行替换掉</li>
</ul>
</li>
<li>一个例子：页面访问顺序 0, 1, 2, 3, 2, 1, 0, 3, 2, 3</li>
</ul>
<img src="Review-2/image-20210621134821834.png" style="zoom:40%;" />



<h6 id="最不经常使用算法（NFU）"><a href="#最不经常使用算法（NFU）" class="headerlink" title="最不经常使用算法（NFU）"></a>最不经常使用算法（NFU）</h6><ul>
<li>选择访问次数最少的页面置换</li>
<li>实现：<ul>
<li>软件计数器，一页一个，初值为 0</li>
<li>每次时钟中断时，计数器加 R</li>
<li>发生缺页中断时，选择计数器值最小的一页置换</li>
</ul>
</li>
</ul>
<h6 id="老化算法（Aging）"><a href="#老化算法（Aging）" class="headerlink" title="老化算法（Aging）"></a>老化算法（Aging）</h6><ul>
<li>改进（模拟LRU）：计数器在加 R 前先右移一位，R 位加到计数器的最左端</li>
<li>感觉和 LRU 相似，但是计数器的位数是有限的，会把较早的访问情况冲掉</li>
</ul>
<h6 id="页面置换例子"><a href="#页面置换例子" class="headerlink" title="页面置换例子"></a>页面置换例子</h6><ul>
<li>注意 FIFO 访问已经缓存的页的时候不移动链表（相当于不修改时间戳）</li>
</ul>
<img src="Review-2/image-20210621135801334.png" style="zoom:150%;" />

<ul>
<li>LRU</li>
</ul>
<img src="Review-2/image-20210621135939814.png" style="zoom:150%;" />

<ul>
<li>OPT</li>
</ul>
<img src="Review-2/image-20210621135958374.png" style="zoom:150%;" />

<h5 id="Belady-现象"><a href="#Belady-现象" class="headerlink" title="Belady 现象"></a>Belady 现象</h5><ul>
<li>FIFO：当分配给进程的物理页面数增加时，缺页次数反而增加</li>
</ul>
<h5 id="影响缺页次数的因素"><a href="#影响缺页次数的因素" class="headerlink" title="影响缺页次数的因素"></a>影响缺页次数的因素</h5><ul>
<li>因素<ul>
<li>页面置换算法</li>
<li>页面本身的大小<ul>
<li>最佳页面大小：$\sqrt{2se}$</li>
</ul>
</li>
<li>程序的编制方法</li>
<li>分配给进程的物理页面数</li>
</ul>
</li>
<li>颠簸（Thrashing，抖动）<ul>
<li>虚存中，页面在内存与磁盘之间频繁调度，使得调度页面所需的时间比进程实际运行的时间还多，这样导致系统效率急剧下降，这种现象称为颠簸或抖动</li>
</ul>
</li>
</ul>
<h5 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h5><ul>
<li>活跃页面</li>
<li>工作集 $W(t,\Delta)$<ul>
<li>该进程在过去的 $\Delta$ 个虚拟时间单位中使用的虚拟页面集合</li>
</ul>
</li>
<li>驻留集：当前时刻，进程实际驻留在内存当中的页框集合</li>
<li>思路：找出一个不在工作集中的页面并置换它<ul>
<li>判定：每个页表项中有一个字段记录该页面最后一次被访问的时间</li>
</ul>
</li>
<li>算法实现<ul>
<li>扫描所有页表项，执行操作</li>
<li>(1) 如果一个页面的 R 位是 1，则将该页面的最后一次访问时间设为当前时间，将 R 位清零</li>
<li>(2)  如果一个页面的 R 位是 0，则检查该页面的访问时间是否在 “当前时间 - T” 之前<ol start="2">
<li><pre><code>[1] 如果是，则该页面为被置换的页面；
</code></pre>
<ol start="2">
<li><pre><code>[2] 如果不是，记录当前所有被扫描过页面的最后访问时间里面的最小值。扫描下一个页面并重复 (1)、(2)
</code></pre>
<ol start="2">
<li><pre><code>类似的思想：监视缺页率增减驻留集大小
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="清除策略"><a href="#清除策略" class="headerlink" title="清除策略"></a>清除策略</h5><ul>
<li>保存一定数目的页框供给比使用所有内存并在需要时搜索一个页框有更好的性能</li>
<li>一个置换出去但是还未被覆盖的页面，当他再次被访问的时候，直接将其移出空闲缓冲池即可</li>
<li>分页守护进程：检查内存状态，保证有大量空闲页框</li>
<li>双指针时钟：前指针由分页守护进程控制</li>
<li><strong>页缓冲技术</strong><ul>
<li>空闲页链表</li>
<li>修改页链表：簇的方式写回（减少 I&#x2F;O）</li>
</ul>
</li>
</ul>
<h5 id="加载控制"><a href="#加载控制" class="headerlink" title="加载控制"></a>加载控制</h5><ul>
<li>系统并发度：驻留在内存中的进程数目</li>
<li><strong>通过调节并发进程数进行系统负载控制</strong><ul>
<li>交换到磁盘</li>
</ul>
</li>
</ul>
<h4 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h4><ul>
<li>mmap()</li>
<li>lazy 读入</li>
<li>共享库文件中的共享对象</li>
<li>私有的写时拷贝对象</li>
</ul>
<h4 id="策略与机制分离"><a href="#策略与机制分离" class="headerlink" title="策略与机制分离"></a>策略与机制分离</h4><ul>
<li>Mach</li>
<li>存储管理系统被分为三个部分<ul>
<li>底层MMU处理程序（与机器相关）</li>
<li>作为内核一部分的缺页中断处理程序（与机器无关）</li>
<li>运行在<strong>用户空间</strong>中的外部页面调度程序（策略）</li>
</ul>
</li>
</ul>
<img src="Review-2/image-20210621144545558.png" style="zoom:50%;" />



<h2 id="Chapter-07-2：Windows-虚拟内存管理技术"><a href="#Chapter-07-2：Windows-虚拟内存管理技术" class="headerlink" title="Chapter 07-2：Windows 虚拟内存管理技术"></a>Chapter 07-2：Windows 虚拟内存管理技术</h2><h3 id="思考题-2"><a href="#思考题-2" class="headerlink" title="思考题"></a>思考题</h3><ul>
<li>进程虚拟地址空间的大小由谁决定？</li>
<li>进程虚拟地址空间的布局由谁确定？</li>
<li>创建一个进程，加载相应的可执行文件并且执行的过程是怎样的？</li>
<li>当捕获到缺页错误时，操作系统如何知道程序当前所需要的页在可执行文件中的哪一个位置？</li>
<li>总结 Windows 自映射机制的实现原理</li>
<li>总结 Windows 的物理内存管理</li>
</ul>
<h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><h4 id="Intel-x86-虚拟内存机制"><a href="#Intel-x86-虚拟内存机制" class="headerlink" title="Intel x86 虚拟内存机制"></a>Intel x86 虚拟内存机制</h4><img src="Review-2/image-20210621145153555.png" style="zoom:50%;" />



<h4 id="Windows-虚拟内存管理"><a href="#Windows-虚拟内存管理" class="headerlink" title="Windows 虚拟内存管理"></a>Windows 虚拟内存管理</h4><h5 id="内存管理器的组成部分"><a href="#内存管理器的组成部分" class="headerlink" title="内存管理器的组成部分"></a>内存管理器的组成部分</h5><ul>
<li>工作集管理器（MmWorkingSetManager）</li>
<li>进程&#x2F;栈交换器（KeSwapProcessOrStack）</li>
<li>修改页面写出器（MiModifiedPageWriter）</li>
<li>映射页面写出器（MiMappedPageWriter）</li>
<li>零页线程（MmZeroPageThread）</li>
</ul>
<h5 id="缺页异常处理"><a href="#缺页异常处理" class="headerlink" title="缺页异常处理"></a>缺页异常处理</h5><ul>
<li><p>CPU 翻译的时候发现页表项无效 $\Rightarrow$ 缺页中断</p>
</li>
<li><p>发生缺页中断时， CPU 自动将引发异常时访问的虚拟地址存入寄存器 <strong>CR2</strong></p>
</li>
<li><p>走中断异常处理流程</p>
</li>
<li><p>根据操作系统提供的异常处理程序开始处理</p>
</li>
<li><p>页目录与自映射机制</p>
<ul>
<li>专用寄存器（x86 中为 <strong>CR3</strong>）用于保存页目录的物理地址</li>
</ul>
</li>
</ul>
<img src="Review-2/image-20210621152121351.png" style="zoom:67%;" />



<h5 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h5><ul>
<li>基于工作集模型的页面置换算法</li>
</ul>
<h5 id="用户空间内存分配方式"><a href="#用户空间内存分配方式" class="headerlink" title="用户空间内存分配方式"></a>用户空间内存分配方式</h5><ul>
<li>以页为单位的虚拟内存分配方式<ul>
<li>两阶段：<strong>保留</strong>、<strong>提交</strong></li>
<li>如何判断保留&#x2F;提交<ul>
<li>页表可以判断提交，但是无法判断保留</li>
<li>VAD 虚拟地址描述符，平衡二叉树</li>
</ul>
</li>
</ul>
</li>
<li>内存映射文件</li>
<li>内存堆方法<ul>
<li>适用于大量的小型内存申请</li>
</ul>
</li>
</ul>
<h5 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h5><ul>
<li>页框的状态<ul>
<li>活动（Active）&#x2F; 有效（Valid ）：在工作集中</li>
<li>过渡（Transition）：读入页框 &#x2F; 从页框写出</li>
<li>空闲（Free）</li>
<li>零初始化（zeroed）：空闲且被零初始化</li>
<li>坏（Bad ）：硬件坏了</li>
<li>后备（standby）：页框内容未修改，invalid、transition，但是内容还在</li>
<li>修改（Modified）：页框内容修改过，invalid、transition，但是内容还在</li>
</ul>
</li>
<li>页表与页框号数据库</li>
</ul>
<img src="Review-2/image-20210621154155412.png" style="zoom:67%;" />

<ul>
<li>了解每一条线是为什么<ul>
<li>进程的工作集出来：页框不够用得回收（看是否被修改）、<strong>进程结束</strong></li>
</ul>
</li>
</ul>
<img src="Review-2/image-20210621154246683.png" style="zoom:67%;" />
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/OS/CXQ/Review-2/" data-id="cl9lj74b500he64tzazipcc6w" data-title="操作系统复习.陈向群（06-07）（存储管理）" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OS/CXQ/Review-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/OS/CXQ/Review-1/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T07:07:36.000Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OS-CXQ/">OS.CXQ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/20/OS/CXQ/Review-1/">操作系统复习.陈向群（03-05）（进程线程）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="操作系统复习（03-05）"><a href="#操作系统复习（03-05）" class="headerlink" title="操作系统复习（03-05）"></a>操作系统复习（03-05）</h1><h2 id="Chapter-03：进程线程模型"><a href="#Chapter-03：进程线程模型" class="headerlink" title="Chapter 03：进程线程模型"></a>Chapter 03：进程线程模型</h2><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><ul>
<li>进程、进程状态及状态转换、进程控制、进程控制块、进程地址空间、进程上下文、线程、线程属性、Web 服务器、用户级线程、Pthreads、核心级线程 、原语、可再入程序</li>
</ul>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><ul>
<li>怎样理解 “进程是对 CPU 的抽象” 这句话？</li>
<li>一个程序要经过哪些准备工作才能运行(程序怎样变成进程) ？</li>
<li>进程有哪些状态？状态之间转换的条件以及对应的操作？</li>
<li>一个进程在生命周期内都由哪些要素组成？</li>
<li>从静态和动态两个角度，怎样观察进程？</li>
<li>进程与程序是一样的吗？你能用日常生活中的例子解释什么是进程、什么是程序吗？</li>
<li>什么是可再入程序？为什么进程执行的程序要具备可再入特性？</li>
<li>哪些应用场景需要多线程支持？</li>
<li>线程的基本概念是什么？与进程是什么关系？</li>
<li>线程有哪些属性？为什么线程要有自己的栈？</li>
<li>线程实现机制有哪几种？</li>
<li>典型的操作系统都是怎样支持线程的？</li>
<li>Linux 是怎样支持线程的？ Linux内核是否区分进程和线程？</li>
</ul>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>多道程序设计</li>
<li>并发环境与并发程序<ul>
<li>如下都可以认为是并发</li>
</ul>
</li>
</ul>
<img src="Review-1/image-20210620152710803.png" style="zoom:67%;" />

<ul>
<li>进程<ul>
<li>进程是具有独立功能的程序关于某个数据集合上的<strong>一次运行活动</strong>，是系统进行资源分配和调度的独立单位</li>
</ul>
</li>
</ul>
<h4 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h4><ul>
<li>三状态<ul>
<li>运行态（Running）、就绪态（Ready）、等待态（Waiting&#x2F;Blocked）</li>
</ul>
</li>
</ul>
<img src="Review-1/image-20210620153101230.png" style="zoom:50%;" />

<ul>
<li>5 状态<ul>
<li>创建（New）、终止（Terminated）、挂起（Suspended）<ul>
<li>挂起：把一个进程从内存转到<strong>磁盘</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="Review-1/image-20210620153216549.png" style="zoom:50%;" />

<ul>
<li>7 状态</li>
</ul>
<img src="Review-1/image-20210620153624993.png" style="zoom: 50%;" />

<ul>
<li>Linux 进程模型</li>
</ul>
<img src="Review-1/image-20210620153824357.png" style="zoom: 67%;" />



<ul>
<li><p>数据结构 PCB</p>
<ul>
<li>PCB 是系统感知进程存在的唯一标志</li>
</ul>
</li>
<li><p>PCB 内容</p>
<ul>
<li>进程描述信息、进程控制信息、所拥有的资源和使用情况、CPU 现场信息</li>
</ul>
</li>
<li><p>进程地址空间</p>
</li>
</ul>
<img src="Review-1/image-20210620155652222.png" style="zoom:50%;" />

<ul>
<li>上下文切换</li>
<li>进程表<ul>
<li>每类进程维护一个或者多个队列</li>
</ul>
</li>
</ul>
<h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><ul>
<li>原语<ul>
<li>原子操作</li>
</ul>
</li>
<li>进程的创建</li>
<li>进程的撤销</li>
<li>进程阻塞与进程唤醒</li>
<li>UNIX 系统设计的进程控制操作<ul>
<li>fork、exec、wait、exit</li>
</ul>
</li>
<li>copy-on-write 技术</li>
<li>进程的分类<ul>
<li>系统进程、用户进程</li>
<li>前台进程、后台进程</li>
<li>CPU 密集型进程、I&#x2F;O 密集型进程</li>
</ul>
</li>
<li>进程的层次结构<ul>
<li>UNIX进程家族树：init 为根</li>
<li>Windows：地位相同</li>
</ul>
</li>
</ul>
<h4 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h4><ul>
<li>为什么在进程中再派生线程？<ul>
<li>应用的需要<ul>
<li>web 服务器</li>
</ul>
</li>
<li>开销的考虑<ul>
<li>创建、撤销、通信、切换</li>
</ul>
</li>
<li>性能的考虑<ul>
<li>并行</li>
<li>多处理器</li>
</ul>
</li>
</ul>
</li>
<li>Web 服务器的 3 种实现方式</li>
</ul>
<table>
<thead>
<tr>
<th align="center">模型</th>
<th align="center">特性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">多线程</td>
<td align="center">并行性、阻塞系统调用</td>
</tr>
<tr>
<td align="center">单线程进程</td>
<td align="center">无并行性、阻塞系统调用</td>
</tr>
<tr>
<td align="center">有限状态机</td>
<td align="center">并行性、非阻塞系统调用、中断</td>
</tr>
</tbody></table>
<ul>
<li>线程：进程中一个运行实体，是 CPU 的调度单位<ul>
<li>轻量级进程</li>
</ul>
</li>
<li>单线程进程模型、多线程进程模型</li>
</ul>
<img src="Review-1/image-20210620162653610.png" style="zoom: 67%;" />

<ul>
<li>线程的实现<ul>
<li>用户级线程：Linux<ul>
<li>大多数系统调用是阻塞的，因此，由于内核阻塞进程，故进程中所有线程也被阻塞<ul>
<li>修改系统调用为非阻塞的</li>
<li>重新实现对应系统调用的I&#x2F;O库函数</li>
</ul>
</li>
</ul>
</li>
<li>核心级线程：Windows</li>
<li>混合：Solaris<ul>
<li>用户空间创建、核心态调度</li>
<li>多个用户级线程多路复用多个内核级线程</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="Review-1/image-20210620163606724.png" style="zoom:50%;" />

<ul>
<li>Solaris<ul>
<li>Solaris 的多线程模型中包括四种实体<ul>
<li>进程，内核线程，用户线程、轻量级进程（LWP）</li>
<li>LWP 把用户线程和内核线程绑定到一起</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="Review-1/image-20210620163756995.png" style="zoom: 60%;" />

<ul>
<li>可再入程序（可重入）<ul>
<li>可被多个进程同时调用的程序，具有下列性质<ul>
<li>它是纯代码的，即在执行过程中自身不改变</li>
<li>调用它的进程应该提供数据区</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Chapter-04：进程线程调度"><a href="#Chapter-04：进程线程调度" class="headerlink" title="Chapter 04：进程线程调度"></a>Chapter 04：进程线程调度</h2><h3 id="关键词-1"><a href="#关键词-1" class="headerlink" title="关键词"></a>关键词</h3><ul>
<li>调度层次、调度时机、进程切换、调度算法设计原则、抢占与非抢占、时间片、饥饿、调度算法、优先级反转、吞吐量、周转时间、响应时间、Linux调度算法、Windows 线程调度</li>
</ul>
<h3 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h3><ul>
<li>所谓调度仅仅是指的CPU(处理器)调度吗？</li>
<li>怎样描述进程的优先级？</li>
<li>就绪队列有哪些组织方式？</li>
<li>有哪些引发调度的原因？</li>
<li>衡量调度算法的指标有哪些？怎样选取？</li>
<li>怎样区分抢占式和非抢占式调度思想？</li>
<li>操作系统内核怎么实现抢占式调度策略的？</li>
<li>时间片轮转算法是抢占式调度算法吗？</li>
<li>操作系统的调度机制很好地体现了机制和策略分离<br>  的原则，请举例说明这一点</li>
<li>请同学们上网查一查, 1997年，美国发射的探测器‘探路者号”在火星上究竟发生了什么？请回答：<ul>
<li>这个故事涉及到进程调度的哪个知识点？</li>
<li>故事中涉及到的是哪一个操作系统？</li>
<li>运行过程中“ 探路者号” 遇到了什么问题？</li>
<li>这个问题产生的原因是什么？</li>
<li>工程师们是怎么解决这个问题的？</li>
<li>这件事给我们什么启示？</li>
</ul>
</li>
</ul>
<h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><ul>
<li>调度的 3 个层次<ul>
<li>长程调度：作业调度或宏观调度</li>
<li>中程调度：进程在内外存之间的交换</li>
<li>短程调度：微观调度（毫秒级）</li>
</ul>
</li>
<li>处理器调度<ul>
<li>系统空闲进程、idle 进程</li>
<li>调度程序</li>
</ul>
</li>
<li>三个问题：<strong>调度算法、调度时机、调度过程</strong></li>
<li><strong>调度时机</strong>：事件发生<ul>
<li>内核对中断&#x2F;异常&#x2F;系统调用处理后返回到用户态前最后时刻</li>
</ul>
</li>
<li><strong>调度过程</strong>：进程切换<ul>
<li>全局页目录</li>
<li>内核栈、硬件上下文</li>
<li>保存旧的，恢复新的</li>
</ul>
</li>
<li>上下文切换开销<ul>
<li>直接开销</li>
<li>间接开销：高速缓存 Cache、Buffer Cache、TLB</li>
</ul>
</li>
</ul>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><ul>
<li>目标<ul>
<li>交互式进程（interactive process）：响应时间、均衡性</li>
<li>批处理进程（batch process）：吞吐量、周转时间、CPU利用率</li>
<li>实时进程（real-time process）：最后期限、可预测性</li>
</ul>
</li>
<li>评价指标<ul>
<li>公平性 Fairness</li>
<li>吞吐量 Throughput </li>
<li>周转时间 TT (Turnaround Time)：提出请求到完成</li>
<li>响应时间 RT (Response Time)</li>
<li>CPU 利用率 (CPU Utilization)</li>
<li>等待时间 (Waiting time)</li>
</ul>
</li>
</ul>
<h5 id="调度算法要点"><a href="#调度算法要点" class="headerlink" title="调度算法要点"></a>调度算法要点</h5><ul>
<li>进程优先级</li>
<li>进程就绪队列组织<ul>
<li>按优先级排队、多级队列</li>
</ul>
</li>
</ul>
<img src="Review-1/image-20210620171014692.png" style="zoom: 67%;" />

<ul>
<li>抢占与非抢占</li>
<li>I&#x2F;O 密集型与 CPU 密集型进程</li>
<li>时间片<ul>
<li>长短、长短是否一致、是否可变</li>
</ul>
</li>
</ul>
<h5 id="批处理系统中采用的调度算法"><a href="#批处理系统中采用的调度算法" class="headerlink" title="批处理系统中采用的调度算法"></a>批处理系统中采用的调度算法</h5><ul>
<li>先来先服务（FCFS-First Come First Serve）</li>
<li>最短作业优先（SJF-Shortest Job First）</li>
<li>最短剩余时间优先（SRTN-Shortest Remaining Time Next）<ul>
<li>SJF 的抢占版本</li>
</ul>
</li>
<li>最高响应比优先（HRRN-Highest Response Ratio Next）<ul>
<li>响应比 R &#x3D; 作业周转时间 &#x2F; 作业处理时间 &#x3D; 1 +（作业等待时间 &#x2F; 作业处理时间）</li>
<li>抢占版本、不可抢占版本</li>
</ul>
</li>
</ul>
<h5 id="交互式系统中采用的调度算法"><a href="#交互式系统中采用的调度算法" class="headerlink" title="交互式系统中采用的调度算法"></a>交互式系统中采用的调度算法</h5><ul>
<li>轮转调度（RR-Round Robin）<ul>
<li>对于相同大小的进程不利（平均周转时间）</li>
</ul>
</li>
<li>优先级调度（HPF-Highest Priority First）<ul>
<li>通常而言<ul>
<li><strong>系统进程优先级</strong> 高于 用户进程</li>
<li><strong>前台进程优先级</strong> 高于 后台进程操作</li>
<li>系统更偏好 I&#x2F;O 型进程</li>
</ul>
</li>
<li>优先级反转问题（抢占才会出现）<ul>
<li>设置优先级上限（优先级天花板协议 priority ceiling protocol）</li>
<li>优先级继承<ul>
<li><strong>阻挡了谁就继承谁</strong></li>
</ul>
</li>
<li>使用中断禁止</li>
</ul>
</li>
</ul>
</li>
<li>多级队列（Multiple queues）与多级反馈队列（Multiple feedback queue）</li>
<li>最短进程优先（Shortest Process Next）</li>
</ul>
<h5 id="Windows-调度算法"><a href="#Windows-调度算法" class="headerlink" title="Windows 调度算法"></a>Windows 调度算法</h5><ul>
<li>动态优先级、抢占式</li>
<li>具体算法</li>
<li>线程优先级提升与时间配额调整</li>
</ul>
<h5 id="Linux-调度算法"><a href="#Linux-调度算法" class="headerlink" title="Linux 调度算法"></a>Linux 调度算法</h5><img src="Review-1/image-20210620192211811.png" style="zoom:67%;" />



<h5 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h5><ul>
<li>负载均衡、迁移开销（直接、间接）</li>
<li>静态进程分配、动态进程分配</li>
</ul>
<h2 id="Chapter-05：进程线程同步模型"><a href="#Chapter-05：进程线程同步模型" class="headerlink" title="Chapter 05：进程线程同步模型"></a>Chapter 05：进程线程同步模型</h2><h3 id="关键词-2"><a href="#关键词-2" class="headerlink" title="关键词"></a>关键词</h3><ul>
<li>临界区、进程互斥、进程同步、信号量、PV 操作、管程、生产者消费者问题、读者写者问题、 条件变量、wait&#x2F;signal、锁、Pthreads、Hoare 管程</li>
</ul>
<h3 id="思考题-2"><a href="#思考题-2" class="headerlink" title="思考题"></a>思考题</h3><ul>
<li>课件第 17 页，如果把判断标志然后谖置标志实现为 lock()，则lock() 应该满足 什么性质？</li>
<li>当有进程在临界区时，有两种处理方式: (1) 一直占用 CPU 等待进入临界区; (2) 阻塞等待。试问前者的效率一定比后者的效率低吗？</li>
<li>课件 25-26 页， “睡眠” 与“唤醒”操作都是原语操作，为什么用它们解决生产者消费者问题时依然可能出错？在什么场景下会出错？简单思考一下如何解决？</li>
<li>课件32页上给出的 PV 操作的定义与参考书《现代操作系统》或 ICS 课上的定义不同，但效果是否一样？请解释一下</li>
<li>请简单总结一下JAVA语言对管程的支持<ul>
<li>如何解决互斥问题？</li>
<li>如何解决同步问题？</li>
</ul>
</li>
<li>课件第 80 页上锁的实现代码是否正确？为什么？第 81 页的解决方案是不是对的？第 82 页的呢？请解释一下 83 页的方案</li>
<li>阅读一下课件第 91 页上的例子，总结一下在用消息传递实现生产者消费者问题时，send 和 receive 的作用</li>
<li>请举一个简单的例子，说明 Linux 的共享内存机制的应用</li>
</ul>
<h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><ul>
<li><p>进程：并发、共享、不确定性</p>
</li>
<li><p>顺序环境：程序执行的顺序性</p>
</li>
<li><p>并发环境</p>
</li>
<li><p>进程前趋图</p>
</li>
<li><p>竞争条件（race）</p>
</li>
<li><p>进程互斥</p>
<ul>
<li>临界资源（critical resource）</li>
<li>临界区（critical section&#x2F;region）</li>
</ul>
</li>
<li><p>临界区使用规则</p>
<ul>
<li>有空让进、无空等待、有限等待</li>
<li>多中择一、让权等待</li>
</ul>
</li>
<li><p>进程的同步</p>
<ul>
<li>某种时序关系</li>
</ul>
</li>
<li><p>实现进程互斥的方案</p>
<ul>
<li>软件解法：Dekker、Peterson</li>
<li>硬件解法：中断屏蔽方法、测试并加锁（TSL）</li>
</ul>
</li>
<li><p>生产者消费者问题（有界缓冲区）</p>
</li>
</ul>
<h4 id="信号量及-PV-操作"><a href="#信号量及-PV-操作" class="headerlink" title="信号量及 PV 操作"></a>信号量及 PV 操作</h4><ul>
<li>PV 操作是原语操作</li>
<li>信号量<ul>
<li>初始化（非负数），P 操作、V 操作</li>
</ul>
</li>
<li>生产者消费者问题（有界缓冲区）</li>
<li>读者写者问题<ul>
<li>读者优先</li>
</ul>
</li>
</ul>
<h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><ul>
<li>由关于<strong>共享资源的数据结构</strong>及<strong>在其上操作的一组过程</strong>组成</li>
<li>进程<strong>只能</strong>通过<strong>调用管程中的过程</strong>来<strong>间接访问</strong>管程中的数据结构</li>
<li>两个问题：同步、互斥</li>
</ul>
<h5 id="Hoare-管程"><a href="#Hoare-管程" class="headerlink" title="Hoare 管程"></a>Hoare 管程</h5><ul>
<li>管程中的两个进程，P 唤醒 Q：P 等待，Q 运行</li>
</ul>
<img src="Review-1/image-20210620204847938.png" style="zoom:67%;" />

<ul>
<li>条件变量：在管程内部说明和使用的一种特殊类型的变量<ul>
<li>var c:condition;</li>
<li>对于条件变量，可以执行 wait 和 signal 操作</li>
</ul>
</li>
<li>wait(c)<ul>
<li>如果紧急等待队列非空，则唤醒第一个等待者，否则释放管程的互斥权</li>
<li>执行此操作的进程进入c 链尾部</li>
</ul>
</li>
<li>signal(c)<ul>
<li>如果 c 链为空，则相当于空操作，执行此操作的进程继续执行</li>
<li>否则唤醒第一个等待者，执行此操作的进程进入紧急等待队列的尾部</li>
</ul>
</li>
</ul>
<h5 id="Mesa-管程"><a href="#Mesa-管程" class="headerlink" title="Mesa 管程"></a>Mesa 管程</h5><ul>
<li>signal $\to$ notify<ul>
<li>notify：当一个正在管程中的进程执行 notify(x) 时，它使得 x 条件队列得到通知，发信号的进程继续执行</li>
</ul>
</li>
<li>notify 的结果：位于条件队列头的进程在将来合适的时候且当处理器可用时恢复执行<ul>
<li>得用 while 再次判断条件</li>
</ul>
</li>
<li>超时则改为就绪（优化），但是还是得判断条件<ul>
<li>避免 notify 的程序炸掉导致无法被唤醒</li>
</ul>
</li>
<li>broadcast 原语：全唤醒成就绪</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/OS/CXQ/Review-1/" data-id="cl9lj74b400h164tzd282garl" data-title="操作系统复习.陈向群（03-05）（进程线程）" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OS/CXQ/Review" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/OS/CXQ/Review/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T04:09:07.000Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OS-CXQ/">OS.CXQ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/20/OS/CXQ/Review/">操作系统复习.陈向群（00-02）（概述、中断异常）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="操作系统复习（00-02）"><a href="#操作系统复习（00-02）" class="headerlink" title="操作系统复习（00-02）"></a>操作系统复习（00-02）</h1><h2 id="Chapter-00：课程简介"><a href="#Chapter-00：课程简介" class="headerlink" title="Chapter 00：课程简介"></a>Chapter 00：课程简介</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ul>
<li>执行一个可执行文件的时候，操作系统做了什么？</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hello world&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>两种观点<ul>
<li>用户程序：OS 功能调用、返回</li>
<li>进程调度：调度、返回</li>
</ul>
</li>
<li>操作系统的主要工作<ul>
<li>执行程序、个性（硬件相关）、共性、其他问题（性能、安全、健壮性等）</li>
</ul>
</li>
</ul>
<h2 id="Chapter-01：操作系统概述"><a href="#Chapter-01：操作系统概述" class="headerlink" title="Chapter 01：操作系统概述"></a>Chapter 01：操作系统概述</h2><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><ul>
<li>操作系统定义、并发性、共享性、虚拟性、随机性、SPOOLing、多道程序设计、OS&#x2F;360、MULTICS、典型操作系统</li>
</ul>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><ul>
<li>一个应用程序的执行流程是怎样的？ 涉及到哪些功能模块？</li>
<li>请问 Windows 操作系统中的设备驱动程序具体提 供了什么功能？有具体的例子吗？为什么说它不直接与硬件打交道？ 可不可以理解为设备驱动程序是建立在 HAL 之上的更高层的抽象，所以是通过HAL与硬件打交道 ？</li>
<li>课件上 “UNIX操作系统” <ul>
<li>文件子系统与块设备之间的 Buffer Cache 的作用是什么？</li>
<li>简要小结一下 Buffer Cache 的工作原理</li>
</ul>
</li>
<li>UNIX 的名字来历的猜测</li>
<li>SPOOLing 技术过时了吗？</li>
<li>传统的分时系统在今天有什么意义？</li>
</ul>
<h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><ul>
<li><p>Windows 架构、Unix 架构、Linux 架构、Android 架构</p>
</li>
<li><p>层次：应用程序、系统功能调用、操作系统、计算机硬件</p>
</li>
<li><p>操作系统是什么？</p>
<ul>
<li><p>系统软件</p>
<p>  软硬件资源管理（<strong>有效</strong>、<strong>合理</strong>）</p>
</li>
<li><p>程序执行控制，对外提供服务</p>
</li>
<li><p>用户<strong>方便</strong>使用</p>
</li>
<li><p>机器的<strong>扩展</strong></p>
</li>
</ul>
</li>
<li><p>设计与实现目标：抽象、模块化、性能、应用之间、隔离性、可靠性、节能、安全性、移动性</p>
</li>
<li><p>什么是操作系统（不同角度）？</p>
<ul>
<li>作为软件来看的观点</li>
<li>资源管理的观点</li>
<li>进程的观点</li>
<li>虚机器观点（<strong>分层结构</strong>）</li>
</ul>
</li>
<li><p>操作系统的特征：<strong>并发</strong>、<strong>共享</strong>、<strong>虚拟</strong>、<strong>随机</strong></p>
</li>
<li><p>操作系统发展史</p>
<ul>
<li>第1阶段 （1948 -1970 ）：硬件昂贵，人工便宜<ul>
<li>SPOOLing（假脱机）</li>
</ul>
</li>
<li>第2阶段 （1970 -1985 ）：硬件便宜，人工昂贵 <ul>
<li>第一个分时操作系统 CTSS</li>
</ul>
</li>
<li>第3阶段 （1981 -）：硬件非常便宜，人工昂贵</li>
<li>第4阶段 （1981 -）：分布式</li>
<li>第5阶段 （1995 -）：移动计算时代</li>
<li>第6阶段 （2006 -）：云计算时代</li>
<li>第7阶段 （200？ -）：泛在计算 &#x2F; 普适计算 &#x2F; 物联网</li>
</ul>
</li>
<li><p>操作系统分类</p>
<ul>
<li>批处理操作系统（多道）</li>
<li>分时系统</li>
<li>实时操作系统<ul>
<li>硬实时系统、软实时系统</li>
</ul>
</li>
<li>个人计算机操作系统 </li>
<li>网络操作系统</li>
<li>分布式操作系统</li>
<li>嵌入式操作系统</li>
</ul>
</li>
<li><p>操作系统的另一种分类（Tanenbaum）</p>
<ul>
<li>大型机操作系统</li>
<li>服务器操作系统</li>
<li>多处理机操作系统</li>
<li>个人计算机操作系统</li>
<li>实时操作系统</li>
<li>嵌入式操作系统</li>
<li>智能卡操作系统</li>
</ul>
</li>
</ul>
<h2 id="Chapter-02：运行环境和运行机制"><a href="#Chapter-02：运行环境和运行机制" class="headerlink" title="Chapter 02：运行环境和运行机制"></a>Chapter 02：运行环境和运行机制</h2><h3 id="关键词-1"><a href="#关键词-1" class="headerlink" title="关键词"></a>关键词</h3><ul>
<li>CPU 状态 (模式 )、特权指令、非特权指令、内核态&#x2F;用户态、管态&#x2F;目态、R0&#x2F;R3、中断与异常、中断向量表、中断描述符、系统调用、机制与策略</li>
</ul>
<h3 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h3><ul>
<li>怎样理解 ”操作系统是由中断&#x2F;异常&#x2F;事件驱动的” 这句话？</li>
<li>中断&#x2F;异常的来源有什么不同？ 处理方式是一样的吗？</li>
<li>中断&#x2F;异常机制中，哪些是硬件(体系结构)负责的？ 哪些是软件(操作系统)负责的？</li>
<li>从中断响应(硬件)到中断处理程序(软件)执行结束，计算机系统经过了哪些流程？</li>
<li>操作系统初始化与中断&#x2F;异常有哪些关联？</li>
<li>怎样理解应用程序是如何与操作系统交互的？</li>
<li>什么是软件异常？ 它是如何工作的？</li>
<li>X86 在 Peniuml1300 之后提供了 sysantcr&#x2F;sysexit 指令，为什么？与int0x80&#x2F;iret有什么不同？</li>
<li>关于基于 x86 体系结构的 Linux 的系统调用实现:<ul>
<li>系统调用入口程序 system_ call() 与中断描述符表是什么关系？与系统调用表是什么关系？</li>
<li>系统调用处理结束后，处理器转去执行哪个模块？</li>
</ul>
</li>
<li>系统调用与 C 函数调用的区别？</li>
</ul>
<h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><ul>
<li>CPU 与内存</li>
</ul>
<img src="Review/image-20210620130725590.png" style="zoom: 50%;" />

<ul>
<li>两类寄存器<ul>
<li>用户可见寄存器<ul>
<li>数据寄存器、地址寄存器、条件码寄存器</li>
</ul>
</li>
<li>控制和状态寄存器<ul>
<li>程序计数器（PC）、指令寄存器（IR）、程序状态字（PSW）</li>
</ul>
</li>
</ul>
</li>
<li>内核态与用户态</li>
<li>特权指令与非特权指令</li>
<li>x86 系列处理器<ul>
<li>R0 $\to$ R3：特权高 $\to$ 低</li>
</ul>
</li>
<li>CPU 状态之间的切换<ul>
<li>进入内核态：中断&#x2F;异常&#x2F;陷入机制</li>
<li>返回用户态：设置程序状态字 PSW</li>
</ul>
</li>
</ul>
<h4 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h4><ul>
<li>中断与异常的引入原因<ul>
<li>中断的引入：为了支持 CPU 和设备之间的并行操作</li>
<li>异常的引入：表示 CPU 执行指令时本身出现的问题</li>
</ul>
</li>
<li>中断与异常</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">原因</th>
<th align="center">异步&#x2F;同步</th>
<th align="center">返回行为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">中断<br/>Interrupt</td>
<td align="center">来自 I&#x2F;O 设备、其他硬件部件</td>
<td align="center">异步</td>
<td align="center">总是返回到下一条指令</td>
</tr>
<tr>
<td align="center">陷入<br/>Trap</td>
<td align="center">有意识安排的</td>
<td align="center">同步</td>
<td align="center">返回到下一条指令</td>
</tr>
<tr>
<td align="center">故障<br/>Fault</td>
<td align="center">可恢复的错误</td>
<td align="center">同步</td>
<td align="center">返回到当前指令</td>
</tr>
<tr>
<td align="center">终止<br/>Abort</td>
<td align="center">不可恢复的错误</td>
<td align="center">同步</td>
<td align="center">不会返回</td>
</tr>
</tbody></table>
<ul>
<li>中断&#x2F;异常机制工作原理<ul>
<li><strong>软硬件配合</strong></li>
</ul>
</li>
<li>中断响应（中断硬件部件完成）<ul>
<li>在每条指令执行周期的<strong>最后时刻</strong>扫描中断寄存器，查看是否有中断信号</li>
<li>若有中断，中断硬件将该中断触发器内容按规定编码送入 PSW 的相应位，称为中断码，通过交换<strong>中断向量</strong>引出中断处理程序</li>
</ul>
</li>
<li>中断向量与中断向量表</li>
</ul>
<img src="Review/image-20210620133337993.png" style="zoom:67%;" />

<ul>
<li>中断处理程序</li>
<li><strong>中断&#x2F;异常机制中软硬件分工</strong><ul>
<li>以设备 IO 中断为例</li>
</ul>
</li>
</ul>
<h5 id="IA32-体系结构对中断的支持"><a href="#IA32-体系结构对中断的支持" class="headerlink" title="IA32 体系结构对中断的支持"></a>IA32 体系结构对中断的支持</h5><ul>
<li>中断控制器</li>
<li>实模式（正常情况）：中断向量表</li>
<li>保护模式（刚启动）：中断描述符表</li>
<li>门描述符</li>
<li>IDTR 寄存器、GDTR 寄存器</li>
</ul>
<img src="Review/image-20210620135745915.png" style="zoom: 67%;" />

<ul>
<li>整个流程</li>
</ul>
<img src="Review/image-20210620140055338.png" style="zoom:67%;" />



<h4 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h4><ul>
<li>容量、速度、成本</li>
<li>寄存器、高速缓存、主存、磁盘</li>
<li>局部性原理</li>
</ul>
<h4 id="I-x2F-O-访问技术"><a href="#I-x2F-O-访问技术" class="headerlink" title="I&#x2F;O 访问技术"></a>I&#x2F;O 访问技术</h4><ul>
<li>程序控制方式<ul>
<li>I&#x2F;O 处理单元</li>
<li>CPU 定期<strong>轮询</strong> I&#x2F;O 单元的状态，直到处理完毕</li>
</ul>
</li>
<li>中断驱动方式<ul>
<li>每个数据需要传输时中断 CPU</li>
<li>I&#x2F;O 操作与指令并行</li>
</ul>
</li>
<li>直接存储器存取（DMA）方式<ul>
<li>一批数据需要传输时中断 CPU</li>
<li>DMA 控制</li>
</ul>
</li>
</ul>
<h4 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h4><ul>
<li>绝对时钟、相对时钟</li>
<li>硬件时钟、软件时钟</li>
</ul>
<h5 id="x86-体系结构的定时硬件"><a href="#x86-体系结构的定时硬件" class="headerlink" title="x86 体系结构的定时硬件"></a>x86 体系结构的定时硬件</h5><ul>
<li>4 种定时硬件<ul>
<li>实时时钟（RTC）</li>
<li>时间戳计数器（TSC）</li>
<li>可编程间隔定时器（PIT）</li>
<li>SMP系统中的本地APIC定时器</li>
</ul>
</li>
</ul>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><ul>
<li>系统调用、库函数、API、内核函数</li>
</ul>
<img src="Review/image-20210620144410952.png" style="zoom:67%;" />



<ul>
<li>系统调用机制的设计<ul>
<li>利用中断&#x2F;异常机制</li>
</ul>
</li>
<li>如何实现参数传递<ul>
<li>陷入指令自带参数</li>
<li><strong>通用寄存器</strong></li>
<li>专用堆栈区</li>
</ul>
</li>
</ul>
<h4 id="内核的进入与退出"><a href="#内核的进入与退出" class="headerlink" title="内核的进入与退出"></a>内核的进入与退出</h4><img src="Review/image-20210620150546175.png" style="zoom:67%;" />
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/OS/CXQ/Review/" data-id="cl9lj74b400h764tzh6oaa5p2" data-title="操作系统复习.陈向群（00-02）（概述、中断异常）" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OS/CXQ/00" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/OS/CXQ/00/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T03:00:07.000Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/0/">0</a>►<a class="article-category-link" href="/categories/OS-CXQ/">OS.CXQ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/20/OS/CXQ/00/">操作系统复习.陈向群.说明</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="操作系统复习"><a href="#操作系统复习" class="headerlink" title="操作系统复习"></a>操作系统复习</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>课程名称：操作系统</li>
<li>授课老师：陈向群</li>
<li>课程链接：<a target="_blank" rel="noopener" href="http://www.chinesemooc.org/mooc/4747">华文慕课</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/OS/CXQ/00/" data-id="cl9lj74b300gv64tzgb37cnw5" data-title="操作系统复习.陈向群.说明" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/Algorithm/SM-PCF-PCSS-VSM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/" class="article-date">
  <time class="dt-published" datetime="2021-06-18T04:12:13.000Z" itemprop="datePublished">2021-06-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-Algorithm/">CG.Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/">阴影算法的实现(SM、PCF、PCSS、VSM)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="阴影算法的实现"><a href="#阴影算法的实现" class="headerlink" title="阴影算法的实现"></a>阴影算法的实现</h1><ul>
<li>我们实现了从最经典的 Shadow Map 算法开始，实现了一系列的软阴影算法，包括 PCF、PCSS、VSM 三种软阴影算法</li>
<li>如下是我们的算法实现过程以及结果展示</li>
</ul>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>环境<ul>
<li>VS2017 <span style="color:red;font-weight:bold">x86</span></li>
<li>OpenGL 4.6（版本设置成了 3.3，之后的都行）</li>
</ul>
</li>
<li>依赖库<ul>
<li>glad 0.1.34</li>
<li>glfw 3.3</li>
<li>glm 0.9.9.8</li>
</ul>
</li>
<li>代码<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/banbao990/OpenGL/tree/main/Demo/Codes/project/SM-PCF-PCSS-VSM">Github</a>，需要按照 <a target="_blank" rel="noopener" href="https://github.com/banbao990/OpenGL/blob/main/README.md">README</a> 配置</li>
<li><a href="/resources/CG/Algorithm/SM-PCF-PCSS-VSM/SM-PCF-PCSS-VSM.zip">打包好的源代码</a></li>
<li><a href="/resources/CG/Algorithm/SM-PCF-PCSS-VSM/VSM.pptx">PPT 报告</a></li>
</ul>
</li>
</ul>
<h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><h3 id="SM"><a href="#SM" class="headerlink" title="SM"></a>SM</h3><ul>
<li>Shadow Mapping</li>
<li>传统的 two-pass 阴影算法<ul>
<li>第一个 pass，切换到以光源为视点的观察坐标系中，利用帧缓冲生成一张深度图 DepthMap</li>
<li>第二个 pass，正常渲染，对渲染的每一个 fragment 做可见性判断，得到一个<strong>非零即一</strong>的 visibility<ul>
<li>将 shading point 通过第一个 pass 的变换得到的深度值和 DepthMap 中记录的对应位置的深度值作比较</li>
<li>如果 DepthMap 中记录的值小，说明当前的点对光源不可见，visibility&#x3D;0</li>
<li>否则 visibility&#x3D;1</li>
<li>用 visibility 乘上当前点的直接光照，进行遮蔽效果</li>
</ul>
</li>
</ul>
</li>
<li>在实现上可以使用定向光做平行投影生成 DepthMap，也可以使用点光源做透视投影生成 DepthMap</li>
</ul>
<h3 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h3><ul>
<li>Percentage Closer Filter</li>
<li>由于 SM 得到的阴影结果是非零即一的值，这样子我们得到的边界就是一个很生硬的过渡（硬阴影），而实际生活中我们看到的阴影是有一个比较平滑的过渡（软阴影），这是由于我们定向光和点光源的假设在生活中是不成立的。生活中的光源是占据一块区域的，而不是只有一个点</li>
<li>为了模拟这种软阴影的效果，我们在 SM 第二个 pass 的时候做如下处理<ul>
<li>对于每一个 shading point，我们将其变换到以光源为视点的观察坐标系中的深度值和它对应的周围的 N 个点进行深度比较，求出一个 visibility 值</li>
<li>$\mathrm{visibility}&#x3D;\dfrac{深度比当前点深度值大的采样点数目}{\mathrm{N}}$</li>
<li>这样子我们得到的 visibility 的值就不是简单的非零即一的值，于是在边界产生过渡的效果</li>
</ul>
</li>
<li>上面的周围我们一般是给定半径 R，在半径为 R 的圆形区域内采样</li>
</ul>
<h3 id="PCSS"><a href="#PCSS" class="headerlink" title="PCSS"></a>PCSS</h3><ul>
<li>Percentage Closer Soft Shadow</li>
<li>我们在生活中还观察到另外一种现象，物体越靠近投射出阴影的平面，阴影越偏向于硬边界，物体越远离投射出阴影的平面的时候，阴影越偏向于软边界</li>
<li>如下图中，笔尖部分的阴影更硬，远离笔尖部分的阴影更软</li>
</ul>
<img src="SM-PCF-PCSS-VSM/image-20210407175007126.png" style="zoom:50%;" />

<ul>
<li>这原因很简单，物体离成阴影平面越近，阴影过渡区域（半影）越小</li>
<li>下图中<ul>
<li>红色区域表示半影区域</li>
<li>黄色部分表示全影区域</li>
<li>显然在阴影平面 1 上半影区域比阴影平面 2 更小</li>
</ul>
</li>
</ul>
<img src="SM-PCF-PCSS-VSM/image-20210618203106841.png" style="zoom: 67%;" />

<ul>
<li>我们加一条蓝色的辅助线，我们发现阴影平面1上半影区域占全影区域的比例也更小</li>
</ul>
<img src="SM-PCF-PCSS-VSM/image-20210618203601043.png" style="zoom: 67%;" />

<ul>
<li>也就是说我们要通过物体到阴影平面的距离来决定阴影的软硬程度，也就是采样半径 R 的大小</li>
<li>我们从上图中也了解到，半影区域也就是阴影过渡的区域，因此我们可以通过半影的大小估计采样半径 R</li>
<li><span id="anchor2">估计方式</span>如下图所示</li>
</ul>
<p>$$<br>w_{penumbra}&#x3D;\dfrac{d_{Receiver}-d_{Blocker}}{d_{Blocker}}\cdot w_{Light}<br>$$</p>
<img src="SM-PCF-PCSS-VSM/image-20210407175256445.png" style="zoom: 33%;" />

<ul>
<li>但是同时这里出现了另外一个问题，$d_{Blocker}$ 的计算问题，可以通过给定固定范围的计算得到，或者<span id="anchor1">启发式的计算</span>得到</li>
</ul>
<img src="SM-PCF-PCSS-VSM/image-20210407181810295.png" style="zoom: 33%;" />



<h3 id="VSM"><a href="#VSM" class="headerlink" title="VSM"></a>VSM</h3><ul>
<li>Variance Shadow Mapping</li>
<li>VSM 算法试图使用计算的方式避免采样，因为采样是一个很慢的过程</li>
<li>我们对 shading point 周围的点进行深度的采样，计算得到的 visibility 本质上就是在估计周围有百分之多少的点深度值比当前点大，也就是说如果我们能够获取到这个百分比，就不需要采样了</li>
<li>切比雪夫不等式可以实现这一点</li>
</ul>
<p>$$<br>P(x&gt;t)\le\dfrac{\sigma^2}{\sigma^2+(t-\mu)^2}<br>$$</p>
<ul>
<li>切比雪夫不等式的条件是 $t&gt;\mu$ 以及分布是一个单峰的分布</li>
<li>给定一个深度值 t，我们可以通过其周围的深度均值与方差估计出当前点深度的排名</li>
<li>当然实时渲染中我们不等式直接当等式使用</li>
</ul>
<h2 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h2><ul>
<li>我们的场景比较简单<ul>
<li>一个点光源</li>
<li>一个跳动的小球和一排方柱子</li>
</ul>
</li>
</ul>
<img src="SM-PCF-PCSS-VSM/2021.06.18-21.00.50.30.png" style="zoom:67%;" />



<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="着色模型"><a href="#着色模型" class="headerlink" title="着色模型"></a>着色模型</h3><ul>
<li>使用 Blinn-Phong 着色模型，由 diffuse + specular + ambient 三部分组成</li>
<li>shader 主要代码如下</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// 环境光 ambient</span></span><br><span class="line">    <span class="type">vec3</span> ambient = <span class="number">0.2</span> * color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 漫发射光 diffuse</span></span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">vec3</span> normal = <span class="built_in">normalize</span>(fs_in.Normal);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">vec3</span> diffuse = diff * color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 镜面高光 specular</span></span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Blinn-Phong 模型考虑法线和半角矢量的夹角</span></span><br><span class="line">    <span class="type">vec3</span> halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line">    spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">32.0</span>);</span><br><span class="line">    <span class="type">vec3</span> specular = <span class="type">vec3</span>(<span class="number">0.3</span>) * spec;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> visibility = <span class="number">1.0</span>f;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阴影算法</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    FragColor = <span class="type">vec4</span>(</span><br><span class="line">        ambient + visibility*(diffuse + specular), </span><br><span class="line">        <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>没有阴影的效果如下，缺乏真实感</li>
</ul>
<img src="SM-PCF-PCSS-VSM/2021.06.18-21.06.28.17.png"  style="zoom:67%;" />



<h3 id="SM-1"><a href="#SM-1" class="headerlink" title="SM"></a>SM</h3><ul>
<li>第一趟利用 OpenGL 的帧缓冲生成一张 DepthMap</li>
<li>第二趟比较即可</li>
<li>shader 代码如下<ul>
<li>注意这里的 DepthMap 中虽然你保存的是透视投影的深度，但是我们不需要变换成线性深度，因为只需要知道相对大小即可</li>
</ul>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处于阴影之中: 0.0</span></span><br><span class="line"><span class="comment">// 否则返回 1.0</span></span><br><span class="line"><span class="type">float</span> ShadowCalculation(<span class="type">vec4</span> fragPosLightSpace) &#123;</span><br><span class="line">    <span class="comment">// 转化为标准齐次坐标, z:[-1, 1]</span></span><br><span class="line">    <span class="type">vec3</span> projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    <span class="comment">// xyz:[-1, 1] =&gt; [0,1]</span></span><br><span class="line">    projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 在深度图中获取深度信息</span></span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, projCoords.xy).r;</span><br><span class="line">    <span class="comment">// 当前片元的深度</span></span><br><span class="line">    <span class="type">float</span> currentDepth = projCoords.z;</span><br><span class="line">    <span class="comment">// 判断是否处于阴影当中</span></span><br><span class="line">    <span class="type">float</span> shadow = currentDepth-BIAS &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> - shadow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    visibility = ShadowCalculation(fs_in.FragPosLightSpace);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>效果如下，是我们想象中的硬阴影</li>
</ul>
<img src="SM-PCF-PCSS-VSM/2021.06.18-21.06.30.75.png" style="zoom:67%;" />

<ul>
<li>注意上面的 BIAS 是为了解决自遮挡现象（黑白条纹）<ul>
<li>由于 Z-Buffer 分辨率有限导致的</li>
<li>下图形象说明了这点，蓝色的点竟然不可见了</li>
</ul>
</li>
</ul>
<img src="SM-PCF-PCSS-VSM/image-20210407160246926.png" style="zoom: 67%;" />

<ul>
<li>不加 BIAS 的效果</li>
</ul>
<img src="SM-PCF-PCSS-VSM/2021.06.18-21.10.09.72.png" style="zoom:67%;" />



<h3 id="PCF-1"><a href="#PCF-1" class="headerlink" title="PCF"></a>PCF</h3><ul>
<li>PCF 的实现和 SM 类似，只需要对周围点多采样几个即可，我们直接对周围 R $\times$ R 的点进行一个遍历</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PCF 算法</span></span><br><span class="line"><span class="type">float</span> PCF(<span class="type">vec4</span> fragPosLightSpace, <span class="type">float</span> radius) &#123;</span><br><span class="line">    <span class="comment">// 采样距离修正</span></span><br><span class="line">    radius *= PCF_SampleRadius;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">float</span> currentDepth = projCoords.z;</span><br><span class="line">    <span class="type">vec2</span> texelSize = <span class="number">1.0</span> / <span class="built_in">textureSize</span>(depthMap, <span class="number">0</span>); <span class="comment">// 0 级纹理相邻纹素的距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = -PCF_RADIUS; x &lt;= PCF_RADIUS; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y = -PCF_RADIUS; y &lt;= PCF_RADIUS; ++y) &#123;</span><br><span class="line">            <span class="type">float</span> shadowMapDepth = <span class="built_in">texture</span>(depthMap, projCoords.xy + radius*<span class="type">vec2</span>(x, y) * texelSize).r;</span><br><span class="line">            shadow += currentDepth-BIAS &gt; shadowMapDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">float</span> total = (<span class="number">2</span>*PCF_RADIUS+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> - shadow/(total*total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    visibility = PCF(fs_in.FragPosLightSpace, <span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>PCF_SampleRadius 修正是服务于 PCSS 的，试图让阴影扩散<ul>
<li>因为我们不想让采样数过多，但是又需要考虑一个相对比较大的半径时，增大采样间隔</li>
</ul>
</li>
<li>效果如下，阴影变成了软阴影，但是所有阴影的边界模糊程度是相似的</li>
</ul>
<img src="SM-PCF-PCSS-VSM/2021.06.18-21.06.33.02.png" style="zoom:67%;" />





<h3 id="PCSS-1"><a href="#PCSS-1" class="headerlink" title="PCSS"></a>PCSS</h3><ul>
<li>PCSS 分为 3 个步骤<ul>
<li>Step 1: Blocker search<ul>
<li>在某个区域内计算平均遮挡深度</li>
</ul>
</li>
<li>Step 2: Penumbra estimation<ul>
<li>通过计算出来的平均遮挡深度来计算半影的大小</li>
</ul>
</li>
<li>Step 3: Percentage Closer Filtering<ul>
<li>根据 Step 2 计算出来的大小进行 PCF</li>
</ul>
</li>
</ul>
</li>
<li>主体思路如下，由于我们需要进行深度的平均计算，这里必须使用<strong>线性深度</strong></li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> PCSS(<span class="type">vec4</span> fragPosLightSpace)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// depthMap 中的坐标</span></span><br><span class="line">    <span class="comment">// =&gt; [-1, 1]</span></span><br><span class="line">    <span class="type">vec3</span> projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    <span class="comment">// 转换为线性深度</span></span><br><span class="line">    <span class="type">float</span> depth = getLinearizeDepth(projCoords.z);</span><br><span class="line">    <span class="comment">// [-1, 1] =&gt; [0, 1]</span></span><br><span class="line">    projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// STEP 1: avgblocker depth</span></span><br><span class="line">    <span class="type">float</span> avgDepth = findBlocker(projCoords.xy, depth);</span><br><span class="line">    <span class="comment">// 没有遮挡物</span></span><br><span class="line">    <span class="keyword">if</span>(avgDepth == <span class="number">-1.0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// STEP 2: penumbra size</span></span><br><span class="line">    <span class="type">float</span> penumbra = (depth - avgDepth) / avgDepth * lightWidth;</span><br><span class="line">    <span class="type">float</span> filterRadius = penumbra * NEAR_PLANE / (depth);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// STEP 3: filtering</span></span><br><span class="line">    <span class="keyword">return</span> PCF(fs_in.FragPosLightSpace, filterRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    visibility = PCSS(fs_in.FragPosLightSpace);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一步我们根据上面提到的<a href="#anchor1">启发式估计方法</a>计算得到<ul>
<li>这里的弥散参数修正是用于控制软阴影的边界，如果小了会被原来硬阴影的边界限制住（外面的都是可见）</li>
</ul>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* uv: depthMap 中的坐标</span></span><br><span class="line"><span class="comment">* zRecerver: 计算得到的线性深度值 [0, 1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">float</span> findBlocker(<span class="type">vec2</span> uv, <span class="type">float</span> zReceiver) &#123;</span><br><span class="line">    <span class="type">int</span> blockers = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> ret = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">float</span> r = lightWidth * (zReceiver - NEAR_PLANE/FAR_PLANE) / zReceiver;</span><br><span class="line">    <span class="comment">// 弥散参数修正</span></span><br><span class="line">    r *= SMDiffuse;</span><br><span class="line">    <span class="type">vec2</span> texelSize = <span class="number">1.0</span> / <span class="built_in">textureSize</span>(depthMap, <span class="number">0</span>); <span class="comment">// 0 级纹理相邻纹素的距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = -BLOCK_RADIUS; x &lt;= BLOCK_RADIUS; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y = -BLOCK_RADIUS; y &lt;= BLOCK_RADIUS; ++y) &#123;</span><br><span class="line">            <span class="comment">// [0, 1]</span></span><br><span class="line">            <span class="type">float</span> shadowMapDepth = <span class="built_in">texture</span>(depthMap, uv + r*<span class="type">vec2</span>(x, y) * texelSize).r;</span><br><span class="line">            <span class="comment">// [0, 1] =&gt; [-1, 1]</span></span><br><span class="line">            shadowMapDepth = getLinearizeDepth(shadowMapDepth * <span class="number">2.0</span> - <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">if</span>(zReceiver - BIAS &gt; shadowMapDepth) &#123;</span><br><span class="line">                ret += shadowMapDepth;</span><br><span class="line">                ++blockers;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有 blocker</span></span><br><span class="line">    <span class="keyword">if</span>(blockers == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret/blockers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当第一步找到的平均遮挡物深度为 0 的时候，我们认为当前点可见，返回 visibility&#x3D;1</li>
<li>第二步根据上面的<a href="#anchor">相似三角形</a>计算出 PCF 的采样半径即可</li>
<li>第三步就是 PCF</li>
<li>效果如下，明显看到软阴影和硬阴影的结果都有</li>
</ul>
<img src="SM-PCF-PCSS-VSM/2021.06.18-21.06.34.97.png" style="zoom:67%;" />





<h3 id="VSM-1"><a href="#VSM-1" class="headerlink" title="VSM"></a>VSM</h3><ul>
<li>我们需要生成两张图记录当前点对应点周围区域内的方差和均值</li>
<li>我们知道 $\mathrm{var&#x3D;E(X^2)-E^2X}$，因此我们只需要记录两张图，分别记录当前点周围区域的 $\mathrm{EX,EX^2}$ 即可</li>
<li>第一个 pass 我们使用帧缓冲生成一张颜色缓冲，R 通道记录深度值 $\mathrm{d}$，G 通道记录 $\mathrm{d^2}$</li>
<li>然后我们需要生成一张周围点的均值和方差<ul>
<li>利用两趟 pass 对周围的周围的点求平均值实现</li>
<li>两趟 pass 可以把每一个点的复杂度从 $(2R+1)^2$ 降到 $(4R+2)$</li>
</ul>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define R 5</span></span><br><span class="line"><span class="meta">#define R21 11</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> d = <span class="type">vec2</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">vec2</span> texelSize = <span class="number">1.0</span> / <span class="built_in">textureSize</span>(d_d2, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(vertical) &#123;</span><br><span class="line">        <span class="type">float</span> r = texelSize.y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = -R; i &lt;= R; ++i) &#123;</span><br><span class="line">            d += <span class="built_in">texture</span>(d_d2, <span class="type">vec2</span>(TexCoords.x, TexCoords.y + i*r)).rg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">float</span> r = texelSize.x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = -R; i &lt;= R; ++i) &#123;</span><br><span class="line">            d += <span class="built_in">texture</span>(d_d2, <span class="type">vec2</span>(TexCoords.x + i*r, TexCoords.y)).rg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FragColor.rg = d/R21;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最后一个 pass 的可见性估计如下<ul>
<li>注意这里如果不满足切比雪夫不等式的条件的话，直接返回可见即可（深度值比平均深度小）</li>
</ul>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VSM 算法</span></span><br><span class="line"><span class="type">float</span> VSM(<span class="type">vec4</span> fragPosLightSpace) &#123;</span><br><span class="line">    <span class="type">vec3</span> projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    <span class="comment">// 转换为线性深度</span></span><br><span class="line">    <span class="type">float</span> depth = getLinearizeDepth(projCoords.z);</span><br><span class="line">    <span class="comment">// [-1, 1] =&gt; [0, 1]</span></span><br><span class="line">    projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec2</span> d_d2 = <span class="built_in">texture</span>(d_d2_filter, projCoords.xy).rg;</span><br><span class="line">    <span class="type">float</span> var = d_d2.y - d_d2.x * d_d2.x; <span class="comment">// E(X-EX)^2 = EX^2-E^2X</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不满足不等式, 直接可见</span></span><br><span class="line">    <span class="keyword">if</span>(depth - BIAS &lt; d_d2.x)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">float</span> t_minus_mu = depth - d_d2.x;</span><br><span class="line">        <span class="keyword">return</span> var/(var + t_minus_mu*t_minus_mu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    visibility = VSM(fs_in.FragPosLightSpace);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>效果如下，很好的软硬阴影结果，和 PCSS 的区别是，柱子的底部阴影更小了</li>
</ul>
<img src="SM-PCF-PCSS-VSM/2021.06.18-21.06.37.04.png" style="zoom:67%;" />

<ul>
<li>VSM 存在一个很大的问题，漏光，当不满足单峰的长尾分布时，估计不准确<ul>
<li>球的阴影漏光了</li>
</ul>
</li>
</ul>
<img src="SM-PCF-PCSS-VSM/2021.06.18-21.52.38.86.png" style="zoom:67%;" />





<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>小球运动的实现<ul>
<li>利用物理公式计算出来位置即可</li>
</ul>
</li>
<li>小球的实现，类似于经纬度，切分成三角形<ul>
<li>注意外面看进去得都是逆时针（OpenGL 逆时针为正向面）</li>
</ul>
</li>
</ul>
<h2 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h2><ul>
<li>include 文件夹<ul>
<li>一些依赖头文件</li>
<li>myUtils&#x2F;basicModel.h：渲染一些基本模型</li>
</ul>
</li>
<li>lib 文件夹<ul>
<li>库文件</li>
</ul>
</li>
<li>shaders 文件夹<ul>
<li>gen_SM.vert, genSM_perspective.frag：pass 1 生成 DepthMap（$d, d^2$）</li>
<li>light.vert, light.frag：pass 2 渲染光源</li>
<li>BlinnPhong.vert, BlinnPhong_perspective.frag：pass 2 渲染场景</li>
<li>gen_d_d2.vert, gen_d_d2.frag：生成均值（$d, d^2$）</li>
</ul>
</li>
<li>Demo.exe<ul>
<li>可执行文件</li>
</ul>
</li>
</ul>
<h3 id="执行文件"><a href="#执行文件" class="headerlink" title="执行文件"></a>执行文件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo.exe</span><br></pre></td></tr></table></figure>

<ul>
<li>功能如下<ul>
<li>W&#x2F;A&#x2F;S&#x2F;D 和鼠标：切换视角</li>
<li>空格：可以让小球开始&#x2F;停止运动</li>
<li>P&#x2F;L： 增大&#x2F;减小光源宽度（影响PCSS）</li>
<li>O&#x2F;K：增大&#x2F;减小平均深度的寻找半径，限制 PCSS 的阴影范围</li>
<li>I&#x2F;J：增大&#x2F;减小 PCF 采样半径，阴影弥散参数（影响 PCF、PCSS）</li>
<li>0&#x2F;1&#x2F;2&#x2F;3&#x2F;4：选择阴影种类<ul>
<li>0(No Shadow), 1(Shadow Map), 2(PCF), 3(PCSS), 4(VSM)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/">LearnOpenGL 框架性代码</a></li>
<li>GAMES202 课程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY?p=3">PCSS</a>、<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY?p=4">PCSS&#x2F;VSM</a></li>
<li><a target="_blank" rel="noopener" href="http://developer.download.nvidia.com/whitepapers/2007/SDK10/VarianceShadowMapping.pdf">Nvidia VSM 白皮书</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mrdoob/three.js/blob/master/examples/webgl_shadowmap_pcss.html">PCSS 的平行投影实现</a></li>
<li>论文：<a target="_blank" rel="noopener" href="https://software.intel.com/content/dam/develop/external/us/en/documents/vsm-paper-182629.pdf">Variance Shadow Maps</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/" data-id="cl9lj748u002i64tz6iosbnxo" data-title="阴影算法的实现(SM、PCF、PCSS、VSM)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG-Algorithm/" rel="tag">CG-Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Shadow/" rel="tag">Shadow</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Code/code" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/16/Code/code/" class="article-date">
  <time class="dt-published" datetime="2021-06-16T10:20:43.000Z" itemprop="datePublished">2021-06-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Code/">Code</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/16/Code/code/">代码练习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul>
<li><a target="_blank" rel="noopener" href="http://ica.openjudge.cn/string/5/">单词排序</a></li>
<li><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/4133">垃圾炸弹</a></li>
<li><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/1664">放苹果</a></li>
<li><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/1979">Red and Black</a></li>
<li><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/4119">复杂的整数划分问题</a></li>
<li><a target="_blank" rel="noopener" href="http://dsalgo.openjudge.cn/graph/1/">兔子与樱花</a></li>
<li><a target="_blank" rel="noopener" href="http://dsalgo.openjudge.cn/binarytree/7/">表达式·表达式树·表达式求值</a></li>
<li><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/1986">Distance Queries</a></li>
</ul>
<h2 id="单词排序"><a href="#单词排序" class="headerlink" title="单词排序"></a>单词排序</h2><ul>
<li><a href="/utils/show_code/index.html?OJ/code/1.cpp">代码</a></li>
<li>简单的排序题，同时可以学习下 STL 中的如下函数<ul>
<li><code>iterator unique(iterator it_1,iterator it_2);</code><ul>
<li>返回去重后的最后一个元素的下一个元素</li>
<li>调用前需要先排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="垃圾炸弹"><a href="#垃圾炸弹" class="headerlink" title="垃圾炸弹"></a>垃圾炸弹</h2><ul>
<li><a href="/utils/show_code/index.html?OJ/code/2.cpp">代码</a></li>
<li>暴力枚举所有点即可</li>
</ul>
<h2 id="放苹果"><a href="#放苹果" class="headerlink" title="放苹果"></a>放苹果</h2><ul>
<li><a href="/utils/show_code/index.html?OJ/code/3.cpp">代码</a></li>
<li>简单递归</li>
<li>记忆化搜索<ul>
<li>分类：有盘子不放，所有盘子都放</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apple(m, k) = apple(m - k, k) + apple(m, k - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>






<h2 id="Red-and-Black"><a href="#Red-and-Black" class="headerlink" title="Red and Black"></a>Red and Black</h2><ul>
<li><a href="/utils/show_code/index.html?OJ/code/4.cpp">代码</a></li>
<li>深搜</li>
<li>找到起始点相邻的所有黑色格子</li>
<li>输入输出格式比较麻烦</li>
</ul>
<h2 id="复杂的整数划分问题"><a href="#复杂的整数划分问题" class="headerlink" title="复杂的整数划分问题"></a>复杂的整数划分问题</h2><ul>
<li><a href="/utils/show_code/index.html?OJ/code/5.cpp">代码</a></li>
<li>动态规划<ul>
<li>逐个尝试，状态转移的时候添加一维，表示当前拆分最小的数为 <code>min_val</code></li>
</ul>
</li>
<li>注意一些细节，详情见代码</li>
<li>输入有多组，注意复用</li>
<li>记忆化</li>
</ul>
<h2 id="兔子与樱花"><a href="#兔子与樱花" class="headerlink" title="兔子与樱花"></a>兔子与樱花</h2><ul>
<li><a href="/utils/show_code/index.html?OJ/code/6.cpp">代码</a></li>
<li>Floyd 最短路</li>
</ul>
<h2 id="表达式·表达式树·表达式求值"><a href="#表达式·表达式树·表达式求值" class="headerlink" title="表达式·表达式树·表达式求值"></a>表达式·表达式树·表达式求值</h2><ul>
<li><a href="/utils/show_code/index.html?OJ/code/7.cpp">代码</a></li>
<li>输出格式比较麻烦<ul>
<li>计算</li>
</ul>
</li>
<li>中缀转后缀<ul>
<li>准备一个栈</li>
<li>遇到操作数，直接输出</li>
<li>遇到左括号，将左括号压栈</li>
<li>遇到右括号，弹栈输出，直到遇到左括号停止<ul>
<li>遇不到左括号则输入序列有问题</li>
</ul>
</li>
<li>遇到操作符，重复如下操作，直至条件不成立，最后将当前操作符压栈<ul>
<li>同时满足：栈非空、栈顶不为左括号、栈顶操作符优先级小于等于当前操作符</li>
</ul>
</li>
<li>最后弹空栈输出</li>
</ul>
</li>
</ul>
<h2 id="Distance-Queries"><a href="#Distance-Queries" class="headerlink" title="Distance Queries"></a>Distance Queries</h2><ul>
<li>Floyd 算法 $O(N^3)$，TLE</li>
<li><a href="/utils/show_code/index.html?OJ/code/8.cpp">代码</a></li>
<li>一些条件<ul>
<li>无向无环图<ul>
<li>No two roads cross, and precisely one path.</li>
</ul>
</li>
<li>连通图<ul>
<li>precisely one path (sequence of roads) links every pair of farms.</li>
</ul>
</li>
</ul>
</li>
<li>构建一棵树<ul>
<li>dist[x] 记录 x 结点到根的距离</li>
<li>如果两个结点 $a,b$ 的存在<strong>最近公共祖先</strong>  $c$<ul>
<li>结果为 $\mathrm{dist[a]+dist[b]-2\times dist[c]}$</li>
</ul>
</li>
<li>利用并查集优化判断是否在同一棵树中，或者增加一个虚拟结点</li>
</ul>
</li>
<li>基本思路<ul>
<li>深度大的点先找他的父结点，直到两个结点的深度一样</li>
<li>然后一起向上找父结点，直到找到相同的父结点</li>
</ul>
</li>
<li>lca：Least Common Ancestors</li>
</ul>
<h3 id="倍增法"><a href="#倍增法" class="headerlink" title="倍增法"></a>倍增法</h3><ul>
<li>倍增法求最近公共祖先</li>
<li>第一步，先让 x，y 跳到相同深度（不妨假设 x 深度更大）<ul>
<li>x 与 y 的深度差可以表示为若干 2 的幂次的和，每次跳跃  $2^i$ 个点，复杂度 $\log(x-y)&#x3D;O(\log N)$</li>
<li>这个差可以显式获取到</li>
</ul>
</li>
<li>第二步，要么是同一个点，要么一起往上跳<ul>
<li>同样的思路，lca(x, y) 与现在的深度差可以也可以可以表示为若干 2 的幂次的和，复杂度 $O(\log N)$</li>
<li>这个差不能显示获取到，但是可以通过深度比较试出来</li>
</ul>
</li>
<li>具体实现见代码</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/16/Code/code/" data-id="cl9lj748f000l64tzef2w820i" data-title="代码练习" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Code/" rel="tag">Code</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DP/" rel="tag">DP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Floyd/" rel="tag">Floyd</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LCA/" rel="tag">LCA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tree/" rel="tag">tree</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="tag">最短路</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/CLJ/09-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/13/DB/CLJ/09-1/" class="article-date">
  <time class="dt-published" datetime="2021-06-13T14:57:18.000Z" itemprop="datePublished">2021-06-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/13/DB/CLJ/09-1/">数据库概论.陈立军.09.恢复控制(2)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="恢复控制"><a href="#恢复控制" class="headerlink" title="恢复控制"></a>恢复控制</h1><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><h3 id="事务故障恢复"><a href="#事务故障恢复" class="headerlink" title="事务故障恢复"></a>事务故障恢复</h3><ul>
<li>撤消事务已对数据库所做的修改</li>
</ul>
<h3 id="事务故障恢复过程"><a href="#事务故障恢复过程" class="headerlink" title="事务故障恢复过程"></a>事务故障恢复过程</h3><ul>
<li><strong>反向</strong>扫描日志文件，查找该事务的更新操作</li>
<li>对该事务的更新操作执行 undo 操作，即将事务更新前的<strong>旧值</strong>写入数据库</li>
<li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理</li>
<li>直至读到事务的开始标识，结束事务故障恢复过程</li>
<li><strong>同一事务的日志需要反向链接在一起</strong><ul>
<li>加速事务的撤销操作</li>
</ul>
</li>
<li>正向撤销会出错<ul>
<li>这是显然的，撤销是写的逆过程</li>
</ul>
</li>
</ul>
<img src="09-1/image-20210613231700809.png" style="zoom:67%;" />



<h3 id="山寨版系统故障恢复"><a href="#山寨版系统故障恢复" class="headerlink" title="山寨版系统故障恢复"></a>山寨版系统故障恢复</h3><ul>
<li>不一致状态原因<ul>
<li>未完成事务对数据库的更新已写入数据库<ul>
<li>Steal policy</li>
</ul>
</li>
<li>已提交事务对数据库的更新未写入数据库<ul>
<li>还在 OS Buffer 中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="系统故障恢复过程"><a href="#系统故障恢复过程" class="headerlink" title="系统故障恢复过程"></a>系统故障恢复过程</h4><ul>
<li>正向扫描日志文件，找出圆满事务，记入重做队列；找出夭折事务，记入撤消队列</li>
<li>反向扫描日志，对撤消队列中事务 Ti 的每一个日志记录执行 undo 操作</li>
<li>正向扫描日志文件，对重做队列中事务 Ti 的每一个日志记录执行 redo 操作</li>
</ul>
<img src="09-1/image-20210613233141824.png" style="zoom:67%;" />



<h5 id="实际数据库"><a href="#实际数据库" class="headerlink" title="实际数据库"></a>实际数据库</h5><ul>
<li>对所有操作（不区分成功还是失败），都进行 redo 操作<ul>
<li>连续操作，磁盘 I&#x2F;O 友好</li>
</ul>
</li>
<li>然后再对夭折事务进行 undo</li>
</ul>
<h3 id="介质故障恢复"><a href="#介质故障恢复" class="headerlink" title="介质故障恢复"></a>介质故障恢复</h3><ul>
<li>磁盘上数据文件和日志文件遭到破坏</li>
</ul>
<h4 id="介质故障恢复过程"><a href="#介质故障恢复过程" class="headerlink" title="介质故障恢复过程"></a>介质故障恢复过程</h4><ul>
<li>装入最新的数据库后备副本，使数据库恢复到最近一次转储时的一致性状态</li>
<li>装入相应的日志文件副本，重做已完成的事务</li>
</ul>
<img src="09-1/image-20210613233249680.png" style="zoom: 67%;" />

<ul>
<li>数据文件和日志文件最好不要放在一个磁盘上</li>
</ul>
<h3 id="检查点-Checkpoint"><a href="#检查点-Checkpoint" class="headerlink" title="检查点(Checkpoint)"></a>检查点(Checkpoint)</h3><ul>
<li>当系统故障发生时，我们必须搜索整个日志，以决定哪些事务需要 redo，哪些需要 undo</li>
<li>大多数需要被重做的事务其更新已经写入了数据库中（$\mathrm{redo}^2$）<ul>
<li>因为我们不知道数据是否已经被写入磁盘（异步写缓冲区）</li>
<li>尽管对它们重做不会造成不良后果，但会使恢复过程变得更长</li>
</ul>
</li>
<li>检查点原理：且行且珍惜<ul>
<li><strong>保证在检查点时刻，日志与数据库的内容是一致的</strong></li>
</ul>
</li>
</ul>
<h4 id="带有检查点记录的日志生成"><a href="#带有检查点记录的日志生成" class="headerlink" title="带有检查点记录的日志生成"></a>带有检查点记录的日志生成</h4><ul>
<li>将当前日志缓冲区的所有日志记录写入稳存中</li>
<li>在日志文件中写入一个检查点记录</li>
<li>将当前数据缓冲区的所有数据记录写入稳存中</li>
<li>输出检查点时活跃事务的列表 L</li>
</ul>
<img src="09-1/image-20210613233943188.png" style="zoom: 67%;" />

<ul>
<li>我们对检查点之前就已经提交的事务，不需要做 redo 处理</li>
<li>只需要对检查点时刻还在活跃的事务、检查点之后出现的事务进行 redo 处理</li>
<li>最小日志序列号<ul>
<li>生成检查点时刻的还在活跃的最小日志记录的序列号</li>
</ul>
</li>
<li>长事务再数据库中危害很大<ul>
<li>并发</li>
<li>长事务不释放，检查点做的恢复工作不会少<ul>
<li>最小序列号之后、但是在检查点之前已经提交的事务需要重做吗？</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="SQL-Server：最小恢复LSN"><a href="#SQL-Server：最小恢复LSN" class="headerlink" title="SQL Server：最小恢复LSN"></a>SQL Server：最小恢复LSN</h4><ul>
<li>MinLSN 是下面这些 LSN 中的最小 LSN：<ul>
<li>检查点起点的 LSN</li>
<li>最旧的活动事务起点的 LSN</li>
</ul>
</li>
</ul>
<h4 id="SQL-Server：生成检查点"><a href="#SQL-Server：生成检查点" class="headerlink" title="SQL Server：生成检查点"></a>SQL Server：生成检查点</h4><ol>
<li>将标记检查点起点的记录写入日志文件</li>
<li>将为检查点记录的信息存储在检查点日志记录链内，将这条链起点的 LSN 写入数据库根页</li>
<li>将最小恢复 LSN(MinLSN) 保存在检查点记录中</li>
<li>将所有未完成的活动事务列表保存在检查点记录中</li>
<li>如果数据库使用的是简单恢复模式，则删除新的 MinLSN 之前的所有日志记录</li>
<li>将所有脏日志和数据页写入磁盘</li>
<li>将标记检查点末端的记录写入日志文件</li>
</ol>
<h5 id="恢复过程"><a href="#恢复过程" class="headerlink" title="恢复过程"></a>恢复过程</h5><ul>
<li>检查点线程遍历缓冲区池，按照缓冲区编号顺序扫描页面，当它发现脏页时，它将查看与该页面<strong>物理(磁盘上)连续的其他页面</strong>是否也是脏的，这样它可以进行大块写操作<ul>
<li>顺序写性能远高于随机写</li>
</ul>
</li>
<li>如果它看到页面5是脏的时，它可能会写入页面10、25、380、500等，这些页面在磁盘上是连续的。这样，缓冲区中非连续的页面可以被一次聚集写入（<strong>gather-write</strong>）磁盘</li>
<li>以后检查点会到达页面 500，为避免将该页面重复写入磁盘，检查点算法会为每个页面设置标志位，开始时所有的位都相同(都为0或1)。当检查点检查到某个页面时，它将其标志位翻转。如果检查点碰到具有相反位的页面，它就跳过该页面</li>
<li><strong>对于在检查点期间新近引入的页面，或者已经被检查点输出到磁盘但又重新变脏的页面，都不会被该次检查点操作写入</strong></li>
</ul>
<h5 id="recovery-interval"><a href="#recovery-interval" class="headerlink" title="recovery interval"></a>recovery interval</h5><ul>
<li>recovery interval 选项设置 SQL Server 恢复数据库所需的最大分钟数</li>
<li>据此 SQL Server 将估计在恢复时间间隔期间可以处理多少更新的数据，从而决定在每一个数据库中 SQL Server 何时生成一次检查点</li>
<li>SQL Server 根据 10MB 的日志可以在 1 分钟内得到恢复这样一个估计来确定它的恢复间隔</li>
<li>当最近一个检查点之后数据更新操作达到了 SQL Server 认为可以在恢复时间间隔更新的数量时，它将进行一个检查点操作</li>
</ul>
<h4 id="MySQL-检查点执行时机"><a href="#MySQL-检查点执行时机" class="headerlink" title="MySQL 检查点执行时机"></a>MySQL 检查点执行时机</h4><ul>
<li>Master Thread Checkpoint<ul>
<li>每秒或每10秒刷出一定比例的脏页</li>
</ul>
</li>
<li>FLUSH_LRU_LIST Checkpoint<ul>
<li>LRU 列表中空闲页不够时淘汰的页面中有脏页</li>
</ul>
</li>
<li>Dirty Page too much Checkpoint<ul>
<li>innodb_max_dirty_pages_pct</li>
</ul>
</li>
<li>Async&#x2F;Sync Flush Checkpoint<ul>
<li>redo_lsn–checkpoing_lsn 超过日志文件大小75%</li>
</ul>
</li>
</ul>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="MySQL-日志文件"><a href="#MySQL-日志文件" class="headerlink" title="MySQL 日志文件"></a>MySQL 日志文件</h3><ul>
<li>重做日志（redolog）</li>
<li>回滚日志（undolog）</li>
<li>二进制日志（binlog）</li>
<li>错误日志（errorlog）</li>
<li>慢查询日志（slowquerylog）</li>
<li>一般查询日志（generallog）</li>
<li>中继日志（relaylog）</li>
</ul>
<h3 id="事务日志物理构架"><a href="#事务日志物理构架" class="headerlink" title="事务日志物理构架"></a>事务日志物理构架</h3><ul>
<li>循环使用<ul>
<li>生成检查点的时候，可以释放之前的一些无用日志块</li>
</ul>
</li>
</ul>
<img src="09-1/image-20210613235856513.png" style="zoom:67%;" />



<h3 id="逻辑-Undo-日志"><a href="#逻辑-Undo-日志" class="headerlink" title="逻辑 Undo 日志"></a>逻辑 Undo 日志</h3><ul>
<li><strong>针对索引页</strong></li>
<li>一般恢复技术要求一旦事务更新了一个数据项，其它事务都不能更新该数据项，直至第一个事务提交或回滚</li>
<li>严格两阶段封锁协议实施到某些特殊结构如 B+ 树索引页时，并发性极度下降。为提高并发性，可以使锁较早释放<ul>
<li>提早释放会导致问题</li>
<li>如果是物理日志<ul>
<li>A 事务写页 a，B 事务也写页 a，此时 A 事务出错，回滚，页 a 回滚（页面为单位），此时把事务 B 修改的部分给覆盖了</li>
</ul>
</li>
<li>逻辑日志则没有这个问题</li>
<li>插入操作必须通过一个逻辑 undo 来完成，即通过执行一次删除操作撤消</li>
</ul>
</li>
<li><strong>闩锁，自旋锁</strong></li>
<li>如果事务 T 向 B+ 树插入了一项，在插入操作结束后但在事务提交前释放了某些锁，那么在锁释放后，其它事务可执行插入或删除操作，于是造成对 B+ 树结点的进一步改变</li>
<li>如果使用物理 undo 执行事务回滚，即事务回滚时我们将 B+ 树内部结点(执行插入操作前)的旧值写回，那么其它事务在其后执行的插入或删除操作所做的某些更新可能会丢失</li>
</ul>
<h3 id="其他恢复技术"><a href="#其他恢复技术" class="headerlink" title="其他恢复技术"></a>其他恢复技术</h3><h4 id="提交日志（Commit-Logging）"><a href="#提交日志（Commit-Logging）" class="headerlink" title="提交日志（Commit Logging）"></a>提交日志（Commit Logging）</h4><ul>
<li>特点<ul>
<li><strong>只有 redo 记录，没有 undo 记录</strong></li>
<li><strong>脏数据不会持久化</strong></li>
<li><strong>提交时将事务日志都刷写到磁盘</strong></li>
</ul>
</li>
<li>如果日志只写到一半时出现系统故障，事务修改也会随之消失。当数据库系统重新恢复时，会发现日志中事务没有完成标记，就好像完全没有发生过一样</li>
<li>OceanBase、Hekaton（SQL Server 内存存储引擎）</li>
<li>如果在系统故障后，重启的时候发现有一条事务没有 commit 标记，怎么办？<ul>
<li>不需要做任何操作，是一条失败的操作记录（日志不完整而且脏数据没写回磁盘）</li>
<li>只需要重做已经成功的日志</li>
</ul>
</li>
</ul>
<h4 id="Shadow-Paging"><a href="#Shadow-Paging" class="headerlink" title="Shadow Paging"></a>Shadow Paging</h4><ul>
<li><strong>影子页</strong>，没有日志的概念</li>
<li>在事务操作过程中，被修改的数据会同时存在两份，一份<strong>修改前</strong>的数据，一份是<strong>修改后</strong>的数据，这就是影子（Shadow）这个名字的由来</li>
<li>持久性保证：事务的修改直接持久化在硬盘上</li>
<li>如果在事务提交前出现系统故障，数据库恢复时见不到未完成事务的修改，硬盘上的这个事务曾经修改的数据也会由垃圾回收模块回收</li>
<li>SQLite</li>
</ul>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><ul>
<li>A 向 B 转账 100</li>
</ul>
<img src="09-1/image-20210721151303697.png" style="zoom: 50%;" />

<ul>
<li>当事务提交时，以一次原子的数据写入让整个事务新的修改生效</li>
<li>A 和 B 的余额都是直接写入新的位置，保证原先的数据没有改动</li>
<li>系统通过两个目录结构分别指向修改前的数据和修改后的数据，最后 Current 指针原子切换到新的目录上，表示事务提交成功</li>
</ul>
<h3 id="镜像数据库"><a href="#镜像数据库" class="headerlink" title="镜像数据库"></a>镜像数据库</h3><ul>
<li><strong>主体服务器</strong><ul>
<li>存放数据库</li>
<li>执行事务</li>
<li>推送更新（内容数据同步）</li>
</ul>
</li>
<li><strong>镜像服务器</strong><ul>
<li>存放数据库副本</li>
<li>接受更新</li>
<li>替补篡位（主题服务器宕机）</li>
</ul>
</li>
<li><strong>见证服务器</strong><ul>
<li>自动故障转移</li>
<li>判断主体服务器不可用</li>
</ul>
</li>
<li>实际部署的问题（为什么需要见证服务器）<ul>
<li>怎么判断主体服务器是否还在工作：heartbeat<ul>
<li>如果是由网络故障导致接收不到 heartbeat，镜像服务器不能贸然替补篡位</li>
<li>这个由见证服务器判断</li>
</ul>
</li>
<li>通常使用投票来决定谁是主题服务器</li>
</ul>
</li>
<li>split-brain quorum</li>
</ul>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul>
<li>实现系统的安全性，抗故障能力</li>
</ul>
<p><img src="/09-1/image-20210721151848266.png"></p>
<ul>
<li>读写分离、伸缩性、安全性</li>
<li>提高访问的本地性（可以在比较近的服务器上读取数据）</li>
<li>增加系统可靠性（一个结点失效，其他结点还是可用的）</li>
</ul>
<h4 id="数据复制的更新传播策略"><a href="#数据复制的更新传播策略" class="headerlink" title="数据复制的更新传播策略"></a>数据复制的更新传播策略</h4><ul>
<li><strong>紧密复制</strong>：将所有结点上的副本更新作为一个原子事务的一部分，所有结点上的副本严格同步<ul>
<li>更新代价大</li>
</ul>
</li>
<li><strong>松散复制</strong>：更新事务提交之后，异步的将更新传向其他结点<ul>
<li>各个结点之间会有短暂的不一致</li>
</ul>
</li>
</ul>
<h4 id="数据复制的更新控制策略"><a href="#数据复制的更新控制策略" class="headerlink" title="数据复制的更新控制策略"></a>数据复制的更新控制策略</h4><ul>
<li><strong>主方式</strong>（master）<ul>
<li>每一对象都有一起主结点，只有主结点能够更新对象的主拷贝，其他副本是只读的。其他与更新该对象的结点请求主结点完成更新，由主结点将更新传向其他结点。</li>
</ul>
</li>
<li><strong>群方式</strong>（group）<ul>
<li>任何拥有某数据项拷贝的结点都可以更新该拷贝，称之为随处更新（update everywhere）并将更新操作广播到其他结点</li>
<li>需要设计冲突协调策略？怎么解决冲突？<ul>
<li>人为设计：时间靠后、值较大 ······</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数据复制的更新策略"><a href="#数据复制的更新策略" class="headerlink" title="数据复制的更新策略"></a>数据复制的更新策略</h4><p><img src="/09-1/image-20210721153646701.png"></p>
<ul>
<li>松散 + 群：数据一致性很差，数据库场景中实际应用较少</li>
<li>SQL Server 4 种都支持</li>
</ul>
<h4 id="MySQL-复制类型"><a href="#MySQL-复制类型" class="headerlink" title="MySQL 复制类型"></a>MySQL 复制类型</h4><ul>
<li>没有群方式，只有主从<ul>
<li>所有的更新都发生在主结点，再由主结点将更新推送给其他结点</li>
</ul>
</li>
<li><strong>主从 + 同步&#x2F;异步</strong></li>
</ul>
<h5 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h5><ul>
<li>只有所有的 slaver 更新完成之后，整个事务才完成</li>
</ul>
<p><img src="/09-1/image-20210721153844233.png"></p>
<ul>
<li>主结点发送一个 binlog 到其他的从结点，slaver 结点再现这个 log ，然后发送 ACK 回主结点</li>
</ul>
<h5 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h5><ul>
<li>主结点不会等待从节点更新完成</li>
</ul>
<p><img src="/09-1/image-20210721154306532.png"></p>
<ul>
<li>问题<ul>
<li>主结点更新完就挂了，此时数据丢失，无法恢复</li>
</ul>
</li>
</ul>
<h5 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h5><ul>
<li>主结点等待某一个从结点更新结束之再进行接下来的操作</li>
</ul>
<p><img src="/09-1/image-20210721154443488.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/13/DB/CLJ/09-1/" data-id="cl9lj74b000gd64tz6ffxfa1d" data-title="数据库概论.陈立军.09.恢复控制(2)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/YLQ-GAMES202/14" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/13/CG/YLQ-GAMES202/14/" class="article-date">
  <time class="dt-published" datetime="2021-06-13T06:48:44.000Z" itemprop="datePublished">2021-06-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES202/">CG.GAMES202</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/13/CG/YLQ-GAMES202/14/">GAMES202.闫令琪.14.工业界算法实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY">https://www.bilibili.com/video/BV1YK4y1T7yY</a></li>
</ul>
<img src="14/image-20210613145024654.png" style="zoom:50%;" />



<h1 id="工业界算法实现"><a href="#工业界算法实现" class="headerlink" title="工业界算法实现"></a>工业界算法实现</h1><ul>
<li>A Glimpse of Industrial Solutions (from the scientific perspective)</li>
</ul>
<h2 id="AA"><a href="#AA" class="headerlink" title="AA"></a>AA</h2><ul>
<li>Anti-Aliasing：反走样</li>
</ul>
<h3 id="TAA"><a href="#TAA" class="headerlink" title="TAA"></a>TAA</h3><ul>
<li>Temporal Anti-Aliasing</li>
<li>TAA 算法的成功，才有了 temporal 思想在 RTRT 中的应用</li>
<li>走样的来源：对于每个像素的采样数不够（采样定理）</li>
<li>解决思路：使用更多的样本</li>
<li>temporal AA：使用更多的样本，但是是使用更多上一帧（以及之前帧）的样本<ul>
<li>思路和 RTRT 中是一样的</li>
</ul>
</li>
</ul>
<h4 id="静止场景"><a href="#静止场景" class="headerlink" title="静止场景"></a>静止场景</h4><img src="14/image-20210614143611181.png" style="zoom:50%;" />

<ul>
<li>怎么复用上一帧的样本？</li>
<li>一种想法，每一帧采不同的区域<ul>
<li>连续 4 帧，分别采样 左上、右上、右下、左下（移动的 sampling pattern）</li>
<li>复用上一帧，递归形成复用之前所有的样本的 sampling</li>
</ul>
</li>
</ul>
<p><img src="/14/rec.png"></p>
<ul>
<li>为什么不随机生成呢？<ul>
<li>相对均匀分布</li>
<li>如果随机会引入一些额外的高频信息，效果可能不太好</li>
</ul>
</li>
</ul>
<h4 id="运动场景"><a href="#运动场景" class="headerlink" title="运动场景"></a>运动场景</h4><ul>
<li>motion vector</li>
<li>temporal 信息不可用的时候，也是使用 clamping 的方法<ul>
<li>基本上和 RTRT 中的思路一致</li>
</ul>
</li>
</ul>
<h3 id="MSAA-和-SSAA"><a href="#MSAA-和-SSAA" class="headerlink" title="MSAA 和 SSAA"></a>MSAA 和 SSAA</h3><ul>
<li>SSAA：Supersampling<ul>
<li>渲染的时候，使用更高的分辨率，在渲染结束后，降采样到要求的分辨率</li>
<li>正确的，效果非常好，但是开销非常大</li>
</ul>
</li>
<li>MSAA：Multisampling AA<ul>
<li>一个 primitive 只会进行一次 shading</li>
<li>下图中，SSAA 需要做 4 次 shading，MSAA 只需要做两次</li>
</ul>
</li>
</ul>
<img src="14/image-20210614145047754.png" style="zoom:50%;" />

<ul>
<li>MSAA 支持空间上的复用<ul>
<li>(1)(2) 中间的两个采样点可以被视为对 (1) 的贡献，也能被当作对 (2) 的贡献</li>
<li>复用了中间两个点</li>
</ul>
</li>
</ul>
<img src="14/image-20210614145220883.png" style="zoom: 80%;" />

<ul>
<li><a target="_blank" rel="noopener" href="https://www.sapphirenation.net/anti-aliasing-comparison-performance-quality">https://www.sapphirenation.net/anti-aliasing-comparison-performance-quality</a></li>
</ul>
<h3 id="图像上的-AA"><a href="#图像上的-AA" class="headerlink" title="图像上的 AA"></a>图像上的 AA</h3><ul>
<li>先渲染得到带锯齿的结果图，然后在图像上进行反走样处理</li>
<li>最流行的方法：SMAA（Enhanced subpixelmorphological AA）</li>
<li>发展历史：FXAA $\to$ MLAA（Morphological AA）$\to$ SMAA</li>
</ul>
<h4 id="SMAA"><a href="#SMAA" class="headerlink" title="SMAA"></a>SMAA</h4><ul>
<li><a target="_blank" rel="noopener" href="http://www.iryoku.com/smaa/">http://www.iryoku.com/smaa/</a></li>
<li>先检测出来边界，然后根据找出来的边界，根据占比上色<ul>
<li>矢量化的过程</li>
</ul>
</li>
</ul>
<img src="14/image-20210614145953181.png" style="zoom: 67%;" />

<ul>
<li>效果非常快</li>
<li>不能对 G-Buffer 做反走样，反走样了则失去了原来的意义</li>
</ul>
<h2 id="Temporal-Super-Resolution"><a href="#Temporal-Super-Resolution" class="headerlink" title="Temporal Super Resolution"></a>Temporal Super Resolution</h2><ul>
<li>超分辨率：Super Resolution（Super Sampling）<ul>
<li>字面理解：提高分辨率</li>
</ul>
</li>
</ul>
<h3 id="DLSS"><a href="#DLSS" class="headerlink" title="DLSS"></a>DLSS</h3><ul>
<li>Nvidia</li>
<li>DLSS 1.0：硬猜，通过神经网络学习到一些结果，将模糊的边缘换成不模糊的边缘<ul>
<li>完全数据驱动</li>
</ul>
</li>
<li>DLSS 2.0：使用更多 Temporal 的信息<ul>
<li>分辨率提高，变模糊，等价于是采样不足，试从上一帧中获取信息</li>
</ul>
</li>
<li>核心思想就是利用 TAA<ul>
<li>Temporally reuse samples to increase resolution</li>
</ul>
</li>
<li>DLSS 面临的另外一个问题，如果时间的信息不可用，不能使用 clamping 的方法<ul>
<li>对 temporal 的信息利用更加严格</li>
<li>我们实际上需要的是一个增大了分辨率的结果，我们需要知道一些更细致分辨率的值，如果我们不能够在时间上获取到这些信息，盲目的使用周围的值去猜，这样会导致模糊的结果<ul>
<li>也就是说新的值和原来的值本质上是不同的，更细致的分辨率有更多细节</li>
</ul>
</li>
<li>因此我们需要找一个比 clamp 更好的方案（当 temporal failure 的时候）</li>
</ul>
</li>
</ul>
<img src="14/image-20210614151204493.png" style="zoom:50%;" />

<ul>
<li>当前帧和上一帧的采样信号 $\to$ 得到一个当前帧增加了采样点的值<ul>
<li>DLSS 的网络没有输出具体的颜色值，而是告诉我们应该怎么去使用上一帧的信息</li>
</ul>
</li>
</ul>
<img src="14/image-20210614151247397.png" style="zoom:50%;" />



<h4 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h4><ul>
<li>540p Bicubic Upsampled to 1080p</li>
</ul>
<p><img src="/14/image-20210614151725046.png"></p>
<ul>
<li>540p to 1080p DLSS2.0</li>
</ul>
<p><img src="/14/image-20210614151801326.png"></p>
<ul>
<li>1080p with TAA</li>
</ul>
<p><img src="/14/image-20210614151819215.png"></p>
<ul>
<li>DLSS 2.0 的效果可能更加锐利，因为 Temporal 的复用可能提高的分辨率不止 2x</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>DLSS 网络跑得快，具体怎么实现不清楚<ul>
<li>Network inference performance optimization (classified)</li>
</ul>
</li>
<li>AMD 也有 DLSS<ul>
<li>AMD：FidelityFX Super Resolution</li>
<li>同样性能的 <strong>CPU</strong>，AMD 的价格大概在 Nvidia 的一半价格</li>
</ul>
</li>
<li>Facebook：Neural Supersampling for Real-time Rendering [Xiao et al.]<ul>
<li>效果不太好，实现上更像 DLSS 1.0，工业界不好用</li>
</ul>
</li>
</ul>
<h2 id="避免没有意义的-shading"><a href="#避免没有意义的-shading" class="headerlink" title="避免没有意义的 shading"></a>避免没有意义的 shading</h2><h3 id="Deferred-Shading"><a href="#Deferred-Shading" class="headerlink" title="Deferred Shading"></a>Deferred Shading</h3><ul>
<li>延迟渲染</li>
<li>让 shading 变得更加高效，速度更快</li>
<li>传统的光栅化渲染管线<ul>
<li>Triangles -&gt; fragments -&gt; depth test -&gt; shade -&gt; pixel</li>
</ul>
</li>
<li>延迟渲染的想法<ul>
<li>在传统的光栅化渲染管线下，只有对视点可见的点的 shading 才是真正有效的，其他点的渲染本质上都是是无用功</li>
</ul>
</li>
<li>最坏的情况<ul>
<li>对于每一个 fragment，都是<strong>从远到近</strong>渲染的，这样做了很多无用功</li>
<li>这样每一个点都得做 shading</li>
<li>复杂度：O(#fragment $\times$ #light)</li>
</ul>
</li>
<li>延迟渲染的基本想法<ul>
<li>大部分的 fragment 在最终的 image 中是不可见的</li>
<li>我们只需要渲染在最终的 image 中可见的 fragment</li>
</ul>
</li>
</ul>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li>光栅化两次</li>
<li>第一次光栅化<ul>
<li>只生成 depth-buffer</li>
<li>不做 shading</li>
</ul>
</li>
<li>第二次光栅化<ul>
<li>给通过深度测试的 fragment 进行 shading</li>
<li>因为对于每一个像素，能够通过深度测试的 fragment 只会有 1 个</li>
</ul>
</li>
<li>延迟渲染的基本想法<ul>
<li>一次光栅化的开销比对大量不必要点的 shading 计算开销要小</li>
<li>assume rasterizing the scene is way faster than shading all unseen fragments (<strong>usually true</strong>)</li>
</ul>
</li>
<li>复杂度：O(#vis. fragment $\times$ #light)</li>
<li>问题<ul>
<li>我们做不了 AA（G-Buffer 不能做 AA）</li>
<li>但是可以通过 TAA 或者图像空间上的 AA，AA 的问题能够被很好的解决</li>
</ul>
</li>
<li>因此延迟渲染成为工业界的标配</li>
</ul>
<h3 id="Tiled-Shading"><a href="#Tiled-Shading" class="headerlink" title="Tiled Shading"></a>Tiled Shading</h3><ul>
<li><strong>优化光源</strong></li>
<li>把屏幕切分为若干个 tile（大概每个 $32\times32$），每个小块单独做 shading</li>
<li>这样子的方法可以<strong>减少每一个小块需要考虑的光源数目</strong></li>
<li>如下是 frustum 的俯视图</li>
</ul>
<img src="14/image-20210614164138654.png" style="zoom:50%;" />

<ul>
<li>对于每一个小条，不是所有光源都会影响到它<ul>
<li>光源的平方衰减<ul>
<li>上面的圆圈表示每一个光源的覆盖范围（球投影成圆）</li>
</ul>
</li>
<li>上面的数字表示影响到这个光源的光源个数</li>
</ul>
</li>
<li>复杂度：O(#vis. frag. $\times$ avg #light per tile)</li>
</ul>
<h3 id="Clustered-shading"><a href="#Clustered-shading" class="headerlink" title="Clustered shading"></a>Clustered shading</h3><img src="14/image-20210614164138654.png" style="zoom:50%;" />

<ul>
<li>想法和 tiled shading 类似</li>
<li>深度上也切片</li>
<li>一个格子可能包含多个像素，前面可能不会把后面整个各自都遮挡住</li>
</ul>
<h2 id="Level-of-Detail"><a href="#Level-of-Detail" class="headerlink" title="Level of Detail"></a>Level of Detail</h2><ul>
<li>LoD<ul>
<li>例如 mipmap 就是一个 level of detail</li>
</ul>
</li>
<li>在具体使用的时候，选择正确的层级去使用，这样能够节省计算的效率</li>
<li>RTR 工业界中把这种在对不同层级细节的使用称为 <strong>cascaded</strong></li>
<li>shadow map 可以用来做 LoD</li>
</ul>
<h3 id="Cascaded-Shadow-Map"><a href="#Cascaded-Shadow-Map" class="headerlink" title="Cascaded Shadow Map"></a>Cascaded Shadow Map</h3><ul>
<li>[Dimitrov et al., Cascaded Shadow Maps]</li>
<li>离视点近的物体使用高分辨率的  SM，离视点远的物体使用低分辨率的 SM<ul>
<li>下图中，三角形为 frustum，红色使用高分辨率 SM，蓝色使用低分辨率 SM</li>
</ul>
</li>
</ul>
<img src="14/image-20210614182849481.png" style="zoom:50%;" />

<ul>
<li>实际应用中我们很难生成一张变分辨率的 SM，因此实际应用会生成多张不同分辨率的 SM</li>
<li>针对不同距离，我们使用不同分辨率的 SM</li>
<li>范围会有一些重叠<ul>
<li>保证切换 SM 时能够平滑过渡</li>
<li>重叠区域使用两个 SM 混合的效果</li>
</ul>
</li>
</ul>
<h3 id="Cascaded-LPV"><a href="#Cascaded-LPV" class="headerlink" title="Cascaded LPV"></a>Cascaded LPV</h3><ul>
<li>[Anton Kaplanyan, Light Propagation Volumes in CryEngine 3]</li>
<li>近处比较小，远处比较大</li>
</ul>
<img src="14/image-20210614183357657.png" style="zoom:67%;" />





<h3 id="Geometric-LoD"><a href="#Geometric-LoD" class="headerlink" title="Geometric LoD"></a>Geometric LoD</h3><ul>
<li>高模（三角形多的模型）、低模（三角形少的模型）</li>
<li>预先生成一系列的不同三角形数的模型</li>
<li>可以对一个物体的不同部分使用不同精细程度的模型细节</li>
<li>UE5 的 Nanite 就是利用这些原理实现</li>
<li>对于引擎来说，技术实现是难点</li>
</ul>
<h3 id="Cascaded-的问题"><a href="#Cascaded-的问题" class="headerlink" title="Cascaded 的问题"></a>Cascaded 的问题</h3><ul>
<li>在不同层级之间切换的时候可能会有问题（popping artifactss）<ul>
<li>通常的方法可以在边界的地方使用 blending 的方法</li>
<li>Popping artifacts<ul>
<li>TAA 处理（复用上一帧的信息）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="引擎实现的难点"><a href="#引擎实现的难点" class="headerlink" title="引擎实现的难点"></a>引擎实现的难点</h3><ul>
<li>一个物体的不同部分使用不同层级的 LoD，怎么保证相接的地方是没有缝的？</li>
<li>如何动态加载和调度不同层级的资源？<ul>
<li>GPU 容量有限</li>
</ul>
</li>
<li>Representing geometry using triangles or geometry textures?<ul>
<li>怎么表示几何形体？三角形？几何纹理？</li>
</ul>
</li>
<li>引擎实现的加速<ul>
<li>clipping 裁剪</li>
<li>culling 剔除（背面剔除）</li>
</ul>
</li>
</ul>
<h2 id="全局光照的解决方法"><a href="#全局光照的解决方法" class="headerlink" title="全局光照的解决方法"></a>全局光照的解决方法</h2><ul>
<li>SSR 屏幕空间光线跟踪</li>
<li>没有一种简单的 GI 方法能够解决所有的场景<ul>
<li>RTRT可以，但是现在还是太慢了</li>
</ul>
</li>
<li>工业界经常把多种方法混合起来使用</li>
<li>一个 GI 的解决方案<ul>
<li>SSR 得到近似的 GI</li>
<li>对于 SSR 失败的地方，是用其他方式补充<ul>
<li>hardware (RTRT) or software ray tracing</li>
</ul>
</li>
</ul>
</li>
<li>软件光追<ul>
<li><span style="color:red">HQ SDF for individual objects that are close-by</span><ul>
<li>高质量的有向距离场</li>
</ul>
</li>
<li><span style="color:red">LQ SDF for the entire scene</span></li>
<li><span style="color:red">RSM if there are strong directional &#x2F; point lights</span><ul>
<li>手电筒</li>
</ul>
</li>
<li>Dynamic Diffuse GI(<strong>DDGI</strong>)<ul>
<li>Probes that stores irradiance in a 3D grid</li>
<li>利用这些探针去照亮整个场景</li>
</ul>
</li>
</ul>
</li>
<li>硬件光追<ul>
<li><span style="color:red">Doesn’t have to use the original geometry, but low-poly proxies</span><ul>
<li>使用简化的模型</li>
</ul>
</li>
<li>Probes（RTXGI）</li>
</ul>
</li>
<li>以上<span style="color:red">红色部分</span>是 UE5 的 Lumen 实现</li>
</ul>
<h2 id="课程没有涉及的部分"><a href="#课程没有涉及的部分" class="headerlink" title="课程没有涉及的部分"></a>课程没有涉及的部分</h2><ul>
<li>Texturing an SDF</li>
<li>Transparent material and order-independent transparency</li>
<li>Particle rendering</li>
<li>Post processing (depth of field, motion blur, etc.)</li>
<li>Random seed and blue noise<ul>
<li>蓝噪声：</li>
</ul>
</li>
<li>Foveated rendering<ul>
<li>注视点投入更多渲染的算力</li>
</ul>
</li>
<li>Probe based global illumination</li>
<li>ReSTIR, Neural Radiance Caching, etc.</li>
<li>Many-light theory and light cuts</li>
<li>Participating media, SSSSS<ul>
<li>参与介质</li>
<li>次表面散射</li>
</ul>
</li>
<li>Hair appearance</li>
<li>……</li>
</ul>
<img src="14/image-20210614192555110.png" style="zoom:67%;" />
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/13/CG/YLQ-GAMES202/14/" data-id="cl9lj749x009464tz8phgdedb" data-title="GAMES202.闫令琪.14.工业界算法实现" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/CLJ/09" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/13/DB/CLJ/09/" class="article-date">
  <time class="dt-published" datetime="2021-06-13T06:38:17.000Z" itemprop="datePublished">2021-06-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/13/DB/CLJ/09/">数据库概论.陈立军.09.恢复控制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="恢复控制"><a href="#恢复控制" class="headerlink" title="恢复控制"></a>恢复控制</h1><ul>
<li>目标<ul>
<li>服务可用性<ul>
<li>时间延迟</li>
</ul>
</li>
<li>数据可用性<ul>
<li>数据一致性</li>
</ul>
</li>
</ul>
</li>
<li>可能的措施<ul>
<li>备份</li>
<li>日志</li>
<li>把内存总的数据刷到稳定存储介质（磁盘等）上（ctrl+S）</li>
</ul>
</li>
</ul>
<h2 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h2><h3 id="事务故障"><a href="#事务故障" class="headerlink" title="事务故障"></a>事务故障</h3><ul>
<li>事务的运行没有到达预期的终点就被终止</li>
<li>影响范围只在这个事务上</li>
</ul>
<h4 id="非预期故障"><a href="#非预期故障" class="headerlink" title="非预期故障"></a>非预期故障</h4><ul>
<li>不能由事务程序处理的（异常）</li>
<li>如运算溢出，发生死锁而被选中撤消该事务</li>
</ul>
<h4 id="可预期故障"><a href="#可预期故障" class="headerlink" title="可预期故障"></a>可预期故障</h4><ul>
<li>应用程序可以发现的事务故障，并且应用程序可以让事务回滚</li>
<li>如转帐时发现帐面金额不足</li>
<li>写了异常处理，那么可以把非预期故障转变为可预期故障</li>
</ul>
<h3 id="系统故障"><a href="#系统故障" class="headerlink" title="系统故障"></a>系统故障</h3><ul>
<li><strong>软故障</strong>（soft crash）</li>
<li>在硬件故障、软件错误的影响下，虽引起<strong>内存信息丢失</strong>，但未破坏外存中数据</li>
<li>如CPU故障、突然停电，DBMS、OS、应用程序等异常终止</li>
</ul>
<h3 id="介质故障"><a href="#介质故障" class="headerlink" title="介质故障"></a>介质故障</h3><ul>
<li><strong>硬故障</strong>（hard crash）</li>
<li>又称<strong>磁盘故障</strong>，破坏<strong>外存上的数据库</strong>，并影响正在存取这部分数据的所有事务</li>
<li>如磁盘的磁头碰撞、瞬时的强磁场干扰</li>
<li>只能通过备份等方式恢复</li>
</ul>
<h3 id="恢复的定义"><a href="#恢复的定义" class="headerlink" title="恢复的定义"></a>恢复的定义</h3><ul>
<li>恢复是把数据库从错误状态恢复到某一正确状态的功能，从而确保数据库的一致性</li>
<li>恢复的基本原理是**<span style="color:red">冗余</span>**，即数据库中任一部分的数据可以根据存储在系统别处的冗余数据来重建</li>
<li>冗余<ul>
<li>备份（数据）</li>
<li>日志（事务活动）</li>
</ul>
</li>
</ul>
<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h3 id="转储"><a href="#转储" class="headerlink" title="转储"></a>转储</h3><ul>
<li>生成备份的过程：<strong>转储</strong>（dump）<ul>
<li>将数据库复制到磁带或另一个磁盘上保存起来的过程</li>
<li>这些备用数据称为后备（后援）副本</li>
</ul>
</li>
</ul>
<h3 id="转储类型"><a href="#转储类型" class="headerlink" title="转储类型"></a>转储类型</h3><ul>
<li>静态转储<ul>
<li>转储期间不允许对数据库进行任何存取、修改活动</li>
<li><strong>转储期间不向外提供服务</strong></li>
</ul>
</li>
<li>动态转储<ul>
<li>转储期间允许对数据库进行存取或修改</li>
<li><strong>转储期间数据块还对外提供服务</strong></li>
</ul>
</li>
<li>海量转储<ul>
<li>每次转储<strong>全部数据库</strong></li>
</ul>
</li>
<li>增量转储<ul>
<li>每次只转储上次转储后*<strong>更新过的数据</strong></li>
</ul>
</li>
</ul>
<h3 id="SQL-Server-数据库备份"><a href="#SQL-Server-数据库备份" class="headerlink" title="SQL Server 数据库备份"></a>SQL Server 数据库备份</h3><ul>
<li>完整的数据库备份</li>
<li>数据库备份创建备份完成时数据库内存在的数据的副本，通常按常规时间间隔调度</li>
<li>还原数据库备份将重新创建数据库和备份完成时数据库中存在的所有相关文件<ul>
<li>但是，自创建备份后所做的任何数据库修改都将丢失</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">USE master</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_addumpdevice <span class="string">&#x27;disk&#x27;</span>, <span class="string">&#x27;MyBKDB&#x27;</span>, DISK <span class="operator">=</span><span class="string">&#x27;c:\MyBKDB.dat&#x27;</span></span><br><span class="line"></span><br><span class="line">BACKUP DATABASE LJCHEN <span class="keyword">TO</span> MyBKDB</span><br><span class="line"></span><br><span class="line">RESTORE DATABASE LJCHEN <span class="keyword">FROM</span> MyBKDB</span><br></pre></td></tr></table></figure>



<h3 id="SQL-Server-差异数据库备份"><a href="#SQL-Server-差异数据库备份" class="headerlink" title="SQL Server 差异数据库备份"></a>SQL Server 差异数据库备份</h3><ul>
<li>差异数据库备份（DCM）</li>
<li>差异数据库备份只记录自上次数据库备份后发生更改的数据，比数据库备份小而且速度快</li>
<li>使用差异数据库备份将数据库还原到差异数据库备份完成时的那一点</li>
<li>初始得是一个全量的备份</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 全量备份 */</span></span><br><span class="line">BACKUP DATABASE LJCHEN <span class="keyword">TO</span> MyBKDB <span class="keyword">WITH</span> INIT</span><br><span class="line"><span class="comment">/* 增量备份*/</span></span><br><span class="line">BACKUP DATABASE LJCHEN <span class="keyword">TO</span> MyBKDB <span class="keyword">WITH</span> DIFFERENTIAL</span><br><span class="line"></span><br><span class="line">RESTORE DATABASE LJCHEN <span class="keyword">FROM</span> MyBKDB <span class="keyword">WITH</span> NORECOVERY</span><br><span class="line">RESTORE DATABASE LJCHEN <span class="keyword">FROM</span> MyBKDB <span class="keyword">WITH</span> FILE<span class="operator">=</span><span class="number">2</span>, RECOVERY</span><br></pre></td></tr></table></figure>

<ul>
<li>一个位图，每一个页一位，如果修改了则把这个页对应位图上的位置为 1<ul>
<li>增量备份的时候把修改过的备份出去即可</li>
</ul>
</li>
</ul>
<h3 id="SQL-Server-事务日志备份"><a href="#SQL-Server-事务日志备份" class="headerlink" title="SQL Server 事务日志备份"></a>SQL Server 事务日志备份</h3><ul>
<li>事务日志是自上次备份事务日志后对数据库执行的所有事务的一系列记录，它可以将数据库恢复到特定的即时点或恢复到故障点</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BACKUP DATABASE MyDB <span class="keyword">TO</span> MyDB_1 <span class="keyword">WITH</span> INIT</span><br><span class="line"></span><br><span class="line">BACKUP LOG MyDB <span class="keyword">TO</span> MyDB_log1</span><br><span class="line"></span><br><span class="line">BACKUP LOG MyDB <span class="keyword">TO</span> MyDB_log2 <span class="keyword">WITH</span> NO_TRUNCATE</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RESTORE DATABASE MyDB <span class="keyword">FROM</span> MyDB_1 <span class="keyword">WITH</span> NORECOVERY</span><br><span class="line"></span><br><span class="line">RESTORE LOG MyDB <span class="keyword">FROM</span> MyDB_log1 <span class="keyword">WITH</span> NORECOVERY</span><br><span class="line"></span><br><span class="line">RESTORE LOG MyDB <span class="keyword">FROM</span> MyDB_log2 <span class="keyword">WITH</span> RECOVERY</span><br></pre></td></tr></table></figure>

<ul>
<li>WITH NORECOVERY：<strong>重做所有日志记录</strong></li>
<li>WITH RECOVERY：<strong>回滚失败事务日志记录</strong></li>
</ul>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><ul>
<li>事务 T 从 A 帐户过户 50 到 B 帐户</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read(A); A:<span class="operator">=</span>A<span class="number">-50</span>; write(A);</span><br><span class="line">read(B); B:<span class="operator">=</span>B<span class="operator">+</span><span class="number">50</span>; write(B);</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure>

<ul>
<li>由于某些原因，事务 T 的两个操作被写到两个日志文件 MyDB_log1、MyDB_log2 中了</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyDB_log1</span><br><span class="line">&lt;T,A,100,50&gt;</span><br><span class="line"></span><br><span class="line">MyDB_log2</span><br><span class="line">&lt;T,B,100,150&gt;</span><br><span class="line">commit</span><br></pre></td></tr></table></figure>

<ul>
<li>如下两种恢复方式的结果不同</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RESTORE LOG MyDB <span class="keyword">FROM</span> MyDB_log1 <span class="keyword">WITH</span> NORECOVERY</span><br><span class="line">RESTORE LOG MyDB <span class="keyword">FROM</span> MyDB_log2 <span class="keyword">WITH</span> RECOVERY</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A: 50, B: 150</span></span><br><span class="line"><span class="comment">正确的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RESTORE LOG MyDB <span class="keyword">FROM</span> MyDB_log1 <span class="keyword">WITH</span> RECOVERY</span><br><span class="line">RESTORE LOG MyDB <span class="keyword">FROM</span> MyDB_log2 <span class="keyword">WITH</span> RECOVERY</span><br><span class="line"></span><br><span class="line"><span class="comment">/* log1 中没有 commit, 认为是失败的事务, 被回滚 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A: 100, B: 150</span></span><br><span class="line"><span class="comment">错误的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>因此告诉我们，如果我们有多个日志备份文件<ul>
<li>前面的文件应该都是 <code>WITH NORECORERY</code></li>
<li>只有最后一个日志文件是 <code>WITH RECOVERY</code></li>
</ul>
</li>
</ul>
<h3 id="SQL-Server-恢复模型"><a href="#SQL-Server-恢复模型" class="headerlink" title="SQL Server 恢复模型"></a>SQL Server 恢复模型</h3><ul>
<li>我们期望能够保留下来的工作越多，也就是希望数据库能够恢复到更近的一致性的状态<ul>
<li>这与数据库系统平时付出的代价相关</li>
</ul>
</li>
</ul>
<h4 id="简单恢复"><a href="#简单恢复" class="headerlink" title="简单恢复"></a>简单恢复</h4><ul>
<li>允许将数据库恢复到最新的备份<ul>
<li>简单数据库备份，没有日志，只能恢复到最新的数据库备份那一刻的内容</li>
</ul>
</li>
<li>数据库备份 + 差异备份（可选）</li>
</ul>
<h4 id="完全恢复"><a href="#完全恢复" class="headerlink" title="完全恢复"></a>完全恢复</h4><ul>
<li>允许将数据库恢复到故障点状态<ul>
<li>完全恢复（恢复到尽可能近的状态），先通过数据库备份恢复，然后通过日志记录恢复</li>
</ul>
</li>
<li>数据库备份 + 差异备份（可选） + 事务日志备份</li>
</ul>
<h4 id="大容量日志记录恢复（BCM）"><a href="#大容量日志记录恢复（BCM）" class="headerlink" title="大容量日志记录恢复（BCM）"></a>大容量日志记录恢复（BCM）</h4><ul>
<li>允许大容量日志记录操作（select into，bcp，bulk insert）<ul>
<li>批量的修改会导致日志文件庞大，对性能造成影响</li>
<li>这种模式下，日志文件中只记录操作的帧，操作所影响的数据写到其他的数据文件中</li>
<li>BCM 位图实现，把影响的页面单独写出去，并在位图上做标记</li>
</ul>
</li>
<li>数据库备份 + 差异备份（可选） + 事务日志备份</li>
</ul>
<h4 id="切换恢复模型"><a href="#切换恢复模型" class="headerlink" title="切换恢复模型"></a>切换恢复模型</h4><ul>
<li>可以将数据库从一个恢复模型切换到另一个恢复模型，以满足不断变化的业务要求</li>
<li>例如，如果系统需要完全的可恢复性，可以在装载和索引操作的过程中，将数据库的恢复模型更改到批量日志记录模型，然后再返回到完全恢复</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 切换恢复模型 */</span></span><br><span class="line"><span class="keyword">alter</span> database <span class="operator">&lt;</span>database_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">set</span> recovery[ <span class="keyword">FULL</span> <span class="operator">|</span> BULK_LOGGED <span class="operator">|</span> SIMPLE ]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看当前数据库所使用的恢复模型 */</span></span><br><span class="line"><span class="keyword">select</span> database propertyex(<span class="string">&#x27;&lt;database_name&gt;&#x27;</span>, <span class="string">&#x27;recovery&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="MySQL-备份类型"><a href="#MySQL-备份类型" class="headerlink" title="MySQL 备份类型"></a>MySQL 备份类型</h3><ul>
<li>备份内容<ul>
<li>逻辑备份：从表的角度备份</li>
<li>裸文件备份：把磁盘上面的数据文件备份出去</li>
</ul>
</li>
<li>备份方法<ul>
<li>热备(Hot Backup)：数据库保持业务工作的同时进行备份</li>
<li>冷备(Cold Backup)：数据库停下来备份</li>
<li>温备(Warm Backup)：只允许读操作下执行，不允许写操作执行</li>
</ul>
</li>
<li>备份数据库内容<ul>
<li>完全备份</li>
<li>增量备份</li>
<li>日志备份</li>
</ul>
</li>
</ul>
<h3 id="MySQL-备份工具"><a href="#MySQL-备份工具" class="headerlink" title="MySQL 备份工具"></a>MySQL 备份工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --databases db1 db2 db3 &gt; dump.sql</span><br><span class="line">mysqldump --no-data -databases db1 db2 &gt; structure.sql</span><br><span class="line">mysqldump <span class="built_in">test</span> t1 t3 t7 &gt; dump.sql</span><br><span class="line"><span class="built_in">source</span> dump.sql</span><br></pre></td></tr></table></figure>

<ul>
<li>这种方式同时可用于在不同的数据库之间交换内容</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 导出到文件 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">into</span> outfile <span class="string">&#x27;data.txt&#x27;</span></span><br><span class="line">fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">lines terminated <span class="keyword">by</span> <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line"><span class="keyword">from</span> my_table</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从文件中恢复 */</span></span><br><span class="line">load data infile <span class="string">&#x27;data.txt&#x27;</span></span><br><span class="line"><span class="keyword">into</span> <span class="keyword">table</span> my_table</span><br><span class="line">fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">lines terminated <span class="keyword">by</span> <span class="string">&#x27;\r\n&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="MySQL-热备工具"><a href="#MySQL-热备工具" class="headerlink" title="MySQL 热备工具"></a>MySQL 热备工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --user=root --password=123456 --host=127.0.0.1 /backups/</span><br><span class="line"></span><br><span class="line">innobackupex --apply-log /backups</span><br><span class="line"></span><br><span class="line">innobackupex --copy-back /backups</span><br></pre></td></tr></table></figure>

<ul>
<li>在<strong>增量备份</strong>时，比较表空间中每个页的 LSN 是否大于上次备份时的 LSN，若是，则备份</li>
</ul>
<img src="09/image-20210613171041017.png"  />



<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul>
<li>日志文件是<strong>以事务为单位</strong>用来记录数据库的每一次更新活动的文件，由系统自动记录<ul>
<li>增删改，不记录查询</li>
</ul>
</li>
<li>日志内容包括<ul>
<li>记录名、旧记录值、新记录值、事务标识符、操作标识符等</li>
</ul>
</li>
<li>内容如下<ul>
<li>事务 Ti 开始时，写入日志：Tistart</li>
<li>事务 Ti 执行 write(X) 前，写入日志：&lt;Ti,X,V1,V2&gt;<ul>
<li>V1 是 X 更新前的值，V2 是 X 更新后的值</li>
</ul>
</li>
<li>事务 Ti 结束后，写入日志：Ticommit</li>
</ul>
</li>
<li>日志记录的是值的变换，而不是逻辑的操作<ul>
<li>记录的是物理值的话，不管重复多少次，结果中是一致的</li>
<li>如果记录具体的逻辑操作，重复多次的结果不一样<ul>
<li>例如一个操作是-10，重复多次则会多次-10</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="事务分类"><a href="#事务分类" class="headerlink" title="事务分类"></a>事务分类</h3><ul>
<li>基于日志记录对事务进行分类</li>
<li>圆满事务（成功了）<ul>
<li>日志文件中记录了事务的 commit 标识</li>
</ul>
</li>
<li>夭折事务（失败的）<ul>
<li>日志文件中只有事务的 begin transaction 标识，无 commit</li>
</ul>
</li>
</ul>
<h3 id="基本的恢复操作"><a href="#基本的恢复操作" class="headerlink" title="基本的恢复操作"></a>基本的恢复操作</h3><ul>
<li>对圆满事务所做过的修改应执行 redo 操作，即重新执行该操作，修改对象被赋予<strong>新记录值</strong><ul>
<li>不管 redo 多少次，结果都是一样的（$\mathrm{redo^2&#x3D;redo}$）</li>
</ul>
</li>
<li>对夭折事务所做过的修改应执行undo操作，即撤消该操作，修改对象被赋予<strong>旧记录值</strong><ul>
<li>$\mathrm{undo^2&#x3D;undo}$</li>
</ul>
</li>
</ul>
<h3 id="事务的原语操作"><a href="#事务的原语操作" class="headerlink" title="事务的原语操作"></a>事务的原语操作</h3><ul>
<li>input(X)：将包含数据库元素 X 的<strong>磁盘块</strong>拷贝到<strong>内存缓冲区</strong></li>
<li>read(X,t)：将<strong>内存缓冲区</strong>的数据库元素 X 拷贝到事务的<strong>局部变量</strong> t</li>
<li>write(X,t)：将<strong>局部变量</strong> t 的值拷贝到<strong>内存缓冲区</strong>中的数据库元素 X</li>
<li>output(X)：将包含 X 的<strong>缓冲区</strong>拷贝回<strong>磁盘</strong></li>
<li>发出者不同<ul>
<li>read 和 write 由<strong>事务</strong>发出</li>
<li>input 和 output 由<strong>缓冲区管理器</strong>（或<strong>日志管理器</strong>）发出</li>
</ul>
</li>
</ul>
<h3 id="先写日志的原则-WAL"><a href="#先写日志的原则-WAL" class="headerlink" title="先写日志的原则(WAL)"></a>先写日志的原则(WAL)</h3><ul>
<li>保证原子性（<strong>all or not</strong>）<ul>
<li>文件系统 xv6 的日志系统也是如此</li>
</ul>
</li>
<li>日志记录将要发生何种修改</li>
<li>写入 DB 表示实际发生何种修改</li>
<li>Write Ahead Log（WAL）<ul>
<li>对于尚未提交的事务，在将DB缓冲区写到外存之前，必须先将日志缓冲区内容写到外存去</li>
</ul>
</li>
</ul>
<img src="09/image-20210613172816406.png" style="zoom:67%;" />

<ul>
<li>如果先写 DB，则可能在写的中途发生系统崩溃，导致内存缓冲区内容丢失，而外存 DB 处于不一致状态，由于日志缓冲区内容已破坏，导致无法对 DB 恢复</li>
<li>如果先写数据库再写日志记录的话<ul>
<li>假设这样的一种情况，日志记录还没写完，系统崩溃了</li>
<li>此时日志中只有 A 的记录</li>
<li>故障恢复的时候，由于缺少 commit，认为是夭折事务，执行 undo</li>
<li>此时 B 的结果没有修改回去，造成错误（不一致）</li>
</ul>
</li>
</ul>
<img src="09/image-20210613221235500.png" style="zoom:67%;" />

<ul>
<li>先写日志则能够恢复到一致的状态<ul>
<li>以下是写 B 日志的时候系统崩溃了的情况</li>
<li>此时 redo 操作能够撤销 A 的修改，虽然 B 没有修改，但是 redo 也不会将其改成错误数据</li>
</ul>
</li>
</ul>
<img src="09/image-20210613221653647.png" style="zoom:67%;" />

<ul>
<li>日志写完了，但是磁盘没写完，此时系统崩溃了，通过 redo 操作实现一致</li>
</ul>
<img src="09/image-20210613221940870.png" style="zoom:67%;" />



<h3 id="写时机"><a href="#写时机" class="headerlink" title="写时机"></a>写时机</h3><ul>
<li>日志缓冲区和数据库缓冲区的写时机不同</li>
<li><strong>同步（synchronous）写日志</strong><ul>
<li>只有事务的相关日志已经完全在磁盘上了，才会向进程发送该事务已提交的确认消息</li>
<li>事务提交驱动</li>
</ul>
</li>
<li><strong>异步（asynchronous）写缓冲区</strong><ul>
<li>只需要将数据页的写入操作投递给操作系统即可，不需要等待其完成</li>
<li>不是事务提交驱动的</li>
</ul>
</li>
</ul>
<h3 id="Buffer-Manager-BM"><a href="#Buffer-Manager-BM" class="headerlink" title="Buffer Manager(BM)"></a>Buffer Manager(BM)</h3><ul>
<li>不同策略（当然要求先写日志）<ul>
<li>Steal policy<ul>
<li>对内存页面的更改可以随意同步回硬盘而<strong>不需要等待事务提交</strong></li>
</ul>
</li>
<li>Force policy<ul>
<li>事务在提交前，它所有更改的页面必须写回到硬盘</li>
</ul>
</li>
</ul>
</li>
<li>ARIES 的 BM 遵循 “Non-Force，Steal”</li>
<li>如果必须等待所有更改过页面的事务都提交了才同步这个内存页到磁盘会如何？<ul>
<li>如果需要支持行锁，那么一个页面可能有多个行被不同的 Tx 更改，这个页面必须等待所有的   Tx 都 Commit，但是如果不断有新的 Tx 来更改这个页面，这个页面就迟迟无法同步回物理页面</li>
</ul>
</li>
</ul>
<h3 id="读取一个页面的过程"><a href="#读取一个页面的过程" class="headerlink" title="读取一个页面的过程"></a>读取一个页面的过程</h3><ul>
<li>如果事务没结束，那么日志也不一定写回到磁盘</li>
</ul>
<img src="09/image-20210613223550791.png" style="zoom:67%;" />



<h3 id="MySQL-日志刷写时机"><a href="#MySQL-日志刷写时机" class="headerlink" title="MySQL 日志刷写时机"></a>MySQL 日志刷写时机</h3><ul>
<li>在主线程<strong>每秒一次</strong>的循环中，将重做日志缓冲器的内容刷新到重做日志文件中，即便某个事务尚未提交</li>
<li>由参数 innodb_flush_log_at_trx_commit 控制<ul>
<li>0 代表提交事务时，并不立即刷出日志，而是等待主线程每秒的刷新<ul>
<li>1 秒之内失败的话，事务结果会丢失</li>
</ul>
</li>
<li>1 代表提交事务时，将重做日志同步写磁盘，也即伴有 fsync() 的调用<ul>
<li>磁盘 IO 开销比较大</li>
</ul>
</li>
<li>2 代表提交事务时，将重做日志异步写磁盘，也即写入文件系统缓存中<ul>
<li>可能操作系统没有把他落盘</li>
</ul>
</li>
</ul>
</li>
<li>有两个缓冲区<ul>
<li>数据库缓冲区、操作系统缓冲区</li>
</ul>
</li>
</ul>
<img src="09/image-20210613225205691.png" style="zoom: 45%;" />



<h3 id="MySQL-组提交"><a href="#MySQL-组提交" class="headerlink" title="MySQL 组提交"></a>MySQL 组提交</h3><ul>
<li>磁盘 I&#x2F;O 开销大</li>
<li>fsync 是昂贵的操作，MySQL 一次事务提交最多会导致 3 次 fsync</li>
<li>组提交通过将多个并发需要提交的事务共享一次 fsync 操作来进行数据的持久化</li>
<li>binlog_group_commit_sync_delay&#x3D;N<ul>
<li>在等待 N 微秒后，进行 binlog 刷盘操作</li>
</ul>
</li>
<li>binlog_group_commit_sync_no_delay_count&#x3D;N<ul>
<li>达到最大事务等待数量，开始 binlog 刷盘</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/13/DB/CLJ/09/" data-id="cl9lj74b100gj64tz613zfxc8" data-title="数据库概论.陈立军.09.恢复控制" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/14/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/16/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/0/">0</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algebra/">Algebra</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-Kits/">C++.Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG/">CG</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Algorithm/">CG.Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES101/">CG.GAMES101</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES102/">CG.GAMES102</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES103/">CG.GAMES103</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES104/">CG.GAMES104</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES202/">CG.GAMES202</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES203/">CG.GAMES203</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Kits/">CG.Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-LS/">CG.LS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-PBRT/">CG.PBRT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Paper/">CG.Paper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CV/">CV</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Code/">Code</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-CLJ/">DB.CLJ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-MySQL/">DB.MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-SQLServer/">DB.SQLServer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DSA/">DSA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kits/">Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-CXQ/">OS.CXQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-OSTEP/">OS.OSTEP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-xv6-labs/">OS.xv6-labs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-xv6-source-code/">OS.xv6-source-code</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TODO/">TODO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/book-directory/">book.directory</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computation-pyr/">computation.pyr</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/csharp-kits/">csharp.kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/csharp-tds/">csharp.tds</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/images/">images</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/installation/">installation</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mitsuba/">mitsuba</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nothing/">nothing</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-Maya/">software.Maya</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-ps/">software.ps</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-vscode/">software.vscode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/win/">win</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algebra/" rel="tag">Algebra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS/" rel="tag">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BST/" rel="tag">BST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BVH/" rel="tag">BVH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CG-Algorithm/" rel="tag">CG-Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CV/" rel="tag">CV</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Code/" rel="tag">Code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB/" rel="tag">DB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/" rel="tag">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DSA/" rel="tag">DSA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dijkstra/" rel="tag">Dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EG/" rel="tag">EG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Floyd/" rel="tag">Floyd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GI/" rel="tag">GI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Glints/" rel="tag">Glints</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDR/" rel="tag">HDR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HQX/" rel="tag">HQX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Heap/" rel="tag">Heap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kits/" rel="tag">Kits</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCA/" rel="tag">LCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLG/" rel="tag">LLG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MCMC/" rel="tag">MCMC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MIS/" rel="tag">MIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MLT/" rel="tag">MLT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maya/" rel="tag">Maya</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NEE/" rel="tag">NEE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBRT/" rel="tag">PBRT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paper/" rel="tag">Paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Radiometry/" rel="tag">Radiometry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RayTracing/" rel="tag">RayTracing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SAH/" rel="tag">SAH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SDF/" rel="tag">SDF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SGJ/" rel="tag">SGJ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLServer/" rel="tag">SQLServer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shadow/" rel="tag">Shadow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WHM/" rel="tag">WHM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WX/" rel="tag">WX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/book/" rel="tag">book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/computation/" rel="tag">computation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csharp/" rel="tag">csharp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/images/" rel="tag">images</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/installation/" rel="tag">installation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/" rel="tag">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mitsuba/" rel="tag">mitsuba</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobaxterm/" rel="tag">mobaxterm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nothing/" rel="tag">nothing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/obs/" rel="tag">obs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/occlusion/" rel="tag">occlusion</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ps/" rel="tag">ps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/software/" rel="tag">software</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tree/" rel="tag">tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/win/" rel="tag">win</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xv6/" rel="tag">xv6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%83%E5%AE%87%E5%AE%99/" rel="tag">元宇宙</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%A0%E4%BD%95/" rel="tag">几何</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/" rel="tag">可见性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" rel="tag">拓扑排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%99%AE%E5%90%95%E5%85%8B%E5%9D%90%E6%A0%87/" rel="tag">普吕克坐标</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="tag">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algebra/" style="font-size: 10px;">Algebra</a> <a href="/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/tags/BST/" style="font-size: 10px;">BST</a> <a href="/tags/BVH/" style="font-size: 12.5px;">BVH</a> <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/CG/" style="font-size: 20px;">CG</a> <a href="/tags/CG-Algorithm/" style="font-size: 10px;">CG-Algorithm</a> <a href="/tags/CV/" style="font-size: 10.63px;">CV</a> <a href="/tags/Code/" style="font-size: 14.38px;">Code</a> <a href="/tags/DB/" style="font-size: 19.38px;">DB</a> <a href="/tags/DFS/" style="font-size: 12.5px;">DFS</a> <a href="/tags/DP/" style="font-size: 13.13px;">DP</a> <a href="/tags/DSA/" style="font-size: 11.25px;">DSA</a> <a href="/tags/Dijkstra/" style="font-size: 10px;">Dijkstra</a> <a href="/tags/EG/" style="font-size: 12.5px;">EG</a> <a href="/tags/Floyd/" style="font-size: 10.63px;">Floyd</a> <a href="/tags/GI/" style="font-size: 11.25px;">GI</a> <a href="/tags/Glints/" style="font-size: 10px;">Glints</a> <a href="/tags/HDR/" style="font-size: 10px;">HDR</a> <a href="/tags/HQX/" style="font-size: 10px;">HQX</a> <a href="/tags/Heap/" style="font-size: 10px;">Heap</a> <a href="/tags/Kits/" style="font-size: 13.75px;">Kits</a> <a href="/tags/LCA/" style="font-size: 10px;">LCA</a> <a href="/tags/LLG/" style="font-size: 12.5px;">LLG</a> <a href="/tags/MCMC/" style="font-size: 10.63px;">MCMC</a> <a href="/tags/MIS/" style="font-size: 10px;">MIS</a> <a href="/tags/MLT/" style="font-size: 10px;">MLT</a> <a href="/tags/Maya/" style="font-size: 10px;">Maya</a> <a href="/tags/MySQL/" style="font-size: 11.88px;">MySQL</a> <a href="/tags/NEE/" style="font-size: 10px;">NEE</a> <a href="/tags/OS/" style="font-size: 17.5px;">OS</a> <a href="/tags/PBRT/" style="font-size: 10px;">PBRT</a> <a href="/tags/Paper/" style="font-size: 15.63px;">Paper</a> <a href="/tags/Radiometry/" style="font-size: 10px;">Radiometry</a> <a href="/tags/RayTracing/" style="font-size: 10px;">RayTracing</a> <a href="/tags/SAH/" style="font-size: 10px;">SAH</a> <a href="/tags/SDF/" style="font-size: 10px;">SDF</a> <a href="/tags/SGJ/" style="font-size: 10.63px;">SGJ</a> <a href="/tags/SQL/" style="font-size: 13.13px;">SQL</a> <a href="/tags/SQLServer/" style="font-size: 10.63px;">SQLServer</a> <a href="/tags/STL/" style="font-size: 11.25px;">STL</a> <a href="/tags/Shadow/" style="font-size: 10px;">Shadow</a> <a href="/tags/WHM/" style="font-size: 16.88px;">WHM</a> <a href="/tags/WX/" style="font-size: 11.88px;">WX</a> <a href="/tags/YLQ/" style="font-size: 18.13px;">YLQ</a> <a href="/tags/book/" style="font-size: 10.63px;">book</a> <a href="/tags/computation/" style="font-size: 18.75px;">computation</a> <a href="/tags/csharp/" style="font-size: 16.25px;">csharp</a> <a href="/tags/images/" style="font-size: 10px;">images</a> <a href="/tags/installation/" style="font-size: 11.88px;">installation</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/linux/" style="font-size: 11.25px;">linux</a> <a href="/tags/math/" style="font-size: 10px;">math</a> <a href="/tags/mitsuba/" style="font-size: 11.88px;">mitsuba</a> <a href="/tags/mobaxterm/" style="font-size: 10px;">mobaxterm</a> <a href="/tags/nothing/" style="font-size: 10.63px;">nothing</a> <a href="/tags/obs/" style="font-size: 10px;">obs</a> <a href="/tags/occlusion/" style="font-size: 15px;">occlusion</a> <a href="/tags/ps/" style="font-size: 10px;">ps</a> <a href="/tags/software/" style="font-size: 10px;">software</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/tree/" style="font-size: 11.25px;">tree</a> <a href="/tags/vscode/" style="font-size: 10.63px;">vscode</a> <a href="/tags/win/" style="font-size: 10.63px;">win</a> <a href="/tags/xv6/" style="font-size: 16.25px;">xv6</a> <a href="/tags/%E4%BA%8C%E5%88%86/" style="font-size: 10.63px;">二分</a> <a href="/tags/%E5%85%83%E5%AE%87%E5%AE%99/" style="font-size: 10.63px;">元宇宙</a> <a href="/tags/%E5%87%A0%E4%BD%95/" style="font-size: 10px;">几何</a> <a href="/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/" style="font-size: 11.88px;">可见性</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 10.63px;">并查集</a> <a href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">拓扑排序</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%99%AE%E5%90%95%E5%85%8B%E5%9D%90%E6%A0%87/" style="font-size: 10px;">普吕克坐标</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 10px;">最小生成树</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" style="font-size: 13.13px;">最短路</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 10px;">线段树</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/23/CG/WHM-GAMES103/11/">GAMES103.王华民.11.Incompressible Fluid Dynamics and Eulerian Fluids</a>
          </li>
        
          <li>
            <a href="/2022/10/23/CG/Papers/2021/bvh-survey-3/">(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(4)</a>
          </li>
        
          <li>
            <a href="/2022/04/28/CG/Kits/MIS-NEE/">NEE、MIS(多重重要性采样)</a>
          </li>
        
          <li>
            <a href="/2022/04/18/CG/WHM-GAMES103/10/">GAMES103.王华民.10.Surface Waves</a>
          </li>
        
          <li>
            <a href="/2022/04/17/CG/WHM-GAMES103/09-1/">GAMES103.王华民.09.Collision Handling(1)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>