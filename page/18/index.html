<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/18/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-OS/xv6-labs/lab5-copyonwrite" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/10/OS/xv6-labs/lab5-copyonwrite/" class="article-date">
  <time class="dt-published" datetime="2021-05-10T04:00:00.000Z" itemprop="datePublished">2021-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OS-xv6-labs/">OS.xv6-labs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/10/OS/xv6-labs/lab5-copyonwrite/">xv6-labs-2020.lab5.Copy on Write</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="lab5-Copy-on-Write"><a href="#lab5-Copy-on-Write" class="headerlink" title="lab5 Copy-on-Write"></a>lab5 Copy-on-Write</h1><h2 id="1-作业链接"><a href="#1-作业链接" class="headerlink" title="1.作业链接"></a>1.作业链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/labs/cow.html">https://pdos.csail.mit.edu/6.828/2020/labs/cow.html</a></li>
</ul>
<h2 id="2-实习内容"><a href="#2-实习内容" class="headerlink" title="2. 实习内容"></a>2. 实习内容</h2><h3 id="2-1-说明"><a href="#2-1-说明" class="headerlink" title="2.1 说明"></a>2.1 说明</h3><ul>
<li>当调用 <code>fork()</code> 的时候，父进程会把其所有的内存都复制给子进程，但是实际上子进程可能都不会去使用这些内存中的内容（例如调用  <code>exec()</code> 自己设置内容）</li>
<li>利用写时复制的技术减少无用内存空间的复制</li>
<li>写时复制（copy-on-write）技术的要求<ul>
<li>延迟分配</li>
<li>在必要的时候才进行物理内存的复制<ul>
<li>例如父进程写，但是子进程使用的是写之前的内容，不能共享了</li>
</ul>
</li>
</ul>
</li>
<li>COW 技术说明<ul>
<li>当父进程调用 <code>fork()</code> 的时候，我们只是为子进程创建 pagetable，PTE 指向父进程的物理页，同时标记这段父子进程共享的内存区域为 <code>not writable</code></li>
<li>当某个进程试图去写这块区域的时候，触发 pagefault，此时开一块新的物理内存区域，把之前的内容复制过去，同时标记为 <code>writeable</code></li>
<li>对于原来的部分，如果变成独享，则可以标记为 <code>writeable</code></li>
<li>共享的区域 free 的时候，只有在最后一个进程 free 的时候才真正 free</li>
</ul>
</li>
</ul>
<h3 id="2-2-一些提示"><a href="#2-2-一些提示" class="headerlink" title="2.2 一些提示"></a>2.2 一些提示</h3><ul>
<li>修改 <code>vm.c:uvmcopy()</code> 实现复制的时候，只是将子进程的 PTE 指向父进程的物理页，同时把父子进程的共享的 PTE 都设置为 <code>not writable</code>（清空 PTE_W 位）<ul>
<li>注意 <code>uvmcopy()</code> 只被 <code>fork()</code> 调用</li>
</ul>
</li>
<li>修改 <code>trap.c:usertrap()</code> 识别出 COW 页上的 pagefault，然后调用 kalloc() 分配新的物理页，将旧的物理页复制过来，装载 PTE，设置为 <code>writable</code>（PTE_W 位设置为 1）</li>
<li>保证在 free 的时候，只有最后一个 PTE 引用 free 的时候才释放物理页<ul>
<li>可以为每一个物理页设置一个 <code>reference count</code></li>
<li><code>kalloc()</code> 分配的时候设置为 1</li>
<li><code>fork()</code> 的时候将计数器 +1<ul>
<li><code>uvmcopy()</code></li>
</ul>
</li>
<li><code>kfree()</code> 的时候将计数器 -1，若减到 0 则释放</li>
<li>计数器的实现可以用一个全局数组去记录<ul>
<li>初始化为全1，因为有一个 <code>kfree()</code> 的调用</li>
<li>通过物理地址整除 4096 （页大小）去访问</li>
</ul>
</li>
</ul>
</li>
<li>修改 <code>copyout()</code> 去处理内核态可能发生的 cow 导致的 pagefault<ul>
<li>处理的机制相同</li>
</ul>
</li>
<li>可以使用 PTE 中的保留位 RSW (reserved for software) 去记录 PTE 指向的页是不是 COW 页</li>
<li><code>kernel/riscv.h</code> 中有一些预定义的宏</li>
<li>如果 COW 触发 pagefault 时内存耗尽，应该把该进程 kill 掉</li>
</ul>
<h3 id="2-3-实习"><a href="#2-3-实习" class="headerlink" title="2.3 实习"></a>2.3 实习</h3><h4 id="1-如何维护引用计数"><a href="#1-如何维护引用计数" class="headerlink" title="(1) 如何维护引用计数"></a>(1) 如何维护引用计数</h4><ul>
<li>在 xv6 中，我们将 end 到 PHYSTOP 之间的区域用于动态的物理页分配，我们可以在这段区域的开头保留一段区域，将这段区域用于保存引用计数</li>
<li>如果直接保存在栈上的话，感觉太大了，可能会导致栈溢出</li>
<li>我们没有必要计算得很精确，可以直接把数组大小 CNT_INDEXS 设置为如下值</li>
</ul>
<p>$$<br>\dfrac{PHYSTOP-end}{PAGE_SIZE}<br>$$</p>
<ul>
<li>对于每个元素的大小，因为 xv6 最多只允许 64 个进程，因此我们使用一个 char 去记录就够了</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">    <span class="type">char</span> *ref_cnt; <span class="comment">// 用于记录 reference count 的一个数组</span></span><br><span class="line">    uint64 ref_start; <span class="comment">// 开始分配的物理内存的起始地址(用于计算偏移量)</span></span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="comment">// 数组元素为 char(最多 64 进程)</span></span><br><span class="line">    <span class="comment">// sizeof(char) = 1, 不需要乘</span></span><br><span class="line">    <span class="comment">// 计算大小(偏大)</span></span><br><span class="line">    uint64 size = ((uint64) pa_end - (uint64) pa_start) &gt;&gt; PGSHIFT;</span><br><span class="line">    <span class="comment">// 初始化为全 1</span></span><br><span class="line">    <span class="comment">// memset 逐字节设置</span></span><br><span class="line">    <span class="built_in">memset</span>(pa_start, <span class="number">1</span>, size);</span><br><span class="line">    <span class="comment">// 开始分配物理内存的位置</span></span><br><span class="line">    p = (<span class="type">char</span> *)pa_start + size;</span><br><span class="line">    p = (<span class="type">char</span> *)PGROUNDUP((uint64)p);</span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    <span class="comment">// 数组起始位置设置为 pa_start</span></span><br><span class="line">    kmem.ref_cnt = (<span class="type">char</span> *)pa_start;</span><br><span class="line">    kmem.ref_start = (uint64)p;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE) &#123;</span><br><span class="line">        kfree(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将 <code>kmem.ref_cnt</code> 全部初始化为 1，因为调用 <code>kfree()</code> 的时候，我们会将引用计数 -1<ul>
<li>这样刚好可以把所有的物理页的引用计数初始化为 0</li>
<li>但是起始并没有什么关系，我们每次分配的时候会将引用计数记为 0</li>
</ul>
</li>
<li>针对引用计数，我们增加一些辅助的函数<ul>
<li>具体的函数和解释见代码</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line">uint64          <span class="title function_">get_ref_cnt_index</span><span class="params">(uint64)</span>;</span><br><span class="line"><span class="type">char</span>            <span class="title function_">ref_increment</span><span class="params">(uint64, <span class="type">char</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="comment">/* 带锁 */</span></span><br><span class="line"><span class="comment">// 对引用计数进行 += inc 的操作</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">ref_increment</span><span class="params">(uint64 pa, <span class="type">char</span> inc)</span> &#123;</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="type">char</span> ans = (kmem.ref_cnt[get_ref_cnt_index(pa)] += inc);</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不带锁 */</span></span><br><span class="line"><span class="comment">// 获取引用计数</span></span><br><span class="line">uint64 <span class="title function_">get_ref_cnt_index</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">  uint64 ans = (pa - kmem.ref_start) &gt;&gt; PGSHIFT;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-kalloc-x2F-kfree"><a href="#2-kalloc-x2F-kfree" class="headerlink" title="(2) kalloc&#x2F;kfree"></a>(2) kalloc&#x2F;kfree</h4><ul>
<li>在 <code>kalloc()</code> 分配页得时候，将引用计数置为 1</li>
<li>在 <code>kfree()</code> 释放页得时候，修改并判断引用计数是否为 0<ul>
<li>如果为 0 则放回空的链表</li>
<li>如果不为 0 则直接返回</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(r) &#123;</span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">        <span class="comment">// 注意 get_ref_cnt_index() 函数是不加锁的, 因此需要在外面加锁</span></span><br><span class="line">        kmem.ref_cnt[get_ref_cnt_index((uint64)r)] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">char</span> num = ref_increment((uint64)pa, (<span class="type">char</span>)<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 引用计数不为 0</span></span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-修改-uvmcopy"><a href="#3-修改-uvmcopy" class="headerlink" title="(3) 修改 uvmcopy()"></a>(3) 修改 uvmcopy()</h4><ul>
<li>复制的时候，将子进程的 PTE 指向父进程的物理地址即可，不需要重新分配</li>
<li>判断 PTE 指向的物理页是否可写<ul>
<li>如果可写，同时修改 PTE 为 <code>not writable</code>，并设置 PTE 的 PTE_COW 位（RSW 的低位，第 8 位）</li>
<li>如果不可写，则不需要设置 PTE_COW &#x2F; PTE_W 位</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/riscv.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 8) <span class="comment">// COW</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span> &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa, i;</span><br><span class="line">    uint64 flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">        <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">        pa = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 之前的 PTE_W, PTE_COW</span></span><br><span class="line">        uint64 pte_w_cow_before = *pte &amp; (PTE_W|PTE_COW);</span><br><span class="line">        <span class="comment">// 对于可以进行写操作的 PTE, 我们才使用 COW 策略</span></span><br><span class="line">        <span class="comment">// 如果这个页不可写, 我们直接不复制即可</span></span><br><span class="line">        <span class="keyword">if</span>(*pte &amp; PTE_W) &#123;</span><br><span class="line">            *pte ^= PTE_W; <span class="comment">// *pte &amp;= ~PTE</span></span><br><span class="line">            *pte |= PTE_COW;</span><br><span class="line">        &#125;</span><br><span class="line">        flags = PTE_FLAGS(*pte);</span><br><span class="line">        <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// kfree(mem);</span></span><br><span class="line">            <span class="comment">// 恢复原来的 flags</span></span><br><span class="line">            *pte &amp;= ~(PTE_COW | PTE_W);</span><br><span class="line">            *pte |= pte_w_cow_before;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 引用计数 +1</span></span><br><span class="line">        ref_increment(pa, (<span class="type">char</span>)<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-识别-pagefault"><a href="#4-识别-pagefault" class="headerlink" title="(4) 识别 pagefault"></a>(4) 识别 pagefault</h4><ul>
<li>类似于 lazy allocation，我们需要在 <code>usertrap()</code> 中识别 COW 导致的 pagefault</li>
<li>为了方便，我们封装成一个函数 <code>cow_handler()</code><ul>
<li>判断是否是由于 COW 导致的 pagefault</li>
<li>处理引用计数</li>
<li>重新分配物理内存</li>
<li>在重新分配内存的时候，我们需要进行的操作是直接修改返回的 PTE<ul>
<li>因为这 3 级页表的映射关系还是存在的，我们只需要将第 3 级页表中存储的 PTE 直接修改为 <code>PPN|flags</code></li>
<li>其中 PPN 是新分配的物理地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"><span class="comment">// vm.c</span></span><br><span class="line">uint64          <span class="title function_">cow_handler</span><span class="params">(<span class="type">pagetable_t</span>, uint64)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/traps.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">0xf</span> || r_scause() == <span class="number">0xd</span>) &#123;</span><br><span class="line">        <span class="comment">// page fault</span></span><br><span class="line">        <span class="comment">// 获取虚拟页位置</span></span><br><span class="line">        uint64 va = r_stval();</span><br><span class="line">        <span class="keyword">if</span>(cow_handler(p-&gt;pagetable, va) == <span class="number">0</span>) &#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="comment">/* va 需要对齐 */</span></span><br><span class="line">uint64 <span class="title function_">cow_handler</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 不是 COW 页</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_COW) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有内存了</span></span><br><span class="line">    <span class="type">char</span> *mem;</span><br><span class="line">    <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">    uint64 flags = PTE_FLAGS(*pte);</span><br><span class="line">    kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    flags = (flags &amp; ~PTE_COW) | PTE_W;</span><br><span class="line">    *pte = PA2PTE((uint64)mem) | flags;</span><br><span class="line">    <span class="keyword">return</span> (uint64)mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-识别内核态的-cow-导致的-pagefault"><a href="#5-识别内核态的-cow-导致的-pagefault" class="headerlink" title="(5) 识别内核态的 cow 导致的 pagefault"></a>(5) 识别内核态的 cow 导致的 pagefault</h4><ul>
<li>这会发生在函数 <code>copyout()</code> 中，于是我们采用相同的策略，这里需要先判断是否是</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span> &#123;</span><br><span class="line">    uint64 n, va0, pa0;</span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        va0 = PGROUNDDOWN(dstva);</span><br><span class="line">        <span class="keyword">if</span> (va0 &gt;= MAXVA)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 先判断是不是 COW 页</span></span><br><span class="line">        <span class="type">pte_t</span>* pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 不是 COW 页</span></span><br><span class="line">        <span class="keyword">if</span>((*pte &amp; PTE_COW) == <span class="number">0</span>) &#123;</span><br><span class="line">            pa0 = walkaddr(pagetable, va0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pa0 = cow_handler(pagetable, va0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3. 实验结果"></a>3. 实验结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu-gdb</span><br><span class="line">(24.2s)</span><br><span class="line">== Test   simple ==</span><br><span class="line">  simple: OK</span><br><span class="line">== Test   three ==</span><br><span class="line">  three: OK</span><br><span class="line">== Test   file ==</span><br><span class="line">  file: OK</span><br><span class="line">== Test usertests ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(211.7s)</span><br><span class="line">== Test   usertests: copyin ==</span><br><span class="line">  usertests: copyin: OK</span><br><span class="line">== Test   usertests: copyout ==</span><br><span class="line">  usertests: copyout: OK</span><br><span class="line">== Test   usertests: all tests ==</span><br><span class="line">  usertests: all tests: OK</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 110/110</span><br></pre></td></tr></table></figure>



<h2 id="4-遇到的困难以及收获"><a href="#4-遇到的困难以及收获" class="headerlink" title="4. 遇到的困难以及收获"></a>4. 遇到的困难以及收获</h2><ul>
<li>这个 lab 想起来难度并不是很大，思路在网页中也写得很清楚，但是很多细节还是很花费时间的</li>
<li>做完 lab 之后对于 cow 整体的实现也有了更加深入的理解</li>
<li>同时对一些细节的处理也让我收获颇丰，例如这里关于 PTE 的处理，直接修改 PTE 的内容而不是重新映射，这样的设计确实很巧妙</li>
<li>同时通过 lazy allocation 和 cow 这两个 lab，也让我们意识到了，在设计的过程中要同时考虑用户态的内核态的异常<ul>
<li>例如 pagefault<ul>
<li>用户态的 pagefault 可以在 <code>usertrap()</code> 中考虑（产生后利用异常机制处理）</li>
<li>内核态的 pagefault 需要在 <code>copyout()</code> 中考虑（产生的地方）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-对课程或-lab-的意见和建议"><a href="#5-对课程或-lab-的意见和建议" class="headerlink" title="5. 对课程或 lab 的意见和建议"></a>5. 对课程或 lab 的意见和建议</h2><ul>
<li>暂时没有意见</li>
</ul>
<h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf">https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/labs/cow.html">https://pdos.csail.mit.edu/6.828/2020/labs/cow.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/10/OS/xv6-labs/lab5-copyonwrite/" data-id="cl9lj74bc00iq64tzd9gj7aqm" data-title="xv6-labs-2020.lab5.Copy on Write" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xv6/" rel="tag">xv6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OS/xv6-source-code/04-VM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/09/OS/xv6-source-code/04-VM/" class="article-date">
  <time class="dt-published" datetime="2021-05-09T05:00:00.000Z" itemprop="datePublished">2021-05-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OS-xv6-source-code/">OS.xv6-source-code</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/09/OS/xv6-source-code/04-VM/">xv6-riscv-源代码阅读.虚存管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="XV6-源代码阅读——虚存管理"><a href="#XV6-源代码阅读——虚存管理" class="headerlink" title="XV6 源代码阅读——虚存管理"></a>XV6 源代码阅读——虚存管理</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>阅读的代码是 <code>xv6-riscv</code> 版本的</li>
<li>涉及到的文件如下<ul>
<li><code>kernel</code><ul>
<li><code>kalloc.c</code>、<code>vm.c</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h2><blockquote>
<p>XV6 初始化之后到执行 main.c 时，内存布局是怎样的（其中已有哪些内容）？</p>
</blockquote>
<h3 id="xv6-的启动流程（main-c-之前）"><a href="#xv6-的启动流程（main-c-之前）" class="headerlink" title="xv6 的启动流程（main.c 之前）"></a>xv6 的启动流程（main.c 之前）</h3><ul>
<li><p>xv6 的启动过程在之前的进程线程源代码阅读中已经说过了，这里只展示和内存分布相关的部分</p>
</li>
<li><p>kernel&#x2F;kernel.ld</p>
<ul>
<li>当 xv6 的系统启动的时候，首先会启动一个引导加载程序（存在 ROM 里面），之后装载内核程序进内存</li>
<li>引导加载程序把内核代码加载到物理地址为 0x8000000 的地方（0x0 - 0x80000000 之间有 I&#x2F;O 设备）</li>
<li>设置 ENTRY 为_entry，开始执行 kernel&#x2F;entry.S 的代码</li>
</ul>
</li>
<li><p>kernel&#x2F;entry.S</p>
<ul>
<li>注意由于只有一个内核栈，内核栈部分的地址空间可以是固定，因此 xv6 启动的时候并没有开启硬件支持的 paging 策略，也就是说，对于内核栈而言，它的物理地址和虚拟地址是一样的</li>
<li>在机器模式下，CPU 从 _entry 处开始执行操作系统的代码</li>
<li>首先需要给内核开辟一个栈，从而可以执行 C 代码</li>
<li>每一个 CPU 都应该有自己的栈（xv6 最多支持 8 个 CPU），开始每个内核栈的大小为 4096 byte，地址空间向下增长</li>
<li>最后设置调用 kernel&#x2F;start.c 中的 start 函数</li>
</ul>
</li>
<li><p>kernel&#x2F;start.c</p>
<ul>
<li>主要是配置一些寄存器和机器状态等</li>
<li>例如打开时钟中断、设置中断等</li>
<li>跳转到 kernel&#x2F;main.c</li>
</ul>
</li>
</ul>
<h3 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h3><ul>
<li>xv6 的<span id="vmd">内存分布</span>如下</li>
</ul>
<img src="04-VM/image-20210509145509177.png" style="zoom:67%;" />

<ul>
<li>根据上面的描述，在执行到 main.c 之前，在内存中 Kernel text 、Kernel data、UART0、PLIC、CLINT、VIRTIO 是已经存在了的，通过引导程序加载进了内存</li>
</ul>
<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h2><blockquote>
<p>XV6 的动态内存管理是如何完成的？有一个kmem（链表），用于管理可分配的物理内存页</p>
<p>（vend&#x3D;0x00400000，也就是可分配的内存页最大为4Mb）</p>
</blockquote>
<ul>
<li>xv6 的动态内存管理指的是怎么去管理物理内存</li>
<li>xv6 将 Kernel data 以上，PHYSTOP 以下的区域用于作为物理内存的分配，将其划分为页的形式，然后保存在数据结构 <code>kmem</code> 中，<code>kmem</code> 中保存着一个链表，这个链表保存着所有空闲的物理内存</li>
<li>xv6 的物理内存分配与回收都是按页进行的</li>
<li>当需要申请一块物理内存的时候，我们调用 <code>kalloc()</code> 从 <code>kmem</code> 中申请一页（链表头部申请一页），当需要时放一块内存的时候，我们调用 <code>kfree()</code> 将内存还给 <code>kmem</code>（插入到链表的开头）</li>
</ul>
<h2 id="问题-3"><a href="#问题-3" class="headerlink" title="问题 3"></a>问题 3</h2><blockquote>
<p>XV6 的虚拟内存是如何初始化的？画出 XV6 的虚拟内存布局图，请说出每一部分对应的内容是什么</p>
<p>见 memlayout.h 和 vm.c 的 kmap 上的注释</p>
</blockquote>
<ul>
<li>虚拟内存的初始化是在 <code>main.c</code> 中实现的</li>
<li><a href="#vmd">内存分布图如上</a></li>
</ul>
<h3 id="main-c-的操作"><a href="#main-c-的操作" class="headerlink" title="main.c 的操作"></a>main.c 的操作</h3><h4 id="kinit"><a href="#kinit" class="headerlink" title="kinit()"></a>kinit()</h4><ul>
<li>调用 <code>kinit()</code> 对物理页进行一个组织<ul>
<li>将 Kernel data 以上，PHYSTOP 以下的区域用于作为物理内存的分配</li>
<li>因为 xv6 分配物理页是按页分配的，需要将这个区域两端取整，然后按页划分，保存在结构体 <code>kmem</code>  的 <code>freelist</code> 中</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>



<h4 id="kvminit"><a href="#kvminit" class="headerlink" title="kvminit()"></a>kvminit()</h4><ul>
<li>调用 <code>kvminit()</code> 对内核的页表进行初始化，调用 <code>kvmmake()</code> 实现</li>
<li>直接映射（物理地址和虚拟地址相同）生成如下的页表（为了使用统一的页表映射策略）<ul>
<li>UART0：Universal Asynchronous Receiver&#x2F;Transmitter</li>
<li>VIRTIO0：virtio disk</li>
<li>PLIC：Platform-Level Interrupt Controller</li>
<li>Kernel text（内核代码段）</li>
<li>Kernel data（内核数据段）</li>
</ul>
</li>
<li>对 <code>TRAMPOLINE</code> 进行虚拟映射</li>
<li>映射内核栈，为每一个进程分配一个页的内核栈，在两个内核栈之间分配一个 guard page，用于检测栈溢出</li>
<li>接下来就是初始一些数据结构 <code>proc</code> 等</li>
<li>以上的建立起虚拟地址和物理地址的映射是通过函数 <code>mappages()</code> 实现的，实现的大致逻辑如下<ul>
<li>首先通过 <code>walk()</code> 在已经存在的页表项中检索，如果找到一个有效的页表项，则报错 <code>remap</code></li>
<li>如果找不到（正常的情况下应该是找不到），此时建立起映射即可，也就是在页表项（第 3 级页表）设置 PPN 的值和物理页的基地址相同，同时设置权限位</li>
</ul>
</li>
</ul>
<h2 id="问题-4"><a href="#问题-4" class="headerlink" title="问题 4"></a>问题 4</h2><blockquote>
<p>关于XV6 的内存页式管理。发生中断时，用哪个页表？一个内页是多大？页目录有多少项？页表有多少项？最大支持多大的内存？画出从虚拟地址到物理地址的转换图。在XV6 中，是如何将虚拟地址与物理地址映射的（调用了哪些函数实现了哪些功能）？</p>
</blockquote>
<h3 id="3-级页表"><a href="#3-级页表" class="headerlink" title="3 级页表"></a>3 级页表</h3><ul>
<li>xv6 的页式管理，xv6 通过 3 级页表实现，具体实现如下图</li>
</ul>
<img src="04-VM/image-20210509193047497.png" style="zoom:80%;" />

<ul>
<li>虚拟地址中首先保存着 4 个偏移量 L2、L1、L0、Offset</li>
<li>通过 satp 寄存器读取到第一级页表的基地址，通过 L2 找到 PPN1</li>
<li>PPN1 中记录的第二级页表的基地址，通过 L1 找到 PPN2</li>
<li>PPN2 记录着第三级页表的基地址，通过 L2 找到 PPN</li>
<li>PPN 和 页内偏移量 Offset 组合形成最终的物理地址</li>
<li>具体是通过函数 <code>walkaddr()</code> 实现的，其中三级页表的翻译是通过 <code>walk()</code> 实现的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 判断是否合法并返回物理页的基地址 */</span></span><br><span class="line">uint64 <span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa;</span><br><span class="line">    <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 找到最后一级页表(第3级页表)对应的 PTE */</span></span><br><span class="line"><span class="type">pte_t</span> * <span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">        panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">        <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">            pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">            *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><ul>
<li>发生中断时，将 CPU 上进程的第一级页表的及地址存入 stap 寄存器，同时清空 TLB</li>
<li>也就是说，将当前页表替换为触发中断的进程的页表，紧接着之后的查找都是在新的页表上执行，具体的翻译步骤就是通过上面的 3 级页表翻译</li>
<li>其中每一级页表都有 512 个页表项，支持内存大小可达 $2^{39}$</li>
<li>清空 TLB 的操作是由如下命令执行的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">sfence_vma</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// the zero, zero means flush all TLB entries.</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sfence.vma zero, zero&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="虚拟地址空间设计"><a href="#虚拟地址空间设计" class="headerlink" title="虚拟地址空间设计"></a>虚拟地址空间设计</h3><ul>
<li>xv6-riscv 的设计和其他的设计不太一样，xv6 的设计中内核态拥有自己的一个页表，这就是说对于 xv6 来说，用户态和内核态的虚拟地址空间都可以达到 0 - MAXVA，这样的设计的好处似乎还挺多<ul>
<li>首先我们可以看到，可以分配的空间变大了</li>
<li>在内核态分配空间的时候不需要考虑和用户态是否有交集了<ul>
<li>当然直接将内核态和用户态分离开也能马上实现没有交集的效果</li>
</ul>
</li>
<li>当然也存在一些问题，比在在陷入内核、退出内核的时候都需要对 TLB 进行一个清空的操作，这样增大了 TLB miss 的概率，导致效率有所下降</li>
</ul>
</li>
<li>用户空间的虚拟地址范围如下</li>
</ul>
<img src="04-VM/image-20210509222041197.png" style="zoom:60%;" />



<h3 id="内核态的-CPU-栈与内核栈"><a href="#内核态的-CPU-栈与内核栈" class="headerlink" title="内核态的 CPU 栈与内核栈"></a>内核态的 CPU 栈与内核栈</h3><ul>
<li>一开始系统启动的时候为每一个 CPU 都分配了一个栈，这个栈是为了每个 CPU 的前期初始化操作以及调度程序准备的</li>
<li>我们可以认为在内核态下，其实是存在两个线程的，一个线程是调度线程，一个线程是由用户态的 trap 进入的</li>
<li>因此这两个线程也是需要有自己的栈的</li>
<li>所以这样的设计是没有问题的，而且在一定程度上讲确实得这么设计</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv">https://github.com/mit-pdos/xv6-riscv</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/09/OS/xv6-source-code/04-VM/" data-id="cl9lj74b800hz64tz93a09cqe" data-title="xv6-riscv-源代码阅读.虚存管理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xv6/" rel="tag">xv6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OS/xv6-labs/lab4-lazy-allocation" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/08/OS/xv6-labs/lab4-lazy-allocation/" class="article-date">
  <time class="dt-published" datetime="2021-05-08T04:00:00.000Z" itemprop="datePublished">2021-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OS-xv6-labs/">OS.xv6-labs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/08/OS/xv6-labs/lab4-lazy-allocation/">xv6-labs-2020.lab4.lazy page allocation</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="lab4-lazy-page-allocation"><a href="#lab4-lazy-page-allocation" class="headerlink" title="lab4: lazy page allocation"></a>lab4: lazy page allocation</h1><h2 id="1-作业链接"><a href="#1-作业链接" class="headerlink" title="1.作业链接"></a>1.作业链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/labs/cow.html">https://pdos.csail.mit.edu/6.828/2020/labs/cow.html</a></li>
</ul>
<h2 id="2-实习内容"><a href="#2-实习内容" class="headerlink" title="2. 实习内容"></a>2. 实习内容</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>子进程</p>
<ul>
<li>阅读给定文档的 Chapter 03&#x2F;04</li>
</ul>
<h3 id="P1-Eliminate-allocation-from-sbrk"><a href="#P1-Eliminate-allocation-from-sbrk" class="headerlink" title="P1: Eliminate allocation from sbrk()"></a>P1: Eliminate allocation from sbrk()</h3><ul>
<li>修改系统调用 <code>sbrk()</code>，让其只增加进程的大小 <code>myproc()-&gt;sz</code>，返回未增长前的的地址，不分配新的内存空间</li>
<li>直接修改文件 <code>kernel/sysproc.c</code> 中的函数 <code>sys_sbrk()</code> 即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c:sys_sbrk()</span></span><br><span class="line">uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 注意地址要写成 uint64, 原来的代码里面写的是 int</span></span><br><span class="line">    <span class="comment">// 导致最后会有 panic(&quot;walk&quot;)</span></span><br><span class="line">    <span class="comment">// 截断导致最终 p-&gt;sz 变成负数(f开头)</span></span><br><span class="line">    uint64 addr;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    addr = myproc()-&gt;sz;</span><br><span class="line">    <span class="comment">// if(growproc(n) &lt; 0)</span></span><br><span class="line">    <span class="comment">//  return -1;</span></span><br><span class="line">    myproc()-&gt;sz = addr + n;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这样的修改势必会导致在读取地址的时候导致 page fault，因为没有分配内存，虚拟映射失败</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hi</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usertrap(): unexpected scause 0x000000000000000f pid=3</span><br><span class="line">            sepc=0x00000000000012ac stval=0x0000000000004008</span><br><span class="line">panic: uvmunmap: not mapped</span><br></pre></td></tr></table></figure>



<h3 id="P2-Lazy-allocation"><a href="#P2-Lazy-allocation" class="headerlink" title="P2: Lazy allocation"></a>P2: Lazy allocation</h3><ul>
<li>响应上面的 page fault，从而能够让程序良好运行</li>
<li>需要在 <code>usertrap()</code> 调用 <code>printf()</code> 之前加入一些代码进行 page fault 的判断</li>
<li>可能需要修改一些其它地方的代码</li>
</ul>
<h4 id="1-一些提示"><a href="#1-一些提示" class="headerlink" title="(1) 一些提示"></a>(1) 一些提示</h4><ul>
<li>可以通过 <code>r_scause()</code> 为 13 或者 15 来判断当前是否触发的是 <code>pagefault</code></li>
<li><code>r_stval()</code> 返回导致异常的虚拟地址</li>
<li>仿照 <code>vm.c</code> 中的 <code>uvmalloc()</code> 代码进行分配内存<ul>
<li>原来 <code>sbrk()</code> 通过调用 <code>growproc()</code> 间接调用到 <code>uvmalloc()</code></li>
<li>需要调用 <code>kalloc()</code> 以及 <code>mappages()</code></li>
</ul>
</li>
<li>使用 <code>PGROUNDDOWN(va)</code> 可以获取到当前虚拟页的最小地址</li>
<li><code>uvmunmap()</code> 会调用 <code>panic()</code>，如果是因为没有映射造成的话，我们应该不让他调用</li>
<li><code>kernel/kernel.asm</code> 中保存着汇编代码，如果发生错误可以查看这部分代码</li>
<li>如果报错 <code>incomplete type proc</code><ul>
<li>include “spinlock.h” then “proc.h”.</li>
</ul>
</li>
</ul>
<h4 id="2-修改-usertrap"><a href="#2-修改-usertrap" class="headerlink" title="(2) 修改 usertrap()"></a>(2) 修改 usertrap()</h4><ul>
<li>判断异常是否为 pagefault</li>
<li>如果是则正确分配一页物理页</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c:usertrap()</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0xf</span> || scause == <span class="number">0xd</span>) &#123;</span><br><span class="line">    <span class="comment">// Page Fault Code Start</span></span><br><span class="line">    uint64 scause = r_scause();</span><br><span class="line">    <span class="comment">// 判断是否为 pagefault</span></span><br><span class="line">    <span class="comment">// 获取虚拟页位置</span></span><br><span class="line">    uint64 vm_addr = r_stval();</span><br><span class="line">    vm_addr = PGROUNDDOWN(vm_addr);</span><br><span class="line">    <span class="type">pagetable_t</span> pagetable = myproc()-&gt;pagetable;</span><br><span class="line">    <span class="type">char</span> *mem;</span><br><span class="line">    <span class="comment">// 为虚拟页分配一页物理页</span></span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="comment">// 当分配不到物理页时的处理</span></span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>) &#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刷零</span></span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, vm_addr, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">        kfree(mem);</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Page Fault Code End</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>同时我们要把由于 pagefault 导致的 <code>panic()</code> 取消<ul>
<li>注释掉如下代码</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c:uvmunmap()</span></span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: not mapped&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>由于我们现在只是实现了 lazy 的分配，还需要解决这样一个问题，如果申请了一块内存，但是尚未分配映射，此时我们不需要进行 <code>kfree()</code> 操作</li>
<li>整段代码修改如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c:uvmunmap()</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="comment">// 分配了而且映射了的内存才需要释放</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// panic(&quot;uvmunmap: walk&quot;);</span></span><br><span class="line">    <span class="comment">// if((*pte &amp; PTE_V) == 0)</span></span><br><span class="line">    <span class="comment">// panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">        panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="comment">// 分配了而且映射了的内存才需要释放</span></span><br><span class="line">    <span class="keyword">if</span>(do_free &amp;&amp; (*pte &amp; PTE_V) != <span class="number">0</span>)&#123;</span><br><span class="line">        uint64 pa = PTE2PA(*pte);</span><br><span class="line">        kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>此时运行 <code>echo hi</code>，能够正确的输出 <code>hi</code></li>
</ul>
<h3 id="P3-Lazytests-and-Usertests"><a href="#P3-Lazytests-and-Usertests" class="headerlink" title="P3: Lazytests and Usertests"></a>P3: Lazytests and Usertests</h3><ul>
<li>处理一些细节问题</li>
<li>实现 <code>sbrk()</code> 中参数为负的情况</li>
<li>如果请求的虚拟地址，比当前进程通过 <code>sbrk()</code> 申请的最高地址要高的话，<code>kill</code> 掉</li>
<li>内核态访问的的内存已申请，但是尚未分配映射<ul>
<li>You can fix it by add code in <code>walkaddr()</code> in <code>kernel/vm.c:104</code>, as any r&#x2F;w syscall will invoke <code>walkaddr</code> to get physical address.</li>
</ul>
</li>
<li>能够处理 <code>fork()</code> 中父子进程的内存复制</li>
<li><code>kalloc()</code> 失败的时候，<code>kill</code> 掉当前进程<ul>
<li>已经实现</li>
</ul>
</li>
<li>解决栈溢出的问题，栈的大小只有一页，不能访问栈之外的空间</li>
</ul>
<h4 id="1-sbrk-参数为负"><a href="#1-sbrk-参数为负" class="headerlink" title="(1) sbrk() 参数为负"></a>(1) sbrk() 参数为负</h4><ul>
<li>直接调用 <code>uvmunmap()</code> 释放即可</li>
<li>简单实现，我们可以直接调用 <code>growproc()</code> 实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c:sys_sbrk()</span></span><br><span class="line">uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    uint64 addr;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    addr = myproc()-&gt;sz;</span><br><span class="line">    <span class="comment">// if(growproc(n) &lt; 0)</span></span><br><span class="line">    <span class="comment">//  return -1;</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        myproc()-&gt;sz = addr + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-访问到未申请的空间"><a href="#2-访问到未申请的空间" class="headerlink" title="(2) 访问到未申请的空间"></a>(2) 访问到未申请的空间</h4><ul>
<li>判断访问的虚拟地址是否已经申请</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c:usertrap()</span></span><br><span class="line"><span class="keyword">if</span>(vm_addr &gt;= p-&gt;sz) &#123;</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-栈溢出"><a href="#3-栈溢出" class="headerlink" title="(3) 栈溢出"></a>(3) 栈溢出</h4><ul>
<li>因为栈的大小只有一页，我们可以通过 <code>myproc()-&gt;trapframe-&gt;sp</code> 获取到当前栈所在的页</li>
<li>然后使用 <code>PGROUNDDOWN</code> 以及 <code>PGROUNDUP</code> 获取到边界</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c:usertrap()</span></span><br><span class="line"><span class="comment">// 用户栈溢出</span></span><br><span class="line">uint64 ustack = p-&gt;trapframe-&gt;sp;</span><br><span class="line"><span class="keyword">if</span>(vm_addr &lt; PGROUNDDOWN(ustack)) &#123;</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-fork-问题"><a href="#4-fork-问题" class="headerlink" title="(4) fork 问题"></a>(4) fork 问题</h4><ul>
<li>调用 fork 的时候，如果父进程存在一些申请了但是尚未分配映射的内存，子进程就不需要 copy 了</li>
<li>在进行 <code>uvmcopy()</code> 的时候进行修改，如果 pte 不存在，则不复制，而不是报错</li>
<li>修改如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// panic(&quot;uvmcopy: pte should exist&quot;);</span></span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// panic(&quot;uvmcopy: page not present&quot;);</span></span><br></pre></td></tr></table></figure>





<h4 id="5-内核态的内存操作"><a href="#5-内核态的内存操作" class="headerlink" title="(5) 内核态的内存操作"></a>(5) 内核态的内存操作</h4><ul>
<li>如果内核态需要操作一个申请了但是尚未分配映射的空间时，需要进行处理</li>
<li>例如 <code>write()</code> 的内存尚未分配映射</li>
<li>在 <code>walkaddr()</code> 中加入判断<ul>
<li>如果出现找不到页的情况，马上分配</li>
<li>具体的分配页的判断和 <code>usertrap()</code> 中的一样，于是我们将其封装为一个函数</li>
</ul>
</li>
</ul>
<h4 id="6-最终的修改情况"><a href="#6-最终的修改情况" class="headerlink" title="(6) 最终的修改情况"></a>(6) 最终的修改情况</h4><ul>
<li><code>kernel/defs.h</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vm.c</span></span><br><span class="line">uint64          <span class="title function_">alloc_page</span><span class="params">(<span class="keyword">struct</span> proc*, uint64)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/vm.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加一个 lazy allocation 的函数</span></span><br><span class="line">uint64 <span class="title function_">alloc_page</span><span class="params">(<span class="keyword">struct</span> proc* p, uint64 vm_addr)</span>&#123;</span><br><span class="line">    <span class="comment">// 访问的虚拟地址没有申请</span></span><br><span class="line">    <span class="comment">// 虚拟地址越界</span></span><br><span class="line">    <span class="keyword">if</span>(vm_addr &gt;= p-&gt;sz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用户栈溢出</span></span><br><span class="line">    uint64 ustack = p-&gt;trapframe-&gt;sp;</span><br><span class="line">    <span class="keyword">if</span>(vm_addr &lt; (uint64)PGROUNDDOWN(ustack)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vm_addr = PGROUNDDOWN(vm_addr);</span><br><span class="line">    <span class="type">pagetable_t</span> pagetable = p-&gt;pagetable;</span><br><span class="line">    <span class="type">char</span> *mem;</span><br><span class="line">    <span class="comment">// 为虚拟页分配一页物理页</span></span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="comment">// 当分配不到物理页时的处理</span></span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刷零</span></span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, vm_addr, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">        kfree(mem);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (uint64)mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// uvmcopy()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// panic(&quot;uvmcopy: pte should exist&quot;);</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// panic(&quot;uvmcopy: page not present&quot;);</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// uvmunmap()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// panic(&quot;uvmunmap: walk&quot;);</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配了而且映射了的内存才需要释放</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// walkaddr()</span></span><br><span class="line">uint64 <span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">    <span class="comment">// if(pte == 0)</span></span><br><span class="line">    <span class="comment">//   return 0;</span></span><br><span class="line">    <span class="comment">// if((*pte &amp; PTE_V) == 0)</span></span><br><span class="line">    <span class="comment">//   return 0;</span></span><br><span class="line">    <span class="comment">// if((*pte &amp; PTE_U) == 0)</span></span><br><span class="line">    <span class="comment">//   return 0;</span></span><br><span class="line">    <span class="title function_">if</span><span class="params">(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span>)</span> &#123;</span><br><span class="line">        pa = alloc_page(myproc(), va);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pa = PTE2PA(*pte);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/sysproc.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    uint64 addr;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    p = myproc();</span><br><span class="line">    addr = p-&gt;sz;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;sz = addr + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/trap.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span> || r_scause() == <span class="number">13</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = alloc_page(p, r_stval());</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3. 实验结果"></a>3. 实验结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu-gdb</span><br><span class="line">(26.0s)</span><br><span class="line">== Test   lazy: map ==</span><br><span class="line">  lazy: map: OK</span><br><span class="line">== Test   lazy: unmap ==</span><br><span class="line">  lazy: unmap: OK</span><br><span class="line">== Test usertests ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">Timeout! (300.9s)</span><br><span class="line">== Test   usertests: pgbug ==</span><br><span class="line">  usertests: pgbug: OK</span><br><span class="line">== Test   usertests: sbrkbugs ==</span><br><span class="line">  usertests: sbrkbugs: OK</span><br><span class="line">== Test   usertests: argptest ==</span><br><span class="line">  usertests: argptest: OK</span><br><span class="line">== Test   usertests: sbrkmuch ==</span><br><span class="line">  usertests: sbrkmuch: OK</span><br><span class="line">== Test   usertests: sbrkfail ==</span><br><span class="line">  usertests: sbrkfail: OK</span><br><span class="line">== Test   usertests: sbrkarg ==</span><br><span class="line">  usertests: sbrkarg: OK</span><br><span class="line">== Test   usertests: stacktest ==</span><br><span class="line">  usertests: stacktest: OK</span><br><span class="line">== Test   usertests: execout ==</span><br><span class="line">  usertests: execout: OK</span><br><span class="line">== Test   usertests: copyin ==</span><br><span class="line">  usertests: copyin: OK</span><br><span class="line">== Test   usertests: copyout ==</span><br><span class="line">  usertests: copyout: OK</span><br><span class="line">== Test   usertests: copyinstr1 ==</span><br><span class="line">  usertests: copyinstr1: OK</span><br><span class="line">== Test   usertests: copyinstr2 ==</span><br><span class="line">  usertests: copyinstr2: OK</span><br><span class="line">== Test   usertests: copyinstr3 ==</span><br><span class="line">  usertests: copyinstr3: OK</span><br><span class="line">== Test   usertests: rwsbrk ==</span><br><span class="line">  usertests: rwsbrk: OK</span><br><span class="line">== Test   usertests: truncate1 ==</span><br><span class="line">  usertests: truncate1: OK</span><br><span class="line">== Test   usertests: truncate2 ==</span><br><span class="line">  usertests: truncate2: OK</span><br><span class="line">== Test   usertests: truncate3 ==</span><br><span class="line">  usertests: truncate3: OK</span><br><span class="line">== Test   usertests: reparent2 ==</span><br><span class="line">  usertests: reparent2: OK</span><br><span class="line">== Test   usertests: badarg ==</span><br><span class="line">  usertests: badarg: OK</span><br><span class="line">== Test   usertests: reparent ==</span><br><span class="line">  usertests: reparent: OK</span><br><span class="line">== Test   usertests: twochildren ==</span><br><span class="line">  usertests: twochildren: OK</span><br><span class="line">== Test   usertests: forkfork ==</span><br><span class="line">  usertests: forkfork: OK</span><br><span class="line">== Test   usertests: forkforkfork ==</span><br><span class="line">  usertests: forkforkfork: OK</span><br><span class="line">== Test   usertests: createdelete ==</span><br><span class="line">  usertests: createdelete: OK</span><br><span class="line">== Test   usertests: linkunlink ==</span><br><span class="line">  usertests: linkunlink: OK</span><br><span class="line">== Test   usertests: linktest ==</span><br><span class="line">  usertests: linktest: OK</span><br><span class="line">== Test   usertests: unlinkread ==</span><br><span class="line">  usertests: unlinkread: OK</span><br><span class="line">== Test   usertests: concreate ==</span><br><span class="line">  usertests: concreate: OK</span><br><span class="line">== Test   usertests: subdir ==</span><br><span class="line">  usertests: subdir: OK</span><br><span class="line">== Test   usertests: fourfiles ==</span><br><span class="line">  usertests: fourfiles: OK</span><br><span class="line">== Test   usertests: sharedfd ==</span><br><span class="line">  usertests: sharedfd: OK</span><br><span class="line">== Test   usertests: exectest ==</span><br><span class="line">  usertests: exectest: OK</span><br><span class="line">== Test   usertests: bigargtest ==</span><br><span class="line">  usertests: bigargtest: OK</span><br><span class="line">== Test   usertests: bigwrite ==</span><br><span class="line">  usertests: bigwrite: OK</span><br><span class="line">== Test   usertests: bsstest ==</span><br><span class="line">  usertests: bsstest: OK</span><br><span class="line">== Test   usertests: sbrkbasic ==</span><br><span class="line">  usertests: sbrkbasic: OK</span><br><span class="line">== Test   usertests: kernmem ==</span><br><span class="line">  usertests: kernmem: OK</span><br><span class="line">== Test   usertests: validatetest ==</span><br><span class="line">  usertests: validatetest: OK</span><br><span class="line">== Test   usertests: opentest ==</span><br><span class="line">  usertests: opentest: OK</span><br><span class="line">== Test   usertests: writetest ==</span><br><span class="line">  usertests: writetest: OK</span><br><span class="line">== Test   usertests: writebig ==</span><br><span class="line">  usertests: writebig: OK</span><br><span class="line">== Test   usertests: createtest ==</span><br><span class="line">  usertests: createtest: OK</span><br><span class="line">== Test   usertests: openiput ==</span><br><span class="line">  usertests: openiput: OK</span><br><span class="line">== Test   usertests: exitiput ==</span><br><span class="line">  usertests: exitiput: OK</span><br><span class="line">== Test   usertests: iput ==</span><br><span class="line">  usertests: iput: OK</span><br><span class="line">== Test   usertests: mem ==</span><br><span class="line">  usertests: mem: OK</span><br><span class="line">== Test   usertests: pipe1 ==</span><br><span class="line">  usertests: pipe1: OK</span><br><span class="line">== Test   usertests: preempt ==</span><br><span class="line">  usertests: preempt: OK</span><br><span class="line">== Test   usertests: exitwait ==</span><br><span class="line">  usertests: exitwait: OK</span><br><span class="line">== Test   usertests: rmdot ==</span><br><span class="line">  usertests: rmdot: OK</span><br><span class="line">== Test   usertests: fourteen ==</span><br><span class="line">  usertests: fourteen: OK</span><br><span class="line">== Test   usertests: bigfile ==</span><br><span class="line">  usertests: bigfile: OK</span><br><span class="line">== Test   usertests: dirfile ==</span><br><span class="line">  usertests: dirfile: OK</span><br><span class="line">== Test   usertests: iref ==</span><br><span class="line">  usertests: iref: OK</span><br><span class="line">== Test   usertests: forktest ==</span><br><span class="line">  usertests: forktest: OK</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 119/119</span><br></pre></td></tr></table></figure>



<h2 id="4-遇到的困难以及收获"><a href="#4-遇到的困难以及收获" class="headerlink" title="4. 遇到的困难以及收获"></a>4. 遇到的困难以及收获</h2><ul>
<li>在 <code>sys_sbrk()</code> 函数中的部分 <code>addr</code> 被声明成了 <code>int</code>，但是实际上应该是 <code>uint64</code>，这个 bug 改了好久，一直都在报错 <code>panic(&quot;walk&quot;)</code>，看来对原始的代码也不能都相信，还得是自己重新修改下</li>
<li>有些问题的设计还是挺巧妙的，例如在内核态下遇到了 pagefault 的处理，这个在之前都没有仔细思考过</li>
<li>在学习完这一部分的 lab 之后，对整个多级页表的立即更加深入了，对操作系统在底层内存空间实现也有了更好的理解</li>
</ul>
<h2 id="5-对课程或-lab-的意见和建议"><a href="#5-对课程或-lab-的意见和建议" class="headerlink" title="5. 对课程或 lab 的意见和建议"></a>5. 对课程或 lab 的意见和建议</h2><ul>
<li>希望中文版本能把 hint 也翻译过来（当然不是必要的）</li>
</ul>
<h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/08/OS/xv6-labs/lab4-lazy-allocation/" data-id="cl9lj74bb00ih64tzexyq1v9b" data-title="xv6-labs-2020.lab4.lazy page allocation" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xv6/" rel="tag">xv6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OS/xv6-labs/lab3-traps" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/06/OS/xv6-labs/lab3-traps/" class="article-date">
  <time class="dt-published" datetime="2021-05-06T04:00:00.000Z" itemprop="datePublished">2021-05-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OS-xv6-labs/">OS.xv6-labs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/06/OS/xv6-labs/lab3-traps/">xv6-labs-2020.lab3.traps</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="lab3-traps"><a href="#lab3-traps" class="headerlink" title="lab3 traps"></a>lab3 traps</h1><h2 id="1-作业链接"><a href="#1-作业链接" class="headerlink" title="1. 作业链接"></a>1. 作业链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/labs/traps.html">https://pdos.csail.mit.edu/6.828/2020/labs/traps.html</a></li>
</ul>
<h2 id="2-实习内容"><a href="#2-实习内容" class="headerlink" title="2. 实习内容"></a>2. 实习内容</h2><h3 id="RISC-V-汇编代码"><a href="#RISC-V-汇编代码" class="headerlink" title="RISC-V 汇编代码"></a>RISC-V 汇编代码</h3><p>（1）函数传参使用哪些寄存器？printf() 函数调用中 13 放在那个寄存器里？</p>
<ul>
<li>函数传递参数使用寄存器：a0-a7</li>
<li>放置在 a2 寄存器里（第 3 个参数）</li>
</ul>
<p>（2）哪一部分的代码体现了对 f(), g() 的调用？</p>
<ul>
<li>f()：编译器优化的太厉害了，直接把 f(8)+1 算出来了，结果是 12</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># f(int)</span><br><span class="line"># Line 46</span><br><span class="line">26: 45b1                li  a1,12</span><br></pre></td></tr></table></figure>

<ul>
<li>g()：编译器直接把 g() 函数优化成 inline 形式的，在调用 g() 的地方，直接使用 a0 &#x3D; a0 + 3 代替</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># g(int)</span><br><span class="line"># Line 32</span><br><span class="line">14: 250d                addiw   a0,a0,3</span><br></pre></td></tr></table></figure>



<p>（3）printf() 函数的地址</p>
<ul>
<li>0000000000000630</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Line 1092</span><br><span class="line">0000000000000630 &lt;printf&gt;:</span><br></pre></td></tr></table></figure>



<p>（4）在调用 printf() 之后，ra 寄存器中保存的值是多少？</p>
<ul>
<li>0x38<ul>
<li>1536 &#x3D; 0x600</li>
<li>0x630 - 0x600 + 0x8 &#x3D; 0x38</li>
</ul>
</li>
</ul>
<p>（5）下列代码输出是什么？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<ul>
<li>输出为：<code>HE110 World</code><ul>
<li>57616 &#x3D; 0xe110</li>
<li>RISC-V 是小端的，因此 i 在内存中的分布为 72 6c 64 00（低地址到高地址）,对应的字符串为 <code>rld</code></li>
</ul>
</li>
<li>如果 RISC-V  是大端的，为了保证输出输出不变，需要把 i 的值修改为 0x726c6400，不需要修改 57616</li>
</ul>
<p>（6）下列代码的输出是什么？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d y=%d&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>输出结果为：<code>x=3 y=5221</code><ul>
<li>其中 5221 为一个不确定的数字，寄存器传参的时候少传了一个参数，所以这个值我们是未知的</li>
</ul>
</li>
</ul>
<h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><ul>
<li>要求<ul>
<li>The compiler puts in each stack frame a frame pointer that holds the address of the caller’s frame pointer. Your <code>backtrace</code> should use these frame pointers to walk up the stack and print the saved return address in each stack frame.</li>
</ul>
</li>
<li>在 sys_sleep() 中调用 backtrace()</li>
</ul>
<h4 id="kernel-x2F-defs-h"><a href="#kernel-x2F-defs-h" class="headerlink" title="kernel&#x2F;defs.h"></a>kernel&#x2F;defs.h</h4><ul>
<li>添加函数原型，从而能够让 sleep() 调用 backtrace()</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>



<h4 id="kernel-x2F-riscv-h"><a href="#kernel-x2F-riscv-h" class="headerlink" title="kernel&#x2F;riscv.h"></a>kernel&#x2F;riscv.h</h4><ul>
<li>在这里添加读取寄存器 s0 的指令</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_fp</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="kernel-x2F-sysproc-c"><a href="#kernel-x2F-sysproc-c" class="headerlink" title="kernel&#x2F;sysproc.c"></a>kernel&#x2F;sysproc.c</h4><ul>
<li>在 sys_sleep() 函数中添加对 backtrace() 的调用</li>
<li>我直接加在开头了</li>
</ul>
<h4 id="kernel-x2F-printf-c"><a href="#kernel-x2F-printf-c" class="headerlink" title="kernel&#x2F;printf.c"></a>kernel&#x2F;printf.c</h4><ul>
<li>添加函数实现</li>
<li>注意栈帧结构<ul>
<li>return address: a fixed offset (-8) from the frame pointer of a stackframe</li>
<li>the saved frame pointer: fixed offset (-16) from the frame pointer</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// backtrace</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">backtrace</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前的帧指针 frame pointer</span></span><br><span class="line">    uint64 fp = r_fp();</span><br><span class="line">    uint64 down = PGROUNDDOWN(fp);</span><br><span class="line">    uint64 up = PGROUNDUP(fp);</span><br><span class="line">    <span class="comment">// 栈向下增长, 因此循环的时候 fp 应该是越来越大</span></span><br><span class="line">    <span class="keyword">while</span>(fp &lt; up &amp;&amp; fp &gt; down) &#123;</span><br><span class="line">        printptr(*(uint64 *)(fp - <span class="number">8</span>));</span><br><span class="line">        consputc(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        fp = *(uint64 *)(fp - <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="backtrace-用途"><a href="#backtrace-用途" class="headerlink" title="backtrace 用途"></a>backtrace 用途</h4><ul>
<li>Once your backtrace is working, call it from <code>panic</code> in <code>kernel/printf.c</code> so that you see the kernel’s backtrace when it panics.</li>
</ul>
<h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul>
<li>In this exercise you’ll add a feature to xv6 that periodically alerts a process as it uses CPU time. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. More generally, you’ll be implementing a primitive form of user-level interrupt&#x2F;fault handlers; you could use something similar to handle page faults in the application, for example. Your solution is correct if it passes alarmtest and usertests.</li>
<li>添加两个系统调用</li>
</ul>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><h5 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h5><ul>
<li>把 <code>$U/_alarmtest</code> 添加到 <code>UPROGS</code> 里</li>
</ul>
<h5 id="user-x2F-user-h"><a href="#user-x2F-user-h" class="headerlink" title="user&#x2F;user.h"></a>user&#x2F;user.h</h5><ul>
<li>添加函数原型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> ticks, <span class="type">void</span> (*handler)())</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>



<h5 id="user-x2F-user-pl"><a href="#user-x2F-user-pl" class="headerlink" title="user&#x2F;user.pl"></a>user&#x2F;user.pl</h5><ul>
<li>添加入口，辅助生成汇编代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entry(&quot;sigalarm&quot;);</span><br><span class="line">entry(&quot;sigreturn&quot;);</span><br></pre></td></tr></table></figure>



<h5 id="kernel-x2F-syscall-h"><a href="#kernel-x2F-syscall-h" class="headerlink" title="kernel&#x2F;syscall.h"></a>kernel&#x2F;syscall.h</h5><ul>
<li>添加系统调用号</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigalarm  22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigreturn  23</span></span><br></pre></td></tr></table></figure>



<h5 id="kernel-x2F-syscall-c"><a href="#kernel-x2F-syscall-c" class="headerlink" title="kernel&#x2F;syscall.c"></a>kernel&#x2F;syscall.c</h5><ul>
<li>添加新系统调用的定义和入口</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    [SYS_sigalarm]   sys_sigalarm,</span><br><span class="line">    [SYS_sigreturn]   sys_sigreturn,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="kernel-x2F-sysproc-c-1"><a href="#kernel-x2F-sysproc-c-1" class="headerlink" title="kernel&#x2F;sysproc.c"></a>kernel&#x2F;sysproc.c</h5><ul>
<li>添加具体的实现（测试）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>做到这里，程序能够编译成功了，但是具体功能还没有实现</li>
</ul>
<h4 id="test0-invoke-handler"><a href="#test0-invoke-handler" class="headerlink" title="test0: invoke handler"></a>test0: invoke handler</h4><ul>
<li><p>实现逻辑</p>
<ul>
<li>在调用 sysalarm 的时候，在进程的数据结构中保存参数<ul>
<li>handler、多久调用一次 handler、现在已经运行了多少个 ticks（初始化为 0）</li>
</ul>
</li>
<li>在收到时钟中断信号的时候，判断是否需要调用 handler，如果需要，设置 PC 为 handler</li>
</ul>
</li>
<li><p>这个是先破坏了栈帧，因此是有问题的</p>
<ul>
<li>test1&#x2F;test2 部分解决这个问题</li>
</ul>
</li>
</ul>
<h5 id="kernel-x2F-proc-h"><a href="#kernel-x2F-proc-h" class="headerlink" title="kernel&#x2F;proc.h"></a>kernel&#x2F;proc.h</h5><ul>
<li>添加一些中间变量辅助实现 sys_alarm() 功能</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 添加几个变量辅助实现 sysalarm()</span></span><br><span class="line">    <span class="type">int</span> ticks_for_alarm;    <span class="comment">// 多久时间调用一次 handler</span></span><br><span class="line">    <span class="type">void</span>(*)(alarm_handler); <span class="comment">// handler</span></span><br><span class="line">    <span class="type">int</span> ticks_used;         <span class="comment">// 已经使用了多少 ticks(对 ticks_for_alarm 取模)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="kernel-x2F-proc-c"><a href="#kernel-x2F-proc-c" class="headerlink" title="kernel&#x2F;proc.c"></a>kernel&#x2F;proc.c</h5><ul>
<li>对于上面那些变量的初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 最后的部分添加如下修改</span></span><br><span class="line"></span><br><span class="line">    p-&gt;ticks_for_alarm = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 理论上修改上边一个变量就够了, 但是为了安全, 全都修改了</span></span><br><span class="line">    p-&gt;alarm_handler = <span class="number">0</span>;</span><br><span class="line">    p-&gt;ticks_used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全起见也改了, 但是不该不影响结果</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    p-&gt;ticks_for_alarm = <span class="number">0</span>;</span><br><span class="line">    p-&gt;alarm_handler = <span class="number">0</span>;</span><br><span class="line">    p-&gt;ticks_used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="kernel-x2F-sysproc-c-2"><a href="#kernel-x2F-sysproc-c-2" class="headerlink" title="kernel&#x2F;sysproc.c"></a>kernel&#x2F;sysproc.c</h5><ul>
<li>设置 proc.h 中的变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    uint64 handler;</span><br><span class="line">    <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(argaddr(<span class="number">1</span>, &amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    p-&gt;alarm_handler = (<span class="type">void</span>(*)()) handler;</span><br><span class="line">    p-&gt;ticks_for_alarm = n;</span><br><span class="line">    p-&gt;ticks_used = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="kernel-x2F-usertrap-c（错误实现）"><a href="#kernel-x2F-usertrap-c（错误实现）" class="headerlink" title="kernel&#x2F;usertrap.c（错误实现）"></a>kernel&#x2F;usertrap.c（错误实现）</h5><ul>
<li>每次接受到时钟中断的时候，计数器 ticks 自增</li>
<li>在从内核态返回用户态的时候判断 ticks 记录是否超标，如果是，则调用 handler 进行处理</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ticks_for_alarm) &#123;</span><br><span class="line">            ++p-&gt;ticks_used;</span><br><span class="line">        &#125;</span><br><span class="line">        yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 原来是 w_sepc(p-&gt;trapframe-&gt;epc);</span></span><br><span class="line">    <span class="comment">// 现在加上一个判断, 将其设置为 handler 的地址</span></span><br><span class="line">    <span class="comment">// 这显然是错误的, 栈帧被破坏了, 但是 test0 是 OK 的</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ticks_for_alarm &amp;&amp; p-&gt;ticks_used == p-&gt;ticks_for_alarm) &#123;</span><br><span class="line">        p-&gt;ticks_used = <span class="number">0</span>;</span><br><span class="line">        w_sepc((uint64)p-&gt;alarm_handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另外一种简便的实现方式<ul>
<li>直接修改 epc</li>
<li>但是也是破坏了栈帧</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ticks_for_alarm) &#123;</span><br><span class="line">            ++p-&gt;ticks_used;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;ticks_used == p-&gt;ticks_for_alarm) &#123;</span><br><span class="line">                p-&gt;ticks_used = <span class="number">0</span>;</span><br><span class="line">                p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarm_handler;</span><br><span class="line">            &#125;</span><br><span class="line">            yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="test1-resume-interrupted-code"><a href="#test1-resume-interrupted-code" class="headerlink" title="test1: resume interrupted code"></a>test1: resume interrupted code</h4><ul>
<li>这一部分的实现除了 usertrap.c，其他部分都是基于 test0 进行修改的</li>
</ul>
<h5 id="kernel-x2F-usertrap-c（正确实现）"><a href="#kernel-x2F-usertrap-c（正确实现）" class="headerlink" title="kernel&#x2F;usertrap.c（正确实现）"></a>kernel&#x2F;usertrap.c（正确实现）</h5><ul>
<li>需要保存寄存器状态，通过 sysalarm 和 sigreturn 的配合实现</li>
<li>要求每个 hander 的最后都需要调用 sigreturn 回到内核态</li>
<li>test0 的实现回到用户态之前需要保存当时的寄存器状态，当 sigreturn 回到了内核态是恢复寄存器状态，返回用户态正常执行</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ticks_for_alarm) &#123;</span><br><span class="line">            ++p-&gt;ticks_used;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;ticks_used == p-&gt;ticks_for_alarm) &#123;</span><br><span class="line">                p-&gt;ticks_used = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 保存所有的寄存器状态</span></span><br><span class="line">                memmove(&amp;(p-&gt;trapframe2), p-&gt;trapframe, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">                p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarm_handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="kernel-x2F-proc-h-1"><a href="#kernel-x2F-proc-h-1" class="headerlink" title="kernel&#x2F;proc.h"></a>kernel&#x2F;proc.h</h5><ul>
<li>需要在 proc 数据结构中保存寄存器</li>
<li>这里为了方便直接使用 trapframe 的数据结构，实际上有些值是不需要保存恢复的<ul>
<li>kernel 的相关值不用恢复：kernel_satp、kernel_sp、kernel_trap、kernel_hartid</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 保存 sysalarm 的寄存器状态, kernel 的 4 个不需要, 但是为了方便都写了</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">trapframe2</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="kernel-x2F-sysproc-c-3"><a href="#kernel-x2F-sysproc-c-3" class="headerlink" title="kernel&#x2F;sysproc.c"></a>kernel&#x2F;sysproc.c</h5><ul>
<li>当调用 sys_sigreturn 的时候恢复寄存器状态</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="comment">// 恢复寄存器状态(4 个 kernel 的不需要)</span></span><br><span class="line">    <span class="comment">// 如果是 sigalarm(0, 0) 的话不需要恢复现场</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ticks_for_alarm) &#123;</span><br><span class="line">        memmove(</span><br><span class="line">            ((uint64 *)p-&gt;trapframe) + <span class="number">5</span>,</span><br><span class="line">            ((uint64 *)&amp;(p-&gt;trapframe2)) + <span class="number">5</span>,</span><br><span class="line">            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe) - <span class="number">5</span>*<span class="keyword">sizeof</span>(uint64)</span><br><span class="line">        );</span><br><span class="line">        p-&gt;trapframe-&gt;epc = p-&gt;trapframe2.epc;</span><br><span class="line">        p-&gt;is_alarm = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>到这里为止，已经能够通过 test2，在不破坏栈帧的情况下实现 sysalarm 的效果</li>
</ul>
<h4 id="test2-prevent-re-entrant-calls"><a href="#test2-prevent-re-entrant-calls" class="headerlink" title="test2(): prevent re-entrant calls"></a>test2(): prevent re-entrant calls</h4><ul>
<li>这一部分的实现基于 test1 进行修改的</li>
</ul>
<h5 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><ul>
<li>不允许重复调用，当一个 sysalarm 已经存在的时候，没有调用 sigreturn 之前不允许调用新的 sigalarm</li>
<li>这一部分的实现很简单，在 proc 数据结构中添加一个标记变量<ul>
<li>调用 sigalarm 的时候设置为 1<ul>
<li>如果调用 sigalarm 的时候已经为 1，则该调用不生效</li>
</ul>
</li>
<li>调用 sigreturn 的时候设置为 0</li>
</ul>
</li>
</ul>
<h5 id="kernel-x2F-proc-h-2"><a href="#kernel-x2F-proc-h-2" class="headerlink" title="kernel&#x2F;proc.h"></a>kernel&#x2F;proc.h</h5><ul>
<li>添加一个标记变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> is_alarm; <span class="comment">// 是否调用 sigalarm</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="kernel-x2F-proc-c-1"><a href="#kernel-x2F-proc-c-1" class="headerlink" title="kernel&#x2F;proc.c"></a>kernel&#x2F;proc.c</h5><ul>
<li>标记变量的初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    p-&gt;is_alarm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全起见也改了, 但是不该不影响结果</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    p-&gt;is_alarm = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="kernel-x2F-sysproc-c（错误实现）"><a href="#kernel-x2F-sysproc-c（错误实现）" class="headerlink" title="kernel&#x2F;sysproc.c（错误实现）"></a>kernel&#x2F;sysproc.c（错误实现）</h5><ul>
<li>添加标记变量的判断</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;is_alarm) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(handler)&#123;</span><br><span class="line">        <span class="comment">// 注意如果调用的是 sigalarm(0, 0) 的话是不需要调用 sigreturn 的</span></span><br><span class="line">        p-&gt;is_alarm = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    p-&gt;is_alarm = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这样子实现是错误的，只能阻止新的 sigalarm 的调用，但是不能够实现已经设置的 handler 在 sigreturn 之前的再次调用</li>
<li>输出结果</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test2 start</span><br><span class="line">.....alarm!</span><br><span class="line">alarm!</span><br><span class="line">test2 failed: alarm handler called more than once</span><br></pre></td></tr></table></figure>



<h5 id="kernel-x2F-sysproc-c（正确实现）"><a href="#kernel-x2F-sysproc-c（正确实现）" class="headerlink" title="kernel&#x2F;sysproc.c（正确实现）"></a>kernel&#x2F;sysproc.c（正确实现）</h5><ul>
<li>此时 is_alarm 的含义变成了是否调用 handler</li>
<li>如果有 handler 调用，禁止新的 sigalarm 调用</li>
<li>恢复当然还是在调用 sigreturn 的时候恢复</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 如果已经调用了一个 handler, 而且没有返回的话</span></span><br><span class="line">    <span class="comment">// 我们禁止这个新的调用(我们的设计不支持递归调用)</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;is_alarm) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 恢复寄存器状态(4 个 kernel 的不需要)</span></span><br><span class="line">    <span class="comment">// 只有保存了寄存器才需要恢复现场</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;is_alarm) &#123;</span><br><span class="line">        memmove(</span><br><span class="line">            ((uint64 *)p-&gt;trapframe) + <span class="number">5</span>,</span><br><span class="line">            ((uint64 *)&amp;(p-&gt;trapframe2)) + <span class="number">5</span>,</span><br><span class="line">            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe) - <span class="number">5</span>*<span class="keyword">sizeof</span>(uint64)</span><br><span class="line">        );</span><br><span class="line">        p-&gt;trapframe-&gt;epc = p-&gt;trapframe2.epc;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;is_alarm = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="kernel-x2F-trap-c"><a href="#kernel-x2F-trap-c" class="headerlink" title="kernel&#x2F;trap.c"></a>kernel&#x2F;trap.c</h5><ul>
<li>正确实现应该是在保存寄存器的时候进行判断<ul>
<li>因为我们只有一块区域，不能够实现递归调用</li>
<li>也能解决上面的问题</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 保存所有的寄存器状态</span></span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;is_alarm)) &#123;</span><br><span class="line">        p-&gt;is_alarm = <span class="number">1</span>;</span><br><span class="line">        memmove(&amp;(p-&gt;trapframe2), p-&gt;trapframe, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">        p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarm_handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3. 实验结果"></a>3. 实验结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">== Test answers-traps.txt == answers-traps.txt: OK</span><br><span class="line">== Test backtrace <span class="built_in">test</span> ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">backtrace <span class="built_in">test</span>: OK (14.9s)</span><br><span class="line">== Test running alarmtest ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(7.0s)</span><br><span class="line">== Test   alarmtest: test0 ==</span><br><span class="line">  alarmtest: test0: OK</span><br><span class="line">== Test   alarmtest: test1 ==</span><br><span class="line">  alarmtest: test1: OK</span><br><span class="line">== Test   alarmtest: test2 ==</span><br><span class="line">  alarmtest: test2: OK</span><br><span class="line">== Test usertests ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">usertests: OK (231.3s)</span><br><span class="line">    (Old xv6.out.usertests failure <span class="built_in">log</span> removed)</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 85/85</span><br></pre></td></tr></table></figure>



<h2 id="4-遇到的困难以及收获"><a href="#4-遇到的困难以及收获" class="headerlink" title="4. 遇到的困难以及收获"></a>4. 遇到的困难以及收获</h2><ul>
<li>做完整个 lab 感觉操作系统的设计很巧妙，这里的的 sysalarm 的实际就感觉很有趣，通过两次系统调用解决了一次系统调用很难解决的问题。</li>
<li>具体的解决方法在上面都已经提到了，主要是怎么设置 PC，以及栈帧的保存与恢复问题。</li>
</ul>
<h3 id="一个小问题"><a href="#一个小问题" class="headerlink" title="一个小问题"></a>一个小问题</h3><ul>
<li>在这个 lab 的实现中，在 <code>sigreturn()</code> 未返回时，有两种实现方案<ul>
<li>不允许 <code>sigalarm()</code> 重新设置 <code>handler</code></li>
<li>允许 <code>sigalarm()</code> 重新设置 <code>handler</code>，但是不允许其有修改保存的寄存器（我们只有一块区域，不支持递归）</li>
</ul>
</li>
<li>这两种方法都可行，测试都能过</li>
<li>但似乎又都有各自的问题<ul>
<li>第一种方法不能允许 <code>sigalarm(0, 0)</code> 的调用，这样的调用能够取消 <code>handler()</code></li>
<li>第二种方法会让最终的 <code>handler()</code> 不太可控，可能在 <code>sigreturn()</code> 未返回的时候设置了奇怪的 <code>handler()</code></li>
</ul>
</li>
<li>我是按照方法 1 实现的</li>
</ul>
<h3 id="sys-alarm-保存的寄存器"><a href="#sys-alarm-保存的寄存器" class="headerlink" title="sys_alarm 保存的寄存器"></a>sys_alarm 保存的寄存器</h3><ul>
<li>epc（需要）</li>
<li>callee-saved（需要）（sig_return 之前可能没有 pop 栈）</li>
<li>caller-saved（不需要）</li>
<li>kernel_sp（不需要）</li>
<li>kernel_hartid（不能）</li>
<li>kernel_stap（不需要）</li>
</ul>
<h2 id="5-对课程或-lab-的意见和建议"><a href="#5-对课程或-lab-的意见和建议" class="headerlink" title="5. 对课程或 lab 的意见和建议"></a>5. 对课程或 lab 的意见和建议</h2><ul>
<li>一个建议是最后的 usertests.c 的运行时间太长了，感觉没有必要用那么多的测试，之前已按因为一行代码写反了一直超时，浪费了太多时间。</li>
</ul>
<h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/reference.html">https://pdos.csail.mit.edu/6.828/2020/reference.html</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/riscv/riscv-isa-manual/releases/download/draft-20200727-8088ba4/riscv-spec.pdf">https://github.com/riscv/riscv-isa-manual/releases/download/draft-20200727-8088ba4/riscv-spec.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf">https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/06/OS/xv6-labs/lab3-traps/" data-id="cl9lj74bc00in64tz8qdrfr9c" data-title="xv6-labs-2020.lab3.traps" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xv6/" rel="tag">xv6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/CLJ/05" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/05/DB/CLJ/05/" class="article-date">
  <time class="dt-published" datetime="2021-05-05T15:28:20.000Z" itemprop="datePublished">2021-05-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/05/DB/CLJ/05/">数据库概论.陈立军.05.关系规范化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="关系规范化"><a href="#关系规范化" class="headerlink" title="关系规范化"></a>关系规范化</h1><ul>
<li>为什么需要关系规范化</li>
</ul>
<img src="05/image-20210505233157308.png" style="zoom: 50%;" />



<h2 id="关系模式的设计问题"><a href="#关系模式的设计问题" class="headerlink" title="关系模式的设计问题"></a>关系模式的设计问题</h2><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h3><ul>
<li>为管理职工信息而设计如下一个关系模式<ul>
<li>问题：当删除职工 A 后，没有等级 4 的员工了，此时如果想再招聘一个等级 4 的员工，不知道如何安排工资</li>
<li>不完整了</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">职工</th>
<th align="center">级别</th>
<th align="center">工资</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">4</td>
<td align="center">500</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">5</td>
<td align="center">600</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">6</td>
<td align="center">700</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">5</td>
<td align="center">600</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">6</td>
<td align="center">700</td>
</tr>
</tbody></table>
<ul>
<li>问题根源：在属性如何取值的问题上，表结构与现实出现偏离<ul>
<li>现实中<ul>
<li>职工只和岗位有关系</li>
<li>每个级别的工资和职工没关系，只和级别有关系</li>
</ul>
</li>
</ul>
</li>
<li>应该这样设计<ul>
<li>职工 - 级别一张表</li>
<li>级别 - 工资一张表</li>
</ul>
</li>
<li>问题根源：<strong>人为造成了现实当中本来无关属性之间的依赖</strong></li>
</ul>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ul>
<li><strong>信息的不可表示问题</strong><ul>
<li><strong>插入异常</strong>：如果没有职工具有 8 级工资，则 8 级工资的工资数额就难以插入</li>
<li><strong>删除异常</strong>：如果仅有职工 A 具有 4 级工资，删除 A 则会将有关 4 级工资的工资数额信息也一并删除</li>
</ul>
</li>
<li><strong>信息的冗余问题</strong><ul>
<li><strong>数据冗余</strong>：职工很多，工资级别有限，每一级别的工资数额反复存储多次</li>
<li><strong>更新异常</strong>：如果将 5 级工资的工资数额调为 620，则需要找到每个具有 5 级工资的职工，逐一修改</li>
</ul>
</li>
</ul>
<h4 id="不良的数据依赖"><a href="#不良的数据依赖" class="headerlink" title="不良的数据依赖"></a>不良的数据依赖</h4><ul>
<li>解决方案</li>
<li>应该这样设计<ul>
<li>职工 - 级别一张表</li>
<li>级别 - 工资一张表</li>
</ul>
</li>
</ul>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h3><ul>
<li>有些人可能有很多爱好，主码设置为 <strong>姓名+爱好</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">姓名</th>
<th align="center">年龄</th>
<th align="center">性别</th>
<th align="center">爱好</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">20</td>
<td align="center">男</td>
<td align="center">电影</td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">20</td>
<td align="center">男</td>
<td align="center">音乐</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">18</td>
<td align="center">女</td>
<td align="center">购物</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">18</td>
<td align="center">女</td>
<td align="center">美食</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">23</td>
<td align="center">null</td>
<td align="center">null</td>
</tr>
</tbody></table>
<ul>
<li>有些人可能没有爱好，此时它不能插入<ul>
<li>C 的记录是无法插入的（主码非 null ）</li>
</ul>
</li>
</ul>
<h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><h3 id="函数依赖的定义"><a href="#函数依赖的定义" class="headerlink" title="函数依赖的定义"></a>函数依赖的定义</h3><ul>
<li>设 $R(U)$ 是属性集 $U$ 上的关系模式，$X,Y\subseteq U$，$r$ 是 $R(U)$ 上的任意一个关系<ul>
<li>如果成立 对 $\forall t,s\in R$ 若 $t[X]&#x3D;s[X]$，则 $t[Y]&#x3D;s[Y]$</li>
<li>则称 “$X$ 函数决定 $Y$ ” 或 “ $Y$ 函数依赖于 $X$ “，记作 $X\to Y$</li>
<li><strong>称 $X$ 为决定因素</strong></li>
</ul>
</li>
<li>函数依赖的双重否定定义<ul>
<li>不存在 $t, s \in r$，$t[X] &#x3D; s[X]$，但 $t[Y]\ne s[Y]$</li>
</ul>
</li>
<li>函数依赖的例子<ul>
<li>姓名 $\to$ 学号</li>
</ul>
</li>
</ul>
<h3 id="例子-1-1"><a href="#例子-1-1" class="headerlink" title="例子 1"></a>例子 1</h3><ul>
<li>给定如下关系示例，判断如下函数依赖是否成立</li>
</ul>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a1</td>
<td align="center">b1</td>
<td align="center">c1</td>
<td align="center">d1</td>
</tr>
<tr>
<td align="center">a1</td>
<td align="center">b2</td>
<td align="center">c1</td>
<td align="center">d2</td>
</tr>
<tr>
<td align="center">a2</td>
<td align="center">b2</td>
<td align="center">c2</td>
<td align="center">d2</td>
</tr>
<tr>
<td align="center">a2</td>
<td align="center">b3</td>
<td align="center">c2</td>
<td align="center">d3</td>
</tr>
<tr>
<td align="center">a3</td>
<td align="center">b3</td>
<td align="center">c2</td>
<td align="center">d4</td>
</tr>
</tbody></table>
<ul>
<li>$A\to C$：成立<ul>
<li>判断在 A 上相等的两行，在 C 上是否相等</li>
</ul>
</li>
<li>$C\to A$：不成立</li>
<li>$AB\to D$：成立<ul>
<li>$AB$ 上取值是唯一的</li>
</ul>
</li>
</ul>
<h3 id="两种依赖的等级"><a href="#两种依赖的等级" class="headerlink" title="两种依赖的等级"></a>两种依赖的等级</h3><ul>
<li>满足依赖的关系：<strong>依赖在模式的某个关系实例上成立</strong><ul>
<li>可能在插入几行之后，函数依赖就不成立了</li>
</ul>
</li>
<li>模式上成立的依赖：<strong>依赖在模式的所有关系实例上都成立</strong></li>
</ul>
<h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
</tbody></table>
<ul>
<li>找出所有可能的函数依赖</li>
<li>$A\to B,A\to C,B\to C$</li>
<li>$A\to A,B\to B,C\to C$</li>
<li>$AB\to A,ABC\to A,\cdots$</li>
<li>$\cdots$</li>
</ul>
<h3 id="平凡函数依赖"><a href="#平凡函数依赖" class="headerlink" title="平凡函数依赖"></a>平凡函数依赖</h3><ul>
<li>如果 $X\to Y$，$Y\subseteq X$，则称其为<strong>平凡的函数依赖</strong>，否则称为<strong>非平凡的函数依赖</strong></li>
<li>一个关系模式有 n 个属性，在它上面成立的所有可能的函数依赖有多少个？非平凡的函数依赖有多少个？<ul>
<li>函数依赖：$4^n$</li>
<li>平凡的函数依赖：$3^n$<ul>
<li>$\sum{n \choose i}2^i&#x3D;\sum{n \choose i}2^i1^{n-i}&#x3D;(2+1)^n&#x3D;3^n$</li>
</ul>
</li>
<li>非平凡的函数依赖：$4^n-3^n$</li>
</ul>
</li>
<li>如果 R(U) 的候选码是整个属性集 U，这称为全码<ul>
<li>例如选课表，只有两个属性（学号、课程号）</li>
</ul>
</li>
<li>一个全码的关系模式存在非平凡的函数依赖吗？<ul>
<li><strong>不存在</strong></li>
<li>如果存在 $A\to B$，则存在一个候选码 $A$，而且 $A$ 不是整个属性集</li>
</ul>
</li>
<li>如果存在非平凡关系依赖 $A\to B$，则 $B$ 可以不作为码的一部分</li>
</ul>
<h3 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h3><ul>
<li>如果 $X\to Y$，且对于任意 $X$ 的真子集 $X’$，都有 $X′\not\to Y$，则称 $Y$ 对 $X$ <strong>完全函数依赖</strong>，记作 $X\overset{f}{\to} Y$</li>
<li>否则称 $Y$ 对 $X$ <strong>部分函数依赖</strong>，记作 $X\overset{p}{\to} Y$</li>
<li><strong>如果在一个关系模式里面存在部分函数依赖的话，则是一个不好的设计</strong></li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>(sno, cno) $\overset{f}{\to}$ grade</li>
<li>(sno, cno) $\overset{p}{\to}$ sname</li>
</ul>
<h3 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h3><ul>
<li>如果关系模式中存在传递函数依赖，则也是一种差的设计</li>
<li>在 $R(U)$ 中，如果 $X\to Y,Y\to Z,Y\not\to X,Z\nsubseteq Y$，则称 $Z$ 对 $X$ <strong>传递函数依赖</strong></li>
<li>排除 $Z\nsubseteq Y$ 原因<ul>
<li>平凡函数依赖是一定成立的，关系模式中存在这样的函数依赖是正常的</li>
</ul>
</li>
<li>排除 $Y\not\to X$ 原因<ul>
<li>说明 $X,Y$ 都是候选码</li>
<li>多个候选码，在在关系模式的设计中是允许的</li>
</ul>
</li>
<li>如何把函数的部分依赖整理成传递函数依赖的形式？<ul>
<li>$X’\subset X,X\to Y,X’\to Y$</li>
<li>$X\to X’,X’\to Y$</li>
</ul>
</li>
<li>部分函数依赖一定能够转化为传递函数依赖</li>
</ul>
<h3 id="函数依赖的方式定义之前的码"><a href="#函数依赖的方式定义之前的码" class="headerlink" title="函数依赖的方式定义之前的码"></a>函数依赖的方式定义之前的码</h3><ul>
<li><strong>超码</strong><ul>
<li>设 $K$ 为 $R(U,F)$ 的属性或属性组，若 $K\to U$，则称 $K$ 为 $R$ 的超码</li>
</ul>
</li>
<li><strong>候选码</strong><ul>
<li>设 $K$ 为 $R(U,F)$ 的超码，若 $K\overset{f}{\to} U$，则称 $K$ 为 $R$ 的候选码</li>
</ul>
</li>
<li><strong>主属性</strong><ul>
<li>包含在每一个候选码中的属性，称作主属性<ul>
<li>候选码属性集的并，而不是交</li>
<li>例如属性集 (A,B,C)，候选码 A, (B,C)，则主属性是 A,B,C</li>
</ul>
</li>
</ul>
</li>
<li><strong>非主属性</strong><ul>
<li>不包含在任何候选码中的属性称为非主属性</li>
</ul>
</li>
<li><strong>全码</strong><ul>
<li>关系模式的码由整个属性组构成，如 SPJ</li>
</ul>
</li>
</ul>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><ul>
<li>一个不好的设计的例子</li>
<li>学号，姓名、系号、系主任、选修课程、成绩</li>
</ul>
<img src="05/image-20210507105954851.png" style="zoom: 43%;" />

<ul>
<li>范式是对关系的<strong>不同数据依赖程度</strong>的要求</li>
<li>通过<strong>模式分解</strong>将一个低级范式转换为若干个高级范式的过程称作<strong>规范化</strong>（<strong>概念的纯粹化</strong>）</li>
<li>排除法：在某一的范式中，不存在某些类型的函数依赖</li>
</ul>
<img src="05/image-20210507110327834.png" style="zoom:50%;" />



<h2 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h2><ul>
<li>关系中每一分量不可再分，也即不能以集合、序列等作为属性值</li>
</ul>
<h3 id="1NF-与查询效率的折中"><a href="#1NF-与查询效率的折中" class="headerlink" title="1NF 与查询效率的折中"></a>1NF 与查询效率的折中</h3><img src="05/image-20210507110548289.png" style="zoom:50%;" />

<h3 id="1NF-与应用对属性粒度的处理需求"><a href="#1NF-与应用对属性粒度的处理需求" class="headerlink" title="1NF 与应用对属性粒度的处理需求"></a>1NF 与应用对属性粒度的处理需求</h3><ul>
<li><strong>分量是否需要再分，与具体应用有关</strong></li>
<li>如果用到值的一部分，则需要进一步分割，否则需要应用编码解析</li>
</ul>
<img src="05/image-20210507110723397.png" style="zoom:50%;" />



<h3 id="1NF-与数据质量的控制准则"><a href="#1NF-与数据质量的控制准则" class="headerlink" title="1NF 与数据质量的控制准则"></a>1NF 与数据质量的控制准则</h3><ul>
<li>较细的原子粒度有助于标准化，施加约束，避免输入错误，从而提高数据质量</li>
<li>例如通讯地址，如果保存为一个属性，则输入格式可能不统一，导致解析困难</li>
</ul>
<img src="05/image-20210507111147090.png" style="zoom:50%;" />



<h3 id="1NF-关系模式的不良特性"><a href="#1NF-关系模式的不良特性" class="headerlink" title="1NF 关系模式的不良特性"></a>1NF 关系模式的不良特性</h3><img src="05/image-20210507105954851.png" style="zoom: 43%;" />

<ul>
<li>基于上面的例子</li>
<li><strong>插入异常</strong>：如果学生没有选课，关于他的个人信息及所在系的信息就无法插入</li>
<li><strong>删除异常</strong>：如果删除学生的选课信息，则他的个人信息及所在系的信息也随之删除</li>
<li><strong>更新异常</strong>：如果学生转系，若他选修了 k 门课，则需要修改 k 次</li>
<li><strong>数据冗余</strong>：如果一个学生选修了 k 门课，则有关他的所在系的信息重复</li>
</ul>
<h2 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h2><ul>
<li>若 R $\in$ 1NP ，且每个<strong>非</strong>主属性<strong>完全依赖</strong>于码，则称 R $\in$ 2NF</li>
<li><strong>2NF 消除了非主属性对码的部分依赖</strong><ul>
<li>不要求主属性对码没有部分依赖</li>
</ul>
</li>
</ul>
<h3 id="如何将关系模式改进到-2NF"><a href="#如何将关系模式改进到-2NF" class="headerlink" title="如何将关系模式改进到 2NF"></a>如何将关系模式改进到 2NF</h3><ul>
<li>非主属性有两种，一种完全依赖于码，一种部分依赖于码，据此将属性集划分为两部分</li>
</ul>
<img src="05/image-20210507112037025.png" style="zoom:50%;" />

<ul>
<li>关系模式R(A,B,C,D)，给出它的一个函数依赖集，使得码为 AB，并且 R 属于 1NF 而不属于 2NF<ul>
<li>设置一个部分函数依赖即可</li>
</ul>
</li>
</ul>
<p>$$<br>AB\to C,B\to D<br>$$</p>
<ul>
<li>但是这样子的设计还是存在<strong>传递函数依赖</strong><ul>
<li>sno 决定 dno，dno 决定 dean</li>
</ul>
</li>
</ul>
<h3 id="2NF关系模式的不良特性"><a href="#2NF关系模式的不良特性" class="headerlink" title="2NF关系模式的不良特性"></a>2NF关系模式的不良特性</h3><ul>
<li><strong>插入异常</strong>：如果系中没有学生，则有关系的信息就无法插入</li>
<li><strong>删除异常</strong>：如果删除某系中全部学生，则该系的系主任信息也随之删除</li>
<li><strong>更新异常</strong>：如果学生转系，不但要修改 dno，还要修改 dean</li>
<li><strong>数据冗余</strong>：每个学生都存储了其系主任的信息</li>
</ul>
<h2 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h2><ul>
<li><p>关系模式 $R(U)$ 中,若不存在这样的码 $X$，属性组 $Y$ 及非主属性 $Z(Z\not\subseteq Y)$，使得 $X\to Y,Y\to Z,Y\not\to X$ 成立，则称 R $\in$ 3NF</p>
</li>
<li><p>3NF 的目标是消除<strong>非主属性对码的传递依赖</strong></p>
</li>
</ul>
<h3 id="如何将关系模式改进到3NF"><a href="#如何将关系模式改进到3NF" class="headerlink" title="如何将关系模式改进到3NF"></a>如何将关系模式改进到3NF</h3><ul>
<li>砸断函数依赖的传递链</li>
</ul>
<img src="05/image-20210507135841410.png" style="zoom:50%;" />

<ul>
<li>关系模式R(A,B,C,D)，给出它的一个函数依赖集，使得码为 AB，并且 R 属于 2NF 而不属于 3NF<ul>
<li>设置一个传递函数依赖即可（当然不能存在部分函数依赖）</li>
</ul>
</li>
</ul>
<p>$$<br>AB\to C, C\to D<br>$$</p>
<ul>
<li>正常情况下数据库的设计要求达到 3NF 就可以了</li>
</ul>
<h3 id="3NF-的问题"><a href="#3NF-的问题" class="headerlink" title="3NF 的问题"></a>3NF 的问题</h3><ul>
<li>没有限定<strong>主属性</strong>的<strong>函数依赖</strong></li>
</ul>
<h3 id="主属性部分依赖的例子：STC"><a href="#主属性部分依赖的例子：STC" class="headerlink" title="主属性部分依赖的例子：STC"></a>主属性部分依赖的例子：<span id="STC">STC</span></h3><ul>
<li>关系模式：STC(sno,tno,cno)</li>
<li>每位老师只教授一门课：tno $\to$ cno</li>
<li>某学生选定一门课，就对应一位老师：(sno,cno) $\to$ tno</li>
<li>候选码：(sno, cno)、(sno, tno)</li>
<li>STC $\in$ 3NF<ul>
<li>没有非主属性，因此是满足 3NF 的</li>
</ul>
</li>
</ul>
<h3 id="3NF-的不良特性"><a href="#3NF-的不良特性" class="headerlink" title="3NF 的不良特性"></a>3NF 的不良特性</h3><ul>
<li><strong>插入异常</strong>：如果没有学生选修某位老师的任课，则该老师担任课程的信息就无法插入</li>
<li><strong>删除异常</strong>：删除学生选课信息，会删除掉老师的任课信息</li>
<li><strong>更新异常</strong>：如果老师的授课信息有所改动，则所有选修其课程的学生元组都要做改动</li>
<li><strong>数据冗余</strong>：每位学生都存储了老师的授课信息</li>
</ul>
<h3 id="为什么给主属性留后门"><a href="#为什么给主属性留后门" class="headerlink" title="为什么给主属性留后门"></a>为什么给主属性留后门</h3><ul>
<li>一种折衷的考虑</li>
</ul>
<h2 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h2><ul>
<li>关系模式 $R(U)$ 中,对于属性组 $X,Y$，若 $X\to Y,Y\not\subseteq X$ ，那么 $X$ 必是码，则 R $\in$ BCNF</li>
<li>BCNF：所有属性都由码直接决定</li>
<li>所有非平凡的函数依赖的左边都需要是候选码</li>
</ul>
<h3 id="如何将关系模式改造成BCNF的"><a href="#如何将关系模式改造成BCNF的" class="headerlink" title="如何将关系模式改造成BCNF的"></a>如何将关系模式改造成BCNF的</h3><ul>
<li>将属性划归到以决定它的属性作为码的关系模式中</li>
<li>3NF 中的例子 <a href="#STC">STC</a> 是不属于 BCNF 的<ul>
<li>STC (sno,tno,cno)</li>
<li>修改为 (sno,tno)，(tno,cno)</li>
</ul>
</li>
</ul>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><ul>
<li>(sno, cno, order) 表示学生选修课程的名次（名次各不相同）</li>
<li>函数依赖<ul>
<li>(sno, cno) $\to$ order</li>
<li>(cno, order) $\to$ sno</li>
</ul>
</li>
<li>候选码：(sno, cno) 、(cno, order)</li>
<li>是属于 BCNF 的，函数依赖的左边都是属于候选码</li>
</ul>
<h3 id="3NF-和-BCNF-的比较"><a href="#3NF-和-BCNF-的比较" class="headerlink" title="3NF 和 BCNF 的比较"></a>3NF 和 BCNF 的比较</h3><ul>
<li>比较下面两个模式各自的优缺点<ul>
<li>模式一：STC(sno,tno,cno)</li>
<li>模式二：ST(sno,tno), TC(tno,cno)</li>
</ul>
</li>
<li>为什么有时会需要 3NF 而非 BCNF 的模式设计？<ul>
<li>BCNF 可能会导致表分的过碎，表的数目过多，可能对一些复杂的查询造成<strong>性能</strong>上的影响</li>
<li>例如原始的 STC 表中是有函数依赖 (sno,cno) $\to$ tno 的，但是分开成 ST、C 两张表之后，这个函数不能体现了。这样我们可以在 ST 表（全码）中随意插入数据，而这样插入的数据可能不不满足<strong>函数依赖</strong>  (sno,cno) $\to$ tno</li>
</ul>
</li>
<li><strong>全码是 BCNF 的</strong></li>
</ul>
<h3 id="3NF-的另外一种定义"><a href="#3NF-的另外一种定义" class="headerlink" title="3NF 的另外一种定义"></a>3NF 的另外一种定义</h3><ul>
<li>关系模式 R 中的函数依赖 $X\to Y$，必须满足下述条件之一：<ul>
<li>$X\to Y$ 是平凡的函数依赖</li>
<li>X 是 R 的码</li>
<li><strong>Y 是主属性</strong></li>
</ul>
</li>
<li>上面表示，如果 Y 是主属性的话，则不要求 X 是候选码，这样允许函数传递依赖<ul>
<li>Z $\to$ X $\to$ Y</li>
</ul>
</li>
<li>3NF 允许存在主属性对码的不良依赖</li>
</ul>
<h3 id="BCNF-不良依赖的例子"><a href="#BCNF-不良依赖的例子" class="headerlink" title="BCNF 不良依赖的例子"></a>BCNF 不良依赖的例子</h3><ul>
<li>关系模式 TEACH(cno, tno, bno)</li>
<li>一门课程由多个教员担任</li>
<li>一门课程使用相同的一套参考书</li>
</ul>
<img src="05/image-20210507145742043.png" style="zoom:50%;" />

<ul>
<li>码是 (cno, tno, bno)，全码，属于 BCNF</li>
<li><strong>数据冗余很严重</strong></li>
<li>如果有一门课程没有参考书的话，就无法插入数据</li>
</ul>
<h3 id="BCNF-的不良依赖"><a href="#BCNF-的不良依赖" class="headerlink" title="BCNF 的不良依赖"></a>BCNF 的不良依赖</h3><ul>
<li><strong>插入异常</strong>：当某门课程增加一名教员时，其有多少本参考书就必须插入多少个元组</li>
<li><strong>删除异常</strong>：当删除一门课程的某个教员或者某本参考书时，需要删除多个元组</li>
<li><strong>更新异常</strong>：当一门课程的教员或参考书作出改变时，需要修改多个元组</li>
<li><strong>数据冗余</strong>：同一门课的教员与参考书的信息被反复存储多次</li>
</ul>
<h3 id="BCNF-冗余的根源"><a href="#BCNF-冗余的根源" class="headerlink" title="BCNF 冗余的根源"></a>BCNF 冗余的根源</h3><img src="05/image-20210507150123890.png" style="zoom:50%;" />

<ul>
<li>能否使用如下精简的表示</li>
</ul>
<img src="05/image-20210507150236800.png" style="zoom:50%;" />

<ul>
<li>信息都还在，是完整的</li>
<li>问题<ul>
<li>语义上是有问题的</li>
<li>删除的时候有问题，删除 B1 会把 T1 也删除掉</li>
</ul>
</li>
<li><strong>对等原则</strong>：标红的额外两行并不能提供更多信息，他们的存在纯粹是为了保证 tno 和 bno 彼此取值无关</li>
</ul>
<img src="05/image-20210507150434164.png" style="zoom:50%;" />



<h2 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h2><h3 id="多值依赖的描述型定义"><a href="#多值依赖的描述型定义" class="headerlink" title="多值依赖的描述型定义"></a>多值依赖的描述型定义</h3><ul>
<li>关系模式 $R(U)$，$X,Y,Z\subseteq U,Z&#x3D;U-X-Y$，多值依赖 $X\to\to Y$ 成立当且仅当<ul>
<li>对 $R(U)$ 的任一关系 $r$，给定的一对 $(x,z)$ 值对应有一组 $Y$ 的值，这组值仅仅决定于 $x$ 值而与 $z$ 值无关</li>
</ul>
</li>
<li>一个例子：<span id="CTB">CTB</span><ul>
<li>cno $\to\to$ tno</li>
</ul>
</li>
</ul>
<img src="05/image-20210507150434164.png" style="zoom:50%;" />

<ul>
<li>关系模式中的除法</li>
</ul>
<p>$$<br>\forall xz,Y_{xz}&#x3D;Y_x<br>$$</p>
<h3 id="多值依赖的形式化定义"><a href="#多值依赖的形式化定义" class="headerlink" title="多值依赖的形式化定义"></a>多值依赖的形式化定义</h3><ul>
<li>关系模式 $R(U)$，$X,Y,Z\subseteq U,Z&#x3D;U-X-Y$</li>
<li>对 $R(U)$ 的任一关系 $r$，若存在行  $t_1,t_2$ 使得 $t_1[X]&#x3D;t_2[X]$</li>
<li>那么就必然存在行  $t_3,t_4$，使得 $t_3&#x3D;(t_1[X],t_1[Y],t_2[Z]),t_4&#x3D;(t_2[X],t_2[Y],t_1[Z])$</li>
<li>则称 $Y$ 多值依赖 $X$，记作 $X\to\to Y$</li>
</ul>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><ul>
<li>结合上面的例子，交换 t[Z] 之后还是存在在表中，说明 Z 和 Y 无关</li>
<li><strong>对等原则</strong></li>
</ul>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a1</td>
<td align="center">b1</td>
<td align="center">c1</td>
</tr>
<tr>
<td align="center">a1</td>
<td align="center">b1</td>
<td align="center">c2</td>
</tr>
<tr>
<td align="center">a2</td>
<td align="center">b1</td>
<td align="center">c1</td>
</tr>
<tr>
<td align="center">a2</td>
<td align="center">b1</td>
<td align="center">c3</td>
</tr>
</tbody></table>
<ul>
<li>是否满足 $C\to\to B$<ul>
<li>满足</li>
<li>交换 A 还在表中</li>
</ul>
</li>
<li>改成满足 $B\to\to C$，需要加入那些行</li>
</ul>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a1</td>
<td align="center">b1</td>
<td align="center">c3</td>
</tr>
<tr>
<td align="center">a2</td>
<td align="center">b1</td>
<td align="center">c2</td>
</tr>
</tbody></table>
<h3 id="多值依赖的基本性质"><a href="#多值依赖的基本性质" class="headerlink" title="多值依赖的基本性质"></a>多值依赖的基本性质</h3><ul>
<li>多值依赖具有<strong>对称性</strong><ul>
<li>若 $X\to\to Y$，则 $X\to\to Z$，其中 $Z&#x3D;U-X-Y$</li>
</ul>
</li>
<li><strong>函数依赖是多值依赖的特例</strong><ul>
<li>若 $X\to Y$，则 $X\to\to Y$</li>
</ul>
</li>
<li>若 $X\to\to Y$，$U-X-Y&#x3D;\emptyset$，称 $X\to\to Y$ 为<strong>平凡的多值依赖</strong></li>
</ul>
<h2 id="4NF"><a href="#4NF" class="headerlink" title="4NF"></a>4NF</h2><ul>
<li>关系模式 $R(U)\in 1NF$ ，对于非平凡的多值依赖 $X\to\to Y(Y\not\subseteq X)$，X 含有码，则称 $R\in 4NF$</li>
<li>非 4NF 的主要弊端：<strong>数据冗余非常大</strong></li>
<li>如下，不满足 4NF<ul>
<li>cno $\to\to$ tno 不满足</li>
<li>cno $\to\to$ bno 不满足</li>
</ul>
</li>
</ul>
<img src="05/image-20210624235429721.png" style="zoom:50%;" />



<h3 id="如何将关系模式改造为4NF的"><a href="#如何将关系模式改造为4NF的" class="headerlink" title="如何将关系模式改造为4NF的"></a>如何将关系模式改造为4NF的</h3><ul>
<li>多值属性单独放在独立的关系模式中</li>
</ul>
<img src="05/image-20210507154339812.png" style="zoom:50%;" />



<h2 id="多值依赖与函数依赖"><a href="#多值依赖与函数依赖" class="headerlink" title="多值依赖与函数依赖"></a>多值依赖与函数依赖</h2><h3 id="多值依赖与函数依赖的基本区别"><a href="#多值依赖与函数依赖的基本区别" class="headerlink" title="多值依赖与函数依赖的基本区别"></a>多值依赖与函数依赖的基本区别</h3><ul>
<li><strong>相等产生依赖</strong><ul>
<li><strong>函数依赖</strong>规定某些元组不能出现在关系中</li>
<li>现有的行可能会排斥新来的行</li>
</ul>
</li>
<li><strong>元组产生依赖</strong><ul>
<li><strong>多值依赖</strong>要求某种形式的其它元组必须在关系中</li>
<li>现有的行要求新来的行同时插入一些其他行</li>
</ul>
</li>
</ul>
<h3 id="多值依赖与函数依赖有效性范围的不同"><a href="#多值依赖与函数依赖有效性范围的不同" class="headerlink" title="多值依赖与函数依赖有效性范围的不同"></a>多值依赖与函数依赖有效性范围的不同</h3><ul>
<li>$X\to Y$ 的有效性仅决定于 $X,Y$ 属性集上的值,，它在任何属性集 $W(XY\subseteq W\subseteq U)$ 上都成立</li>
<li>$X\to\to Y$ 在属性集 $W(XY\subseteq W\subseteq U)$  上成立，但在 $U$ 上不一定成立<ul>
<li>只能说明 Y 和 W-X-Y 无关</li>
<li>例如 $A\to\to B$ 在 ABC上成立，在 ABCD 上不一定成立</li>
<li>例子如下</li>
</ul>
</li>
</ul>
<img src="05/image-20210507160447953.png" style="zoom:50%;" />



<ul>
<li>有效性<ul>
<li>监视函数依赖：更新、插入</li>
<li>监视多值依赖：更新、插入、删除</li>
</ul>
</li>
<li>若 $X\to\to Y$ 在属性集 $W(XY\subseteq W\subseteq U)$  上成立，则称 $X\to\to Y$ 为 $R(U)$ 的<strong>嵌入式多值依赖</strong></li>
<li>若 $X\to\to Y$ 在属性集 U上成立，则 $X\to\to Y$ 在属性集 $W(XY\subseteq W\subseteq U)$ 上成立</li>
<li>若 $X\to Y$ 在 $R(U)$ 上成立，则对于 $\forall Y’\subseteq Y$ ，均有 $X\to Y’$ 成立</li>
<li>若 $X\to\to Y$ 在 $R(U)$ 上成立，则对于 $\forall Y’\subseteq Y$ ，<span style="color:red;font-weight:bold">不能保证</span>有 $X\to\to Y’$ 成立<ul>
<li>不能保证 Y’ 和 U-X-Y’ 是否相关</li>
<li>例子如下</li>
</ul>
</li>
</ul>
<img src="05/image-20210507160447953.png" style="zoom:50%;" />



<h3 id="验证函数依赖和多值依赖"><a href="#验证函数依赖和多值依赖" class="headerlink" title="验证函数依赖和多值依赖"></a>验证函数依赖和多值依赖</h3><ul>
<li>函数依赖 $A\to B$ ：下式为空</li>
</ul>
<p>$$<br>\sigma_{R.A&#x3D;S.A\land R.B\ne S.B}(R\times \rho_S(R))<br>$$</p>
<ul>
<li>多值依赖 $A\to\to B$<ul>
<li>C 的取值和 B 无关</li>
</ul>
</li>
</ul>
<p>$$<br>R&#x3D;\prod_{AB}(R)\bowtie\prod_{AC}(R)<br>$$</p>
<h2 id="连接依赖"><a href="#连接依赖" class="headerlink" title="连接依赖"></a>连接依赖</h2><ul>
<li>$R_1(U_1),R_2(U_2),\cdots,R_n(U_n)$ 是 $R(U)$ 的一个分解，$r$ 是 $R(U)$ 上的一个关系，若 $r&#x3D;\bowtie_{i&#x3D;1}^{n}\prod R_i(r)$</li>
<li>则称 $r$ 满足<strong>连接依赖</strong> ${}^\ast(R_1,R_2,\cdots,R_n)$</li>
</ul>
<img src="05/image-20210507161727543.png" style="zoom:50%;" />

<ul>
<li><strong>说明存在冗余</strong></li>
<li>现实中很少考虑连接依赖，检测代价太高</li>
<li>平凡连接依赖</li>
<li>连接依赖与多值依赖</li>
</ul>
<img src="05/image-20210507161852990.png" style="zoom:50%;" />

<img src="05/image-20210507162027483.png" style="zoom:50%;" />



<h2 id="PJNF"><a href="#PJNF" class="headerlink" title="PJNF"></a>PJNF</h2><ul>
<li>投影-连接范式（PJNF）</li>
<li>若$R\in PJNF$，则对于 $R$ 的任一连接依赖 ${}^\ast(R_1,R_2,\cdots,R_n)$ 必是下述情况之一：<ul>
<li>${}^\ast(R_1,R_2,\cdots,R_n)$ 是平凡的连接依赖</li>
<li>每个 $R_i$ 是 $R$ 的超码</li>
</ul>
</li>
</ul>
<h2 id="一些其他问题"><a href="#一些其他问题" class="headerlink" title="一些其他问题"></a>一些其他问题</h2><ul>
<li>任何一个二目关系模式 $R(A,B)$ ，一定属于 BCNF 吗？一定属于4NF 吗？</li>
<li>一个候选码全是<strong>单属性</strong>的关系模式最高一定可以达到第几范式？</li>
<li>一个全是<strong>主属性</strong>的关系模式最高一定可以达到第几范式？</li>
<li>一个只有一个候选码的 3NF 关系模式是 BCNF 的吗？</li>
<li>一个<strong>全码</strong>的关系模式最高一定可以达到第几范式？</li>
</ul>
<h2 id="各种范式的关系"><a href="#各种范式的关系" class="headerlink" title="各种范式的关系"></a>各种范式的关系</h2><ul>
<li>3NF $\in$ 2NF</li>
</ul>
<img src="05/image-20210507162525769.png" style="zoom:50%;" />

<ul>
<li>BCNF $\in$ 3NF</li>
</ul>
<img src="05/image-20210507162539860.png" style="zoom:50%;" />

<ul>
<li>PJNF $\in$ 4NF</li>
</ul>
<img src="05/image-20210507162558208.png" style="zoom:50%;" />

<ul>
<li>总结</li>
</ul>
<img src="05/image-20210507162613036.png" style="zoom:50%;" />
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/05/DB/CLJ/05/" data-id="cl9lj74av00fh64tzbcz04913" data-title="数据库概论.陈立军.05.关系规范化" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/YLQ-GAMES202/09" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/05/CG/YLQ-GAMES202/09/" class="article-date">
  <time class="dt-published" datetime="2021-05-05T03:11:26.000Z" itemprop="datePublished">2021-05-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES202/">CG.GAMES202</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/05/CG/YLQ-GAMES202/09/">GAMES202.闫令琪.09.实时全局光照(屏幕空间)(SSR)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY">https://www.bilibili.com/video/BV1YK4y1T7yY</a></li>
</ul>
<h1 id="屏幕空间全局光照"><a href="#屏幕空间全局光照" class="headerlink" title="屏幕空间全局光照"></a>屏幕空间全局光照</h1><h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><ul>
<li>Screen Space Reflection<ul>
<li>Screen Space RayTracing</li>
</ul>
</li>
<li>屏幕空间上做光线追踪<ul>
<li>不需要 3D 信息、三角形加速结构等</li>
</ul>
</li>
<li>Ritschel et al., <a target="_blank" rel="noopener" href="https://www.ea.com/frostbite/news/stochastic-screen-space-reflections">Stochastic Screen-Space Reflections</a>, SIGGRAPH 2015 course<ul>
<li>作者PPT，<a target="_blank" rel="noopener" href="http://advances.realtimerendering.com/s2015/Stochastic%20Screen-Space%20Reflections.pptx">原始网站</a></li>
</ul>
</li>
</ul>
<h3 id="现实、游戏中的反射"><a href="#现实、游戏中的反射" class="headerlink" title="现实、游戏中的反射"></a>现实、游戏中的反射</h3><ul>
<li>反射本质上就是全局光照</li>
</ul>
<img src="09/image-20210505112034773.png" style="zoom: 33%;" />

<ul>
<li>不评价好坏，工厂地板的反射可能本身就没这么亮</li>
<li>技术是不错的</li>
</ul>
<img src="09/image-20210505112138650.png" style="zoom:33%;" />



<h3 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h3><ul>
<li><strong>绝大多</strong>是反射的东西都是在图上有了的东西<ul>
<li>因此可以直接使用 Screen Space 的东西</li>
<li>白色框选部分反射的是红色框选部分</li>
</ul>
</li>
</ul>
<img src="09/image-20210505112333707.png" style="zoom:70%;" />



<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><ul>
<li>我们想做的是类似<strong>镜面反射</strong>的效果</li>
</ul>
<img src="09/image-20210505163251248.png" style="zoom:50%;" />

<ul>
<li>我们渲染好了整个场景，现在试图在地面上加入反射</li>
<li>对于每一个 fragment<ul>
<li>我们对其求出<strong>反射光线</strong></li>
<li>我们让反射光线和场景求交</li>
</ul>
</li>
<li><strong>SSR 可以做镜面反射，也可以做 glossy 材质的反射</strong></li>
<li>glossy 材质：采样</li>
<li>SSR 可以做地面不是平面的场景</li>
<li><strong>SSR 可以做任意的光线追踪</strong></li>
</ul>
<h3 id="SSR-思路"><a href="#SSR-思路" class="headerlink" title="SSR 思路"></a>SSR 思路</h3><ul>
<li>两个问题<ul>
<li>反射光在哪里</li>
<li>怎么做 shading</li>
</ul>
</li>
</ul>
<img src="09/image-20210505163631903.png" style="zoom:30%;" />



<h3 id="计算发射光位置"><a href="#计算发射光位置" class="headerlink" title="计算发射光位置"></a>计算发射光位置</h3><h4 id="Linear-Raymarch"><a href="#Linear-Raymarch" class="headerlink" title="Linear Raymarch"></a>Linear Raymarch</h4><ul>
<li>步进</li>
</ul>
<img src="09/image-20210505164249050.png" style="zoom:70%;" />

<ul>
<li>从 shading point 出发，沿着场景一步一步前进，利用深度图判断当前点是否和场景相交</li>
<li>找到相交的点，就把这个点作为次级光源</li>
<li>步长需要给定，怎么定义步长？<ul>
<li>步长太大，可能找到的点离真实的点很远</li>
<li>步长太小，计算量太大</li>
</ul>
</li>
</ul>
<h4 id="Hierarchical-ray-trace"><a href="#Hierarchical-ray-trace" class="headerlink" title="Hierarchical ray trace"></a>Hierarchical ray trace</h4><ul>
<li>动态决定步长的大小</li>
<li>例如下图中，反射点一开始可以直接走好几格都不会和壳（获得的图片相当于是场景的一个壳）</li>
<li>如果我们能够很快的获得可以走多少格都不会和壳相交，这样效率就会大大提高</li>
</ul>
<img src="09/image-20210505164743420.png" style="zoom:50%;" />

<ul>
<li>层次结构，对对深度图做一个 mipmap，但是我们对于上一层的 mipmap，对应区域取的是下一层的<strong>最小值</strong>，而不是平均值<ul>
<li>min-pooling</li>
</ul>
</li>
</ul>
<img src="09/image-20210505165208112.png" style="zoom:50%;" />

<ul>
<li>取最小值，可以保证我们如果在上层的 mipmap 中不相交，在下层的 mipmap 中也一定不相交<ul>
<li><strong>保守估计</strong></li>
</ul>
</li>
</ul>
<img src="09/image-20210505165449662.png" style="zoom:70%;" />

<ul>
<li>这样的层次结构就可以允许我们的步进值是好几个格子</li>
<li>从层次机构的根部开始判断<ul>
<li>如果和上层的 mipmap 不相交，则直接跨过这个区域</li>
<li>如果相交，则进入下一层的 mipmap<ul>
<li>有两个子结点，但是我们知道应该进入哪一个子结点</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mip = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(level &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    step through current cell;</span><br><span class="line">    <span class="keyword">if</span>(above Z plane) ++level;</span><br><span class="line">    <span class="keyword">if</span>(below Z plane) --level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>mipmap 存在问题，做不了起点不在 $2^k$ 上的最小值<ul>
<li>例如上面的例子，[2, 3] 格子之间的最小值就求不了</li>
</ul>
</li>
</ul>
<h3 id="SSR-的问题"><a href="#SSR-的问题" class="headerlink" title="SSR 的问题"></a>SSR 的问题</h3><ul>
<li>问题源自于屏幕空间</li>
<li>我们不知到我们没有看到的场景是什么，我们只了解一层壳</li>
<li><strong>下图中手掌心没了</strong></li>
</ul>
<img src="09/image-20210505173006720.png" style="zoom: 33%;" />

<ul>
<li><strong>下图中地面反射只有一部分窗帘</strong><ul>
<li>我们可以根据反射光走的距离进行一个衰减，这样子的话我们可以把边缘虚化，效果会好一点</li>
</ul>
</li>
</ul>
<img src="09/image-20210505173319014.png" style="zoom: 33%;" />

<ul>
<li>虚化后的结果</li>
</ul>
<img src="09/image-20210505173724688.png" style="zoom:33%;" />



<h3 id="Shading"><a href="#Shading" class="headerlink" title="Shading"></a>Shading</h3><ul>
<li>SSR 本质上就是把 path tracing 中光线和场景求交的问题转化成了光线和场景的壳求交的问题</li>
<li>所以之前 path tracing 的方法都可以直接使用</li>
</ul>
<p>$$<br>L_o(p,\omega_o)&#x3D;<br>\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)\cos\theta_i,\mathrm{d}\omega_i\<br>$$</p>
<ul>
<li>diffuse&#x2F;glossy：蒙特卡洛采样方法</li>
<li>specular：直接计算即可</li>
<li>我们有一个假设：<strong>反射物（次级光源）是 diffuse 的</strong><ul>
<li>和 RSM 一样，不然无法求出 $L_i(p,\omega_i)$</li>
<li>$L_i(p,\omega_i)&#x3D;L_o(q,q\to p)$</li>
</ul>
</li>
<li>是否需要距离衰减？<ul>
<li><strong>不需要</strong></li>
<li>还是对 BRDF 的立体角进行采样，而没有转化为光源的面积</li>
<li>只有对光源采样才会有平方衰减的问题</li>
</ul>
</li>
<li>次级光源和 shading point 的可见性问题？<ul>
<li>处理得很好，上面的 hierarchical ray tracing 求出的是第一个交点</li>
<li>只有对光源采样才会出现可见性问题</li>
</ul>
</li>
</ul>
<h3 id="SSR-可以模拟的结果"><a href="#SSR-可以模拟的结果" class="headerlink" title="SSR 可以模拟的结果"></a>SSR 可以模拟的结果</h3><ul>
<li><strong>以下现象只要你正确对 BRDF 采样计算，就能自然得到结果</strong></li>
<li>Sharp and blur reflections<ul>
<li>不同材质的反射结果</li>
</ul>
</li>
<li>contact hardening<ul>
<li>shading point 与次级光源离得越近，我们看到的反射越清晰</li>
<li>同样的反射叶，距离越远，圆锥的面积越大，结果就会模糊一些</li>
</ul>
</li>
<li>specular elongation<ul>
<li>雨天坐车看到红绿灯，地面看过去，发现红绿灯被垂直上下拉长了</li>
<li>认为地面是各向同性的，法线分布在一个标准的圆上，给定一个观察的方向，BRDF lobe 应该是一个长条的椭圆</li>
</ul>
</li>
</ul>
<p><img src="/09/image-20210505194523700.png"></p>
<ul>
<li>per-pixel roughness and normal<ul>
<li>我们本身没有对这些条件做出假设，因此是可以的</li>
</ul>
</li>
</ul>
<h3 id="Improvements"><a href="#Improvements" class="headerlink" title="Improvements"></a>Improvements</h3><ul>
<li>BRDF important sampling</li>
<li>glossy 物体<ul>
<li>因为反射光线是在一个 lobe 内部，没必要对四面八方均匀采样</li>
<li>只需要选择一个 PDF，让它和这个 lobe 形状一致</li>
</ul>
</li>
</ul>
<img src="09/image-20210505195534812.png" style="zoom:60%;" />

<ul>
<li>复用一些可行的光路，形成新的光路</li>
</ul>
<img src="09/image-20210505195447596.png" style="zoom:60%;" />

<ul>
<li>预先模糊<ul>
<li>Prefiltered samples</li>
<li>Weighed by each BRDF</li>
<li>对于 lobe 多次采样，等价于预先模糊再在镜面反射的方向上采样一次<ul>
<li>问题，屏幕空间上不同的点深度是不一样的</li>
<li>怎么做 filter 是个问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="SSR-评价"><a href="#SSR-评价" class="headerlink" title="SSR 评价"></a>SSR 评价</h3><h4 id="Pros"><a href="#Pros" class="headerlink" title="Pros"></a>Pros</h4><ul>
<li>Fast performance for glossy and specular reflections</li>
</ul>
<ul>
<li>Good quality</li>
</ul>
<ul>
<li>No spikes and occlusion issues</li>
</ul>
<h4 id="Cons"><a href="#Cons" class="headerlink" title="Cons"></a>Cons</h4><ul>
<li>Not as efficient in the diffuse case<ul>
<li>需要打出大量光线</li>
</ul>
</li>
<li>Missing information outside the screen</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/05/CG/YLQ-GAMES202/09/" data-id="cl9lj749w008x64tz3gzt9p0i" data-title="GAMES202.闫令琪.09.实时全局光照(屏幕空间)(SSR)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/MySQL/SQL-adventureworks" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/04/DB/MySQL/SQL-adventureworks/" class="article-date">
  <time class="dt-published" datetime="2021-05-04T09:20:00.000Z" itemprop="datePublished">2021-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-MySQL/">DB.MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/04/DB/MySQL/SQL-adventureworks/">MySQL 练习(订单表数据库)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SQL-查询练习"><a href="#SQL-查询练习" class="headerlink" title="SQL 查询练习"></a>SQL 查询练习</h1><h2 id="订单表"><a href="#订单表" class="headerlink" title="订单表"></a>订单表</h2><blockquote>
<p>这是一个自行车制造和销售公司的数据库，该公司建立自己的销售网站，提供在线销售。<br>由于adventureworks数据库所含表的类型过多，这里只介绍题目中涉及到了表及字段。</p>
<p>关于该数据库可以参考：<a target="_blank" rel="noopener" href="http://www.uml.org.cn/sjjm/201905103.asp">http://www.uml.org.cn/sjjm/201905103.asp</a></p>
<p>product(ProductID,Name,ProductModelID,ListPrice)<br>person(FirstName,MiddleName,LastName)<br>salesorderdetail(SalesOrderID,SalesOrderDetailID,OrderQty,ProductID,UnitPrice,UnitPriceDiscount,LineTotal)</p>
<p>product:产品ID,产品名字，产品类型ID(不同的产品ID可能具有相同的产品类型ID),产品标价<br>person:姓名<br>salesorderdetail:这笔订单的ID(不是主键，可能有ID相同的记录)，订单详细ID,订单涉及的产品数量，产品ID，单元价格，单元价格折扣，销售总额</p>
<p>注意：每个产品的没有打折之前的销售总额&#x3D;OrderQty x UnitPrice,打折之后的销售总额&#x3D;OrderQty x UnitPrice x UnitPriceDiscount</p>
<p>其他参考：<a href="/resources/DB/AdventureWorks.pdf">数据库说明</a></p>
<p>salesorderheader(SalesOrderID, RevisionNumber, OrderDate, DueDate, ShipDate, Status, OnlineOrderFlag, SalesOrderNumber, PurchaseOrderNumber, AccountNumber, CustomerID, SalesPersonID, TerritoryID, BillToAddressID, ShipToAddressID, ShipMethodID, CreditCardID, CreditCardApprovalCode, CurrencyRateID, SubTotal, TaxAmt, Freight, TotalDue, Comment, rowguid, ModifiedDate)</p>
<p>address(AddressID, AddressLine1, AddressLine2, City, StateProvinceID, PostalCode, SpatialLocation, rowguid, ModifiedDate)</p>
<p>businessentityaddress(BusinessEntityID, AddressID, AddressTypeID, rowguid, ModifiedDate)</p>
</blockquote>
<ul>
<li>在Product表中查出所有产品信息，按产品名升序排列</li>
<li>输出格式：Name, ProductNumber, ListPrice</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Name, ProductNumber, ListPrice</span><br><span class="line"><span class="keyword">from</span> product</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Name <span class="keyword">asc</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查出每种产品类型均价等于该类产品最高标价的产品类型号</li>
<li>涉及表：Product</li>
<li>输出格式为(ProductModelID)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ProductModelID</span><br><span class="line"><span class="keyword">from</span> product</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ProductModelID</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(ListPrice) <span class="operator">=</span> <span class="built_in">max</span>(ListPrice)</span><br></pre></td></tr></table></figure>

<ul>
<li>查出每个销售订单的销售总额</li>
<li>涉及表：SalesOrderDetail</li>
<li>输出格式为(SalesOrderID,total[&#x3D;sum(LineTotal)])</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SalesOrderID, <span class="built_in">sum</span>(LineTotal) total</span><br><span class="line"><span class="keyword">from</span> salesorderdetail</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> SalesOrderID</span><br></pre></td></tr></table></figure>

<ul>
<li>查出标价大于1000的产品，求出这些产品的均价(按ProductModelID分组)</li>
<li>涉及表：Product</li>
<li>输出格式为(ProductModelID,avg_price[avg(ListPrice)])</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ProductModelID, <span class="built_in">avg</span>(ListPrice)</span><br><span class="line"><span class="keyword">from</span> product</span><br><span class="line"><span class="keyword">where</span> ListPrice <span class="operator">&gt;</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ProductModelID</span><br></pre></td></tr></table></figure>

<ul>
<li>查出总销量大于5的产品ID，并按总销量排序</li>
<li>涉及表：salesorderdetail</li>
<li>输出格式为(ProductID,count[&#x3D;sum(OrderQty])</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ProductID, <span class="built_in">sum</span>(OrderQty) count</span><br><span class="line"><span class="keyword">from</span> salesorderdetail</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ProductID</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">sum</span>(OrderQty) <span class="operator">&gt;</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(OrderQty) <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查出所有商品的没有打折之前的销售额NonDiscountSales，打折之后的销售额Discounts，按ProductName逆序返回</li>
<li>输出格式为(ProductName,NonDiscountSales,Discounts)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Name, OrderQty<span class="operator">*</span>UnitPrice NonDiscountSales, OrderQty<span class="operator">*</span>UnitPrice<span class="operator">*</span>UnitPriceDiscount Discounts</span><br><span class="line"><span class="keyword">from</span> salesorderdetail s <span class="keyword">inner</span> <span class="keyword">join</span> product p <span class="keyword">on</span> s.ProductID <span class="operator">=</span> p.ProductID</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> p.Name <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查询所有名字以“Chain”开头的ProductID,Name</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ProductID, Name</span><br><span class="line"><span class="keyword">from</span> product</span><br><span class="line"><span class="keyword">where</span> Name <span class="keyword">like</span> <span class="string">&#x27;Chain%&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从Person表中选出MiddleName中包含E或B字符的the business entity ID number, first name, middle name, 和 last name</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> BusinessEntityID, FirstName, MiddleName, LastName</span><br><span class="line"><span class="keyword">from</span> person</span><br><span class="line"><span class="keyword">where</span> MiddleName regexp <span class="string">&#x27;.*[ebEB].*&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义每个员工参与的所有订单的总销售额(sum(LineTotal))作为员工的业绩</li>
<li>列出每个城市的业绩排名前三的员工</li>
<li>涉及表(salesorderheader,salesorderdetail,address,businessentityaddress)</li>
<li>输出格式为(city,SalesPersonID)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> TMP <span class="keyword">as</span>(</span><br><span class="line">    <span class="keyword">select</span> SalesPersonID, <span class="built_in">sum</span>(LineTotal) totalMoney, ad.City</span><br><span class="line">    <span class="keyword">from</span> salesorderheader sh</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> salesorderdetail sd</span><br><span class="line">    <span class="keyword">on</span> sd.SalesOrderID <span class="operator">=</span> sh.SalesOrderID <span class="keyword">and</span> <span class="keyword">not</span> isNULL(SalesPersonID)</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> businessentityaddress bea</span><br><span class="line">    <span class="keyword">on</span> sh.SalesPersonID <span class="operator">=</span> bea.BusinessEntityID</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> address ad</span><br><span class="line">    <span class="keyword">on</span> bea.AddressID <span class="operator">=</span> ad.AddressID</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> SalesPersonID, ad.City</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> City, SalesPersonID</span><br><span class="line"><span class="keyword">from</span> TMP</span><br><span class="line"><span class="keyword">where</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> TMP t1</span><br><span class="line">    <span class="keyword">where</span> t1.City <span class="operator">=</span> TMP.City <span class="keyword">and</span> t1.totalMoney <span class="operator">&gt;</span> TMP.totalMoney</span><br><span class="line">) <span class="operator">&lt;=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">and</span> <span class="keyword">not</span> isNull(City)</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">not</span> isNull(SalesPersonID)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> City <span class="keyword">asc</span></span><br></pre></td></tr></table></figure>

<ul>
<li>找出交易过四次以上（不包括四次）的顾客，输出这些顾客对应的订单信息</li>
<li>涉及表(SalesOrderHeader)</li>
<li>输出格式为(CustomerID,SalesOrderID,OrderDate)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> TMP <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> CustomerID <span class="keyword">from</span> salesorderheader</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> CustomerID</span><br><span class="line">    <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> s.CustomerID CustomerID, s.SalesOrderID SalesOrderID, s.OrderDate OrderDate</span><br><span class="line"><span class="keyword">from</span> TMP <span class="keyword">inner</span> <span class="keyword">join</span> salesorderheader s <span class="keyword">on</span> TMP.CustomerID <span class="operator">=</span> s.CustomerID</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/04/DB/MySQL/SQL-adventureworks/" data-id="cl9lj74am00dx64tzg7480h9e" data-title="MySQL 练习(订单表数据库)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/MySQL/SQL-employees" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/04/DB/MySQL/SQL-employees/" class="article-date">
  <time class="dt-published" datetime="2021-05-04T09:10:00.000Z" itemprop="datePublished">2021-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-MySQL/">DB.MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/04/DB/MySQL/SQL-employees/">MySQL 练习(员工数据库)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SQL-查询练习"><a href="#SQL-查询练习" class="headerlink" title="SQL 查询练习"></a>SQL 查询练习</h1><h2 id="员工数据库"><a href="#员工数据库" class="headerlink" title="员工数据库"></a>员工数据库</h2><p><img src="/SQL-employees/employees_details.png"></p>
<ul>
<li>查询每个部门的经理信息。输出格式为（部门名，经理姓，经理名），按部门名升序输出</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> D.dept_name, E.last_name, E.first_name</span><br><span class="line"><span class="keyword">from</span> (departments D <span class="keyword">left</span> <span class="keyword">join</span> dept_manager DM <span class="keyword">on</span> D.dept_no <span class="operator">=</span> DM.dept_no)</span><br><span class="line">                    <span class="keyword">left</span> <span class="keyword">join</span> employees E <span class="keyword">on</span> DM.emp_no <span class="operator">=</span> E.emp_no</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> D.dept_name <span class="keyword">asc</span></span><br></pre></td></tr></table></figure>

<ul>
<li>找出那些至少拥有三个title并且至少在两个部门工作过的员工，要求按升序输出前十个员工号<ul>
<li><strong>count 的时候需要去重</strong></li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> E.emp_no</span><br><span class="line"><span class="keyword">from</span> employees E <span class="keyword">inner</span> <span class="keyword">join</span> dept_emp DE <span class="keyword">on</span> E.emp_no <span class="operator">=</span> DE.emp_no</span><br><span class="line">                 <span class="keyword">inner</span> <span class="keyword">join</span> titles T <span class="keyword">on</span> E.emp_no <span class="operator">=</span> T.emp_no</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> E.emp_no</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> T.title) <span class="operator">&gt;=</span> <span class="number">3</span> <span class="keyword">and</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> DE.dept_no) <span class="operator">&gt;=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> E.emp_no <span class="keyword">asc</span></span><br><span class="line">limit <span class="number">10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>找出比其部门经理工资高的员工，要求输出列是（员工号，经理员工号），按员工号升序，员工号相同的按经理员工号升序，列出前十个。<strong>注意</strong>：有些员工会在多个部门任职，部门经理也会轮换，所以两者在同一部门工作的日期必须有交集。而任期内工资也可能是变化的，所以还必须考虑工资日期的交集。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> DE.emp_no, DM.emp_no</span><br><span class="line"><span class="keyword">from</span> (dept_emp DE <span class="keyword">inner</span> <span class="keyword">join</span> salaries S1 <span class="keyword">on</span>(</span><br><span class="line">    <span class="comment">/* 工资在部门任期之内 */</span></span><br><span class="line">    DE.emp_no <span class="operator">=</span> S1.emp_no</span><br><span class="line">    <span class="keyword">and</span> S1.from_date <span class="operator">&gt;=</span> DE.from_date</span><br><span class="line">    <span class="keyword">and</span> S1.to_date <span class="operator">&lt;=</span> DE.to_date</span><br><span class="line">)),</span><br><span class="line">(dept_manager DM <span class="keyword">inner</span> <span class="keyword">join</span> salaries S2 <span class="keyword">on</span>(</span><br><span class="line">    DM.emp_no <span class="operator">=</span> S2.emp_no</span><br><span class="line">    <span class="keyword">and</span> S2.from_date <span class="operator">&gt;=</span> DM.from_date</span><br><span class="line">    <span class="keyword">and</span> S2.to_date <span class="operator">&lt;=</span> DM.to_date</span><br><span class="line">))</span><br><span class="line"><span class="keyword">where</span> DM.dept_no <span class="operator">=</span> DE.dept_no        <span class="comment">/* 部门经理 */</span></span><br><span class="line">    <span class="keyword">and</span> S1.salary <span class="operator">&gt;</span> S2.salary        <span class="comment">/* 工资更高 */</span></span><br><span class="line">    <span class="comment">/* 工资时间交集 */</span></span><br><span class="line">    <span class="keyword">and</span> (S1.from_date <span class="operator">&lt;=</span> S2.to_date <span class="keyword">and</span> S2.from_date <span class="operator">&lt;=</span> S1.to_date)</span><br><span class="line">    <span class="comment">/* 工作时间交集 */</span></span><br><span class="line">    <span class="keyword">and</span> (DM.from_date <span class="operator">&lt;=</span> DE.to_date <span class="keyword">and</span> DE.from_date <span class="operator">&lt;=</span> DM.to_date)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> DE.emp_no <span class="keyword">asc</span>, DM.emp_no <span class="keyword">asc</span></span><br><span class="line">limit <span class="number">10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将每个部门的员工的姓串接在一列中，要求以逗号分隔，按姓升序排序，仅包括前5个员工。输出格式为（部门号，员工姓），按部门号升序输出。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> DE.dept_no, substring_index(</span><br><span class="line">    group_concat(E.last_name <span class="keyword">order</span> <span class="keyword">by</span> E.last_name <span class="keyword">asc</span> separator <span class="string">&#x27;,&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> dept_emp DE <span class="keyword">inner</span> <span class="keyword">join</span> employees E <span class="keyword">on</span> DE.emp_no <span class="operator">=</span> E.emp_no</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> DE.dept_no</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> DE.dept_no <span class="keyword">asc</span></span><br></pre></td></tr></table></figure>

<ul>
<li>列出每个部门中的最高和最低工资的员工及其工资。输出格式为（部门号，最高工资员工号，最高工资，最低工资员工号，最低工资）。<strong>注意</strong>：员工某一时期的工资，日期范围要和在该部门任职日期范围有交集，才能算作该部门的工资</li>
<li>先找出最高工资，再找到人</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 超时了 */</span></span><br><span class="line"><span class="keyword">with</span> TMP <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> S.salary salary, E.emp_no emp_no, DE.dept_no dept_no</span><br><span class="line"><span class="keyword">from</span> dept_emp DE <span class="keyword">inner</span> <span class="keyword">join</span> employees E <span class="keyword">on</span> DE.emp_no <span class="operator">=</span> E.emp_no</span><br><span class="line">                 <span class="keyword">inner</span> <span class="keyword">join</span> salaries S <span class="keyword">on</span> (</span><br><span class="line">                     E.emp_no <span class="operator">=</span> S.emp_no <span class="keyword">and</span></span><br><span class="line">                     <span class="comment">/* 工资在部门任期之内 */</span></span><br><span class="line">                     S.from_date <span class="operator">&gt;=</span> DE.from_date <span class="keyword">and</span> S.to_date <span class="operator">&lt;=</span> DE.to_date</span><br><span class="line">                 )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> t_max.dept_no, t3.emp_no, max_salary, t4.emp_no, min_salary</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line"><span class="comment">/* 先求出最高工资 */</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> t1.dept_no dept_no, <span class="built_in">max</span>(t1.salary) max_salary</span><br><span class="line">    <span class="keyword">from</span> TMP t1</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> t1.dept_no</span><br><span class="line">) t_max</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line"><span class="comment">/* 最低工资 */</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> t2.dept_no dept_no, <span class="built_in">min</span>(t2.salary) min_salary</span><br><span class="line">    <span class="keyword">from</span> TMP t2</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> t2.dept_no</span><br><span class="line">) t_min</span><br><span class="line"><span class="keyword">on</span> t_max.dept_no <span class="operator">=</span> t_min.dept_no</span><br><span class="line"><span class="comment">/* 再连接 */</span></span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> TMP t3</span><br><span class="line"><span class="keyword">on</span> t3.dept_no <span class="operator">=</span> t_max.dept_no <span class="keyword">and</span> t3.salary <span class="operator">=</span> t_max.max_salary</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> TMP t4</span><br><span class="line"><span class="keyword">on</span> t4.dept_no <span class="operator">=</span> t_min.dept_no <span class="keyword">and</span> t4.salary <span class="operator">=</span> t_min.min_salary</span><br></pre></td></tr></table></figure>

<ul>
<li>最大最小同时求，这样就不会超时</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> TMP <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> S.salary salary, E.emp_no emp_no, DE.dept_no dept_no</span><br><span class="line"><span class="keyword">from</span> dept_emp DE <span class="keyword">inner</span> <span class="keyword">join</span> employees E <span class="keyword">on</span> DE.emp_no <span class="operator">=</span> E.emp_no</span><br><span class="line">                 <span class="keyword">inner</span> <span class="keyword">join</span> salaries S <span class="keyword">on</span> (</span><br><span class="line">                     E.emp_no <span class="operator">=</span> S.emp_no <span class="keyword">and</span></span><br><span class="line">                     <span class="comment">/* 工资在部门任期之内 */</span></span><br><span class="line">                     S.from_date <span class="operator">&gt;=</span> DE.from_date <span class="keyword">and</span> S.to_date <span class="operator">&lt;=</span> DE.to_date</span><br><span class="line">                 )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> t_m.dept_no, t3.emp_no, max_salary, t4.emp_no, min_salary</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line"><span class="comment">/* 先求出最高最低工资 */</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> t1.dept_no dept_no, <span class="built_in">max</span>(t1.salary) max_salary, <span class="built_in">min</span>(t1.salary) min_salary</span><br><span class="line">    <span class="keyword">from</span> TMP t1</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> t1.dept_no</span><br><span class="line">) t_m</span><br><span class="line"><span class="comment">/* 再连接 */</span></span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> TMP t3</span><br><span class="line"><span class="keyword">on</span> t3.dept_no <span class="operator">=</span> t_m.dept_no <span class="keyword">and</span> t3.salary <span class="operator">=</span> t_m.max_salary</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> TMP t4</span><br><span class="line"><span class="keyword">on</span> t4.dept_no <span class="operator">=</span> t_m.dept_no <span class="keyword">and</span> t4.salary <span class="operator">=</span> t_m.min_salary</span><br></pre></td></tr></table></figure>

<ul>
<li>查询最高工资所在的部门中的最低工资是多少？输出格式为（部门号，最高工资，最低工资），按部门号升序输出。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> TMP <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> S.salary salary, E.emp_no emp_no, DE.dept_no dept_no</span><br><span class="line"><span class="keyword">from</span> dept_emp DE <span class="keyword">inner</span> <span class="keyword">join</span> employees E <span class="keyword">on</span> DE.emp_no <span class="operator">=</span> E.emp_no</span><br><span class="line">                 <span class="keyword">inner</span> <span class="keyword">join</span> salaries S <span class="keyword">on</span> (</span><br><span class="line">                     E.emp_no <span class="operator">=</span> S.emp_no <span class="keyword">and</span></span><br><span class="line">                     <span class="comment">/* 工资在部门任期之内 */</span></span><br><span class="line">                     S.from_date <span class="operator">&gt;=</span> DE.from_date <span class="keyword">and</span> S.to_date <span class="operator">&lt;=</span> DE.to_date</span><br><span class="line">                 )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> t_m.dept_no, max_salary msalary, min_salary nsalary</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> t1.dept_no dept_no, <span class="built_in">max</span>(t1.salary) max_salary, <span class="built_in">min</span>(t1.salary) min_salary</span><br><span class="line">    <span class="keyword">from</span> TMP t1</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> t1.dept_no</span><br><span class="line">) t_m</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> max_salary <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>选做。比较男女职工的平均工资差异。一个人的生涯平均工资这样计算：先将某段时间内的年薪换算成日薪（统一用一年360天），再乘以在这个年薪水平下所工作的天数，得到收入，将所有不同时段的收入加起来，再除以总天数，这样就得到总平均日薪了，求所有男女员工的平均日薪也是类似做法。输出格式为（男职工平均日薪，女职工平均日薪，平均日薪差）。<strong>注意：</strong>to_date是’9999-01-01’的统一用最大的from_date+一年 代替，即’2003-08-01’</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TODO */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>11027号员工有过三个不同的title， 将其按如下表格形式输出</li>
</ul>
<table>
<thead>
<tr>
<th align="center">emp_no</th>
<th align="center">tenure1</th>
<th align="center">tenure2</th>
<th align="center">tenure3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">11027</td>
<td align="center">1986-05-07~1991-05-07\nAssistant Engineer</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MySQL 字符串拼接不能直接用 +, 需要使用 concat(,) */</span></span><br><span class="line"><span class="keyword">select</span> emp_no,</span><br><span class="line">    concat(</span><br><span class="line">        DATE_FORMAT(T1.from_date,<span class="string">&#x27;%Y-%m-%d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;~&#x27;</span>,</span><br><span class="line">        DATE_FORMAT(T1.to_date,<span class="string">&#x27;%Y-%m-%d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;\n&#x27;</span>,</span><br><span class="line">        T1.title</span><br><span class="line">    ) tenure1,</span><br><span class="line">    concat(</span><br><span class="line">        DATE_FORMAT(T2.from_date,<span class="string">&#x27;%Y-%m-%d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;~&#x27;</span>,</span><br><span class="line">        DATE_FORMAT(T2.to_date,<span class="string">&#x27;%Y-%m-%d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;\n&#x27;</span>,</span><br><span class="line">        T2.title</span><br><span class="line">    ) tenure2,</span><br><span class="line">    concat(</span><br><span class="line">        DATE_FORMAT(T3.from_date,<span class="string">&#x27;%Y-%m-%d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;~&#x27;</span>,</span><br><span class="line">        DATE_FORMAT(T3.to_date,<span class="string">&#x27;%Y-%m-%d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;\n&#x27;</span>,</span><br><span class="line">        T3.title</span><br><span class="line">    ) tenure3</span><br><span class="line"><span class="keyword">from</span> titles T1 <span class="keyword">join</span> titles T2 <span class="keyword">using</span>(emp_no) <span class="keyword">join</span> titles T3 <span class="keyword">using</span>(emp_no)</span><br><span class="line"><span class="keyword">where</span> emp_no <span class="operator">=</span> <span class="number">11027</span> <span class="keyword">and</span> T1.from_date <span class="operator">&lt;</span> T2.from_date <span class="keyword">and</span> T2.from_date <span class="operator">&lt;</span> T3.from_date</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/04/DB/MySQL/SQL-employees/" data-id="cl9lj74an00e264tzht106u2s" data-title="MySQL 练习(员工数据库)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/MySQL/SQL-SPJ" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/04/DB/MySQL/SQL-SPJ/" class="article-date">
  <time class="dt-published" datetime="2021-05-04T09:00:00.000Z" itemprop="datePublished">2021-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-MySQL/">DB.MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/04/DB/MySQL/SQL-SPJ/">MySQL 练习(SPJ 数据库)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SQL-查询练习"><a href="#SQL-查询练习" class="headerlink" title="SQL 查询练习"></a>SQL 查询练习</h1><h2 id="SPJ"><a href="#SPJ" class="headerlink" title="SPJ"></a>SPJ</h2><blockquote>
<p>供应商数据库SPJ中有三张表：<br>S(SNO, SNAME, STATUS, CITY)<br>P(PNO, PNAME, COLOR, WEIGHT, CITY)<br>J(JNO, JNAME,CITY)<br>SPJ(SNO, PNO, JNO, QTY, PRICE)</p>
<p>S表示供应商，各属性依次为供应商号，供应商名，供应商状态值，供应商所在城市；<br>P表示零件，各属性依次为零件号，零件名，零件颜色，零件重量，零件存放的城市；<br>J表示工程，各属性依次为工程号，工程名，工程所在城市；<br>SPJ表示供货关系，各属性依次为供应商号，零件号，工程号，供货数量，单价。</p>
</blockquote>
<ul>
<li>求没有供应零件号为P1和P2两种零件的供应商姓名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> SNAME</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> SNO <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> SNO</span><br><span class="line">    <span class="keyword">from</span> SPJ</span><br><span class="line">    <span class="keyword">where</span> PNO <span class="operator">=</span> <span class="string">&#x27;P1&#x27;</span> <span class="keyword">or</span> PNO <span class="operator">=</span> <span class="string">&#x27;P2&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2 */</span></span><br><span class="line"><span class="keyword">select</span> SNAME</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> SNO <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> SNO</span><br><span class="line">    <span class="keyword">from</span> SPJ</span><br><span class="line">    <span class="keyword">where</span> PNO <span class="operator">=</span> <span class="string">&#x27;P1&#x27;</span> <span class="keyword">or</span> PNO <span class="operator">=</span> <span class="string">&#x27;P2&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>列出所有供应商的信息，包括供应商姓名、所供应的零件名（没有供应零件的供应商也要列出，最后结果中不要出现重复元组）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> S.SNAME, P.PNAME</span><br><span class="line"><span class="keyword">from</span> S,SPJ,P</span><br><span class="line"><span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br></pre></td></tr></table></figure>

<ul>
<li>求只向与自己位于不同城市的工程供应零件的供应商姓名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SNAME</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> SNAME <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> SNAME</span><br><span class="line">    <span class="keyword">from</span> S,SPJ,J</span><br><span class="line">    <span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.JNO <span class="operator">=</span> J.JNO <span class="keyword">and</span> S.CITY <span class="operator">=</span> J.CITY</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>求只向与自己位于不同城市的工程供应零件的供应商姓名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SNAME</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> SNAME <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> SNAME</span><br><span class="line">    <span class="keyword">from</span> S,SPJ,J</span><br><span class="line">    <span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.JNO <span class="operator">=</span> J.JNO <span class="keyword">and</span> S.CITY <span class="operator">!=</span> J.CITY</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>求供应了所有零件的供应商姓名<ul>
<li><strong>不存在</strong>一个零件，所求的供应商<strong>没有</strong>供应</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SNAME</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> PNO <span class="comment">/* 使用了*则不可能使用索引 */</span></span><br><span class="line">    <span class="keyword">from</span> P</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">        <span class="keyword">select</span> SNO <span class="comment">/* 使用了*则不可能使用索引 */</span></span><br><span class="line">        <span class="keyword">from</span> SPJ</span><br><span class="line">        <span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>求供应了所有红色零件的供应商姓名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SNAME</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> PNO</span><br><span class="line">    <span class="keyword">from</span> P</span><br><span class="line">    <span class="keyword">where</span> P.COLOR <span class="operator">=</span> <span class="string">&#x27;红色&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">        <span class="keyword">select</span> SNO</span><br><span class="line">        <span class="keyword">from</span> SPJ</span><br><span class="line">        <span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>列出每个城市的工程所使用的零件总的数量<ul>
<li>left join：可能有 0 个</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> CITY, <span class="built_in">sum</span>(QTY)</span><br><span class="line"><span class="keyword">from</span> J <span class="keyword">left</span> <span class="keyword">join</span> SPJ <span class="keyword">on</span> J.JNO <span class="operator">=</span> SPJ.JNO</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> CITY</span><br></pre></td></tr></table></figure>

<ul>
<li>按零件数量总和的降序列出每项工程所使用的每种红色零件的总的金额（工程可以向不同的供应商购买同一零件，总金额＝单价*供货数量）。输出工程号、零件号、总金额</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SPJ.JNO, SPJ.PNO, <span class="built_in">sum</span>(QTY<span class="operator">*</span>PRICE)</span><br><span class="line"><span class="keyword">from</span> J,SPJ,P</span><br><span class="line"><span class="keyword">where</span> J.JNO <span class="operator">=</span> SPJ.JNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO <span class="keyword">and</span> P.COLOR <span class="operator">=</span> <span class="string">&#x27;红色&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> SPJ.JNO, SPJ.PNO</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(QTY) <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>

<ul>
<li>求供应零件数量最多的供应商姓名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SNAME</span><br><span class="line"><span class="keyword">from</span> S,SPJ,P</span><br><span class="line"><span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> SPJ.SNO</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">sum</span>(QTY) <span class="operator">&gt;=</span> <span class="keyword">all</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">sum</span>(QTY)</span><br><span class="line">    <span class="keyword">from</span> S,SPJ,P</span><br><span class="line">    <span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> SPJ.SNO</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>求每个城市中供应零件数量最多的供应商姓名。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> S1.CITY, SNAME</span><br><span class="line"><span class="keyword">from</span> S S1,SPJ,P</span><br><span class="line"><span class="keyword">where</span> S1.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> SPJ.SNO, S1.CITY</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">sum</span>(QTY) <span class="operator">&gt;=</span> <span class="keyword">all</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">sum</span>(QTY)</span><br><span class="line">    <span class="keyword">from</span> S,SPJ,P</span><br><span class="line">    <span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO <span class="keyword">and</span> S.CITY <span class="operator">=</span> S1.CITY</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> SPJ.SNO</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>列出恰好供应了相同零件的供应商对。输出的时候，供应商对小号在前，相等不输出，要去重，都没有供应零件也算供应了相同零件。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> S1.SNAME, S2.SNAME</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="comment">/* 给每一个供应商组织一个供应零件的序列 */</span></span><br><span class="line">    <span class="keyword">select</span> S.SNAME, group_concat(<span class="keyword">distinct</span> P.PNO <span class="keyword">order</span> <span class="keyword">by</span> P.PNO) GC_PNO</span><br><span class="line">    <span class="keyword">from</span> S, SPJ, P</span><br><span class="line">    <span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> S.SNO</span><br><span class="line">) S1, (</span><br><span class="line">    <span class="keyword">select</span> S.SNAME, group_concat(<span class="keyword">distinct</span> P.PNO <span class="keyword">order</span> <span class="keyword">by</span> P.PNO) GC_PNO</span><br><span class="line">    <span class="keyword">from</span> S, SPJ, P</span><br><span class="line">    <span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> S.SNO</span><br><span class="line">) S2</span><br><span class="line"><span class="comment">/* 使用小于号去重 */</span></span><br><span class="line"><span class="keyword">where</span> S1.GC_PNO <span class="operator">=</span> S2.GC_PNO <span class="keyword">and</span> S1.SNAME <span class="operator">&lt;</span> S2.SNAME</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/04/DB/MySQL/SQL-SPJ/" data-id="cl9lj74al00dp64tz7l3b7h2s" data-title="MySQL 练习(SPJ 数据库)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB/CLJ/04-7" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/03/DB/CLJ/04-7/" class="article-date">
  <time class="dt-published" datetime="2021-05-03T13:38:19.000Z" itemprop="datePublished">2021-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB-CLJ/">DB.CLJ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/03/DB/CLJ/04-7/">数据库概论.陈立军.04.SQL 安全性</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="在线-SQL"><a href="#在线-SQL" class="headerlink" title="在线 SQL"></a>在线 SQL</h1><ul>
<li><a target="_blank" rel="noopener" href="http://sqlfiddle.com/">http://sqlfiddle.com/</a></li>
<li>MySQL 5.6</li>
</ul>
<h1 id="SQL-安全性"><a href="#SQL-安全性" class="headerlink" title="SQL 安全性"></a>SQL 安全性</h1><ul>
<li>数据库的安全性是很重要的</li>
</ul>
<h2 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h2><ul>
<li>主体（principal）<ul>
<li>是可以授予权限以访问特定数据库对象的对象，包括<strong>登录用户</strong>、<strong>角色</strong>、<strong>应用程序</strong></li>
</ul>
</li>
</ul>
<h3 id="SQL-Server-下三个级别的主体"><a href="#SQL-Server-下三个级别的主体" class="headerlink" title="SQL Server 下三个级别的主体"></a>SQL Server 下三个级别的主体</h3><h4 id="Windows-级别的主体"><a href="#Windows-级别的主体" class="headerlink" title="Windows 级别的主体"></a>Windows 级别的主体</h4><ul>
<li>Windows 域用户帐号&#x2F;组、本地用户帐号&#x2F;组，基于 Windows 身份验证</li>
<li>创建Windows登录名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> login login_name <span class="keyword">from</span> windows</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> login [ljchen<span class="operator">-</span>PC\SQLUser] <span class="keyword">from</span> windows</span><br></pre></td></tr></table></figure>

<ul>
<li>删除Windows登录名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> login login_name</span><br></pre></td></tr></table></figure>

<ul>
<li>拒绝和允许 Windows 用户访问 SQL Server</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deny <span class="keyword">connect</span> <span class="keyword">SQL</span> <span class="keyword">to</span> login_name</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">connect</span> <span class="keyword">SQL</span> <span class="keyword">to</span> login_name</span><br></pre></td></tr></table></figure>

<ul>
<li>查看Windows登录名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys.server_principals</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name,type,sid,principal_id</span><br><span class="line"><span class="keyword">from</span> sys.server_principals</span><br><span class="line"><span class="keyword">where</span> type_desc<span class="operator">=</span><span class="string">&#x27;WINDOWS_LOGIN&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="SQL-Server-级别的主体"><a href="#SQL-Server-级别的主体" class="headerlink" title="SQL Server 级别的主体"></a>SQL Server 级别的主体</h4><ul>
<li><p>SQL Server 级别的登录名和固定服务器角色</p>
</li>
<li><p>创建 SQL Server 登录名</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> login login_name</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> login sweetHeart</span><br><span class="line"><span class="keyword">with</span> password<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span></span><br><span class="line">default_database<span class="operator">=</span><span class="string">&#x27;demoDB&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看 SQL Server 登录名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name,type,sid,principal_id</span><br><span class="line"><span class="keyword">from</span> sys.server_principals</span><br><span class="line"><span class="keyword">where</span> type_desc<span class="operator">=</span><span class="string">&#x27;SQL_LOGIN&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="数据库级别的主体"><a href="#数据库级别的主体" class="headerlink" title="数据库级别的主体"></a>数据库级别的主体</h4><ul>
<li><p>数据库用户、数据库角色、应用程序角色</p>
</li>
<li><p>创建 SQL Server 数据库用户</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> user_name</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> Carefully</span><br><span class="line"><span class="keyword">for</span> login [ljchen<span class="operator">-</span>PC\SQLUser]</span><br><span class="line"><span class="keyword">with</span> default_schema<span class="operator">=</span>Finance</span><br></pre></td></tr></table></figure>

<ul>
<li>删除数据库用户</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure>

<ul>
<li>报告数据库用户信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_helpuser</span><br></pre></td></tr></table></figure>



<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul>
<li>角色是一组<strong>相关权限</strong>的集合，即将多个不同的权限集合在一起就形成了角色</li>
<li>如果直接把权限分给用户，权限授予关系非常繁琐</li>
<li>通常数据库上的权限是和职位（角色）对应的</li>
</ul>
<img src="04-7/image-20210505214704801.png" style="zoom:50%;" />

<ul>
<li>查看 SQL Server 固定服务器角色</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> sys.server_principals</span><br><span class="line"><span class="keyword">where</span> type_desc<span class="operator">=</span><span class="string">&#x27;SERVER_ROLE&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>添加登录名到固定服务器角色</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_addsrvrolemember</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_addsrvrolemember <span class="string">&#x27;sweetHeart&#x27;</span>, <span class="string">&#x27;sysadmin&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从固定服务器角色删除登录名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_dropsrvrolemember</span><br></pre></td></tr></table></figure>

<ul>
<li>添加用户名到数据库角色</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_addrolemember</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> sp_addrolemember <span class="string">&#x27;db_datawriter&#x27;</span>, <span class="string">&#x27;Carefully&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从数据库角色删除用户名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_droprolemember</span><br></pre></td></tr></table></figure>

<ul>
<li>查看 SQL Server 固定数据库角色</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_helpdbfixedrole</span><br></pre></td></tr></table></figure>

<ul>
<li>查看角色成员</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_helprolemember</span><br></pre></td></tr></table></figure>



<h2 id="客体"><a href="#客体" class="headerlink" title="客体"></a>客体</h2><ul>
<li>客体<ul>
<li>安全对象（securable）</li>
<li>主体所操纵的对象</li>
</ul>
</li>
<li>服务器范围：登录名、数据库和端点</li>
<li>数据库范围：数据库用户、角色、架构</li>
<li>架构范围：各种对象，如表、视图、函数、存储过程等</li>
</ul>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><ul>
<li>权限（permission）<ul>
<li>允许主体在安全对象上执行操作</li>
</ul>
</li>
<li>权限的转授和回收<ul>
<li>允许用户<strong>把已获得的权限转授给其他用户</strong>，或者<strong>把已授给其他用户的权限再回收上来</strong></li>
</ul>
</li>
</ul>
<h3 id="权限图"><a href="#权限图" class="headerlink" title="权限图"></a>权限图</h3><ul>
<li>结点是用户，根结点是 DBA</li>
<li>有向边 $U_i\to;U_j$，表示用户 $U_i$ 把某权限授给用户 $U_j$</li>
<li>一个用户拥有权限的<strong>充分必要条件</strong>是在权限图中有一条从根结点到该用户结点的路径</li>
<li>回收某个结点权限的时候，需要把这个结点转授的权限收回<ul>
<li>上面一行<ul>
<li>回收 U1 的时候，需要回收 U4 的权限</li>
</ul>
</li>
<li>下面一行<ul>
<li>只回收 U2，结果是第二张小图</li>
<li>回收 U2、U3，需要把 U2、U3 之间的权限都回收</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="04-7/image-20210505221247912.png" style="zoom:50%;" />



<h3 id="报告可用权限"><a href="#报告可用权限" class="headerlink" title="报告可用权限"></a>报告可用权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys.fn_builtin_permissions</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> class_desc,</span><br><span class="line">    permission_name,</span><br><span class="line">    covering_permission_name,</span><br><span class="line">    parent_class_desc,</span><br><span class="line">    parent_covering_permission_name</span><br><span class="line"><span class="keyword">from</span> sys.fn_builtin_permissions(<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="授权命令"><a href="#授权命令" class="headerlink" title="授权命令"></a>授权命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限</span><br><span class="line"><span class="keyword">on</span> 对象名</span><br><span class="line"><span class="keyword">to</span> &#123;用户[,用户]...<span class="operator">|</span>public&#125;</span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">grant</span> option]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>with grant option</code>：获得权限的用户可以把权限再授予其它用户</li>
<li><strong>表级权限</strong><ul>
<li>select, update, insert, delete, index, alter, drop, resource 等以及它们的总和 all</li>
</ul>
</li>
<li>为什么需要 references 权限<ul>
<li>是否允许其他用户定义外码来参照这个表？</li>
<li>可能出现泄密的可能</li>
</ul>
</li>
</ul>
<h3 id="回收权限"><a href="#回收权限" class="headerlink" title="回收权限"></a>回收权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> 权限</span><br><span class="line"><span class="keyword">on</span> 对象</span><br><span class="line"><span class="keyword">from</span> &#123;用户[,用户]...<span class="operator">|</span>public&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>授权路径的起点一定是 DBA</li>
<li>收回权限时，若该用户已将权限转授给其它用户，则也一并收回</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 授予权限 */</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>, <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> S</span><br><span class="line"><span class="keyword">to</span> Liming</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">grant</span> option</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回收权限 */</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> S</span><br><span class="line"><span class="keyword">from</span> Liming</span><br></pre></td></tr></table></figure>



<h3 id="当前用户"><a href="#当前用户" class="headerlink" title="当前用户"></a>当前用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable">@usrchar</span>(<span class="number">30</span>)</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@usr</span><span class="operator">=</span><span class="keyword">user</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;The current user is: &#x27;</span> <span class="operator">+</span> <span class="variable">@usr</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实现精细存取控制<ul>
<li>普通员工只能查看自己的记录</li>
<li>部门经理可以查看他所管理的员工</li>
<li>人力资源代表可以查看所有员工</li>
</ul>
</li>
<li>不同的用户执行相同的命令，可能返回的结果是不一样的</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> SNAME <span class="operator">=</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure>



<h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><ul>
<li>审计就是对指定用户在数据库中的操作情况进行<strong>监控和记录</strong>，用以审查用户的相关活动<ul>
<li>数据被非授权用户删除，用户越权管理，权限管理不正确，用户获得不应有的系统权限等</li>
</ul>
</li>
<li>审计就是<strong>监视和收集关于指定数据库获得的数据</strong><ul>
<li>哪些表经常被修改，用户共执行了多少次 I&#x2F;O 操作等，为优化提供依据</li>
</ul>
</li>
</ul>
<h3 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h3><ul>
<li>服务器审核</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> server audit MyServerAuditto file ...</span><br></pre></td></tr></table></figure>

<ul>
<li>服务器审核规范</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> server audit specification MyServerAuditSpe</span><br><span class="line"><span class="keyword">for</span> server audit MyServerAudit</span><br><span class="line"><span class="keyword">alter</span> server audit specification MyServerAuditSpe</span><br><span class="line"><span class="keyword">add</span> (SERVER_PRINCIPAL_CHANGE_GROUP)</span><br></pre></td></tr></table></figure>

<ul>
<li>数据库审核规范</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database audit specification MyDBAudit</span><br><span class="line"><span class="keyword">for</span> server audit MyServerAudit</span><br><span class="line"><span class="keyword">alter</span> database audit specification MyDBAudit</span><br><span class="line"><span class="keyword">add</span> (SELECTONS)</span><br></pre></td></tr></table></figure>

<ul>
<li>查看审核历史</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> event_time, succeeded, statement</span><br><span class="line"><span class="keyword">from</span> sys.fn_get_audit_file(…)</span><br></pre></td></tr></table></figure>



<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="短语加密"><a href="#短语加密" class="headerlink" title="短语加密"></a>短语加密</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encryptByPassPhrase(&#123; <span class="string">&#x27;passphrase&#x27;</span>, <span class="string">&#x27;cleartext&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> encryptByPassPhrase(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;whoami&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="还原数据"><a href="#还原数据" class="headerlink" title="还原数据"></a>还原数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decryptByPassPhrase( &#123; <span class="string">&#x27;passphrase&#x27;</span>, <span class="string">&#x27;ciphertext&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> decryptByPassPhrase(<span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line"><span class="number">0x0100000021D68E2E078E3EA6752239788B69D8B9BF1AD542A7C9774C9CAF66304F215F49</span>)</span><br></pre></td></tr></table></figure>



<h3 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">asymmetric</span> key myAsym_key</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(ename, salary)</span><br><span class="line"><span class="keyword">values</span>(<span class="string">&#x27;tom&#x27;</span>, EncryptByAsymkey(Asymkey_ID(<span class="string">&#x27;myAsym_key&#x27;</span>),<span class="number">100000000</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> DecryptByAsymkey(</span><br><span class="line">    Asymkey_ID(<span class="string">&#x27;myAsym_key&#x27;</span>), salary</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;tom&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">symmetric</span> key mySym_key</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(ename,salary)</span><br><span class="line"><span class="keyword">values</span>(<span class="string">&#x27;tom&#x27;</span>, EncryptBykey(Key_GUID(<span class="string">&#x27;mySym_key&#x27;</span>),<span class="number">100000000</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> DecryptByKey(</span><br><span class="line">Key_GUID(<span class="string">&#x27;mySym_key&#x27;</span>),salary)</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;tom&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h2><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><ul>
<li>认证过程发出的查询语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;jake&#x27;</span></span><br><span class="line"><span class="keyword">and</span> PASSWORD<span class="operator">=</span><span class="string">&#x27;jakespasswd&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>攻击者篡改这个SQL语句<ul>
<li>这样的话始终为真</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;jake&#x27;</span></span><br><span class="line"><span class="keyword">and</span>(PASSWORD<span class="operator">=</span><span class="string">&#x27;jakespasswd&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;x&#x27;</span><span class="operator">=</span><span class="string">&#x27;x&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>现在这种情况比较少，数据库会先对用户的输入进行一个检查</li>
</ul>
<h2 id="基于视图的安全性控制"><a href="#基于视图的安全性控制" class="headerlink" title="基于视图的安全性控制"></a>基于视图的安全性控制</h2><ul>
<li>授权 Tom 只有察看职工平均工资的权限</li>
<li>定义一个视图，仅授予用户这个权限</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> avg_sal</span><br><span class="line"><span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">avg</span>(sal)</span><br><span class="line">    <span class="keyword">from</span> PROF</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">SELECT</span> <span class="keyword">on</span> avg_sal <span class="keyword">to</span> <span class="string">&#x27;Tom&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="资源控制：Oracle"><a href="#资源控制：Oracle" class="headerlink" title="资源控制：Oracle"></a>资源控制：Oracle</h2><ul>
<li>PROFILE</li>
</ul>
<img src="04-7/image-20210505225532090.png" style="zoom:70%;" />



<h2 id="统计数据库安全"><a href="#统计数据库安全" class="headerlink" title="统计数据库安全"></a>统计数据库安全</h2><ul>
<li>要求：<strong>用户只能查询数据的聚集值，不能访问个体</strong></li>
</ul>
<h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><ul>
<li>漏洞一：个体太少<ul>
<li>查询选修 ”古典哲学史“ 的学生的平均成绩（假设只有一个人选）</li>
<li>解决方案：可以做一个限制，如果返回记录数小于设定值 k 条，则不返回结果</li>
</ul>
</li>
<li>漏洞二：多次查询，太多交叠<ul>
<li>Q1：查询 n 个学生的总成绩为 x</li>
<li>Q2：查询 n 个学生＋A 的总成绩为 y</li>
<li>A 的总成绩为 y-x</li>
<li>解决方案：两个查询的交不能多于m</li>
</ul>
</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>查询引用的数据不能少于 n</li>
<li>两个查询的交不能多于 m</li>
<li>推出个体信息至少需要 $1+\dfrac{n-2}{m}$ 次查询</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>Student (ID, GPA)，ID从1 到 50</li>
<li>任何查询结果只能是一个聚集值</li>
<li>每次至少使用 4 条元组</li>
<li>任何两个查询的交不能大于 2 条元组</li>
<li>给出一个查询集合，使得能确定 ID&#x3D;9 的 GPA</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 我的一个解答 */</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">9</span>;</span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span>;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span>;</span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span>;</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>



<h2 id="隐私保护"><a href="#隐私保护" class="headerlink" title="隐私保护"></a>隐私保护</h2><h3 id="数据发布"><a href="#数据发布" class="headerlink" title="数据发布"></a>数据发布</h3><ul>
<li>数据脱敏处理<ul>
<li>例如把个体姓名抹去</li>
</ul>
</li>
</ul>
<img src="04-7/image-20210505231933683.png" style="zoom:60%;" />

<ul>
<li>还是可能会出现数据泄露的问题</li>
</ul>
<h3 id="连接推理"><a href="#连接推理" class="headerlink" title="连接推理"></a>连接推理</h3><ul>
<li>[Swe00] 的研究表明，87％的美国人口信息可以通过性别、出生日期、5位邮政编码进行个人重建</li>
</ul>
<img src="04-7/image-20210505232109407.png" style="zoom:60%;" />



<h3 id="k-anonymity"><a href="#k-anonymity" class="headerlink" title="k-anonymity"></a>k-anonymity</h3><ul>
<li>k 匿名</li>
<li>有相同的准标识属性组（QI）的元组至少有 k 个（2-anonymous）</li>
</ul>
<img src="04-7/image-20210505232433215.png" style="zoom:67%;" />
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/03/DB/CLJ/04-7/" data-id="cl9lj74at00f364tz2xvs0m5d" data-title="数据库概论.陈立军.04.SQL 安全性" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/17/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/19/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/0/">0</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algebra/">Algebra</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-Kits/">C++.Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG/">CG</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Algorithm/">CG.Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES101/">CG.GAMES101</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES102/">CG.GAMES102</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES103/">CG.GAMES103</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES104/">CG.GAMES104</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES202/">CG.GAMES202</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES203/">CG.GAMES203</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Kits/">CG.Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-LS/">CG.LS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-PBRT/">CG.PBRT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Paper/">CG.Paper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CV/">CV</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Code/">Code</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-CLJ/">DB.CLJ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-MySQL/">DB.MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-SQLServer/">DB.SQLServer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DSA/">DSA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kits/">Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-CXQ/">OS.CXQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-OSTEP/">OS.OSTEP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-xv6-labs/">OS.xv6-labs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-xv6-source-code/">OS.xv6-source-code</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TODO/">TODO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/book-directory/">book.directory</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computation-pyr/">computation.pyr</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/csharp-kits/">csharp.kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/csharp-tds/">csharp.tds</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/images/">images</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/installation/">installation</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mitsuba/">mitsuba</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nothing/">nothing</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-Maya/">software.Maya</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-ps/">software.ps</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-vscode/">software.vscode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/win/">win</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algebra/" rel="tag">Algebra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS/" rel="tag">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BST/" rel="tag">BST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BVH/" rel="tag">BVH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CG-Algorithm/" rel="tag">CG-Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CV/" rel="tag">CV</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Code/" rel="tag">Code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB/" rel="tag">DB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/" rel="tag">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DSA/" rel="tag">DSA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dijkstra/" rel="tag">Dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EG/" rel="tag">EG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Floyd/" rel="tag">Floyd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GI/" rel="tag">GI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Glints/" rel="tag">Glints</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDR/" rel="tag">HDR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HQX/" rel="tag">HQX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Heap/" rel="tag">Heap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kits/" rel="tag">Kits</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCA/" rel="tag">LCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLG/" rel="tag">LLG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MCMC/" rel="tag">MCMC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MIS/" rel="tag">MIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MLT/" rel="tag">MLT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maya/" rel="tag">Maya</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NEE/" rel="tag">NEE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBRT/" rel="tag">PBRT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paper/" rel="tag">Paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Radiometry/" rel="tag">Radiometry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RayTracing/" rel="tag">RayTracing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SAH/" rel="tag">SAH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SDF/" rel="tag">SDF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SGJ/" rel="tag">SGJ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLServer/" rel="tag">SQLServer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shadow/" rel="tag">Shadow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WHM/" rel="tag">WHM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WX/" rel="tag">WX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/book/" rel="tag">book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/computation/" rel="tag">computation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csharp/" rel="tag">csharp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/images/" rel="tag">images</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/installation/" rel="tag">installation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/" rel="tag">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mitsuba/" rel="tag">mitsuba</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobaxterm/" rel="tag">mobaxterm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nothing/" rel="tag">nothing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/obs/" rel="tag">obs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/occlusion/" rel="tag">occlusion</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ps/" rel="tag">ps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/software/" rel="tag">software</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tree/" rel="tag">tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/win/" rel="tag">win</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xv6/" rel="tag">xv6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%83%E5%AE%87%E5%AE%99/" rel="tag">元宇宙</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%A0%E4%BD%95/" rel="tag">几何</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/" rel="tag">可见性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" rel="tag">拓扑排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%99%AE%E5%90%95%E5%85%8B%E5%9D%90%E6%A0%87/" rel="tag">普吕克坐标</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="tag">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algebra/" style="font-size: 10px;">Algebra</a> <a href="/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/tags/BST/" style="font-size: 10px;">BST</a> <a href="/tags/BVH/" style="font-size: 12.5px;">BVH</a> <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/CG/" style="font-size: 20px;">CG</a> <a href="/tags/CG-Algorithm/" style="font-size: 10px;">CG-Algorithm</a> <a href="/tags/CV/" style="font-size: 10.63px;">CV</a> <a href="/tags/Code/" style="font-size: 14.38px;">Code</a> <a href="/tags/DB/" style="font-size: 19.38px;">DB</a> <a href="/tags/DFS/" style="font-size: 12.5px;">DFS</a> <a href="/tags/DP/" style="font-size: 13.13px;">DP</a> <a href="/tags/DSA/" style="font-size: 11.25px;">DSA</a> <a href="/tags/Dijkstra/" style="font-size: 10px;">Dijkstra</a> <a href="/tags/EG/" style="font-size: 12.5px;">EG</a> <a href="/tags/Floyd/" style="font-size: 10.63px;">Floyd</a> <a href="/tags/GI/" style="font-size: 11.25px;">GI</a> <a href="/tags/Glints/" style="font-size: 10px;">Glints</a> <a href="/tags/HDR/" style="font-size: 10px;">HDR</a> <a href="/tags/HQX/" style="font-size: 10px;">HQX</a> <a href="/tags/Heap/" style="font-size: 10px;">Heap</a> <a href="/tags/Kits/" style="font-size: 13.75px;">Kits</a> <a href="/tags/LCA/" style="font-size: 10px;">LCA</a> <a href="/tags/LLG/" style="font-size: 12.5px;">LLG</a> <a href="/tags/MCMC/" style="font-size: 10.63px;">MCMC</a> <a href="/tags/MIS/" style="font-size: 10px;">MIS</a> <a href="/tags/MLT/" style="font-size: 10px;">MLT</a> <a href="/tags/Maya/" style="font-size: 10px;">Maya</a> <a href="/tags/MySQL/" style="font-size: 11.88px;">MySQL</a> <a href="/tags/NEE/" style="font-size: 10px;">NEE</a> <a href="/tags/OS/" style="font-size: 17.5px;">OS</a> <a href="/tags/PBRT/" style="font-size: 10px;">PBRT</a> <a href="/tags/Paper/" style="font-size: 15.63px;">Paper</a> <a href="/tags/Radiometry/" style="font-size: 10px;">Radiometry</a> <a href="/tags/RayTracing/" style="font-size: 10px;">RayTracing</a> <a href="/tags/SAH/" style="font-size: 10px;">SAH</a> <a href="/tags/SDF/" style="font-size: 10px;">SDF</a> <a href="/tags/SGJ/" style="font-size: 10.63px;">SGJ</a> <a href="/tags/SQL/" style="font-size: 13.13px;">SQL</a> <a href="/tags/SQLServer/" style="font-size: 10.63px;">SQLServer</a> <a href="/tags/STL/" style="font-size: 11.25px;">STL</a> <a href="/tags/Shadow/" style="font-size: 10px;">Shadow</a> <a href="/tags/WHM/" style="font-size: 16.88px;">WHM</a> <a href="/tags/WX/" style="font-size: 11.88px;">WX</a> <a href="/tags/YLQ/" style="font-size: 18.13px;">YLQ</a> <a href="/tags/book/" style="font-size: 10.63px;">book</a> <a href="/tags/computation/" style="font-size: 18.75px;">computation</a> <a href="/tags/csharp/" style="font-size: 16.25px;">csharp</a> <a href="/tags/images/" style="font-size: 10px;">images</a> <a href="/tags/installation/" style="font-size: 11.88px;">installation</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/linux/" style="font-size: 11.25px;">linux</a> <a href="/tags/math/" style="font-size: 10px;">math</a> <a href="/tags/mitsuba/" style="font-size: 11.88px;">mitsuba</a> <a href="/tags/mobaxterm/" style="font-size: 10px;">mobaxterm</a> <a href="/tags/nothing/" style="font-size: 10.63px;">nothing</a> <a href="/tags/obs/" style="font-size: 10px;">obs</a> <a href="/tags/occlusion/" style="font-size: 15px;">occlusion</a> <a href="/tags/ps/" style="font-size: 10px;">ps</a> <a href="/tags/software/" style="font-size: 10px;">software</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/tree/" style="font-size: 11.25px;">tree</a> <a href="/tags/vscode/" style="font-size: 10.63px;">vscode</a> <a href="/tags/win/" style="font-size: 10.63px;">win</a> <a href="/tags/xv6/" style="font-size: 16.25px;">xv6</a> <a href="/tags/%E4%BA%8C%E5%88%86/" style="font-size: 10.63px;">二分</a> <a href="/tags/%E5%85%83%E5%AE%87%E5%AE%99/" style="font-size: 10.63px;">元宇宙</a> <a href="/tags/%E5%87%A0%E4%BD%95/" style="font-size: 10px;">几何</a> <a href="/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/" style="font-size: 11.88px;">可见性</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 10.63px;">并查集</a> <a href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">拓扑排序</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%99%AE%E5%90%95%E5%85%8B%E5%9D%90%E6%A0%87/" style="font-size: 10px;">普吕克坐标</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 10px;">最小生成树</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" style="font-size: 13.13px;">最短路</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 10px;">线段树</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/23/CG/WHM-GAMES103/11/">GAMES103.王华民.11.Incompressible Fluid Dynamics and Eulerian Fluids</a>
          </li>
        
          <li>
            <a href="/2022/10/23/CG/Papers/2021/bvh-survey-3/">(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(4)</a>
          </li>
        
          <li>
            <a href="/2022/04/28/CG/Kits/MIS-NEE/">NEE、MIS(多重重要性采样)</a>
          </li>
        
          <li>
            <a href="/2022/04/18/CG/WHM-GAMES103/10/">GAMES103.王华民.10.Surface Waves</a>
          </li>
        
          <li>
            <a href="/2022/04/17/CG/WHM-GAMES103/09-1/">GAMES103.王华民.09.Collision Handling(1)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>