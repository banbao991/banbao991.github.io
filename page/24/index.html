<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/24/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-CG/YLQ-GAMES101/02" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/13/CG/YLQ-GAMES101/02/" class="article-date">
  <time class="dt-published" datetime="2021-03-13T06:31:39.000Z" itemprop="datePublished">2021-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES101/">CG.GAMES101</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/13/CG/YLQ-GAMES101/02/">GAMES101.闫令琪.02.Shading(Lecture 07-09)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av90798049">https://www.bilibili.com/video/av90798049</a></li>
</ul>
<h1 id="Lecture-07"><a href="#Lecture-07" class="headerlink" title="Lecture 07"></a>Lecture 07</h1><ul>
<li>Shading 1 (Illumination, Shading and Graphics Pipeline)</li>
<li>着色（光照与基本着色模型）</li>
</ul>
<h1 id="Lecture-08"><a href="#Lecture-08" class="headerlink" title="Lecture 08"></a>Lecture 08</h1><ul>
<li>Shading 2 (Shading, pipeline and texture mapping)</li>
<li>着色（着色频率、图形管线、纹理映射）</li>
</ul>
<h2 id="Blinn-Phong-模型"><a href="#Blinn-Phong-模型" class="headerlink" title="Blinn-Phong 模型"></a>Blinn-Phong 模型</h2><ul>
<li>ambient + diffuse + specular</li>
<li>单位向量<ul>
<li>光源方向：$\vec{l}$（指向光源）</li>
<li>法向：$\vec{n}$</li>
<li>视线方向：$\vec{v}$</li>
<li>光线反射方向：$\vec{r}$</li>
</ul>
</li>
<li>光源到物体反射点的距离 $r$</li>
</ul>
<h3 id="1-Diffuse"><a href="#1-Diffuse" class="headerlink" title="(1) Diffuse"></a>(1) Diffuse</h3><p>$$<br>L_d&#x3D;k_d\dfrac{I}{r^2}\max(\vec{n}\cdot\vec{l},0)<br>$$</p>
<h3 id="2-Specular"><a href="#2-Specular" class="headerlink" title="(2) Specular"></a>(2) Specular</h3><ul>
<li>半程向量：$h$</li>
</ul>
<p>$$<br>\vec{h}&#x3D;bisector(\vec{v},\vec{l})&#x3D;\dfrac{\vec{v}+\vec{n}}{||\vec{v}+\vec{n}||}<br>$$</p>
<p>$$<br>L_s&#x3D;k_s\dfrac{I}{r^2}\max(\vec{n}\cdot\vec{h},0)^p<br>$$</p>
<ul>
<li>Phong 模型中使用 $\vec{r}\cdot\vec{v}$<ul>
<li>Blinn-Phong 模型是一个改进<ul>
<li>相对好算</li>
<li>$\vec{v},\vec{r}$ 的夹角大于90度时应该也能有部分高光<ul>
<li>不会出现 Phong 模型中的高光断层问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>$p$ 限制反光范围<ul>
<li>实际应用：100 - 200</li>
</ul>
</li>
</ul>
<h3 id="3-Ambient"><a href="#3-Ambient" class="headerlink" title="(3) Ambient"></a>(3) Ambient</h3><ul>
<li>模拟间接光照</li>
<li>实际上是不存在的 <strong>FAKE</strong></li>
</ul>
<p>$$<br>L_a&#x3D;k_aI_a<br>$$</p>
<ul>
<li>光源到物体的距离会引发能量损失，<span style="color:red;font-weight:bold">视点到物体的距离不会</span></li>
</ul>
<h2 id="Shading-Frequencies"><a href="#Shading-Frequencies" class="headerlink" title="Shading Frequencies"></a>Shading Frequencies</h2><ul>
<li><strong>着色频率</strong>：多大的区域应用一次着色算法<ul>
<li>频率越高，着色算法应用的区域越小，着色算法使用的次数越多</li>
</ul>
</li>
<li>Flat Shading<ul>
<li><strong>逐三角形</strong> Face</li>
<li>一个三角形只有一个法线，三角形内部没有颜色变化</li>
</ul>
</li>
<li>Gouraud Shading<ul>
<li><strong>逐顶点</strong> Vertex</li>
<li>一个三角形的每一个顶点进行一次着色计算，内部颜色使用插值计算出来</li>
</ul>
</li>
<li>Phong Shading<ul>
<li><strong>逐像素</strong> Pixel</li>
<li>对三角形所在区域的每一个像素进行光照计算</li>
</ul>
</li>
<li>模型足够复杂（面的细分够小）的时候，可能面的个数比像素多<ul>
<li>逐三角形绘制可能耗时</li>
<li>逐像素绘制也不一定比逐三角形绘制效果好</li>
</ul>
</li>
</ul>
<h2 id="怎么知道顶点-x2F-像素的法线"><a href="#怎么知道顶点-x2F-像素的法线" class="headerlink" title="怎么知道顶点&#x2F;像素的法线"></a>怎么知道顶点&#x2F;像素的法线</h2><ul>
<li>如果知道已知模型，可以通过已知的几何模型中获取（例如本身是球体）</li>
<li>不知道的话，可以对这个顶点关联的面的法线求一个平均<ul>
<li>亦可以加权平均</li>
</ul>
</li>
<li>像素的法线：插值<ul>
<li>重心坐标</li>
</ul>
</li>
</ul>
<h2 id="Graphics-Pipeline（Real-time-Pipeline）"><a href="#Graphics-Pipeline（Real-time-Pipeline）" class="headerlink" title="Graphics Pipeline（Real-time Pipeline）"></a>Graphics Pipeline（Real-time Pipeline）</h2><ul>
<li>vertex processing</li>
<li>triangle processing</li>
<li>rasterization</li>
<li>fragment processing</li>
<li>framebuffer processing</li>
</ul>
<h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><ul>
<li>vertex shader</li>
<li>fragment shader</li>
<li>OpenGL: GLSL</li>
</ul>
<h2 id="Texture-Mapping"><a href="#Texture-Mapping" class="headerlink" title="Texture Mapping"></a>Texture Mapping</h2><ul>
<li>纹理映射</li>
<li>纹理用于定义着色的时候所用的属性<ul>
<li>一般用于代替漫反射系数 $K_d$</li>
</ul>
</li>
<li>3D 物体表面可以和一张 2D 表面相对应</li>
<li>空间中的三角形怎么和 2D 平面上的纹理相对应<ul>
<li>美工设计</li>
<li>自动化：parametric（参数化）</li>
</ul>
</li>
<li>纹理坐标系 uv<ul>
<li>通常认为 u,v 范围都是 [0, 1]</li>
</ul>
</li>
<li>纹理可以被重复使用<ul>
<li>设计的好的时候，重复的时候可以无缝连接</li>
</ul>
</li>
<li>纹素：texel<ul>
<li>a pixel on a texture</li>
</ul>
</li>
</ul>
<h1 id="Lecture-09"><a href="#Lecture-09" class="headerlink" title="Lecture 09"></a>Lecture 09</h1><ul>
<li>Texture Mapping</li>
<li>插值、高级纹理映射</li>
</ul>
<h2 id="Barycentric-Coordinates"><a href="#Barycentric-Coordinates" class="headerlink" title="Barycentric Coordinates"></a>Barycentric Coordinates</h2><ul>
<li>重心坐标</li>
<li>为了做三角形内的插值<ul>
<li>知道顶点属性，可以平滑的插值三角形内部的属性</li>
</ul>
</li>
<li>三角形 $ABC$ 所在平面内的任意一点 $(x,y)$ 都可以用 $ABC$ 三个顶点的坐标线性组合得出</li>
</ul>
<p>$$<br>(x,y)&#x3D;\alpha A + \beta B+\gamma C,\alpha+\beta+\gamma&#x3D;1<br>$$</p>
<ul>
<li>如果点 $(x,y)$ 在三角形内部，<strong>系数不为负</strong><ul>
<li>系数与面积相关</li>
</ul>
</li>
</ul>
<img src="02/1615614278867.png" style="zoom:50%;" />

<ul>
<li>或者直接利用坐标计算</li>
</ul>
<p>$$<br>\begin{aligned}<br>\alpha &amp;&#x3D;\frac{-\left(x-x_{B}\right)\left(y_{C}-y_{B}\right)+\left(y-y_{B}\right)\left(x_{C}-x_{B}\right)}{-\left(x_{A}-x_{B}\right)\left(y_{C}-y_{B}\right)+\left(y_{A}-y_{B}\right)\left(x_{C}-x_{B}\right)} \<br>\beta &amp;&#x3D;\frac{-\left(x-x_{C}\right)\left(y_{A}-y_{C}\right)+\left(y-y_{C}\right)\left(x_{A}-x_{C}\right)}{-\left(x_{B}-x_{C}\right)\left(y_{A}-y_{C}\right)+\left(y_{B}-y_{C}\right)\left(x_{A}-x_{C}\right)} \<br>\gamma &amp;&#x3D;1-\alpha-\beta<br>\end{aligned}<br>$$</p>
<ul>
<li>可以直接利用重心坐标进行属性插值</li>
<li>存在的一个问题，<strong>投影变换下重心坐标会变化</strong><ul>
<li>例如深度值的插值应该在世界坐标系&#x2F;观察中进行，不能在投影坐标系下进行</li>
</ul>
</li>
</ul>
<h2 id="Texture-Mapping-1"><a href="#Texture-Mapping-1" class="headerlink" title="Texture Mapping"></a>Texture Mapping</h2><h3 id="Simple-Texture-Mapping"><a href="#Simple-Texture-Mapping" class="headerlink" title="Simple Texture Mapping"></a>Simple Texture Mapping</h3><ul>
<li>插值出 $(u,v)$</li>
<li>然后再在纹理中采样</li>
</ul>
<h3 id="纹理放大"><a href="#纹理放大" class="headerlink" title="纹理放大"></a>纹理放大</h3><ul>
<li>Texture Magnification</li>
</ul>
<h4 id="1-纹理太小了怎么办"><a href="#1-纹理太小了怎么办" class="headerlink" title="(1) 纹理太小了怎么办"></a>(1) 纹理太小了怎么办</h4><ul>
<li>纹理分辨率太低</li>
<li>计算出非整数值：插值（Nearest、Bilinear、Bicubic）</li>
<li>双线性插值：Bilinear<ul>
<li>使用临近的 4 个点进行双线性插值</li>
<li>两趟线性插值 lerp</li>
</ul>
</li>
<li>双三次插值：Bicubic<ul>
<li>取邻近得到 16 个点进行插值</li>
<li>两趟 cubic 插值方法</li>
<li>运算量大，但是效果更好<ul>
<li>trade off</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-纹理太大了怎么办"><a href="#2-纹理太大了怎么办" class="headerlink" title="(2) 纹理太大了怎么办"></a>(2) 纹理太大了怎么办</h4><ul>
<li>更严重的问题<ul>
<li>远处摩尔纹，近处锯齿</li>
</ul>
</li>
<li>远处占据了一块很大区域的纹理，简单的取中心点所在的坐标会出问题</li>
</ul>
<img src="02/1615614006106.png" style="zoom:50%;" />

<ul>
<li>超采样，可以解决，但是计算量很大</li>
<li>不做采样，立刻知道的话就不会有问题<ul>
<li>Mipmap</li>
</ul>
</li>
<li>经典问题：Point Query &amp; Range Query</li>
</ul>
<h4 id="MipMap"><a href="#MipMap" class="headerlink" title="MipMap"></a>MipMap</h4><ul>
<li>允许范围查询<ul>
<li><strong>正方形</strong>、近似的、快</li>
</ul>
</li>
<li>通过一张图，生成一系列分辨率的纹理图<ul>
<li>原始分辨率 64x64</li>
<li>生成的一系列的纹理分辨率：64x64, 32x32, 16x16, 8x8, 4x4, 2x2, 1x1<ul>
<li>Level 0 - 6</li>
</ul>
</li>
</ul>
</li>
<li>存储量变为原来的 $\dfrac{4}{3}$</li>
<li>怎么知道需要查询的是哪一张（层次）纹理<ul>
<li>计算出来</li>
<li>取最大值，相当于用一个正方形近似</li>
<li>$D&#x3D;\log_2L$，很巧妙<ul>
<li>和上面生成纹理分辨率对比</li>
<li>L &#x3D; 1 刚好是 Level 0（原始图像）</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="02/1615614093881.png" style="zoom:50%;" />

<ul>
<li>由于层是离散的，因此计算出来的层数是不连续的<ul>
<li>利用三线性插值（Trilinear）计算</li>
<li>例如计算出来是 1.6 层，则在第 1 层和第 2 层上分别取最近的 4 个点进行一次双线性插值，然后在层与层之间进行一次线性插值</li>
</ul>
</li>
<li>MipMap 的问题<ul>
<li>远处的细节全都被模糊掉了（和超采样相比）<ul>
<li>三线性插值的近似</li>
<li>只能查询正方形，对长条形的区域可能会产生 Overblur</li>
</ul>
</li>
<li>一个解决方法：各向异性过滤 Anisotropic Filtering</li>
</ul>
</li>
</ul>
<h4 id="各向异性过滤-Anisotropic-Filtering"><a href="#各向异性过滤-Anisotropic-Filtering" class="headerlink" title="各向异性过滤 Anisotropic Filtering"></a>各向异性过滤 Anisotropic Filtering</h4><ul>
<li>水平竖直缩小的倍数不一样，使用矩形去近似</li>
<li>部分解决问题，对于<strong>横平竖直的矩形</strong>查询相对更加准确</li>
<li>但是一些斜着的区域还是存在 Over Blur 的问题</li>
<li>存储开销变为原来的 4 倍</li>
<li>RipMap</li>
</ul>
<p><img src="/02/1615614525178.png"></p>
<ul>
<li>2x 指的是每个方向只压缩 1 次，左上角 4 张图<ul>
<li>3x：左上角 9 张图（最小的压缩了两次）</li>
<li>nx：最终收敛到 4 倍存储开销</li>
</ul>
</li>
</ul>
<h4 id="EWA-Filtering"><a href="#EWA-Filtering" class="headerlink" title="EWA Filtering"></a>EWA Filtering</h4><ul>
<li>不规则的图形利用<strong>圆形</strong>去近似</li>
<li>多次查询，覆盖这个不规则图形（耗时长）</li>
</ul>
<h2 id="纹理的应用"><a href="#纹理的应用" class="headerlink" title="纹理的应用"></a>纹理的应用</h2><ul>
<li>In modern GPUs, <strong>texture &#x3D; memory + range query</strong> (filtering)  </li>
<li>把纹理理解为一块数据，而不仅仅局限在图像上</li>
<li>Store microgeometry</li>
<li>Procedural textures</li>
<li>Solid modeling</li>
<li>Volume rendering</li>
</ul>
<h3 id="Environment-lighting"><a href="#Environment-lighting" class="headerlink" title="Environment lighting"></a>Environment lighting</h3><ul>
<li>环境光照</li>
<li>Environment Map 环境贴图</li>
<li>认为光源无限远，没有深度意义，因此可以通过方向采样（不定义位置）</li>
</ul>
<h4 id="Spherical-Environment-Map"><a href="#Spherical-Environment-Map" class="headerlink" title="Spherical Environment Map"></a>Spherical Environment Map</h4><ul>
<li>球面光贴图</li>
<li>将整个环境光记录在球面上</li>
<li>展开到长方形平面上，极点部分会有扭曲的问题</li>
</ul>
<img src="02/1615641364773.png" style="zoom:50%;" />



<h4 id="Cube-Map"><a href="#Cube-Map" class="headerlink" title="Cube Map"></a>Cube Map</h4><ul>
<li>解决扭曲问题而提出的</li>
</ul>
<img src="02/1615641448166.png" style="zoom:70%;" />

<ul>
<li>产生的问题<ul>
<li>球面采样更快，立方体需要先判断在哪一个面上</li>
</ul>
</li>
</ul>
<img src="02/1615641521532.png" style="zoom:60%;" />





<h3 id="凹凸贴图"><a href="#凹凸贴图" class="headerlink" title="凹凸贴图"></a>凹凸贴图</h3><ul>
<li>凹凸贴图（法线贴图）</li>
<li>Bump Mapping &#x2F; Normal Mapping</li>
<li>复杂的效果，粗糙效果</li>
<li>物体的几何信息没有改变，加入一个随机扰动（perturb）<ul>
<li>常数用于表示凹凸贴图的影响程度</li>
</ul>
</li>
</ul>
<img src="02/1615641786775.png" style="zoom:80%;" />



<ul>
<li>蓝色的线是凹凸贴图定义的高度，重新计算法线<ul>
<li>先算切线，再算法线</li>
</ul>
</li>
<li>3 维空间类似<ul>
<li>原来的法线 $n(p)&#x3D;(0,0,1)$</li>
<li>$\dfrac{dp}{du}&#x3D;c1\ast[h(u+1)-h(u)]$</li>
<li>$\dfrac{dp}{dv}&#x3D;c2\ast[h(\mathbf{v}+1)-h(\mathbf{v})]$</li>
<li>扰动后的法线（未归一化）$n&#x3D;(-\dfrac{dp}{du},-\dfrac{dp}{dv},1)$</li>
<li>可以通过旋转矩阵推导，或者空间想象</li>
</ul>
</li>
<li>局部坐标系：切线空间 TBN</li>
</ul>
<h3 id="位移贴图"><a href="#位移贴图" class="headerlink" title="位移贴图"></a>位移贴图</h3><ul>
<li>Displacement Map</li>
<li><strong>直接把顶点的位置移动了</strong>，而不是说简单的影响法线</li>
</ul>
<p><img src="/02/1615642434137.png"></p>
<ul>
<li>和凹凸贴图的区别<ul>
<li>边缘</li>
<li>自己的阴影在自己上面</li>
<li>影子</li>
</ul>
</li>
<li>要求三角形足够细<ul>
<li>如果三角形比较大，纹理定义的变换在三角形内部体现不出来</li>
<li>要求三角形定义的间隔比纹理间隔更下（频率更高）</li>
</ul>
</li>
<li>DirextX：动态曲面细分<ul>
<li>根据需要做细分，而不是所有的三角形都这么细致</li>
</ul>
</li>
</ul>
<h3 id="3D-Procedural-Noise-Solid-Model"><a href="#3D-Procedural-Noise-Solid-Model" class="headerlink" title="3D Procedural Noise + Solid Model"></a>3D Procedural Noise + Solid Model</h3><ul>
<li>程序纹理</li>
<li>定义三维空间的噪声函数</li>
</ul>
<h3 id="Provide-Precomputed-Shading"><a href="#Provide-Precomputed-Shading" class="headerlink" title="Provide Precomputed Shading"></a>Provide Precomputed Shading</h3><ul>
<li>记录一些已经计算好的信息</li>
<li>OpenGL 帧缓冲</li>
<li>环境光遮蔽例子</li>
</ul>
<img src="02/1615642847111.png" style="zoom:70%;" />



<h3 id="3D-Textures-and-Volume-Rendering"><a href="#3D-Textures-and-Volume-Rendering" class="headerlink" title="3D Textures and Volume Rendering"></a>3D Textures and Volume Rendering</h3><ul>
<li>体渲染</li>
<li>例如核磁共振分层扫描，返回了三维信息，把这些记录的信息当作纹理传入用于渲染</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/13/CG/YLQ-GAMES101/02/" data-id="cl9lj74a0009t64tz9cbbcd88" data-title="GAMES101.闫令琪.02.Shading(Lecture 07-09)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/YLQ-GAMES101/01" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/13/CG/YLQ-GAMES101/01/" class="article-date">
  <time class="dt-published" datetime="2021-03-13T06:31:09.000Z" itemprop="datePublished">2021-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-GAMES101/">CG.GAMES101</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/13/CG/YLQ-GAMES101/01/">GAMES101.闫令琪.01.Lecture(01-06)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av90798049">https://www.bilibili.com/video/av90798049</a></li>
</ul>
<h1 id="Lecture-01"><a href="#Lecture-01" class="headerlink" title="Lecture 01"></a>Lecture 01</h1><ul>
<li>Overview of Computer Graphics</li>
<li>计算机图形学概述</li>
</ul>
<h1 id="Lecture-02"><a href="#Lecture-02" class="headerlink" title="Lecture 02"></a>Lecture 02</h1><ul>
<li>Review of Linear Algebra</li>
<li>向量与线性代数</li>
</ul>
<h1 id="Lecture-03"><a href="#Lecture-03" class="headerlink" title="Lecture 03"></a>Lecture 03</h1><ul>
<li>Transformation</li>
<li>变换（二维与三维）</li>
</ul>
<h2 id="基本变换"><a href="#基本变换" class="headerlink" title="基本变换"></a>基本变换</h2><ul>
<li>scale、rotate、shear、reflection<ul>
<li>放缩、旋转、错切、对称</li>
</ul>
</li>
<li>translate<ul>
<li>平移</li>
</ul>
</li>
<li><strong>变换顺序</strong>很重要</li>
</ul>
<h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><ul>
<li>统一表示所有变换</li>
</ul>
<h1 id="Lecture-04"><a href="#Lecture-04" class="headerlink" title="Lecture 04"></a>Lecture 04</h1><ul>
<li>Transform Cont.</li>
<li>变换（模型、视图、投影）</li>
</ul>
<h2 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h2><ul>
<li>表示任意旋转</li>
</ul>
<p>$$<br>R_{xyz}(\alpha,\beta,\gamma)&#x3D;R_x(\alpha)R_y(\beta)R_(\gamma)<br>$$</p>
<ul>
<li>roll, pitch, yaw</li>
</ul>
<img src="01/1615626783481.png" style="zoom:80%;" />

<ul>
<li>存在万向锁问题</li>
</ul>
<h2 id="绕任意轴的旋转"><a href="#绕任意轴的旋转" class="headerlink" title="绕任意轴的旋转"></a>绕任意轴的旋转</h2><ul>
<li>Rodrigues’ Rotation Formula</li>
<li><a href="/2021/01/31/CG/LS/05-2/">推导</a></li>
<li>绕过原点的单位轴 $\mathbf{n}$ 逆时针旋转 $\alpha$ 角度</li>
</ul>
<p>$$<br>\mathbf{R}(\mathbf{n}, \alpha)&#x3D;\cos (\alpha) \mathbf{I}+(1-\cos (\alpha)) \mathbf{n} \mathbf{n}^{T}+\sin (\alpha)\left(\begin{array}{ccc} 0 &amp; -n_{z} &amp; n_{y} \ n_{z} &amp; 0 &amp; -n_{x} \ -n_{y} &amp; n_{x} &amp; 0 \end{array}\right)<br>$$</p>
<h2 id="MVP-变换"><a href="#MVP-变换" class="headerlink" title="MVP 变换"></a>MVP 变换</h2><ul>
<li>model、view、projection</li>
</ul>
<h3 id="camera-相机"><a href="#camera-相机" class="headerlink" title="camera 相机"></a>camera 相机</h3><ul>
<li>Position<ul>
<li>$\vec{e}$</li>
</ul>
</li>
<li>Look-at &#x2F; gaze direction<ul>
<li>$\vec{g}$</li>
</ul>
</li>
<li>Up direction<ul>
<li>$\vec{t}$</li>
</ul>
</li>
</ul>
<img src="01/1615627477778.png" style="zoom:50%;" />

<ul>
<li>通常变换的结果<ul>
<li>Position<ul>
<li>原点</li>
</ul>
</li>
<li>Look-at &#x2F; gaze direction<ul>
<li>$-z$</li>
</ul>
</li>
<li>Up direction<ul>
<li>$y$</li>
</ul>
</li>
</ul>
</li>
<li>变换的过程<ul>
<li>位置移动到原点<ul>
<li>$-\mathbf{Position_{camera}}$</li>
</ul>
</li>
<li>旋转（正交变换）<ul>
<li><a href="/2021/01/29/CG/LS/05/">推导</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h3><ul>
<li>Perspective projection 透视投影</li>
<li>Orthographic projection 正交投影</li>
</ul>
<img src="01/1615628267875.png" style="zoom: 70%;" />

<ul>
<li>透视变换：变换到 $[-1,+1]^3$<ul>
<li>Frustum 转变为 Cuboid（<strong>近裁剪面一样大</strong>）</li>
<li>平移、放缩</li>
</ul>
</li>
</ul>
<p>$$<br>M_{persp} &#x3D; M_{ortho}M_{persp\to ortho} &#x3D; M_{scale}M_{translate}M_{persp\to ortho}<br>$$</p>
<p>$$<br>M_{persp\to ortho}&#x3D;<br>\begin{bmatrix}<br>n &amp; 0 &amp; 0 &amp; 0\<br>0 &amp; n &amp; 0 &amp; 0\<br>0 &amp; 0 &amp; n+f &amp; -nf\<br>0 &amp; 0 &amp; 1 &amp; 0\<br>\end{bmatrix}<br>$$</p>
<p>$$<br>M_{scale}&#x3D;<br>\begin{bmatrix}<br>\dfrac{2}{r-l} &amp; 0 &amp; 0 &amp; 0\<br>0 &amp; \dfrac{2}{t-b} &amp; 0 &amp; 0\<br>0 &amp; 0 &amp; \dfrac{2}{n-f} &amp; 0\<br>0 &amp; 0 &amp; 0 &amp; 1\<br>\end{bmatrix}<br>$$</p>
<p>$$<br>M_{translate}<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; -\dfrac{r+l}{2}\<br>0 &amp; 1 &amp; 0 &amp; -\dfrac{t+b}{2}\<br>0 &amp; 0 &amp; 1 &amp; -\dfrac{n+f}{2}\<br>0 &amp; 0 &amp; 0 &amp; 1\<br>\end{bmatrix}<br>$$</p>
<p>$$<br>M_{ortho}&#x3D;<br>\begin{bmatrix}<br>\dfrac{2}{r-l} &amp; 0 &amp; 0 &amp; -\dfrac{r+l}{r-l}\<br>0 &amp; \dfrac{2}{t-b} &amp; 0 &amp; -\dfrac{t+b}{t-b}\<br>0 &amp; 0 &amp; \dfrac{2}{n-f} &amp; -\dfrac{n+f}{n-f}\<br>0 &amp; 0 &amp; 0 &amp; 1\<br>\end{bmatrix}<br>$$</p>
<ul>
<li>OpenGL 中 z 方向乘了个 $-1$<ul>
<li><a href="/2021/01/31/CG/LS/05-1/">OpenGL 中的推导</a></li>
</ul>
</li>
</ul>
<h3 id="计算出参数"><a href="#计算出参数" class="headerlink" title="计算出参数"></a>计算出参数</h3><img src="01/1615630292201.png" style="zoom:50%;" />

<ul>
<li><span style="color:red">Vertical</span> <strong>Field-of-View</strong> (fov<span style="color:red">Y</span>)<ul>
<li>一个角度值</li>
</ul>
</li>
<li>Aspect ratio<ul>
<li>width &#x2F; height</li>
</ul>
</li>
<li>通过 $n,f,fovY,aspect$ 计算出 $l,r,b,t$<ul>
<li>$t&#x3D;|n|\times\tan\dfrac{fovY}{2}$</li>
<li>$r&#x3D;t\times aspect$</li>
</ul>
</li>
</ul>
<h1 id="Lecture-05"><a href="#Lecture-05" class="headerlink" title="Lecture 05"></a>Lecture 05</h1><ul>
<li>Rasterization 1 (Triangles)</li>
<li>光栅化（三角形的离散化）</li>
</ul>
<h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><ul>
<li>直接采样<ul>
<li>实际上采样点的坐标应该是 $(x+0.5,y+0.5)$<img src="01/1615637516517.png" style="zoom:50%;" /></li>
<li>中心在三角形内，就设置为三角形的颜色<ul>
<li>边缘出现走样的问题</li>
</ul>
</li>
</ul>
</li>
<li>怎么判断在三角形内部：<strong>叉乘</strong></li>
<li>点 P 在三角形 ABC 内部，以下三个结果同号</li>
</ul>
<p>$$<br>\vec{AP}\times\vec{AB},\vec{BP}\times\vec{BC},\vec{CP}\times\vec{CA}<br>$$</p>
<ul>
<li>点同时在 3 个向量 $\vec{AB},\vec{BC},\vec{CA}$ 的左边 &#x2F; 右边</li>
</ul>
<h2 id="光栅化加速优化"><a href="#光栅化加速优化" class="headerlink" title="光栅化加速优化"></a>光栅化加速优化</h2><ul>
<li>基于三角形覆盖的区域较小</li>
</ul>
<h3 id="包围盒技术"><a href="#包围盒技术" class="headerlink" title="包围盒技术"></a>包围盒技术</h3><ul>
<li>不需要对所有的点进行判断，只需要对包围盒内的点进行判断</li>
<li>AABB 包围盒<ul>
<li>Axis-Aligned Bounding Box</li>
<li>横平竖直</li>
</ul>
</li>
</ul>
<img src="01/1615638505359.png" style="zoom:50%;" />

<ul>
<li>AABB 包围盒技术失效<ul>
<li>包围盒大，但是三角形小</li>
<li>三角形斜着放</li>
</ul>
</li>
<li>如下方法可以解决 AABB 失效的问题<ul>
<li>适合瘦小、斜置的三角形</li>
</ul>
</li>
</ul>
<img src="01/1615638748203.png" style="zoom:50%;" />



<h2 id="光栅化显示技术"><a href="#光栅化显示技术" class="headerlink" title="光栅化显示技术"></a>光栅化显示技术</h2><ul>
<li>隔行扫描<ul>
<li>每帧只渲染一半</li>
<li>快、看不出来</li>
</ul>
</li>
<li>像素<ul>
<li>我们认为是不可分的</li>
<li>实际上在显示设备上可能是由更小的像素（条&#x2F;点）组成的</li>
</ul>
</li>
</ul>
<img src="01/1615638916808.png" style="zoom:50%;" />

<ul>
<li>bayer pattern（iPhone 6S）<ul>
<li>像素内分布方式</li>
</ul>
</li>
<li>像素内<strong>绿色多</strong>，密度大，红蓝差不多<ul>
<li>人眼对绿色敏感</li>
</ul>
</li>
<li>屏幕：加色系统（初始黑，全加白）</li>
<li>打印机：减色系统（初始白，全加黑）</li>
</ul>
<h1 id="Lecture-06"><a href="#Lecture-06" class="headerlink" title="Lecture 06"></a>Lecture 06</h1><ul>
<li>Rasterization 2 (Antialiasing and Z-Buffering)</li>
<li>光栅化（深度测试与抗锯齿）</li>
</ul>
<h2 id="采样问题"><a href="#采样问题" class="headerlink" title="采样问题"></a>采样问题</h2><ul>
<li>Sampling <strong>Artifacts</strong> in Computer Graphics<ul>
<li>看上去不太对的东西，瑕疵</li>
<li>Errors &#x2F; Mistakes &#x2F; Inaccuracies</li>
</ul>
</li>
<li>锯齿 Jaggies</li>
<li>摩尔纹 Moire<ul>
<li>奇数行、奇数列去掉，变成小的图，但是显示仍然是和原来一样大</li>
<li>手机拍显示器的屏幕产生的摩尔纹</li>
</ul>
</li>
<li>Wagon Wheel Illusion (False Motion)<ul>
<li>高速行驶的汽车倒转</li>
<li>人眼在时间中的采样跟不上运动速度</li>
</ul>
</li>
</ul>
<h3 id="信号与系统的观点"><a href="#信号与系统的观点" class="headerlink" title="信号与系统的观点"></a>信号与系统的观点</h3><ul>
<li>原始图像的频率过高，采样频率跟不上，导致原始的图像不能恢复</li>
<li>采样定理<ul>
<li>当采样频率大于信号中最高频率的2倍时，采样之后的数字信号完整地保留了原始信号中的信息</li>
<li>采样过慢，频域上有混叠</li>
</ul>
</li>
<li>反走样的方法<ul>
<li>提高采样频率</li>
<li>降低原始图像的频率<ul>
<li><strong>采样之前先做模糊化</strong></li>
</ul>
</li>
</ul>
</li>
<li>反走样方法：<strong>采样之前先做模糊化</strong><ul>
<li>先模糊，后采样 OK</li>
<li>先采样，后模糊 NO</li>
</ul>
</li>
<li>模糊<ul>
<li>频域相乘 $\Leftrightarrow$ 时域卷积</li>
</ul>
</li>
<li>傅里叶变换到频域上可视化<ul>
<li>中间水平竖直线，信号强</li>
<li>原因是我们分析图片的时候，会将其看成是重复的（一张一张放一起），边界部分极其高频</li>
</ul>
</li>
</ul>
<img src="01/1615639807145.png" style="zoom:50%;" />



<h2 id="Anti-Aliasing"><a href="#Anti-Aliasing" class="headerlink" title="Anti Aliasing"></a>Anti Aliasing</h2><ul>
<li>MSAA 增大了计算量<ul>
<li>使用更多的点去判断是否在三角形内</li>
<li>最后通过在三角形内部的采样点的比例计算出近似的覆盖率</li>
</ul>
</li>
<li>MSAA 解决的是对信号的模糊操作，得到<strong>近似的覆盖率</strong>（<strong>不是增加分辨率</strong>）<ul>
<li>有点的复用</li>
<li>例如打开 2x2 的 MSAA 之后，帧率不会变为原来的 $\dfrac{1}{4}$</li>
</ul>
</li>
<li>工业界近似采样率的得到，不同的 pattern，<strong>点的复用</strong>，提高效率<ul>
<li>MSAA 是 2x2 的正方形 pattern</li>
</ul>
</li>
<li>FXAA<ul>
<li>Fast Approximate AA</li>
<li>先得到有锯齿的图片，然后做后期处理去除锯齿（图像匹配等方法）</li>
<li>和采样无关，是在图形层面上的抗锯齿</li>
</ul>
</li>
<li>TAA<ul>
<li>Temporal AA</li>
<li>时间，复用上一帧的感知，把 MSAA 的采样点分布到不同帧</li>
</ul>
</li>
<li>Super resolution &#x2F; super sampling 超分辨率<ul>
<li>From low resolution to high resolution</li>
<li>Essentially still “not enough samples” problem</li>
<li>DLSS (Deep Learning Super Sampling)</li>
</ul>
</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><ul>
<li>画家算法：先排序，再绘制</li>
<li>问题：互相遮挡</li>
</ul>
<img src="01/1615640549993.png" style="zoom: 67%;" />

<h2 id="Z-Buffer"><a href="#Z-Buffer" class="headerlink" title="Z-Buffer"></a>Z-Buffer</h2><ul>
<li><p>Depth Buffer</p>
</li>
<li><p>深度缓存</p>
</li>
<li><p>复杂度：$O(n)$</p>
<ul>
<li>指绘制 n 个三角形，每个三角形只覆盖常数个像素</li>
</ul>
</li>
<li><p>如果配合 MSAA，则应该是每个采样点对应一个深度，而不是每个像素</p>
</li>
</ul>
<h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><h3 id="Shadow-Mapping-算法"><a href="#Shadow-Mapping-算法" class="headerlink" title="Shadow Mapping 算法"></a>Shadow Mapping 算法</h3><ul>
<li><p>光栅化比较难处理<strong>全局现象</strong></p>
</li>
<li><p>图像空间的做法</p>
</li>
<li><p>有走样现象</p>
</li>
<li><p>思想：<strong>如果点不在阴影里，光源可以看到这个点</strong></p>
</li>
<li><p>经典的 shadow mapping 算法只能处理 <strong>点光源&#x2F;平行光</strong> 的阴影</p>
<ul>
<li><strong>硬阴影</strong></li>
<li>非 0 即 1 的问题</li>
</ul>
</li>
<li><p>算法</p>
<ul>
<li>变换到以光源为视点的观察坐标系中，记录深度图</li>
<li>正常渲染到以视点为观察坐标系中，将你看到的点转换到上一步的坐标系中，利用深度值怕段是否在阴影中（能否被光源看到）</li>
</ul>
</li>
<li><p>一些问题</p>
<ul>
<li>浮点数判断相等困难，因此会出现黑白条纹的问题<ul>
<li>shadow map 分辨率问题<ul>
<li>一般游戏中选择阴影质量，就是修改分辨率</li>
</ul>
</li>
<li>记录值的精度问题</li>
</ul>
</li>
<li>加入一个 bias</li>
<li>需要渲染场景两遍</li>
</ul>
</li>
<li><p>软阴影与硬阴影</p>
</li>
</ul>
<img src="01/1615962188769.png" style="zoom:50%;" />

<ul>
<li>物理上的本影与半影</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/13/CG/YLQ-GAMES101/01/" data-id="cl9lj749z009n64tzgb0c5ni6" data-title="GAMES101.闫令琪.01.Lecture(01-06)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/YLQ-GAMES101/00" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/13/CG/YLQ-GAMES101/00/" class="article-date">
  <time class="dt-published" datetime="2021-03-13T06:01:42.000Z" itemprop="datePublished">2021-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/0/">0</a>►<a class="article-category-link" href="/categories/CG/">CG</a>►<a class="article-category-link" href="/categories/CG-GAMES101/">CG.GAMES101</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/13/CG/YLQ-GAMES101/00/">GAMES101.闫令琪.00.课程介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h1><ul>
<li>GAMES101：现代计算机图形学入门</li>
<li><a target="_blank" rel="noopener" href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">课程主页</a></li>
<li>授课老师：闫令琪</li>
<li>视频地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av90798049">B站</a></li>
<li><a target="_blank" rel="noopener" href="https://www.notion.so/GAMES101-WSL-ea56a93aa3614e0aba911e21193baa8d">WSL 配置</a></li>
<li>内容<ul>
<li>Rasterization （光栅化）</li>
<li>Geometry（几何）</li>
<li>Ray Tracing （光线追踪）</li>
<li>Animation &#x2F; Simulation（动画与模拟）</li>
</ul>
</li>
</ul>
<h1 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h1><h2 id="GAMES"><a href="#GAMES" class="headerlink" title="GAMES"></a>GAMES</h2><ul>
<li>图形学在线交流平台</li>
<li>GAMES: Graphics And Mixed Environment Symposium</li>
<li><a target="_blank" rel="noopener" href="http://games-cn.org/">网站</a></li>
<li>线上活动：<ul>
<li>每周四晚8:00-9:30《在线报告》</li>
<li>2020年2月开始推出《在线课程》</li>
<li>所有活动的视频及PPT都可在线学习和下载</li>
</ul>
</li>
</ul>
<h2 id="Chinagraph"><a href="#Chinagraph" class="headerlink" title="Chinagraph"></a>Chinagraph</h2><ul>
<li>学术会议：Chinagraph 2020（第十三届中国计算机图形学大会）</li>
<li><a target="_blank" rel="noopener" href="https://chinagraph2020.xmu.edu.cn/">主页</a></li>
</ul>
<h2 id="ChinaVR"><a href="#ChinaVR" class="headerlink" title="ChinaVR"></a>ChinaVR</h2><ul>
<li>学术会议：ChinaVR 2020（第二十届中国虚拟现实大会）</li>
<li>主页：<a target="_blank" rel="noopener" href="https://www.chinavr.info/">https://www.chinavr.info</a></li>
</ul>
<h2 id="其他的渲染课程"><a href="#其他的渲染课程" class="headerlink" title="其他的渲染课程"></a>其他的渲染课程</h2><ul>
<li>GAMES202（实时渲染）<ul>
<li><a target="_blank" rel="noopener" href="https://sites.cs.ucsb.edu/~lingqi/teaching/games202.html">课程主页</a></li>
</ul>
</li>
<li>离线渲染<ul>
<li>Advanced Image Synthesis（高级图像合成）</li>
</ul>
</li>
</ul>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><img src="00/image-20210402143533594.png" style="zoom:80%;" />


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/13/CG/YLQ-GAMES101/00/" data-id="cl9lj74a0009r64tz79bc7syz" data-title="GAMES101.闫令琪.00.课程介绍" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CV/HDR/Paper23" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/04/CV/HDR/Paper23/" class="article-date">
  <time class="dt-published" datetime="2021-03-04T09:12:50.000Z" itemprop="datePublished">2021-03-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CV/">CV</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/04/CV/HDR/Paper23/">高动态范围成像</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="HDR-高动态范围成像"><a href="#HDR-高动态范围成像" class="headerlink" title="HDR 高动态范围成像"></a>HDR 高动态范围成像</h1><ul>
<li>代码路径<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/banbao990/CV/tree/main/HDR">https://github.com/banbao990/CV/tree/main/HDR</a></li>
</ul>
</li>
</ul>
<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><p>HDR 高动态范围成像的主要内容有 3 个部分，具体的内容以及参考文献如下</p>
<ul>
<li>论文 1：利用多张不同曝光时间的图片重建 HDR 图片<ul>
<li>Recovering High Dynamic Range Radiance Maps from Photographs</li>
</ul>
</li>
<li>论文 2：利用单张 LDR 图片和 intensity map 图片重建 HDR 图片<ul>
<li>Neuromorphic Camera Guided High Dynamic Range Imaging</li>
</ul>
</li>
<li>论文 3：对单张 LDR 图片，利用 deep-CNNs 重建 HDR 图片<ul>
<li>HDR image reconstruction from a single exposure using deep CNNs</li>
</ul>
</li>
</ul>
<p>接下来的内容就围绕着这 3 篇论文展开</p>
<h2 id="二-正文"><a href="#二-正文" class="headerlink" title="二. 正文"></a>二. 正文</h2><h3 id="论文-1：利用多张不同曝光时间的图片重建-HDR-图片"><a href="#论文-1：利用多张不同曝光时间的图片重建-HDR-图片" class="headerlink" title="论文 1：利用多张不同曝光时间的图片重建 HDR 图片"></a>论文 1：利用多张不同曝光时间的图片重建 HDR 图片</h3><blockquote>
<p> Recovering High Dynamic Range Radiance Maps from Photographs</p>
</blockquote>
<h3 id="论文-2：利用单张-LDR-图片和-intensity-map-图片重建-HDR-图片"><a href="#论文-2：利用单张-LDR-图片和-intensity-map-图片重建-HDR-图片" class="headerlink" title="论文 2：利用单张 LDR 图片和 intensity map 图片重建 HDR 图片"></a>论文 2：利用单张 LDR 图片和 intensity map 图片重建 HDR 图片</h3><blockquote>
<p> Neuromorphic Camera Guided High Dynamic Range Imaging</p>
</blockquote>
<h4 id="2-1-主要目的"><a href="#2-1-主要目的" class="headerlink" title="2.1 主要目的"></a>2.1 主要目的</h4><ul>
<li>利用单张 LDR 图片和 intensity map 图片重建 HDR 图片</li>
<li>由于一张 RGB  的LDR 的图片在高曝光和低曝光区域都存在一些细节缺失，而 intensity map 中保留了所有区域的深度信息，因此可以在某种意义上使用这两张图片恢复出一张 HDR 的图片，该论文的第一部分就介绍了这样的一种方法</li>
</ul>
<h4 id="2-2-主要方法"><a href="#2-2-主要方法" class="headerlink" title="2.2 主要方法"></a>2.2 主要方法</h4><p><img src="/Paper23/J_001.png"></p>
<ul>
<li>以上是流程图，具体的步骤如下<ul>
<li>首先我们利用相机响应函数将 LDR 的图片从非线性转化到线性空间得到图片pic1</li>
<li>将 pic1 从 RGB 空间转换到 YUV 空间中得到 pic2，此时 Y 平面中包含了图象的深度信息</li>
<li>将 intensity map 过采样到和 LDR 图片大小相同得到 pic3</li>
<li>将 pic3 和 pic2 的 Y 平面进行融合得到 pic4</li>
<li>将 pic4 作为 pic2 的 Y 平面，将其转化为 RGB 空间</li>
<li>最后通过 tone mapping 将图片转化为观感较好的 RGB 图片</li>
</ul>
</li>
</ul>
<h4 id="2-3-具体的实现与效果展示"><a href="#2-3-具体的实现与效果展示" class="headerlink" title="2.3 具体的实现与效果展示"></a>2.3 具体的实现与效果展示</h4><ul>
<li>使用 opencv 的 python 版本实现</li>
<li>具体使用到的库以及 python 的版本信息如下</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python: 3.7.9 [MSC v.1916 64 bit (AMD64)]</span><br><span class="line">matplotlib: 3.3.2</span><br><span class="line">numpy: 1.19.1</span><br><span class="line">cv2: 4.4.0</span><br></pre></td></tr></table></figure>

<ul>
<li><p>每一步的实现如下，具体细节见代码</p>
</li>
<li><p>以下以示例图片作为简单的效果展示</p>
</li>
<li><p>示例图片</p>
<ul>
<li><p>ldr 图片</p>
  <img src="Paper23/J_ex_ldr.jpg" alt="img" style="zoom:50%;" />
</li>
<li><p>intensity map</p>
<p>  <img src="/Paper23/J_ex_intensity_map.jpg"></p>
</li>
<li><p>ground truth</p>
  <img src="Paper23/J_ex_ground_truth.jpg" alt="img" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<h5 id="1-逆色调映射"><a href="#1-逆色调映射" class="headerlink" title="(1) 逆色调映射"></a>(1) 逆色调映射</h5><ul>
<li>因为我们不知道相机的响应函数以及图片的曝光时间，因此使用简单的 gamma2.2 校正<ul>
<li>$y&#x3D;x^\frac{1}{\gamma},gamma&#x3D;2.2$</li>
</ul>
</li>
<li>效果图如下</li>
</ul>
<img src="pic\J_ex_ldr_linear.jpg" alt="img" style="zoom:50%"/>

<h5 id="2-RGB-空间转换为-YUV-空间"><a href="#2-RGB-空间转换为-YUV-空间" class="headerlink" title="(2) RGB 空间转换为 YUV 空间"></a>(2) RGB 空间转换为 YUV 空间</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># opencv 自带的函数</span></span><br><span class="line">cv2.cvtColor(ldr_linear, cv2.COLOR_BGR2YUV)</span><br></pre></td></tr></table></figure>

<ul>
<li>展示 YUV 空间的图片</li>
</ul>
<p><img src="/Paper23/J_ex_ldr_yuv.png"></p>
<ul>
<li>我们看到这里的 Y 平面中确实含有一定的深度信息</li>
</ul>
<h5 id="3-intensity-map-的大小转换"><a href="#3-intensity-map-的大小转换" class="headerlink" title="(3) intensity map 的大小转换"></a>(3) intensity map 的大小转换</h5><ul>
<li>使用论文中给的使用 INTER_CUBIC 三次样条插值</li>
</ul>
<h5 id="4-深度融合"><a href="#4-深度融合" class="headerlink" title="(4) 深度融合"></a>(4) 深度融合</h5><ul>
<li><p>尝试了两种融合方法</p>
<ul>
<li>论文中给的是 $w_{ij}∗Y_{ij}+(1-w_i)∗I_{ij}$<ul>
<li>其中</li>
</ul>
</li>
</ul>
<p>  $$<br>  w_{ij}&#x3D;\frac{(0.5-max(|I_{ij}-0.5|,τ-0.5))}{(1-τ)}<br>  $$</p>
  <img src="Paper23/J_weight_funciton.png" alt="1610207884863" style="zoom: 40%;" />

<ul>
<li>$w_{ij}∗Y_{ij}+I_{ij}$</li>
</ul>
</li>
<li><p>展示效果图如下</p>
</li>
</ul>
<p><img src="/Paper23/J_ex_fusion.png"></p>
<h5 id="5-最后的色调映射"><a href="#5-最后的色调映射" class="headerlink" title="(5) 最后的色调映射"></a>(5) 最后的色调映射</h5><ul>
<li><p>简单的使用 gamma2.2 校正</p>
</li>
<li><p>效果展示</p>
<ul>
<li>使用论文函数 (w)</li>
</ul>
  <img src="Paper23/J_ex_result.1.jpg" alt="img" style="zoom:80%;" />

<ul>
<li>使用函数 (1-w)</li>
</ul>
  <img src="Paper23/J_ex_result.1.minus.w.jpg" alt="img" style="zoom:80%;" />
</li>
<li><p>图上我们可以看到亮处的深度信息已经被恢复出来，但是颜色信息缺失了</p>
</li>
<li><p>上下对比，我们发现使用函数 w 的图片更加亮一些，但是出现了一些模糊的现象（例如水管部分）</p>
<ul>
<li>更亮是因为使用 w 得到的值更大</li>
<li>模糊是因为 ldr 图片和 intensity map 的对齐问题，对齐问题在两张图的深度都占一定比例时体现的最完全，也就是亮度中等的时候</li>
</ul>
</li>
<li><p>颜色信息缺失是没有办法的，因为我们没有处理原图的 U&#x2F;V 两个平面的颜色信息，而只是补充上了深度信息</p>
</li>
<li><p>而论文中最后使用神经网络生成的图像从 U&#x2F;V 两个平面学到了色彩信息，因此填充上了色彩</p>
</li>
<li><p>还有存在的问题是过渡效果比较差，因为 intensity map 中整体偏暗，导致结果图中本应该是亮色的部分反而偏暗，因此过渡比较难看</p>
</li>
</ul>
<h4 id="2-4-一些改进与颜色校正的尝试"><a href="#2-4-一些改进与颜色校正的尝试" class="headerlink" title="2.4 一些改进与颜色校正的尝试"></a>2.4 一些改进与颜色校正的尝试</h4><ul>
<li>在上课做完报告之后，我们发现在 intensity map 之中确实整体偏暗，导致合成的结果亮色部分偏暗，以下是我们的一些修改策略</li>
<li>以下以示例图片为例，展示如下</li>
</ul>
<h5 id="1-直方图均衡化-调库-256采样"><a href="#1-直方图均衡化-调库-256采样" class="headerlink" title="(1) 直方图均衡化 (调库+256采样)"></a>(1) 直方图均衡化 (调库+256采样)</h5><ul>
<li><p>原始的直方图</p>
  <img src="Paper23/J_ex_hist_origin.jpg" alt="img" style="zoom:40%;" />
</li>
<li><p>直接调用内置的函数实现，但是内置的函数只能实现 256 精度的采样</p>
</li>
</ul>
<img src="Paper23/J_ex_result.1.minus.w.equalize_hist(256).jpg" alt="img" style="zoom: 80%;" />

<ul>
<li><p>效果如上图所示，我们发现亮色部分的提升很明显，但是暗色部分的噪声也很明显</p>
<ul>
<li><p>这一方面是时直方图均衡化采样精度低导致的问题</p>
<ul>
<li>采样精度低会导致结果并不是很均衡，丧失高动态范围</li>
</ul>
</li>
<li><p>另一方面是原生的问题 intensity map 本来分辨率就低导致的</p>
</li>
<li><p>均衡化的直方图如下</p>
  <img src="Paper23/J_ex_hist_256.jpg" alt="img" style="zoom:40%;" /></li>
</ul>
</li>
</ul>
<h5 id="2-直方图均衡化-高采样"><a href="#2-直方图均衡化-高采样" class="headerlink" title="(2) 直方图均衡化 (高采样)"></a>(2) 直方图均衡化 (高采样)</h5><ul>
<li><p>自己写的一个高精度的直方图均衡化</p>
</li>
<li><p>采样精度为 10000，直方图如下</p>
<ul>
<li>基本上实现了均衡化</li>
</ul>
  <img src="Paper23/J_ex_hist_10000.jpg" alt="img" style="zoom:40%;" />
</li>
<li><p>但是最终合成效果还是不太好，噪声很严重（似乎更严重了，噪声的采样也更细致了）</p>
  <img src="Paper23/J_ex_result.1.minus.w.equalize_hist(10000).jpg" alt="img" style="zoom: 80%;" /></li>
</ul>
<h5 id="3-调整权重函数"><a href="#3-调整权重函数" class="headerlink" title="(3) 调整权重函数"></a>(3) 调整权重函数</h5><ul>
<li><p>手动设置范围将暗部噪声减弱</p>
</li>
<li><p>一个简单的操作就是直接将暗处的 intensity map 舍去，将权重函数修改为如下<br>  $$<br>  w_{ij}&#x3D;\frac{(0.5-max(I_{ij}-0.5,τ-0.5))}{(1-τ)}<br>  $$</p>
  <img src="Paper23/J_weight_funciton.only.bright.png" alt="1610207884863" style="zoom: 40%;" />
</li>
<li><p>虽然说这样就舍弃了暗部的高动态范围，但是这和噪声相比不算什么</p>
</li>
<li><p>效果如下</p>
  <img src="Paper23/J_ex_result.1.minus.w.equalize_hist(10000).only.bright.jpg" alt="img" style="zoom:80%;" />
</li>
<li><p>感觉还是很棒的，过度效果也挺好的</p>
</li>
</ul>
<h4 id="2-5-其他图片的效果图"><a href="#2-5-其他图片的效果图" class="headerlink" title="2.5 其他图片的效果图"></a>2.5 其他图片的效果图</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO</span></span><br></pre></td></tr></table></figure>


<h5 id="1-图片1的结果"><a href="#1-图片1的结果" class="headerlink" title="(1) 图片1的结果"></a>(1) 图片1的结果</h5><ul>
<li>效果很好，过渡比原来直接做的效果好太多了</li>
<li>不使用 intensity map 的暗部也使得噪声控制很好</li>
</ul>
<p><img src="/Paper23/J_1_all.png"></p>
<h5 id="2-图片2的结果"><a href="#2-图片2的结果" class="headerlink" title="(2) 图片2的结果"></a>(2) 图片2的结果</h5><ul>
<li>效果一般，但是色调比较正常</li>
<li>过渡也比较好，但是跟 ldr 图片相比，最终的动态范围提升不大<ul>
<li>这张图片的主要提升点应该在暗部，但是我们现在的解决方案对暗部提升没有作用</li>
</ul>
</li>
</ul>
<p><img src="/Paper23/J_2_all.png"></p>
<ul>
<li><p>尝试了一个其他的方法</p>
<ul>
<li><p>对整体进行一个校正，暗处加强，亮处减弱<br>  $$<br>  s&#x3D;T(r)&#x3D;\frac{(2x-1)^{\alpha}+1}{2}<br>  $$</p>
</li>
<li><img src="Paper23/J_adjusted.jpg" alt="img" style="zoom:33%;" />
</li>
<li><p>使用 1-w，仅保留 intensity map 中的亮部</p>
</li>
<li><p>效果如下</p>
<ul>
<li>相较于之前而言，整体配色接近原始图片，而且在亮处的过度也稍微好一些，此时暗处提确实提高了亮度</li>
</ul>
  <img src="Paper23/J_2_result.1.minus.w.adjusted.only.bright.jpg" alt="img" style="zoom: 80%;" /></li>
</ul>
</li>
</ul>
<h3 id="论文-3：对单张-LDR-图片，利用-deep-CNNs-重建-HDR-图片"><a href="#论文-3：对单张-LDR-图片，利用-deep-CNNs-重建-HDR-图片" class="headerlink" title="论文 3：对单张 LDR 图片，利用 deep-CNNs 重建 HDR 图片"></a>论文 3：对单张 LDR 图片，利用 deep-CNNs 重建 HDR 图片</h3><blockquote>
<p>HDR image reconstruction from a single exposure using deep CNNs</p>
</blockquote>
<h4 id="3-1-环境配置"><a href="#3-1-环境配置" class="headerlink" title="3.1 环境配置"></a>3.1 环境配置</h4><ul>
<li>实验环境 Google Colab</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tensorflow-gpu==1.12.0</span><br><span class="line">tensorlayer==1.11.0</span><br><span class="line">OpenEXR-1.3.2</span><br></pre></td></tr></table></figure>

<ul>
<li>遇到一些问题<ul>
<li>本地配置可能需要比较大的显存<ul>
<li>至少大于 2G</li>
</ul>
</li>
<li>对于比较大的图片上的输入，可能也跑不动</li>
</ul>
</li>
</ul>
<h4 id="3-2-方法简述"><a href="#3-2-方法简述" class="headerlink" title="3.2 方法简述"></a>3.2 方法简述</h4><ul>
<li><p>构造一个神经网络如下，训练从一张图片生成 HDR 的能力</p>
<p>  <img src="/Paper23/J_network.png"></p>
</li>
<li><p>设计亮点</p>
<ul>
<li>skip-connection<ul>
<li>保留高维细节</li>
</ul>
</li>
<li>HDR-decoder 对比<ul>
<li>log 域</li>
<li>范围大</li>
</ul>
</li>
<li>损失函数<ul>
<li>直接差异R + 正则项 I</li>
<li>颜色，细节 + 全局亮度</li>
<li>I &#x3D;&gt; 只能处理高曝光的补全</li>
<li>只能够补全高曝光面积较小的区域</li>
</ul>
</li>
</ul>
</li>
<li><p>本质上神经网络是学习到了加强高曝光区域的细节</p>
<ul>
<li>如果输入的图片在高曝光区域没有任何细节，那么是无法恢复的</li>
</ul>
</li>
</ul>
<h4 id="3-3-效果展示"><a href="#3-3-效果展示" class="headerlink" title="3.3 效果展示"></a>3.3 效果展示</h4><h5 id="1-示例图片"><a href="#1-示例图片" class="headerlink" title="(1) 示例图片"></a>(1) 示例图片</h5><p><img src="/Paper23/J_3_001.png"></p>
<ul>
<li>效果很好，甚至文字细节都展示出来了</li>
</ul>
<h5 id="2-论文-1-的图片"><a href="#2-论文-1-的图片" class="headerlink" title="(2) 论文 1 的图片"></a>(2) 论文 1 的图片</h5><p><img src="/Paper23/J_3_002.png"></p>
<ul>
<li>效果超级好</li>
<li>灯顶、窗户细节</li>
</ul>
<h5 id="2-论文-2-的图片"><a href="#2-论文-2-的图片" class="headerlink" title="(2) 论文 2 的图片"></a>(2) 论文 2 的图片</h5><p><img src="/Paper23/J_3_003.png"></p>
<ul>
<li>首先恢复了一些颜色信息，这是论文 2 的简单方法做不到的，这个很强<ul>
<li>红色区域</li>
</ul>
</li>
<li>出现了一些问题，树枝周围存在一些阴影<ul>
<li>绿色区域</li>
<li>神经网络本质上是加强了高曝光区域的细节，这里细节信息比较少，因此将树枝周围的小的高曝光区域使用树枝的成分进行了补全，导致在结果上产生了阴影</li>
</ul>
</li>
</ul>
<p><img src="/Paper23/J_3_004.png"></p>
<ul>
<li>对于低曝光区域，神经网络无法给出结果</li>
</ul>
<h5 id="3-自己拍的照片"><a href="#3-自己拍的照片" class="headerlink" title="(3) 自己拍的照片"></a>(3) 自己拍的照片</h5><ul>
<li><p>灯光</p>
<ul>
<li>能够很好的将灯光细节恢复过来</li>
</ul>
<p>  <img src="/Paper23/J_3_005.png"></p>
</li>
<li><p>安全入口标志</p>
<ul>
<li>也能除去一些发光的亮晕</li>
<li>对于上面的灯，也有一定的缩小光电的作用</li>
</ul>
<p>  <img src="/Paper23/J_3_006.png"></p>
</li>
<li><p>中文字</p>
<ul>
<li>恢复没有英文字那么明显，可能是中文字符的连接比较复杂，没有英文字符那么容易修复</li>
</ul>
<p>  <img src="/Paper23/J_3_007.png"></p>
</li>
</ul>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><h3 id="1-方法对比"><a href="#1-方法对比" class="headerlink" title="(1) 方法对比"></a>(1) 方法对比</h3><ul>
<li>论文 1：利用多张不同曝光时间的图片重建 HDR 图片<ul>
<li>优点<ul>
<li>理论基础好，图片较多时恢复效果好</li>
<li>能够把高曝光和低曝光区域的高动态范围都做的很好</li>
</ul>
</li>
<li>缺点<ul>
<li>需要大量已知曝光时间的照片</li>
<li>需要自己设定最终的色调映射函数<ul>
<li>设置不好的时候会出现奇怪的色彩</li>
</ul>
</li>
<li>多张图片需要处理对齐的问题</li>
</ul>
</li>
</ul>
</li>
<li>论文 2：利用单张 LDR 图片和 intensity map 图片重建 HDR 图片<ul>
<li>优点<ul>
<li>能够将图像的深度信息较好的恢复</li>
<li>两张照片即可，相对容易获取</li>
</ul>
</li>
<li>缺点<ul>
<li>需要获得 intensity map</li>
<li>恢复不出来颜色信息</li>
<li>需要自己设置色调映射函数</li>
<li>可能需要进行 ldr 图片和 intensity map 的对齐<ul>
<li>存在一定的偏差</li>
</ul>
</li>
<li>每一张图片的性质不同，如果要恢复得比较好的话，需要对每一张图片进行调节</li>
<li>intensity map 的低分辨率导致图片的低曝光区域噪声很多，因此对低曝光区域的恢复也不太好</li>
</ul>
</li>
</ul>
</li>
<li>论文 3：对单张 LDR 图片，利用 deep-CNNs 重建 HDR 图片<ul>
<li>优点<ul>
<li>所需材料少，获取材料简单</li>
<li>效果其实很好，使用论文1 中一张合适的图片便可以将整体恢复得很好</li>
</ul>
</li>
<li>缺点<ul>
<li>训练一个这样的神经网络需要大量的材料和算力</li>
<li>需要有一定的硬件设备<ul>
<li>显卡内存需要比较大</li>
</ul>
</li>
<li>只能恢复高曝光饱和的情况</li>
<li>细节缺失严重的时候恢复不出来</li>
<li>回复的细节信息可能与实际有所偏差</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/04/CV/HDR/Paper23/" data-id="cl9lj748v002l64tz7s4wg7b6" data-title="高动态范围成像" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CV/" rel="tag">CV</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HDR/" rel="tag">HDR</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/LS/11" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/22/CG/LS/11/" class="article-date">
  <time class="dt-published" datetime="2021-02-22T06:39:19.000Z" itemprop="datePublished">2021-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-LS/">CG.LS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/22/CG/LS/11/">计算机图形学.李胜.11.物理模拟</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>游戏、动画，谋求逼真的效果（指视觉上的逼真效果）</li>
</ul>
<h1 id="Rigging"><a href="#Rigging" class="headerlink" title="Rigging"></a>Rigging</h1><h2 id="Workflow（制作电影的工作流程）"><a href="#Workflow（制作电影的工作流程）" class="headerlink" title="Workflow（制作电影的工作流程）"></a>Workflow（制作电影的工作流程）</h2><ul>
<li>Story<ul>
<li>故事绘本</li>
</ul>
</li>
<li>Video footage<ul>
<li>小样</li>
</ul>
</li>
<li>Concept drawing<ul>
<li>虚拟生物等草图绘制</li>
</ul>
</li>
<li>Modeling<ul>
<li>建模</li>
</ul>
</li>
<li>Rigging and simulation<ul>
<li>动起来</li>
</ul>
</li>
<li>Rendering<ul>
<li>渲染</li>
</ul>
</li>
<li>Composites<ul>
<li>把以上内容合成在一起</li>
<li>另外可能还有<ul>
<li>motion blur</li>
<li>camera shake</li>
<li>character（角色动画）</li>
<li>color lighting</li>
<li>effects（特效）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="What-Is-Rigging"><a href="#What-Is-Rigging" class="headerlink" title="What Is Rigging"></a>What Is Rigging</h2><ul>
<li>Rig come from Puppet（木偶）</li>
<li>How character’s motion is driven</li>
<li>rig vs skin<ul>
<li>skin：蒙皮、运动中的变化<ul>
<li>rig 的一个部分</li>
</ul>
</li>
<li>Skinning just solve surface motion for display</li>
<li>Rig is more general<ul>
<li>加骨骼、运动控制、运动中表皮的变化</li>
</ul>
</li>
<li>Part of rigging process</li>
</ul>
</li>
</ul>
<h3 id="Rigging-Movie-in-History"><a href="#Rigging-Movie-in-History" class="headerlink" title="Rigging Movie in History"></a>Rigging Movie in History</h3><ul>
<li>Jurassic Park [1993] , milestone in digital art.</li>
<li>Rigging + simple secondary muscle motion.</li>
<li>Use many real models.</li>
<li>People do composite job on dinosaurs on YOUTUBE</li>
</ul>
<h3 id="Rigging-Types"><a href="#Rigging-Types" class="headerlink" title="Rigging Types"></a>Rigging Types</h3><ul>
<li>Performance rig<ul>
<li>a motion and control system providing control of the character to animation artists.</li>
<li>骨架驱动的对象运动形态</li>
</ul>
</li>
<li>Simulation rig<ul>
<li>物理、基于动力学模拟出来的</li>
<li>Dynamic behavior(g)</li>
<li>Collision</li>
<li>Cloth</li>
<li>Spring</li>
<li>soft and rigid‐body</li>
<li>Bake to animation sequence</li>
</ul>
</li>
<li>Deformation rig<ul>
<li>形变的时候，外表皮如何生成</li>
<li>character’s skin relative to the motion of the performance rig</li>
<li>Know as Skinning as we have mentioned</li>
<li>T pose</li>
</ul>
</li>
<li>Facial rig<ul>
<li>人脸（复杂、逼真很难）<ul>
<li>人对人脸看的很多，很容易判断一张人脸是否是合成的</li>
</ul>
</li>
<li>Blend shapes<ul>
<li>Face can be defined with limited set</li>
<li>Synthesis, transfer, interpolate</li>
<li>Recent hot in graphics and vision</li>
<li>Also need manual rig in production</li>
</ul>
</li>
<li>现在电影的开销：演员、动画师<ul>
<li>演员是否会被替代？逼真人脸的制作</li>
</ul>
</li>
</ul>
</li>
<li>Muscle rig<ul>
<li>解剖学：肌肉驱动</li>
<li>Most complicated rig</li>
<li>Also is collision object with skin</li>
<li>Need experience in anatomy, how muscle works</li>
<li>Generally don’t use it</li>
</ul>
</li>
<li>Clothing and accoutrements rig</li>
<li>Motion capture&#x2F;tracking rig<ul>
<li>Usually used as an input to the performance rig.</li>
<li>Lots of company building tracking hardware</li>
<li>阿凡达电影</li>
</ul>
</li>
</ul>
<h3 id="Standard-Performance-Rig"><a href="#Standard-Performance-Rig" class="headerlink" title="Standard Performance Rig"></a>Standard Performance Rig</h3><ul>
<li>Joint Placement&#x2F;Orientation(lock some DOF)<ul>
<li>结点的放置&#x2F;朝向，锁定自由度</li>
<li>例如人的手有些方向是不能动的</li>
</ul>
</li>
<li>Add Controller (cage select detail hard)<ul>
<li>cage：模型的几何代理、类似于包围盒的粗糙盒子<ul>
<li>通过调整盒子的变化控制模型的形变</li>
</ul>
</li>
</ul>
</li>
<li>Attach FK&#x2F;IK to the controller<ul>
<li>FK：forward kinematics（运动学）<ul>
<li>给定怎么从 A 状态运动到 B 状态</li>
</ul>
</li>
<li>IK：inverse kinematics（逆运动学）<ul>
<li>给定两个状态，通 过计算得到运动方式</li>
</ul>
</li>
</ul>
</li>
<li>Paint the skinning weights<ul>
<li>蒙皮刷权重</li>
<li>可能会出现一些奇异的情况（不符合现实），因此需要蒙皮刷权重</li>
</ul>
</li>
<li>special handling<ul>
<li>一些风格化的渲染</li>
</ul>
</li>
</ul>
<h1 id="Simulation"><a href="#Simulation" class="headerlink" title="Simulation"></a>Simulation</h1><ul>
<li>更真实展现自然界的现象</li>
</ul>
<p><img src="/11/simulation.png"></p>
<ul>
<li>弹性体、弹塑性体<ul>
<li>碰撞<ul>
<li>恢复</li>
<li>弹塑性材料：部分恢复</li>
</ul>
</li>
<li>应变的计算</li>
</ul>
</li>
<li>多体碰撞、多点接触<ul>
<li>怎么计算力的作用</li>
<li>离散化大量离散点的碰撞</li>
</ul>
</li>
<li>固体：非穿越条件<ul>
<li>$t_0$ 未接触，但是 $t_0+\Delta t$ 就穿越了</li>
<li>解决：时间片 $\Delta t$ 选择更小（$10^{-5},10^{-6}$级别）</li>
</ul>
</li>
<li>绳子的模拟<ul>
<li>扭转、剪切</li>
</ul>
</li>
<li>布料的模拟<ul>
<li>褶皱多，且互不穿越</li>
<li>自碰撞检测</li>
</ul>
</li>
<li>刚体<ul>
<li>碰撞碎裂</li>
</ul>
</li>
<li>流体<ul>
<li>粘性流体：蜂蜜</li>
<li>沙子：湿 &#x2F; 干 $\Rightarrow$ 固体 &#x2F; 流体<ul>
<li>形态转换</li>
<li>湿沙子，沙子颗粒之间有液桥力</li>
</ul>
</li>
<li>胶体</li>
</ul>
</li>
<li>Collision, Contact, Friction<ul>
<li>碰撞、接触、摩擦</li>
</ul>
</li>
<li>海洋表面的模拟</li>
</ul>
<h2 id="核心原理：-物体运动方程"><a href="#核心原理：-物体运动方程" class="headerlink" title="核心原理： 物体运动方程"></a>核心原理： 物体运动方程</h2><h3 id="流体"><a href="#流体" class="headerlink" title="流体"></a>流体</h3><ul>
<li>纳维斯托克斯方程</li>
</ul>
<p>$$<br>\rho\dfrac{dv}{dt}&#x3D;\rho g-\triangledown p+\mu\triangledown^2v<br>$$</p>
<ul>
<li>$\rho$：密度</li>
<li>$p$：压强</li>
<li>$\mu$：粘滞系数</li>
</ul>
<h3 id="两大流派"><a href="#两大流派" class="headerlink" title="两大流派"></a>两大流派</h3><ul>
<li>拉格朗日流派：粒子<ul>
<li>拉格朗日法着眼于研究各个流体质点的运动，描述的流体质点至始至终的运动过程以及它们的物理量随时间 t 的变化规律</li>
</ul>
</li>
<li>欧拉流派：栅格<ul>
<li>欧拉法着眼于空间点，描述的是各个时刻，各个空间点（场论的概念）中流体质点物理量的变化情况。物理量在空间中的分布称为物理场，如速度场、压力场、密度场等，这些所有的物理量场统称为流场</li>
</ul>
</li>
</ul>
<h3 id="刚体"><a href="#刚体" class="headerlink" title="刚体"></a>刚体</h3><ul>
<li>平动与转动</li>
</ul>
<p>$$<br>\dfrac{d}{dt}(X_t)&#x3D;d\left(<br>\begin{array}{ccc}<br>x_t\<br>R_t<br>\end{array}<br>\right)<br>&#x3D;\left(<br>\begin{array}{ccc}<br>v_t\<br>w_t\times R_t<br>\end{array}<br>\right)<br>$$</p>
<h3 id="弹性体"><a href="#弹性体" class="headerlink" title="弹性体"></a>弹性体</h3><ul>
<li>有限元方法</li>
</ul>
<h2 id="动画计算的一般流程"><a href="#动画计算的一般流程" class="headerlink" title="动画计算的一般流程"></a>动画计算的一般流程</h2><ul>
<li>离散化</li>
<li>方程初始化</li>
<li>仿真计算与迭代</li>
<li>仿真中止</li>
<li>真实感渲染</li>
</ul>
<p><img src="/11/animation.png"></p>
<h3 id="示例：绳子（弹簧模型）"><a href="#示例：绳子（弹簧模型）" class="headerlink" title="示例：绳子（弹簧模型）"></a>示例：绳子（弹簧模型）</h3><h4 id="1-离散化"><a href="#1-离散化" class="headerlink" title="(1) 离散化"></a>(1) 离散化</h4><ul>
<li>分成一段一段的，弹簧质点模型</li>
<li>质点 $x_0,x_1,…,x_{n+1}$</li>
<li>弹簧 $e_0,e_1,…,e_n$</li>
</ul>
<h4 id="2-方程初始化"><a href="#2-方程初始化" class="headerlink" title="(2) 方程初始化"></a>(2) 方程初始化</h4><ul>
<li>质量 $m_0,m_1,…,m_{n+1}$</li>
<li>初速度 $v_0,v_1,…,v_{n+1}$</li>
<li>弹性系数 $k_0,k_1,…,k_n$</li>
</ul>
<h4 id="3-仿真迭代计算"><a href="#3-仿真迭代计算" class="headerlink" title="(3) 仿真迭代计算"></a>(3) 仿真迭代计算</h4><ul>
<li>将连续的运动过程离散到一系列时间点<ul>
<li>时间片划分</li>
</ul>
</li>
<li>在相邻的时间点之间更新运动状态<ul>
<li>$v^t\to v^{t+1}$</li>
<li>$x^t\to x^{t+1}$</li>
</ul>
</li>
<li>更新规则：胡克定律 $m\dfrac{d^2x}{dt^2}&#x3D;k\Delta l$</li>
</ul>
<h4 id="4-渲染"><a href="#4-渲染" class="headerlink" title="(4) 渲染"></a>(4) 渲染</h4><h2 id="热点与难点"><a href="#热点与难点" class="headerlink" title="热点与难点"></a>热点与难点</h2><h3 id="固体"><a href="#固体" class="headerlink" title="固体"></a>固体</h3><ul>
<li>非光滑的多体接触碰撞<ul>
<li>扑克牌塔（静摩擦处于稳定状态）<ul>
<li>算法不稳定会导致崩塌</li>
</ul>
</li>
</ul>
</li>
<li>大场景快速而稳定的仿真计算<ul>
<li>碰撞摩擦</li>
</ul>
</li>
</ul>
<h3 id="形变体"><a href="#形变体" class="headerlink" title="形变体"></a>形变体</h3><ul>
<li>大形变不能产生畸变</li>
<li>复杂拓扑修改</li>
<li>艺术指导的形变</li>
</ul>
<h3 id="碎裂"><a href="#碎裂" class="headerlink" title="碎裂"></a>碎裂</h3><ul>
<li>断裂面跟踪</li>
<li>设计碎裂模式<ul>
<li>一碰就裂</li>
<li>慢慢的产生裂纹，裂开</li>
</ul>
</li>
</ul>
<h3 id="流体-1"><a href="#流体-1" class="headerlink" title="流体"></a>流体</h3><ul>
<li>精细薄片特征</li>
<li>表面波纹</li>
</ul>
<h3 id="流体、烟雾及其耦合"><a href="#流体、烟雾及其耦合" class="headerlink" title="流体、烟雾及其耦合"></a>流体、烟雾及其耦合</h3><ul>
<li>湍流效果</li>
<li>多种形态耦合作用</li>
</ul>
<h3 id="产生声音"><a href="#产生声音" class="headerlink" title="产生声音"></a>产生声音</h3><ul>
<li>从动力学的角度产生声音</li>
<li>振动模态可以从动力学产生</li>
</ul>
<h3 id="开源代码"><a href="#开源代码" class="headerlink" title="开源代码"></a>开源代码</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/yuanming-hu/difftaichi">https://github.com/yuanming-hu/difftaichi</a></li>
</ul>
<h1 id="工业界与研究"><a href="#工业界与研究" class="headerlink" title="工业界与研究"></a>工业界与研究</h1><ul>
<li>industry &amp; research</li>
<li>相辅相成、互相促进</li>
</ul>
<h2 id="exhaust-the-existing-techniques"><a href="#exhaust-the-existing-techniques" class="headerlink" title="exhaust the existing techniques"></a>exhaust the existing techniques</h2><ul>
<li>detailed smoke</li>
<li>flip particles</li>
</ul>
<h2 id="megamind-fluid-simulation"><a href="#megamind-fluid-simulation" class="headerlink" title="megamind fluid simulation"></a>megamind fluid simulation</h2><ul>
<li>large scale</li>
<li>serious simulation</li>
</ul>
<h1 id="一些研究工作"><a href="#一些研究工作" class="headerlink" title="一些研究工作"></a>一些研究工作</h1><ul>
<li>以固体的仿真为核心，研究固体的运动、碰撞、形变、碎裂现象的物理机理和仿真建模，模拟固体多体之间的相互作用以及液体与固体多体的相互作用的仿真计算<ul>
<li>并行的快速连续碰撞检测</li>
<li>刚性固体的破碎</li>
<li>复杂物体表面破碎裂纹的仿真</li>
<li>弹性固体的仿真</li>
<li>具有材料属性的固体交互编辑和仿真</li>
<li>不可压流体的高效模拟<ul>
<li>基于表面张力波的流体细节仿真</li>
</ul>
</li>
<li>固液耦合的交错光滑例子动力学</li>
<li>精确的摩擦计算的多点接触刚体系统</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/22/CG/LS/11/" data-id="cl9lj7497004n64tz7xsz3rjx" data-title="计算机图形学.李胜.11.物理模拟" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/LS/10" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/22/CG/LS/10/" class="article-date">
  <time class="dt-published" datetime="2021-02-22T01:21:55.000Z" itemprop="datePublished">2021-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-LS/">CG.LS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/22/CG/LS/10/">计算机图形学.李胜.10.高级光照模型与绘制理论</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="BRDF反射模型"><a href="#BRDF反射模型" class="headerlink" title="BRDF反射模型"></a>BRDF反射模型</h1><ul>
<li>Bidirectional Reflectance Distribution Function</li>
<li>双向反射率分布函数</li>
<li>用来描述物体的<strong>材料属性</strong>，表示光如何从一个表面反射出去</li>
<li>输入参数：5<ul>
<li>入射光和发射光的方位角 $\phi$、仰角 $\theta$</li>
<li>入射光的波长 $\lambda$</li>
</ul>
</li>
<li>输出一个无单位的值<ul>
<li>表示对于给定的入射方向，在发射方向反射出去能量的<strong>比例</strong></li>
<li>BRDF 给出了入射光子在某一方向离开的<strong>概率</strong><ul>
<li>立体角对应的面上的能量</li>
</ul>
</li>
</ul>
</li>
<li>incoming &#x2F; outgoing</li>
</ul>
<img src="10/brdf.png" style="zoom:60%;" />

<ul>
<li>BRDF 描述了入射辐射亮度和发射辐射亮度是如何相互联系的，但没有解释材料是如何在物理上与光相互作用的</li>
</ul>
<h2 id="BRDF-的性质"><a href="#BRDF-的性质" class="headerlink" title="BRDF 的性质"></a>BRDF 的性质</h2><ul>
<li>Helmholtz互反定理（Helmholtz reciprocity）<ul>
<li>Value of BRDF remains unchanged if the incident and outgoing directions are interchanged</li>
<li><strong>输入和输出角切换后函数值相同</strong></li>
</ul>
</li>
<li>能量守恒定律<ul>
<li>the total amount of power reflected all directions must be less than or equal to the total amount of power incident on the surface</li>
<li><strong>发射的能量小于等于入射的能量</strong></li>
</ul>
</li>
</ul>
<h2 id="BRDF-的例子"><a href="#BRDF-的例子" class="headerlink" title="BRDF 的例子"></a>BRDF 的例子</h2><h3 id="Diffuse-漫反射"><a href="#Diffuse-漫反射" class="headerlink" title="Diffuse 漫反射"></a>Diffuse 漫反射</h3><p>$$<br>F_r&#x3D;\dfrac{\rho_d}{2\pi}<br>$$</p>
<ul>
<li>$\rho_d$ 表示出射光占入射光的比例，0-1</li>
</ul>
<img src="10/diffuse.png" style="zoom: 50%;" />



<h3 id="specular-镜面高光"><a href="#specular-镜面高光" class="headerlink" title="specular 镜面高光"></a>specular 镜面高光</h3><p>$$<br>Exitant\ direction:R&#x3D;2(N\cdot\Psi)N-\Psi<br>$$</p>
<img src="10/specular.png" alt="1613960000494" style="zoom:50%;" />



<h3 id="一般物体"><a href="#一般物体" class="headerlink" title="一般物体"></a>一般物体</h3><img src="10/brdf-normal.png" style="zoom:50%;" />



<h2 id="BSSRDF"><a href="#BSSRDF" class="headerlink" title="BSSRDF"></a>BSSRDF</h2><ul>
<li>BRDF 是更一般方程<strong>双向表面散射反射率分布函数</strong>的一种逼近<ul>
<li>Bidirectional Surface Scattering Reflectance Distribution Function (BSSRDF)</li>
</ul>
</li>
<li>BRDF 没有考虑表面内光的散射<ul>
<li>大理石</li>
</ul>
</li>
<li>BSSRDF 通过把<strong>入射光的位置</strong>和<strong>发射光的位置</strong>作为函数的输入覆盖了散射现象<ul>
<li>它描述的是光从入射方向在表面的<strong>某一点</strong>入射，然后在<strong>另一点</strong>沿发射方向发射的比率</li>
</ul>
</li>
</ul>
<h2 id="反射方程"><a href="#反射方程" class="headerlink" title="反射方程"></a>反射方程</h2><ul>
<li>Reflectance Equation</li>
<li>给定一 BRDF 和入射辐射亮度分布，反射方程决定了表面在给定视域方向的发射辐射亮度。它通过在表面的半球面上对所有方向的入射辐射亮度进行积分得到</li>
</ul>
<p>$$<br>L(\theta_o,\phi_o)&#x3D;\iint_{\Omega}f(\theta_o,\phi_o,\theta_i,\phi_i)L(\theta_i,\phi_i)\cos(\theta_i)d\sigma(\theta_i,\phi_i)<br>$$</p>
<ul>
<li>$i,o$ 入射出射方向</li>
<li>$f$ 表示 BRDF</li>
<li>$L\cos(\theta_i)$ 将光线转化为正向入射</li>
<li>在<strong>半球面</strong>上积分</li>
<li>该方程对三个颜色分量<strong>单独</strong>计算</li>
</ul>
<h3 id="点光源的反射方程"><a href="#点光源的反射方程" class="headerlink" title="点光源的反射方程"></a>点光源的反射方程</h3><ul>
<li><strong>点光源</strong>，简化为</li>
</ul>
<p>$$<br>L(\theta_o,\phi_o)&#x3D;f(\theta_o,\phi_o,\theta_i,\phi_i)L(\theta_i,\phi_i)\cos(\theta_i)<br>$$</p>
<ul>
<li>$(\theta_i,\phi_i)$ 表示光源方向</li>
<li>向量表示</li>
</ul>
<p>$$<br>L(\vec{\omega_o})&#x3D;f(\vec{\omega_o},\vec{\omega_i})L(\vec{\omega_i})(\vec{n}\cdot\vec{\omega_i})<br>$$</p>
<h2 id="BRDF分布图"><a href="#BRDF分布图" class="headerlink" title="BRDF分布图"></a>BRDF分布图</h2><ul>
<li>理解 BRDF 的一种方法为把入射方向保持恒定，然后观察其输出结果。对于给定方向的入射光，发射能量的分布不同。</li>
<li>交点附近的球面部分为漫反射项。椭圆形部分的为反射叶(reflectance lobe)（镜面项），通常在入射光的反射方向。</li>
<li>Torrance-Sparrow 模型：镜面高光并非在反射方向最强</li>
</ul>
<table>
<thead>
<tr>
<th align="center">漫反射表面</th>
<th align="center">Phong&#x2F;Blinn 高光 + 漫反射</th>
<th align="center">Torrance-Sparrow模型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ward’s各向异性模型</td>
<td align="center">Hapke的BRDF模型</td>
<td align="center">Lommel-Seeliger散射模型</td>
</tr>
</tbody></table>
<img src="10/brdf-01.png" alt="1613960889148" style="zoom:80%;" />



<h2 id="微面元"><a href="#微面元" class="headerlink" title="微面元"></a>微面元</h2><ul>
<li><strong>microfacet</strong></li>
<li>微面元是物体表面上一种<strong>微小</strong>的、<strong>平坦</strong>的<strong>镜面</strong>，具有<strong>随机的大小和角度</strong></li>
</ul>
<img src="10/mmicrofacet.png" style="zoom:50%;" />

<ul>
<li>在 BRDF 模型中，一般处理成高斯分布<ul>
<li>处理方便</li>
</ul>
</li>
<li>微面元描述典型反射<ul>
<li><strong>镜面反射</strong>可以用一些微面元的<strong>直接反射</strong>来描述</li>
<li><strong>漫反射</strong>可以用微面元间的<strong>相互反射</strong>来描述</li>
<li>微面元之间还可以互相投射阴影</li>
</ul>
</li>
<li>当<strong>微面元的大小</strong>与<strong>光的波长</strong>相近时，还有一个重要概念 height correlation, 可用来模拟干涉、衍射等物理现象</li>
</ul>
<h2 id="菲涅尔反射"><a href="#菲涅尔反射" class="headerlink" title="菲涅尔反射"></a>菲涅尔反射</h2><ul>
<li>Fresnel Reflectance</li>
<li>塑料、玻璃和水等绝缘体或电介质材料</li>
<li>当电介质材料以接近掠角（Grazing angle）的角度观察时，反射会更厉害（但对于金属，该角度引起的反射变化相对较小）<ul>
<li>当用最浅的掠角时，所有的材料变成全反射</li>
</ul>
</li>
<li>现象<ul>
<li>手拿一本书，对准计算机的显示器，以很浅的角度去看其中的页面，在一个极端浅的角度，你可以看到屏幕在书上的反射</li>
</ul>
</li>
</ul>
<h3 id="菲涅尔反射公式"><a href="#菲涅尔反射公式" class="headerlink" title="菲涅尔反射公式"></a>菲涅尔反射公式</h3><ul>
<li>菲涅尔反射的公式与折射率、衰减系数、入射角有关<ul>
<li>绝缘体的折射率可设成是1.5</li>
<li>若衰减系数未知，可设置为0</li>
</ul>
</li>
<li>菲涅尔反射公式如下</li>
</ul>
<p>$$<br>F&#x3D;\dfrac{1}{2}\dfrac{(g+c)^2}{(g-c)^2}(1+\dfrac{[c(g+c)-1]^2}{[c(g-c)+1]^2})<br>$$</p>
<p>$$<br>c&#x3D;\vec{v}\cdot\vec{h}<br>$$</p>
<p>$$<br>g&#x3D;\sqrt{n^2+c^2-1}<br>$$</p>
<ul>
<li><p>$\vec{v}$ 为视线矢量，$\vec{h}$ 为半角矢量，$n$ 为折射率</p>
<ul>
<li>$\vec{h}&#x3D;\dfrac{1}{2}(\vec{v}+\vec{l})$</li>
<li>入射光矢量、视线矢量</li>
</ul>
</li>
<li><p>一个 $n&#x3D;1.5$ 的例子</p>
</li>
</ul>
<img src="10/fresnel.png" style="zoom: 80%;" />



<h2 id="Torrance-Sparrow-x2F-Cook-Torrance-BRDF"><a href="#Torrance-Sparrow-x2F-Cook-Torrance-BRDF" class="headerlink" title="Torrance-Sparrow &#x2F; Cook-Torrance BRDF"></a>Torrance-Sparrow &#x2F; Cook-Torrance BRDF</h2><ul>
<li>描述较光滑的表面</li>
<li>基于微面元<ul>
<li>通过光线在微面元上的相互作用计算出一个衰减因子 $G$<ul>
<li>geometric attenuation factor</li>
<li>0-1：total shadowing - no shadowing</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="光线在微面元上传播的一些情况"><a href="#光线在微面元上传播的一些情况" class="headerlink" title="光线在微面元上传播的一些情况"></a>光线在微面元上传播的一些情况</h3><h4 id="unblocked"><a href="#unblocked" class="headerlink" title="unblocked"></a>unblocked</h4><h3 id=""><a href="#" class="headerlink" title=""></a></h3><img src="10/unblocked.png" style="zoom:50%;" />



<h4 id="masking"><a href="#masking" class="headerlink" title="masking"></a>masking</h4><ul>
<li>部分&#x2F;全部出射光线被遮挡</li>
</ul>
<img src="10/masking.png" style="zoom:50%;" />



<h4 id="shadowing"><a href="#shadowing" class="headerlink" title="shadowing"></a>shadowing</h4><ul>
<li>入射光线部分&#x2F;全部被遮挡</li>
</ul>
<img src="10/shadowing.png" style="zoom:50%;" />



<h3 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h3><p>$$<br>\dfrac{F(l,h)G(l,v)D(h)}{4(n\cdot l)(n\cdot v)}<br>$$</p>
<ul>
<li>$l$：光源方向，$v$：视线方向，$n$：法向，$h$：半角矢量</li>
<li>$G(l,v)$：Geometric Attenuation Factor<ul>
<li>reduces the output based on the amount of <strong>shadowing</strong> or <strong>masking</strong> that occurs</li>
</ul>
</li>
<li>$F(l,h)$：Fresnel term（菲涅尔反射）</li>
<li>$D(h)$：Distribution<ul>
<li>distribution function determines what percentage of microfacet are oriented to reflect in the viewer direction</li>
</ul>
</li>
<li>$(n\cdot l)$：How much of the macroscopic surface is visible to the light source</li>
<li>$(n\cdot v)$：How much of the macroscopic surface is visible to the viewer</li>
</ul>
<h2 id="如何获取-BRDF"><a href="#如何获取-BRDF" class="headerlink" title="如何获取 BRDF"></a>如何获取 BRDF</h2><ul>
<li>BRDF 理论模型的一个问题是它们不能表示特定的材料</li>
<li>获取真实表面的 BRDF<ul>
<li>角度测定法（goniometers）</li>
<li>双向反射计成像法（imaging bidrectional reflectometers）</li>
<li>基于图像的方法（image-based methods）</li>
</ul>
</li>
<li>公开数据库下载<ul>
<li><a target="_blank" rel="noopener" href="http://people.csail.mit.edu/wojciech/BRDFDatabase/">http://people.csail.mit.edu/wojciech/BRDFDatabase/</a><ul>
<li>无法访问？</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="BRDF-绘制实现方法"><a href="#BRDF-绘制实现方法" class="headerlink" title="BRDF 绘制实现方法"></a>BRDF 绘制实现方法</h2><ul>
<li>应用 BRDF 的直接方法为计算顶点的颜色并把结果传到流水线。但其缺点是：如果 BRDF 反射在一些象素上的变化速度太快，线性插值会导致丢失或过分突出这种反射变化。一个解决方法是把表面加细，但会降低算法的性能。</li>
<li>对于给定的材料，如果有一种存取快速的简凑的表示方法，可以带来如下好处<ul>
<li>避免精确理论模型的计算耗费</li>
<li>减少存贮量</li>
<li>减少实验获取BRDF中的噪声</li>
</ul>
</li>
<li>在实时绘制中，主要采用两种简凑的BRDF表示方法<ul>
<li>Factorization 因数分解法</li>
<li>Environment map filtering 环境图滤波</li>
</ul>
</li>
</ul>
<h3 id="因数分解法"><a href="#因数分解法" class="headerlink" title="因数分解法"></a>因数分解法</h3><ul>
<li>一种表示 BRDF 的方法为把 BRDF 表示成乘积项的和（而不是一系列基函数的加权和），其中每个乘积项包含两项</li>
<li>思想：把 BRDF 转化为一系列二维纹理对。每对纹理通过四维参数存取（2个入射角和2个发射角），返回的纹理值相乘后再相加，得到象素的颜色</li>
<li>初始的 BRDF 有两个方向矢量，入射矢量和发射矢量。因数分解法就是把 BRDF 表示成简单函数对乘积的和</li>
</ul>
<p>$$<br>f(\vec{\omega_i},\vec{\omega_o})\approx\sum_{j&#x3D;1}^np_j(\vec{\omega_i})q_j(\vec{\omega_o})<br>$$</p>
<ul>
<li>因数分解法蕴涵的思想为把入射和发射方向映射为纹理上的象素，使得上式中的 n 尽量小，并且方向矢量可以通过纹理的线性插值来得到</li>
<li>存取的纹理与环境映照具有相同的形式：球面图、抛物面图、立方体图<ul>
<li>其中立方体图的质量最高</li>
</ul>
</li>
<li>我们的目标是构造纹理对<ul>
<li>入射纹理：通过入射方向存取</li>
<li>发射纹理：通过发射方向存取</li>
</ul>
</li>
<li>在实践中，我们发现这种参数化结果并不好，会导致需要很多纹理对（n很大）才能较好地逼近 BRDF。在三角形内的线性插值结果也不好，会导致严重的误差</li>
<li>好的参数化方法与材料的类型有关（并非完全是一个科学问题）</li>
</ul>
<h4 id="矩阵分解计算纹理对"><a href="#矩阵分解计算纹理对" class="headerlink" title="矩阵分解计算纹理对"></a>矩阵分解计算纹理对</h4><ul>
<li>为了计算纹理对，需要构造一大型矩阵（可以采用预计算的方法）</li>
<li>入射纹理的每个纹素表示该矩阵的行下标，发射纹理的每个纹素表示该矩阵的列下标</li>
<li>矩阵的每个元素表示 BRDF 的反射系数值</li>
<li>矩阵分解通常采用两种方法<ul>
<li>奇异值分解(SVD, Singular Value Decomposition),</li>
<li>规范化分解(ND, Normalized Decomposition)</li>
</ul>
</li>
<li>把分解得到的行矢量和列矢量对存入纹理对，便得到我们所需要的纹理对</li>
<li>规范化分解的缺点是结果不太精确，但比SVD简单、存贮量小，并且纹理值都是正的<ul>
<li>用的不多</li>
</ul>
</li>
<li><strong>矩阵分解可看成是一种数据压缩方式</strong><ul>
<li>四维的 BRDF 转化为纹理对，然后由图形硬件进行解压。由于纹理可以用球面图或抛物面图来表示，因此该技术可在任何图形硬件上运行</li>
</ul>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>对于每个光源，至少需要一对纹理</li>
<li>只适合点光源和方向光。不能捕获从面光源、天空光和其它物体来的辐射亮度</li>
</ul>
<h3 id="环境图滤波"><a href="#环境图滤波" class="headerlink" title="环境图滤波"></a>环境图滤波</h3><ul>
<li>BRDF 是一个方向，对多个反射方向进行滤波（漫反射效果）</li>
<li>前面我们讲过，环境图可以用来绘制理想的发光表面（perfectly shiny surface）</li>
<li>这个概念同样可以推广到光滑面（glossy surface）和漫反射面</li>
<li>为了模拟表面<strong>不同程度的粗糙度</strong>，我们可以对纹理的环境表示进行<strong>滤波</strong><ul>
<li>通过对环境图进行<strong>模糊操作</strong>，我们可以使得镜面反射呈现*<em>粗糙的视觉效果</em></li>
</ul>
</li>
<li>理论上，模糊操作应以非线性的方式进行。也就是说，纹理的不同部分应以不同的方式进行模糊。但因为<strong>整体的反射效果通常比精确的反射更重要</strong>，所以我们可以直接采用对环境图进行<strong>均匀模糊</strong>的方法</li>
<li>一个物理上更真实的方法为采用 Phong 镜面方程来对环境图进行滤波。镜面叶决定采样环境映照中的哪些纹素，并决定每个纹素的相对贡献</li>
<li>滤波方式<ul>
<li>理想镜面反射</li>
<li>反射光线的<strong>镜面叶</strong></li>
<li>对表面上的余弦加权半球面进行求和来得到漫反射分量中入射光的贡献</li>
</ul>
</li>
</ul>
<p><img src="/10/environment.png"></p>
<ul>
<li>其思想是把环境映照 EM 看成是罩在物体外面的一个球面。EM 上的每个纹素表示球面上的不同面积，其值为常数。由纹素构成的四边形实际上描述了一个球面四边形，其面积可用两个平面三角形来简单逼近。为了建立模拟表面模糊效果的图，首先进行预处理，计算纹素四个角点的单位化法向和纹素的面积。</li>
<li>算法思想<ul>
<li>对于每个反射方向，找到每个EM纹素对该方向的贡献</li>
<li>假设反射方向附近有一个光源，直接从反射方向来的光具有最大的贡献，越偏离该方向, 贡献越小</li>
<li>EM纹素的面积乘上该纹素的 BRDF 贡献给出了该纹素的相对影响，把结果相加来计算q。s为加权贡献的和</li>
<li>最后的结果 q&#x2F;s 为在反射方向叶上积分得到的整体颜色</li>
</ul>
</li>
</ul>
<h1 id="绘制方程"><a href="#绘制方程" class="headerlink" title="绘制方程"></a>绘制方程</h1><h2 id="反射方程-1"><a href="#反射方程-1" class="headerlink" title="反射方程"></a>反射方程</h2><ul>
<li>Reflected Light(Output Image)<ul>
<li>Emission</li>
<li>Incident Light (from light source) x BRDF x Cosine of Incident angle</li>
</ul>
</li>
<li>自发光 + 反射光</li>
</ul>
<h3 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h3><img src="10/one-light.png" style="zoom: 70%;" />
$$
L_r(x,\vec{\omega_r})=L_e(x,\vec{\omega_r})+L_i(x,\vec{\omega_i})f(x,\omega_i,\omega_r)(\omega_i\cdot n)
$$


<h3 id="多光源"><a href="#多光源" class="headerlink" title="多光源"></a>多光源</h3><p>$$<br>L_r(x,\vec{\omega_r})&#x3D;L_e(x,\vec{\omega_r})+\sum L_i(x,\vec{\omega_i})f(x,\omega_i,\omega_r)(\omega_i\cdot n)<br>$$</p>
<h3 id="面光源"><a href="#面光源" class="headerlink" title="面光源"></a>面光源</h3><ul>
<li>立体角积分</li>
</ul>
<p>$$<br>L_r(x,\vec{\omega_r})&#x3D;L_e(x,\vec{\omega_r})+\int_\Omega L_i(x,\vec{\omega_i})f(x,\omega_i,\omega_r)(\omega_i\cdot n)d\omega_i<br>$$</p>
<h3 id="全局光照明"><a href="#全局光照明" class="headerlink" title="全局光照明"></a>全局光照明</h3><ul>
<li>其他表面的反射光</li>
<li>$ L_r(x’,-\vec{\omega_i})$ <strong>未知</strong></li>
</ul>
<p>$$<br>L_r(x,\vec{\omega_r})&#x3D;L_e(x,\vec{\omega_r})+\int_\Omega L_r(x’,-\vec{\omega_i})f(x,\omega_i,\omega_r)(\omega_i\cdot n)d\omega_i<br>$$</p>
<h2 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h2><ul>
<li>上面的全局光照明</li>
<li>直接光与间接光<ul>
<li>Direct (local ) illumination<ul>
<li>Light directly from light sources</li>
<li>No shadows</li>
</ul>
</li>
<li>Indirect (global ) illumination<ul>
<li>Hard and soft shadows</li>
<li>Diffuse interreflections (radiosity)<ul>
<li>interreflections ：相互反射</li>
</ul>
</li>
<li>Glossy interreflections (caustics)<ul>
<li>caustics：焦散</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>挑战：入射光出射光互相依赖<ul>
<li>To evaluate the reflection equation the incoming radiance must be known</li>
<li>To evaluate the incoming radiance the reflected radiance must be known</li>
</ul>
</li>
<li>Surface Balance Equation<ul>
<li>[outgoing] &#x3D; [emitted] + [reflected]</li>
<li>[outgoing] &#x3D; [emitted] + [reflected] + [transmitted]<ul>
<li>BTDF：透射光（下面透射上来、透射下去）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>$$<br>L_o(x,\vec{\omega_o})&#x3D;L_e(x,\vec{\omega_o})+L_r(x,\vec{\omega_o})+L_t(x,\vec{\omega_o})<br>$$</p>
<p>$$<br>L_r(x,\vec{\omega_o})&#x3D;\int_{H_+^2} L_i(x’,\vec{\omega_i})f_r(x,\omega_i\to\omega_o)(\cos\theta_i)d\omega_i<br>$$</p>
<p>$$<br>L_t(x,\vec{\omega_o})&#x3D;\int_{H_-^2} L_i(x’,\vec{\omega_t})f_r(x,\omega_t\to\omega_o)(\cos\theta_t)d\omega_t<br>$$</p>
<ul>
<li>可以利用法向合并</li>
</ul>
<p>$$<br>H_+^2(n):\omega_o\cdot n(x)&gt;0\<br>H_-^2(n):\omega_o\cdot n(x)&lt;0<br>$$</p>
<p>$$<br>L(x,\vec{\omega})&#x3D;L_e(x,\vec{\omega})+\int_{H^2} L(x^\ast(x,\omega’),\vec{\omega})f_r(x,\omega’\to\omega)(\cos\theta’)d\omega’<br>$$</p>
<ul>
<li>$x^\ast(x,\omega’)$ 中间包含路径衰减等因素（传输因子）</li>
<li>推到得到矩阵形式</li>
</ul>
<p>$$<br>l(u)&#x3D;e(u)+\int l(v)K(u,v)dv<br>$$</p>
<p>$$<br>L&#x3D;E+KL<br>$$</p>
<ul>
<li>矩阵 $K$ 表示在光的传播过程中其他各点的贡献</li>
<li>L, E are vectors, K is the light transport matrix</li>
</ul>
<h3 id="解渲染方程的方法"><a href="#解渲染方程的方法" class="headerlink" title="解渲染方程的方法"></a>解渲染方程的方法</h3><ul>
<li>All global illumination methods try to solve (approximations of) the rendering equation<ul>
<li>Too hard for analytic solution: numerical methods</li>
<li>General theory of solving integral equations</li>
</ul>
</li>
<li>Radiosity (usually diffuse surfaces)<ul>
<li>General class numerical finite element methods (divide surfaces in scene into a finite set elements or patches)</li>
<li>Set up linear system (matrix) of simultaneous equations</li>
<li>Solve <strong>iteratively</strong></li>
</ul>
</li>
<li>ray tracing and extensions<ul>
<li>$L&#x3D;(I-K)^{-1}E$</li>
<li>$L&#x3D;(I+K+K^2+K^3+K^2+\cdots)E$<ul>
<li>$E$：Emission directly（From light sources）</li>
<li>$KE$：Direct Illumination on surfaces</li>
<li>$KE^2$：Global Illumination (One bounce indirect)[Mirrors, Refraction]</li>
<li>$KE^3$：Global Illumination (Two bounce indirect)[Caustics etc]</li>
</ul>
</li>
<li>OpenGL：L&#x3D;E+KE</li>
</ul>
</li>
<li>将立体角转变为我们常用的离散面片</li>
</ul>
<img src="10/omega2a.png" style="zoom: 60%;" />

<ul>
<li>加入可见性检测 $V(x,x’)$</li>
</ul>
<p>$$<br>L_r(x,\vec{\omega_r})&#x3D;L_e(x,\vec{\omega_r})+\int_\Omega L_r(x’,-\vec{\omega_i})f(x,\omega_i,\omega_r)\cos\theta_id\omega_i<br>$$</p>
<p>$$<br>L_r(x,\vec{\omega_r})&#x3D;L_e(x,\vec{\omega_r})+\int_\Omega L_r(x’,-\vec{\omega_i})f(x,\omega_i,\omega_r)V(x,x’)\dfrac{\cos\theta_i\cos<br>\theta_0}{|x-x’|^2}dA’<br>$$</p>
<p>$$<br>L_r(x,\vec{\omega_r})&#x3D;L_e(x,\vec{\omega_r})+\int_\Omega L_r(x’,-\vec{\omega_i})f(x,\omega_i,\omega_r)V(x,x’)G(x,x’)dA’<br>$$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/22/CG/LS/10/" data-id="cl9lj7498004w64tzhr52ex02" data-title="计算机图形学.李胜.10.高级光照模型与绘制理论" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/LS/09" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/20/CG/LS/09/" class="article-date">
  <time class="dt-published" datetime="2021-02-20T13:20:26.000Z" itemprop="datePublished">2021-02-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-LS/">CG.LS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/20/CG/LS/09/">计算机图形学.李胜.09.纹理映射</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="纹理及纹理映射基本原理"><a href="#纹理及纹理映射基本原理" class="headerlink" title="纹理及纹理映射基本原理"></a>纹理及纹理映射基本原理</h1><h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><ul>
<li>纹理 &#x2F; 贴图</li>
<li>纹理是物体表面的细小结构</li>
<li><strong>颜色纹理</strong>、<strong>几何纹理</strong></li>
<li>纹素：纹理像素</li>
</ul>
<h3 id="颜色纹理"><a href="#颜色纹理" class="headerlink" title="颜色纹理"></a>颜色纹理</h3><ul>
<li>光滑表面的花纹、图案</li>
</ul>
<h3 id="几何纹理"><a href="#几何纹理" class="headerlink" title="几何纹理"></a>几何纹理</h3><ul>
<li>基于物体表面的微观几何形状的表面纹理</li>
<li>粗糙的表面<ul>
<li>例：桔子表面的皱纹)</li>
</ul>
</li>
<li><strong>修改几何</strong>、<strong>法向扰动</strong></li>
</ul>
<h2 id="模拟物体表面细节"><a href="#模拟物体表面细节" class="headerlink" title="模拟物体表面细节"></a>模拟物体表面细节</h2><h3 id="模拟细节多边形"><a href="#模拟细节多边形" class="headerlink" title="模拟细节多边形"></a>模拟细节多边形</h3><ul>
<li>根据代生成的纹理构造细节多边形</li>
<li>将细节多边形贴到物体表面</li>
<li><strong>很麻烦</strong></li>
</ul>
<p><img src="/09/T.png"></p>
<ul>
<li>例如上图中的前向面<ul>
<li>如果使用纹理贴图的话，只需要两张图即可（底层浅灰色+T的深灰色）</li>
<li>如果使用模拟多边形的话，需要将整个面划分为<strong>若干个三角形</strong>，将这些三角形分别着色（灰&#x2F;深灰）</li>
</ul>
</li>
</ul>
<h2 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h2><h3 id="纹理的表示"><a href="#纹理的表示" class="headerlink" title="纹理的表示"></a>纹理的表示</h3><h4 id="图象纹理"><a href="#图象纹理" class="headerlink" title="图象纹理"></a>图象纹理</h4><ul>
<li>将二维纹理图案映射到三维物体表面，绘制物体表面上一点时，采用相应的纹理图案中相应点的颜色值</li>
</ul>
<h4 id="函数纹理"><a href="#函数纹理" class="headerlink" title="函数纹理"></a>函数纹理</h4><ul>
<li>用数学函数定义简单的二维纹理图案，如方格地毯</li>
<li>或用数学函数定义随机高度场，生成表面粗糙纹理即几何纹理<ul>
<li>噪声</li>
</ul>
</li>
</ul>
<h3 id="纹理映射-1"><a href="#纹理映射-1" class="headerlink" title="纹理映射"></a>纹理映射</h3><ul>
<li>当物体表面是<strong>多边形</strong>时，直接给定多边形顶点的纹理坐标</li>
<li>当物体表面是<strong>参数曲面</strong>时，给定参数与纹理坐标之间的关系</li>
</ul>
<h3 id="纹理映射的步骤"><a href="#纹理映射的步骤" class="headerlink" title="纹理映射的步骤"></a>纹理映射的步骤</h3><ul>
<li>将屏幕像素的四个角点映射到景物坐标空间中可见的物体表面上</li>
<li>将景物坐标空间映射到纹理坐标空间</li>
<li>将像素所对应的纹理坐标空间中的四边形内的所有纹素的值作<strong>加权平均</strong>，结果作为<strong>物体表面的漫反射系数参与颜色计算</strong><ul>
<li>加权平均只是其中一种方法</li>
<li>作为漫反射系数参与计算只是其中一种用途</li>
</ul>
</li>
</ul>
<p><img src="/09/mapping.png"></p>
<h3 id="一些纹理映射"><a href="#一些纹理映射" class="headerlink" title="一些纹理映射"></a>一些纹理映射</h3><ul>
<li>纹理图象模拟国际象棋上黑白相间的方格</li>
</ul>
<h3 id="常用的纹理映射方法"><a href="#常用的纹理映射方法" class="headerlink" title="常用的纹理映射方法"></a>常用的纹理映射方法</h3><h4 id="圆柱面映射"><a href="#圆柱面映射" class="headerlink" title="圆柱面映射"></a>圆柱面映射</h4><p><img src="/09/cylindrical.png"></p>
<ul>
<li>参数方程</li>
</ul>
<p>$$<br>\left{<br>\begin{array}{<strong>lr</strong>}<br>x&#x3D;\cos(2\pi u) &amp;0\le u\le1\<br>y&#x3D;\sin(2\pi u) &amp;0\le v\le1\<br>z&#x3D;v<br>\end{array}<br>\right.<br>$$</p>
<ul>
<li>反求参数</li>
</ul>
<p>$$<br>(u,v)&#x3D;<br>\left{<br>\begin{array}{<strong>lr</strong>}<br>(y,z)&amp;,x&#x3D;0\<br>(x,z)&amp;,y&#x3D;0\<br>(\dfrac{\sqrt{x^2+y^2}-|y|}{x},z)&amp;,else<br>\end{array}<br>\right.<br>$$</p>
<h4 id="球面映射"><a href="#球面映射" class="headerlink" title="球面映射"></a>球面映射</h4><ul>
<li>参数方程</li>
</ul>
<p>$$<br>\left{<br>\begin{array}{<strong>lr</strong>}<br>x&#x3D;\cos(2\pi u)\cos(2\pi v) &amp;0\le u\le1\<br>y&#x3D;\sin(2\pi u)\cos(2\pi v) &amp;0\le v\le1\<br>z&#x3D;\sin(2\pi v)<br>\end{array}<br>\right.<br>$$</p>
<ul>
<li>反求参数</li>
</ul>
<p>$$<br>(u,v)&#x3D;<br>\left{<br>\begin{array}{<strong>lr</strong>}<br>(0,0)&amp;,(x,y)&#x3D;(0,0)\<br>(\dfrac{1-\sqrt{1-(x^2+y^2)}}{x^2+y^2}x,\dfrac{1-\sqrt{1-(x^2+y^2)}}{x^2+y^2}y&amp;,else<br>\end{array}<br>\right.<br>$$</p>
<h3 id="两步法纹理映射"><a href="#两步法纹理映射" class="headerlink" title="两步法纹理映射"></a>两步法纹理映射</h3><ul>
<li>Bier 和 Sloan 提出，应用于三维曲面上</li>
</ul>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>先映射到一个简单的三维曲面上，如平面，柱面，球面或者立方体上（<strong>中介曲面</strong>）</li>
<li>把变形后的映射结果映射到最终曲面上</li>
</ul>
<h4 id="从中介曲面到物体表面的映射方式"><a href="#从中介曲面到物体表面的映射方式" class="headerlink" title="从中介曲面到物体表面的映射方式"></a>从中介曲面到物体表面的映射方式</h4><ul>
<li>反射光线法</li>
<li>物体法向法</li>
<li>物体中心法</li>
<li>中介表面法向法</li>
</ul>
<h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><ul>
<li>大片屏幕区域使用同一个纹素（<strong>色块效应</strong>）</li>
<li>一个像素对应很大区域的纹素</li>
<li><strong>纹理的走样</strong></li>
</ul>
<h1 id="特殊类别纹理映射"><a href="#特殊类别纹理映射" class="headerlink" title="特殊类别纹理映射"></a>特殊类别纹理映射</h1><h2 id="环境映射"><a href="#环境映射" class="headerlink" title="环境映射"></a>环境映射</h2><ul>
<li>Blinn 和 Newell 提出</li>
<li><strong>环境被映照到一个大的球面上</strong></li>
</ul>
<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><ul>
<li>如果目的是为了渲染场景中的一个杯子（小物体），若利用光线跟踪方法，需要对整个场景进行建模渲染，<strong>计算量极大</strong></li>
<li>效果比光线跟踪差，但是计算量要小很多</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>从视点出发，向待绘制的物体表面上一点发出一条光线，求在该点的反射光线与环境球面的交点</li>
<li>平面情况处理，用虚视点方法</li>
<li>环境纹理的获取<ul>
<li><strong>实拍</strong></li>
<li><strong>生成</strong></li>
</ul>
</li>
</ul>
<h3 id="一种环境映射-cube-map"><a href="#一种环境映射-cube-map" class="headerlink" title="一种环境映射 cube map"></a>一种环境映射 cube map</h3><img src="09/cube-map1.png" style="zoom:80%;" />

<img src="09/cube-map2.png" style="zoom:80%;" />





<h2 id="过程纹理"><a href="#过程纹理" class="headerlink" title="过程纹理"></a>过程纹理</h2><ul>
<li>一个小的纹理样本，通过一些简单的变化（相关到那时不一样）形成一片纹理</li>
<li>例如：斑马纹、豹纹等</li>
<li>木头纹理</li>
<li>三维体纹理<ul>
<li>二维纹理图象或纹理函数 sweep（平移、旋转等）</li>
<li>Fourier合成</li>
<li>噪声函数随机合成</li>
</ul>
</li>
</ul>
<h2 id="3D-体纹理"><a href="#3D-体纹理" class="headerlink" title="3D 体纹理"></a>3D 体纹理</h2><ul>
<li>动物毛皮（制作得很真实极难）</li>
<li>精细建模：计算量很大</li>
<li>不精细建模：整体效果粗糙，边界粗糙</li>
</ul>
<h3 id="体纹理绘制方法"><a href="#体纹理绘制方法" class="headerlink" title="体纹理绘制方法"></a>体纹理绘制方法</h3><ul>
<li>基于 shells 的绘制策略</li>
<li>初始的带点的一张图片，通过微小的偏移形成毛发效果</li>
</ul>
<p><img src="/09/shells.png"></p>
<ul>
<li>毛发绘制真实感<ul>
<li>加入阴影</li>
<li>可变长度</li>
</ul>
</li>
</ul>
<h2 id="纹理反走样"><a href="#纹理反走样" class="headerlink" title="纹理反走样"></a>纹理反走样</h2><h3 id="MipMapping-反走样"><a href="#MipMapping-反走样" class="headerlink" title="MipMapping 反走样"></a>MipMapping 反走样</h3><ul>
<li><strong>图象金字塔</strong></li>
<li>从高分辨率到低分辨率，<strong>分层存储</strong></li>
<li>纹理颜色的平均，正方形滤波器作卷积</li>
<li>解决的问题：纹素分辨率与渲染图像分辨率不匹配<ul>
<li>假使原先是匹配的，视点的改变也会导致不匹配（距离变化）</li>
</ul>
</li>
</ul>
<p><img src="/09/mipmap.png"></p>
<ul>
<li>使用的时候按照距离的远近选择不同的分辨率</li>
<li>例如：每次缩小一半<ul>
<li>RGB 3通道，一个方便的存储方式</li>
</ul>
</li>
</ul>
<img src="09/rgb-mipmap.png" style="zoom:80%;" />

<ul>
<li>使用 mipmap 之后过度更加柔和</li>
</ul>
<h3 id="SAT-表反走样"><a href="#SAT-表反走样" class="headerlink" title="SAT 表反走样"></a>SAT 表反走样</h3><ul>
<li>将屏幕像素的4个顶点做映射，找到在纹理中中对应的4个点，对这4个点围成的区域中的纹素表示屏幕像素的纹理<ul>
<li>表示方式：均值、滤波等</li>
</ul>
</li>
<li>相对低效，因此会采用矩形近似的方法（横平竖直的矩形）</li>
</ul>
<p><img src="/09/SAT.png"></p>
<ul>
<li>加速<ul>
<li>动态规划加速</li>
<li>每个顶点记录和原点组成的矩形内像素的<strong>和</strong></li>
</ul>
</li>
</ul>
<h2 id="三维纹理域的映射"><a href="#三维纹理域的映射" class="headerlink" title="三维纹理域的映射"></a>三维纹理域的映射</h2><ul>
<li>物体中每一个点 $(x,y,z)$ 均有一个纹理值 $t(x,y,z)$，其值由纹理函数 $t(x,y,z)$ 唯一确定</li>
<li>三维纹理映射的纹理空间定义在三维空间上，与物体空间维数相同，在纹理映射的时候，只需把场景中的物体变换到纹理空间的局部坐标系中去即可</li>
</ul>
<h2 id="几何纹理之法向扰动法"><a href="#几何纹理之法向扰动法" class="headerlink" title="几何纹理之法向扰动法"></a>几何纹理之法向扰动法</h2><ul>
<li><strong>效果很棒</strong></li>
<li>目标：产生几何纹理，模拟凸凹不平的物体表面</li>
<li>应用：自然界中植物的表皮等</li>
<li>方法：对物体表面微观形状进行扰动</li>
</ul>
<h3 id="bump-map（凹凸贴图）"><a href="#bump-map（凹凸贴图）" class="headerlink" title="bump map（凹凸贴图）"></a>bump map（凹凸贴图）</h3><ul>
<li>凹凸贴图是指计算机图形学中在三维环境中通过纹理方法来产生表面凹凸不平的视觉效果。它主要的原理是通过<strong>改变表面光照方程的法线</strong>，而不是表面的几何法线来模拟凹凸不平的视觉特征，如褶皱、波浪等等。凹凸贴图的实现方法主要有：偏移向量凹凸纹理和改变高度场（百度百科）</li>
</ul>
<h3 id="法向扰动"><a href="#法向扰动" class="headerlink" title="法向扰动"></a>法向扰动</h3><ul>
<li>对物体表面几何性质作微小扰动，产生凹凸不平的细节效果，给物体表面图象加上一个粗糙的外观</li>
<li>物体表面上的每一个点 $P(u,v)$，都沿该点处的法向量方向位移 $F(u,v)$ 个单位长度，新表面位置 $\widetilde{P}(u,v)&#x3D;P(u,v)+F(u,v)*N(u,v)$</li>
<li>新表面的计算方法：通过对两个偏导数求叉积得到</li>
</ul>
<p>$$<br>\widetilde{N}&#x3D;\widetilde{P_u}\times\widetilde{P_v}\<br>\widetilde{P_u}&#x3D;\dfrac{d(P+FN)}{du}&#x3D;P_u+F_uN+FN_u\<br>\widetilde{P_v}&#x3D;\dfrac{d(P+FN)}{dv}&#x3D;P_u+F_vN+FN_v\<br>$$</p>
<ul>
<li>由于 $F$ 很小，作近似计算</li>
</ul>
<p>$$<br>\widetilde{N}\approx(P_u+F_uN)\times(P_u+F_vN)<br>$$</p>
<h4 id="几何纹理实现"><a href="#几何纹理实现" class="headerlink" title="几何纹理实现"></a>几何纹理实现</h4><ul>
<li>扰动后的法向量<strong>单位化</strong>，用于计算曲面的明暗度，产生凹凸不平的几何纹理</li>
<li>$F$ 的偏导数的计算，可以用中心差分实现</li>
<li>几何纹理函数定义可以用统一的图案纹理记录<ul>
<li>图案中较暗的颜色对应较小 $F$ 值</li>
<li>较亮的颜色对应较大 $F$ 值</li>
<li>把各象素的值一个二维数组记录下来</li>
</ul>
</li>
<li>在实际操作中直接给每个点新的法向即可（即上述说的记录）</li>
</ul>
<h1 id="parallax-mapping-amp-relief-mapping"><a href="#parallax-mapping-amp-relief-mapping" class="headerlink" title="parallax mapping &amp; relief mapping"></a>parallax mapping &amp; relief mapping</h1><h2 id="parallax-mapping"><a href="#parallax-mapping" class="headerlink" title="parallax mapping"></a>parallax mapping</h2><ul>
<li><strong>视差贴图</strong></li>
<li>普通纹理映射存在的问题：<strong>立体感不强</strong><ul>
<li>原因是因为之前的纹理并没有考虑实际场景中的物体内容</li>
<li>在视角变化下，实际看到的纹理内容会有变化<ul>
<li>实际看到的是 $T_{ideal}$ 而不是 $T$</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="09/parallax-mapping-01.png" style="zoom:50%;" />

<ul>
<li>视差贴图的纹理与<strong>内容相关</strong>，估计&#x2F;计算真正的纹理位置</li>
<li>Kaneko (2001)<ul>
<li>take an educated guess of what should be seen in a pixel by examining the height of what was found to be visible<ul>
<li>在高度场（height field）中检测像素的可见性</li>
</ul>
</li>
<li>Height field texture can be stored in unused color channel (alpha)<ul>
<li>将高度场信息保存在透明度通道</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><ul>
<li>直接给定一个 offset​（箭头表示视线）</li>
</ul>
<p>$$<br>P_{adj}&#x3D;P+\dfrac{h\cdot v_{xy}}{v_z}&#x3D;p+h\tan\theta<br>$$</p>
<ul>
<li>$v_z,v_{xy}$ 视线的偏移量</li>
</ul>
<img src="09/parallax-mapping-02.png" style="zoom:50%;" />

<ul>
<li>不准确<ul>
<li>尤其是浅视角（Shallow viewing angle）的时候，$v_z$ 很小，偏移量极大</li>
</ul>
</li>
</ul>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><ul>
<li>offset-limited，对 offset 进行限制没最多让其为 h<ul>
<li>对 $v_{xy}$ 进行归一化（0-1）</li>
</ul>
</li>
</ul>
<p>$$<br>P_{adj}&#x3D;P+h\cdot v_{xy}<br>$$</p>
<img src="09/parallax-mapping-03.png" style="zoom: 80%;" />



<ul>
<li>纹理内容 $\rightarrow$ 高度场 $\rightarrow$ 新的纹理坐标</li>
</ul>
<h2 id="同类技术的多种名称"><a href="#同类技术的多种名称" class="headerlink" title="同类技术的多种名称"></a>同类技术的多种名称</h2><ul>
<li>Independently discovered under different names<ul>
<li>parallax occlusion mapping</li>
<li>relief mapping</li>
<li>steep parallax mapping</li>
<li>inverse displacement mapping</li>
</ul>
</li>
<li>改进的方向：<strong>快速</strong>、<strong>效果</strong></li>
</ul>
<h2 id="Relief-Texture-Mapping"><a href="#Relief-Texture-Mapping" class="headerlink" title="Relief Texture Mapping"></a>Relief Texture Mapping</h2><ul>
<li>纹理 $\rightarrow$ 提炼出深度图作为高度场信息</li>
<li>如果视线和高度场只有一个交点，通过二分的方式进行查找交点，从而找到正确的纹理坐标</li>
</ul>
<p><img src="/09/relief-texture-mapping.png"></p>
<ul>
<li>如果交点不止一个怎么办？<ul>
<li>从外界开始步进探测视线与高度场的第一个交点（粗糙查找）</li>
<li>步进找到粗糙的位置之后，进行二分检测（精确）</li>
<li>32 步一定能找到</li>
</ul>
</li>
</ul>
<p><img src="/09/relief-texture-mapping-03.png"></p>
<p><img src="/09/relief-texture-mapping-02.jpg"></p>
<h2 id="阴影计算"><a href="#阴影计算" class="headerlink" title="阴影计算"></a>阴影计算</h2><ul>
<li>在找到位置之后，直接计算光照</li>
<li>在找纹理位置的同时就已经解决了阴影的问题</li>
</ul>
<p><img src="/09/relief-texture-mapping-04.png"></p>
<h2 id="更加复杂的纹理"><a href="#更加复杂的纹理" class="headerlink" title="更加复杂的纹理"></a>更加复杂的纹理</h2><ul>
<li>Relief mapping of non-height-field surface details<ul>
<li>Fabio Policarpo, Manuel M. Oliveira</li>
</ul>
</li>
<li>多层次高度场</li>
</ul>
<p><img src="/09/relief-texture-mapping-05.png"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>遵照物理模型的自然现象模拟</li>
<li>夜空光照</li>
<li>不同时刻不同散射系数的天空光</li>
<li>天空体积云及光照</li>
<li>云状物及爆照效果</li>
<li>火焰</li>
<li>烟雾</li>
<li>间接阴影</li>
<li>复杂材质光照特性</li>
<li>焦散</li>
<li>半透明材质</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/20/CG/LS/09/" data-id="cl9lj7498004t64tz64pve832" data-title="计算机图形学.李胜.09.纹理映射" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/LS/08-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/06/CG/LS/08-1/" class="article-date">
  <time class="dt-published" datetime="2021-02-06T12:30:21.000Z" itemprop="datePublished">2021-02-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-LS/">CG.LS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/06/CG/LS/08-1/">计算机图形学.李胜.08.真实感绘制之光照明(2)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="整体光照明模型"><a href="#整体光照明模型" class="headerlink" title="整体光照明模型"></a>整体光照明模型</h1><ul>
<li>全局光照明 &#x2F; 整体光照明</li>
<li>还要考虑周围环境的光对物体表面的影响（<strong>间接光照</strong>）<ul>
<li>光亮平滑的物体会将环境中其它物体映象在表面上</li>
<li>透过透明物体可以看到其后的环境景象</li>
</ul>
</li>
<li>更精致的真实感图形的绘制还要考虑物体表面的<strong>细节纹理</strong>（纹理映射）</li>
</ul>
<h2 id="物体表面入射光的构成"><a href="#物体表面入射光的构成" class="headerlink" title="物体表面入射光的构成"></a>物体表面入射光的构成</h2><p>(1) 光源直接照射</p>
<p>(2) 其他物体的反射光</p>
<p>(3) 透射光</p>
<ul>
<li>局部光照明模型仅考虑了 (1)</li>
</ul>
<h2 id="整体光照明方程"><a href="#整体光照明方程" class="headerlink" title="整体光照明方程"></a>整体光照明方程</h2><ul>
<li>Whitted 模型</li>
</ul>
<p>$$<br>I_\lambda&#x3D;I_{l\lambda}+K_sC_{c\lambda}I_{s\lambda}+K_tC_{t\lambda}T_{t\lambda}<br>$$</p>
<ul>
<li>局部光照明 + 其他表面光的反射光 + 物体背面的透射光</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>辐射度类<ul>
<li>VPL：Virtual Point Light</li>
<li>辐射度方法</li>
</ul>
</li>
<li>光线跟踪类<ul>
<li>metropolis light</li>
<li>photon mapping</li>
<li>蒙特卡洛光线追踪</li>
</ul>
</li>
</ul>
<h2 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h2><ul>
<li>路径追踪<ul>
<li>狭义：蒙特卡洛光线跟踪</li>
<li>广义：光线跟踪</li>
</ul>
</li>
</ul>
<h1 id="初级光线跟踪法"><a href="#初级光线跟踪法" class="headerlink" title="初级光线跟踪法"></a>初级光线跟踪法</h1><ul>
<li>光线跟踪法<ul>
<li>1968，Apple A 研究隐藏面消除算法时[APPL68]，给出了光线跟踪算法的描述</li>
<li>1979，Kay 和 Greenberg 的研究考虑了光的折射[KAY79]</li>
<li>1980，Whitted 提出了第一个整体光照 Whitted模型[WHIT80]</li>
</ul>
</li>
<li>注意光线跟踪不走经典的 pipeline（不同于经典的绘制管线）</li>
<li>光的传播过程<ul>
<li>光源 $\rightarrow$ 物体表面 $\rightarrow$ 物体表面 $\rightarrow\dots\rightarrow$ 物体表面 $\rightarrow$ 人眼</li>
</ul>
</li>
<li>光线跟踪过程——光线传播的逆过程<ul>
<li><strong>逆过程</strong>：不从光源出发，而从视点出发</li>
<li>若从光源出发，光线进入人眼的概率<strong>极低</strong></li>
</ul>
</li>
</ul>
<p><img src="/08-1/ray-tracing.png"></p>
<ul>
<li>是一个递归的过程</li>
<li>列出方程，求解<ul>
<li>模拟解 $ \checkmark$</li>
<li>数值解 $\times$</li>
</ul>
</li>
</ul>
<h2 id="光线跟踪的关键问题"><a href="#光线跟踪的关键问题" class="headerlink" title="光线跟踪的关键问题"></a>光线跟踪的关键问题</h2><ul>
<li>光线与物体表面的<strong>求交</strong></li>
<li>逢交点考察<strong>反射</strong>和<strong>折射</strong></li>
<li>阴影测试线<ul>
<li>判断待计算点是否对光源可见</li>
</ul>
</li>
<li>终止条件<ul>
<li>虽然在理想情况下，光线可以在物体之间进行无限的反射和折射</li>
<li>但是在实际的算法进行过程中，我们不可能进行无穷的光线跟踪</li>
<li>因而需要给出一些跟踪的终止条件</li>
</ul>
</li>
</ul>
<h2 id="几种可行的终止条件"><a href="#几种可行的终止条件" class="headerlink" title="几种可行的终止条件"></a>几种可行的终止条件</h2><ul>
<li>该光线未碰到任何物体</li>
<li>该光线碰到了背景</li>
<li>光线在经过许多次反射和折射以后，就会产生衰减，光线对于视点的光强贡献很小<ul>
<li>小于某个设定值</li>
</ul>
</li>
<li>光线反射或折射次数即跟踪深度大于一定值</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li>从视点出发，对于视屏上的每一个象素点，从视点作一条到该象素点的射线，调用该算法函数就可以确定这个象素点的颜色</li>
<li>对所得的全部交点进行排序，确定可见点</li>
</ul>
<h2 id="Hall-模型"><a href="#Hall-模型" class="headerlink" title="Hall 模型"></a>Hall 模型</h2><p>$$<br>I&#x3D;I_{ed}+I_{ld}+I_{ls}+I_{tr}<br>$$</p>
<ul>
<li>环境起的漫反射光亮度 + 光源引起的漫反射光度 + 光源引起的面反射光亮度 + 光源引起的规则透射亮度</li>
<li>漫反射 + 透射高光</li>
<li>算法一些要点<ul>
<li>光强衰减：终止条件</li>
<li>反射 + 折射</li>
</ul>
</li>
</ul>
<h2 id="光线与物体表面求交"><a href="#光线与物体表面求交" class="headerlink" title="光线与物体表面求交"></a>光线与物体表面求交</h2><h3 id="分类求交"><a href="#分类求交" class="headerlink" title="分类求交"></a>分类求交</h3><ul>
<li>光线与平面求交</li>
<li>光线与球面求交</li>
<li>光线与圆柱面求交</li>
<li>光线与二次曲面求交</li>
<li>光线与参数曲面求交</li>
</ul>
<h2 id="光线跟踪算法的加速"><a href="#光线跟踪算法的加速" class="headerlink" title="光线跟踪算法的加速"></a>光线跟踪算法的加速</h2><ul>
<li>提高求交速度</li>
<li>减少求交次数<ul>
<li>减少无效求交</li>
</ul>
</li>
<li>减少光线条数<ul>
<li>下采样</li>
</ul>
</li>
<li>采用并行算法</li>
</ul>
<h2 id="减少求交次数"><a href="#减少求交次数" class="headerlink" title="减少求交次数"></a>减少求交次数</h2><h3 id="包围盒及层次结构"><a href="#包围盒及层次结构" class="headerlink" title="包围盒及层次结构"></a>包围盒及层次结构</h3><ul>
<li>树状结构</li>
<li>景物的分布情况，将相距较近的景物组成一组局部场景，相邻各组又组成更大的组，这样，将整个景物空间组织成树状的层次结构</li>
</ul>
<h3 id="三维-DDA-算法"><a href="#三维-DDA-算法" class="headerlink" title="三维 DDA 算法"></a>三维 DDA 算法</h3><ul>
<li>是一个增量算法<ul>
<li>在一个迭代算法中，每一步的 x、y 值是用前一步的值加上一个增量来获得</li>
</ul>
</li>
<li>基本思想<ul>
<li>将景物空间剖分为网络，由于空间的连贯性，被跟踪的光线从起始点出发，依次穿越它所经过的空间网格，直至第一个交点，这种方法称为空间剖分技术，可以利用这种空间相关性来加速光线跟踪</li>
</ul>
</li>
<li>三维 DDA 网格跨越过程，根据 d 空间八叉树剖分技术确定两组始面和终面，并得到最终终面，以此终面为下一个穿越立方格</li>
<li>算法对于稠密的场景，选取适当的空间剖分分辨率，可以使算法非常有效</li>
</ul>
<h3 id="空间八叉树剖分技术"><a href="#空间八叉树剖分技术" class="headerlink" title="空间八叉树剖分技术"></a>空间八叉树剖分技术</h3><ul>
<li>空间非均匀网格剖分算法</li>
<li>利用了空间连贯性</li>
</ul>
<h2 id="减少光线条数"><a href="#减少光线条数" class="headerlink" title="减少光线条数"></a>减少光线条数</h2><ul>
<li>随机采样：蒙特卡洛采样<ul>
<li>存在噪声</li>
<li>采样点越多，噪声越小</li>
</ul>
</li>
<li>神经网络</li>
</ul>
<h2 id="光线跟踪算法评价"><a href="#光线跟踪算法评价" class="headerlink" title="光线跟踪算法评价"></a>光线跟踪算法评价</h2><ul>
<li>实现<strong>全局光照明</strong>，易于实现光滑物体之间彼此反射的影响，因此显示效果<strong>十分逼真</strong></li>
<li>有<strong>消隐</strong>功能：采用光线跟踪方法，在显示的同时，自然完成消隐功能</li>
<li>有<strong>阴影</strong>效果：光线跟踪能完成阴影的生成和显示</li>
<li>该算法具有<strong>并行</strong>性质<ul>
<li>每条光线的处理过程相同，结果彼此独立，因此可以大并行处理的硬件上快速实现光线跟踪算法</li>
</ul>
</li>
<li>光线跟踪算法的缺点是<strong>计算量非常大</strong>，因此，显示速度极慢，随视点变化而重新计算</li>
</ul>
<h2 id="Glossy-reflection-amp-refraction"><a href="#Glossy-reflection-amp-refraction" class="headerlink" title="Glossy reflection &amp; refraction"></a>Glossy reflection &amp; refraction</h2><ul>
<li>带有光泽的反射与折射</li>
</ul>
<p><img src="/08-1/cone.png"></p>
<ul>
<li>控制圆锥顶角的大小，从而控制粗糙度（镜面高光&#x2F;漫反射）</li>
</ul>
<h2 id="Photon-Mapping"><a href="#Photon-Mapping" class="headerlink" title="Photon Mapping"></a>Photon Mapping</h2><ul>
<li>光子映射</li>
<li>对于透明物体的高光模拟的很好<ul>
<li>焦散（caustics）</li>
<li>焦散是指当光线穿过一个透明物体时，由于对象表面的不平整，使得光线折射并没有平行发生，出现漫折射，投影表面出现光子分散</li>
</ul>
</li>
</ul>
<h2 id="光线跟踪算法评价-1"><a href="#光线跟踪算法评价-1" class="headerlink" title="光线跟踪算法评价"></a>光线跟踪算法评价</h2><ul>
<li>较好地模拟了光在光滑物体表面之间的反射和折射现象</li>
<li>无法模拟光在景物之间<strong>漫反射</strong>引起的<strong>彩色渗透</strong>现象（多重漫反射效果）</li>
</ul>
<h1 id="初级辐射度算法"><a href="#初级辐射度算法" class="headerlink" title="初级辐射度算法"></a>初级辐射度算法</h1><ul>
<li>面对早期的光线跟踪算法只能处理光滑表面而产生的</li>
<li>1984，美国 Cornell 大学和日本广岛大学的学者分别将<strong>热辐射工程</strong>中的<strong>辐射度方法</strong>引入到计算机图形学中</li>
<li>辐射度方法<ul>
<li>将场景看作一个<strong>封闭的系统</strong>，<strong>能量多重反射</strong>，最终达到<strong>平衡</strong>状态。</li>
<li>根据<strong>能量守恒定律</strong>，计算出每一个表面上的能量</li>
<li>选定观察点，采用绘制算法计算出被观察点的颜色</li>
<li>与<strong>视点</strong>无关：广泛用于<strong>虚拟漫游</strong></li>
<li>主要问题：<strong>提高算法效率</strong></li>
</ul>
</li>
</ul>
<h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul>
<li>求解场景的辐射度积分方程<ul>
<li>数值解，利用Gauss-Siedel迭代，Southwell迭代</li>
</ul>
</li>
<li>景物表面网格剖分及其形状因子<ul>
<li>有限元方法，半立方体法</li>
</ul>
</li>
</ul>
<h2 id="基础理论原理"><a href="#基础理论原理" class="headerlink" title="基础理论原理"></a>基础理论原理</h2><h3 id="立体角"><a href="#立体角" class="headerlink" title="立体角"></a>立体角</h3><ul>
<li>$d\omega&#x3D;\dfrac{dS}{r^2}$</li>
</ul>
<img src="08-1/SolidAngle.png" style="zoom:50%;" />

<ul>
<li>$dA_2&#x3D;dS&#x3D;rd\theta\ast r\sin\theta d\psi$<ul>
<li>矩形近似，边长为弧长</li>
</ul>
</li>
<li>$d\omega&#x3D;\sin\theta d\theta d\psi$</li>
</ul>
<img src="08-1/SolidAngle2.png"/>

<ul>
<li>球的立体角：$4\pi$</li>
</ul>
<h3 id="光强度"><a href="#光强度" class="headerlink" title="光强度"></a>光强度</h3><ul>
<li>光通量：单位时间通过的光能<ul>
<li>单位：流明</li>
<li>图形学中往往讲瞬时，因此往往将光通量和光能混用</li>
</ul>
</li>
<li>为表征物体在某一方向上的发光情况，定义<strong>某方向</strong>上<strong>单位立体角</strong>内的<strong>光通量</strong>为该方向上的光强度，记为 $J$</li>
<li>$J&#x3D;\dfrac{dF}{d\omega}$</li>
</ul>
<h3 id="光亮度"><a href="#光亮度" class="headerlink" title="光亮度"></a>光亮度</h3><ul>
<li>将<span style="color:red;font-weight:bold">发光面元</span><strong>单位面积</strong>上向某方向辐射的光能称为光亮度，记为 $I$</li>
<li>$I&#x3D;\dfrac{J\cdot \cos i}{dS_i}&#x3D;\dfrac{dF\cdot\cos i}{dS_i\cdot d\omega}$<ul>
<li>这里 $i$ 是法向和辐射法向的夹角</li>
</ul>
</li>
<li>光亮度决定了人眼接收的光能的大小和色彩组成</li>
<li>光能接受面元所对应的立体角大小<ul>
<li>$dw’&#x3D;\dfrac{\cos\theta dA(x)}{r^2}$<ul>
<li>$A(x)$：面积</li>
<li>$\theta$：两个面的法向夹角</li>
<li>$r$：距离</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="辐射度算法的假设"><a href="#辐射度算法的假设" class="headerlink" title="辐射度算法的假设"></a>辐射度算法的假设</h3><ul>
<li>假设一封闭环境中，景物表面均为理想漫反射表面<ul>
<li>景物表面上，每一点向周围各方向辐射的<strong>光亮度</strong>是相同的</li>
<li>表面各点处的光亮度只与位置有关，与辐射的方向无关</li>
</ul>
</li>
<li>假设 $dP$ 为表面某一点处<strong>单位面积</strong>上朝<strong>某辐射方向</strong>发出的<strong>光通量</strong>，则与该点处沿同一方向的光亮度 $I$ 的关系为<ul>
<li>$dP&#x3D;I\cos\theta d\omega$</li>
<li>其中 $\theta$ 为该点处的法向与辐射方向之间的夹角</li>
<li>Lambert 漫反射模型</li>
</ul>
</li>
<li>则该点处单位面积面元向其四周半空间辐射的总能量（总辐射度 $B$）</li>
</ul>
<p>$$<br>B&#x3D;\int_{\Omega}dP&#x3D;\int_{\Omega}I\cos\theta d\omega&#x3D;I\int_0^{2\pi}\int_0^{\dfrac{\pi}{2}}\cos\theta\sin\theta d\theta d\psi&#x3D;I\pi<br>$$</p>
<ul>
<li>理想漫反射表面每一点处的<strong>辐射度值</strong>与<strong>光亮度值</strong>之比为一常数因子，因而表面各点的光亮度计算可通过求解整个场景的辐射度方程而得到</li>
<li>假设周围环境为一封闭系统，则表面上每一点处微面元向周围环境辐射的能量由它自身所具有的辐射光能和它接受来自环境中其他景物表面向该点辐射的光能组成<ul>
<li>周围环境入射到微面元上的光能为 $H(x)$</li>
<li>该表面在此处的漫反射率 $\rho(x)$</li>
<li>则微面元对环境入射光能的反射而产生的那部分辐射光能为 $\rho(x)H(x)$</li>
<li>由此，此点处的辐射度满足 $B(x)dA(x)&#x3D;E(x)dA(x)+\rho(x)H(x)$<ul>
<li>$dA(x)$ 为微面元 $dS(x)$ 的面积</li>
<li>$E(x)$ 为该表面在 $x$ 点处的<strong>自身辐射度</strong><ul>
<li>若该表面为漫反射光源，$E(x)&gt;0$ ，否则 $E(x)&#x3D;0$</li>
</ul>
</li>
<li>自发光 + 周围照射</li>
</ul>
</li>
</ul>
</li>
<li>可以对每个面元离散化，使用矩阵求解</li>
</ul>
<p>$$<br>\begin{bmatrix}<br>B_1\<br>B_2\<br>\vdots\<br>B_n<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>E_1\<br>E_2\<br>\vdots\<br>E_n<br>\end{bmatrix}<br>+<br>\begin{bmatrix}<br>&amp;\cdots\<br>\rho_iF_{i1}&amp;\cdots&amp;\rho_iF_{in}\<br>&amp;\cdots\<br>\end{bmatrix}<br>\begin{bmatrix}<br>B_1\<br>B_2\<br>\vdots\<br>B_n<br>\end{bmatrix}<br>$$</p>
<ul>
<li>辐射度算法：色彩柔和（基于漫反射）</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>Fluoresence（荧光效果）</li>
<li>海面模拟</li>
<li>折射：单层 &#x2F; 双层<ul>
<li>入射、出射的折射</li>
</ul>
</li>
</ul>
<p><img src="/08-1/refraction.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/06/CG/LS/08-1/" data-id="cl9lj7496004f64tze4ragtg9" data-title="计算机图形学.李胜.08.真实感绘制之光照明(2)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/LS/08" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/05/CG/LS/08/" class="article-date">
  <time class="dt-published" datetime="2021-02-05T03:50:24.000Z" itemprop="datePublished">2021-02-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-LS/">CG.LS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/05/CG/LS/08/">计算机图形学.李胜.08.真实感绘制之光照明(1)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="真实感绘制流程"><a href="#真实感绘制流程" class="headerlink" title="真实感绘制流程"></a>真实感绘制流程</h1><ul>
<li>动机：图形真实感的需求</li>
<li>真实感：产生幻觉（illusion）</li>
<li>基于用户评估，没有一个确定的标准</li>
<li>例子：树皮<ul>
<li>光线：产生阴影</li>
<li>边界：粗糙的感觉</li>
</ul>
</li>
</ul>
<h2 id="光照明模型发展历史"><a href="#光照明模型发展历史" class="headerlink" title="光照明模型发展历史"></a>光照明模型发展历史</h2><ul>
<li>早期光照明模型<ul>
<li>基于<strong>经验</strong></li>
<li>只能反映<strong>光源直接照射</strong>的情况</li>
</ul>
</li>
<li>比较精确的模型<ul>
<li>模拟物体之间光的相互作用</li>
<li><strong>间接光照</strong></li>
</ul>
</li>
<li>更精确的模型<ul>
<li>模拟物体自身的光照相互作用</li>
<li>模拟光源至物体表面以及物体表面至视点之间光的传播</li>
<li>光传播的介质（雾）、物体表面形态、视点位置变化、体数据</li>
</ul>
</li>
<li>2005 siggraph achievement：Nishita 东京大学<ul>
<li>截止：光在大气中传播的模拟</li>
<li>participating media：参与介质</li>
</ul>
</li>
</ul>
<h2 id="真实感图形绘制的四个步骤"><a href="#真实感图形绘制的四个步骤" class="headerlink" title="真实感图形绘制的四个步骤"></a>真实感图形绘制的四个步骤</h2><h3 id="3D流水线"><a href="#3D流水线" class="headerlink" title="3D流水线"></a>3D流水线</h3><ul>
<li>三维形体 $\rightarrow$ 变换 $\rightarrow$ 明暗处理（光照）$\rightarrow$ 光栅化 $\rightarrow$ 真实感图像</li>
</ul>
<h3 id="1-几何建模"><a href="#1-几何建模" class="headerlink" title="(1) 几何建模"></a>(1) 几何建模</h3><ul>
<li>用数学方法建立所需三维场景的几何描述</li>
<li>通常是由三维造型系统完成</li>
<li>场景的几何描述直接影响了图形的复杂性和图形绘制的计算开销</li>
</ul>
<h3 id="2-投影"><a href="#2-投影" class="headerlink" title="(2) 投影"></a>(2) 投影</h3><ul>
<li>将三维几何描述转换为二维透视图</li>
<li>通过对场景的透视变换来完成</li>
</ul>
<h3 id="3-确定形状"><a href="#3-确定形状" class="headerlink" title="(3) 确定形状"></a>(3) 确定形状</h3><ul>
<li>隐藏面消除</li>
<li>确定场景中的所有可见面</li>
<li>将视野之外或被其它物体遮挡的不可见面消去</li>
</ul>
<h3 id="4-确定色彩"><a href="#4-确定色彩" class="headerlink" title="(4) 确定色彩"></a>(4) 确定色彩</h3><ul>
<li>计算场景中可见面的颜色</li>
<li>根据基于光学物理的光照明模型计算可见面投射到观察者眼中的光亮度大小和色彩组成，并将它转换成适合图形设备的颜色值，从而确定投影画面上每一象素的颜色（或者与纹理相结合），最终生成图形</li>
</ul>
<h1 id="简单光照明模型"><a href="#简单光照明模型" class="headerlink" title="简单光照明模型"></a>简单光照明模型</h1><h2 id="简单光照明模型的假设"><a href="#简单光照明模型的假设" class="headerlink" title="简单光照明模型的假设"></a>简单光照明模型的假设</h2><ul>
<li>仅考虑光源照射在物体表面产生的<strong>反射光</strong></li>
<li>通常假定物体表面是<strong>光滑</strong>的且由<strong>理想材料</strong>构成，只考虑<strong>被照明物体的几何</strong>对反射和透射光的影响</li>
<li>忽略光源的颜色和几何形状（<strong>点光源白光照明</strong>）</li>
<li>可以模拟出<strong>不透明物体</strong>表面的明暗过渡，具有一定的真实感。 但真实感较差，阴影区域边界尖锐</li>
</ul>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li>反射<ul>
<li>理想漫反射（diffuse reflection）</li>
<li>镜面高光（specular highlight）</li>
</ul>
</li>
<li>环境光<ul>
<li>ambient lighting</li>
</ul>
</li>
<li>直接光：直接反射&#x2F;折射</li>
<li>间接光：间接反射&#x2F;折射<ul>
<li>简单光照明不考虑间接光</li>
</ul>
</li>
<li><strong>以下提到的方向向量均为单位向量</strong></li>
</ul>
<h2 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h2><ul>
<li>光线在场景中经过复杂传播之后，形成的弥漫于整个空间的光线</li>
<li><strong>事实上是不存在的</strong><ul>
<li>由于难以模拟，假想出来的</li>
</ul>
</li>
<li>$I_e&#x3D;K_aI_a$<ul>
<li>物体表面呈现的亮度 &#x3D; 环境光反射系数 x 环境光亮度</li>
</ul>
</li>
</ul>
<h2 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h2><ul>
<li>点光源<ul>
<li>向周围辐射等强度的光</li>
</ul>
</li>
<li>漫反射<ul>
<li>粗糙、无光泽物体（如粉笔）表面对光的反射</li>
</ul>
</li>
<li>$I_d&#x3D;I_pK_d\cos\theta&#x3D;I_pK_d(\vec{L}\cdot\vec{N})$<ul>
<li>物体表面呈现的亮度  &#x3D; 点光源的亮度 x 漫反射系数 x $\cos$(入射角)</li>
</ul>
</li>
</ul>
<p><img src="/08/diffuse-reflection.png"></p>
<h2 id="镜面反射与-Phong-模型"><a href="#镜面反射与-Phong-模型" class="headerlink" title="镜面反射与 Phong 模型"></a>镜面反射与 Phong 模型</h2><ul>
<li>光滑物体表面，高光效果</li>
</ul>
<h3 id="理想镜面反射"><a href="#理想镜面反射" class="headerlink" title="理想镜面反射"></a>理想镜面反射</h3><ul>
<li>难以捕获：要求视点恰好在反射光 R 的方向上</li>
<li>$\vec{R}&#x3D;2(\vec{L}\cdot\vec{N})\vec{N}-\vec{L}$</li>
<li>$\vec{R}+\vec{L}&#x3D;(2|\vec{R}|\cos\theta)\vec{N}&#x3D;(2\cos\theta)\vec{N}&#x3D;2(\vec{N}\cdot\vec{L})\vec{N}$</li>
</ul>
<p><img src="/08/ideal-specular-highlight.png"></p>
<h3 id="非理想镜面反射"><a href="#非理想镜面反射" class="headerlink" title="非理想镜面反射"></a>非理想镜面反射</h3><ul>
<li>锥形区域：中心轴为 R，圆锥角 $2\beta$<ul>
<li>圆锥内部：光强由中心向四周递减</li>
<li>圆锥外部：光强为 0</li>
</ul>
</li>
</ul>
<p><img src="/08/specular-highlight.png"></p>
<ul>
<li>Phong 模型<ul>
<li>$I_s&#x3D;I_pK_s(\cos\alpha)^n&#x3D;I_pK_s(\vec{V}\cdot\vec{R})^n$</li>
<li>n 为镜面反射系数<ul>
<li>n 越大，高光越集中</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/08/phong-n.png"></p>
<ul>
<li>定义 $\vec{H_0}&#x3D;\dfrac{1}{2}(\vec{L}+\vec{V}),\vec{H}&#x3D;\dfrac{\vec{H_0}}{\Vert\vec{H_0}\Vert}&#x3D;\dfrac{\vec{H_0}}{\cos\theta}$<ul>
<li>可以用 $\vec{H}\cdot\vec{N}$ 代替 $\vec{V}\cdot\vec{R}$</li>
<li>趋势是一致的<ul>
<li>$\vec{H}\cdot\vec{N}&#x3D;\dfrac{\cos\theta+\cos(\theta+\alpha)}{2\cos\theta}$<ul>
<li>$\alpha\in[0,\dfrac{\pi}{2}]\to[1,1-\tan\theta]$</li>
</ul>
</li>
<li>$\vec{V}\cdot\vec{R}&#x3D;\cos\alpha$<ul>
<li>$\alpha\in[0,\dfrac{\pi}{2}]\to[1,0]$</li>
</ul>
</li>
<li>$&lt;\vec{H},\vec{N}&gt;&#x3D;\dfrac{&lt;\vec{V},\vec{R}&gt;}{2}$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="光线的衰减"><a href="#光线的衰减" class="headerlink" title="光线的衰减"></a>光线的衰减</h2><h3 id="1-光在光源到物体表面过程中的衰减"><a href="#1-光在光源到物体表面过程中的衰减" class="headerlink" title="(1) 光在光源到物体表面过程中的衰减"></a>(1) 光在光源到物体表面过程中的衰减</h3><ul>
<li>$f(d)&#x3D;\min(\dfrac{1}{c_0+c_1d+c_2d^2},1)$<ul>
<li>经验函数</li>
</ul>
</li>
</ul>
<h3 id="2-光在物体表面到人眼过程中的衰减"><a href="#2-光在物体表面到人眼过程中的衰减" class="headerlink" title="(2) 光在物体表面到人眼过程中的衰减"></a>(2) 光在物体表面到人眼过程中的衰减</h3><ul>
<li>Depth Cueing 技术（深度暗示技术）<ul>
<li>使用深度值代替表示距离（几乎等价）</li>
</ul>
</li>
<li>线性插值<ul>
<li>front&#x2F;back：前&#x2F;后参考面，并且赋予比例因子 $S_f,S_b\in[0,1]$</li>
</ul>
</li>
</ul>
<p>$$<br>S_0&#x3D;<br>\begin{cases}<br>S_b,&amp;Z_0&lt;Z_b\<br>S_b+\dfrac{Z_0-Z_b}{Z_f-Z_b}(S_f-S_b),&amp;Z_0\in[Z_b,Z_f],\<br>S_f,&amp;Z_0&gt;Z_f<br>\end{cases}<br>$$</p>
<p><img src="/08/depth-cueing.png"></p>
<ul>
<li>$I’&#x3D;S_0I+(1-S_0)I_{dc}$<ul>
<li>$I_{dc}$ 为融合亮度，是用户指定的</li>
</ul>
</li>
<li>特别的：$S_f&#x3D;1,S_b&#x3D;0,I_{dc}&#x3D;0$</li>
</ul>
<p>$$<br>S_0&#x3D;<br>\begin{cases}<br>0,&amp;Z_0&lt;Z_b\<br>\dfrac{Z_0-Z_b}{Z_f-Z_b},&amp;Z_0\in[Z_b,Z_f],\<br>1,&amp;Z_0&gt;Z_f<br>\end{cases}<br>$$</p>
<p>$$<br>I’&#x3D;<br>\begin{cases}<br>0,&amp;Z_0&lt;Z_b\<br>\dfrac{Z_0-Z_b}{Z_f-Z_b}I,&amp;Z_0\in[Z_b,Z_f],\<br>I,&amp;Z_0&gt;Z_f<br>\end{cases}<br>$$</p>
<ul>
<li>衰减为 0 $\rightarrow$ 部分衰减 $\rightarrow$ 不衰减<ul>
<li>真实感较好</li>
</ul>
</li>
</ul>
<h2 id="简单光照明模型-1"><a href="#简单光照明模型-1" class="headerlink" title="简单光照明模型"></a>简单光照明模型</h2><ul>
<li>$I&#x3D;I_aK_a+f(d)I_p[K_d(\vec{L}\cdot \vec{N})+K_s(\vec{V}\cdot\vec{R})^n]$</li>
<li>环境光是不衰减的</li>
</ul>
<h2 id="彩色"><a href="#彩色" class="headerlink" title="彩色"></a>彩色</h2><ul>
<li>选择合适的颜色模型：RGB模型</li>
<li>为颜色模型中的每一种基色建立光照明方程</li>
<li>$I&#x3D;I_{a\lambda}K_{a\lambda}+f(d)I_{p\lambda}[K_{d\lambda}(\vec{L}\cdot \vec{N})+K_{s\lambda}(\vec{V}\cdot\vec{R})^n]$<ul>
<li>$\lambda\in{R,G,B}$</li>
</ul>
</li>
</ul>
<h2 id="多光源"><a href="#多光源" class="headerlink" title="多光源"></a>多光源</h2><ul>
<li>为每个光源建立光照明模型<ul>
<li>注意环境光只有一个</li>
</ul>
</li>
<li>如下，$m$ 个光源​</li>
</ul>
<p>$$<br>I&#x3D;I_{a\lambda}K_{a\lambda}+\sum_{i&#x3D;1}^{m}{f(d_i)I_{p_i\lambda}[K_{d_i\lambda}(\vec{L_i}\cdot \vec{N})+K_{s_i\lambda}(\vec{V}\cdot\vec{R})^n]}<br>$$</p>
<h2 id="多边形绘制着色方法"><a href="#多边形绘制着色方法" class="headerlink" title="多边形绘制着色方法"></a>多边形绘制着色方法</h2><ul>
<li>shading</li>
<li>计算完<strong>顶点</strong>信息之后如何对<strong>内部的点</strong>上色<ul>
<li>统一着色（constant shading）</li>
<li>均匀着色（flat shading）</li>
<li>光滑着色 (smooth shading)<ul>
<li>Gouraud着色方法 (Gouraud shading)</li>
<li>Phong着色方法 (Phong shading)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="统一着色"><a href="#统一着色" class="headerlink" title="统一着色"></a>统一着色</h3><ul>
<li>constant shading</li>
<li>每个<strong>物体</strong>着同一种颜色</li>
</ul>
<h3 id="均匀着色"><a href="#均匀着色" class="headerlink" title="均匀着色"></a>均匀着色</h3><ul>
<li>flat shading</li>
<li>每个<strong>表面</strong>着同一种颜色</li>
<li>着色方法<ul>
<li>任取多边形上一点，利用光照明方程计算出它的颜色</li>
<li>用这个颜色填充整个多边形</li>
</ul>
</li>
<li>适用情况：<strong>同一表面差别不大</strong><ul>
<li>光源在无穷远处</li>
<li>视点在无穷远处</li>
<li>多边形是物体表面的精确表示</li>
</ul>
</li>
<li>优点<ul>
<li>每个多边形只需计算一次光照明方程，<strong>速度快</strong></li>
</ul>
</li>
<li>缺点<ul>
<li>相邻多边形颜色<strong>过渡十分不光滑</strong></li>
</ul>
</li>
</ul>
<h3 id="光滑着色"><a href="#光滑着色" class="headerlink" title="光滑着色"></a>光滑着色</h3><ul>
<li>方法：<strong>插值</strong><ul>
<li>颜色插值 $\rightarrow$ Gouraud 着色方法</li>
<li>法矢量插值 $\rightarrow$ Phong 着色方法</li>
</ul>
</li>
</ul>
<h4 id="Gouraud-着色方法"><a href="#Gouraud-着色方法" class="headerlink" title="Gouraud 着色方法"></a>Gouraud 着色方法</h4><ul>
<li>面法向量 $\rightarrow$ 顶点法向量 $\rightarrow$ 计算颜色 $\rightarrow$ 颜色插值</li>
</ul>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li><p>计算多边形的单位法矢量（<strong>面法向量</strong>）</p>
<ul>
<li>面内两个向量叉乘</li>
</ul>
</li>
<li><p>计算多边形顶点的单位法矢量（<strong>顶点法向量</strong>）</p>
<ul>
<li>拟合</li>
<li>简单的拟合方式：使用 1 邻域的面法向量的均值<ul>
<li>1 邻域：直接相邻的面</li>
<li>2 邻域：直接相邻的面以及和这些面直接相邻的面</li>
</ul>
</li>
</ul>
</li>
<li><p>利用光照明方程计算顶点颜色</p>
</li>
<li><p>对多边形顶点颜色进行<strong>双线性插值</strong>，获得多边形内部各点的颜色</p>
<ul>
<li>如下图：需要求得点 $P$ 的颜色<ul>
<li>第三步求出了顶点 $P_1,P_2,P_3$ 的颜色</li>
<li>通过<strong>线性插值</strong>求出点 $A,B$ 的颜色</li>
<li>对 $A,B$ 进行线性插值求得点 $P$ 的颜色</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/08/bilinear-interpolation.png"><br>$$<br>I_a&#x3D;I_1\dfrac{y_a-y_2}{y_1-y_2}+I_2\dfrac{y_1-y_a}{y_1-y_2}\<br>I_b&#x3D;I_1\dfrac{y_a-y_3}{y_1-y_3}+I_2\dfrac{y_1-y_a}{y_1-y_3}\<br>I_p&#x3D;I_a\dfrac{x_p-x_a}{x_b-x_a}+I_b\dfrac{x_p-x_a}{x_b-x_a}<br>$$</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>不能正确模拟高光</li>
</ul>
<h4 id="Phong-着色方法"><a href="#Phong-着色方法" class="headerlink" title="Phong 着色方法"></a>Phong 着色方法</h4><ul>
<li>面法向量 $\rightarrow$ 顶点法向量 $\rightarrow$法向量插值 $\rightarrow$  计算颜色</li>
</ul>
<h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li>计算多边形单位法矢量</li>
<li>计算多边形顶点单位法矢量</li>
<li>对多边形顶点法矢量进行双线性插值，获得内部各点的法矢量</li>
</ul>
<p><img src="/08/normal-bilinear-interpolation.png"></p>
<ul>
<li>利用光照明方程计算多边形内部各点颜色</li>
</ul>
<p><img src="/08/contrast-flat-gouraud-phong.png"></p>
<h4 id="方法对比"><a href="#方法对比" class="headerlink" title="方法对比"></a>方法对比</h4><ul>
<li>计算颜色时期的不同：插值总是在<strong>光栅化</strong>阶段（rasterization）<ul>
<li>Gouraud：vertex shader</li>
<li>Phong：fragment shader</li>
</ul>
</li>
<li>高光<ul>
<li>Gouraud：缺失</li>
<li>Phong：还不错</li>
</ul>
</li>
</ul>
<img src="08/highlight-gouraud-phong.png" style="zoom: 25%;" />



<h4 id="插值方法存在的问题"><a href="#插值方法存在的问题" class="headerlink" title="插值方法存在的问题"></a>插值方法存在的问题</h4><ul>
<li>不光滑的物体轮廓<ul>
<li>模型离散化道中的</li>
<li>解决方案：使用法相贴图，将需要求的法向值给定，这样就无需插值拟合</li>
</ul>
</li>
<li>透视变形<ul>
<li>我们的插值是在投影平面上进行的，实际上应该在三维空间中插值</li>
<li>这样在趋势上会有所差别</li>
</ul>
</li>
</ul>
<img src="08/interpolation-projection.png" style="zoom:50%;" />

<ul>
<li>方向依赖性<ul>
<li>双线性插值的方向依赖性</li>
<li>早期的问题，现在已经能够解决</li>
</ul>
</li>
</ul>
<img src="08/interpolation-direction.png" style="zoom:50%;" />

<ul>
<li>公共顶点颜色不连续<ul>
<li>下图的绿点<ul>
<li>对于左上角的小矩形来说，是顶点（计算产生）</li>
<li>对于右上角的的矩形来说，不是顶点（插值产生）</li>
</ul>
</li>
<li>因此其周围的点颜色可能不连续</li>
</ul>
</li>
</ul>
<img src="08/interpolation-continue.png" style="zoom:50%;" />

<ul>
<li>顶点方向不具有代表性<ul>
<li>如果使用定顶点进行插值，区分不出来两种类型的面（颜色都一样）</li>
<li>解决方案：<strong>将面进行更加细致的剖分</strong>，这样就可以减少这种情况的发生</li>
</ul>
</li>
</ul>
<img src="08/interpolation-point-normal.png" style="zoom:50%;" />



<h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><ul>
<li>阴影<ul>
<li>光源不能直接照射的区域</li>
<li>对光源来说，不可见的面（隐藏面）</li>
</ul>
</li>
<li>考虑阴影的光照明方程</li>
</ul>
<p>$$<br>I&#x3D;I_{a\lambda}K_{a\lambda}+\sum_{i&#x3D;1}^{m}{S_if(d_i)I_{p_i\lambda}[K_{d_i\lambda}(\vec{L_i}\cdot \vec{N})+K_{s_i\lambda}(\vec{V}\cdot\vec{R})^n]}\<br>$$</p>
<p>$$<br>S_i&#x3D;<br>\begin{cases}<br>0,&amp;位于第i个光源的阴影中\<br>1,&amp;else<br>\end{cases}<br>$$</p>
<ul>
<li>简单：点光源</li>
<li>复杂：体光源、面光源</li>
</ul>
<h3 id="基于-GPU-硬件的-shadow-map-算法"><a href="#基于-GPU-硬件的-shadow-map-算法" class="headerlink" title="基于 GPU 硬件的 shadow map 算法"></a>基于 GPU 硬件的 shadow map 算法</h3><ul>
<li><strong>像素</strong>级别精确的阴影算法</li>
<li><strong>点光源</strong></li>
<li>利用 z-buffer 消隐<ul>
<li>将物体变换到光源坐标系中，消隐，记录下可见的最小深度值（z-buffer）</li>
<li>将物体变换到光源坐标系中，计算深度，如果大于记录值则不可见，否则可见（只可能<strong>等于</strong>）</li>
</ul>
</li>
</ul>
<h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul>
<li>将所有景物变换到光源坐标系中，利用 z 缓冲器算法按光线方向对景物进行消隐，把那些距光源最近的物体表面上点的深度值保存在阴影缓冲器中</li>
<li>利用Z缓冲器算法按视线方向对景物进行消隐，将得到的每一个可见点变换到光源坐标系中，若<br>  它在光源坐标系中的深度值比阴影缓冲器中相应单元的值小，则说明该可见点位于阴影中，否则不是</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>算法简单，易于实现</li>
<li>已经可以在GPU硬件上直接实现</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>每个光源需要一个阴影缓冲器</li>
<li>在阴影的边界上容易形成锯齿效果<ul>
<li>量化误差（算法精度、z-buffer大小、深度值精度）</li>
</ul>
</li>
</ul>
<h3 id="RSM：Reflective-Shadow-Map"><a href="#RSM：Reflective-Shadow-Map" class="headerlink" title="RSM：Reflective Shadow Map"></a>RSM：Reflective Shadow Map</h3><ul>
<li>shadow map 第一次渲染只生成了一张深度图，太浪费（代价太大）</li>
<li>第一次渲染的时候同时生成一些其他信息<ul>
<li>光源直接照到部分的深度 $\rightarrow$ 光源直接照到部分的深度、颜色、法向</li>
</ul>
</li>
<li>第二次绘制利用第一次绘制生成的信息可以计算<strong>单次间接光照</strong></li>
</ul>
<h3 id="阴影反混淆"><a href="#阴影反混淆" class="headerlink" title="阴影反混淆"></a>阴影反混淆</h3><ul>
<li>边界锯齿 $\rightarrow$ 平滑过渡<ul>
<li>锯齿的光栅化过程产生的</li>
<li>走样</li>
</ul>
</li>
<li>反走样<ul>
<li>时域：连续帧中，远方亮点的忽隐忽现（flick）</li>
<li>空域：边界锯齿</li>
</ul>
</li>
<li>反走样方法<ul>
<li>SSAA：Super Sampling  Anti-Aliasing<ul>
<li>超采样反走样</li>
<li>每个采样点进行进一步的<strong>细分</strong><ul>
<li>x2，x3，x4 $\rightarrow$ 每个采样点细分为为 4，9，16个采样点</li>
</ul>
</li>
</ul>
</li>
<li>MSAA：Multi-Sampling AA<ul>
<li>多采样反走样</li>
<li>SSAA 的计算量非常大，SSAA 的改进</li>
<li>寻找出物体边缘部分的像素，然后对它们进行超采样处理<ul>
<li>这样忽略掉了不会产生锯齿的内部像素，减少了计算量</li>
</ul>
</li>
<li>光栅化而言，MSAA 跟 SSAA 差不多，覆盖和遮挡信息在更大的分辨率上进行的</li>
<li>着色的时候，通过计算原始的一个采样点细分出来的不同采样点的颜色混合得到原始采样点的颜色</li>
</ul>
</li>
<li>CSAA：Coverage Sampling AA<ul>
<li>覆盖取样抗锯齿</li>
</ul>
</li>
<li>TAA<ul>
<li>temporal AA</li>
</ul>
</li>
</ul>
</li>
<li>方法对比<ul>
<li>SSAA 中，每个取样表示了着色颜色、储存的颜色&#x2F;Z&#x2F;模板、和覆盖，本质上增加了渲染到一个过大的缓存并向下取样</li>
<li>MSAA 通过从储存的颜色和覆盖中分离出着色取样，减少了这项操作的着色器开销；这允许应用程序使用抗锯齿来处理更少的着色取样同时维持同样质量的颜色&#x2F;Z&#x2F;模板和覆盖取样</li>
<li>CSAA通过从颜色&#x2F;Z&#x2F;模板分离出覆盖进一步优化了这个过程，从而减少带宽和存储开销</li>
</ul>
</li>
<li>反走样方法<ul>
<li>光栅化图形显示必然的问题问题</li>
<li>trade off（时间与质量）</li>
</ul>
</li>
</ul>
<h3 id="基于GPU硬件-的-Shadow-Volume"><a href="#基于GPU硬件-的-Shadow-Volume" class="headerlink" title="基于GPU硬件 的 Shadow Volume"></a>基于GPU硬件 的 Shadow Volume</h3><ul>
<li><strong>几何</strong>级别精确的阴影算法<ul>
<li>没有阴影锯齿问题</li>
</ul>
</li>
<li>光源 $\rightarrow$ <strong>物体轮廓</strong><ul>
<li>光源和轮廓形成的锥体向远处拉伸，形成<strong>阴影体</strong></li>
</ul>
</li>
<li>关键问题<ul>
<li>找出轮廓</li>
<li>如何判断物体是否处于阴影中</li>
</ul>
</li>
</ul>
<h4 id="如何判断物体处于阴影体中"><a href="#如何判断物体处于阴影体中" class="headerlink" title="如何判断物体处于阴影体中"></a>如何判断物体处于阴影体中</h4><ul>
<li>直接对所有的几何体和阴影体求交、求交线<ul>
<li>复杂度很高</li>
</ul>
</li>
<li>利用 buffer</li>
</ul>
<h5 id="累积缓冲"><a href="#累积缓冲" class="headerlink" title="累积缓冲"></a>累积缓冲</h5><h6 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h6><img src="08/accumulative.png" style="zoom:80%;" />

<ul>
<li>光源和物体形成射线</li>
<li>视点和需要求的点形成<strong>线段</strong>（方向为视点到待求的点），在线段上求累积值</li>
<li>正向面 +1，负向面 -1<ul>
<li>朝向视点的面&#x2F;远离视点的面</li>
</ul>
</li>
<li>求累计值<ul>
<li>若大于 0，则处于阴影中</li>
<li>若等于 0，则不在阴影中</li>
</ul>
</li>
</ul>
<h6 id="怎么形成线段"><a href="#怎么形成线段" class="headerlink" title="怎么形成线段"></a>怎么形成线段</h6><ul>
<li>怎么去掉物体之后的视线部分，上述黄线的绿点右边部分</li>
<li><strong>绘制顺序、绘制状态</strong></li>
</ul>
<h6 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h6><ul>
<li>绘制出整个场景（非阴影体），确定整个场景的深度（记录到深度缓冲器中）</li>
<li>画阴影体（正向面&#x2F;反向面），顺序没有关系<ul>
<li>和记录的深度值比较<ul>
<li>若比记录的小，则根据自己是正向面还是反向面更新累计缓冲值</li>
<li>若大，则不更新累计缓冲值</li>
</ul>
</li>
<li>只进行深度判断，不进行深度更新（不修改深度缓冲器的值）</li>
<li>阴影体是虚拟的，是我们人为加入的</li>
</ul>
</li>
</ul>
<h6 id="问题（特例）"><a href="#问题（特例）" class="headerlink" title="问题（特例）"></a>问题（特例）</h6><ul>
<li><p>视点位于阴影体内部</p>
<ul>
<li>解决方法：在视线上，从无穷远到待求的点这条线段上进行累计缓冲计数<ul>
<li>比较计数的时候，只比较深度大于待求点的阴影体<ul>
<li>z-fail：计数的点是没有通过深度检测的阴影体（解决特例的方法）</li>
<li>z-pass：计数的点是通过深度检测的阴影体（常规方法）</li>
</ul>
</li>
<li>无穷远是客观的（无穷远不在阴影内部）</li>
</ul>
</li>
<li>问题：无穷远在阴影中，出错</li>
</ul>
  <img src="08/error.png" style="zoom:60%;" />
</li>
<li><p>视见体把某些物体裁剪掉了，导致阴影体减少了</p>
<ul>
<li>上述算法出错</li>
</ul>
</li>
</ul>
<h3 id="软影以及动态光源阴影的生成"><a href="#软影以及动态光源阴影的生成" class="headerlink" title="软影以及动态光源阴影的生成"></a>软影以及动态光源阴影的生成</h3><ul>
<li>面光源、体光源<ul>
<li>软影（本影、半影）</li>
<li>笨的方法：将光源进行<strong>点采样</strong><ul>
<li>慢，效率低下</li>
</ul>
</li>
<li><strong>阴影楔</strong><ul>
<li>A Geometry-based Soft Shadow Volume Algorithm<ul>
<li>实时图像渲染</li>
<li>Tomas Akenine-Möller</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>光源形态发生变化（火焰）</li>
<li>待渲染的物体变化</li>
</ul>
<h2 id="透明现象"><a href="#透明现象" class="headerlink" title="透明现象"></a>透明现象</h2><h3 id="简单透明"><a href="#简单透明" class="headerlink" title="简单透明"></a>简单透明</h3><ul>
<li>简单透明不考虑折射现象</li>
</ul>
<h4 id="插值透明"><a href="#插值透明" class="headerlink" title="插值透明"></a>插值透明</h4><p><img src="/08/simple-transparent.png"></p>
<ul>
<li>$I_\lambda&#x3D;(1-K_{t_1})I_{\lambda_1}+K_{t_1}I_{\lambda_2}$<ul>
<li>$K_{t_1}&#x3D;1$：1 完全透明，2 完全不透明</li>
<li>$K_{t_1}&#x3D;0$：2 完全透明，1 完全不透明</li>
</ul>
</li>
</ul>
<h4 id="过滤透明"><a href="#过滤透明" class="headerlink" title="过滤透明"></a>过滤透明</h4><ul>
<li>$I_\lambda&#x3D;I_{\lambda_1}+K_{t_1}C_{t\lambda}I_{\lambda_2}$<ul>
<li>$K_{t_1}$：透射系数，越大颜色透射得越多</li>
<li>$C_{t\lambda}$：不同颜色系数不同</li>
</ul>
</li>
</ul>
<h3 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h3><ul>
<li>折射定律</li>
</ul>
<p><img src="/08/refraction.png"></p>
<ul>
<li>$\dfrac{\sin\theta_i}{\sin\theta_t}&#x3D;\dfrac{\eta_t}{\eta_i}&#x3D;\dfrac{1}{\eta}$</li>
<li>$\vec{T}&#x3D;(\eta\cos\theta_i-\cos\theta_t)\vec{N}-\eta\vec{I}$</li>
</ul>
<p><img src="/08/refraction2.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/05/CG/LS/08/" data-id="cl9lj7497004k64tz1gf6dd1u" data-title="计算机图形学.李胜.08.真实感绘制之光照明(1)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CG/LS/07" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/03/CG/LS/07/" class="article-date">
  <time class="dt-published" datetime="2021-02-03T12:39:30.000Z" itemprop="datePublished">2021-02-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CG-LS/">CG.LS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/03/CG/LS/07/">计算机图形学.李胜.07.三维实体的表示</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="表示形体的两种模型"><a href="#表示形体的两种模型" class="headerlink" title="表示形体的两种模型"></a>表示形体的两种模型</h1><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><ul>
<li>完全以数据表示<ul>
<li>例如：以 8 个顶点表示的立方体，以半径和中心表示的球体</li>
<li>以数据文件的形式存在</li>
<li>包括<ul>
<li>特征表示、空间分割表示、推移表示、边界表示、构造实体集合表示等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-线框模型"><a href="#1-线框模型" class="headerlink" title="(1) 线框模型"></a>(1) 线框模型</h3><ul>
<li>将形体表示成一组<strong>轮廓线</strong>的集合</li>
<li>简单、处理速度快</li>
<li>与形体之间不存在一一对应关系，是真实物体的高度抽象、不适合真实感显示</li>
</ul>
<h3 id="2-表面模型"><a href="#2-表面模型" class="headerlink" title="(2) 表面模型"></a>(2) 表面模型</h3><ul>
<li>将形体表示成一组<strong>表面</strong>的集合</li>
<li>形体与其表面一一对应，适合真实感显示</li>
</ul>
<h3 id="3-实体模型"><a href="#3-实体模型" class="headerlink" title="(3) 实体模型"></a>(3) 实体模型</h3><ul>
<li>用来描述<strong>实体</strong>，主要用于 CAD&#x2F;CAM</li>
<li>包含了描述一个实体所需要的较多信息（几何信息、拓扑信息等）</li>
</ul>
<h2 id="过程模型"><a href="#过程模型" class="headerlink" title="过程模型"></a>过程模型</h2><ul>
<li>以一个过程和相应的控制参数描述</li>
<li>例如：用一些控制参数和一个生成规则描述的植物</li>
<li>以一个数据文件和一段代码的形式存在</li>
<li>包括<ul>
<li>粒子系统、L系统、迭代函数系统</li>
</ul>
</li>
</ul>
<h1 id="实体的定义"><a href="#实体的定义" class="headerlink" title="实体的定义"></a>实体的定义</h1><ul>
<li><p>抽象带来的问题</p>
<ul>
<li>计算机中的数学方法表示的物体可能无效</li>
<li>不能够客观存在<ul>
<li>CAD &#x2F; CAM 需要客观存在</li>
</ul>
</li>
</ul>
</li>
<li><p>客观存在（有效）—— <strong>实体的定义</strong></p>
<ul>
<li>具有一定的形状</li>
<li>具有封闭的边界（表面）</li>
<li>内部连通</li>
<li>占据有限的空间</li>
<li>经过运算之后仍是有效的实体</li>
</ul>
</li>
<li><p>实体看作点集（使用集合论的方法描述）</p>
<ul>
<li>内点：具有完全包含于该点集的充分小的领域的点</li>
<li>边界点：物体上除了内点之外的点</li>
<li>取内点运算：$i$</li>
<li>取闭包运算：$c$</li>
<li>正则运算：$r$<ul>
<li>先取内点，再取闭包</li>
<li>$r\cdot A&#x3D;c\cdot i\cdot A$</li>
<li>一个例子</li>
</ul>
</li>
</ul>
<p>  <img src="/07/r.png"></p>
<ul>
<li>正则点集 $A$ 满足 $r\cdot A&#x3D;A$</li>
</ul>
</li>
<li><p>正则点集一定是实体吗？<span style="color:red;font-weight:bold">不一定</span></p>
<ul>
<li>内部不连通</li>
</ul>
</li>
</ul>
<p><img src="/07/r-not-real.png"></p>
<ul>
<li>实体可计算的条件<ul>
<li>正则点集</li>
<li>表面是二维流形<ul>
<li>二维流形：其上任意一点存在充分小的领域与平面圆盘同构（存在连续的一一映射）</li>
</ul>
</li>
<li>同构<ul>
<li>内点 $\cong$ 圆盘</li>
<li>边界点 $\cong$ 半圆盘</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="正则集合运算"><a href="#正则集合运算" class="headerlink" title="正则集合运算"></a>正则集合运算</h1><h2 id="为什么需要正则集合运算"><a href="#为什么需要正则集合运算" class="headerlink" title="为什么需要正则集合运算"></a>为什么需要正则集合运算</h2><ul>
<li>集合运算式构造物体的有效方法</li>
<li>普通的集合运算会产生无效物体</li>
</ul>
<h2 id="正则并-x2F-交-x2F-差"><a href="#正则并-x2F-交-x2F-差" class="headerlink" title="正则并&#x2F;交&#x2F;差"></a>正则并&#x2F;交&#x2F;差</h2><h3 id="正则运算定义"><a href="#正则运算定义" class="headerlink" title="正则运算定义"></a>正则运算定义</h3><ul>
<li>$A\ op^\star\ B&#x3D;r\cdot(A\ op\ B)$</li>
<li>正则并：$A\cup^\star B&#x3D;r\cdot(A\cup B)$</li>
<li>正则交：$A\cap^\star\ B&#x3D;r\cdot(A\cap B)$</li>
<li>正则差：$A-^\star\ B&#x3D;r\cdot(A-B)$</li>
</ul>
<h3 id="边界-bS"><a href="#边界-bS" class="headerlink" title="边界 bS"></a>边界 bS</h3><ul>
<li>内部 $iS$，边界 $bS$，外部 $eS$</li>
<li>$S&#x3D;bS\cup iS$</li>
</ul>
<h4 id="求边界确定实体"><a href="#求边界确定实体" class="headerlink" title="求边界确定实体"></a>求边界确定实体</h4><ul>
<li>$bA&#x3D;(bA\cap iB)\cup(bA\cap bB)\cup(bA\cap eB)$</li>
<li>$bB&#x3D;(bB\cap iA)\cup(bB\cap bA)\cup(bB\cap eA)$</li>
<li>公共边界 $bA\cap bB&#x3D;bB\cap bA$ 可以分为两个部分<ul>
<li>同侧：实体 A 和 B 位于边界的同侧</li>
<li>异侧：实体 A 和 B 位于边界的异侧</li>
<li>$bA\cap bB&#x3D;(bA\cap bB)<em>{同侧}\cup(bA\cap bB)</em>{异侧}$</li>
</ul>
</li>
<li>通过讨论边界的组成得到以下结论<ul>
<li>正则并<ul>
<li>$b(A\cup^\star B)&#x3D;(bA\cap eB)\cup(bB\cap eA)\cup(bA\cap bB)_{同侧}$</li>
</ul>
</li>
<li>正则交<ul>
<li>$b(A\cap^\star B)&#x3D;(bA\cap iB)\cup(bB\cap iA)\cup(bA\cap bB)_{同侧}$</li>
</ul>
</li>
<li>正则差<ul>
<li>$b(A-^\star B)&#x3D;(bA\cap eB)\cup(bB\cap iA)\cup(bA\cap bB)_{异侧}$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="特征表示"><a href="#特征表示" class="headerlink" title="特征表示"></a>特征表示</h1><ul>
<li>用一组特征参数表示一组类似的物体</li>
<li>特征包括<strong>形状特征</strong>、<strong>材料特征</strong>等</li>
<li>适用于工业上标准件的表示</li>
<li>例子<ul>
<li>圆柱体：R，H</li>
<li>立方体：边长a</li>
</ul>
</li>
</ul>
<h1 id="空间分割表示"><a href="#空间分割表示" class="headerlink" title="空间分割表示"></a>空间分割表示</h1><h2 id="1-空间枚举表示"><a href="#1-空间枚举表示" class="headerlink" title="(1) 空间枚举表示"></a>(1) 空间枚举表示</h2><ul>
<li>选择一个立方体空间，将其均匀划分</li>
<li>使用三维数组表示物体，数组中的元素与单位小立方体一一对应<ul>
<li>1&#x2F;0：是否被物体占据</li>
</ul>
</li>
<li>优点<ul>
<li>可以表示任何物体</li>
<li>容易实现物体间的集合运算</li>
<li>容易计算物体的整体性质，如体积等</li>
</ul>
</li>
<li>缺点<ul>
<li>占据大量的存储空间</li>
<li>没有边界信息，不适于图形显示</li>
<li>对物体进行几何变换困难，例如非90度的旋转</li>
<li>是物体的非精确表示<ul>
<li>量化走样</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-八叉树"><a href="#2-八叉树" class="headerlink" title="(2) 八叉树"></a>(2) 八叉树</h2><ul>
<li>对空间位置枚举表示的空间分割方法做了改进<ul>
<li>均匀分割 $\rightarrow$ 自适应分割</li>
</ul>
</li>
<li>对绘制有好处</li>
</ul>
<h3 id="八叉树的建立"><a href="#八叉树的建立" class="headerlink" title="八叉树的建立"></a>八叉树的建立</h3><ul>
<li>根结点对应整个物体空间</li>
<li>从根结点开始，对于一个结点<ul>
<li>如果该结点完全被物体占据则记为 $F$（Full）</li>
<li>如果该结点内部没有物体则记为 $E$（Empty）</li>
<li>如果被物体部分占据则记作 $P$（Partitial）<ul>
<li>同时将其分割为 8 个立方体，每个立方体作为一个新的结点，进行同样的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="八叉树的应用"><a href="#八叉树的应用" class="headerlink" title="八叉树的应用"></a>八叉树的应用</h3><ul>
<li>Voxel based GI：基于八叉树的全局光照明</li>
<li>SVOGI：Sparse Voxel Octree Global Illumination<ul>
<li>全局光渲染</li>
</ul>
</li>
<li>Voxelization（体素化）<ul>
<li>将物体的几何形式表示转换成最接近该物体的体素表示形式，产生体数据集</li>
<li>不透明度属性&#x2F;法向&#x2F;发光向&#x2F;材质&#x2F;······</li>
</ul>
</li>
<li>待渲染场景 $\rightarrow$ 体素化 $\rightarrow$ 八叉树构造</li>
</ul>
<h3 id="cone-tracing"><a href="#cone-tracing" class="headerlink" title="cone tracing"></a>cone tracing</h3><ul>
<li>结合八叉树</li>
<li>点向周围展开圆锥（立体角）</li>
<li>全局光照明：计算间接光照的时候，使用圆锥内的光照进行近似<ul>
<li>在圆锥中，根据大小找到对应的不同粒度的八叉树，使用保存的属性</li>
<li>不同粒度，八叉树最小结点的大小不同（层次）</li>
</ul>
</li>
</ul>
<img src="07/core-tracing.png" style="zoom:100%;" />

<ul>
<li>求光照<ul>
<li>蒙特卡洛采样积分：复杂度高</li>
<li>core tracing：复杂度相对较低</li>
</ul>
</li>
</ul>
<h3 id="八叉树评价"><a href="#八叉树评价" class="headerlink" title="八叉树评价"></a>八叉树评价</h3><ul>
<li>优点<ul>
<li>可以表示任何物体</li>
<li>容易实现物体间的集合运算</li>
<li>容易计算物体的整体性质，如体积等</li>
<li>相较于空间位置枚举表示占用的存贮空间少</li>
</ul>
</li>
<li>缺点<ul>
<li>没有边界信息，不适于图形显示</li>
<li>对物体进行几何变换困难，例如非90度的旋转</li>
<li>是物体的非精确表示</li>
</ul>
</li>
</ul>
<h2 id="3-单元分解表示"><a href="#3-单元分解表示" class="headerlink" title="(3) 单元分解表示"></a>(3) 单元分解表示</h2><ul>
<li>对空间位置枚举表示的空间分割方法做了改进<ul>
<li>单一体素 $\rightarrow$ 多种体素</li>
</ul>
</li>
</ul>
<p><img src="/07/multi-voxel.png"></p>
<ul>
<li>优点<ul>
<li>表示简单</li>
<li>容易实现几何变换</li>
<li>基本提速可以按需选择，表示范围较广</li>
<li>可以精确表示物体</li>
</ul>
</li>
<li>缺点<ul>
<li>物体表示不唯一</li>
<li>物体有效性难以保证</li>
</ul>
</li>
</ul>
<h1 id="空间层次划分"><a href="#空间层次划分" class="headerlink" title="空间层次划分"></a>空间层次划分</h1><h2 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD-Tree"></a>KD-Tree</h2><ul>
<li>适合静态场景的光线追踪</li>
<li>降低算法查找的复杂度<ul>
<li>静态：一次建立，多次查找</li>
<li>$\log n$</li>
</ul>
</li>
<li>只进行横向和纵向的划分<ul>
<li>分割线只有水平和竖直</li>
</ul>
</li>
<li>KD-Tree 降低了每一步判断在哪一个区域的复杂度<ul>
<li>只需要和某几个维度比较（降维）</li>
</ul>
</li>
<li>判断点在分割线的哪个部分（2D）<ul>
<li>任意直线：$ax+by+c$ 和 $0$ 作比较</li>
<li>KD-Tree：<ul>
<li>水平：$x$ 和 $0$ 作比较</li>
<li>竖直：$y$ 和 $0$ 作比较</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/07/kd-tree.png"></p>
<ul>
<li>基于 kd-tree 的光子映射算法 photon mapping<ul>
<li>给定一个点（位置），搜索在某个邻域之内散落的光子</li>
<li>KNN 的方法</li>
<li>KD-Tree 能够很好支持</li>
</ul>
</li>
</ul>
<h2 id="BVH-层次包围盒"><a href="#BVH-层次包围盒" class="headerlink" title="BVH 层次包围盒"></a>BVH 层次包围盒</h2><ul>
<li>Bounding Volumn Hierarchy</li>
<li>适合动态场景的表示以及碰撞检测</li>
</ul>
<h1 id="推移表示"><a href="#推移表示" class="headerlink" title="推移表示"></a>推移表示</h1><ul>
<li>sweep 体（扫掠）<ul>
<li>将物体 A 沿着轨迹 P 推移得到物体 B，称 B 为 sweep 体</li>
</ul>
</li>
<li>平移 sweep<ul>
<li>将一个二维区域沿着一个矢量方向推移</li>
</ul>
</li>
<li>旋转 sweep<ul>
<li>将一个二维区域绕旋转轴旋转一周</li>
</ul>
</li>
<li>广义 sweep<ul>
<li>任意物体沿着任意轨迹推移</li>
<li>推移过程中物体可以变形</li>
</ul>
</li>
<li>优点<ul>
<li>表示简单、直观</li>
<li>适合做图形输入手段</li>
</ul>
</li>
<li>缺点<ul>
<li>做集合运算困难，正则集合运算下非封闭</li>
</ul>
</li>
<li>应用<ul>
<li>CAD 中工件的表示</li>
</ul>
</li>
</ul>
<h1 id="边界表示"><a href="#边界表示" class="headerlink" title="边界表示"></a>边界表示</h1><ul>
<li><p>思想：物体的边界与物体一一对应，确定了物体的边界也就确定了物体本身</p>
</li>
<li><p>用于表示物体边界的有平面多边形、曲面片</p>
</li>
<li><p><strong>平面多边体</strong></p>
<ul>
<li>表面由平面多边形组成的多面体</li>
<li>严格要求每条边只属于两个多边形</li>
</ul>
</li>
<li><p>简单多面体</p>
<ul>
<li>与球拓扑同构</li>
</ul>
</li>
<li><p><strong>欧拉公式</strong>：$V-E+F&#x3D;2$</p>
<ul>
<li>顶点数 - 边数 + 面数 &#x3D; 2</li>
<li>图论角度，从<strong>树</strong>开始推导</li>
</ul>
</li>
</ul>
<p><img src="/07/Euler.png"></p>
<ul>
<li>欧拉公式是实体的<strong>必要条件</strong><ul>
<li>其他条件：边共享，顶点共享</li>
<li>一条边只能被两个面共享（${\color{red}2}$）</li>
</ul>
</li>
</ul>
<p><img src="/07/Euler-not-real.png"></p>
<ul>
<li><strong>广义欧拉公式</strong>：$V-E+F-R&#x3D;2(S-H)$<ul>
<li>顶点数 - 边数 + 面数 - 孔的个数 &#x3D; 2(体的个数 - 洞的个数)</li>
<li>孔和洞的区别在于洞是<strong>贯穿</strong>的</li>
<li>非简单多面体</li>
</ul>
</li>
</ul>
<p><img src="/07/Euler-general.png"></p>
<ul>
<li><p>torus：亏格</p>
<ul>
<li>面包圈形态：亏格为1（$H&#x3D;1$）</li>
<li>亏格为0的实体可以和<strong>球</strong>同构</li>
</ul>
</li>
<li><p>多边形的顶点顺序与法向量</p>
<ul>
<li>规定一个顶点顺序，确定法向量</li>
<li>法向量：正反面，光照，几何计算等</li>
</ul>
</li>
<li><p>空间多边形的平面方程计算</p>
<ul>
<li>顶点可能不共面：<strong>最小二乘法</strong> 拟合出一个平面，使其到所有顶点的距离之和最小</li>
</ul>
</li>
<li><p>边界表示的<strong>数据结构</strong></p>
<ul>
<li><strong>半边结构</strong><ul>
<li>一条边当作两条半边</li>
<li>好处<ul>
<li>确定边的方向</li>
<li>确定一个边的搜索顺序</li>
<li>确定边被哪些平面共享<ul>
<li>在几何造型时有用，单纯显示没有必要</li>
<li>例如删除某个平面，此时相关联的边也需要修改（修改拓扑结构）</li>
</ul>
</li>
</ul>
</li>
<li>下图：方向为规定的正方向，红色为半边的方向</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/07/half-edge.png"></p>
<ul>
<li>边界表示优点<ul>
<li>精确表示物体</li>
<li>表示能力强</li>
<li>几何变换容易</li>
<li>适于显示处理</li>
</ul>
</li>
<li>边界表示缺点<ul>
<li>表示复杂</li>
<li>有效性难以保证</li>
<li>集合运算复杂</li>
</ul>
</li>
</ul>
<h1 id="构造实体的几何表示"><a href="#构造实体的几何表示" class="headerlink" title="构造实体的几何表示"></a>构造实体的几何表示</h1><ul>
<li>将物体表示成一棵二叉树，<strong>CSG树</strong></li>
<li>叶节点：基本体素<ul>
<li>立方体，圆柱体等</li>
</ul>
</li>
<li>中间节点：正则运算集合<ul>
<li>并交差</li>
</ul>
</li>
</ul>
<p><img src="/07/CSG-Tree.png"></p>
<ul>
<li><p>面</p>
<ul>
<li>环</li>
<li>边<ul>
<li>半边（1，2）</li>
</ul>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>表示简单、直观</li>
<li>是物体的构造方法，可用作图形输入手段</li>
<li>容易计算物体的整体性质</li>
<li>物体的有效性自动得到保证</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>表示不唯一</li>
<li>不能直接用于显示</li>
<li>求交计算麻烦</li>
</ul>
</li>
</ul>
<h1 id="不规则形体的建模方法"><a href="#不规则形体的建模方法" class="headerlink" title="不规则形体的建模方法"></a>不规则形体的建模方法</h1><ul>
<li>迭代函数系统</li>
<li>基于文法的模型</li>
<li>粒子系统</li>
</ul>
<h2 id="迭代函数系统"><a href="#迭代函数系统" class="headerlink" title="迭代函数系统"></a>迭代函数系统</h2><ul>
<li>IFS：Iterated Function System</li>
<li>分形</li>
<li>具有 5 个基本特征<ul>
<li>形态的不规则性</li>
<li>结构的精细性</li>
<li>局部与整体的自相似性</li>
<li>为数的非整数性</li>
<li>生成的迭代性</li>
</ul>
</li>
</ul>
<h2 id="L-系统"><a href="#L-系统" class="headerlink" title="L 系统"></a>L 系统</h2><ul>
<li>由生物学家 <strong>Lindenmayer</strong> 创立</li>
<li>基本思想<ul>
<li>用文法表示植物的拓扑结构<ul>
<li>BNF</li>
</ul>
</li>
<li>通过图形学的方法生成逼真的画面</li>
</ul>
</li>
<li>DOL系统（确定的上下文无关的L系统）<ul>
<li>定义为三元组 $&lt;V,w,P&gt;$<ul>
<li>$V$ 表示字母集合，<strong>字母表</strong></li>
<li>$Y^\star$ 表示 $V$ 上的<strong>所有单词</strong>的集合</li>
<li>$w$ 是一个非空单词（$V$ 中元素的非空排列，称为公理）</li>
<li>$P$ <strong>产生式</strong>集合<ul>
<li>$\forall a\in V,\exists x\in V^\star$ 使得 $a\to x$<ul>
<li>有且只有（唯一）的 $x$</li>
</ul>
</li>
<li>若无明显的产生式，则令 $a\to a$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Koch-雪花"><a href="#Koch-雪花" class="headerlink" title="Koch 雪花"></a>Koch 雪花</h3><ul>
<li>$V:{F,+,-}$</li>
<li>$w:F$</li>
<li>$P:F\to F-F++F-F$</li>
<li>几何解释：<ul>
<li>$F$：向前画一条直线</li>
<li>$+$：右转 $\alpha$</li>
<li>$-$：左转 $\beta$</li>
</ul>
</li>
</ul>
<p><img src="/07/koch.png"></p>
<h3 id="Bracketed-L系统"><a href="#Bracketed-L系统" class="headerlink" title="Bracketed L系统"></a>Bracketed L系统</h3><ul>
<li>$V:{F,+,-,[,]}$</li>
<li>$w:F$</li>
<li>$P:F\to F[+F]F[-F]F$</li>
<li>几何解释：<ul>
<li>$F$：向前画一条直线</li>
<li>$+$：右转 $\alpha$</li>
<li>$-$：左转 $\beta$</li>
<li>$[$：压栈</li>
<li>$[$：出栈</li>
</ul>
</li>
</ul>
<p><img src="/07/bracketed-L.png"></p>
<h1 id="粒子系统"><a href="#粒子系统" class="headerlink" title="粒子系统"></a>粒子系统</h1><h2 id="Particle-Systems"><a href="#Particle-Systems" class="headerlink" title="Particle Systems"></a>Particle Systems</h2><ul>
<li>simulate and render objects &#x2F; phenomena that do not have clear surface definitions<ul>
<li>fire, water, snow, explosion, smoke, swarm, fountain …<ul>
<li>火焰、水、雪、爆炸、烟雾、群、喷泉</li>
</ul>
</li>
</ul>
</li>
<li>Particles are entities (e.g.points) with attributes acting independently and collectively<ul>
<li>带有属性的实体，实体之间的属性相互独立或联系</li>
</ul>
</li>
<li>Typical attributes: position, velocity, color, life span, etc.<ul>
<li>位置、速度、颜色、生命周期</li>
</ul>
</li>
</ul>
<h2 id="一些特点"><a href="#一些特点" class="headerlink" title="一些特点"></a>一些特点</h2><ul>
<li>An object is represented as clouds of primitive particles that define its volume.<ul>
<li>单个粒子很简单，物体的形态由集群的粒子表现</li>
</ul>
</li>
<li>dynamic, changing form and moving with the passage of time.<ul>
<li>动态的、变化的，处于不同生命周期时间段的例子有不一样的状态</li>
</ul>
</li>
<li>Object is not deterministic, its shape and form are not completely specified.<ul>
<li>非确定性的，形状或者样式不是完全规定好的</li>
</ul>
</li>
<li>Different force rules and different renderings give all the different types of behaviors.<ul>
<li>例字在面对不同的条件或者规则会有不一样的行为</li>
</ul>
</li>
</ul>
<h2 id="粒子的属性"><a href="#粒子的属性" class="headerlink" title="粒子的属性"></a>粒子的属性</h2><ul>
<li>Position：<strong>位置</strong><ul>
<li>the change of the particle position is affected by its velocity</li>
</ul>
</li>
<li>velocity：<strong>速度</strong><ul>
<li>affected by force&#x2F;acceleration</li>
</ul>
</li>
<li>Lifetime：<strong>生命周期</strong><ul>
<li>the remain life time before the extinction of the particle</li>
<li>It is decremented every frame.</li>
<li>It may affect may other attributes</li>
</ul>
</li>
<li>Size：<strong>大小</strong><ul>
<li>may vary during its life span</li>
</ul>
</li>
<li>Weight：<strong>质量</strong><ul>
<li>useful to calculate acceleration from force</li>
</ul>
</li>
<li>Visual representation：<strong>可视化形式</strong><ul>
<li>3D points：3D 的<strong>点</strong>，适用于比较远的点（看不出来差异）<ul>
<li>for remote scene</li>
</ul>
</li>
<li>Lines：<strong>线</strong>（粒子轨迹）<ul>
<li>a trace of particle trajectory</li>
</ul>
</li>
<li>Texture-mapped quads：带纹理的四边形<ul>
<li>very flexible &amp; widely used</li>
</ul>
</li>
</ul>
</li>
<li>Color：<strong>颜色</strong><ul>
<li>may change during its life span</li>
</ul>
</li>
</ul>
<h2 id="粒子的集群控制"><a href="#粒子的集群控制" class="headerlink" title="粒子的集群控制"></a>粒子的集群控制</h2><ul>
<li>Particle list：<strong>粒子的列表</strong></li>
<li>Particle generation：<strong>粒子的产生</strong><ul>
<li>Position：<strong>位置信息</strong><ul>
<li>default, Random or fixed.</li>
</ul>
</li>
<li>Emission rate：<strong>生成速率</strong><ul>
<li>how often particles are created.</li>
</ul>
</li>
<li>Default particle attributes：<strong>初始属性</strong><ul>
<li>Random or fixed.</li>
</ul>
</li>
</ul>
</li>
<li>Particle kill：<strong>粒子的湮灭</strong>（生命周期）<ul>
<li>kill particles if their lifetimes become <strong>0</strong> or <strong>certain conditions</strong> happen</li>
</ul>
</li>
<li>Particle Animation：<strong>粒子的动画</strong>（每一帧的动画）<ul>
<li>The remaining particles are moved and transformed according to their dynamic attributes.</li>
</ul>
</li>
<li>Rendering：<strong>渲染器</strong><ul>
<li>An image of the particles is rendered in the frame buffer, often using special purpose algorithms.</li>
</ul>
</li>
<li>Force field：<strong>交互，外界的影响</strong> affector<ul>
<li>assign a force (can be different) to each particles to produce acceleration</li>
</ul>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>与环境交互<ul>
<li>火焰吹风，得动起来</li>
<li>小球沿着坡滚下来</li>
</ul>
</li>
<li>粒子的行为<ul>
<li>行为规则（内在）</li>
<li>环境（外在，交互）</li>
</ul>
</li>
<li>粒子湮灭<ul>
<li>Lifetime decremented each frame, particle is killed when it reaches zero</li>
<li>Kill particles that no longer contribute to image (<strong>transparency below a certain threshold</strong>, etc.).</li>
</ul>
</li>
<li>粒子系统很好玩，但是很难做<ul>
<li>粒子系统引擎</li>
<li>交互式编辑（灵活、泛化）</li>
<li>给定一个任意场景（环境因素）<ul>
<li>给定一个山形，构建一个符合这个山形的瀑布（很难）</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/03/CG/LS/07/" data-id="cl9lj7496004c64tz4ocuhl7r" data-title="计算机图形学.李胜.07.三维实体的表示" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG/" rel="tag">CG</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/23/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="page-number" href="/page/23/">23</a><span class="page-number current">24</span><a class="page-number" href="/page/25/">25</a><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/25/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/0/">0</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algebra/">Algebra</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-Kits/">C++.Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG/">CG</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Algorithm/">CG.Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES101/">CG.GAMES101</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES102/">CG.GAMES102</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES103/">CG.GAMES103</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES104/">CG.GAMES104</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES202/">CG.GAMES202</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-GAMES203/">CG.GAMES203</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Kits/">CG.Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-LS/">CG.LS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-PBRT/">CG.PBRT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CG-Paper/">CG.Paper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CV/">CV</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Code/">Code</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-CLJ/">DB.CLJ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-MySQL/">DB.MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB-SQLServer/">DB.SQLServer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DSA/">DSA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kits/">Kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-CXQ/">OS.CXQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-OSTEP/">OS.OSTEP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-xv6-labs/">OS.xv6-labs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS-xv6-source-code/">OS.xv6-source-code</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TODO/">TODO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/book-directory/">book.directory</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computation-pyr/">computation.pyr</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/csharp-kits/">csharp.kits</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/csharp-tds/">csharp.tds</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/images/">images</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/installation/">installation</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mitsuba/">mitsuba</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nothing/">nothing</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-Maya/">software.Maya</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-ps/">software.ps</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-vscode/">software.vscode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/win/">win</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algebra/" rel="tag">Algebra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS/" rel="tag">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BST/" rel="tag">BST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BVH/" rel="tag">BVH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CG/" rel="tag">CG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CG-Algorithm/" rel="tag">CG-Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CV/" rel="tag">CV</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Code/" rel="tag">Code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB/" rel="tag">DB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/" rel="tag">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DSA/" rel="tag">DSA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dijkstra/" rel="tag">Dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EG/" rel="tag">EG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Floyd/" rel="tag">Floyd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GI/" rel="tag">GI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Glints/" rel="tag">Glints</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDR/" rel="tag">HDR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HQX/" rel="tag">HQX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Heap/" rel="tag">Heap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kits/" rel="tag">Kits</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCA/" rel="tag">LCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLG/" rel="tag">LLG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MCMC/" rel="tag">MCMC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MIS/" rel="tag">MIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MLT/" rel="tag">MLT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maya/" rel="tag">Maya</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NEE/" rel="tag">NEE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBRT/" rel="tag">PBRT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paper/" rel="tag">Paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Radiometry/" rel="tag">Radiometry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RayTracing/" rel="tag">RayTracing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SAH/" rel="tag">SAH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SDF/" rel="tag">SDF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SGJ/" rel="tag">SGJ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLServer/" rel="tag">SQLServer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shadow/" rel="tag">Shadow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WHM/" rel="tag">WHM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WX/" rel="tag">WX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YLQ/" rel="tag">YLQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/book/" rel="tag">book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/computation/" rel="tag">computation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csharp/" rel="tag">csharp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/images/" rel="tag">images</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/installation/" rel="tag">installation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/" rel="tag">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mitsuba/" rel="tag">mitsuba</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobaxterm/" rel="tag">mobaxterm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nothing/" rel="tag">nothing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/obs/" rel="tag">obs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/occlusion/" rel="tag">occlusion</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ps/" rel="tag">ps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/software/" rel="tag">software</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tree/" rel="tag">tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/win/" rel="tag">win</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xv6/" rel="tag">xv6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%83%E5%AE%87%E5%AE%99/" rel="tag">元宇宙</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%A0%E4%BD%95/" rel="tag">几何</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/" rel="tag">可见性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" rel="tag">拓扑排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%99%AE%E5%90%95%E5%85%8B%E5%9D%90%E6%A0%87/" rel="tag">普吕克坐标</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="tag">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algebra/" style="font-size: 10px;">Algebra</a> <a href="/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/tags/BST/" style="font-size: 10px;">BST</a> <a href="/tags/BVH/" style="font-size: 12.5px;">BVH</a> <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/CG/" style="font-size: 20px;">CG</a> <a href="/tags/CG-Algorithm/" style="font-size: 10px;">CG-Algorithm</a> <a href="/tags/CV/" style="font-size: 10.63px;">CV</a> <a href="/tags/Code/" style="font-size: 14.38px;">Code</a> <a href="/tags/DB/" style="font-size: 19.38px;">DB</a> <a href="/tags/DFS/" style="font-size: 12.5px;">DFS</a> <a href="/tags/DP/" style="font-size: 13.13px;">DP</a> <a href="/tags/DSA/" style="font-size: 11.25px;">DSA</a> <a href="/tags/Dijkstra/" style="font-size: 10px;">Dijkstra</a> <a href="/tags/EG/" style="font-size: 12.5px;">EG</a> <a href="/tags/Floyd/" style="font-size: 10.63px;">Floyd</a> <a href="/tags/GI/" style="font-size: 11.25px;">GI</a> <a href="/tags/Glints/" style="font-size: 10px;">Glints</a> <a href="/tags/HDR/" style="font-size: 10px;">HDR</a> <a href="/tags/HQX/" style="font-size: 10px;">HQX</a> <a href="/tags/Heap/" style="font-size: 10px;">Heap</a> <a href="/tags/Kits/" style="font-size: 13.75px;">Kits</a> <a href="/tags/LCA/" style="font-size: 10px;">LCA</a> <a href="/tags/LLG/" style="font-size: 12.5px;">LLG</a> <a href="/tags/MCMC/" style="font-size: 10.63px;">MCMC</a> <a href="/tags/MIS/" style="font-size: 10px;">MIS</a> <a href="/tags/MLT/" style="font-size: 10px;">MLT</a> <a href="/tags/Maya/" style="font-size: 10px;">Maya</a> <a href="/tags/MySQL/" style="font-size: 11.88px;">MySQL</a> <a href="/tags/NEE/" style="font-size: 10px;">NEE</a> <a href="/tags/OS/" style="font-size: 17.5px;">OS</a> <a href="/tags/PBRT/" style="font-size: 10px;">PBRT</a> <a href="/tags/Paper/" style="font-size: 15.63px;">Paper</a> <a href="/tags/Radiometry/" style="font-size: 10px;">Radiometry</a> <a href="/tags/RayTracing/" style="font-size: 10px;">RayTracing</a> <a href="/tags/SAH/" style="font-size: 10px;">SAH</a> <a href="/tags/SDF/" style="font-size: 10px;">SDF</a> <a href="/tags/SGJ/" style="font-size: 10.63px;">SGJ</a> <a href="/tags/SQL/" style="font-size: 13.13px;">SQL</a> <a href="/tags/SQLServer/" style="font-size: 10.63px;">SQLServer</a> <a href="/tags/STL/" style="font-size: 11.25px;">STL</a> <a href="/tags/Shadow/" style="font-size: 10px;">Shadow</a> <a href="/tags/WHM/" style="font-size: 16.88px;">WHM</a> <a href="/tags/WX/" style="font-size: 11.88px;">WX</a> <a href="/tags/YLQ/" style="font-size: 18.13px;">YLQ</a> <a href="/tags/book/" style="font-size: 10.63px;">book</a> <a href="/tags/computation/" style="font-size: 18.75px;">computation</a> <a href="/tags/csharp/" style="font-size: 16.25px;">csharp</a> <a href="/tags/images/" style="font-size: 10px;">images</a> <a href="/tags/installation/" style="font-size: 11.88px;">installation</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/linux/" style="font-size: 11.25px;">linux</a> <a href="/tags/math/" style="font-size: 10px;">math</a> <a href="/tags/mitsuba/" style="font-size: 11.88px;">mitsuba</a> <a href="/tags/mobaxterm/" style="font-size: 10px;">mobaxterm</a> <a href="/tags/nothing/" style="font-size: 10.63px;">nothing</a> <a href="/tags/obs/" style="font-size: 10px;">obs</a> <a href="/tags/occlusion/" style="font-size: 15px;">occlusion</a> <a href="/tags/ps/" style="font-size: 10px;">ps</a> <a href="/tags/software/" style="font-size: 10px;">software</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/tree/" style="font-size: 11.25px;">tree</a> <a href="/tags/vscode/" style="font-size: 10.63px;">vscode</a> <a href="/tags/win/" style="font-size: 10.63px;">win</a> <a href="/tags/xv6/" style="font-size: 16.25px;">xv6</a> <a href="/tags/%E4%BA%8C%E5%88%86/" style="font-size: 10.63px;">二分</a> <a href="/tags/%E5%85%83%E5%AE%87%E5%AE%99/" style="font-size: 10.63px;">元宇宙</a> <a href="/tags/%E5%87%A0%E4%BD%95/" style="font-size: 10px;">几何</a> <a href="/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/" style="font-size: 11.88px;">可见性</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 10.63px;">并查集</a> <a href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">拓扑排序</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%99%AE%E5%90%95%E5%85%8B%E5%9D%90%E6%A0%87/" style="font-size: 10px;">普吕克坐标</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 10px;">最小生成树</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" style="font-size: 13.13px;">最短路</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 10px;">线段树</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/23/CG/WHM-GAMES103/11/">GAMES103.王华民.11.Incompressible Fluid Dynamics and Eulerian Fluids</a>
          </li>
        
          <li>
            <a href="/2022/10/23/CG/Papers/2021/bvh-survey-3/">(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(4)</a>
          </li>
        
          <li>
            <a href="/2022/04/28/CG/Kits/MIS-NEE/">NEE、MIS(多重重要性采样)</a>
          </li>
        
          <li>
            <a href="/2022/04/18/CG/WHM-GAMES103/10/">GAMES103.王华民.10.Surface Waves</a>
          </li>
        
          <li>
            <a href="/2022/04/17/CG/WHM-GAMES103/09-1/">GAMES103.王华民.09.Collision Handling(1)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>