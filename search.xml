<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>VAE(Auto Encoding Variational Bayes)</title>
    <url>/2022/10/29/CV/VAE/</url>
    <content><![CDATA[<h1 id="auto-encoding-variational-bayes">Auto Encoding Variational
Bayes</h1>
<h2 id="方法">方法</h2>
<h3 id="问题描述">问题描述</h3>
<ul>
<li>数据集 <span class="math inline">\(\mathrm{X}=\left\{\mathrm{x}^{(i)}\right\}_{i=1}^{N}\)</span>
是 <span class="math inline">\(N\)</span> 个独立同分布的样本</li>
<li>假设 <span class="math inline">\(\mathrm{x}^{(i)}\)</span>
是由一个连续的随机变量 <span class="math inline">\(\mathrm{z}\)</span>
产生的</li>
<li>过程如下
<ul>
<li>首先根据某个先验分布 <span class="math inline">\(p_{\theta^\ast}(\mathrm{z})\)</span> 产生一个样本
<span class="math inline">\(\mathrm{z}^{(i)}\)</span></li>
<li>然后再根据条件概率 <span class="math inline">\(p_{\theta^\ast}(\mathrm{x}\vert\mathrm{z})\)</span>
生成样本 <span class="math inline">\(\mathrm{x}^{(i)}\)</span></li>
</ul></li>
<li>假设 <span class="math inline">\(p_{\theta^\ast}(\mathrm{z}),p_{\theta^\ast}(\mathrm{x}\vert\mathrm{z})\)</span>
来自于参数族分布 <span class="math inline">\(p_{\theta}(\mathrm{z}),p_{\theta}(\mathrm{x}\vert\mathrm{z})\)</span>，他们对于
<span class="math inline">\(\theta,\mathrm{z}\)</span>
都是几乎处处可导的</li>
<li>问题：我们不知道真实的 <span class="math inline">\(\theta^\ast\)</span> 和隐变量 <span class="math inline">\(\mathrm{z}\)</span></li>
</ul>
<h4 id="适用">适用</h4>
<ul>
<li>不对后验分布做简化的假设，适合通用场景</li>
<li>Intractability
<ul>
<li><span class="math inline">\(p_{\theta}(\mathrm{x})=\int
p_{\theta}(\mathrm{z})p_{\theta}(\mathrm{x}\vert\mathrm{z})\;\mathrm{dz}\)</span>
很难估计和求导（不能直接用最大似然估计）</li>
<li><span class="math inline">\(p_{\theta}(\mathrm{z}\vert\mathrm{x})=p_{\theta}(\mathrm{x}\vert\mathrm{z})p_{\theta}(\mathrm{z})/p_{\theta}(\mathrm{x})\)</span>
不好求（不能使用 EM 算法）
<ul>
<li>EM（Expectation Maximization）</li>
<li>随机初始化 <span class="math inline">\(\theta\)</span></li>
<li>E-step：估计 <span class="math inline">\(p_{\theta}(\mathrm{z}\vert\mathrm{x})\)</span></li>
<li>M-step：更新 <span class="math inline">\(\theta\)</span></li>
</ul></li>
<li>mean-field VB（Variational Bayesian）算法也不能运行</li>
<li>比较常见，当似然函数 <span class="math inline">\(p_{\theta}(\mathrm{z}\vert\mathrm{x})\)</span>
比较复杂的时候
<ul>
<li>带非线性激活层的神经网络</li>
</ul></li>
</ul></li>
<li>A large dataset
<ul>
<li>batch optimization is too costly</li>
<li>希望使用更小的 batch，甚至是单个数据点</li>
<li>基于采样的方法开销大，例如 MC-EM，采样很耗时</li>
</ul></li>
</ul>
<h4 id="说明">说明</h4>
<ul>
<li>我们的方法试图解决如下 3 个问题
<ul>
<li>快速估计 <span class="math inline">\(\theta\)</span></li>
<li>快速估计 <span class="math inline">\(p_{\theta}(\mathrm{z}\vert\mathrm{x})\)</span></li>
<li>快速估计 <span class="math inline">\(p_{\theta}(\mathrm{x}\vert\mathrm{z})\)</span></li>
</ul></li>
<li>recognition model <span class="math inline">\(q_{\phi}(\mathrm{z}\vert\mathrm{x})\)</span>
<ul>
<li>对复杂的后验分布 <span class="math inline">\(p_{\theta}(\mathrm{z}\vert\mathrm{x})\)</span>
的估计</li>
<li>和变分推断的限制不一样，我们不要求是可因子化的，参数 <span class="math inline">\(\phi\)</span> 也不需要从闭式期望中求出</li>
</ul></li>
<li>我们提出一个方法能够将 recognition model <span class="math inline">\(q_{\phi}(\mathrm{z}\vert\mathrm{x})\)</span> 和
generative model parameters <span class="math inline">\(\theta\)</span>
一起训练的学习方法</li>
<li>encoder：<span class="math inline">\(q_{\phi}(\mathrm{z}\vert\mathrm{x})\)</span></li>
<li>decoder：<span class="math inline">\(p_{\theta}(\mathrm{x}\vert\mathrm{z})\)</span></li>
</ul>
<h3 id="the-variational-bound">The variational bound</h3>
<ul>
<li>marginal likelihood，给定 <span class="math inline">\(\theta\)</span> 下的 <span class="math inline">\(\mathrm{x}\)</span> 的分布的似然函数</li>
</ul>
<p><img src="/2022/10/29/CV/VAE/marginal-likelihood.png"></p>
<ul>
<li>重写每一个项（<span id="eq1">EQ1</span>）</li>
</ul>
<p><img src="/2022/10/29/CV/VAE/marginal-likelihood-rewrite.png"></p>
<ul>
<li>KL 散度是非负的，因此 <span class="math inline">\(\mathcal{L}\)</span> 项也被称为 (variational)
lower bound</li>
</ul>
<p><span class="math display">\[
D_{KL}(p(x)\Vert q(x)) = \int p(x)\log\left(\frac{p(x)}{q(x)}\right)
\mathrm{d}x
\]</span></p>
<ul>
<li>以下的 <span class="math inline">\(\mathrm{x}\)</span> 代表 <span class="math inline">\(\mathrm{x}^{(i)}\)</span>
<ul>
<li><span id="eq2"><strong>Eq2</strong></span></li>
</ul></li>
</ul>
<p><img src="/2022/10/29/CV/VAE/lower-bound.png"></p>
<ul>
<li>推导</li>
</ul>
<p><span class="math display">\[
\begin{align}
\mathcal{L}(\theta, \phi ;\mathrm{x}^{(i)})
&amp;=\log p_{\theta} (\mathrm{x}^{(i)}) - D_{KL}(q_{\phi}
(\mathrm{z}|\mathrm{x}^{(i)}) \Vert p_{\theta}
(\mathrm{z}|\mathrm{x}^{(i)}))\\
&amp;=\mathbb{E}_{q_{\phi} (\mathrm{z}|\mathrm{x})} [\log p_{\theta}
(\mathrm{x})]-\mathbb{E}_{q_{\phi} (\mathrm{z}|\mathrm{x})} [\log
q_{\phi} (\mathrm{z}|\mathrm{x}) - \log p_{\theta}
(\mathrm{z}|\mathrm{x})]\\
&amp;=\mathbb{E}_{q_{\phi} (\mathrm{z}|\mathrm{x})} \Big[\log
\Big(p_{\theta} (\mathrm{x})p_{\theta} (\mathrm{z}|\mathrm{x})\Big)-\log
q_{\phi} (\mathrm{z}|\mathrm{x})\Big]\\
&amp;=\mathbb{E}_{q_{\phi} (\mathrm{z}|\mathrm{x})} [\log p_{\theta}
(\mathrm{z},\mathrm{x})-\log q_{\phi} (\mathrm{z}|\mathrm{x})]
\end{align}
\]</span></p>
<ul>
<li>也可以重写为如下式子
<ul>
<li><span id="eq3"><strong>Eq3</strong></span></li>
</ul></li>
</ul>
<p><img src="/2022/10/29/CV/VAE/lower-bound2.png"></p>
<ul>
<li>推导</li>
</ul>
<p>$$ <span class="math display">\[\begin{align}
\mathcal{L}(\theta, \phi ;\mathrm{x}^{(i)})
&amp;=\mathbb{E}_{q_{\phi} (\mathrm{z}|\mathrm{x})}\left[\log p_{\theta}
(\mathrm{z},\mathrm{x})-\log q_{\phi} (\mathrm{z}|\mathrm{x})\right]\\
&amp;=\mathbb{E}_{q_{\phi} (\mathrm{z}|\mathrm{x})}\left[\log
\left(\dfrac{p_{\theta} (\mathrm{z},\mathrm{x})}{q_{\phi}
(\mathrm{z}|\mathrm{x})}\right)\right]\\
&amp;=\mathbb{E}_{q_{\phi} (\mathrm{z}|\mathrm{x})}\left[\log
\left(\dfrac{p_{\theta} (\mathrm{x}\vert\mathrm{z})p_{\theta}
(\mathrm{z})}{q_{\phi} (\mathrm{z}|\mathrm{x})}\right)\right]\\
&amp;=\mathbb{E}_{q_{\phi} (\mathrm{z}|\mathrm{x})}\left[\log p_{\theta}
(\mathrm{x}\vert\mathrm{z})+\log p_{\theta} (\mathrm{z})-\log q_{\phi}
(\mathrm{z}|\mathrm{x})\right]\\

&amp;=\mathbb{E}_{q_{\phi} (\mathrm{z}|\mathrm{x})}[\log p_{\theta}
(\mathrm{x}\vert\mathrm{z})]-D_{KL}(q_{\phi} (\mathrm{z}|\mathrm{x})
\Vert p_{\theta} (\mathrm{z}))\\
\end{align}\]</span> $$</p>
<ul>
<li>通过优化 <span class="math inline">\(\theta,\phi\)</span>
让下界最小化</li>
<li><span class="math inline">\(\mathcal{L}\)</span> 对 <span class="math inline">\(\phi\)</span> 求导困难
<ul>
<li><span class="math inline">\(\mathrm{z}\)</span>
的具体分布不知道，随意采样会导致方差很大</li>
<li>按照分布采样的估计</li>
</ul></li>
</ul>
<p><img src="/2022/10/29/CV/VAE/MC-gradient-phi.png"></p>
<figure>
<img src="/2022/10/29/CV/VAE/MC-gradient-phi2.png" alt="image-20221030111014197">
<figcaption aria-hidden="true">image-20221030111014197</figcaption>
</figure>
<h3 id="sgvb-estimator">SGVB estimator</h3>
<ul>
<li>a practical estimator of the lower bound and its derivatives</li>
<li>假设后验分布的形式为 <span class="math inline">\(q_{\phi}(\mathrm{z}\vert\mathrm{x})\)</span>
<ul>
<li>也可以应用在 <span class="math inline">\(q_{\phi}(\mathrm{z})\)</span></li>
</ul></li>
<li>The fully variational Bayesian method for inferring a posterior over
the parameters is given in the appendix.
<ul>
<li><span style="color:red"><strong>看附录</strong></span></li>
</ul></li>
<li>我们可以重参数化一个随机变量 <span class="math inline">\(\hat{\mathrm{z}}\sim
g_{\phi}(\epsilon,\mathrm{x})\)</span>
<ul>
<li><span class="math inline">\(g\)</span> 可微分的</li>
<li>其中 <span class="math inline">\(\epsilon\)</span>
是一个已知分布的随机噪声</li>
<li><span style="color:red"><strong>如何选择看后面</strong></span></li>
</ul></li>
<li>现在可以构造一个对 <span class="math inline">\(f(\mathrm{z})\)</span> 的通用的 MC 估计</li>
</ul>
<p><img src="/2022/10/29/CV/VAE/MC.png"></p>
<ul>
<li>将其应用在<a href="#eq2">Eq2</a>，得到 SGVB（Stochastic Gradient
Variational Bayes）估计</li>
</ul>
<p><img src="/2022/10/29/CV/VAE/SGVB.png"></p>
<p><img src="/2022/10/29/CV/VAE/SGVB2.png"></p>
<ul>
<li>通常 <a href="#eq3">Eq3</a> 中的 KL
散度部分能被显式积分得到（见附录），只有重建误差需要通过采样估计</li>
<li>因此得到一个方差更小的估计</li>
</ul>
<p><img src="/2022/10/29/CV/VAE/SGVB-v2.png"></p>
<h3 id="aevb-algorithm">AEVB algorithm</h3>
<p><img src="/2022/10/29/CV/VAE/AVEB.png"></p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.sohu.com/a/226209674_500659">变分自编码器VAE：原来是这么一回事
| 附开源代码</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/78311644">【机器学习】EM——期望最大（非常详细）</a></li>
<li><a href="https://spaces.ac.cn/archives/5716">用变分推断统一理解生成模型（VAE、GAN、AAE、ALI）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/161277762">Auto-Encoding
Variational Bayes(VAE)</a></li>
</ul>
]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>VAE</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg 简单应用</title>
    <url>/2021/10/01/Kits/ffmpeg/</url>
    <content><![CDATA[<ul>
<li><a href="https://ffmpeg.org/">ffmpeg 官网</a></li>
</ul>
<h1 id="说明">说明</h1>
<h2 id="版本信息">版本信息</h2>
<ul>
<li><a href="https://www.gyan.dev/ffmpeg/builds/">windows 版本</a></li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">ffmpeg version 2021-09-30-git-3ee4502753-essentials_build-www.gyan.dev Copyright (c) 2000-2021 the FFmpeg developers</span><br></pre></td></tr></table></figure>
<ul>
<li>ffmpeg、ffprobe、ffplay 三件套</li>
<li>ffmpeg 处理视频的流程</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"> _______              ______________</span><br><span class="line">|       |            |              |</span><br><span class="line">| input |  demuxer   | encoded data |   decoder</span><br><span class="line">| file  | ---------&gt; | packets      | -----+</span><br><span class="line">|_______|            |______________|      |</span><br><span class="line">                                           v</span><br><span class="line">                                       _________</span><br><span class="line">                                      |         |</span><br><span class="line">                                      | decoded |</span><br><span class="line">                                      | frames  |</span><br><span class="line">                                      |_________|</span><br><span class="line"> ________             ______________       |</span><br><span class="line">|        |           |              |      |</span><br><span class="line">| output | &lt;-------- | encoded data | &lt;----+</span><br><span class="line">| file   |   muxer   | packets      |   encoder</span><br><span class="line">|________|           |______________|</span><br></pre></td></tr></table></figure>
<h1 id="一些功能">一些功能</h1>
<h2 id="查看视频信息">1. 查看视频信息</h2>
<h3 id="查看视频整体的信息">(1) 查看视频整体的信息</h3>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffprobe -show_format input.mp4</span><br></pre></td></tr></table></figure>
<ul>
<li>时长、比特率</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Duration: 00:00:06.78, start: 0.000000, bitrate: 14865 kb/s</span><br></pre></td></tr></table></figure>
<ul>
<li>流信息</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Stream #0:0[0x1](und): Video: h264 (Baseline) (avc1 / 0x31637661), yuv420p(tv, smpte170m/bt470bg/smpte170m, progressive), 1080x1920, 14831 kb/s, 30 fps, 30 tbr, 1000k tbn (default)</span><br><span class="line">  Metadata:</span><br><span class="line">    handler_name    : VideoHandler</span><br><span class="line">    vendor_id       : [0][0][0][0]</span><br><span class="line">Stream #0:1[0x2](und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 128 kb/s (default)</span><br><span class="line">  Metadata:</span><br><span class="line">    handler_name    : SoundHandler</span><br><span class="line">    vendor_id       : [0][0][0][0]</span><br></pre></td></tr></table></figure>
<h3 id="查看视频的帧信息">(2) 查看视频的帧信息</h3>
<ul>
<li>如下 <code>test_1s.mp4</code> 为一个时长 <code>1s</code>
的视频文件</li>
<li>输出所有帧的信息（包括视频帧和音频帧）
<ul>
<li><code>-of xml</code>：输出为 xml 格式</li>
</ul></li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffprobe -show_frames -of xml test_1s.mp4 &gt; info_all.xml</span><br></pre></td></tr></table></figure>
<h4 id="视频帧信息">视频帧信息</h4>
<ul>
<li>json 格式</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;media_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;video&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;stream_index&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;key_frame&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 是否是关键帧</span></span><br><span class="line">    <span class="attr">&quot;pts&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pts_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pkt_dts&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pkt_dts_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;best_effort_timestamp&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;best_effort_timestamp_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pkt_duration&quot;</span><span class="punctuation">:</span> <span class="number">33333</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pkt_duration_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.033333&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pkt_pos&quot;</span><span class="punctuation">:</span> <span class="string">&quot;791&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pkt_size&quot;</span><span class="punctuation">:</span> <span class="string">&quot;223934&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;width&quot;</span><span class="punctuation">:</span> <span class="number">1080</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="number">1920</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pix_fmt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yuv420p&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pict_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;I&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;coded_picture_number&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;display_picture_number&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;interlaced_frame&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;top_field_first&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;repeat_pict&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;color_range&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tv&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;color_space&quot;</span><span class="punctuation">:</span> <span class="string">&quot;smpte170m&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;color_primaries&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bt470bg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;color_transfer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;smpte170m&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;chroma_location&quot;</span><span class="punctuation">:</span> <span class="string">&quot;left&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="select_streams">select_streams</h4>
<ul>
<li>选项
<ul>
<li><code>v</code>：视频</li>
<li><code>a</code>：音频</li>
<li><code>v:1</code>： 音频流，而且 index=1</li>
</ul></li>
<li>只输出<strong>视频帧</strong>的信息
<ul>
<li><code>-of json</code>：输出为 json 格式</li>
</ul></li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffprobe -select_streams v -show_frames -of json test_1s.mp4 &gt; infos.json</span><br></pre></td></tr></table></figure>
<h4 id="show_entries"><strong>show_entries</strong></h4>
<ul>
<li>只显示给定的属性
<ul>
<li>例如只显示<strong>这一帧开始播放的时间</strong>、<strong>帧号</strong></li>
</ul></li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffprobe -select_streams v -show_frames ^</span><br><span class="line">-show_entries frame=pts_time,coded_picture_number ^</span><br><span class="line">-of xml test_1s.mp4 &gt; infos.xml</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>根据给定的帧数找到对应的时间戳</strong>
<ul>
<li>找到第 30 帧的时间戳
<ul>
<li>帧从 0 开始编号</li>
</ul></li>
<li><strong>视频较大时很慢</strong></li>
</ul></li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffprobe -select_streams v -show_frames ^</span><br><span class="line">-show_entries frame=pts_time,coded_picture_number ^</span><br><span class="line">-of xml test_1s.mp4 | <span class="built_in">findstr</span> &quot;coded_picture_number=\&quot;<span class="number">29</span>\&quot;&quot; &gt; ans.xml</span><br></pre></td></tr></table></figure>
<h2 id="按时间剪辑">2. 按时间剪辑</h2>
<h3 id="视频剪辑">(1) 视频剪辑</h3>
<ul>
<li>如果选项放在 <code>-i</code> 之前那就是作为 <code>input</code>
选项，之后就是作为 <code>output</code> 选项</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -s <span class="number">0</span> -t <span class="number">3</span>.<span class="number">33</span> -vcodec <span class="built_in">copy</span> -acodec <span class="built_in">copy</span> output.mp4</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-i</code>：输入文件</li>
<li><code>-s(input/output)</code>：从哪里时间开始</li>
<li><code>-to(input/output)</code>：到哪个时间停止
<ul>
<li><code>-t(input/output)</code>：持续多久时间（和 <code>-to</code>
互斥，<code>-t</code> 优先级更高）</li>
</ul></li>
<li><code>-vcodec copy</code>：不对视频进行重新编码</li>
<li><code>-acodec copy</code>：不对音频进行重新编码</li>
<li><strong>时间的格式</strong>
<ul>
<li>55：55 seconds</li>
<li>0.2：0.2 seconds</li>
<li>23.189：23.189 seconds</li>
<li>200ms：200 milliseconds (= 0.2s)</li>
<li>200000us：200000 microseconds (= 0.2s)</li>
<li>12:03:45：12 hours, 03 minutes and 45 seconds</li>
</ul></li>
</ul>
<h3 id="音频剪辑">(2) 音频剪辑</h3>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -vn -i a.mp3 -s <span class="number">0</span> -t <span class="number">3</span>.<span class="number">33</span> b.mp3</span><br></pre></td></tr></table></figure>
<h2 id="合并视频">3. 合并视频</h2>
<ul>
<li>mp4 转 ts</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -i p1.mp4 -vcodec <span class="built_in">copy</span> -acodec <span class="built_in">copy</span> -vbsf h264_mp4toannexb <span class="number">1</span>.ts</span><br><span class="line">ffmpeg -i p2.mp4 -vcodec <span class="built_in">copy</span> -acodec <span class="built_in">copy</span> -vbsf h264_mp4toannexb <span class="number">2</span>.ts</span><br><span class="line">ffmpeg -i p3.mp4 -vcodec <span class="built_in">copy</span> -acodec <span class="built_in">copy</span> -vbsf h264_mp4toannexb <span class="number">3</span>.ts</span><br></pre></td></tr></table></figure>
<ul>
<li>拼接，转 mp4</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -i &quot;concat:<span class="number">1</span>.ts|<span class="number">2</span>.ts|<span class="number">3</span>.ts&quot; -acodec <span class="built_in">copy</span> -vcodec <span class="built_in">copy</span> -absf aac_adtstoasc output.mp4</span><br></pre></td></tr></table></figure>
<ul>
<li>删除中间 ts 文件 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">del</span> *.ts</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="分离视频与音频">4. 分离视频与音频</h2>
<ul>
<li><code>-an(input/output)</code>：阻挡所有音频流</li>
<li><code>-vn(input/output)</code>：阻挡所有视频流</li>
<li>输出视频</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -an -i input.mp4 -vcodec <span class="built_in">copy</span> audio_mutex.mp4</span><br></pre></td></tr></table></figure>
<ul>
<li>输出音频</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -vn -i input.mp4 -acodec <span class="built_in">copy</span> only_audio.aac</span><br></pre></td></tr></table></figure>
<h2 id="音视频合并">5. 音视频合并</h2>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -i audio_mutex.mp4 -i only_audio.aac ^</span><br><span class="line">-c:v <span class="built_in">copy</span> -c:a aac -strict experimental combine.mp4</span><br></pre></td></tr></table></figure>
<ul>
<li>如果音频长于视频，则输出视频长度和<strong>音频</strong>一样，<strong>缺失的视频用最后一帧补全</strong></li>
<li>如果视频长于音频，则输出视频长度和<strong>视频</strong>一样，<strong>缺失的音频为无声</strong></li>
</ul>
<h3 id="音频循环播放直至视频结束">(1) 音频循环播放直至视频结束</h3>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -stream_loop -<span class="number">1</span> -i xue.m4a -i pintu.mp4 -shortest ^</span><br><span class="line">-vcodec <span class="built_in">copy</span> -acodec <span class="built_in">copy</span> ^</span><br><span class="line">-map <span class="number">1</span>:v:<span class="number">0</span> -map <span class="number">0</span>:a:<span class="number">0</span> ^</span><br><span class="line">out.mp4</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-stream_loop(input)</code>：表示流循环次数
<ul>
<li>-1：无限循环</li>
<li>1：循环一次，表示让当前输入流循环一次，一共播放<strong>两次</strong></li>
</ul></li>
<li><code>-shortest</code>
<ul>
<li>短的流结束则输入结束</li>
</ul></li>
<li><code>-map 1:v:0 -map 0:a:0</code>
<ul>
<li>使用第 1 号输入流的视频作为第 0 号输出流的视频</li>
<li>使用第 0 号输入流的音频作为第 0 号输出流的音频</li>
</ul></li>
</ul>
<h2 id="视频加速">6. 视频加速</h2>
<ul>
<li>如下例子是对音视频都加速 1.1 倍</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -hwaccel cuda -i input.mp4 -vf setpts=PTS/<span class="number">1</span>.<span class="number">1</span> -af atempo=<span class="number">1</span>.<span class="number">1</span> output_1.<span class="number">1</span>.mp4</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-hwaccel cuda</code>：使用 GPU 加速</li>
<li>查看可用硬件</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -hwaccels</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kits</category>
      </categories>
      <tags>
        <tag>Kits</tag>
      </tags>
  </entry>
  <entry>
    <title>cmd 命令行技巧</title>
    <url>/2021/10/01/Kits/cmd/</url>
    <content><![CDATA[<h1 id="cmd">cmd</h1>
<h2 id="shell">1. shell</h2>
<h3 id="多行输入">(1) 多行输入</h3>
<ul>
<li>命令太长分为多行输入，使用连接符 <code>^</code></li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ls D:\</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ls ^</span><br><span class="line"><span class="function">D:\</span></span><br></pre></td></tr></table></figure>
<h3 id="重定向">(2) 重定向</h3>
<ul>
<li>在原来的文件中<strong>追加</strong></li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ls D:\ &gt;&gt; a.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>先清空原来文件，然后将文字输出到文件中（文件不存在则新建）</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ls D:\ &gt; a.txt</span><br></pre></td></tr></table></figure>
<h2 id="fsutil">2. fsutil</h2>
<ul>
<li>关于文件系统的功能，可以试试</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">fsutil</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">---- 支持的命令 ----</span><br><span class="line"></span><br><span class="line">8dot3name         8dot3name 管理</span><br><span class="line">behavior          控制文件系统行为</span><br><span class="line">dax               Dax 卷管理</span><br><span class="line">dirty             管理卷更改位</span><br><span class="line">file              文件特定命令</span><br><span class="line">fsInfo            文件系统信息</span><br><span class="line">hardlink          硬链接管理</span><br><span class="line">objectID          对象 ID 管理</span><br><span class="line">quota             配额管理</span><br><span class="line">repair            自愈管理</span><br><span class="line">reparsePoint      重分析点管理</span><br><span class="line">storageReserve    存储保留管理</span><br><span class="line">resource          事务性资源管理器管理</span><br><span class="line">sparse            稀疏文件控制</span><br><span class="line">tiering           存储分层属性管理</span><br><span class="line">transaction       事务管理</span><br><span class="line">usn               USN 管理</span><br><span class="line">volume            卷管理</span><br><span class="line">wim               透明 wim 托管管理</span><br></pre></td></tr></table></figure>
<h3 id="新建空文件">(1) 新建空文件</h3>
<ul>
<li>利用 <code>fsutil</code></li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">fsutil file createNew b.txt <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>输出空的内容，重定向到新文件中</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> . &gt; a.txt</span><br></pre></td></tr></table></figure>
<h2 id="netsh">3. netsh</h2>
<ul>
<li>网络操作</li>
<li>每一个命令之后使用 <code>/?</code>
都能获得当前操作之后的提示信息</li>
</ul>
<h3 id="wlan">(1) wlan</h3>
<ul>
<li>查看所有保存过密码的 wifi</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">netsh wlan show profiles</span><br></pre></td></tr></table></figure>
<ul>
<li>查看某个账号对应的信息
<ul>
<li><code>key=clear</code> 表示直接显示密码</li>
</ul></li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">netsh wlan show profile name=banbao990 key=clear</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kits</category>
      </categories>
      <tags>
        <tag>Kits</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 基础知识</title>
    <url>/2022/10/24/Kits/learn-git/</url>
    <content><![CDATA[<h1 id="learn-git">Learn Git</h1>
<ul>
<li><a href="https://learngitbranching.js.org/">学习链接</a></li>
</ul>
<h2 id="基础">基础</h2>
<h3 id="确认修改-commit">确认修改 commit</h3>
<ul>
<li>确认你的修改，将其持久化</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>
<h3 id="分支-branch">分支 branch</h3>
<ul>
<li>创建分支 <code>branch1</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch branch1</span><br></pre></td></tr></table></figure>
<ul>
<li>切换到分支 <code>branch1</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout branch1</span><br></pre></td></tr></table></figure>
<ul>
<li>新建分支 <code>branch1</code>，并且切换到这个分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b branch1</span><br></pre></td></tr></table></figure>
<ul>
<li>查看所有分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<h3 id="合并分支-merge">合并分支 merge</h3>
<ul>
<li>将 <code>branch1</code> 分支合并到当前分支
<ul>
<li><code>branch1</code>
中的头指针没有变换，当前分支的头指针指向合并后的节点</li>
</ul></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge branch1</span><br></pre></td></tr></table></figure>
<h4 id="例子">例子</h4>
<ul>
<li><code>*</code> 表示 <code>head</code> 节点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  A---B---C topic</span><br><span class="line"> /</span><br><span class="line">D---E---F---G master*</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge topic</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  A---B---C topic</span><br><span class="line"> /         \</span><br><span class="line">D---E---F---G---H master*</span><br></pre></td></tr></table></figure>
<h3 id="合并分支-rebase">合并分支 rebase</h3>
<ul>
<li>将当前分支的修改在 <code>branch1</code>
中都执行一遍，然后当前分支的头指针指向修改后的节点
<ul>
<li>nowBranch 默认为 HEAD</li>
</ul></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase branch1 nowBranch</span><br></pre></td></tr></table></figure>
<ul>
<li>Q：如果说没有删除当前分支头指针指向的原来的那个节点，如何回到这个节点呢？
<ul>
<li>实际上的 git 会删除原来的节点（删除没有引用的节点）</li>
</ul></li>
<li><code>rebase</code> 的含义：将当前分支和 <code>branch1</code>
的分支节点往后移动到指定的节点
<ul>
<li>往前无效</li>
</ul></li>
</ul>
<h4 id="例子-1">例子</h4>
<ul>
<li><code>*</code> 表示 <code>head</code> 节点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      A---B---C topic*</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase master</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">               B&#x27;---C&#x27; topic*</span><br><span class="line">              /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>
<h3 id="rebasemerge">rebase/merge</h3>
<ul>
<li><code>rebase</code>
让提交树更干净（一条线），但是会修改提交历史</li>
<li><code>merge</code> 不会修改提交历史，但是提交树更复杂</li>
</ul>
<h3 id="删除分支">删除分支</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --delete branch_name</span><br></pre></td></tr></table></figure>
<ul>
<li>注意不能删除当前分支（需要先 <code>checkout</code> 到其他分支）</li>
</ul>
<h2 id="高级">高级</h2>
<ul>
<li><code>head</code> 指针：当前状态</li>
</ul>
<p><img src="/2022/10/24/Kits/learn-git/before-reset-revert.png"></p>
<ul>
<li><code>Description</code> 栏下，<span style="color:#0085d9;font-weight:bold">蓝色的小圆圈</span>就是
<code>head</code> 的位置</li>
</ul>
<h3 id="分离头指针">分离头指针</h3>
<ul>
<li>查看 <code>head</code> 指针</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux</span></span><br><span class="line"><span class="built_in">cat</span> ./.git/HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows</span></span><br><span class="line"><span class="built_in">type</span> .\.git\HEAD</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>git</code> 查看 <code>head</code> 指针</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要 head 所在位置恰好是某个分支的位置(不能只是只是简单的哈希值的结点)</span></span><br><span class="line">git symbolic-ref HEAD</span><br></pre></td></tr></table></figure>
<ul>
<li>分离 <code>head</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout main     <span class="comment"># 指向 main</span></span><br><span class="line">git checkout hashcode <span class="comment"># 指向某一个提交节点</span></span><br></pre></td></tr></table></figure>
<h3 id="相对引用">相对引用</h3>
<ul>
<li>利用哈希值修改 <code>head</code> 指针</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 092d58b38f41f9594c0c284ef6defc6aba788e8e</span><br><span class="line"><span class="comment"># 可以修改为唯一前缀</span></span><br><span class="line">git checkout 092d5</span><br></pre></td></tr></table></figure>
<h4 id="section"><code>^</code></h4>
<ul>
<li><code>^</code> 表示父节点</li>
<li>例如移动 <code>head</code> 到 <code>flower</code> 的父节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout flower^</span><br><span class="line"><span class="comment"># 注意如果是在 windows 命令行中, 由于 ^ 表示转义,</span></span><br><span class="line"><span class="comment"># 如下命令才是表示移动到 flower 的父节点</span></span><br><span class="line"><span class="comment"># git checkout flower^^</span></span><br></pre></td></tr></table></figure>
<ul>
<li>例如移动 <code>head</code> 到 <code>flower</code> 的祖父节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout flower^^</span><br></pre></td></tr></table></figure>
<ul>
<li>加数字表示移动到第几个父提交（存在多个父节点的时候）</li>
</ul>
<h5 id="加数字">加数字</h5>
<p><img src="/2022/10/24/Kits/learn-git/ref-number-before.png"></p>
<ul>
<li>每一个命令都是基于上面的图（状态）进行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout HEAD^^  <span class="comment"># windows</span></span><br><span class="line">git checkout HEAD^^1 <span class="comment"># windows</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Kits/learn-git/ref-number-1.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout HEAD^^2 <span class="comment"># windows</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Kits/learn-git/ref-number-2.png"></p>
<h4 id="section-1"><code>~</code></h4>
<ul>
<li><code>~N</code>：表示向前移动 <code>N</code> 个节点</li>
</ul>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout flower~1</span><br><span class="line"><span class="comment"># 等价于 git checkout flower~</span></span><br><span class="line"><span class="comment"># 等价于 git checkout flower^</span></span><br></pre></td></tr></table></figure></p>
<h4 id="链式连接">链式连接</h4>
<p><img src="/2022/10/24/Kits/learn-git/ref-number-before.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout b1^^2~3</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Kits/learn-git/ref-number-3.png"></p>
<h3 id="强制修改分支位置">强制修改分支位置</h3>
<ul>
<li>将 <code>main</code> 分支强制指向 <code>HEAD</code> 的第
<code>3</code> 级父提交</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -f main HEAD^3</span><br></pre></td></tr></table></figure>
<h3 id="撤销变更">撤销变更</h3>
<ul>
<li>原始状态</li>
</ul>
<p><img src="/2022/10/24/Kits/learn-git/before-reset-revert.png"></p>
<h4 id="reset">reset</h4>
<ul>
<li>用于本地分支的修改
<ul>
<li>相当于把哈希值为 <code>e816**</code> 结点之后的 <code>commit</code>
都取消了</li>
</ul></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset e816</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/10/24/Kits/learn-git/reset.png" alt="image-20230102154651492">
<figcaption aria-hidden="true">image-20230102154651492</figcaption>
</figure>
<h4 id="revert">revert</h4>
<ul>
<li>远程分支修改，用于合作的同步
<ul>
<li>新增加一个节点，这个节点便是取消 <code>f9f7**</code> 之后的修改</li>
</ul></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git revert f9f7</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Kits/learn-git/revert.png"></p>
<h4 id="另外的细微区别">另外的细微区别</h4>
<ul>
<li><code>git reset hashcode</code>：表示恢复到 <code>hashcode</code>
节点的状态
<ul>
<li>例如在上面的原始状态，运行
<code>git reset f9f7</code>，则无事发生（因为当前状态就是
<code>f9f7**</code> 的状态）</li>
</ul></li>
<li><code>git reset hashcode</code>：表示撤销 <code>hashcode</code>
节点之后（包括这个节点）的修改
<ul>
<li>例如在上面的原始状态，运行
<code>git reset f9f7</code>，则回到前一个结点 <code>e816**</code>
的状态</li>
</ul></li>
</ul>
<h2 id="移动提交记录">移动提交记录</h2>
<h3 id="cherry-pick">cherry-pick</h3>
<ul>
<li>将某个节点上的 commit 在当前节点上进行 commit</li>
<li>可以接多个修改</li>
</ul>
<p><img src="/2022/10/24/Kits/learn-git/before-cherry-pick.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick abd8 00ae 8ea1</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Kits/learn-git/cherry-pick.png"></p>
<ul>
<li>可以接区间
<ul>
<li>注意是左开右闭 <span class="math inline">\((a,b]\)</span></li>
</ul></li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(abd8^, 8ea1] = [abd8, 8ea1]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上面的命令等价于</span></span><br><span class="line">git cherry-pick abd8^..8ea1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># windows 版本如下</span></span><br><span class="line">git cherry-pick abd8^^..8ea1  <span class="comment"># 需要转义 ^</span></span><br></pre></td></tr></table></figure>
<h3 id="交互式-rebase">交互式 rebase</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i branch1</span><br><span class="line">git rebase --interactive branch1</span><br></pre></td></tr></table></figure>
<ul>
<li>可以选择需要当前分支上的哪些修改
<ul>
<li>可以选择 <code>pick/omit</code>（还有更多选项）</li>
<li>可以修改 commit 的顺序</li>
</ul></li>
</ul>
<p><img src="/2022/10/24/Kits/learn-git/before-rebase-i.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i e816</span><br><span class="line"><span class="comment"># 提示信息: Rebase e816ef1..2c5279a onto e816ef1 (3 commands)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># git-rebase-todo</span><br><span class="line">pick 2c5279a c</span><br><span class="line">drop c4a3404 p</span><br><span class="line">pick 49f25db m</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Kits/learn-git/rebase-i.png"></p>
<h3 id="应用">应用</h3>
<h4 id="debug">debug</h4>
<ul>
<li>debug 的时候，某些 commit 适用于输出调试信息的，debug
结束之后可以不需要这些调试的commit</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">  main</span><br><span class="line"> /</span><br><span class="line">A--------B--------C--------D bugFix*</span><br><span class="line">      (debug)  (printf)  (fixed)</span><br></pre></td></tr></table></figure>
<ul>
<li>命令如下</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git cherry-pick D</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">   D&#x27;---main*</span><br><span class="line"> /</span><br><span class="line">A--------B--------C--------D bugFix</span><br><span class="line">      (debug)  (printf)  (fixed)</span><br></pre></td></tr></table></figure>
<h4 id="修改之前的记录">修改之前的记录</h4>
<h5 id="rebase">rebase</h5>
<ul>
<li>需要对如下的 module3 进行一些修改</li>
</ul>
<figure>
<img src="/2022/10/24/Kits/learn-git/change-module3-1.png" alt="image-20230102223848364">
<figcaption aria-hidden="true">image-20230102223848364</figcaption>
</figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i bcc4</span><br><span class="line"><span class="comment"># 调换顺序</span></span><br><span class="line"><span class="comment"># pick a0cc8eb modify1</span></span><br><span class="line"><span class="comment"># pick e56f8ec modify2</span></span><br><span class="line"><span class="comment"># pick 082f9c4 add module3</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Kits/learn-git/change-module3-2.png"></p>
<ul>
<li>此时修改 <code>module3</code>，修改之后 <code>add</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add module3.txt</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<ul>
<li>修改 commit 信息</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">add module3(modify)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Kits/learn-git/change-module3-3.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i bcc4</span><br><span class="line"><span class="comment"># 调换顺序</span></span><br><span class="line"><span class="comment"># pick 603c602 add module3(modify)</span></span><br><span class="line"><span class="comment"># pick 8a1d97d modify1</span></span><br><span class="line"><span class="comment"># pick b3fb43a modify2</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Kits/learn-git/change-module3-4.png"></p>
<ul>
<li>实际操作会存在很多冲突，只有在需要修改的模块很独立，提交也比较独立的时候比较方便</li>
</ul>
<h5 id="cherry-pick-1">cherry-pick</h5>
<p><img src="/2022/10/24/Kits/learn-git/change-module3-4.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout bcc4</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Kits/learn-git/cherry-pick-1.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick 76e2</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Kits/learn-git/cherry-pick-2.png"></p>
<ul>
<li>修改 <code>module3</code>，修改之后 <code>add</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add module3.txt</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">add module3(modify2)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Kits/learn-git/cherry-pick-3.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick d7fa^^..6453 <span class="comment"># windows</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Kits/learn-git/cherry-pick-4.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git branch -f master 3e49</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Kits/learn-git/cherry-pick-5.png"></p>
<ul>
<li>好处是比 rebase 更加容易处理冲突</li>
</ul>
<h2 id="杂项">杂项</h2>
<h3 id="tag">tag</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag tagName Node <span class="comment"># unannotated tag</span></span><br></pre></td></tr></table></figure>
<ul>
<li>给节点 <code>Node</code> 打上 <code>tagName</code></li>
<li>可以被作为节点的引用</li>
<li>长久留存</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -a tagName -m tagMessage <span class="comment"># annotated tag</span></span><br></pre></td></tr></table></figure>
<h3 id="describe">describe</h3>
<ul>
<li>找到距离节点 <code>hashcode</code> 最近的一个
<code>annotated tag</code>
<ul>
<li>hashcode 默认为 HEAD</li>
</ul></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git describe hashcode</span><br></pre></td></tr></table></figure>
<ul>
<li>找到距离节点 <code>hashcode</code> 最近的一个 <code>tag</code>（包括
<code>unannotated tag</code>）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git describe hashcode --tags</span><br></pre></td></tr></table></figure>
<ul>
<li>输出格式</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">A-B-gC</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">A: tagName</span><br><span class="line">B: commit numbers from hashnode</span><br><span class="line">C: hashcode&#x27;s hash number</span><br></pre></td></tr></table></figure>
<h2 id="远程">远程</h2>
<h3 id="clone">clone</h3>
<ul>
<li>下载</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:github/pycon2011.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/github/pycon2011.git</span><br></pre></td></tr></table></figure>
<ul>
<li>此时会至少有 3 个分支
<ul>
<li><code>master</code></li>
<li><code>remotes/origin/HEAD</code>
<ul>
<li>会自动形成远程的分离 <code>HEAD</code>，无法让你操作</li>
</ul></li>
<li><code>remotes/origin/master</code></li>
</ul></li>
<li>远程分支命名规范：<code>name/branch</code></li>
<li>切换远程分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout remotes/origin/master</span><br><span class="line">git checkout origin/master</span><br></pre></td></tr></table></figure>
<ul>
<li>切换远程分支之后 <code>commit</code>，会形成本地的分离
<code>HEAD</code> 状态
<ul>
<li>不会更新远程状态</li>
</ul></li>
</ul>
<p><img src="/2022/10/24/Kits/learn-git/detached-head.png"></p>
<ul>
<li>拉取特定分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b branchName remote-link</span><br></pre></td></tr></table></figure>
<h3 id="fetch">fetch</h3>
<ul>
<li><strong>拉取所有远程分支</strong></li>
<li>不会更新本地其他分支的状态</li>
<li>不改变 <code>HEAD</code> 指针位置</li>
<li>合并分支：使用 <code>merge/cherry-pick/merge</code> 等方式</li>
</ul>
<h3 id="pull">pull</h3>
<ul>
<li><code>fetch+merge</code></li>
<li>拉取远程分支并合并
<ul>
<li><strong>只拉取当前分支</strong></li>
</ul></li>
<li>修改 <code>HEAD</code> 指针位置为最新</li>
</ul>
<h3 id="push">push</h3>
<ul>
<li>推送本地修改到远程
<ul>
<li><strong>只推送当前分支</strong></li>
</ul></li>
<li>如果是然后会更新本地<strong>对应</strong>的远程分支状态</li>
<li><code>push</code> 命令执行之前，会先将本地的记录和远程的同步
<ul>
<li>不然可能有冲突，而远程分支自身不知道如何处理</li>
</ul></li>
<li>也就是说如果 <code>push</code> 命令执行失败，需要先
<code>fetch</code> 下来处理冲突之后再 <code>push</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull --rebase</span><br><span class="line"><span class="comment"># 等价于如下的命令</span></span><br><span class="line">git fetch</span><br><span class="line">git rebase</span><br></pre></td></tr></table></figure>
<h3 id="锁定的-master-分支">锁定的 master 分支</h3>
<ul>
<li>不允许直接推送到远程的主分支，需要推送到其他分支</li>
<li>用于权限管理，大型项目开发</li>
<li>最好将 <code>master</code> 分支和 <code>remotes/origin/master</code>
分支保持一致
<ul>
<li>这样在 <code>pull</code> 的时候不要会出问题</li>
</ul></li>
</ul>
<h3 id="管理">管理</h3>
<ul>
<li>开发特性不在主分支上进行</li>
<li>专门有人合并分支</li>
</ul>
<h3 id="远程追踪">远程追踪</h3>
<ul>
<li>当前分支为 <code>master</code>，本地对应的远程分支为
<code>origin/master</code></li>
<li>push
<ul>
<li>推送本地分支到远程</li>
<li>更新 <code>origin/master</code></li>
</ul></li>
<li>pull
<ul>
<li>拉取远程分支，更新 <code>origin/master</code></li>
<li>更新 <code>master</code></li>
</ul></li>
<li>默认关联：<code>master</code> 对应 <code>origin/master</code></li>
<li>自己设定（如下两种方式都 OK）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># notMasterBranch 分支可以不存在</span></span><br><span class="line">git checkout -b notMasterBranch origin/master</span><br><span class="line"></span><br><span class="line"><span class="comment"># notMasterBranch 分支必须已经存在</span></span><br><span class="line">git branch   -u origin/master notMasterBranch</span><br></pre></td></tr></table></figure>
<h3 id="push-参数">push 参数</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push remote branch</span><br></pre></td></tr></table></figure>
<ul>
<li>在远程仓库 <code>remote</code> 中找到分支
<code>branch</code>，并将其更新，更新之后更新本地的
<code>origin/branch</code>
<ul>
<li>默认没有参数的时候，<code>branch</code> 为当前 <code>checkout</code>
的点，此时只有检出点跟踪了某个远程分支，命令才生效</li>
</ul></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push remote branch1:branch2</span><br></pre></td></tr></table></figure>
<ul>
<li>把本地的 <code>branch1</code> 分支推送到 <code>remote</code> 的
<code>branch2</code> 分支</li>
<li>支持相对引用的节点
<ul>
<li><code>branch1</code> 可以是节点</li>
</ul></li>
<li>如果 <code>branch2</code> 不存在，会自动新建</li>
</ul>
<h3 id="fetch-参数">fetch 参数</h3>
<ul>
<li>和 push 类似</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取远程的 branch 分支</span></span><br><span class="line">git fetch remote branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取远程的 branch1 节点到本地分支 branch2</span></span><br><span class="line"><span class="comment"># branch 2 不存在则会新建</span></span><br><span class="line">git fetch remote branch1:branch2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取所有远程分支</span></span><br><span class="line">git fetch</span><br></pre></td></tr></table></figure>
<ul>
<li>注意运行结束前后，当前 <code>HEAD</code> 位置不变</li>
</ul>
<h3 id="source-留空">source 留空</h3>
<ul>
<li>神奇操作</li>
<li>push：远程删除分支</li>
<li>fetch：本地新建空分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们通过给 push 传空值 source，成功删除了远程仓库中的 side 分支</span></span><br><span class="line">git push origin :side</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 fetch 空值到本地，会在本地(当前节点)创建一个新分支</span></span><br><span class="line">git fetch origin :bugFix</span><br></pre></td></tr></table></figure>
<h3 id="pull-1">pull</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin foo</span><br><span class="line"><span class="comment"># 等价于如下两条命令之和</span></span><br><span class="line">git fetch origin foo</span><br><span class="line">git merge o/foo</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin bar~1:bugFix</span><br><span class="line"><span class="comment"># 等价于如下两条命令之和</span></span><br><span class="line">git fetch origin bar~1:bugFix</span><br><span class="line">git merge bugFix</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2>
<h3 id="升级-git-版本">升级 git 版本</h3>
<ul>
<li>windows</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git update-git-for-windows</span><br></pre></td></tr></table></figure>
<h3 id="git-老是卡死">git 老是卡死</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag --column <span class="comment"># 直接卡死</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kits</category>
      </categories>
      <tags>
        <tag>Kits</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>油猴脚本</title>
    <url>/2022/03/16/Kits/ViolentMonkey/</url>
    <content><![CDATA[<h1 id="油猴脚本">油猴脚本</h1>
<ul>
<li><a href="https://www.tampermonkey.net/">tampermonkey</a></li>
<li><a href="https://violentmonkey.github.io/">暴力猴</a></li>
</ul>
<h2 id="个人网站">个人网站</h2>
<h3 id="图片显示格式">(1) 图片显示格式</h3>
<ul>
<li><code>80%</code> or <code>100%</code></li>
<li>为了适配屏幕不同的放缩情况</li>
<li><a href="/utils/show_code/index.html?ViolentMonkey/001.js">代码</a></li>
</ul>
<h2 id="github">GitHub</h2>
<ul>
<li>链接不是在当前页直接打开，而是新建一个标签页打开</li>
<li><a href="/utils/show_code/index.html?ViolentMonkey/002.js">代码</a></li>
</ul>
]]></content>
      <categories>
        <category>Kits</category>
      </categories>
      <tags>
        <tag>Kits</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>一些网站链接</title>
    <url>/2021/11/12/Kits/links/</url>
    <content><![CDATA[<h1 id="一些网站链接">一些网站链接</h1>
<h2 id="计算机">1. 计算机</h2>
<h3 id="数据库">(1) 数据库</h3>
<ul>
<li><a href="https://db-engines.com/en/ranking">数据库引擎排名</a></li>
<li>在线 SQL：<a href="http://sqlfiddle.com/">sql fiddle</a></li>
</ul>
<h3 id="matlab">(2) Matlab</h3>
<ul>
<li><a href="https://ww2.mathworks.cn/products/matlab-online.html">在线使用</a></li>
</ul>
]]></content>
      <categories>
        <category>Kits</category>
      </categories>
      <tags>
        <tag>Kits</tag>
      </tags>
  </entry>
  <entry>
    <title>obs 使用技巧</title>
    <url>/2021/10/06/Kits/obs/</url>
    <content><![CDATA[<h1 id="obs-使用技巧">obs 使用技巧</h1>
<h2 id="input-overlay">1. input-overlay</h2>
<ul>
<li>小插件，能够显示按键和鼠标</li>
<li>安装教程参考<a href="https://www.bilibili.com/video/BV1Mf4y1S7QB">B站视频</a></li>
</ul>
<h3 id="下载">(1) 下载</h3>
<ul>
<li><a href="ttps://github.com/univrsal/input-overlay/releases/tag/v4.8">GitHub</a>
<ul>
<li><a href="https://github.com/univrsal/input-overlay/releases/download/v4.8/input-overlay.v4.8b.win32.64.zip">windows
版本</a></li>
</ul></li>
</ul>
<h3 id="解压">(2) 解压</h3>
<ul>
<li>解压下载得到的 <code>input-overlay.v4.8b.win32.64.zip</code> 文件
<ul>
<li>文件夹重命名为 <code>input-overlay</code></li>
</ul></li>
<li>进入到 <code>presets</code> 文件夹下，将对应的压缩包都解压到
<code>*/</code> 文件夹下</li>
</ul>
<h3 id="安装">(3) 安装</h3>
<ul>
<li>我的 <code>obs</code> 安装路径为
<code>D:\installed application\obs-studio\</code></li>
<li>文件移动
<ul>
<li>我的版本是 <code>64-bit</code>，因此只操作 <code>64-bit</code>
的</li>
</ul></li>
</ul>
<table>
<colgroup>
<col style="width: 55%">
<col style="width: 44%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">下载解压插件</th>
<th style="text-align: center;">obs 安装目录</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>input-overlay\plugin\data\obs-plugins\*</code></td>
<td style="text-align: center;"><code>obs-studio\data\obs-plugins\</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>input-overlay\plugin\obs-plugins\64bit\*</code></td>
<td style="text-align: center;"><code>obs-studio\obs-plugins\64bit\</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>input-overlay\presets\*</code></td>
<td style="text-align: center;"><code>obs-studioinput-overlay\presets\</code></td>
</tr>
</tbody>
</table>
<ul>
<li>其中 <code>presets</code>
文件夹只需要保存在自己找的到的地方即可</li>
</ul>
]]></content>
      <categories>
        <category>Kits</category>
      </categories>
      <tags>
        <tag>Kits</tag>
        <tag>obs</tag>
      </tags>
  </entry>
  <entry>
    <title>一些 webapi</title>
    <url>/2021/11/23/Kits/webapi/</url>
    <content><![CDATA[<h1 id="webapi">webapi</h1>
<h2 id="百度">1. 百度</h2>
<h3 id="关键词提示">(1) 关键词提示</h3>
<ul>
<li>方式一</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://suggestion.baidu.com/su?wd=你好</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">baidu</span>.<span class="title function_">sug</span>(&#123;<span class="attr">q</span>:<span class="string">&quot;你好&quot;</span>,<span class="attr">p</span>:<span class="literal">false</span>,<span class="attr">s</span>:[<span class="string">&quot;你好李焕英&quot;</span>,<span class="string">&quot;你好李焕英电影免费版高清在线观看&quot;</span>,<span class="string">&quot;你好,母亲大人&quot;</span>,<span class="string">&quot;你好旧时光&quot;</span>,<span class="string">&quot;你好对方辩友&quot;</span>,<span class="string">&quot;你好检察官&quot;</span>,<span class="string">&quot;你好的英文&quot;</span>,<span class="string">&quot;你好生活&quot;</span>,<span class="string">&quot;你好再见,妈妈&quot;</span>,<span class="string">&quot;你好对方辩友2&quot;</span>]&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>方式二</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">https://www.baidu.com/sugrec?ie=utf-8&amp;prod=pc&amp;wd=你好</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;q&quot;</span><span class="punctuation">:</span><span class="string">&quot;你好&quot;</span><span class="punctuation">,</span><span class="attr">&quot;p&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span><span class="attr">&quot;g&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;sug&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sa&quot;</span><span class="punctuation">:</span><span class="string">&quot;s_1&quot;</span><span class="punctuation">,</span><span class="attr">&quot;q&quot;</span><span class="punctuation">:</span><span class="string">&quot;你好李焕英&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;sug&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sa&quot;</span><span class="punctuation">:</span><span class="string">&quot;s_2&quot;</span><span class="punctuation">,</span><span class="attr">&quot;q&quot;</span><span class="punctuation">:</span><span class="string">&quot;你好,母亲大人&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;sug&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sa&quot;</span><span class="punctuation">:</span><span class="string">&quot;s_3&quot;</span><span class="punctuation">,</span><span class="attr">&quot;q&quot;</span><span class="punctuation">:</span><span class="string">&quot;你好旧时光&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;sug&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sa&quot;</span><span class="punctuation">:</span><span class="string">&quot;s_4&quot;</span><span class="punctuation">,</span><span class="attr">&quot;q&quot;</span><span class="punctuation">:</span><span class="string">&quot;你好李焕英电影免费版高清在线观看&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;sug&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sa&quot;</span><span class="punctuation">:</span><span class="string">&quot;s_5&quot;</span><span class="punctuation">,</span><span class="attr">&quot;q&quot;</span><span class="punctuation">:</span><span class="string">&quot;你好的英文&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;sug&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sa&quot;</span><span class="punctuation">:</span><span class="string">&quot;s_6&quot;</span><span class="punctuation">,</span><span class="attr">&quot;q&quot;</span><span class="punctuation">:</span><span class="string">&quot;你好生活&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;sug&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sa&quot;</span><span class="punctuation">:</span><span class="string">&quot;s_7&quot;</span><span class="punctuation">,</span><span class="attr">&quot;q&quot;</span><span class="punctuation">:</span><span class="string">&quot;你好对方辩友&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;sug&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sa&quot;</span><span class="punctuation">:</span><span class="string">&quot;s_8&quot;</span><span class="punctuation">,</span><span class="attr">&quot;q&quot;</span><span class="punctuation">:</span><span class="string">&quot;你好检察官&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;sug&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sa&quot;</span><span class="punctuation">:</span><span class="string">&quot;s_9&quot;</span><span class="punctuation">,</span><span class="attr">&quot;q&quot;</span><span class="punctuation">:</span><span class="string">&quot;你好火焰蓝&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;sug&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sa&quot;</span><span class="punctuation">:</span><span class="string">&quot;s_10&quot;</span><span class="punctuation">,</span><span class="attr">&quot;q&quot;</span><span class="punctuation">:</span><span class="string">&quot;你好乔安&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;slid&quot;</span><span class="punctuation">:</span><span class="string">&quot;6452960271384873924&quot;</span><span class="punctuation">,</span><span class="attr">&quot;queryid&quot;</span><span class="punctuation">:</span><span class="string">&quot;0x96852d759a8bc4&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="百度翻译">(2) 百度翻译</h3>
<ul>
<li><strong>需要注册</strong>，<a href="http://api.fanyi.baidu.com/">链接</a></li>
</ul>
<h2 id="bilibili">2. Bilibili</h2>
<h3 id="关注列表">(1) 关注列表</h3>
<ul>
<li>最后面加上 uid
<ul>
<li><a href="https://space.bilibili.com/546195">老番茄</a></li>
</ul></li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">https://api.bilibili.com/x/relation/followings?vmid=546195</span><br></pre></td></tr></table></figure>
<h2 id="奇奇怪怪">3. 奇奇怪怪</h2>
<h3 id="纸金网">(1) 纸金网</h3>
<ul>
<li><a href="http://gold.zhijinwang.com/">纸金网</a></li>
<li>当前时刻下的各种金价</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">http://quote.zhijinwang.com/xml/ag.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">time=10:48:01&amp;gold=|4.987|4.967|5.007|5.053|4.948|24.2940|96.56|76.31</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kits</category>
      </categories>
      <tags>
        <tag>Kits</tag>
      </tags>
  </entry>
  <entry>
    <title>代码练习(2018 计算机学科夏令营上机考试)</title>
    <url>/2021/07/17/Code/code-1/</url>
    <content><![CDATA[<ul>
<li><a href="http://bailian.openjudge.cn/xly2018/">2018计算机学科夏令营上机考试</a></li>
</ul>
<h1 id="题目">题目</h1>
<ul>
<li><a href="http://noi.openjudge.cn/ch0113/25/">计算两个日期之间的天数</a></li>
<li><a href="http://cxsjsx.openjudge.cn/practise2021pool/11B/">回文子串</a></li>
<li><a href="http://bailian.openjudge.cn/practice/1481/">The Die Is
Cast</a></li>
<li><a href="http://bailian.openjudge.cn/practice/1252/">Euro
Efficiency</a></li>
<li><a href="http://algorithm.openjudge.cn/201919191919/18xlyB/">重要逆序对</a></li>
<li><a href="http://bailian.openjudge.cn/practice/1847/">Tram</a></li>
<li><a href="http://bailian.openjudge.cn/practice/1182/">食物链</a></li>
<li><a href="http://bailian.openjudge.cn/practice/4063/">DFS spanning
tree</a></li>
</ul>
<h2 id="计算两个日期之间的天数">计算两个日期之间的天数</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-1/A.cpp">代码</a></li>
<li>模拟即可</li>
<li>年份范围 1-3000，暴力枚举即可</li>
</ul>
<h2 id="回文子串">回文子串</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-1/B.cpp">代码</a></li>
<li>暴力枚举即可</li>
</ul>
<h2 id="the-die-is-cast">The Die Is Cast</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-1/C.cpp">代码</a></li>
<li>第一遍 dfs，为每一个芯片标号</li>
<li>第二遍 dfs，找出每个芯片上的非连通 X 数目</li>
<li>可以合并</li>
</ul>
<h2 id="euro-efficiency">Euro Efficiency</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-1/D.cpp">代码</a></li>
<li>题意
<ul>
<li>给定 6 种面值的硬币（数量无限），让他们组成 1-100 的数</li>
<li>dp[i] 表示组成面值 i 花费的最小硬币数</li>
<li>求出 <span class="math inline">\(\dfrac{\sum_{i=1}^{100}\mathrm{dp[i]}}{100}\)</span>
和 <span class="math inline">\(\max{\mathrm{dp[i]}}\)</span></li>
</ul></li>
<li>可以使用加法得到结果，也可以使用减法得到结果</li>
<li>dp 迭代至不动点即可</li>
<li>注意数组要开大，因为可能出现如下情况
<ul>
<li>可以先构造出大于 100 的, 然后差值减到 100 以下</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 5 25 30 80 81</span></span><br><span class="line"><span class="comment">// 100 = 80+25-5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>最大为 100，因此数组开到 600 就够了</li>
</ul>
<h2 id="重要逆序对">重要逆序对</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-1/E.cpp">代码</a></li>
<li>归并排序的思想，在归并的时候计算重要逆序对数</li>
<li>归并和计算的过程得分为两个</li>
</ul>
<h2 id="tram">Tram</h2>
<ul>
<li>Floyd 算法
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-1/F-Floyd.cpp">代码</a></li>
</ul></li>
<li>Bellman-Ford 算法
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-1/F-Bellman-Ford.cpp">代码</a></li>
</ul></li>
<li><strong>注意输入某个结点可能指向 0 条边</strong></li>
</ul>
<h2 id="食物链">食物链</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-1/G.cpp">代码</a></li>
<li>并查集</li>
<li>能够确定关系的放在一个集合里</li>
</ul>
<h2 id="dfs-spanning-tree">DFS spanning tree</h2>
<ul>
<li><span style="color:red;font-weight:bold">TODO</span></li>
<li>DFS 树的特征是，所有的非树边边都是由子结点指向祖先结点</li>
</ul>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>并查集</tag>
        <tag>排序</tag>
        <tag>DP</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>代码练习(2007 图形实验室研究生入学考试)</title>
    <url>/2021/07/19/Code/code-4/</url>
    <content><![CDATA[<ul>
<li><a href="http://bailian.openjudge.cn/contest1404/">图形实验室研究生入学考试</a></li>
</ul>
<h1 id="题目">题目</h1>
<ul>
<li><a href="http://bailian.openjudge.cn/practice/2719/">陶陶摘苹果</a></li>
<li><a href="http://bailian.openjudge.cn/practice/2807/">两倍</a></li>
<li><a href="http://bailian.openjudge.cn/practice/2753/">菲波那契数列</a></li>
<li><a href="http://bailian.openjudge.cn/practice/2760/">数字三角形</a></li>
<li><a href="http://bailian.openjudge.cn/practice/2756/">二叉树</a></li>
<li><a href="http://bailian.openjudge.cn/practice/2816/">红与黑</a></li>
<li><a href="http://bailian.openjudge.cn/practice/1922/">Ride to
School</a></li>
<li><a href="http://bailian.openjudge.cn/practice/2051/">Argus</a></li>
</ul>
<h2 id="陶陶摘苹果">陶陶摘苹果</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-4/A.cpp">代码</a></li>
<li>模拟</li>
</ul>
<h2 id="两倍">两倍</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-4/B.cpp">代码</a></li>
<li>可以复用
<ul>
<li>1 2 4 中有两对</li>
</ul></li>
</ul>
<h2 id="菲波那契数列">菲波那契数列</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-4/C.cpp">代码</a></li>
<li>先计算数列，在读取输入输出结果</li>
</ul>
<h2 id="数字三角形">数字三角形</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-4/D.cpp">代码</a></li>
<li>DP</li>
</ul>
<h2 id="二叉树">二叉树</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-4/E.cpp">代码</a></li>
<li>lca 在完全二叉树上的实现</li>
<li>暴力可过</li>
</ul>
<h2 id="红与黑">红与黑</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-4/F.cpp">代码</a></li>
<li>DFS</li>
<li>注意题目给的输入末尾有空格，但是实际上的输入是没有的，测试的时候得注意下</li>
</ul>
<h2 id="ride-to-school">Ride to School</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-4/G.cpp">代码</a></li>
<li>找到最先到而且出发时间为正的人即可</li>
</ul>
<h2 id="argus">Argus</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-4/H.cpp">代码</a></li>
<li>使用堆即可</li>
</ul>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>DP</tag>
        <tag>DFS</tag>
        <tag>tree</tag>
        <tag>STL</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>普吕克坐标(Plücker Coordinates) 简介</title>
    <url>/2021/10/07/Math/Pl%C3%BCcker-Coordinates/</url>
    <content><![CDATA[<h1 id="普吕克坐标">普吕克坐标</h1>
<ul>
<li>Plücker Coordinates</li>
<li>3
维欧氏空间的一条直线被两个其上不同的点确定，或者被两个包含这条直线的平面确定</li>
</ul>
<h2 id="几何定义">几何定义</h2>
<h3 id="两个点导出">两个点导出</h3>
<ul>
<li>直线 <span class="math inline">\(L\)</span>，考虑 <span class="math inline">\(L\)</span> 上两个<strong>不同</strong>的点：<span class="math inline">\(x=(x_{1},x_{2},x_{3}),y=(y_{1},y_{2},y_{3})\)</span></li>
<li><span class="math inline">\(d=y-x\)</span></li>
<li>矩：<span class="math inline">\(m={x}\times{y}\)</span>
<ul>
<li>质点从 <span class="math inline">\(x\)</span> 移动到 <span class="math inline">\(y\)</span> 的矩</li>
<li><span class="math inline">\(m\)</span> 的大小为三角形 <span class="math inline">\(Oxy\)</span> 面积的两倍，正比于 <span class="math inline">\(d\)</span> 的大小</li>
</ul></li>
</ul>
<p><img src="/2021/10/07/Math/Pl%C3%BCcker-Coordinates/pic1.jpg" style="zoom:67%;"></p>
<ul>
<li><span class="math inline">\({d}\cdot{m}=0\)</span>
<ul>
<li>垂直</li>
</ul></li>
<li>单独 <span class="math inline">\(d\)</span> 或者 <span class="math inline">\(m\)</span> 都无法唯一确定直线 <span class="math inline">\(L\)</span>，他们俩才能唯一确定直线 <span class="math inline">\(L\)</span></li>
<li>定义齐次坐标如下</li>
</ul>
<p><span class="math display">\[
(d:m)=(d_1:d_2:d_3:m_1:m_2:m_3)
\]</span></p>
<ul>
<li>其中</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\begin{array}{c}
d_1=y_1-x_1\\
d_2=y_2-x_2\\
d_3=y_3-x_3\\
m_1=x_2y_3-y_2x_3\\
m_2=x_3y_1-y_3x_1\\
m_3=x_1y_2-y_1x_2\\
\end{array}
\end{aligned}
\]</span></p>
<ul>
<li>所有的 <span class="math inline">\((\lambda d:\lambda
m),\lambda\ne0\)</span> 都可以由直线 <span class="math inline">\(L\)</span> 上不同的两个点生成</li>
<li><span class="math inline">\((d:m)\)</span> 就是普吕克坐标</li>
</ul>
<h2 id="代数定义">代数定义</h2>
<ul>
<li>直线 <span class="math inline">\(L\)</span> 穿过两个点 <span class="math inline">\(x,y\)</span>，他们的齐次坐标表示为 <span class="math inline">\(x=(x_0,x_1,x_2,x_3),y=(y_0,y_1,y_2,y_3)\)</span>
<ul>
<li>坐标 0 为其次项</li>
</ul></li>
<li>定义普吕克坐标为 <span class="math inline">\(p_{ij}=x_iy_j-x_jy_i\)</span>
<ul>
<li><span class="math inline">\(p_{ii}=0,p_{ij}=-p_{ji}\)</span></li>
</ul></li>
<li>因此只有 6 个独立变量，对应普吕克坐标</li>
</ul>
<p><span class="math display">\[
(p_{01}:p_{02}:p_{03}:p_{23}:p_{31}:p_{12})
\]</span></p>
<h2 id="线线相交">线线相交</h2>
<ul>
<li>3 维欧氏空间中，两条直线 <span class="math inline">\(L,L&#39;\)</span> 相交则有</li>
</ul>
<p><span class="math display">\[
d\cdot m&#39;+m\cdot d=0
\]</span></p>
<ul>
<li>其中 <span class="math inline">\(p_{ij},p_{ij}&#39;\)</span> 是
<span class="math inline">\(L,L&#39;\)</span> 的普吕克矩阵</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
0&amp;=p_{01}p&#39;_{23}+p_{02}p&#39;_{31}+p_{03}p&#39;_{12}+p_{23}p&#39;_{01}+p_{31}p&#39;_{02}+p_{12}p&#39;_{03}\\
&amp;=
\begin{vmatrix}
x_{0}&amp;y_{0}&amp;x&#39;_{0}&amp;y&#39;_{0}\\
x_{1}&amp;y_{1}&amp;x&#39;_{1}&amp;y&#39;_{1}\\
x_{2}&amp;y_{2}&amp;x&#39;_{2}&amp;y&#39;_{2}\\
x_{3}&amp;y_{3}&amp;x&#39;_{3}&amp;y&#39;_{3}
\end{vmatrix}
\end{aligned}
\]</span></p>
<ul>
<li>如果不相交，上面式子的正负表示方向
<ul>
<li>正：<span class="math inline">\(L\)</span> 为大拇指，<span class="math inline">\(L&#39;\)</span> 的方向为右手螺旋</li>
<li>负：<span class="math inline">\(L\)</span> 为大拇指，<span class="math inline">\(L&#39;\)</span> 的方向为左手螺旋</li>
</ul></li>
</ul>
<p><img src="/2021/10/07/Math/Pl%C3%BCcker-Coordinates/image-20211007111659627.png" style="zoom:67%;"></p>
<h3 id="齐次坐标行列式为-0">齐次坐标行列式为 0</h3>
<h4 id="二维平面">二维平面</h4>
<ul>
<li><span class="math inline">\(A(x_a,y_a),B(x_b,y_b),C(x_c,y_c)\)</span> 三点共线
等价于这三个点的齐次坐标组成的行列式值为 0</li>
</ul>
<p><span class="math display">\[
\begin{vmatrix}
x_{a}&amp;x_{b}&amp;x_{c}\\
y_{a}&amp;y_{b}&amp;y_{c}\\
1&amp;1&amp;1\\
\end{vmatrix}
\]</span></p>
<ul>
<li><span class="math inline">\(\vec{AB}=k\cdot\vec{AC}\)</span>
<ul>
<li>齐次项化为 1 之后，再相减，此时第三维为 0</li>
</ul></li>
<li>说明线性相关，行列式为 0</li>
</ul>
<h4 id="三维平面">三维平面</h4>
<ul>
<li>类似的，首先将齐次项化为
1，通过同时减去某一列，判断其是否线性相关即可</li>
</ul>
<p><span class="math display">\[
\begin{vmatrix}
x_{0}&amp;y_{0}&amp;x&#39;_{0}&amp;y&#39;_{0}\\
x_{1}&amp;y_{1}&amp;x&#39;_{1}&amp;y&#39;_{1}\\
x_{2}&amp;y_{2}&amp;x&#39;_{2}&amp;y&#39;_{2}\\
x_{3}&amp;y_{3}&amp;x&#39;_{3}&amp;y&#39;_{3}
\end{vmatrix}
\]</span></p>
<ul>
<li><span class="math inline">\(\vec{AB}=k_1\cdot\vec{AC}+k_2\cdot\vec{AD}\)</span></li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Pl%C3%BCcker_coordinates">维基百科</a></li>
</ul>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>普吕克坐标</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>代码练习(2017 计算机学科夏令营上机考试)</title>
    <url>/2021/07/19/Code/code-3/</url>
    <content><![CDATA[<ul>
<li><a href="http://bailian.openjudge.cn/xly2017">2017计算机学科夏令营上机考试</a></li>
</ul>
<h1 id="题目">题目</h1>
<ul>
<li><a href="http://bailian.openjudge.cn/practice/3177/">判决素数个数</a></li>
<li>编码字符串(string)</li>
<li>岛屿周长(matrix)</li>
<li><a href="http://bailian.openjudge.cn/practice/1248/">Safecracker</a></li>
<li>怪盗基德的滑翔翼</li>
<li><a href="http://bailian.openjudge.cn/practice/3761/">Full
Tank?</a></li>
<li><a href="http://bailian.openjudge.cn/practice/4078/">实现堆结构</a></li>
<li><a href="http://bailian.openjudge.cn/practice/2502/">Subway</a></li>
<li><a href="http://bailian.openjudge.cn/practice/2115/">C
Looooops</a></li>
<li>Captain Q's Treasure</li>
</ul>
<h2 id="判决素数个数">判决素数个数</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-3/A.cpp">代码</a></li>
<li>注意输入的两个数，第一个数可能比第二个数大</li>
</ul>
<h2 id="编码字符串string">编码字符串(string)</h2>
<h2 id="岛屿周长matrix">岛屿周长(matrix)</h2>
<h2 id="safecracker">Safecracker</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-3/D.cpp">代码</a></li>
<li>预处理 + 暴力枚举</li>
</ul>
<h2 id="怪盗基德的滑翔翼">怪盗基德的滑翔翼</h2>
<h2 id="full-tank">Full Tank?</h2>
<ul>
<li>最短路问题</li>
<li>Bellman-Ford 算法
<ul>
<li><span class="math inline">\(O(mncc)\)</span></li>
<li><a href="/utils/show_code/index.html?OJ/code-3/F-BF-TLE.cpp">TLE</a></li>
</ul></li>
<li>Dijkstra 算法
<ul>
<li><span class="math inline">\(O((m+n+c)\log(m+nc))\)</span></li>
<li><a href="/utils/show_code/index.html?OJ/code-3/F-Dijkstra.cpp">OK</a></li>
</ul></li>
</ul>
<h2 id="实现堆结构">实现堆结构</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-3/G.cpp">代码</a></li>
<li>STL 优先队列的应用</li>
</ul>
<h2 id="subway">Subway</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-3/H.cpp">代码</a></li>
<li>最短路
<ul>
<li>建图比较麻烦</li>
</ul></li>
</ul>
<h2 id="c-looooops">C Looooops</h2>
<ul>
<li><span style="color:red;font-weight:bold">TODO</span></li>
<li>扩展欧几里得算法</li>
<li>探究如下等式的整数解 <span class="math inline">\(x\)</span></li>
</ul>
<p><span class="math display">\[
(A+Cx)\;\%\;{2^k}=B
\]</span></p>
<ul>
<li>变形</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
(2^k)y+B=A+Cx\\
Cx+(-2^k)y=B-A
\end{aligned}
\]</span></p>
<ul>
<li>参考资料
<ul>
<li><a href="https://blog.csdn.net/u010579068/article/details/45441005">C
Looooops（欧几里德+poj2115）</a></li>
</ul></li>
</ul>
<h2 id="captain-qs-treasure">Captain Q's Treasure</h2>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>最短路</tag>
        <tag>STL</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>代码练习(2019 计算机学科夏令营上机考试)</title>
    <url>/2021/07/18/Code/code-2/</url>
    <content><![CDATA[<ul>
<li><a href="http://bailian.openjudge.cn/xly2019/">2019计算机学科夏令营上机考试</a></li>
</ul>
<h1 id="题目">题目</h1>
<ul>
<li>数与字符串</li>
<li><a href="http://noi.openjudge.cn/ch0113/24/">打印月历</a></li>
<li>Hopscotch</li>
<li>上楼梯</li>
<li><a href="http://bailian.openjudge.cn/practice/1414/">Life
Line</a></li>
<li>跳蛙</li>
<li><a href="http://bailian.openjudge.cn/practice/1577/">Falling
Leaves</a></li>
<li><a href="http://bailian.openjudge.cn/practice/1062/">昂贵的聘礼</a></li>
<li><a href="http://poj.org/problem?id=2706">Connect</a></li>
</ul>
<h2 id="数与字符串">数与字符串</h2>
<h2 id="打印月历">打印月历</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-2/B.cpp">代码</a></li>
<li>注意细节，我把 1900 打成了 1990 竟然能过 90% 样例</li>
<li>如下，真 TM 太巧了</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">// 1900 1</span><br><span class="line">Sun Mon Tue Wed Thu Fri Sat</span><br><span class="line">      1   2   3   4   5   6</span><br><span class="line">  7   8   9  10  11  12  13</span><br><span class="line"> 14  15  16  17  18  19  20</span><br><span class="line"> 21  22  23  24  25  26  27</span><br><span class="line"> 28  29  30  31</span><br><span class="line"></span><br><span class="line">// 1990 1</span><br><span class="line">Sun Mon Tue Wed Thu Fri Sat</span><br><span class="line">      1   2   3   4   5   6</span><br><span class="line">  7   8   9  10  11  12  13</span><br><span class="line"> 14  15  16  17  18  19  20</span><br><span class="line"> 21  22  23  24  25  26  27</span><br><span class="line"> 28  29  30  31</span><br></pre></td></tr></table></figure>
<h2 id="hopscotch">Hopscotch</h2>
<h2 id="上楼梯">上楼梯</h2>
<h2 id="life-line">Life Line</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-2/E.cpp">代码</a></li>
<li>DFS 深搜</li>
</ul>
<h2 id="跳蛙">跳蛙</h2>
<h2 id="falling-leaves">Falling Leaves</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-2/G.cpp">代码</a></li>
<li>一棵树，每次去掉它的叶子结点（去掉的结点形成一个序列），通过这个序列恢复这棵树，并输出前序遍历的结果</li>
<li>注意是 BST 树</li>
<li>输入保证结果唯一</li>
</ul>
<h2 id="昂贵的聘礼">昂贵的聘礼</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-2/H.cpp">代码</a></li>
<li>注意一个坑，酋长的等级不一定是最高的</li>
<li>每次限制能够交换的等级范围，然后使用 Floyd 算法即可
<ul>
<li>范围通过枚举决定（复杂度较高）</li>
</ul></li>
</ul>
<h2 id="connect">Connect</h2>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>最短路</tag>
        <tag>DFS</tag>
        <tag>tree</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>代码练习(2019 大数据科学研究中心全国优秀大学生夏令营机试)</title>
    <url>/2021/07/30/Code/code-6/</url>
    <content><![CDATA[<ul>
<li><a href="http://bailian.openjudge.cn/2019bigdatacamp/2/">2019大数据科学研究中心全国优秀大学生夏令营机试</a></li>
</ul>
<h1 id="题目">题目</h1>
<ul>
<li>最近点对</li>
<li><a href="http://noi.openjudge.cn/ch0110/08/">病人排队</a></li>
<li><a href="http://bailian.openjudge.cn/practice/1064/">网线主管</a></li>
<li><a href="http://bailian.openjudge.cn/practice/1321/">棋盘问题</a></li>
<li><a href="http://cxsjsx.openjudge.cn/practise2021pool/12B/">移动办公</a></li>
<li><a href="http://bailian.openjudge.cn/practice/3421/">螺旋加密</a></li>
<li><a href="http://bailian.openjudge.cn/practice/4128/">单词序列</a></li>
<li>区间异或和</li>
<li><a href="http://bailian.openjudge.cn/practice/1185/">炮兵阵地</a></li>
<li><a href="http://cxsjsx.openjudge.cn/practise2021pool/09H/">迷宫入口</a></li>
</ul>
<h2 id="最近点对">最近点对</h2>
<ul>
<li><span style="font-weight:bold;color:red">没找到</span></li>
</ul>
<h2 id="病人排队">病人排队</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-6/2.cpp">代码</a></li>
<li>排序</li>
</ul>
<h2 id="网线主管">网线主管</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-6/3.cpp">代码</a></li>
<li>二分</li>
<li>不能用 float，精度约为 7 位小数（double 可以过）</li>
</ul>
<h2 id="棋盘问题">棋盘问题</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-6/4.cpp">代码</a></li>
<li>DFS</li>
</ul>
<h2 id="移动办公">移动办公</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-6/5.cpp">代码</a></li>
<li>动态规划</li>
</ul>
<h2 id="螺旋加密">螺旋加密</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-6/6.cpp">代码</a></li>
<li>模拟</li>
</ul>
<h2 id="单词序列">单词序列</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-6/7.cpp">代码</a></li>
<li>最短路
<ul>
<li>Floyd 就足够了</li>
</ul></li>
</ul>
<h2 id="区间异或和">区间异或和</h2>
<ul>
<li><span style="font-weight:bold;color:red">没找到原题</span></li>
<li>一个类似的题目：<a href="http://cpp.zjut.edu.cn/ShowProblem.aspx?ShowID=1561">区间异或</a>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-6/8-zjut-1561.cpp">代码</a></li>
<li>线段树</li>
</ul></li>
</ul>
<h2 id="炮兵阵地">炮兵阵地</h2>
<ul>
<li><span style="font-weight:bold;color:red">TODO</span></li>
<li>状态压缩 + 动态规划</li>
</ul>
<h2 id="迷宫入口">迷宫入口</h2>
<ul>
<li><span style="font-weight:bold;color:red">TODO</span></li>
</ul>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>DP</tag>
        <tag>最短路</tag>
        <tag>DFS</tag>
        <tag>二分</tag>
        <tag>Floyd</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>代码练习(2019 研究生推免上机考试)</title>
    <url>/2021/07/29/Code/code-5/</url>
    <content><![CDATA[<ul>
<li><a href="http://bailian.openjudge.cn/tm2019/">2019
研究生推免上机考试</a></li>
</ul>
<h1 id="题目">题目</h1>
<ul>
<li><a href="http://bailian.openjudge.cn/practice/2575/">有趣的跳跃</a></li>
<li><a href="http://bailian.openjudge.cn/practice/2965/">玛雅历</a></li>
<li><a href="http://bailian.openjudge.cn/practice/3752/">走迷宫</a></li>
<li><a href="http://noi.openjudge.cn/ch0206/3532/">最大上升子序列和</a></li>
<li><a href="http://bailian.openjudge.cn/practice/2393/">Yogurt
factory</a></li>
<li><a href="http://bailian.openjudge.cn/practice/2236/">Wireless
Network</a></li>
<li><a href="http://bailian.openjudge.cn/practice/2349/">Arctic
Network</a></li>
<li>Chinese Poker</li>
</ul>
<h2 id="有趣的跳跃">有趣的跳跃</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-5/A.cpp">代码</a></li>
<li>模拟 + 排序</li>
</ul>
<h2 id="玛雅历">玛雅历</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-5/B.cpp">代码</a></li>
<li>模拟</li>
</ul>
<h2 id="走迷宫">走迷宫</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-5/C.cpp">代码</a></li>
<li>广搜（BFS）</li>
</ul>
<h2 id="最大上升子序列和">最大上升子序列和</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-5/D.cpp">代码</a></li>
<li>动态规划</li>
</ul>
<h2 id="yogurt-factory">Yogurt factory</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-5/E.cpp">代码</a></li>
<li>暴力循环</li>
</ul>
<h2 id="wireless-network">Wireless Network</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-5/F.cpp">代码</a></li>
<li>并查集</li>
</ul>
<h2 id="arctic-network">Arctic Network</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-5/G.cpp">代码</a></li>
<li>二分 + BFS</li>
</ul>
<h2 id="chinese-poker">Chinese Poker</h2>
<ul>
<li><span style="font-weight:bold;color:red">没找到</span></li>
</ul>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>并查集</tag>
        <tag>DP</tag>
        <tag>二分</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>代码练习(2021 图形学实验室夏令营机试)</title>
    <url>/2021/07/31/Code/code-7/</url>
    <content><![CDATA[<ul>
<li><a href="http://bailian.openjudge.cn/test20210731/">2021
图形学实验室夏令营机试</a></li>
</ul>
<h1 id="题目">题目</h1>
<ul>
<li><a href="http://bailian.openjudge.cn/practice/2677/">肿瘤检测</a></li>
<li><a href="http://noi.openjudge.cn/ch0107/25/">最长最短单词</a></li>
<li><a href="http://bailian.openjudge.cn/practice/2659/">Bomb
Game</a></li>
<li>括号生成</li>
<li>哥斯拉大战金刚</li>
<li>删除数字</li>
<li><a href="http://dsa.openjudge.cn/binarytree/0509/">表达式·表达式树·表达式求值</a></li>
<li><a href="http://bailian.openjudge.cn/practice/2502/">Subway</a></li>
<li><a href="http://algorithm.openjudge.cn/201919191919/18xlyB/">重要逆序对</a></li>
<li>构建世界</li>
</ul>
<h2 id="肿瘤检测">肿瘤检测</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-7/A.cpp">代码</a></li>
<li>循环</li>
</ul>
<h2 id="最长最短单词">最长最短单词</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-7/B.cpp">代码</a></li>
<li>排序</li>
</ul>
<h2 id="bomb-game">Bomb Game</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-7/C.cpp">代码</a></li>
<li>模拟</li>
</ul>
<h2 id="括号生成">括号生成</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-7/D.cpp">代码</a></li>
<li>DFS</li>
</ul>
<h2 id="哥斯拉大战金刚">哥斯拉大战金刚</h2>
<ul>
<li><span style="font-weight:bold;color:red">没找到原题</span></li>
<li>BFS</li>
</ul>
<h2 id="删除数字">删除数字</h2>
<ul>
<li>原来的比赛关闭了，另外 OJ 上的题目
<ul>
<li>只有输出格式有所差别</li>
<li><a href="https://wzoi.cc/s/1/785">题目链接</a></li>
</ul></li>
<li>动态规划</li>
<li><a href="/utils/show_code/index.html?OJ/code-7/F-wzoi-785.cpp">代码</a></li>
</ul>
<h2 id="表达式表达式树表达式求值">表达式·表达式树·表达式求值</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code/7.cpp">代码</a></li>
</ul>
<h2 id="subway">Subway</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-7/H.cpp">代码</a></li>
<li>最短路</li>
</ul>
<h2 id="重要逆序对">重要逆序对</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code-7/I.cpp">代码</a></li>
<li>归并排序</li>
</ul>
<h2 id="构建世界">构建世界</h2>
<ul>
<li><span style="font-weight:bold;color:red">没找到原题</span></li>
</ul>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>DP</tag>
        <tag>最短路</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>代码练习</title>
    <url>/2021/06/16/Code/code/</url>
    <content><![CDATA[<h1 id="题目">题目</h1>
<ul>
<li><a href="http://ica.openjudge.cn/string/5/">单词排序</a></li>
<li><a href="http://bailian.openjudge.cn/practice/4133">垃圾炸弹</a></li>
<li><a href="http://bailian.openjudge.cn/practice/1664">放苹果</a></li>
<li><a href="http://bailian.openjudge.cn/practice/1979">Red and
Black</a></li>
<li><a href="http://bailian.openjudge.cn/practice/4119">复杂的整数划分问题</a></li>
<li><a href="http://dsalgo.openjudge.cn/graph/1/">兔子与樱花</a></li>
<li><a href="http://dsalgo.openjudge.cn/binarytree/7/">表达式·表达式树·表达式求值</a></li>
<li><a href="http://bailian.openjudge.cn/practice/1986">Distance
Queries</a></li>
</ul>
<h2 id="单词排序">单词排序</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code/1.cpp">代码</a></li>
<li>简单的排序题，同时可以学习下 STL 中的如下函数
<ul>
<li><code>iterator unique(iterator it_1,iterator it_2);</code>
<ul>
<li>返回去重后的最后一个元素的下一个元素</li>
<li>调用前需要先排序</li>
</ul></li>
</ul></li>
</ul>
<h2 id="垃圾炸弹">垃圾炸弹</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code/2.cpp">代码</a></li>
<li>暴力枚举所有点即可</li>
</ul>
<h2 id="放苹果">放苹果</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code/3.cpp">代码</a></li>
<li>简单递归</li>
<li>记忆化搜索
<ul>
<li>分类：有盘子不放，所有盘子都放</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">apple(m, k) = apple(m - k, k) + apple(m, k - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="red-and-black">Red and Black</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code/4.cpp">代码</a></li>
<li>深搜</li>
<li>找到起始点相邻的所有黑色格子</li>
<li>输入输出格式比较麻烦</li>
</ul>
<h2 id="复杂的整数划分问题">复杂的整数划分问题</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code/5.cpp">代码</a></li>
<li>动态规划
<ul>
<li>逐个尝试，状态转移的时候添加一维，表示当前拆分最小的数为
<code>min_val</code></li>
</ul></li>
<li>注意一些细节，详情见代码</li>
<li>输入有多组，注意复用</li>
<li>记忆化</li>
</ul>
<h2 id="兔子与樱花">兔子与樱花</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code/6.cpp">代码</a></li>
<li>Floyd 最短路</li>
</ul>
<h2 id="表达式表达式树表达式求值">表达式·表达式树·表达式求值</h2>
<ul>
<li><a href="/utils/show_code/index.html?OJ/code/7.cpp">代码</a></li>
<li>输出格式比较麻烦
<ul>
<li>计算</li>
</ul></li>
<li>中缀转后缀
<ul>
<li>准备一个栈</li>
<li>遇到操作数，直接输出</li>
<li>遇到左括号，将左括号压栈</li>
<li>遇到右括号，弹栈输出，直到遇到左括号停止
<ul>
<li>遇不到左括号则输入序列有问题</li>
</ul></li>
<li>遇到操作符，重复如下操作，直至条件不成立，最后将当前操作符压栈
<ul>
<li>同时满足：栈非空、栈顶不为左括号、栈顶操作符优先级小于等于当前操作符</li>
</ul></li>
<li>最后弹空栈输出</li>
</ul></li>
</ul>
<h2 id="distance-queries">Distance Queries</h2>
<ul>
<li>Floyd 算法 <span class="math inline">\(O(N^3)\)</span>，TLE</li>
<li><a href="/utils/show_code/index.html?OJ/code/8.cpp">代码</a></li>
<li>一些条件
<ul>
<li>无向无环图
<ul>
<li>No two roads cross, and precisely one path.</li>
</ul></li>
<li>连通图
<ul>
<li>precisely one path (sequence of roads) links every pair of
farms.</li>
</ul></li>
</ul></li>
<li>构建一棵树
<ul>
<li>dist[x] 记录 x 结点到根的距离</li>
<li>如果两个结点 <span class="math inline">\(a,b\)</span>
的存在<strong>最近公共祖先</strong> <span class="math inline">\(c\)</span>
<ul>
<li>结果为 <span class="math inline">\(\mathrm{dist[a]+dist[b]-2\times
dist[c]}\)</span></li>
</ul></li>
<li>利用并查集优化判断是否在同一棵树中，或者增加一个虚拟结点</li>
</ul></li>
<li>基本思路
<ul>
<li>深度大的点先找他的父结点，直到两个结点的深度一样</li>
<li>然后一起向上找父结点，直到找到相同的父结点</li>
</ul></li>
<li>lca：Least Common Ancestors</li>
</ul>
<h3 id="倍增法">倍增法</h3>
<ul>
<li>倍增法求最近公共祖先</li>
<li>第一步，先让 x，y 跳到相同深度（不妨假设 x 深度更大）
<ul>
<li>x 与 y 的深度差可以表示为若干 2 的幂次的和，每次跳跃 <span class="math inline">\(2^i\)</span> 个点，复杂度 <span class="math inline">\(\log(x-y)=O(\log N)\)</span></li>
<li>这个差可以显式获取到</li>
</ul></li>
<li>第二步，要么是同一个点，要么一起往上跳
<ul>
<li>同样的思路，lca(x, y) 与现在的深度差可以也可以可以表示为若干 2
的幂次的和，复杂度 <span class="math inline">\(O(\log N)\)</span></li>
<li>这个差不能显示获取到，但是可以通过深度比较试出来</li>
</ul></li>
<li>具体实现见代码</li>
</ul>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>DP</tag>
        <tag>最短路</tag>
        <tag>DFS</tag>
        <tag>tree</tag>
        <tag>STL</tag>
        <tag>Floyd</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>元宇宙：解开互联网终极形态的六大问题</title>
    <url>/2021/10/19/nothing/Metaverse-6-Questions/</url>
    <content><![CDATA[<h1 id="元宇宙解开互联网终极形态的六大问题">元宇宙：解开互联网终极形态的六大问题</h1>
<ul>
<li><a href="https://mp.weixin.qq.com/s/7mWelroPlStuGHu0n9sJWw">推送链接</a></li>
<li>有些内容比较省略，详细的查看这个 <a href="/2021/10/19/nothing/Metaverse-THU-2020-2021/">note</a></li>
</ul>
<h2 id="互联网发展至今面临哪些困境">1. 互联网发展至今面临哪些困境</h2>
<h3 id="互联网的影响">互联网的影响</h3>
<ul>
<li>改变了信息的获取以及传播方式</li>
<li>改变了人们的生活习惯</li>
<li>改变了各行各业的商业结构</li>
<li>互联网带来的数字经济成为推动 GDP 增长的重要动力</li>
</ul>
<h3 id="三大困境">三大困境</h3>
<h4 id="市场空间">市场空间</h4>
<ul>
<li>流量增长空间几乎触顶，流量红利逐步消失
<ul>
<li>中国互联网巨头用户渗透率基本见顶
<ul>
<li><strong>用户渗透率</strong>：在被调查的对象中，一个品牌的产品，使用者的比例</li>
</ul></li>
</ul></li>
</ul>
<h4 id="内容">内容</h4>
<ul>
<li>当前互联网内容都是通过文字、声音、视频方式进行呈现，内容呈现单一，用户体验单调，人与人以及人与物距离依然很遥远</li>
<li>社交、购物、娱乐</li>
</ul>
<h4 id="政策">政策</h4>
<ul>
<li>反垄断浪潮掀起，国际国内强化科技平台监管</li>
<li>全球多家互联网巨头遭遇反垄断调查</li>
</ul>
<h2 id="元宇宙能解决互联网面临的哪些问题">2.
元宇宙能解决互联网面临的哪些问题</h2>
<ul>
<li>至少能够解决如下四个问题
<ul>
<li>元宇宙市场空间大，打开互联网成长新空间</li>
<li>反垄断浪潮掀起，解决反垄断背后的问题需要依靠科技创新
<ul>
<li>全球反垄断浪潮掀起，背后存在 3
个核心问题：<strong>市场效率</strong>、<strong>公共权利</strong>、<strong>科技创新</strong></li>
<li>反垄断政策倒逼互联网企业颠覆创新，寻找新的增长点，<strong>元宇宙就是下一代技术革命</strong></li>
</ul></li>
<li>智能化、无人化趋势下，元宇宙能创造更多的就业机会以收入来源
<ul>
<li>互联网创造了大量就业岗位</li>
</ul></li>
<li>元宇宙的发展匹配马斯洛人类需求理论中的各种需求
<ul>
<li>元宇宙的发展匹配<strong>高级的精神价值需求</strong>，比如去中心化的经济系统匹配人的财产安全需求，立体式的社交网络体系匹配人的社交需求，真假难辨的沉浸式体验、开放的创造系统、多样的文明形态匹配人的尊重需求和自我实现需求</li>
</ul></li>
</ul></li>
</ul>
<h2 id="元宇宙为什么能解决这些问题">3. 元宇宙为什么能解决这些问题</h2>
<h3 id="元宇宙的-5-个要素">元宇宙的 5 个要素</h3>
<ul>
<li><strong>真假难辨的沉浸式体验</strong>
<ul>
<li>满足人的精神价值需求</li>
<li>技术设备的需求空间大，创造更多的收入来源</li>
</ul></li>
<li><strong>开放的创造系统</strong>
<ul>
<li>满足人的尊重需求、自我实现需求</li>
<li>创造更多的就业机会及收入来源</li>
</ul></li>
<li><strong>立体式的社交网络体系</strong>
<ul>
<li>满足人的社交需求</li>
</ul></li>
<li><strong>去中心化的经济系统</strong>
<ul>
<li>创造更多的就业机会及收入来源</li>
</ul></li>
<li><strong>多样的文明形态</strong>
<ul>
<li>满足人的精神价值需求</li>
</ul></li>
</ul>
<h3 id="社交网络发展">社交网络发展</h3>
<ul>
<li>社交网络 1.0 时代
<ul>
<li>真实的社会关系还没有沉淀到互联网社交网络上</li>
<li>ICQ</li>
</ul></li>
<li>社交网络 2.0 时代
<ul>
<li>每个人都以真实的身份进入到互联网</li>
<li>微信</li>
</ul></li>
<li>社交网络 3.0 时代
<ul>
<li>立体化、沉浸式、实体形象</li>
<li>一个基于现实的大型 3D 在线世界</li>
<li>经济系统、消费品、娱乐 ······
<ul>
<li>区块链是虚拟世界和现实的桥梁，NFT 是元宇宙中的潜在的经济载体</li>
</ul></li>
<li>元宇宙</li>
</ul></li>
</ul>
<h2 id="如何看待元宇宙的本质及未来趋势">4.
如何看待元宇宙的本质及未来趋势</h2>
<ul>
<li>元宇宙 Metaverse = Meta（超越） +Universe（宇宙）</li>
<li>元宇宙是一个平行于现实世界，又独立于现实世界的虚拟空间，是映射现实世界的在线虚拟世界，是越来越真实的数字虚拟世界</li>
<li>元宇宙的本质就是下一代互联网，“元宇宙”就是互联网的终极形态</li>
</ul>
<h3 id="元宇宙产品的八大特点roblox">元宇宙产品的八大特点（Roblox）</h3>
<ul>
<li>Identity（身份）：自由创造虚拟形象，第二人生</li>
<li>Friends（朋友）：跨越空间、多维社交</li>
<li>Immersive（沉浸感）：虚拟与现实世界无障碍连接</li>
<li>Anywhere（随地）：低门槛 + 高渗透率 + 多端入口</li>
<li>Variety（多元化）：超越现实生活的自由</li>
<li>Low Friction（低延迟）：5G、边缘计算，消除失真感</li>
<li>Economy（经济）：UGC 创造价值、与现实经济打通</li>
<li>Civility（文明）：最终发展方向，虚拟世界大繁荣</li>
</ul>
<h3 id="年内关键结点">30 年内关键结点</h3>
<ul>
<li>第一阶段（2021-2030）：社交 + 娱乐
<ul>
<li>沉浸式体验形成雏形，在虚拟世界中可以实现基本的娱乐、社交功能，少部分玩家对元宇宙形成归属感</li>
<li><strong>社交、游戏、内容等娱乐领域</strong></li>
<li>具有沉浸感的内容体验，显著的用户体验提升</li>
</ul></li>
<li>第二阶段（2030-2050）：虚拟、现实概念逐渐模糊
<ul>
<li>将<strong>消费、金融、生活服务等真实世界的元素</strong>接入到虚拟网络中，用户基数、使用时间进一步提升，元宇宙成为社会生活中重要的一部分</li>
<li>主要发生在<strong>能提升生产生活效率</strong>的领域</li>
</ul></li>
<li>第三阶段（终极形态，2050 年以后）：<strong>全真互联网</strong>
<ul>
<li>虚拟和现实世界密不可分，用户基数和使用时长达到极大，在虚拟世界中形成<strong>新的文明</strong></li>
</ul></li>
</ul>
<h3 id="最终形态">最终形态</h3>
<ul>
<li>倾向于认为未来的元宇宙会是一个<strong>开放与封闭体系共存</strong>甚至可以<strong>局部连通</strong>、大宇宙和小宇宙相互嵌套、小宇宙有机会膨胀扩张、大宇宙有机会碰撞整合的宇宙</li>
</ul>
<h3 id="七层价值链">七层价值链</h3>
<ul>
<li>七层价值链
<ul>
<li>Experience（体验）</li>
<li>Discovery（曝光）</li>
<li>Creator Economy（创作者经济）</li>
<li>Spatial Computing（空间计算）</li>
<li>Decentralization（去中心化）</li>
<li>Human Interface（人机交互）</li>
<li>Infrastructure（基础设施）</li>
</ul></li>
<li>元宇宙 7 层价值链布局公司</li>
</ul>
<p><img src="/2021/10/19/nothing/Metaverse-6-Questions/001.jpg" style="zoom:80%;"></p>
<h2 id="如何看待元宇宙当下的投资机会">5.
如何看待元宇宙当下的投资机会</h2>
<ul>
<li>当下元宇宙的投资机会可以从 3
个维度来看待：<strong>硬件侧</strong>、<strong>内容侧</strong>、<strong>金融交易侧</strong></li>
<li>硬件侧
<ul>
<li>VR/AR 是元宇宙从概念走向现实的必经阶段，未来五年 CAGR 达 54%，VR/AR
是中场，元宇宙是终局</li>
<li>CAGR：复合年均增长率 Compound Annual Growth Rate</li>
</ul></li>
<li>内容侧
<ul>
<li>Roblox 是元宇宙的雏形，如果说 VR/AR 则代表着元宇宙的硬件生态，Roblox
则代表元宇宙的内容生态，Roblox 引领元宇宙内容生态迎来新发展</li>
</ul></li>
<li>金融交易侧
<ul>
<li>NFT为元宇宙经济系统提供底层支持，元宇宙为 NFT
提供了应用场景，二者相互促进</li>
</ul></li>
</ul>
<h3 id="硬件侧">硬件侧</h3>
<ul>
<li>元宇宙的内容产业需要在品类、质量上都具备足够的吸引力以形成<strong>网络效应</strong>，降低规模扩张的边际成本</li>
<li>当发展到生态足够繁荣的阶段将形成<strong>飞轮效应</strong>，迈入生态自我促进与优质内容自我增殖的持续繁荣阶段</li>
</ul>
<h3 id="内容侧">内容侧</h3>
<ul>
<li>Roblox 公司成立于 2004 年，旗下同名产品 Roblox
是一个提供游戏创作、在线游戏与社交的平台，用户能够使用平台提供的游戏引擎开发游戏并获取开发者分成，而玩家能够在多个平台上即点即玩参与各类游戏，同时平台提供好友聊天、“一起玩”、PartyPlace
等多种社交形式。</li>
<li>Roblox 是全球最大的多人游戏创作与社交平台之一</li>
</ul>
<h3 id="金融交易侧">金融交易侧</h3>
<ul>
<li>NFT 为元宇宙经济提供底层支持，元宇宙为 NFT 提供了应用场景</li>
<li>2021H1，NFT 的整体市值和交易规模分别达到 127 亿美元和 7.54
亿美元。而在 2020 年，NFT 的整体市值才 3.38 亿美元，NFT 规模增长迅速
<ul>
<li><strong>令人震惊</strong></li>
</ul></li>
<li>NFT
意为<strong>非同质化代币</strong>，它构建了元宇宙的基本交易秩序，确定了虚拟资产的唯一性和可确权性，这优于现实中的资产特性，因为现实生活中的资产可能会被偷走、假冒、混淆所有权，但元宇宙中的资产因为使用了
NFT 这一工具，便能杜绝仿造品，且能明确物品的所有权</li>
</ul>
<h2 id="元宇宙里可能会出现现实世界哪些问题">6.
元宇宙里可能会出现现实世界哪些问题</h2>
<ul>
<li>10 大风险
<ul>
<li>资本操纵、舆论泡沫、伦理制约、垄断张力、产业内卷</li>
<li>算力压力、经济风险、沉迷风险、隐私风险、知识产权</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>nothing</category>
      </categories>
      <tags>
        <tag>nothing</tag>
        <tag>元宇宙</tag>
      </tags>
  </entry>
  <entry>
    <title>清华大学《2020-2021年元宇宙发展研究报告》</title>
    <url>/2021/10/19/nothing/Metaverse-THU-2020-2021/</url>
    <content><![CDATA[<h1 id="清华大学2020-2021年元宇宙发展研究报告">清华大学《2020-2021年元宇宙发展研究报告》</h1>
<ul>
<li><a href="/resources/nothing/Metaverse-THU-2020-2021.zip">报告链接</a></li>
</ul>
<h2 id="报告概述">报告概述</h2>
<ul>
<li>元宇宙（metaverse）</li>
<li>理念篇
<ul>
<li>讨论了元宇宙诞生的过程和历史契机、元宇宙的概念界定、虚拟和现实的关系、元宇宙的价值来源、多维时空的搭建等相关的理论问题，并对元宇宙的运作模式分物理、地理、伦理、事理、心理5个部分进行了论述。</li>
</ul></li>
<li>产业篇
<ul>
<li>讨论了元宇宙的技术基础，分析了元宇宙的行业生态以及中、美、日、韩四国的元宇宙行业发展现状，最后提出了元宇宙指数体系。</li>
</ul></li>
<li>风险篇
<ul>
<li>从生产力、稳健性、组织结构、服务功能、适应性、公平性六大为对元宇宙产业生态健康度进行了多维评估，指出目前元宇宙处于“亚健康”状态，进一步从舆论、技术、资本、伦理和法律规范等层面对元宇宙产业发展十大风险点进行了讨论。</li>
</ul></li>
</ul>
<h2 id="理念篇">理念篇</h2>
<h3 id="孕育元宇宙">1. 孕育元宇宙</h3>
<ul>
<li>1992 年，Neal Stephenson 的科幻小说《Snow Crash》中提出了 metaverse
的概念</li>
<li><strong>开放多人游戏</strong>
<ul>
<li>文字交互界面 <span class="math inline">\(\to\)</span> 2D 图形界面
<span class="math inline">\(\to\)</span> 轴测图界面 <span class="math inline">\(\to\)</span> 3D 界面 <span class="math inline">\(\to\)</span> 元宇宙</li>
</ul></li>
<li>MMORPG：大型多人在线角色扮演游戏
<ul>
<li>Multiplayer Online Role-Playing Game</li>
</ul></li>
<li>《Second Life》：<strong>第一个现象级的虚拟世界</strong></li>
<li>2020：人类社会虚拟化的临界点
<ul>
<li>疫情加速社会虚拟化、线上生活从例外状态到常态、对虚拟的认知改变、生活迁移</li>
</ul></li>
</ul>
<h3 id="元宇宙是什么">2. 元宇宙是什么</h3>
<ul>
<li>Metaverse = Meta + Universe</li>
<li>前所未有的互操作性</li>
<li>元宇宙构造的七个层面
<ul>
<li>体验；发现；创作者经济；空间计算；去中心化；人机互动；基础设施</li>
</ul></li>
<li>元宇宙至少包括以下要素
<ul>
<li>身份、朋友、沉浸感、低延迟、多元化、随地、经济系统、文明</li>
</ul></li>
<li>具身互动、UGC、经济系统、统一身份、虚实融合
<ul>
<li>UGC（User Generated Content）</li>
<li>PGC（Platform Generated Content）</li>
</ul></li>
</ul>
<h4 id="元宇宙是什么-1">元宇宙是什么？</h4>
<ul>
<li>元宇宙是整合多种<strong>新技术</strong>而产生的<strong>新型虚实相融</strong>的<strong>互联网应用和社会形态</strong>，它基于扩展现实技术提供沉浸式体验，基于数字孪生技术生成现实世界的镜像，基于区块链技术搭建<strong>经济体系</strong>，将虚拟世界与现实世界在经济系统、社交系统、身份系统上密切融合，并且允许每个用户进行<strong>内容生产和世界编辑</strong>。</li>
<li>不仅仅是电子游戏，不仅仅是虚拟世界
<ul>
<li>元宇宙 = 大型多人在线游戏 + 开放式任务 + 可编辑世界 + XR入口 +
AI内容生成 + 经济系统 + 社交系统 + 化身系统 + 去中心化认证系统 +
现实元素 ······</li>
<li>元宇宙 = 虚拟世界 x 现实世界</li>
</ul></li>
</ul>
<h4 id="为什么需要元宇宙">为什么需要元宇宙？</h4>
<ul>
<li>技术渴望新产品、资本寻找新出口、用户期待新体验</li>
<li>互联网发展陷入内卷
<ul>
<li>在内容载体、传播方式、交互方式、参与感和互动性上长期缺乏突破，导致“没有发展的增长”</li>
<li>WEB1.0 <span class="math inline">\(\to\)</span> WEB2.0 <span class="math inline">\(\to\)</span> 移动互联网 <span class="math inline">\(\to\)</span> 元宇宙</li>
</ul></li>
</ul>
<h3 id="虚拟与现实的关系">3. 虚拟与现实的关系</h3>
<h4 id="虚拟现实补偿论">虚拟现实补偿论</h4>
<ul>
<li>虚构一直是人类文明的底层冲动</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">时代</th>
<th style="text-align: center;">形式</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">古代</td>
<td style="text-align: center;">文学、绘画、戏剧</td>
<td style="text-align: center;">绘声绘色</td>
</tr>
<tr class="even">
<td style="text-align: center;">近代</td>
<td style="text-align: center;">电影</td>
<td style="text-align: center;">视听造梦</td>
</tr>
<tr class="odd">
<td style="text-align: center;">现代</td>
<td style="text-align: center;">VR</td>
<td style="text-align: center;">如临其境</td>
</tr>
<tr class="even">
<td style="text-align: center;">未来</td>
<td style="text-align: center;">元宇宙</td>
<td style="text-align: center;">生活其中</td>
</tr>
</tbody>
</table>
<ul>
<li>随着形式变化，<strong>沉浸感</strong>、<strong>参与感</strong>、<strong>补偿感</strong>在上升</li>
<li>永恒的创世冲动</li>
</ul>
<h4 id="人类仿真的阶段">人类仿真的阶段</h4>
<ul>
<li>布希亚区分了人类仿真历史的三个阶段：
<ul>
<li>仿造（counterfeit）、生产（production）、仿真（simulation）</li>
</ul></li>
<li>元宇宙构建的三个阶段
<ul>
<li>数字孪生、虚拟原生、虚实融生</li>
</ul></li>
</ul>
<h4 id="综合环境的结构">综合环境的结构</h4>
<ul>
<li>虚拟世界
<ul>
<li><strong>区块链</strong>框架下的：
<ul>
<li>基于规则与算法运作的<strong>社交平台</strong></li>
<li>基于区块链的数字货币与<strong>经济平台</strong></li>
<li>基于 UGC 的<strong>内容平台</strong></li>
</ul></li>
</ul></li>
<li>虚实界面
<ul>
<li>XR
<ul>
<li>VR：虚拟世界完全<strong>置换</strong>现实世界</li>
<li>MR：现实环境与虚拟环境相互<strong>混合</strong></li>
<li>AR：虚拟世界<strong>叠加</strong>在现实世界上</li>
</ul></li>
<li>虚拟数字人</li>
<li>仿真机器人</li>
<li>脑机接口</li>
</ul></li>
<li>现实世界
<ul>
<li><strong>主权国家</strong>框架下的
<ul>
<li>基于法律与社会规范的<strong>社交</strong></li>
<li>基于商品与货币自由市场的<strong>经济</strong></li>
<li>自发生成的<strong>文化</strong></li>
</ul></li>
</ul></li>
</ul>
<h3 id="元宇宙的理论框架">4. 元宇宙的理论框架</h3>
<h4 id="通往元宇宙的路径">通往元宇宙的路径</h4>
<ul>
<li>沉浸 vs 叠加
<ul>
<li>沉浸 VR</li>
<li>叠加 AR</li>
</ul></li>
<li>渐进 vs 激进
<ul>
<li>渐进：游戏 <span class="math inline">\(\to\)</span> 社区 <span class="math inline">\(\to\)</span> 元宇宙</li>
<li>激进：直接提供开发平台和社区</li>
</ul></li>
<li>开放 vs 封闭</li>
</ul>
<h4 id="元宇宙的物理">元宇宙的物理</h4>
<ul>
<li>有选择的解放：飞翔、瞬移</li>
</ul>
<h4 id="元宇宙的地理">元宇宙的地理</h4>
<ul>
<li>AI 生成，用户参与
<ul>
<li>数字孪生 vs AI 生成</li>
<li>可编辑世界</li>
<li>虚实融合场景</li>
</ul></li>
</ul>
<h4 id="元宇宙的事理">元宇宙的事理</h4>
<ul>
<li>流动、转化与关联逻辑
<ul>
<li>现实与虚拟融合</li>
<li>生产、消费与再生产</li>
</ul></li>
</ul>
<h4 id="元宇宙的心理">元宇宙的心理</h4>
<ul>
<li>从认知到认同</li>
<li>身份认同、交互与认知、在场感、安全感、公平感</li>
</ul>
<h4 id="元宇宙的伦理">元宇宙的伦理</h4>
<ul>
<li>诸多风险需立法监管</li>
<li>平台法规 + 暴力机器</li>
</ul>
<h4 id="元宇宙的价值">元宇宙的价值</h4>
<ul>
<li>参与、土地经济、化身形象、场景化社交</li>
</ul>
<h4 id="多维空间的搭建">多维空间的搭建</h4>
<p><img src="/2021/10/19/nothing/Metaverse-THU-2020-2021/image-20211019141419039.png" style="zoom: 80%;"></p>
<h3 id="对元宇宙的几点展望">5. 对元宇宙的几点展望</h3>
<ul>
<li>元宇宙是虚拟与现实的全面交织
<ul>
<li>生活方式、社会关系、经济形式、犯罪监管</li>
</ul></li>
<li>元宇宙将加深思维的表象化</li>
<li>元宇宙需警惕资本剥削
<ul>
<li>区块链</li>
</ul></li>
<li>去中心化机制 <span class="math inline">\(\ne\)</span> 去中心化结果
<ul>
<li>组织逻辑，分配结果</li>
<li>内容生产逻辑，市场竞争结果</li>
</ul></li>
<li>元宇宙与国家存在深刻张力</li>
</ul>
<p><img src="/2021/10/19/nothing/Metaverse-THU-2020-2021/image-20211019142134189.png" style="zoom:80%;"></p>
<ul>
<li>元宇宙将打开巨大市场空间
<ul>
<li>不断从<strong>存量市场</strong>中发现<strong>增量市场</strong></li>
<li>综合环境，综合感官，玩法无限，增量空间无限</li>
</ul></li>
<li>建议国家推动若干元宇宙相关技术与行业发展
<ul>
<li>推动元宇宙<strong>相关专精特新技术</strong>发展
<ul>
<li>VR、AR、云计算、数字孪生、大数据、物联网、人工智能、智能硬件</li>
</ul></li>
<li>推动元宇宙<strong>相关行业</strong>发展
<ul>
<li>智慧城市、智慧园区、智能汽车、电子商务、数字旅游、教育类游戏、心理治疗、老人陪伴、国潮时尚</li>
</ul></li>
<li>推动中国<strong>元宇宙产业全球化</strong></li>
</ul></li>
</ul>
<h2 id="产业篇">产业篇</h2>
<h3 id="元宇宙的技术底座">1. 元宇宙的技术底座</h3>
<p><img src="/2021/10/19/nothing/Metaverse-THU-2020-2021/image-20211019142810962.png" style="zoom: 80%;"></p>
<h4 id="元宇宙的通信基础5g">元宇宙的通信基础：5G</h4>
<ul>
<li>XR 设备更高的沉浸感 <span class="math inline">\(\leftarrow\)</span>
更高的分辨率、帧率 <span class="math inline">\(\leftarrow\)</span>
视频压缩算法、移动通信技术</li>
<li>5G：高速率、低时延、低能耗、大规模设备连接</li>
</ul>
<h4 id="元宇宙的算力基础云计算">元宇宙的算力基础：云计算</h4>
<ul>
<li>云储存、云计算、<strong>云渲染</strong>
<ul>
<li>运算和显示分离</li>
<li>动态分配算力的云计算系统</li>
</ul></li>
<li>NVIDIA Omniverse</li>
<li>Epic Cloudgine</li>
<li>Microsoft Azure</li>
<li>Amazon AWS</li>
</ul>
<h4 id="元宇宙的虚实界面拓展现实机器人脑机接口">元宇宙的虚实界面：拓展现实、机器人、脑机接口</h4>
<ul>
<li>拓展现实：VR、MR、AR
<ul>
<li>VR：Oculus</li>
<li>芯片：高通XR2平台</li>
<li>AR：苹果开发者生态</li>
<li>MR：微软提出标准，HoloLens</li>
</ul></li>
</ul>
<h5 id="元宇宙激活-vr-内容生态">元宇宙激活 VR 内容生态</h5>
<ul>
<li>VR 元年后的第五年，其应用仍然局限于极客人群和专业应用领域</li>
<li>目前的两个瓶颈：价格高，内容少</li>
</ul>
<h4 id="元宇宙的生成逻辑人工智能">元宇宙的生成逻辑：人工智能</h4>
<ul>
<li>大幅提升运算性能</li>
<li>内容生产</li>
<li>内容呈现</li>
<li>内容审查</li>
</ul>
<h4 id="元宇宙的世界蓝图数字孪生">元宇宙的世界蓝图：数字孪生</h4>
<ul>
<li>数字孪生即在虚拟空间内建立真实事物的动态孪生体</li>
<li>借由<strong>传感器</strong>，本体的运行状态及外部环境数据均可实时映射到孪生体上</li>
<li>Gartner</li>
<li>国内产品
<ul>
<li>华为河图 Cyberverse</li>
<li>百度 DuMix AR</li>
<li>51World</li>
<li>UINO优锘</li>
</ul></li>
</ul>
<h4 id="元宇宙的认证机制区块链">元宇宙的认证机制：区块链</h4>
<ul>
<li>去中心化网络的虚拟货币</li>
<li>NFT（非同质化代币）</li>
</ul>
<h3 id="元宇宙的产业生态">2. 元宇宙的产业生态</h3>
<h4 id="元宇宙生态版图渐趋成熟">元宇宙生态版图渐趋成熟</h4>
<p><img src="/2021/10/19/nothing/Metaverse-THU-2020-2021/image-20211019144755969.png" style="zoom:80%;"></p>
<ul>
<li>具体设施</li>
</ul>
<p><img src="/2021/10/19/nothing/Metaverse-THU-2020-2021/image-20211019144907783.png" style="zoom:80%;"></p>
<h4 id="元宇宙支撑技术多维拓展">元宇宙支撑技术多维拓展</h4>
<ul>
<li>六大技术</li>
</ul>
<p><img src="/2021/10/19/nothing/Metaverse-THU-2020-2021/image-20211019145005042.png" style="zoom:80%;"></p>
<h4 id="产业板块的增长情况">产业板块的增长情况</h4>
<ul>
<li>底层技术企业：视觉中国、海康威视、科大讯飞、景嘉微</li>
<li>前端设备企业：歌尔股份、瑞芯微、京东方 A、思瑞浦</li>
<li>场景内容企业：超图软件、宝通科技、完美世界、电魂网络</li>
</ul>
<h3 id="中美日韩元宇宙发展现状">3. 中美日韩元宇宙发展现状</h3>
<ul>
<li>主要元宇宙公司</li>
</ul>
<p><img src="/2021/10/19/nothing/Metaverse-THU-2020-2021/image-20211019145454002.png" style="zoom:80%;"></p>
<ul>
<li>元宇宙厂商的四套叙事
<ul>
<li>虚实融合、去中心化交易、自由创造、社交协作</li>
</ul></li>
</ul>
<h4 id="美国元宇宙行业现状">美国元宇宙行业现状</h4>
<h5 id="roblox">Roblox</h5>
<ul>
<li><strong>普鲁士教育体制</strong> <span class="math inline">\(\to\)</span> <strong>Roblox 教育创新</strong></li>
<li><strong>prosumer</strong> 社区文化：每个用户都是 producer +
consumer</li>
</ul>
<h5 id="facebook">Facebook</h5>
<ul>
<li>2021 年 7 月 27 日，Facebook
宣布将成立元宇宙团队，在五年内转型为元宇宙公司。新团队将由Instagram
负责产品的高管 Vishal Shah 以及 Facebook 游戏高管 Jason Rubin
带领。</li>
<li>Horizon：VR 协作平台</li>
<li>Libra：Facebook发起的加密货币项目</li>
<li>oculus quest 2：虚拟现实头盔
<ul>
<li>Facebook 在 2014 年 7 月宣布以 20 亿美元的价格收购 Oculus</li>
</ul></li>
</ul>
<h5 id="epic-games">Epic Games</h5>
<ul>
<li>Unreal 虚幻引擎</li>
<li>2021 年 4 月 13 日，Epic Games 宣布投资 10 亿美元打造元宇宙</li>
<li>游戏《堡垒之夜》：元宇宙虚拟世界</li>
</ul>
<h5 id="microsoft">Microsoft</h5>
<ul>
<li>基于数字孪生的游戏《模拟飞行2020》</li>
<li>XBOX 游戏生态</li>
<li>云计算服务 Azure</li>
<li>增强现实眼镜 Microsoft HoloLens 2</li>
<li>混合现实协作平台 Microsoft Mesh</li>
</ul>
<h5 id="decentraland">Decentraland</h5>
<ul>
<li>“ 区块链 + VR + 第二人生 ” 概念的产品</li>
<li>基于以太坊的 VR
的虚拟世界，第一个完全去中心化、由用户所拥有的虚拟世界</li>
</ul>
<h4 id="中国元宇宙行业现状">中国元宇宙行业现状</h4>
<h5 id="腾讯">腾讯</h5>
<ul>
<li>完善的元宇宙资本布局</li>
</ul>
<p><img src="/2021/10/19/nothing/Metaverse-THU-2020-2021/image-20211019152452454.png" style="zoom:80%;"></p>
<h5 id="字节跳动">字节跳动</h5>
<ul>
<li>字节跳动投资的公司代码乾坤发行了《重启世界》，概念与Roblox相似。</li>
<li>2021年 8 月，字节跳动收购中国 VR 设备公司 PICO</li>
<li>注册 “PIXSOUL” 商标，或为类 SOUL 的元宇宙社交产品</li>
<li>抖音、TIKTOK 拥有全球范围的用户基础、活跃的 UGC
生态与线上线下打通的商业模式</li>
<li>投资视觉计算及 AI 计算平台提供商摩尔线程</li>
<li>投资 3D 视觉技术解决方案提供商熵智科技</li>
<li>投资 AI 创作服务商百炼智能</li>
</ul>
<h5 id="网易">网易</h5>
<ul>
<li>推出《河狸计划》原创游戏社区，提供低门槛游戏开发工具</li>
<li>投资 IMPROBABLE，其云计算平台 SPATIALOS
允许第三方建立大型虚拟世界</li>
<li>投资虚拟角色社交平台 IMVU
<ul>
<li>VCOIN 代币</li>
<li>用户生成平台 WITHME</li>
</ul></li>
</ul>
<h5 id="莉莉丝">莉莉丝</h5>
<ul>
<li>推出游戏开发平台和社区</li>
<li>发起 “达芬奇计划” 游戏创作大赛</li>
<li>投资 AI 团队“启元世界”，研发用于在线游戏的认知决策智能技术</li>
<li>投资云游戏技术平台 “念力科技”，研发云游戏解决方案</li>
</ul>
<h5 id="米哈游">米哈游</h5>
<ul>
<li>现象级开放世界 RPG 游戏《原神》</li>
<li>出资 8900 万美元参与 “社交元宇宙” Soul 的私募配售</li>
<li>开发以 “鹿鸣” 为代表的基于虚幻引擎的虚拟形象解决方案</li>
<li>与上海交大医学院附属瑞金医院合作建立
“瑞金医院脑病中心米哈游联合实验室”，研究脑接口技术的开发和临床应用</li>
<li>组建人工智能科学家团队“逆熵工作室”</li>
</ul>
<h4 id="日本元宇宙行业现状">日本元宇宙行业现状</h4>
<ul>
<li>日本社交网站巨头 GREE 称，将以子公司 REALITY 为中心，开展元宇宙业务
<ul>
<li>该公司认为，并不是只有 3D
画面才能叫虚拟世界，让用户感受到<strong>社会性</strong>的机制更为重要</li>
</ul></li>
</ul>
<h5 id="动漫产业">动漫产业</h5>
<ul>
<li>2021年8月5日，Avex Business Development 跟 Digital Motion
成立《Virtual
Avex（虚拟爱贝克思）集团》，计划促进现有动漫或游戏角色，举办虚拟艺术家活动，以及将真实艺术家演唱会等活动虚拟化</li>
<li>Cluster 主打 VR 虚拟场景多人聚会</li>
<li>2020 年 3 月，任天堂发布《动物之森》系列第 7 部作品</li>
</ul>
<h5 id="sony">Sony</h5>
<ul>
<li>PlayStation 主机系统和游戏生态</li>
<li>入股 Epic Games 并建立合作关系</li>
<li>推出《Dreams Universe》，概念类似 《Roblox》</li>
</ul>
<h5 id="hassilas">Hassilas</h5>
<ul>
<li>日本 VR 开发商 Hassilas 公司正式宣布其最新 Metaverser（元宇宙）平台
Mechaverse</li>
</ul>
<h4 id="韩国元宇宙行业现状">韩国元宇宙行业现状</h4>
<h5 id="政府">政府</h5>
<ul>
<li>2021 年 5 月 18 日，韩国信息通讯产业振兴院联合 25 个机构和企业成立
“元宇宙联盟”，旨在通过<strong>政府和企业的合作</strong>，在民间主导下构建元宇宙生态系统，在现实和虚拟的多个领域实现开放型元宇宙平台</li>
<li>“元宇宙-Hub” 协议</li>
<li>韩国数字新政（Korean Digital Newdeal）数字内容产业培育支援计划</li>
</ul>
<h5 id="三星-samsung">三星 SAMSUNG</h5>
<ul>
<li>Relumino Glass：为视觉障碍人士开发的 VR 眼镜</li>
<li>“人工智人”（Artificial Human）项目 NEON</li>
</ul>
<h5 id="sk-telecomnc-soft">SK telecom、NC soft</h5>
<ul>
<li>JUMP AR：App</li>
<li>UNIVERSE：元宇宙平台</li>
</ul>
<h5 id="zepeto">ZEPETO</h5>
<h5 id="hodoo-labs">Hodoo Labs</h5>
<ul>
<li>教育元宇宙</li>
</ul>
<h5 id="首尔大学">首尔大学</h5>
<ul>
<li>XR 技术进行手术实施分享</li>
</ul>
<h4 id="总结">总结</h4>
<ul>
<li>美国：理念上的开拓者，正处于投资风口</li>
<li>日本：ACG产业积累深厚，IP资源丰富</li>
<li>中国：理念上的追随者，市场广阔</li>
<li>韩国：政府引领，偶像工业驱动</li>
</ul>
<h3 id="面向企业的元宇宙">4. 面向企业的元宇宙</h3>
<ul>
<li>产业元宇宙
<ul>
<li>由虚向实：游戏体验真实化 <span class="math inline">\(\to\)</span>
游戏元宇宙</li>
<li>由实向虚：产业生产虚拟化 <span class="math inline">\(\to\)</span>
产业元宇宙</li>
</ul></li>
<li>企业元宇宙</li>
</ul>
<h3 id="元宇宙的指数体系">5. 元宇宙的指数体系</h3>
<h2 id="风险篇">风险篇</h2>
<p><img src="/2021/10/19/nothing/Metaverse-THU-2020-2021/image-20211019160359079.png" style="zoom:80%;"></p>
<ul>
<li>目前元宇宙产业生态系统处于亚健康状态
<ul>
<li>初期发展阶段，具有新兴产业的不成熟、不稳定的特征也是合理的，未来发展不仅要靠<strong>技术创新</strong>引领，还需要<strong>制度创新</strong>（包括正式制度和非正式制度创新）的共同作用，才能实现产业健康发展</li>
</ul></li>
</ul>
<h3 id="元宇宙产业发展十大风险">元宇宙产业发展十大风险</h3>
<ul>
<li><strong>资本操纵</strong>
<ul>
<li>雏形期的元宇宙仍存在诸多不确定性，产业和市场都亟需回归理性</li>
</ul></li>
<li><strong>舆论泡沫</strong>
<ul>
<li>非理性的舆论泡沫呼应着非理性的股市震荡</li>
</ul></li>
<li><strong>伦理制约</strong>
<ul>
<li>如何在去中心化的框架中构建元宇宙的伦理框架共识，仍需从多视角去进行探索</li>
</ul></li>
<li><strong>算力压力</strong>
<ul>
<li>如何保障云计算稳定性、低成本算力资源等诸多问题都有待解决</li>
</ul></li>
<li><strong>经济风险</strong>
<ul>
<li>这种跨越虚实边界的改编应用很可能会引发知识产权纠纷，经济风险可能会从虚拟世界传导至现实世界</li>
</ul></li>
<li><strong>沉迷风险</strong>
<ul>
<li>过度沉浸虚拟世界亦有可能加剧社交恐惧、社会疏离等心理问题</li>
</ul></li>
<li><strong>垄断张力</strong>
<ul>
<li>各家巨头间的竞争态势决定了其生态的相对封闭性，完全的开放和去中心化很难实现</li>
</ul></li>
<li><strong>产业内卷</strong>
<ul>
<li>概念上的突破并未从本质上改变产业内卷的现状</li>
</ul></li>
<li><strong>隐私风险</strong>
<ul>
<li>个体隐私数据作为支撑元宇宙持续运转的底层资源需要不断更新和扩张，<strong>数据资源合规收集、储存与管理</strong>尚待探讨</li>
</ul></li>
<li><strong>知识产权</strong>
<ul>
<li>这种跨越虚实边界的改编应用很可能会引发知识产权纠纷多主体协作与跨越虚实边界的改编应用很可能会引发产权纠纷</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>nothing</category>
      </categories>
      <tags>
        <tag>nothing</tag>
        <tag>元宇宙</tag>
      </tags>
  </entry>
  <entry>
    <title>让 linux 服务器端的 GUI 回传到本地</title>
    <url>/2021/11/14/installation/GUI/</url>
    <content><![CDATA[<h1 id="让-linux-服务器端的-gui-回传到本地">让 linux 服务器端的 GUI
回传到本地</h1>
<ul>
<li>在 linux 服务器上运行 <code>mtsgui</code> 的时候报错</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qt.qpa.xcb: could not connect to display </span><br><span class="line">qt.qpa.plugin: Could not load the Qt platform plugin &quot;xcb&quot; in &quot;&quot; even though it was found.</span><br><span class="line">This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.</span><br><span class="line"></span><br><span class="line">Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb.</span><br><span class="line"></span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>
<ul>
<li>原因是无法接收 GUI 信息</li>
<li>在 windows 上安装一个可以接受 GUI 信息的软件即可</li>
</ul>
<h2 id="mobaxterm">Mobaxterm</h2>
<ul>
<li><strong>Windows 端安装</strong></li>
</ul>
<h3 id="说明">说明</h3>
<ul>
<li><a href="https://mobaxterm.mobatek.net/">官网下载链接</a></li>
<li>支持 ssh 远程连接服务器并且回传 GUI 显示图片</li>
</ul>
<h3 id="安装">安装</h3>
<ul>
<li>下载安装即可</li>
</ul>
<h3 id="配置">配置</h3>
<ul>
<li><code>Sessions</code> <span class="math inline">\(\to\)</span>
<code>New Session</code></li>
</ul>
<p><img src="/2021/11/14/installation/GUI/image-20211114161044842.png" style="zoom:80%;"></p>
<ul>
<li>配置 ssh 即可</li>
</ul>
<p><img src="/2021/11/14/installation/GUI/image-20211114161204213.png" style="zoom:80%;"></p>
<h3 id="结果演示">结果演示</h3>
<p><img src="/2021/11/14/installation/GUI/image-20211114161405482.png" style="zoom:80%;"></p>
<h3 id="一些问题">一些问题</h3>
<ul>
<li>如何设置回传的界面的大小（调整不了）</li>
<li>有的时候会出
BUG，例如渲染场景的时候，如果点设置，就直接报错退出了</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">*** buffer overflow detected ***: terminated</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>installation</category>
      </categories>
      <tags>
        <tag>installation</tag>
        <tag>linux</tag>
        <tag>mitsuba</tag>
        <tag>mobaxterm</tag>
      </tags>
  </entry>
  <entry>
    <title>从源码安装 cmake、openssl</title>
    <url>/2021/10/27/installation/install-cmake-without-root/</url>
    <content><![CDATA[<h1 id="在没有-root-权限的条件下安装-cmake">在没有 root 权限的条件下安装
cmake</h1>
<ul>
<li>这个主要是在 linux 系统从源码安装某一个软件的教程
<ul>
<li>下载、配置、编译、安装、配置</li>
</ul></li>
</ul>
<h2 id="手动安装-cmake">手动安装 cmake</h2>
<ul>
<li><a href="https://cmake.org/download/">官网</a>下载安装包
<ul>
<li>我的版本是<a href="https://github.com/Kitware/CMake/releases/download/v3.22.0-rc1/cmake-3.22.0-rc1.tar.gz">3.22.0-rc1</a></li>
</ul></li>
<li>解压</li>
<li>开始安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入文件夹</span></span><br><span class="line"><span class="built_in">cd</span> cmake-3.22.0-rc1 cmake</span><br><span class="line"></span><br><span class="line">./bootstrap</span><br><span class="line"><span class="comment"># 我的服务器在这一部分报错了</span></span><br><span class="line"><span class="comment"># 安装 OpenSSL 的部分在下面(安装 OpenSSL)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置(安装到用户目录下)</span></span><br><span class="line">./configure --prefix=/home/jhj/software/cmake</span><br><span class="line"></span><br><span class="line"><span class="comment"># make</span></span><br><span class="line">make -j $(<span class="built_in">nproc</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make install</span></span><br><span class="line">make -j $(<span class="built_in">nproc</span>) install</span><br></pre></td></tr></table></figure>
<ul>
<li>更新配置文件
<ul>
<li><code>~/.bashrc</code> 文件最后追加</li>
</ul></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cmake</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$HOME</span>/software/cmake/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<ul>
<li>更新</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake verison</span><br></pre></td></tr></table></figure>
<h2 id="手动安装-openssl">手动安装 OpenSSL</h2>
<ul>
<li>下载</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.openssl.org/source/openssl-1.1.1l.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>可以做一下校验，看文件是否损坏，如果校验码一致则没有问题</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载校验码文件</span></span><br><span class="line">wget https://www.openssl.org/source/openssl-1.1.1l.tar.gz.sha256</span><br><span class="line"><span class="comment"># 查看校验码文件</span></span><br><span class="line"><span class="built_in">cat</span> openssl-1.1.1l.tar.gz.sha256</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看下载文件的校验码</span></span><br><span class="line"><span class="built_in">sha256sum</span> openssl-1.1.1l.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>解压</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xf openssl-1.1.1l.tar.gz</span><br><span class="line"><span class="built_in">cd</span> openssl-1.1.1l</span><br></pre></td></tr></table></figure>
<ul>
<li>配置，设置安装路径</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./config --prefix=/home/jhj/software/openssl --openssldir=/home/jhj/software/openssl no-ssl2</span><br></pre></td></tr></table></figure>
<ul>
<li>编译</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前可用线程数</span></span><br><span class="line"><span class="built_in">nproc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程编译</span></span><br><span class="line">make -j $(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 如果成功会显示 Result: PASS</span></span><br></pre></td></tr></table></figure>
<ul>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<ul>
<li>更新配置文件
<ul>
<li><code>~/.bashrc</code> 文件最后追加</li>
</ul></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># openssl</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$HOME</span>/software/openssl/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$HOME</span>/software/openssl/lib</span><br><span class="line"><span class="built_in">export</span> LC_ALL=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line"><span class="built_in">export</span> LDFLAGS=<span class="string">&quot;-L /home/jhj/software/openssl/lib -Wl,-rpath,/home/jhj/software/openssl/lib&quot;</span></span><br><span class="line"><span class="built_in">export</span> OPENSSL_ROOT_DIR=<span class="variable">$HOME</span>/software/openssl</span><br></pre></td></tr></table></figure>
<ul>
<li>更新</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://blog.csdn.net/opencv_857310866/article/details/81408641">在无
root 权限的服务器下安装 cmake</a></li>
<li><a href="https://help.dreamhost.com/hc/en-us/articles/360001435926-Installing-OpenSSL-locally-under-your-username">Installing
OpenSSL locally under your username</a></li>
</ul>
]]></content>
      <categories>
        <category>installation</category>
      </categories>
      <tags>
        <tag>installation</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>taichi 体素游戏</title>
    <url>/2022/06/19/nothing/taichi-flower/</url>
    <content><![CDATA[<h1 id="flower">flower</h1>
<ul>
<li><a href="https://github.com/banbao990/Taichi-Voxel/tree/taichi-flower">代码链接</a></li>
</ul>
<h2 id="f1.py">f1.py</h2>
<h3 id="爱心">爱心</h3>
<p><span class="math display">\[
r = 3 - 3 \sin\theta + \frac{\sin\theta
\sqrt{\lvert\cos\theta\rvert}}{\sin\theta+1.6},\,\theta\in[0,2\pi]
\]</span></p>
<ul>
<li>效果
<ul>
<li>红色的圆</li>
</ul></li>
</ul>
<p><span class="math display">\[
x^2+(y-2.5)^2=4^2
\]</span></p>
<p><img src="/2022/06/19/nothing/taichi-flower/heart.svg"></p>
<ul>
<li>2D 还不错，如何变成 3D 呢</li>
</ul>
<p><img src="/2022/06/19/nothing/taichi-flower/f1.py-2022-06-18-112324.jpg"></p>
<p><img src="/2022/06/19/nothing/taichi-flower/f1.py-2022-06-18-112414.jpg"></p>
<ul>
<li>球面延伸</li>
</ul>
<h3 id="花瓣">花瓣</h3>
<p><span class="math display">\[
\begin{array}{c}
{\color{blue}r=\sin(4\theta)}\\
{\color{red}x^2+y^2=1^2}
\end{array}
\]</span></p>
<p><img src="/2022/06/19/nothing/taichi-flower/flower8.svg"></p>
<h3 id="结果">结果</h3>
<p><img src="/2022/06/19/nothing/taichi-flower/f1.py-2022-06-19-151156.jpg"></p>
<h2 id="f2.py">f2.py</h2>
<ul>
<li>给定 3 个点，插值出一条路径，形成茎</li>
<li>花的形态，随机选择一个方向，绘制一条直线
<ul>
<li>颜色插值</li>
</ul></li>
<li>花瓶</li>
</ul>
<p><span class="math display">\[
x^2+z^2 = (r\ast\sin(y)+R)^2
\]</span></p>
<p><img src="/2022/06/19/nothing/taichi-flower/f2.py-2022-06-20-162350.jpg"></p>
<h2 id="参考资料">参考资料</h2>
<h3 id="绘制参考">绘制参考</h3>
<ul>
<li><a href="https://github.com/taichi-dev/voxel-challenge/issues/11">官方比赛</a></li>
<li><a href="https://marktube.github.io/2022/05/02/Taichi-Voxel-Challenge">Dream
to be a butterfly</a></li>
<li><a href="https://github.com/ying-lei/little_night_lamp">little_night_lamp</a></li>
<li><a href="https://blog.csdn.net/qq_31804159/article/details/80084601">花瓶</a></li>
</ul>
<h3 id="工具">工具</h3>
<ul>
<li><a href="http://www.fooplot.com/">函数绘图网站</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 - 3*sin(theta) + sin(theta)*sqrt(abs(cos(theta)))/(sin(theta)+1.6)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>nothing</category>
      </categories>
      <tags>
        <tag>nothing</tag>
        <tag>taichi</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-pytorch 配置</title>
    <url>/2022/10/26/installation/linux-pytorch/</url>
    <content><![CDATA[<h1 id="linux-pytorch">linux-pytorch</h1>
<h2 id="基本操作">基本操作</h2>
<h3 id="修改用户密码">修改用户密码</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure>
<h2 id="conda">conda</h2>
<h3 id="安装-conda">安装 conda</h3>
<ul>
<li>参考：<a href="https://zhuanlan.zhihu.com/p/489499097">Linux安装conda</a></li>
<li>下载 miniconda 并安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">bash Miniconda3-latest-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>安装完之后好像会写入 <code>.bashrc</code>，导致连接之后默认激活
<code>base</code> 环境</li>
<li>关闭</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> auto_activate_base <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="新建环境">新建环境</h3>
<ul>
<li>如下命令是新建一个 python 版本为 <span style="color:red"><strong>3.7</strong></span>、名称为 <span style="color:red"><strong>py37</strong></span> 的环境</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n py37 python=3.7</span><br></pre></td></tr></table></figure>
<h3 id="激活退出环境">激活/退出环境</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate py37</span><br><span class="line">conda deactivate py37</span><br></pre></td></tr></table></figure>
<h3 id="安装卸载包">安装/卸载包</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install numpy</span><br><span class="line">conda uninstall numpy</span><br></pre></td></tr></table></figure>
<h3 id="pytorch">pytorch</h3>
<ul>
<li>查看 cuda 版本</li>
<li>实际安装的版本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/26/installation/linux-pytorch/nvcc-v.png"></p>
<ul>
<li>与驱动适配的 cuda 版本（不一定是实际安装的版本）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/26/installation/linux-pytorch/nvidia-smi.png"></p>
<ul>
<li><p>pytorch 官网找对应版本</p>
<ul>
<li><p>找不到匹配的版本</p></li>
<li><p>使用了这个</p></li>
</ul></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio cudatoolkit=11.3 -c pytorch</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/26/installation/linux-pytorch/install-pytorch.png"></p>
]]></content>
      <categories>
        <category>installation</category>
      </categories>
      <tags>
        <tag>installation</tag>
        <tag>linux</tag>
        <tag>python</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh 配置私钥登陆服务器</title>
    <url>/2022/03/23/installation/ssh-rsa/</url>
    <content><![CDATA[<h1 id="ssh-配置私钥登陆服务器">ssh 配置私钥登陆服务器</h1>
<ul>
<li>首先服务器和本地客户端都要安装 ssh</li>
</ul>
<h2 id="证书登录">1. 证书登录</h2>
<ul>
<li>ssh 配置私钥登陆服务器</li>
<li>每次都需要输入密码很麻烦，配置 ssh
连接，但是这样子可能会导致安全问题
<ul>
<li><strong>可以在生成公钥/私钥的时候加入密码</strong></li>
</ul></li>
</ul>
<h3 id="生成公钥私钥对">(1) 生成公钥私钥对</h3>
<ul>
<li>客户端或者服务器利用命令行生成</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果不想设置密码的话，则直接一路回车就好</p>
<ul>
<li>第一次回车，设置生成文件的路径
<ul>
<li>默认是 <code>C:\Users\你的用户名\.ssh\id_rsa</code></li>
<li>建议使用默认目录，放到其他用户可访问目录的时候，<strong>连接的时候会报安全问题</strong></li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">Permissions for &#x27;id_rsa&#x27; are too open.</span><br><span class="line">It is required that your private key files are NOT accessible by others.</span><br><span class="line">This private key will be ignored.</span><br><span class="line">Load key &quot;id_rsa&quot;: bad permissions</span><br></pre></td></tr></table></figure>
<ul>
<li>后面两次回车是设置密码</li>
</ul></li>
</ul>
<h3 id="服务器配置">(2) 服务器配置</h3>
<ul>
<li>上传公钥文件到服务器
<ul>
<li><code>id_rsa.pub</code></li>
</ul></li>
</ul>
<h4 id="上传">上传</h4>
<ul>
<li><code>scp</code> 命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -P portNum 需要上传的文件路径 服务器用户名@服务器IP:服务器上的目录</span><br></pre></td></tr></table></figure>
<ul>
<li>例如
<ul>
<li>我的电脑用户名为 ABC</li>
<li>服务器的用户名为 <code>abc</code>，IP 地址为
<code>12.34.56.789</code></li>
<li>需要上传刚刚生成的 <code>id_rsa.pub</code>
文件到服务器的用户根目录</li>
</ul></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -P 22 &quot;C:\Users\ABC\.ssh\id_rsa&quot; abc@12.34.56.789:~/</span><br></pre></td></tr></table></figure>
<ul>
<li>如果使用 MobaXterm的话，直接拖进去就行</li>
</ul>
<h4 id="配置">配置</h4>
<ul>
<li>刚刚把 <code>id_rsa.pub</code> 上传到了用户根目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat  ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<ul>
<li>可以查看端口号
<ul>
<li>默认为 22</li>
<li>如下命令可以输出配置文件中含有 <code>Port</code> 信息的行</li>
</ul></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep Port /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<h3 id="客户端登陆">(3) 客户端登陆</h3>
<h4 id="命令行">命令行</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -i &quot;id_rsa文件目录&quot; 服务器用户名@服务器IP</span><br></pre></td></tr></table></figure>
<h4 id="配置-vscode">配置 vscode</h4>
<ul>
<li>安装插件</li>
</ul>
<p><img src="/2022/03/23/installation/ssh-rsa/image-20220323104740481.png"></p>
<ul>
<li>配置文件</li>
</ul>
<p><img src="/2022/03/23/installation/ssh-rsa/image-20220323111612500.png"></p>
<ul>
<li>新建一个配置文件（路径任意）</li>
<li>配置如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host 随便起个名字</span><br><span class="line">    HostName 服务器 IP</span><br><span class="line">    Port 服务器端口号(默认22)</span><br><span class="line">    User 服务器用户名</span><br><span class="line">    IdentityFile &quot;刚刚生成的私钥路径(id_rsa)&quot;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">2. 参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/sysk/p/4871700.html">SSH配置私钥登陆服务器</a></li>
</ul>
]]></content>
      <categories>
        <category>installation</category>
      </categories>
      <tags>
        <tag>installation</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Test</title>
    <url>/2021/01/26/test/test-hexo/</url>
    <content><![CDATA[<h1 id="代码测试">1. 代码测试</h1>
<h2 id="c">(1) C++</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="java">(2) java</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String...args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="latex测试">2. Latex测试</h1>
<p><span class="math display">\[
\sum_{n=1}^{\infty}a_{i}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
m&amp;=\sum_{i}k_if(p+k_ih)\\
&amp;=\sum_{i}k_i(f(p+k_ih)-f(p))\\
&amp;=\sum_{i}k_i(\nabla_{k_i}{f(p))}\\
\end{aligned}
\]</span></p>
<h1 id="图片测试">3. 图片测试</h1>
<p><img src="/2021/01/26/test/test-hexo/Maya.cliped.png"></p>
<h1 id="mermaid-测试">4. mermaid 测试</h1>
<pre class="mermaid">graph LR;
A[学生];
B{选修};
C[课程];
A---B---C;</pre>
<h1 id="pdf">5. pdf</h1>
<ul>
<li><a href="GoogleNet.pdf">GoogleNet</a></li>
</ul>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>高等代数.丘维声.00.说明</title>
    <url>/2021/01/26/Algebra/QWS/00/</url>
    <content><![CDATA[<h1 id="说明">1.说明</h1>
<ul>
<li>《高等代数》的学习笔记</li>
<li>《高等代数》
<ul>
<li>大学高等代数课程创新教材</li>
<li>丘维声著</li>
<li>2010.06 第一版</li>
<li>清华大学出版社</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Algebra</category>
        <category>0</category>
      </categories>
      <tags>
        <tag>Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>阴影算法的实现(SM、PCF、PCSS、VSM)</title>
    <url>/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/</url>
    <content><![CDATA[<h1 id="阴影算法的实现">阴影算法的实现</h1>
<ul>
<li>我们实现了从最经典的 Shadow Map
算法开始，实现了一系列的软阴影算法，包括 PCF、PCSS、VSM
三种软阴影算法</li>
<li>如下是我们的算法实现过程以及结果展示</li>
</ul>
<h2 id="说明">说明</h2>
<ul>
<li>环境
<ul>
<li>VS2017 <span style="color:red;font-weight:bold">x86</span></li>
<li>OpenGL 4.6（版本设置成了 3.3，之后的都行）</li>
</ul></li>
<li>依赖库
<ul>
<li>glad 0.1.34</li>
<li>glfw 3.3</li>
<li>glm 0.9.9.8</li>
</ul></li>
<li>代码
<ul>
<li><a href="https://github.com/banbao990/OpenGL/tree/main/Demo/Codes/project/SM-PCF-PCSS-VSM">Github</a>，需要按照
<a href="https://github.com/banbao990/OpenGL/blob/main/README.md">README</a>
配置</li>
<li><a href="/resources/CG/Algorithm/SM-PCF-PCSS-VSM/SM-PCF-PCSS-VSM.zip">打包好的源代码</a></li>
<li><a href="/resources/CG/Algorithm/SM-PCF-PCSS-VSM/VSM.pptx">PPT
报告</a></li>
</ul></li>
</ul>
<h2 id="算法介绍">算法介绍</h2>
<h3 id="sm">SM</h3>
<ul>
<li>Shadow Mapping</li>
<li>传统的 two-pass 阴影算法
<ul>
<li>第一个
pass，切换到以光源为视点的观察坐标系中，利用帧缓冲生成一张深度图
DepthMap</li>
<li>第二个 pass，正常渲染，对渲染的每一个 fragment
做可见性判断，得到一个<strong>非零即一</strong>的 visibility
<ul>
<li>将 shading point 通过第一个 pass 的变换得到的深度值和 DepthMap
中记录的对应位置的深度值作比较</li>
<li>如果 DepthMap
中记录的值小，说明当前的点对光源不可见，visibility=0</li>
<li>否则 visibility=1</li>
<li>用 visibility 乘上当前点的直接光照，进行遮蔽效果</li>
</ul></li>
</ul></li>
<li>在实现上可以使用定向光做平行投影生成
DepthMap，也可以使用点光源做透视投影生成 DepthMap</li>
</ul>
<h3 id="pcf">PCF</h3>
<ul>
<li>Percentage Closer Filter</li>
<li>由于 SM
得到的阴影结果是非零即一的值，这样子我们得到的边界就是一个很生硬的过渡（硬阴影），而实际生活中我们看到的阴影是有一个比较平滑的过渡（软阴影），这是由于我们定向光和点光源的假设在生活中是不成立的。生活中的光源是占据一块区域的，而不是只有一个点</li>
<li>为了模拟这种软阴影的效果，我们在 SM 第二个 pass 的时候做如下处理
<ul>
<li>对于每一个 shading
point，我们将其变换到以光源为视点的观察坐标系中的深度值和它对应的周围的
N 个点进行深度比较，求出一个 visibility 值</li>
<li><span class="math inline">\(\mathrm{visibility}=\dfrac{深度比当前点深度值大的采样点数目}{\mathrm{N}}\)</span></li>
<li>这样子我们得到的 visibility
的值就不是简单的非零即一的值，于是在边界产生过渡的效果</li>
</ul></li>
<li>上面的周围我们一般是给定半径 R，在半径为 R 的圆形区域内采样</li>
</ul>
<h3 id="pcss">PCSS</h3>
<ul>
<li>Percentage Closer Soft Shadow</li>
<li>我们在生活中还观察到另外一种现象，物体越靠近投射出阴影的平面，阴影越偏向于硬边界，物体越远离投射出阴影的平面的时候，阴影越偏向于软边界</li>
<li>如下图中，笔尖部分的阴影更硬，远离笔尖部分的阴影更软</li>
</ul>
<p><img src="/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/image-20210407175007126.png" style="zoom:50%;"></p>
<ul>
<li>这原因很简单，物体离成阴影平面越近，阴影过渡区域（半影）越小</li>
<li>下图中
<ul>
<li>红色区域表示半影区域</li>
<li>黄色部分表示全影区域</li>
<li>显然在阴影平面 1 上半影区域比阴影平面 2 更小</li>
</ul></li>
</ul>
<p><img src="/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/image-20210618203106841.png" style="zoom: 67%;"></p>
<ul>
<li>我们加一条蓝色的辅助线，我们发现阴影平面1上半影区域占全影区域的比例也更小</li>
</ul>
<p><img src="/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/image-20210618203601043.png" style="zoom: 67%;"></p>
<ul>
<li>也就是说我们要通过物体到阴影平面的距离来决定阴影的软硬程度，也就是采样半径
R 的大小</li>
<li>我们从上图中也了解到，半影区域也就是阴影过渡的区域，因此我们可以通过半影的大小估计采样半径
R</li>
<li><span id="anchor2">估计方式</span>如下图所示</li>
</ul>
<p><span class="math display">\[
w_{penumbra}=\dfrac{d_{Receiver}-d_{Blocker}}{d_{Blocker}}\cdot
w_{Light}
\]</span></p>
<p><img src="/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/image-20210407175256445.png" style="zoom: 33%;"></p>
<ul>
<li>但是同时这里出现了另外一个问题，<span class="math inline">\(d_{Blocker}\)</span>
的计算问题，可以通过给定固定范围的计算得到，或者<span id="anchor1">启发式的计算</span>得到</li>
</ul>
<p><img src="/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/image-20210407181810295.png" style="zoom: 33%;"></p>
<h3 id="vsm">VSM</h3>
<ul>
<li>Variance Shadow Mapping</li>
<li>VSM 算法试图使用计算的方式避免采样，因为采样是一个很慢的过程</li>
<li>我们对 shading point 周围的点进行深度的采样，计算得到的 visibility
本质上就是在估计周围有百分之多少的点深度值比当前点大，也就是说如果我们能够获取到这个百分比，就不需要采样了</li>
<li>切比雪夫不等式可以实现这一点</li>
</ul>
<p><span class="math display">\[
P(x&gt;t)\le\dfrac{\sigma^2}{\sigma^2+(t-\mu)^2}
\]</span></p>
<ul>
<li>切比雪夫不等式的条件是 <span class="math inline">\(t&gt;\mu\)</span>
以及分布是一个单峰的分布</li>
<li>给定一个深度值
t，我们可以通过其周围的深度均值与方差估计出当前点深度的排名</li>
<li>当然实时渲染中我们不等式直接当等式使用</li>
</ul>
<h2 id="场景说明">场景说明</h2>
<ul>
<li>我们的场景比较简单
<ul>
<li>一个点光源</li>
<li>一个跳动的小球和一排方柱子</li>
</ul></li>
</ul>
<p><img src="/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/2021.06.18-21.00.50.30.png" style="zoom:67%;"></p>
<h2 id="算法实现">算法实现</h2>
<h3 id="着色模型">着色模型</h3>
<ul>
<li>使用 Blinn-Phong 着色模型，由 diffuse + specular + ambient
三部分组成</li>
<li>shader 主要代码如下</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// 环境光 ambient</span></span><br><span class="line">    <span class="type">vec3</span> ambient = <span class="number">0.2</span> * color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 漫发射光 diffuse</span></span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">vec3</span> normal = <span class="built_in">normalize</span>(fs_in.Normal);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">vec3</span> diffuse = diff * color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 镜面高光 specular</span></span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Blinn-Phong 模型考虑法线和半角矢量的夹角</span></span><br><span class="line">    <span class="type">vec3</span> halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line">    spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">32.0</span>);</span><br><span class="line">    <span class="type">vec3</span> specular = <span class="type">vec3</span>(<span class="number">0.3</span>) * spec;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> visibility = <span class="number">1.0</span>f;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阴影算法</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    FragColor = <span class="type">vec4</span>(</span><br><span class="line">        ambient + visibility*(diffuse + specular), </span><br><span class="line">        <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>没有阴影的效果如下，缺乏真实感</li>
</ul>
<p><img src="/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/2021.06.18-21.06.28.17.png" style="zoom:67%;"></p>
<h3 id="sm-1">SM</h3>
<ul>
<li>第一趟利用 OpenGL 的帧缓冲生成一张 DepthMap</li>
<li>第二趟比较即可</li>
<li>shader 代码如下
<ul>
<li>注意这里的 DepthMap
中虽然你保存的是透视投影的深度，但是我们不需要变换成线性深度，因为只需要知道相对大小即可</li>
</ul></li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处于阴影之中: 0.0</span></span><br><span class="line"><span class="comment">// 否则返回 1.0</span></span><br><span class="line"><span class="type">float</span> ShadowCalculation(<span class="type">vec4</span> fragPosLightSpace) &#123;</span><br><span class="line">    <span class="comment">// 转化为标准齐次坐标, z:[-1, 1]</span></span><br><span class="line">    <span class="type">vec3</span> projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    <span class="comment">// xyz:[-1, 1] =&gt; [0,1]</span></span><br><span class="line">    projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 在深度图中获取深度信息</span></span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, projCoords.xy).r;</span><br><span class="line">    <span class="comment">// 当前片元的深度</span></span><br><span class="line">    <span class="type">float</span> currentDepth = projCoords.z;</span><br><span class="line">    <span class="comment">// 判断是否处于阴影当中</span></span><br><span class="line">    <span class="type">float</span> shadow = currentDepth-BIAS &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> - shadow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    visibility = ShadowCalculation(fs_in.FragPosLightSpace);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>效果如下，是我们想象中的硬阴影</li>
</ul>
<p><img src="/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/2021.06.18-21.06.30.75.png" style="zoom:67%;"></p>
<ul>
<li>注意上面的 BIAS 是为了解决自遮挡现象（黑白条纹）
<ul>
<li>由于 Z-Buffer 分辨率有限导致的</li>
<li>下图形象说明了这点，蓝色的点竟然不可见了</li>
</ul></li>
</ul>
<p><img src="/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/image-20210407160246926.png" style="zoom: 67%;"></p>
<ul>
<li>不加 BIAS 的效果</li>
</ul>
<p><img src="/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/2021.06.18-21.10.09.72.png" style="zoom:67%;"></p>
<h3 id="pcf-1">PCF</h3>
<ul>
<li>PCF 的实现和 SM 类似，只需要对周围点多采样几个即可，我们直接对周围 R
<span class="math inline">\(\times\)</span> R 的点进行一个遍历</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PCF 算法</span></span><br><span class="line"><span class="type">float</span> PCF(<span class="type">vec4</span> fragPosLightSpace, <span class="type">float</span> radius) &#123;</span><br><span class="line">    <span class="comment">// 采样距离修正</span></span><br><span class="line">    radius *= PCF_SampleRadius;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">float</span> currentDepth = projCoords.z;</span><br><span class="line">    <span class="type">vec2</span> texelSize = <span class="number">1.0</span> / <span class="built_in">textureSize</span>(depthMap, <span class="number">0</span>); <span class="comment">// 0 级纹理相邻纹素的距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = -PCF_RADIUS; x &lt;= PCF_RADIUS; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y = -PCF_RADIUS; y &lt;= PCF_RADIUS; ++y) &#123;</span><br><span class="line">            <span class="type">float</span> shadowMapDepth = <span class="built_in">texture</span>(depthMap, projCoords.xy + radius*<span class="type">vec2</span>(x, y) * texelSize).r;</span><br><span class="line">            shadow += currentDepth-BIAS &gt; shadowMapDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">float</span> total = (<span class="number">2</span>*PCF_RADIUS+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> - shadow/(total*total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    visibility = PCF(fs_in.FragPosLightSpace, <span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PCF_SampleRadius 修正是服务于 PCSS 的，试图让阴影扩散
<ul>
<li>因为我们不想让采样数过多，但是又需要考虑一个相对比较大的半径时，增大采样间隔</li>
</ul></li>
<li>效果如下，阴影变成了软阴影，但是所有阴影的边界模糊程度是相似的</li>
</ul>
<p><img src="/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/2021.06.18-21.06.33.02.png" style="zoom:67%;"></p>
<h3 id="pcss-1">PCSS</h3>
<ul>
<li>PCSS 分为 3 个步骤
<ul>
<li>Step 1: Blocker search
<ul>
<li>在某个区域内计算平均遮挡深度</li>
</ul></li>
<li>Step 2: Penumbra estimation
<ul>
<li>通过计算出来的平均遮挡深度来计算半影的大小</li>
</ul></li>
<li>Step 3: Percentage Closer Filtering
<ul>
<li>根据 Step 2 计算出来的大小进行 PCF</li>
</ul></li>
</ul></li>
<li>主体思路如下，由于我们需要进行深度的平均计算，这里必须使用<strong>线性深度</strong></li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> PCSS(<span class="type">vec4</span> fragPosLightSpace)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// depthMap 中的坐标</span></span><br><span class="line">    <span class="comment">// =&gt; [-1, 1]</span></span><br><span class="line">    <span class="type">vec3</span> projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    <span class="comment">// 转换为线性深度</span></span><br><span class="line">    <span class="type">float</span> depth = getLinearizeDepth(projCoords.z);</span><br><span class="line">    <span class="comment">// [-1, 1] =&gt; [0, 1]</span></span><br><span class="line">    projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// STEP 1: avgblocker depth</span></span><br><span class="line">    <span class="type">float</span> avgDepth = findBlocker(projCoords.xy, depth);</span><br><span class="line">    <span class="comment">// 没有遮挡物</span></span><br><span class="line">    <span class="keyword">if</span>(avgDepth == <span class="number">-1.0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// STEP 2: penumbra size</span></span><br><span class="line">    <span class="type">float</span> penumbra = (depth - avgDepth) / avgDepth * lightWidth;</span><br><span class="line">    <span class="type">float</span> filterRadius = penumbra * NEAR_PLANE / (depth);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// STEP 3: filtering</span></span><br><span class="line">    <span class="keyword">return</span> PCF(fs_in.FragPosLightSpace, filterRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    visibility = PCSS(fs_in.FragPosLightSpace);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一步我们根据上面提到的<a href="#anchor1">启发式估计方法</a>计算得到
<ul>
<li>这里的弥散参数修正是用于控制软阴影的边界，如果小了会被原来硬阴影的边界限制住（外面的都是可见）</li>
</ul></li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* uv: depthMap 中的坐标</span></span><br><span class="line"><span class="comment">* zRecerver: 计算得到的线性深度值 [0, 1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">float</span> findBlocker(<span class="type">vec2</span> uv, <span class="type">float</span> zReceiver) &#123;</span><br><span class="line">    <span class="type">int</span> blockers = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> ret = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">float</span> r = lightWidth * (zReceiver - NEAR_PLANE/FAR_PLANE) / zReceiver;</span><br><span class="line">    <span class="comment">// 弥散参数修正</span></span><br><span class="line">    r *= SMDiffuse;</span><br><span class="line">    <span class="type">vec2</span> texelSize = <span class="number">1.0</span> / <span class="built_in">textureSize</span>(depthMap, <span class="number">0</span>); <span class="comment">// 0 级纹理相邻纹素的距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = -BLOCK_RADIUS; x &lt;= BLOCK_RADIUS; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y = -BLOCK_RADIUS; y &lt;= BLOCK_RADIUS; ++y) &#123;</span><br><span class="line">            <span class="comment">// [0, 1]</span></span><br><span class="line">            <span class="type">float</span> shadowMapDepth = <span class="built_in">texture</span>(depthMap, uv + r*<span class="type">vec2</span>(x, y) * texelSize).r;</span><br><span class="line">            <span class="comment">// [0, 1] =&gt; [-1, 1]</span></span><br><span class="line">            shadowMapDepth = getLinearizeDepth(shadowMapDepth * <span class="number">2.0</span> - <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">if</span>(zReceiver - BIAS &gt; shadowMapDepth) &#123;</span><br><span class="line">                ret += shadowMapDepth;</span><br><span class="line">                ++blockers;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有 blocker</span></span><br><span class="line">    <span class="keyword">if</span>(blockers == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret/blockers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当第一步找到的平均遮挡物深度为 0 的时候，我们认为当前点可见，返回
visibility=1</li>
<li>第二步根据上面的<a href="#anchor">相似三角形</a>计算出 PCF
的采样半径即可</li>
<li>第三步就是 PCF</li>
<li>效果如下，明显看到软阴影和硬阴影的结果都有</li>
</ul>
<p><img src="/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/2021.06.18-21.06.34.97.png" style="zoom:67%;"></p>
<h3 id="vsm-1">VSM</h3>
<ul>
<li>我们需要生成两张图记录当前点对应点周围区域内的方差和均值</li>
<li>我们知道 <span class="math inline">\(\mathrm{var=E(X^2)-E^2X}\)</span>，因此我们只需要记录两张图，分别记录当前点周围区域的
<span class="math inline">\(\mathrm{EX,EX^2}\)</span> 即可</li>
<li>第一个 pass 我们使用帧缓冲生成一张颜色缓冲，R 通道记录深度值 <span class="math inline">\(\mathrm{d}\)</span>，G 通道记录 <span class="math inline">\(\mathrm{d^2}\)</span></li>
<li>然后我们需要生成一张周围点的均值和方差
<ul>
<li>利用两趟 pass 对周围的周围的点求平均值实现</li>
<li>两趟 pass 可以把每一个点的复杂度从 <span class="math inline">\((2R+1)^2\)</span> 降到 <span class="math inline">\((4R+2)\)</span></li>
</ul></li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define R 5</span></span><br><span class="line"><span class="meta">#define R21 11</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> d = <span class="type">vec2</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">vec2</span> texelSize = <span class="number">1.0</span> / <span class="built_in">textureSize</span>(d_d2, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(vertical) &#123;</span><br><span class="line">        <span class="type">float</span> r = texelSize.y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = -R; i &lt;= R; ++i) &#123;</span><br><span class="line">            d += <span class="built_in">texture</span>(d_d2, <span class="type">vec2</span>(TexCoords.x, TexCoords.y + i*r)).rg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">float</span> r = texelSize.x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = -R; i &lt;= R; ++i) &#123;</span><br><span class="line">            d += <span class="built_in">texture</span>(d_d2, <span class="type">vec2</span>(TexCoords.x + i*r, TexCoords.y)).rg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FragColor.rg = d/R21;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后一个 pass 的可见性估计如下
<ul>
<li>注意这里如果不满足切比雪夫不等式的条件的话，直接返回可见即可（深度值比平均深度小）</li>
</ul></li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// VSM 算法</span></span><br><span class="line"><span class="type">float</span> VSM(<span class="type">vec4</span> fragPosLightSpace) &#123;</span><br><span class="line">    <span class="type">vec3</span> projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    <span class="comment">// 转换为线性深度</span></span><br><span class="line">    <span class="type">float</span> depth = getLinearizeDepth(projCoords.z);</span><br><span class="line">    <span class="comment">// [-1, 1] =&gt; [0, 1]</span></span><br><span class="line">    projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec2</span> d_d2 = <span class="built_in">texture</span>(d_d2_filter, projCoords.xy).rg;</span><br><span class="line">    <span class="type">float</span> var = d_d2.y - d_d2.x * d_d2.x; <span class="comment">// E(X-EX)^2 = EX^2-E^2X</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不满足不等式, 直接可见</span></span><br><span class="line">    <span class="keyword">if</span>(depth - BIAS &lt; d_d2.x)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">float</span> t_minus_mu = depth - d_d2.x;</span><br><span class="line">        <span class="keyword">return</span> var/(var + t_minus_mu*t_minus_mu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    visibility = VSM(fs_in.FragPosLightSpace);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>效果如下，很好的软硬阴影结果，和 PCSS
的区别是，柱子的底部阴影更小了</li>
</ul>
<p><img src="/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/2021.06.18-21.06.37.04.png" style="zoom:67%;"></p>
<ul>
<li>VSM 存在一个很大的问题，漏光，当不满足单峰的长尾分布时，估计不准确
<ul>
<li>球的阴影漏光了</li>
</ul></li>
</ul>
<p><img src="/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/2021.06.18-21.52.38.86.png" style="zoom:67%;"></p>
<h2 id="其他">其他</h2>
<ul>
<li>小球运动的实现
<ul>
<li>利用物理公式计算出来位置即可</li>
</ul></li>
<li>小球的实现，类似于经纬度，切分成三角形
<ul>
<li>注意外面看进去得都是逆时针（OpenGL 逆时针为正向面）</li>
</ul></li>
</ul>
<h2 id="文件说明">文件说明</h2>
<ul>
<li>include 文件夹
<ul>
<li>一些依赖头文件</li>
<li>myUtils/basicModel.h：渲染一些基本模型</li>
</ul></li>
<li>lib 文件夹
<ul>
<li>库文件</li>
</ul></li>
<li>shaders 文件夹
<ul>
<li>gen_SM.vert, genSM_perspective.frag：pass 1 生成 DepthMap（<span class="math inline">\(d, d^2\)</span>）</li>
<li>light.vert, light.frag：pass 2 渲染光源</li>
<li>BlinnPhong.vert, BlinnPhong_perspective.frag：pass 2 渲染场景</li>
<li>gen_d_d2.vert, gen_d_d2.frag：生成均值（<span class="math inline">\(d, d^2\)</span>）</li>
</ul></li>
<li>Demo.exe
<ul>
<li>可执行文件</li>
</ul></li>
</ul>
<h3 id="执行文件">执行文件</h3>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Demo.exe</span><br></pre></td></tr></table></figure>
<ul>
<li>功能如下
<ul>
<li>W/A/S/D 和鼠标：切换视角</li>
<li>空格：可以让小球开始/停止运动</li>
<li>P/L： 增大/减小光源宽度（影响PCSS）</li>
<li>O/K：增大/减小平均深度的寻找半径，限制 PCSS 的阴影范围</li>
<li>I/J：增大/减小 PCF 采样半径，阴影弥散参数（影响 PCF、PCSS）</li>
<li>0/1/2/3/4：选择阴影种类
<ul>
<li>0(No Shadow), 1(Shadow Map), 2(PCF), 3(PCSS), 4(VSM)</li>
</ul></li>
</ul></li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://learnopengl-cn.github.io/">LearnOpenGL
框架性代码</a></li>
<li>GAMES202 课程：<a href="https://www.bilibili.com/video/BV1YK4y1T7yY?p=3">PCSS</a>、<a href="https://www.bilibili.com/video/BV1YK4y1T7yY?p=4">PCSS/VSM</a></li>
<li><a href="http://developer.download.nvidia.com/whitepapers/2007/SDK10/VarianceShadowMapping.pdf">Nvidia
VSM 白皮书</a></li>
<li><a href="https://github.com/mrdoob/three.js/blob/master/examples/webgl_shadowmap_pcss.html">PCSS
的平行投影实现</a></li>
<li>论文：<a href="https://software.intel.com/content/dam/develop/external/us/en/documents/vsm-paper-182629.pdf">Variance
Shadow Maps</a></li>
</ul>
]]></content>
      <categories>
        <category>CG.Algorithm</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>CG-Algorithm</tag>
        <tag>Shadow</tag>
      </tags>
  </entry>
  <entry>
    <title>高动态范围成像</title>
    <url>/2021/03/04/CV/HDR/Paper23/</url>
    <content><![CDATA[<h1 id="hdr-高动态范围成像">HDR 高动态范围成像</h1>
<ul>
<li>代码路径
<ul>
<li>https://github.com/banbao990/CV/tree/main/HDR</li>
</ul></li>
</ul>
<h2 id="一.-概述">一. 概述</h2>
<p>HDR 高动态范围成像的主要内容有 3
个部分，具体的内容以及参考文献如下</p>
<ul>
<li>论文 1：利用多张不同曝光时间的图片重建 HDR 图片
<ul>
<li>Recovering High Dynamic Range Radiance Maps from Photographs</li>
</ul></li>
<li>论文 2：利用单张 LDR 图片和 intensity map 图片重建 HDR 图片
<ul>
<li>Neuromorphic Camera Guided High Dynamic Range Imaging</li>
</ul></li>
<li>论文 3：对单张 LDR 图片，利用 deep-CNNs 重建 HDR 图片
<ul>
<li>HDR image reconstruction from a single exposure using deep CNNs</li>
</ul></li>
</ul>
<p>接下来的内容就围绕着这 3 篇论文展开</p>
<h2 id="二.-正文">二. 正文</h2>
<h3 id="论文-1利用多张不同曝光时间的图片重建-hdr-图片">论文
1：利用多张不同曝光时间的图片重建 HDR 图片</h3>
<blockquote>
<p>Recovering High Dynamic Range Radiance Maps from Photographs</p>
</blockquote>
<h3 id="论文-2利用单张-ldr-图片和-intensity-map-图片重建-hdr-图片">论文
2：利用单张 LDR 图片和 intensity map 图片重建 HDR 图片</h3>
<blockquote>
<p>Neuromorphic Camera Guided High Dynamic Range Imaging</p>
</blockquote>
<h4 id="主要目的">2.1 主要目的</h4>
<ul>
<li>利用单张 LDR 图片和 intensity map 图片重建 HDR 图片</li>
<li>由于一张 RGB 的LDR 的图片在高曝光和低曝光区域都存在一些细节缺失，而
intensity map
中保留了所有区域的深度信息，因此可以在某种意义上使用这两张图片恢复出一张
HDR 的图片，该论文的第一部分就介绍了这样的一种方法</li>
</ul>
<h4 id="主要方法">2.2 主要方法</h4>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_001.png"></p>
<ul>
<li>以上是流程图，具体的步骤如下
<ul>
<li>首先我们利用相机响应函数将 LDR
的图片从非线性转化到线性空间得到图片pic1</li>
<li>将 pic1 从 RGB 空间转换到 YUV 空间中得到 pic2，此时 Y
平面中包含了图象的深度信息</li>
<li>将 intensity map 过采样到和 LDR 图片大小相同得到 pic3</li>
<li>将 pic3 和 pic2 的 Y 平面进行融合得到 pic4</li>
<li>将 pic4 作为 pic2 的 Y 平面，将其转化为 RGB 空间</li>
<li>最后通过 tone mapping 将图片转化为观感较好的 RGB 图片</li>
</ul></li>
</ul>
<h4 id="具体的实现与效果展示">2.3 具体的实现与效果展示</h4>
<ul>
<li>使用 opencv 的 python 版本实现</li>
<li>具体使用到的库以及 python 的版本信息如下</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">python: 3.7.9 [MSC v.1916 64 bit (AMD64)]</span><br><span class="line">matplotlib: 3.3.2</span><br><span class="line">numpy: 1.19.1</span><br><span class="line">cv2: 4.4.0</span><br></pre></td></tr></table></figure>
<ul>
<li><p>每一步的实现如下，具体细节见代码</p></li>
<li><p>以下以示例图片作为简单的效果展示</p></li>
<li><p>示例图片</p>
<ul>
<li><p>ldr 图片</p>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_ex_ldr.jpg" alt="img" style="zoom:50%;"></p></li>
<li><p>intensity map</p>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_ex_intensity_map.jpg"></p></li>
<li><p>ground truth</p>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_ex_ground_truth.jpg" alt="img" style="zoom:50%;"></p></li>
</ul></li>
</ul>
<h5 id="逆色调映射">(1) 逆色调映射</h5>
<ul>
<li>因为我们不知道相机的响应函数以及图片的曝光时间，因此使用简单的
gamma2.2 校正
<ul>
<li><span class="math inline">\(y=x^\frac{1}{\gamma},gamma=2.2\)</span></li>
</ul></li>
<li>效果图如下</li>
</ul>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_ex_ldr_linear.jpg" alt="img" style="zoom:50%"></p>
<h5 id="rgb-空间转换为-yuv-空间">(2) RGB 空间转换为 YUV 空间</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># opencv 自带的函数</span></span><br><span class="line">cv2.cvtColor(ldr_linear, cv2.COLOR_BGR2YUV)</span><br></pre></td></tr></table></figure>
<ul>
<li>展示 YUV 空间的图片</li>
</ul>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_ex_ldr_yuv.png"></p>
<ul>
<li>我们看到这里的 Y 平面中确实含有一定的深度信息</li>
</ul>
<h5 id="intensity-map-的大小转换">(3) intensity map 的大小转换</h5>
<ul>
<li>使用论文中给的使用 INTER_CUBIC 三次样条插值</li>
</ul>
<h5 id="深度融合">(4) 深度融合</h5>
<ul>
<li><p>尝试了两种融合方法</p>
<ul>
<li>论文中给的是 <span class="math inline">\(w_{ij}∗Y_{ij}+(1-w_i)∗I_{ij}\)</span>
<ul>
<li>其中</li>
</ul></li>
</ul>
<p><span class="math display">\[
  w_{ij}=\frac{(0.5-max(|I_{ij}-0.5|,τ-0.5))}{(1-τ)}
  \]</span></p>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_weight_funciton.png" alt="1610207884863" style="zoom: 40%;"></p>
<ul>
<li><span class="math inline">\(w_{ij}∗Y_{ij}+I_{ij}\)</span></li>
</ul></li>
<li><p>展示效果图如下</p></li>
</ul>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_ex_fusion.png"></p>
<h5 id="最后的色调映射">(5) 最后的色调映射</h5>
<ul>
<li><p>简单的使用 gamma2.2 校正</p></li>
<li><p>效果展示</p>
<ul>
<li>使用论文函数 (w)</li>
</ul>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_ex_result.1.jpg" alt="img" style="zoom:80%;"></p>
<ul>
<li>使用函数 (1-w)</li>
</ul>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_ex_result.1.minus.w.jpg" alt="img" style="zoom:80%;"></p></li>
<li><p>图上我们可以看到亮处的深度信息已经被恢复出来，但是颜色信息缺失了</p></li>
<li><p>上下对比，我们发现使用函数 w
的图片更加亮一些，但是出现了一些模糊的现象（例如水管部分）</p>
<ul>
<li>更亮是因为使用 w 得到的值更大</li>
<li>模糊是因为 ldr 图片和 intensity map
的对齐问题，对齐问题在两张图的深度都占一定比例时体现的最完全，也就是亮度中等的时候</li>
</ul></li>
<li><p>颜色信息缺失是没有办法的，因为我们没有处理原图的 U/V
两个平面的颜色信息，而只是补充上了深度信息</p></li>
<li><p>而论文中最后使用神经网络生成的图像从 U/V
两个平面学到了色彩信息，因此填充上了色彩</p></li>
<li><p>还有存在的问题是过渡效果比较差，因为 intensity map
中整体偏暗，导致结果图中本应该是亮色的部分反而偏暗，因此过渡比较难看</p></li>
</ul>
<h4 id="一些改进与颜色校正的尝试">2.4 一些改进与颜色校正的尝试</h4>
<ul>
<li>在上课做完报告之后，我们发现在 intensity map
之中确实整体偏暗，导致合成的结果亮色部分偏暗，以下是我们的一些修改策略</li>
<li>以下以示例图片为例，展示如下</li>
</ul>
<h5 id="直方图均衡化-调库256采样">(1) 直方图均衡化 (调库+256采样)</h5>
<ul>
<li><p>原始的直方图</p>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_ex_hist_origin.jpg" alt="img" style="zoom:40%;"></p></li>
<li><p>直接调用内置的函数实现，但是内置的函数只能实现 256
精度的采样</p></li>
</ul>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_ex_result.1.minus.w.equalize_hist(256).jpg" alt="img" style="zoom: 80%;"></p>
<ul>
<li><p>效果如上图所示，我们发现亮色部分的提升很明显，但是暗色部分的噪声也很明显</p>
<ul>
<li><p>这一方面是时直方图均衡化采样精度低导致的问题</p>
<ul>
<li>采样精度低会导致结果并不是很均衡，丧失高动态范围</li>
</ul></li>
<li><p>另一方面是原生的问题 intensity map 本来分辨率就低导致的</p></li>
<li><p>均衡化的直方图如下</p>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_ex_hist_256.jpg" alt="img" style="zoom:40%;"></p></li>
</ul></li>
</ul>
<h5 id="直方图均衡化-高采样">(2) 直方图均衡化 (高采样)</h5>
<ul>
<li><p>自己写的一个高精度的直方图均衡化</p></li>
<li><p>采样精度为 10000，直方图如下</p>
<ul>
<li>基本上实现了均衡化</li>
</ul>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_ex_hist_10000.jpg" alt="img" style="zoom:40%;"></p></li>
<li><p>但是最终合成效果还是不太好，噪声很严重（似乎更严重了，噪声的采样也更细致了）</p>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_ex_result.1.minus.w.equalize_hist(10000).jpg" alt="img" style="zoom: 80%;"></p></li>
</ul>
<h5 id="调整权重函数">(3) 调整权重函数</h5>
<ul>
<li><p>手动设置范围将暗部噪声减弱</p></li>
<li><p>一个简单的操作就是直接将暗处的 intensity map
舍去，将权重函数修改为如下 <span class="math display">\[
  w_{ij}=\frac{(0.5-max(I_{ij}-0.5,τ-0.5))}{(1-τ)}
  \]</span>
<img src="/2021/03/04/CV/HDR/Paper23/J_weight_funciton.only.bright.png" alt="1610207884863" style="zoom: 40%;"></p></li>
<li><p>虽然说这样就舍弃了暗部的高动态范围，但是这和噪声相比不算什么</p></li>
<li><p>效果如下</p>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_ex_result.1.minus.w.equalize_hist(10000).only.bright.jpg" alt="img" style="zoom:80%;"></p></li>
<li><p>感觉还是很棒的，过度效果也挺好的</p></li>
</ul>
<h4 id="其他图片的效果图">2.5 其他图片的效果图</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO</span></span><br></pre></td></tr></table></figure>
<h5 id="图片1的结果">(1) 图片1的结果</h5>
<ul>
<li>效果很好，过渡比原来直接做的效果好太多了</li>
<li>不使用 intensity map 的暗部也使得噪声控制很好</li>
</ul>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_1_all.png"></p>
<h5 id="图片2的结果">(2) 图片2的结果</h5>
<ul>
<li>效果一般，但是色调比较正常</li>
<li>过渡也比较好，但是跟 ldr 图片相比，最终的动态范围提升不大
<ul>
<li>这张图片的主要提升点应该在暗部，但是我们现在的解决方案对暗部提升没有作用</li>
</ul></li>
</ul>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_2_all.png"></p>
<ul>
<li><p>尝试了一个其他的方法</p>
<ul>
<li><p>对整体进行一个校正，暗处加强，亮处减弱 <span class="math display">\[
  s=T(r)=\frac{(2x-1)^{\alpha}+1}{2}
  \]</span></p></li>
<li><p><img src="/2021/03/04/CV/HDR/Paper23/J_adjusted.jpg" alt="img" style="zoom:33%;"></p></li>
<li><p>使用 1-w，仅保留 intensity map 中的亮部</p></li>
<li><p>效果如下</p>
<ul>
<li>相较于之前而言，整体配色接近原始图片，而且在亮处的过度也稍微好一些，此时暗处提确实提高了亮度</li>
</ul>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_2_result.1.minus.w.adjusted.only.bright.jpg" alt="img" style="zoom: 80%;"></p></li>
</ul></li>
</ul>
<h3 id="论文-3对单张-ldr-图片利用-deep-cnns-重建-hdr-图片">论文
3：对单张 LDR 图片，利用 deep-CNNs 重建 HDR 图片</h3>
<blockquote>
<p>HDR image reconstruction from a single exposure using deep CNNs</p>
</blockquote>
<h4 id="环境配置">3.1 环境配置</h4>
<ul>
<li>实验环境 Google Colab</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">tensorflow-gpu==1.12.0</span><br><span class="line">tensorlayer==1.11.0</span><br><span class="line">OpenEXR-1.3.2</span><br></pre></td></tr></table></figure>
<ul>
<li>遇到一些问题
<ul>
<li>本地配置可能需要比较大的显存
<ul>
<li>至少大于 2G</li>
</ul></li>
<li>对于比较大的图片上的输入，可能也跑不动</li>
</ul></li>
</ul>
<h4 id="方法简述">3.2 方法简述</h4>
<ul>
<li><p>构造一个神经网络如下，训练从一张图片生成 HDR 的能力</p>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_network.png"></p></li>
<li><p>设计亮点</p>
<ul>
<li>skip-connection
<ul>
<li>保留高维细节</li>
</ul></li>
<li>HDR-decoder 对比
<ul>
<li>log 域</li>
<li>范围大</li>
</ul></li>
<li>损失函数
<ul>
<li>直接差异R + 正则项 I</li>
<li>颜色，细节 + 全局亮度</li>
<li>I =&gt; 只能处理高曝光的补全</li>
<li>只能够补全高曝光面积较小的区域</li>
</ul></li>
</ul></li>
<li><p>本质上神经网络是学习到了加强高曝光区域的细节</p>
<ul>
<li>如果输入的图片在高曝光区域没有任何细节，那么是无法恢复的</li>
</ul></li>
</ul>
<h4 id="效果展示">3.3 效果展示</h4>
<h5 id="示例图片">(1) 示例图片</h5>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_3_001.png"></p>
<ul>
<li>效果很好，甚至文字细节都展示出来了</li>
</ul>
<h5 id="论文-1-的图片">(2) 论文 1 的图片</h5>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_3_002.png"></p>
<ul>
<li>效果超级好</li>
<li>灯顶、窗户细节</li>
</ul>
<h5 id="论文-2-的图片">(2) 论文 2 的图片</h5>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_3_003.png"></p>
<ul>
<li>首先恢复了一些颜色信息，这是论文 2 的简单方法做不到的，这个很强
<ul>
<li>红色区域</li>
</ul></li>
<li>出现了一些问题，树枝周围存在一些阴影
<ul>
<li>绿色区域</li>
<li>神经网络本质上是加强了高曝光区域的细节，这里细节信息比较少，因此将树枝周围的小的高曝光区域使用树枝的成分进行了补全，导致在结果上产生了阴影</li>
</ul></li>
</ul>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_3_004.png"></p>
<ul>
<li>对于低曝光区域，神经网络无法给出结果</li>
</ul>
<h5 id="自己拍的照片">(3) 自己拍的照片</h5>
<ul>
<li><p>灯光</p>
<ul>
<li>能够很好的将灯光细节恢复过来</li>
</ul>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_3_005.png"></p></li>
<li><p>安全入口标志</p>
<ul>
<li>也能除去一些发光的亮晕</li>
<li>对于上面的灯，也有一定的缩小光电的作用</li>
</ul>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_3_006.png"></p></li>
<li><p>中文字</p>
<ul>
<li>恢复没有英文字那么明显，可能是中文字符的连接比较复杂，没有英文字符那么容易修复</li>
</ul>
<p><img src="/2021/03/04/CV/HDR/Paper23/J_3_007.png"></p></li>
</ul>
<h2 id="三.-总结">三. 总结</h2>
<h3 id="方法对比">(1) 方法对比</h3>
<ul>
<li>论文 1：利用多张不同曝光时间的图片重建 HDR 图片
<ul>
<li>优点
<ul>
<li>理论基础好，图片较多时恢复效果好</li>
<li>能够把高曝光和低曝光区域的高动态范围都做的很好</li>
</ul></li>
<li>缺点
<ul>
<li>需要大量已知曝光时间的照片</li>
<li>需要自己设定最终的色调映射函数
<ul>
<li>设置不好的时候会出现奇怪的色彩</li>
</ul></li>
<li>多张图片需要处理对齐的问题</li>
</ul></li>
</ul></li>
<li>论文 2：利用单张 LDR 图片和 intensity map 图片重建 HDR 图片
<ul>
<li>优点
<ul>
<li>能够将图像的深度信息较好的恢复</li>
<li>两张照片即可，相对容易获取</li>
</ul></li>
<li>缺点
<ul>
<li>需要获得 intensity map</li>
<li>恢复不出来颜色信息</li>
<li>需要自己设置色调映射函数</li>
<li>可能需要进行 ldr 图片和 intensity map 的对齐
<ul>
<li>存在一定的偏差</li>
</ul></li>
<li>每一张图片的性质不同，如果要恢复得比较好的话，需要对每一张图片进行调节</li>
<li>intensity map
的低分辨率导致图片的低曝光区域噪声很多，因此对低曝光区域的恢复也不太好</li>
</ul></li>
</ul></li>
<li>论文 3：对单张 LDR 图片，利用 deep-CNNs 重建 HDR 图片
<ul>
<li>优点
<ul>
<li>所需材料少，获取材料简单</li>
<li>效果其实很好，使用论文1 中一张合适的图片便可以将整体恢复得很好</li>
</ul></li>
<li>缺点
<ul>
<li>训练一个这样的神经网络需要大量的材料和算力</li>
<li>需要有一定的硬件设备
<ul>
<li>显卡内存需要比较大</li>
</ul></li>
<li>只能恢复高曝光饱和的情况</li>
<li>细节缺失严重的时候恢复不出来</li>
<li>回复的细节信息可能与实际有所偏差</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>HDR</tag>
      </tags>
  </entry>
  <entry>
    <title>NEE、MIS(多重重要性采样)</title>
    <url>/2022/04/28/CG/Kits/MIS-NEE/</url>
    <content><![CDATA[<h1 id="nee">NEE</h1>
<ul>
<li>Next Event Estimation</li>
<li>参考资料
<ul>
<li><a href="https://www.youtube.com/watch?v=FU1dbi827LY">Youtube</a></li>
<li><a href="https://www.cg.tuwien.ac.at/sites/default/files/course/4411/attachments/08_next%20event%20estimation.pdf">课件</a></li>
</ul></li>
</ul>
<h2 id="概念">概念</h2>
<ul>
<li>NEE
的概念非常简单，就是在做积分的时候，将<strong>直接光照</strong>和<strong>间接光照</strong>区分开
<ul>
<li>相当于分块积分</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
I&amp;=\int_{\Omega}g(X)\mathrm{d}\mu(X)\\
&amp;=\int_{\Omega_1}g(X)\mathrm{d}\mu(X)+\int_{\Omega_2}g(X)\mathrm{d}\mu(X)\\
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\Omega_1\cap\Omega_2=\emptyset,\Omega_1\cup\Omega_1=\Omega
\]</span></p>
<h2 id="直接光照采样">直接光照采样</h2>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/image-20220428155924708.png"></p>
<ul>
<li>这里的一个细节，需要将对光源的采样转化为对立体角的采样</li>
</ul>
<h3 id="算法流程">算法流程</h3>
<ul>
<li>首先在光源上采样，计算出贡献</li>
<li>计算可见性，如果不可见，则计算得到的值为 0</li>
</ul>
<h3 id="实现">实现</h3>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/image-20220428160114276.png"></p>
<h3 id="结果">结果</h3>
<ul>
<li>结果肯定是有偏的，因为只有 1-bounce 的光路，需要配合其他方法
<ul>
<li>因为积分区域没有覆盖整个 BRDF 的定义域</li>
</ul></li>
</ul>
<h2 id="nee-1">NEE</h2>
<ul>
<li>总体的思路是这样的</li>
</ul>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/image-20220428162944585.png"></p>
<h3 id="实现1">实现1</h3>
<ul>
<li>在 path tracing 的框架中，每次求某一个点的 radiance
的时候，我们做两次采样，分别计算直接光照的和间接光照</li>
<li>重复计算问题</li>
</ul>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/image-20220428165331187.png"></p>
<ul>
<li>直接光照采样，就和上面一样
<ul>
<li>光源上采样一个位置，判断可见性，计算贡献值</li>
</ul></li>
<li>间接光照采样
<ul>
<li>如果直接按照 BSDF 采样，那么结果是有偏的（太亮了）</li>
<li>按照 BSDF
采样，这里的积分区域包含了上面光源的积分区域，导致重复计算</li>
<li>PPT 上给的一个实现，将第一次 bounce 之后的间接光照减半</li>
</ul></li>
</ul>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/image-20220428163330740.png"></p>
<ul>
<li>这种实现是无偏的吗？
<ul>
<li><strong><span style="color:red">感觉不是无偏的</span></strong></li>
</ul></li>
</ul>
<h3 id="实现-2">实现 2</h3>
<ul>
<li>直接分离光照来源
<ul>
<li>只有在直接光照采样的部分打到光源，才返回光源的 emission</li>
<li>如果在间接光照采样的部分打到光源，返回 0</li>
</ul></li>
<li>这是无偏的
<ul>
<li>所有路径都会被计算，且只会被计算一次</li>
</ul></li>
</ul>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/image-20220428173622838.png"></p>
<ul>
<li>另外一种写法
<ul>
<li>镜面特殊处理，因为镜面没有直接光源采样（采不到）</li>
</ul></li>
</ul>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/image-20220428173721033.png"></p>
<h2 id="问题">问题</h2>
<ul>
<li>我们使用 <code>NEE</code>
的原因是认识<strong>对光源采样</strong>比<strong>按照 BSDF
采样要好</strong></li>
<li>实际上对光源采样也会有问题
<ul>
<li><strong>不能很好的采样大光源</strong></li>
</ul></li>
</ul>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/image-20220428174955945.png"></p>
<ul>
<li>BSDF：能够较好采样大光源，对小光源采样差</li>
<li>采样光源：能够较好采样小光源，对大光源采样差</li>
<li>原因如下
<ul>
<li>对于大光源，直接采样光源（面积）的范围比采样 BSDF（立体角）更大</li>
<li>可以理解为立体角是面积采样的 Stratified Sampling
<ul>
<li>面积采样有很多无效采样，例如一小部分面积内部可能一样</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/image-20220428175359024.png"></p>
<h3 id="经典老图">经典老图</h3>
<ul>
<li><a href="/utils/image_compare/?/2022/04/28/CG/Kits/MIS-NEE/;brdf.png;light.png;mis.png">效果对比</a></li>
<li>Sampling the light sources</li>
</ul>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/light.png"></p>
<ul>
<li>Sampling the BRDF</li>
</ul>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/brdf.png"></p>
<ul>
<li>A combination of samples from (a) and (b)</li>
</ul>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/mis.png"></p>
<h1 id="mis">MIS</h1>
<ul>
<li>Multiple Importance Sampling
<ul>
<li>多种重要性采样</li>
</ul></li>
<li><a href="https://www.cg.tuwien.ac.at/sites/default/files/course/4411/attachments/08_mis.pdf">课件</a></li>
<li>结合多种采样方式，更准确地说，结合多个 <code>pdf</code></li>
</ul>
<h2 id="理论">理论</h2>
<ul>
<li>如果 <span class="math inline">\(\sum_{i=1}^{n}w_i=1\)</span>
<ul>
<li><span class="math inline">\(X_{i,j}\)</span> 表示使用第 <span class="math inline">\(i\)</span> 种采样方案采样到的第 <span class="math inline">\(j\)</span> 个样本</li>
<li><span class="math inline">\(p_i(X_{i,j})\)</span> 表示这个方向在第
<span class="math inline">\(i\)</span> 个 pdf 中的返回值</li>
</ul></li>
</ul>
<p><span class="math display">\[
F_i=\sum_{j=1}^{n_i}w_{i}(X_{i,j})\dfrac{f(X_{i,j})}{p_i(X_{i,j})}
\]</span></p>
<p><span class="math display">\[
F=\sum_{i=1}^{n}\dfrac{1}{n_i}F_i
\]</span></p>
<ul>
<li>注意 <span class="math inline">\(w_i(x)\)</span> 和 <span class="math inline">\(x\)</span> 相关，不能够将其从积分号中提出来</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
E[F]
&amp;=\sum_{i=1}^{n}\dfrac{1}{n_i}E(F_i)\\
&amp;=\sum_{i=1}^{n}\dfrac{1}{n_i}\int_{\Omega}\sum_{j=1}^{n_i}w_{i}(x)\dfrac{f(x)}{p_i(x)}p_{i}(x)\;\mathrm{d}\mu(x)\\
&amp;=\sum_{i=1}^{n}\dfrac{1}{n_i}\int_{\Omega}\sum_{j=1}^{n_i}w_{i}(x)f(x)\;\mathrm{d}\mu(x)\\
&amp;=\sum_{i=1}^{n}\int_{\Omega}\dfrac{1}{n_i}\cdot
n_iw_{i}(x)f(x)\;\mathrm{d}\mu(x)\\
&amp;=\sum_{i=1}^{n}\int_{\Omega}w_{i}(x)f(x)\;\mathrm{d}\mu(x)\\
&amp;=\int_{\Omega}\sum_{i=1}^{n}w_{i}(x)f(x)\;\mathrm{d}\mu(x)\\
&amp;=\int_{\Omega}\left(\sum_{i=1}^{n}w_{i}(x)\right)f(x)\;\mathrm{d}\mu(x)\\
&amp;=\int_{\Omega}f(x)\;\mathrm{d}\mu(x)\\
\end{aligned}
\]</span></p>
<ul>
<li>使用上面的这种方式就可以结合不同的采样策略（不同的采样 pdf）</li>
</ul>
<h2 id="确定-w_i">确定 <span class="math inline">\(w_i\)</span></h2>
<ul>
<li>如何确定 <span class="math inline">\(w_i\)</span></li>
<li>Balance heuristic
<ul>
<li>You can’t do much better than that, i.e. it’s always within a bound
of the best strategy</li>
<li><a href="http://graphics.stanford.edu/papers/veach_thesis/">Veach</a></li>
<li><span class="math inline">\(c_i\)</span> 表示使用第 <span class="math inline">\(i\)</span> 种采样策略的概率
<ul>
<li><span class="math inline">\(\sum_{i=1}^{n}c_i=1\)</span></li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
w_i(x)=\dfrac{c_ip_i(x)}{\sum_{k=1}^{n}c_kp_k(x)}
\]</span></p>
<ul>
<li>Power heuristic
<ul>
<li>better if there is one strategy with very low variance</li>
</ul></li>
</ul>
<p><span class="math display">\[
w_i(x)=\dfrac{p_i^{\beta}(x)}{\sum_{k=1}^{n}p_k^{\beta}(x)}
\]</span></p>
<h2 id="balance-heuristic">Balance heuristic</h2>
<ul>
<li>细节推导</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
E[F]
&amp;=\sum_{i=1}^{n}\dfrac{1}{n_i}E[F_i]\\
&amp;=\sum_{i=1}^{n}\dfrac{1}{n_i}E\left[\sum_{j=1}^{n_i}\dfrac{f(X_{i,j})w_i(X_{i,j})}{p_i(X_{i,j})}\right]\\
&amp;=\sum_{i=1}^{n}\dfrac{1}{n_i}\sum_{j=1}^{n_i}E\left[\dfrac{f(X_{i,j})w_i(X_{i,j})}{p_i(X_{i,j})}\right]\\
&amp;=\sum_{i=1}^{n}\sum_{j=1}^{n_i}\dfrac{1}{n_i}E\left[\dfrac{f(X_{i,j})c_ip_i(X_{i,j})}{p_i(X_{i,j})\sum_{k=1}^{n}c_kp_k(X_{i,j})}\right]\\
&amp;=\sum_{i=1}^{n}\sum_{j=1}^{n_i}\dfrac{c_i}{n_i}E\left[\dfrac{f(X_{i,j})}{\sum_{k=1}^{n}c_kp_k(X_{i,j})}\right]\\
&amp;=\sum_{i=1}^{n}\sum_{j=1}^{n_i}\dfrac{1}{N}E\left[\dfrac{f(X_{i,j})}{\sum_{k=1}^{n}c_kp_k(X_{i,j})}\right]\\
&amp;=\dfrac{1}{N}\sum_{i=1}^{n}\sum_{j=1}^{n_i}E\left[\dfrac{f(X_{i,j})}{\sum_{k=1}^{n}c_kp_k(X_{i,j})}\right]\\
&amp;=\dfrac{1}{N}\sum_{i=1}^{N}E\left[\dfrac{f(X_{i})}{\sum_{k=1}^{n}c_kp_k(X_{i})}\right]\\
\end{aligned}
\]</span></p>
<ul>
<li>使用 MC 的方式的话，相当于使用一个联合分布 <span class="math inline">\(\bar{p}(x)\)</span> 进行采样</li>
</ul>
<p><span class="math display">\[
\bar{p}(x)=\sum_{k=1}^{n}c_kp_k(x)
\]</span></p>
<ul>
<li>这样我们就可以很容易的将 BSDF 采样和对光源采样结合在一起</li>
<li>一般而言，很容易实现对多种 pdf 的采样</li>
</ul>
<h2 id="效果图">效果图</h2>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/mis.png"></p>
<h1 id="效果图-1">效果图</h1>
<ul>
<li>100spp</li>
<li><a href="/utils/image_compare/?/2022/04/28/CG/Kits/MIS-NEE/;brdf-100spp-18s.png;light-100spp-8s.png;brdf-with-light-100spp-12s.png;nee-100spp-37s.png;hemi-100ssp-19s.png">效果对比</a></li>
</ul>
<h2 id="法向半球采样">法向半球采样</h2>
<ul>
<li>19s</li>
</ul>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/hemi-100ssp-19s.png"></p>
<h2 id="brdf">BRDF</h2>
<ul>
<li>18s</li>
</ul>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/brdf-100spp-18s.png"></p>
<h2 id="light">Light</h2>
<ul>
<li>8s</li>
</ul>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/light-100spp-8s.png"></p>
<h2 id="mis-with-brdf-and-light">MIS with BRDF and Light</h2>
<ul>
<li>12s</li>
</ul>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/brdf-with-light-100spp-12s.png"></p>
<h2 id="nee-2">NEE</h2>
<h3 id="实现1-1">实现1</h3>
<ul>
<li>37s</li>
</ul>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/nee-implement1-100spp-37s.png"></p>
<ul>
<li>1000spp, 417s</li>
</ul>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/nee-implement1-1000spp-417s.png"></p>
<ul>
<li>可以看出来确实亮一些，是有偏的</li>
</ul>
<h3 id="实现2">实现2</h3>
<p><img src="/2022/04/28/CG/Kits/MIS-NEE/nee-100spp-37s.png"></p>
]]></content>
      <categories>
        <category>CG.Kits</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>NEE</tag>
        <tag>MIS</tag>
      </tags>
  </entry>
  <entry>
    <title>Stratified Sampling 分层采样</title>
    <url>/2022/03/15/CG/Kits/StratifiedSampling/</url>
    <content><![CDATA[<h1 id="stratified-sampling">Stratified Sampling</h1>
<h2 id="分层采样">分层采样</h2>
<ul>
<li>分层采样就是将采样区域划分为若干个区域，这些区域两两不相交，所有区域的并为原始的积采样区域</li>
<li>在不同区域上分配的样本数，和他们区域上的测度成比例</li>
<li>此时得到的结果仍然是对原始估计的一个无偏估计，而且<strong>方差更小</strong></li>
</ul>
<h3 id="直观感觉">直观感觉</h3>
<ul>
<li>采样的点数没有减少，方差不会变大</li>
<li>分组这个操作提供了新的信息
<ul>
<li>想象如下例子，你找的划分恰好把圆划为一部分，剩下的划为一部分，此时
<span class="math inline">\(I=EI\)</span>，方差为 0</li>
</ul></li>
</ul>
<h2 id="例子">例子</h2>
<h3 id="蒙特卡洛积分">蒙特卡洛积分</h3>
<h4 id="问题">问题</h4>
<ul>
<li>求 <code>pi</code></li>
</ul>
<p><img src="/2022/03/15/CG/Kits/StratifiedSampling/fig-3.01-circ-square.jpg" style="zoom: 50%;"></p>
<ul>
<li>定义</li>
</ul>
<p><span class="math display">\[
I=\int_{\Omega}g(X)\rho(X)\;\mathrm{d}X,X=(x,y)
\]</span></p>
<ul>
<li>定义域：<span class="math inline">\(\Omega\)</span></li>
</ul>
<p><span class="math display">\[
\Omega=\{X=(x,y)\vert x^2+y^2\le 1\}\\
\]</span></p>
<ul>
<li>分布：<span class="math inline">\(\rho(X)\)</span></li>
</ul>
<p><span class="math display">\[
\rho(X)=\left\{\begin{array}{ll}
1,&amp;X\in\Omega\\
0,&amp;else\\
\end{array}\right.
\]</span></p>
<ul>
<li>函数：<span class="math inline">\(g(X)\)</span></li>
</ul>
<p><span class="math display">\[
g(X)=1
\]</span></p>
<ul>
<li>一般还有另外一种写法</li>
</ul>
<p><span class="math display">\[
\rho(X)\;\mathrm{d}X=\mathrm{d}\mu(X)
\]</span></p>
<ul>
<li>实际积分得到：<span class="math inline">\(I=\pi\)</span></li>
<li>假设 <span class="math inline">\(p(X)\)</span> 是 <span class="math inline">\(\Omega\)</span> 上不为 <span class="math inline">\(0\)</span> 的任意分布，那么对 <span class="math inline">\(I\)</span> 的蒙特卡洛估计如下
<ul>
<li><span class="math inline">\(X_i\)</span> 为独立同分布的样本</li>
</ul></li>
</ul>
<p><span class="math display">\[
\hat{I}=\dfrac{1}{N}\sum_{i=1}^{N}\dfrac{g(X_i)\rho(X_i)}{p(X_i)}
\]</span></p>
<h4 id="期望分析">期望分析</h4>
<ul>
<li>这是一个无偏估计</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
E\left[\hat{I}\right]
&amp;=E\left[\dfrac{1}{N}\sum_{i=1}^{N}\dfrac{g(X_i)\rho(X_i)}{p(X_i)}\right]\\
&amp;=E\left[\dfrac{g(X_i)\rho(X_i)}{p(X_i)}\right]\\
&amp;=\int_{\Omega}\dfrac{g(X)\rho(X)}{p(X)}p(X)\;\mathrm{d}X\\
&amp;=\int_{\Omega}g(X)\rho(X)\;\mathrm{d}X\\
&amp;=I
\end{aligned}
\]</span></p>
<h4 id="方差分析">方差分析</h4>
<ul>
<li>方差如下</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
Var\left[\hat{I}\right]
&amp;=\dfrac{1}{N^2}Var\left[\sum_{i=1}^{N}\dfrac{g(X_i)\rho(X_i)}{p(X_i)}\right]\\
&amp;=\dfrac{1}{N}Var\left[\dfrac{g(X)\rho(X)}{p(X)}\right]\\
&amp;=\dfrac{1}{N}\left(E\left[(\dfrac{g(X)\rho(X)}{p(X)})^2\right]-\left(E\left[\dfrac{g(X)\rho(X)}{p(X)}\right]\right)^2\right)\\
&amp;=\dfrac{1}{N}\int_{\Omega}\dfrac{g^2(X)\rho^2(X)}{p(X)}\;\mathrm{d}X-\dfrac{I^2}{N}\\
\end{aligned}
\]</span></p>
<h4 id="最小方差分析">最小方差分析</h4>
<ul>
<li>首先分析：<span class="math inline">\(g(X)\)</span> 恒非负
<ul>
<li>恒非正同理（<span class="math inline">\(k\)</span>
取负即可），难的是有正有负</li>
</ul></li>
<li>首先 <span class="math inline">\(Var\left[\hat{I}\right]\ge0\)</span>，因此如果能够造出一个分布
<span class="math inline">\(p(X)\)</span> 使得方差为 <span class="math inline">\(0\)</span>，则就是最小值</li>
<li>我们如下构造 <span class="math inline">\(p(X)\)</span></li>
</ul>
<p><span class="math display">\[
p(X)=k\cdot g(X)\rho(X)
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;\int_{\Omega}p(X)\;\mathrm{d}X=1\\
\Rightarrow\quad&amp;\int_{\Omega}k\cdot g(X)\rho(X)\;\mathrm{d}X=kI=1\\
\Rightarrow\quad&amp;k=\dfrac{1}{I}\\
\end{aligned}
\]</span></p>
<ul>
<li>此时方差如下</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
Var\left[\hat{I}\right]
&amp;=\dfrac{1}{N}\int_{\Omega}\dfrac{g^2(X)\rho^2(X)}{p(X)}\;\mathrm{d}X-\dfrac{I^2}{N}\\
&amp;=\dfrac{1}{N}\int_{\Omega}\dfrac{g^2(X)\rho^2(X)}{k\cdot
g(X)\rho(X)}\;\mathrm{d}X-\dfrac{I^2}{N}\\
&amp;=\dfrac{1}{kN}\int_{\Omega}g(X)\rho(X)\;\mathrm{d}X-\dfrac{I^2}{N}\\
&amp;=\dfrac{I}{kN}-\dfrac{I^2}{N}\\
&amp;=\dfrac{I^2}{N}-\dfrac{I^2}{N}\\
&amp;=0
\end{aligned}
\]</span></p>
<ul>
<li>因此我们只需要取 <span class="math inline">\(p(X)\propto
G(X)=g(X)\rho(X)\)</span>，就能零方差得到结果
<ul>
<li>这在渲染领域是合理的，渲染的 <span class="math inline">\(G(X)\)</span> 非负</li>
</ul></li>
<li>如果有正有负，分析如下
<ul>
<li>有最小值，但不是 <span class="math inline">\(0\)</span></li>
<li>柯西不等式</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\int_{\Omega}\dfrac{g^2(X)\rho^2(X)}{p(X)}\;\mathrm{d}X\\
=\quad&amp;\int_{\Omega}\dfrac{g^2(X)\rho^2(X)}{p(X)}\;\mathrm{d}X\int_{\Omega}p(X)\;\mathrm{d}X\\
\ge\quad&amp;\int_{\Omega}\sqrt{\dfrac{g^2(X)\rho^2(X)}{p(X)}}\sqrt{p(X)}\;\mathrm{d}X\\
=\quad&amp;\left(\int_{\Omega}\vert{g(X)}\vert\rho(X)\;\mathrm{d}X\right)^2\\
\end{aligned}
\]</span></p>
<ul>
<li>取等条件</li>
</ul>
<p><span class="math display">\[
p(X)\propto \vert{G(X)}\vert=\vert{g(X)}\vert\rho(X)
\]</span></p>
<ul>
<li>方差最小值为</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
Var\left[\hat{I}\right]
&amp;=\dfrac{1}{N}\int_{\Omega}\dfrac{g^2(X)\rho^2(X)}{p(X)}\;\mathrm{d}X-\dfrac{I^2}{N}\\
&amp;\ge\dfrac{1}{N}\left(\left(\int_{\Omega}\vert{g(X)}\vert\rho(X)\;\mathrm{d}X\right)^2-I^2\right)\\
\end{aligned}
\]</span></p>
<ul>
<li>使用一个 <span class="math inline">\(p(X)\)</span>
进行采样，则正比于绝对值已经是最小方差策略</li>
</ul>
<h4 id="实现">实现</h4>
<ul>
<li>如果 <span class="math inline">\(p(X)\)</span> 为 <span class="math inline">\(\Omega&#39;\)</span>
上的均匀分布，可以简化如下（代码实现）
<ul>
<li>估计 <span class="math inline">\(\pi\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\Omega&#39;=\{-1\le x\le1,-1\le y\le 1\}\\
\]</span></p>
<p><span class="math display">\[
\hat{I}=\dfrac{1}{N}\sum_{i=1}^{N}\dfrac{g(X_i)\rho(X_i)}{p(X_i)}=\dfrac{4}{N}\sum_{i=1}^{N}g(X_i)\rho(X_i)
\]</span></p>
<h3 id="分层采样-1">分层采样</h3>
<ul>
<li>简单的来说，对一个区域使用 <span class="math inline">\(p(X)\)</span>
进行采样的效率，比不上将样本划分给不同区域的采样效率
<ul>
<li><span class="math inline">\(\pi\)</span> 的例子：整个区域均匀采样
160 个点的效率不如对每个小区域采样 10 个点</li>
</ul></li>
<li>为了方便描述，利用 <span class="math inline">\(G(X)\)</span>进行简记， <span class="math inline">\(G(X)=g(X)\rho(X)\)</span></li>
<li>划分为 <span class="math inline">\(k\)</span> 个不相交且并集为 <span class="math inline">\(\Omega\)</span> 的区域：<span class="math inline">\(\Omega_j\)</span></li>
<li>例如这里划分为 <code>4*4</code> 的采样区域</li>
</ul>
<p><img src="/2022/03/15/CG/Kits/StratifiedSampling/fig-3.02-jitter.jpg" style="zoom: 50%;"></p>
<ul>
<li>采样数：<span class="math inline">\(n_j\)</span>
<ul>
<li><span class="math inline">\(N=\sum_{i=1}^{k}{n_j}\)</span></li>
<li><span class="math inline">\(n_j\)</span> 表示在区域 <span class="math inline">\(j\)</span> 中采样 <span class="math inline">\(n_j\)</span> 个样本</li>
<li>每个区域的样本数正比于区域内 <span class="math inline">\(p(X)\)</span> 积分和的大小</li>
</ul></li>
</ul>
<p><span class="math display">\[
n_j\propto \int_{\Omega_j}p(X)\mathrm{d}X
\]</span></p>
<ul>
<li>容易得到</li>
</ul>
<p><span class="math display">\[
\dfrac{n_j}{N}=\int_{\Omega_j}p(X)\mathrm{d}X
\]</span></p>
<ul>
<li>每个区域内部的采样分布为 <span class="math inline">\(p_j\)</span>，其分布由 <span class="math inline">\(p\)</span> 决定
<ul>
<li>简单的说就是 <span class="math inline">\(p\)</span> 在 <span class="math inline">\(\Omega_j\)</span> 内的分布归一化</li>
<li>按比例分配，容易验证 <span class="math inline">\(p_j\)</span>
积分和为 <span class="math inline">\(1\)</span>，是一个分布</li>
</ul></li>
</ul>
<p><span class="math display">\[
p_j(X)=\left\{\begin{array}{ll}
p(X)\cdot\dfrac{N}{n_j},&amp;X\in\Omega_j\\
0,&amp;else\\
\end{array}\right.
\]</span></p>
<ul>
<li>估计如下
<ul>
<li><span class="math inline">\(X_{i,j}\)</span> 表示在区域 <span class="math inline">\(j\)</span> 采样的第 <span class="math inline">\(i\)</span> 个样本</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\hat{I}_2&amp;=\sum_{j=1}^{k}\dfrac{1}{n_j}\sum_{i=1}^{n_j}\dfrac{G(X_{i,j})}{p_j(X_{i,j})}\\
\end{aligned}
\]</span></p>
<ul>
<li>这是无偏的，相当于划分定义域，转化为独立的子问题
<ul>
<li><strong>基于黎曼积分的可加性</strong></li>
<li><span class="math inline">\(I_j\)</span> 的定义如倒数第三行</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
E\left[\hat{I}_2\right]
&amp;=E\left[\sum_{j=1}^{k}\dfrac{1}{n_j}\sum_{i=1}^{n_j}\dfrac{G(X_{i,j})}{p_j(X_{i,j})}\right]\\
&amp;=\sum_{j=1}^{k}E\left[\dfrac{1}{n_j}\sum_{i=1}^{n_j}\dfrac{G(X_{i,j})}{p_j(X_{i,j})}\right]\\
&amp;=\sum_{j=1}^{k}E\left[\dfrac{G(X_{j})}{p_j(X_{j})}\right]\\
&amp;=\sum_{j=1}^{k}\int_{\Omega_j}\dfrac{G(X)}{p_j(X)}p_j(X)\;\mathrm{d}X\\
&amp;=\sum_{j=1}^{k}\int_{\Omega_j}G(X)\;\mathrm{d}X=\sum_{j=1}^{k}I_j\\
&amp;=\int_{\Omega}G(X)\;\mathrm{d}X\\
&amp;=I
\end{aligned}
\]</span></p>
<ul>
<li>方差估计</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
Var\left[\hat{I}_2\right]
&amp;=Var\left[\sum_{j=1}^{k}\dfrac{1}{n_j}\sum_{i=1}^{n_j}\dfrac{G(X_{i,j})}{p_j(X_{i,j})}\right]\\
&amp;=\sum_{j=1}^{k}Var\left[\dfrac{1}{n_j}\sum_{i=1}^{n_j}\dfrac{G(X_{i,j})}{p_j(X_{i,j})}\right]\\
&amp;=\sum_{j=1}^{k}\dfrac{n_j}{n^2_j}Var\left[\dfrac{G(X_{j})}{p_j(X_{j})}\right]\\
&amp;=\sum_{j=1}^{k}\dfrac{1}{n_j}Var\left[\dfrac{G(X_{j})}{p_j(X_{j})}\right]\\
&amp;=\sum_{j=1}^{k}\dfrac{1}{n_j}\left(E\left[\left(\dfrac{G(X_{j})}{p_j(X_{j})}\right)^2\right]-\left(E\left[\dfrac{G(X_{j})}{p_j(X_{j})}\right]\right)^2\right)\\
&amp;=\sum_{j=1}^{k}\dfrac{1}{n_j}\left(E\left[\left(\dfrac{G(X_{j})}{p_j(X_{j})}\right)^2\right]-I_j^2\right)\\
&amp;=\sum_{j=1}^{k}\dfrac{1}{n_j}\left(\int_{\Omega_j}\dfrac{G^2(X_{j})}{p_j^2(X_{j})}p_j(X_{j})\mathrm{d}X_j-I_j^2\right)\\
&amp;=\sum_{j=1}^{k}\int_{\Omega_j}\dfrac{G^2(X_{j})}{p_j(X_{j})n_j}\mathrm{d}X_j-\sum_{j=1}^{k}\dfrac{I_j^2}{n_j}\\
&amp;=\sum_{j=1}^{k}\int_{\Omega_j}\dfrac{G^2(X_{j})}{p(X_{j})N}\mathrm{d}X_j-\sum_{j=1}^{k}\dfrac{I^2}{n_j}\\
&amp;=\dfrac{1}{N}\sum_{j=1}^{k}\int_{\Omega_j}\dfrac{G^2(X_{j})}{p(X_{j})}\mathrm{d}X_j-\sum_{j=1}^{k}\dfrac{I_j^2}{n_j}\\
&amp;=Var\left[\hat
{I}\right]+\dfrac{I^2}{N}-\sum_{j=1}^{k}\dfrac{I_j^2}{n_j}\\
&amp;=Var\left[\hat
{I}\right]+\dfrac{1}{N}\left(I^2-\sum_{j=1}^{k}\dfrac{N}{n_j}I_j^2\right)\\
\end{aligned}
\]</span></p>
<ul>
<li>根据柯西不等式</li>
</ul>
<p><span class="math display">\[
I^2
=\left(\sum_{i=1}^{k} I_i\right)^2
=\left(\sum_{i=1}^{k}
\sqrt{\dfrac{N}{n_j}}I_i\times\sqrt{\dfrac{n_j}{N}}\right)^2
\le\sum_{i=1}^{k}\dfrac{N}{n_j}I_i^2\sum_{i=1}^{k}\dfrac{n_j}{N}
=\sum_{i=1}^{k}\dfrac{N}{n_j}I_i^2
\]</span></p>
<ul>
<li>于是有</li>
</ul>
<p><span class="math display">\[
Var\left[\hat{I}_2\right]\le Var\left[\hat{I}\right]
\]</span></p>
<ul>
<li>如果 <span class="math inline">\(p_i\)</span>
是均匀采样，可以简化如下（代码实现）
<ul>
<li>估计 <span class="math inline">\(\pi\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\hat{I}_2
&amp;=\sum_{j=1}^{k}\dfrac{1}{n_j}\sum_{i=1}^{n_j}\dfrac{G(X_{i,j})}{p_j(X_{i,j})}\\
&amp;=\sum_{j=1}^{k}\dfrac{4}{kn_j}\sum_{i=1}^{n_j}G(X_{i,j})\\
&amp;=\dfrac{4}{N}\sum_{j=1}^{k}\sum_{i=1}^{n_j}G(X_{i,j})\\
\end{aligned}
\]</span></p>
<h2 id="证明">证明</h2>
<ul>
<li>上面的期望和方差分析都是一般性的分析</li>
<li>书上的证明
<ul>
<li>注意这里的 <span class="math inline">\(p_i\)</span>
表示的是选到这一个划分区域的概率，而不是上面的 pdf</li>
<li>原始蒙特卡洛积分为，积分区域为 <span class="math inline">\([0,1]^s\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\int_{\mathcal{L}}\kappa(\mathrm{z})\mathrm{d}F(\mathrm{z})
\]</span></p>
<p><img src="/2022/03/15/CG/Kits/StratifiedSampling/image-20220315164405222.png"></p>
<p><img src="/2022/03/15/CG/Kits/StratifiedSampling/image-20220315164422302.png"></p>
<p><img src="/2022/03/15/CG/Kits/StratifiedSampling/image-20220315164500543.png"></p>
<h2 id="规范化描述">规范化描述</h2>
<h3 id="数值积分">数值积分</h3>
<p><img src="/2022/03/15/CG/Kits/StratifiedSampling/image-20220315104550170.png"></p>
<h3 id="蒙特卡洛积分-1">蒙特卡洛积分</h3>
<p><img src="/2022/03/15/CG/Kits/StratifiedSampling/image-20220315162827071.png"></p>
<h3 id="分层积分">分层积分</h3>
<p><img src="/2022/03/15/CG/Kits/StratifiedSampling/image-20220315162855141.png"></p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://www.mcqmc2012.unsw.edu.au/slides/MCQMC2012_Gopalakrishnan.pdf">课件</a></li>
<li>书籍：Monte Carlo: concepts, algorithms, and applications
<ul>
<li>4.3 Stratified Sampling</li>
</ul></li>
<li><a href="https://zhuanlan.zhihu.com/p/371735546">图形学｜Robust：MC
Integration 基础部分+PBRT：MC Sampling 采样算法</a></li>
<li><a href="https://www.docin.com/p-441150793.html">蒙特卡洛计算中减少方差的技巧</a></li>
</ul>
]]></content>
      <categories>
        <category>CG.Kits</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>z-fighting 问题</title>
    <url>/2021/07/20/CG/Kits/kits/</url>
    <content><![CDATA[<h1 id="z-fighting-问题">z-fighting 问题</h1>
<ul>
<li>一方面可能由于两个平面 a、b
位置一样，在进行深度测试的时候，由于精度问题，有的时候 a 通过，有的时候
b 通过，导致混叠的问题。</li>
</ul>
<p><img src="/2021/07/20/CG/Kits/kits/image-20210720160506031.png" style="zoom:80%;"></p>
<ul>
<li>由于透视投影转化到标准的 <span class="math inline">\([-1,1]^3\)</span>
立方体中时，对深度使用了非线性变换，此时离视点比较近的地方精度高，离视点比较远的地方精度低。这样子离视点比较远的物体在变换之后可能深度差不多，同样由于精度问题，导致混叠。</li>
</ul>
]]></content>
      <categories>
        <category>CG.Kits</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>有向距离场(Raymarching SDFs)</title>
    <url>/2022/01/14/CG/Algorithm/rwwtt/</url>
    <content><![CDATA[<h1 id="raymarching-sdfs">Raymarching SDFs</h1>
<h2 id="说明">说明</h2>
<h3 id="功能实现">功能实现</h3>
<ul>
<li>实现了有向距离场上的<strong>软阴影（Soft
Shadow）</strong>、<strong>环境光遮蔽（AO）</strong>、<strong>凹凸贴图（bump
mapping）</strong></li>
<li>学习两个经典场景的写法
<ul>
<li>加入了光源、相机位置控制</li>
</ul></li>
<li>搭建了一个场景
<ul>
<li><a href="https://www.bilibili.com/video/BV1Nr4y1i7xa/">视频</a></li>
<li><a href="https://www.shadertoy.com/view/7dsyDN">shadertoy</a></li>
</ul></li>
</ul>
<p><img src="/2022/01/14/CG/Algorithm/rwwtt/desk.png"></p>
<ul>
<li><a href="/resources/CG/Algorithm/rwwtt/SDF.zip">源代码与可执行文件</a></li>
<li><a href="/resources/CG/Algorithm/rwwtt/SDF.pptx">PPT</a></li>
</ul>
<h3 id="项目来源">项目来源</h3>
<ul>
<li>项目来源如下
<ul>
<li><a href="https://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm">Rendering
Worlds with Two Triangles with raytracing on the GPU in 4096
bytes</a></li>
</ul></li>
<li>作者使用两个三角形作为输入，不使用图片作为输入，仅使用 4K
资源就渲染出了如下的图片，属实让人震惊</li>
<li>使用有向距离场上的 ray marching 实现的</li>
</ul>
<p><img src="/2022/01/14/CG/Algorithm/rwwtt/scene1.png"></p>
<ul>
<li>我也想学习一下有向距离场（SDF）在渲染中的作用，同时也想学习使用 SDF
构造一个自己的场景</li>
</ul>
<h2 id="概念">概念</h2>
<h3 id="sdf">SDF</h3>
<ul>
<li>SDF
<ul>
<li>signed distance field</li>
<li>有向距离场</li>
</ul></li>
<li>表示空间中的每一个点到物体表面的最小距离
<ul>
<li>外部为正、内部为负</li>
</ul></li>
</ul>
<h3 id="ray-marching">Ray Marching</h3>
<ul>
<li>光线步进算法，用于和物体求交</li>
<li>对于某一个点，如果他到物体表面的距离（SDF 函数的值）为 <span class="math inline">\(R\)</span>，则光线前进 <span class="math inline">\(R\)</span> 一定不会和物体相交
<ul>
<li>利用这个性质实现光线和物体求交的加速</li>
</ul></li>
</ul>
<p><img src="/2022/01/14/CG/Algorithm/rwwtt/raymarching.png" style="zoom:80%;"></p>
<h2 id="复现">复现</h2>
<ul>
<li>原始作者给出了原始工程在 <a href="https://www.shadertoy.com/view/NtlSDs">shadertoy</a>
上的实现，首先我将其移植到 OpenGL 上，实现原始的效果</li>
</ul>
<h3 id="移植">移植</h3>
<ul>
<li>单纯的移植代码比较简单</li>
</ul>
<h4 id="shader-toy">shader toy</h4>
<ul>
<li>shader toy 上相当于一个简单的 fragment shader，有如下固定输入</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span>      iResolution;           <span class="comment">// viewport resolution (in pixels)</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span>     iTime;                 <span class="comment">// shader playback time (in seconds)</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span>     iTimeDelta;            <span class="comment">// render time (in seconds)</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">int</span>       iFrame;                <span class="comment">// shader playback frame</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span>     iChannelTime[<span class="number">4</span>];       <span class="comment">// channel playback time (in seconds)</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span>      iChannelResolution[<span class="number">4</span>]; <span class="comment">// channel resolution (in pixels)</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span>      iMouse;                <span class="comment">// mouse pixel coords. xy: current (if MLB down), zw: click</span></span><br><span class="line"><span class="keyword">uniform</span> samplerXX iChannel0.<span class="number">.3</span>;          <span class="comment">// input channel. XX = 2D/Cube</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span>      iDate;                 <span class="comment">// (year, month, day, time in seconds)</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span>     iSampleRate;           <span class="comment">// sound sample rate (i.e., 44100)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>主函数如下</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="移植到-opengl">移植到 OpenGL</h4>
<ul>
<li>CPU 端程序
<ul>
<li>使用 shader 绘制两个三角形（也就是平面）</li>
<li>传入在 shadertoy 中使用的基本参数（被使用到的上面的参数）</li>
</ul></li>
<li>vertex shader
<ul>
<li>不需要做任何事，设置位置即可</li>
</ul></li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>fragment shader</p>
<ul>
<li>使用 shader toy 中的程序
<ul>
<li>需要修改 <code>mainImage</code> 为 <code>main()</code></li>
</ul></li>
<li>增加输入输出
<ul>
<li>输入：使用到的参数</li>
<li>输出：颜色</li>
</ul></li>
</ul>
<p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span>      iResolution;           <span class="comment">// viewport resolution (in pixels)</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span>     iTime;                 <span class="comment">// shader playback time (in seconds)</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">int</span>       iFrame;                <span class="comment">// shader playback frame</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span>      iMouse;                <span class="comment">// mouse pixel coords. xy: current (if MLB down), zw: click</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>fragCoord 修改为 <code>gl_FragCoord</code></li>
</ul></li>
</ul>
<h3 id="学习代码与重构">学习代码与重构</h3>
<ul>
<li>示例</li>
</ul>
<h4 id="设置相机位置">(1) 设置相机位置</h4>
<ul>
<li>在 fragment shader
中，我们获取到的是以以相机为观察中心的观察坐标系</li>
<li>通过矩阵（视点坐标系 <span class="math inline">\(\to\)</span>
世界坐标系）将其变换回世界坐标系中，可以通过 <code>camera</code>
的三个坐标进行构造</li>
<li>是正交变换，而 OpenGL 恰好是列放置的</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">struct Camera &#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line">    <span class="type">vec3</span> front;</span><br><span class="line">    <span class="type">vec3</span> up;</span><br><span class="line">    <span class="type">float</span> right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="生成光线">(2) 生成光线</h4>
<ul>
<li>OpenGL 中 fragment shader 中的内置变量 <code>gl_FragCoord</code>
记录了当前像素的中心位置
<ul>
<li>偏移了 <code>(0.5,0.5)</code></li>
<li>范围为 <code>[0.5, w-0.5] * [0.5, h-0.5]</code></li>
</ul></li>
<li>生成的光线用于 <code>ray marching</code> 算法，在函数
<code>raycast()</code> 中实现</li>
<li>生成两条另外的光线，<code>x+1,y+1</code>
两条光线，用于实现其他效果</li>
</ul>
<h4 id="ray-marching-1">(3) ray marching</h4>
<ul>
<li><code>raycast()</code>
函数中，首先和整个场景的包围盒求交，计算出时间的上下界
<code>[tmin, tmax]</code></li>
<li><code>map()</code> 函数计算出 <code>sdf</code> 的值</li>
<li>主要<strong>步进算法</strong>如下</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">tmin = <span class="built_in">max</span>(tb.x, tmin);</span><br><span class="line">tmax = <span class="built_in">min</span>(tb.y, tmax);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ray marching, 迭代步数为 70</span></span><br><span class="line"><span class="type">float</span> t = tmin;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">70</span> &amp;&amp; t &lt; tmax; i++) &#123;</span><br><span class="line">    <span class="type">vec2</span> h = map(ro + rd*t);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(h.x) &lt; (<span class="number">0.0001</span>*t)) &#123;</span><br><span class="line">        res = <span class="type">vec2</span>(t, h.y);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t += h.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>map</code> 中计算当前点的 <code>sdf</code> 的值</li>
<li>作者提供了很多原始的图元形式
<ul>
<li><a href="https://iquilezles.org/www/articles/distfunctions/distfunctions.htm">基本图元</a></li>
<li><a href="https://www.shadertoy.com/playlist/43cXRl">其他图元</a></li>
</ul></li>
</ul>
<p><img src="/2022/01/14/CG/Algorithm/rwwtt/primitives.png"></p>
<ul>
<li>具体的实现部分查看代码注释</li>
<li>返回一个二维向量 <code>vec2 res</code>
<ul>
<li><code>res.x</code>：<code>sdf</code> 的值</li>
<li><code>res.y</code>：一个随机数，用于生成物体的颜色</li>
</ul></li>
</ul>
<h4 id="计算-normal">(4) 计算 normal</h4>
<ul>
<li><a href="https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm">教程</a></li>
<li>法线的方向就是 sdf 标量场的梯度方向</li>
</ul>
<p><span class="math display">\[
n=\textbf{normalize}(\nabla{f(p)})
\]</span></p>
<ul>
<li>对于其中的一个维度</li>
<li><strong>前向差分</strong></li>
</ul>
<p><span class="math display">\[
\dfrac{\mathrm{d}f(p)}{\mathrm{d}x}\approx\dfrac{f(p+(h,0,0))}{h}
\]</span></p>
<ul>
<li>或者<strong>中心差分</strong>
<ul>
<li>不会引入方向性的偏差</li>
</ul></li>
</ul>
<p><span class="math display">\[
\dfrac{\mathrm{d}f(p)}{\mathrm{d}x}\approx\dfrac{f(p+(h,0,0))-f(p-(h,0,0))}{2h}
\]</span></p>
<ul>
<li>中心差分的实现</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">vec3</span> calcNormal( <span class="keyword">in</span> <span class="type">vec3</span> p ) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">float</span> eps = <span class="number">0.0001</span>; <span class="comment">// or some other value</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">vec2</span> h = <span class="type">vec2</span>(eps,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">normalize</span>( <span class="type">vec3</span>(f(p+h.xyy) - f(p-h.xyy),</span><br><span class="line">                           f(p+h.yxy) - f(p-h.yxy),</span><br><span class="line">                           f(p+h.yyx) - f(p-h.yyx) ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>中心差分的优化形式</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">vec3</span> calcNormal( <span class="keyword">in</span> <span class="type">vec3</span> &amp; p ) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">float</span> h = <span class="number">0.0001</span>; <span class="comment">// replace by an appropriate value</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">vec2</span> k = <span class="type">vec2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">normalize</span>( k.xyy*f( p + k.xyy*h ) +</span><br><span class="line">                      k.yyx*f( p + k.yyx*h ) +</span><br><span class="line">                      k.yxy*f( p + k.yxy*h ) +</span><br><span class="line">                      k.xxx*f( p + k.xxx*h ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>推导
<ul>
<li>4 个点：<span class="math inline">\(k_i=\{1,-1,-1\},\{-1,-1,1\},\{-1,1,-1\},\{1,1,1\}\)</span>
<ul>
<li><span class="math inline">\(\sum_{i}k_i=\mathbf{0}\)</span></li>
</ul></li>
<li><span class="math inline">\(\ast\)</span> 表示点对点乘法</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
m&amp;=\sum_{i}k_i\ast f(p+k_ih)\\
&amp;=\sum_{i}k_i\ast(f(p+k_ih)-f(p))\\
&amp;=\sum_{i}k_i\ast(k_ih\ast\nabla{f(p))}\\
&amp;=\sum_{i}4h(\nabla{f(p)})\\
\end{aligned}
\]</span></p>
<h4 id="光照模型">(5) 光照模型</h4>
<ul>
<li>材质：地面使用经过 <code>filter</code>
的棋盘格，其他使用不同的物体自带的随机数返回一种颜色</li>
<li>光照模型使用 <code>Blinn-Phong</code> 模型</li>
<li>天空盒、直接光源</li>
</ul>
<h4 id="ao">(6) AO</h4>
<ul>
<li>环境光遮蔽的计算</li>
</ul>
<p><img src="/2022/01/14/CG/Algorithm/rwwtt/ao.png"></p>
<ul>
<li>思路
<ul>
<li>在着色点 p 的周围采样若干个点，计算它们的 sdf 值，和到 p
点的距离作比较</li>
<li>上面的<strong>粉红色</strong>和<strong>黄色</strong>的值相差越大，说明周围遮蔽越严重</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
ao
&amp;=1-k\sum_{i=1}^{5}\dfrac{1}{2^i}(\textrm{pink}_i-\textrm{yellow}_i)\\
&amp;=1-k\sum_{i=1}^{5}\dfrac{1}{2^i}(i\cdot\Delta-\mathrm{sdf}(p+n\cdot
i\cdot\Delta))\\
\end{aligned}
\]</span></p>
<h4 id="软阴影">(7) 软阴影</h4>
<ul>
<li><a href="https://iquilezles.org/www/articles/rmshadows/rmshadows.htm">教程</a></li>
</ul>
<h5 id="硬阴影">硬阴影</h5>
<ul>
<li>向着光源的方向步进，如果碰到物体则在阴影中，没有则不在阴影中</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> t = mint;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = ZERO; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">    <span class="type">float</span> h = map( ro + rd*t ).x;</span><br><span class="line">    <span class="keyword">if</span>(h &lt; <span class="number">0.0001</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    t += h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure>
<h5 id="软阴影-1">软阴影</h5>
<ul>
<li>当向着光源的方向步进的时候没有碰到物体，但是离物体很近的时候，这时候对阴影也是有贡献的</li>
<li>两个观察，点 <span class="math inline">\(p\)</span> 离物体很近
<ul>
<li><span class="math inline">\(p\)</span> 离着色点越近，则阴影越硬</li>
<li><span class="math inline">\(p\)</span> 离物体越近（sdf
值越小），则阴影越硬</li>
</ul></li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">float</span> k = <span class="number">10.0</span>; <span class="comment">// k 是一个可调参数, 越小阴影越软(弥散越开)</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> res = <span class="number">1.0</span>;</span><br><span class="line"><span class="type">float</span> t = mint;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = ZERO; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">    <span class="type">float</span> h = map( ro + rd*t ).x;</span><br><span class="line">    <span class="keyword">if</span>(h &lt; <span class="number">0.0001</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    res = <span class="built_in">min</span>(res, k*h/t);</span><br><span class="line">    t += h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<h5 id="软阴影改进">软阴影（改进）</h5>
<ul>
<li><a href="https://gpuopen.com/wp-content/uploads/2018/05/gdc_2018_tutorial_clay_sim_and_raytracing_in_claybook.pptx">PPT</a></li>
</ul>
<p><img src="/2022/01/14/CG/Algorithm/rwwtt/softshadow-improvement.png"></p>
<ul>
<li>我们在步进的时候可能错过产生最硬的阴影的点（例如图上的<strong>黄点</strong>），引入的问题就是会造成<strong>漏光现象</strong>（light
leaking）</li>
<li>解决方案就是试图求出黄色的点对应的步进长度</li>
<li>红色圆的半径 <span class="math inline">\(r_1\)</span>，绿圆半径
<span class="math inline">\(r_2\)</span>，则实际上的到物体表面的距离（<strong>黄线的一半</strong>）如下</li>
</ul>
<p><span class="math display">\[
r_2\cos\theta=r_2\sqrt{1-\left(\dfrac{r_2/2}{r_1}\right)^2}
\]</span></p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> k = <span class="number">10.0</span>; <span class="comment">// k 是一个可调参数, 越小阴影越软(弥散越开)</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> res = <span class="number">1.0</span>;</span><br><span class="line"><span class="type">float</span> t = mint;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> ph = <span class="number">1e20</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = ZERO; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">    <span class="type">float</span> h = map( ro + rd*t ).x;</span><br><span class="line">    <span class="keyword">if</span>(h &lt; <span class="number">0.0001</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">float</span> y = h*h/(<span class="number">2.0</span>*ph);</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">sqrt</span>(h*h - y*y);</span><br><span class="line">    res = <span class="built_in">min</span>(res, k*d/<span class="built_in">max</span>(t - y, <span class="number">0.0</span>));</span><br><span class="line">    ph = h;</span><br><span class="line">    t += h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<ul>
<li>其他问题，将阴影估计深了，例如下方<strong>黄线为物体包络线</strong></li>
</ul>
<p><img src="/2022/01/14/CG/Algorithm/rwwtt/softshadow2.png"></p>
<ul>
<li>问题不大，因为之后确实有这么深的阴影（<strong>第二个接触点</strong>）</li>
<li><a href="https://www.shadertoy.com/view/lsKcDD">改进前后对比</a></li>
<li>其他问题：左下角的这些残影？
<ul>
<li><strong>上面的方法是没有的</strong></li>
</ul></li>
</ul>
<p><img src="/2022/01/14/CG/Algorithm/rwwtt/artifact.png"></p>
<h5 id="另一种实现">另一种实现</h5>
<ul>
<li>shadertoy 是这么写的</li>
<li>这种方式是没有残影的</li>
<li>就是没改进的软阴影，但是改进了 <span class="math inline">\(t,d\)</span> 的函数</li>
<li>限制了步进的长度，从而减小漏光情况的发生</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> res = <span class="number">1.0</span>;</span><br><span class="line"><span class="type">float</span> t = mint;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = ZERO; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">    <span class="type">float</span> h = map( ro + rd*t ).x;</span><br><span class="line">    <span class="comment">// 就是最简单的 softshadow(没有改进)</span></span><br><span class="line">    <span class="comment">// k=8.0</span></span><br><span class="line">    <span class="type">float</span> s = <span class="built_in">clamp</span>(<span class="number">8.0</span>*h/t, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    res = <span class="built_in">min</span>( res, s );</span><br><span class="line">    <span class="comment">// t += clamp( h, 0.02, 0.2 );</span></span><br><span class="line">    t += h;</span><br><span class="line">    <span class="keyword">if</span>( res &lt; <span class="number">0.037</span> || t &gt; tmax ) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">res = res*res*(<span class="number">3.0</span> - <span class="number">2.0</span>*res); <span class="comment">// 0.037 =&gt; 0.004</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">clamp</span>( res, <span class="number">0.0</span>, <span class="number">1.0</span> );</span><br></pre></td></tr></table></figure>
<h4 id="结果">(8) 结果</h4>
<p><img src="/2022/01/14/CG/Algorithm/rwwtt/image-20220111134442654.png"></p>
<h2 id="monstor-场景实现">monstor 场景实现</h2>
<ul>
<li>基本思路同上面相同，其他技术细节写在下面</li>
</ul>
<h3 id="场景搭建">(1) 场景搭建</h3>
<h4 id="柱子">柱子</h4>
<ul>
<li>sdf 函数中对应的部分如下</li>
</ul>
<p><img src="/2022/01/14/CG/Algorithm/rwwtt/column.png" style="zoom:80%;"></p>
<h4 id="章鱼哥">章鱼哥</h4>
<ul>
<li>见代码注释</li>
</ul>
<h3 id="bump-mapping">(2) bump mapping</h3>
<ul>
<li>对法线进行随机扰动</li>
</ul>
<h3 id="光源的雾状效果">(3) 光源的雾状效果</h3>
<ul>
<li>如果距离光源足够近，则叠加上一层光源的颜色</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 光源</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec3</span> v1 = lightPositionOffset + LIGHT_POSITION - camera.position;</span><br><span class="line">    <span class="type">float</span> lig_dist2 = <span class="built_in">dot</span>(v1, v1);</span><br><span class="line">    <span class="type">float</span> dist = <span class="built_in">dot</span>(v1 ,rd);</span><br><span class="line">    <span class="type">float</span> seg2 = lig_dist2 - dist*dist;</span><br><span class="line">    <span class="meta">#if 1</span></span><br><span class="line">    <span class="comment">// 叠加雾状光源</span></span><br><span class="line">    <span class="comment">// (1) 光源在物体前面 / 没有击中物体</span></span><br><span class="line">    <span class="keyword">if</span>((dist &gt; <span class="number">0</span> &amp;&amp; (dist &lt; t || matID == <span class="number">666</span>u))) &#123;</span><br><span class="line">        col += <span class="type">vec3</span>( <span class="number">1.0</span>, <span class="number">0.95</span>, <span class="number">0.90</span> )*<span class="number">0.75</span>*<span class="built_in">exp2</span>( <span class="number">-64.0</span>*seg2 );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#else</span></span><br><span class="line">    <span class="comment">// 击中光源直接返回</span></span><br><span class="line">    <span class="meta">#define R2 0.01</span></span><br><span class="line">        <span class="comment">// (1) 光源在物体前面 / 没有击中物体</span></span><br><span class="line">        <span class="comment">// (2) 击中光源</span></span><br><span class="line">        <span class="keyword">if</span>((dist &gt; <span class="number">0</span> &amp;&amp; (dist &lt; t || matID == <span class="number">666</span>u)) &amp;&amp; (seg2 &lt; R2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">vec3</span>( <span class="number">1.0</span>, <span class="number">0.95</span>, <span class="number">0.90</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果展示">(4) 结果展示</h3>
<p><img src="/2022/01/14/CG/Algorithm/rwwtt/monster2.png" style="zoom:80%;"></p>
<h2 id="新场景搭建">新场景搭建</h2>
<ul>
<li>茶杯、走路的小人、两本书、苹果</li>
</ul>
<p><img src="/2022/01/14/CG/Algorithm/rwwtt/desk.png"></p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>参考图
<ul>
<li><a href="https://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm">原始网站</a></li>
<li><a href="https://www.shadertoy.com/view/NtlSDs">ShaderToy
实现</a></li>
<li><a href="https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf">pdf
教程</a></li>
<li><a href="https://www.youtube.com/watch?v=A1iW6Z_Jc4k&amp;ab_channel=NVScene">视频教程</a></li>
</ul></li>
<li>SDF 任务
<ul>
<li>https://weirdmachine.me/proj5-distancefields/</li>
<li>https://weirdmachine.me/proj5-distancefields/proposal/index.html</li>
</ul></li>
<li>SDF 的一些视频教程
<ul>
<li><a href="https://www.youtube.com/watch?v=62-pRVZuS5c&amp;ab_channel=InigoQuilez">Box
Function</a></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.Algorithm</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>SDF</tag>
      </tags>
  </entry>
  <entry>
    <title>Ray Tracing in One Weekend</title>
    <url>/2021/11/06/CG/Kits/rt1w/</url>
    <content><![CDATA[<ul>
<li><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">Ray
Tracing in One Weekend</a></li>
</ul>
<h1 id="ray-tracing-in-one-weekend">Ray Tracing in One Weekend</h1>
<ul>
<li>版本：<code>3.2.3</code>， <code>2020-12-07</code></li>
<li>光追框架理解</li>
<li>工程能力训练</li>
</ul>
<h2 id="ppm-文件格式">1. ppm 文件格式</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件头</span></span><br><span class="line">P3           <span class="comment"># &quot;P3&quot; 表示这是一张 RGB 颜色空间的图片, 使用 ASCII 编码</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span>          <span class="comment"># 图片大小为 3*2</span></span><br><span class="line"><span class="number">255</span>          <span class="comment"># 255 表示最大的颜色编码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件数据</span></span><br><span class="line"><span class="number">255</span>   <span class="number">0</span>   <span class="number">0</span>  <span class="comment"># red</span></span><br><span class="line">  <span class="number">0</span> <span class="number">255</span>   <span class="number">0</span>  <span class="comment"># green</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span> <span class="number">255</span>  <span class="comment"># blue</span></span><br><span class="line"><span class="number">255</span> <span class="number">255</span>   <span class="number">0</span>  <span class="comment"># yellow</span></span><br><span class="line"><span class="number">255</span> <span class="number">255</span> <span class="number">255</span>  <span class="comment"># white</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>  <span class="comment"># black</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面例子的图片如下</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/Tiny6pixel.png" alt="img" style="zoom: 50%;"></p>
<ul>
<li>windows 可以使用工具 <a href="https://www.xnview.com/en/">xnview</a>
查看
<ul>
<li>xnview 好像不支持 <code>P3</code> 格式，支持 <code>P6</code>
格式</li>
</ul></li>
<li><code>P3</code> 和 <code>P6</code> 格式的唯一区别就是
<code>P3</code> 使用 ASCII 码存储，而 <code>P6</code>
使用二进制存储</li>
<li>图像头文件库：<a href="https://github.com/nothings/stb">stb_image.h</a></li>
</ul>
<h2 id="坐标系说明">2. 坐标系说明</h2>
<ul>
<li>视点：<span class="math inline">\((0,0,0)\)</span></li>
<li>视窗
<ul>
<li>高度设置为 <span class="math inline">\(2\)</span>，宽度由
<code>aspect ratio</code> 计算得到（一般使用 <code>16:9</code>）</li>
<li><span class="math inline">\(z=-1\)</span>：<code>focal length</code></li>
</ul></li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/fig-1.03-cam-geom.jpg" style="zoom: 50%;"></p>
<h2 id="光线与球求交">3. 光线与球求交</h2>
<p><span class="math display">\[
\begin{array}{c}
(\mathbf{P}(t) - \mathbf{C}) \cdot (\mathbf{P}(t) - \mathbf{C}) = r^2\\
(\mathbf{A} + t \mathbf{b} - \mathbf{C})
\cdot (\mathbf{A} + t \mathbf{b} - \mathbf{C}) = r^2\\
t^2 \mathbf{b} \cdot \mathbf{b}
+ 2t \mathbf{b} \cdot (\mathbf{A}-\mathbf{C})
+ (\mathbf{A}-\mathbf{C}) \cdot (\mathbf{A}-\mathbf{C}) - r^2 = 0\\
\end{array}
\]</span></p>
<p><img src="/2021/11/06/CG/Kits/rt1w/fig-1.04-ray-sphere.jpg" style="zoom:50%;"></p>
<ul>
<li>简化，令 <span class="math inline">\(b=2h\)</span></li>
</ul>
<p><span class="math display">\[
\frac{-b \pm \sqrt{b^2 - 4ac}}{2a}== \frac{-h \pm \sqrt{h^2 - ac}}{a}
\]</span></p>
<ul>
<li>判断光线是从圆内部射出还是外部射入</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> front_face;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dot</span>(ray_direction, outward_normal) &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">    <span class="comment">// ray is inside the sphere</span></span><br><span class="line">    normal = -outward_normal; <span class="comment">// 此时法线反向</span></span><br><span class="line">    front_face = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ray is outside the sphere</span></span><br><span class="line">    normal = outward_normal;</span><br><span class="line">    front_face = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/06/CG/Kits/rt1w/fig-1.06-normal-sides.jpg" style="zoom:50%;"></p>
<h2 id="抗锯齿">4. 抗锯齿</h2>
<ul>
<li>对每一个像素产生多条光线</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/fig-1.07-pixel-samples.jpg" style="zoom:50%;"></p>
<ul>
<li></li>
</ul>
<h2 id="漫反射材质">5. 漫反射材质</h2>
<ul>
<li>diffuse</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/fig-1.08-light-bounce.jpg" style="zoom:67%;"></p>
<ul>
<li>随机出射
<ul>
<li>在<strong>球体内部</strong>随机采样：<strong>在一个正方体中采样，判断长度是否落在球体内部</strong></li>
</ul></li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/fig-1.09-rand-vec.jpg" style="zoom:50%;"></p>
<ul>
<li>上述采样方法，假设出射光线和法线的夹角为 <span class="math inline">\(\phi\)</span>，那么概率分布密度函数系数为 <span class="math inline">\(\cos^{3}{\phi}\)</span>
<ul>
<li>算出来是 <span class="math inline">\(\cos^{3}{\phi}\sin{\phi}\)</span>
<ul>
<li>注意是 3D 的</li>
</ul></li>
<li>因为入射光线和法线的夹角大多较大，因此整体结果偏黑</li>
</ul></li>
<li>朗伯反射的系数应该是 <span class="math inline">\(\cos{\phi}\)</span>
<ul>
<li>实现方式，在<strong>球的表面上</strong>均匀采点，小球面均匀采样
<span class="math inline">\(\mathbf{S}\)</span>，等价于大半球面朗伯采样
<span class="math inline">\(\mathbf{S}_2\)</span></li>
<li>小球面：<span class="math inline">\(\mathrm{d}\omega\)</span></li>
<li>大球面：<span class="math inline">\(\mathrm{d}\omega_2\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\mathrm{d}\omega
&amp;=\sin{2\phi}\;\mathrm{d}\theta\mathrm{d}2\phi\\
&amp;=2\sin{2\phi}\;\mathrm{d}\theta\mathrm{d}\phi\\
&amp;=4\cos{\phi}\sin{\phi}\;\mathrm{d}\theta\mathrm{d}\phi\\
&amp;=4\cos{\phi}\;\mathrm{d}\omega_2\\
\end{aligned}
\]</span></p>
<p><img src="/2021/11/06/CG/Kits/rt1w/image-20220404125152888.png" style="zoom: 50%;"></p>
<ul>
<li>之前还有一种采样方式，随机采一条单位长度的光线，让后判断它和法线是否在同一个法向半球内
<ul>
<li><strong>法向半球采样</strong></li>
</ul></li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/fig-1.10-rand-unitvec.png" style="zoom:50%;"></p>
<h3 id="不同采样方式-10spp">不同采样方式 10spp</h3>
<ul>
<li>法向半球采样</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/semisphere_inner.png"></p>
<ul>
<li>球体表面采样（朗伯采样）</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/sphere_surface.png"></p>
<ul>
<li>球体内部采样，单位化</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/sphere_inner_flatten_to_surface.png"></p>
<ul>
<li>球体内部采样</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/sphere_inner.png"></p>
<h2 id="纯镜面材质">6. 纯镜面材质</h2>
<p><img src="/2021/11/06/CG/Kits/rt1w/fig-1.11-reflection.jpg" style="zoom: 80%;"></p>
<h3 id="磨砂材质">磨砂材质</h3>
<p><img src="/2021/11/06/CG/Kits/rt1w/fig-1.12-reflect-fuzzy.jpg" style="zoom: 80%;"></p>
<ul>
<li>反射方向周围采样一个偏折角</li>
</ul>
<h2 id="绝缘体材质">7. 绝缘体材质</h2>
<ul>
<li>Dielectrics
<ul>
<li><strong>Clear materials</strong> such as <strong>water</strong>,
<strong>glass</strong>, and <strong>diamonds</strong> are
dielectrics.</li>
</ul></li>
<li>同时有折射、反射</li>
<li>实现：每次只取一个方向（折射 / 反射）</li>
<li>折射定律</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/fig-1.13-refraction.jpg" style="zoom: 80%;"> <span class="math display">\[
\eta \cdot \sin\theta = \eta&#39; \cdot \sin\theta&#39;
\]</span></p>
<ul>
<li>入射方向指向交点，出射方向从交点指出</li>
<li>分量分解，出射光线 <span class="math inline">\(\mathbf{R&#39;}\)</span></li>
</ul>
<p><span class="math display">\[
\mathbf{R&#39;}=\mathbf{R&#39;}_{\bot}+\mathbf{R&#39;}_{\parallel}
\]</span></p>
<ul>
<li>垂直法线分量</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
\eta&#39;\mathbf{R&#39;}_{\bot}=\eta\mathbf{R}_{\bot}=\eta(\mathbf{R}-\mathbf{R&#39;}_{\parallel})=\eta(\mathbf{R}+\cos\theta\mathbf{n})=\eta(\mathbf{R}-(\mathbf{n}\cdot\mathbf{R})\mathbf{n})\\
\mathbf{R&#39;}_{\bot}=\dfrac{\eta}{\eta&#39;}(\mathbf{R}-(\mathbf{n}\cdot\mathbf{R})\mathbf{n})\\
\end{array}
\]</span></p>
<ul>
<li>平行法线分量</li>
</ul>
<p><span class="math display">\[
\mathbf{R&#39;}_{\parallel} = -\sqrt{1 - |\mathbf{R&#39;}_{\bot}|^2}
\mathbf{n}
\]</span></p>
<h3 id="schlick-不等式估计反射的概率">Schlick 不等式估计反射的概率</h3>
<ul>
<li>近似菲涅尔项</li>
</ul>
<p><span class="math display">\[
R(\theta) = R_0 + (1 - R_0)(1 - \cos \theta)^5
\]</span></p>
<p><span class="math display">\[
R_0=\left(\frac{n_1-n_2}{n_1+n_2}\right)^2 =
\left(\dfrac{\dfrac{n_1}{n_2}-1}{\dfrac{n_1}{n_2}+1}\right)^2=
\left(\dfrac{\dfrac{n_2}{n_1}-1}{\dfrac{n_2}{n_1}+1}\right)^2
\]</span></p>
<h3 id="球的法向反向">球的法向反向</h3>
<ul>
<li>半径设置为负数，这样可以让法相反向
<ul>
<li>因为我们在计算法相的时候，有一个除以半径的操作</li>
</ul></li>
</ul>
<h2 id="相机">8. 相机</h2>
<ul>
<li>相机参数，<code>y-z</code> 平面</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/fig-1.14-cam-view-geom.jpg" style="zoom: 80%;"></p>
<ul>
<li>lookfrom、lookat</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/fig-1.15-cam-view-dir.jpg" style="zoom: 50%;"></p>
<ul>
<li>vup：用于表示相机的倾斜程度
<ul>
<li>从而建立起坐标系</li>
</ul></li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/fig-1.16-cam-view-up.jpg" style="zoom: 50%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec3 w = (lookfrom - lookat).<span class="built_in">unit_vector</span>();</span><br><span class="line">vec3 u = vup.<span class="built_in">cross</span>(w).<span class="built_in">unit_vector</span>();</span><br><span class="line">vec3 v = w.<span class="built_in">cross</span>(u);</span><br></pre></td></tr></table></figure>
<h2 id="透镜焦距效果">9. 透镜焦距效果</h2>
<ul>
<li>defocus blur</li>
<li>depth of field：景深</li>
<li>focus distance
<ul>
<li>the distance between the projection point and the plane where
everything is in perfect focus</li>
<li>controlled by <strong>the distance between the lens and the
film/sensor</strong></li>
</ul></li>
<li>focal length：焦距
<ul>
<li>the distance between the projection point and the image plane</li>
</ul></li>
<li>aperture：光圈
<ul>
<li>大光圈 <span class="math inline">\(\to\)</span>
高进光量、浅景深</li>
</ul></li>
</ul>
<h3 id="薄透镜近似">薄透镜近似</h3>
<p><img src="/2021/11/06/CG/Kits/rt1w/fig-1.17-cam-lens.jpg" style="zoom: 67%;"></p>
<ul>
<li>我们不需要模拟内部结构，film 上的结果知识 focus plane
上物体的倒影罢了，因此我们可以直接对 focus plane
上的物体成像（二者是等价的）</li>
<li>也就是说，从透镜上采样即可</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/fig-1.18-cam-film-plane.jpg" style="zoom: 50%;"></p>
<h2 id="结果图展示">10. 结果图展示</h2>
<h3 id="spp">spp</h3>
<h4 id="场景-1">场景 1</h4>
<ul>
<li>1000spp</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/003_1000spp.png"></p>
<ul>
<li>10000spp</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/003_10000spp.png"></p>
<h4 id="场景-2">场景 2</h4>
<ul>
<li>1spp</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/004_1spp.png"></p>
<ul>
<li>10spp</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/004_10spp.png"></p>
<ul>
<li>100spp</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/004_100spp.png"></p>
<ul>
<li>1000spp</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/004_1000spp.png"></p>
<h3 id="最终结果">最终结果</h3>
<ul>
<li>景深效果：1000spp</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> dist_to_focus = <span class="number">10.0</span>; <span class="comment">// focus plane</span></span><br><span class="line"><span class="type">double</span> aperture = <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/06/CG/Kits/rt1w/005_1000spp.png"></p>
<ul>
<li>无景深效果：1000spp</li>
</ul>
<p><img src="/2021/11/06/CG/Kits/rt1w/004_1000spp.png"></p>
<h2 id="说明">11. 说明</h2>
<ul>
<li><p>OK</p>
<ul>
<li>物体：球体</li>
<li>相机：任意位置</li>
<li>材质：diffuse、metal(glossy/specular)、dielectric</li>
</ul></li>
<li><p>NO</p>
<ul>
<li>光源</li>
<li>加速结构</li>
<li>三角面片</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.Kits</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>Ray Tracing The Next Week</title>
    <url>/2021/11/16/CG/Kits/rtnw/</url>
    <content><![CDATA[<ul>
<li><a href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">Ray
Tracing The Next Week</a></li>
</ul>
<h1 id="ray-tracing-the-next-week">Ray Tracing The Next Week</h1>
<ul>
<li>版本：<code>3.2.3</code>， <code>2020-12-07</code></li>
<li>光追框架理解</li>
<li>工程能力训练</li>
</ul>
<h2 id="说明">1. 说明</h2>
<ul>
<li>更复杂的功能，<a href="https://in1weekend.blogspot.com/">作者博客</a>
<ul>
<li>需要科学上网</li>
</ul></li>
</ul>
<h2 id="运动模糊">2. 运动模糊</h2>
<ul>
<li>motion blur</li>
<li>实际相机的快门开闭是有时间的，对这段时间内的光线做平均</li>
<li>实现
<ul>
<li>需要添加能够移动的物体</li>
<li>相机需要有一个开闭时间</li>
<li>光线上需要带一个时间戳，用于求交的时候确定物体的位置</li>
</ul></li>
</ul>
<h3 id="效果图100spp">效果图(100spp)</h3>
<ul>
<li>大光圈</li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/100_no_motion_blur_A0.5.png"></p>
<ul>
<li>大光圈 + 运动模糊</li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/100_motion_blur_A0.5.png"></p>
<ul>
<li>小光圈 + 运动模糊</li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/100_motion_blur_A0.1.png"></p>
<ul>
<li>小光圈</li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/100_no_motion_blur_A0.1.png"></p>
<h2 id="bvh">3. BVH</h2>
<ul>
<li>Bounding Volume Hierarchies
<ul>
<li>包围盒（<strong>静态场景</strong>）</li>
</ul></li>
<li>之前光线和场景求交：逐个遍历所有物体
<ul>
<li>加速方法
<ul>
<li>拆分空间</li>
<li>拆分物体：BVH</li>
</ul></li>
</ul></li>
<li>基本思想：如果光线联保为何都没有击中，那么肯定不能击中物体</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ray hits bounding object)</span><br><span class="line">    <span class="keyword">return</span> whether ray hits bounded objects;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>包围盒例子</li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/fig-2.01-bvol-hierarchy.jpg" style="zoom:50%;"></p>
<ul>
<li>因为有可能重合，击中左边的子结点之后，还有可能击中右边的子结点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (hits purple) &#123;</span><br><span class="line">    hit0 = hits blue enclosed objects;</span><br><span class="line">    hit1 = hits red enclosed objects;</span><br><span class="line">    <span class="keyword">if</span> (hit0 <span class="keyword">or</span> hit1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">and</span> info of closer hit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="aabb-包围盒">AABB 包围盒</h3>
<ul>
<li>Axis-Aligned Bounding Boxes
<ul>
<li>轴对齐的包围盒</li>
</ul></li>
<li>一个好的划分方式很重要
<ul>
<li>中点划分</li>
<li>等量划分</li>
<li>SAH</li>
</ul></li>
</ul>
<h4 id="判断相交">判断相交</h4>
<ul>
<li>射线和平面求交</li>
</ul>
<p><span class="math display">\[
\mathbf{P}(t) = \mathbf{A} + t \mathbf{b}
\]</span></p>
<ul>
<li><span class="math inline">\(x\)</span> 轴为例</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
x_0 = A_x + t_0 b_x\\
t_0 = \dfrac{x_0 - A_x}{b_x}\\
t_1 = \dfrac{x_1 - A_x}{b_x}\\
\end{array}
\]</span></p>
<p><img src="/2021/11/16/CG/Kits/rtnw/fig-2.03-ray-slab.jpg" style="zoom: 50%;"></p>
<ul>
<li>三个维度的 <span class="math inline">\([t_0,t_1]\)</span>
相交是否为空，不为空返回的就是光线和包围盒相交的部分</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">compute</span> (tx0, tx1);</span><br><span class="line"><span class="built_in">compute</span> (ty0, ty1);</span><br><span class="line"><span class="built_in">compute</span> (tz0, tz1);</span><br><span class="line"><span class="keyword">return</span> overlap?( (tx0, tx1), (ty0, ty1), (tz0, tz1));</span><br></pre></td></tr></table></figure>
<ul>
<li><p>slab：就是指上面 <span class="math inline">\((x_0,x_1)\)</span>
之间</p></li>
<li><p>注意事项</p>
<ul>
<li><p><span class="math inline">\(t_1&lt;t_0\)</span></p>
<ul>
<li>二者取大取小即可</li>
</ul></li>
<li><p>除 0</p>
<ul>
<li>浮点数可以自己处理这个情况</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.0</span>/<span class="number">0.0</span> = inf;</span><br><span class="line"><span class="number">-1.0</span>/<span class="number">0.0</span> = -inf;</span><br><span class="line"><span class="comment">// inf &gt; 1.0, 可以和一个实数值比大小</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>光线起点在 slab 边界上而且恰好同时除 0</p>
<ul>
<li><p>0/0 的情况，造成 NaN</p>
<ul>
<li>NaN 和任何数字相比都返回 false</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">fmax</span>(<span class="number">0.0</span> / <span class="number">0.0</span>, <span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">std::<span class="built_in">fmin</span>(<span class="number">0.0</span> / <span class="number">0.0</span>, <span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>这种情况是恰好光线掠过边界，可以当作击中，也可以当作不击中</p>
<ul>
<li>我们认为<strong>不击中</strong></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="建立包围盒">建立包围盒</h4>
<ul>
<li>在 hittable 物体中都加上一个包围盒函数
<ul>
<li>返回值为 bool，不是所有的物体都包含包围盒（无限大的平面）</li>
<li>对于移动的物体，我们直接返回这段时间内移动轨迹的包围盒</li>
</ul></li>
</ul>
<h3 id="总结">总结</h3>
<ul>
<li>小场景中，包围盒加速效果不明显，甚至变慢
<ul>
<li>random 场景中，100ssp
<ul>
<li>遍历：60s</li>
<li>BVH：120s</li>
</ul></li>
</ul></li>
</ul>
<h2 id="纹理">4. 纹理</h2>
<ul>
<li>Texture</li>
</ul>
<h3 id="球面纹理坐标">球面纹理坐标</h3>
<ul>
<li>经纬度
<ul>
<li><span class="math inline">\(\phi\in[0,2\pi]\)</span>
<ul>
<li><span class="math inline">\(-x\to+z\to+x\to-z\)</span></li>
</ul></li>
<li><span class="math inline">\(\theta\in[0,\pi]\)</span>
<ul>
<li><span class="math inline">\(-y\to y\)</span></li>
</ul></li>
</ul></li>
<li><span class="math inline">\([\theta,\pi]\to[u,v]\)</span>
<ul>
<li><span class="math inline">\(u,v\in[0,1]\)</span></li>
<li><span class="math inline">\((u,v)=(0,0)\)</span>：<strong>左下角</strong></li>
</ul></li>
</ul>
<h4 id="推导">推导</h4>
<p><span class="math display">\[
\begin{array}{rl}
y=&amp;-\cos{\theta}\\
x=&amp;-\cos{\phi}\sin{\theta}\\
z=&amp;\quad\sin{\phi}\sin{\theta}\\
\end{array}
\]</span></p>
<p><span class="math display">\[
\begin{array}{c}
\phi=\arctan\left(\dfrac{-x}{z}\right)\\
\theta=\arccos(-y)\\
\end{array}
\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">phi = <span class="built_in">atan2</span>(z, -x) + pi; <span class="comment">// [-pi, pi] + pi</span></span><br><span class="line">theta = <span class="built_in">acos</span>(-y);</span><br></pre></td></tr></table></figure>
<h3 id="效果图">效果图</h3>
<ul>
<li>高清大图：1000spp</li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/checker_texture_1000spp.png"></p>
<h2 id="柏林噪声">5. 柏林噪声</h2>
<ul>
<li>Perlin Noise</li>
<li>对于一个三维的输入产生一个实数输出
<ul>
<li>同样的输入对应同样的输出</li>
</ul></li>
<li>简单、快速、有重复性</li>
<li><a href="https://zhuanlan.zhihu.com/p/206271895">柏林噪声参考</a></li>
<li>非整数坐标点
<ul>
<li>输入一个点 <span class="math inline">\(\to\)</span> 根据周围的 8
个整数坐标点，三线性插值该点的噪声值</li>
</ul></li>
<li>整数坐标点
<ul>
<li>每一个维度 （<span class="math inline">\(x,y,z\)</span>）有一张排列表，根据排列表找到噪声值</li>
<li>排列表可以直接保存噪声值（减少存储）</li>
</ul></li>
<li>效果图如下</li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/trilinear_interpolation2.png"></p>
<ul>
<li>可以让噪声纹理更加高频</li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/perlin_high_frequency.png"></p>
<ul>
<li>柏林噪声插值的实际上是向量，每一个顶点都有一个随机向量
<ul>
<li><strong>将三线性插值的得到的向量</strong>点乘<strong>权重向量</strong></li>
<li>可能出现负值</li>
</ul></li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/perlin_high_frequency_vec.png"></p>
<ul>
<li>Turbulence（湍流）
<ul>
<li>将不同位置的柏林噪声以某种权重叠加在一起</li>
</ul></li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/perlin_high_frequency_vec_turbulence.png"></p>
<ul>
<li>大理石样纹理</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">color</span>(<span class="number">0.5</span> * (<span class="number">1</span> + <span class="built_in">sin</span>(scale * p.<span class="built_in">z</span>() + <span class="number">10</span> * noise.<span class="built_in">turb</span>(p))));</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/16/CG/Kits/rtnw/perlin_high_frequency_vec_turbulence_sine.png"></p>
<ul>
<li>加了个纹理小球（在反射中能够看到）</li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/ball_scene_add_perlin.png"></p>
<h2 id="图片纹理映射">6. 图片纹理映射</h2>
<ul>
<li>使用了 <code>stb_image.h</code> 库进行图片读取</li>
<li>和之前没有什么不同，在材质读取 value
的时候，利用纹理坐标在图片上读取即可</li>
</ul>
<h2 id="长方体和光源">7. 长方体和光源</h2>
<h3 id="光源">(1) 光源</h3>
<ul>
<li>光源的设置
<ul>
<li>设置为一种材质，实现 material 类的 emitted 方法
<ul>
<li>默认发白光</li>
</ul></li>
<li>光源不散射光线，因此 scatter 函数返回 false</li>
</ul></li>
</ul>
<h3 id="长方形">(2) 长方形</h3>
<ul>
<li>轴平齐的长方形
<ul>
<li>Axis Aligned</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">xy_rect</span>:<span class="keyword">public</span> hitabble &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">yz_rect</span>:<span class="keyword">public</span> hitabble &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">zx_rect</span>:<span class="keyword">public</span> hitabble &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>cornell box 的例子</li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/CornellBox-mt19937-1000spp.png"></p>
<ul>
<li>1000spp 使用取余数的方法对比图</li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/CornellBox-rand-1000spp.png"></p>
<ul>
<li>不太清楚为什么上面会出现一条亮斑？
<ul>
<li>麻了麻了，竟然是<strong>随机数</strong>的问题（100spp）
<ul>
<li>下面直接取余数的方法，慢很多，大概时间花销在 4.5 倍左右</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rand</span>() / (RAND_MAX + <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/16/CG/Kits/rtnw/rand-100spp.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="type">static</span> std::mt19937 generator;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">distribution</span>(generator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/16/CG/Kits/rtnw/mt19937-100spp.png"></p>
<h2 id="实例化">8. 实例化</h2>
<h3 id="box">(1) Box</h3>
<ul>
<li>box 很简单，就是直接画出 6 个面即可</li>
<li>1000spp（mt19937）
<ul>
<li>487 s</li>
</ul></li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/CornellBox-mt19937-2box-1000spp.png"></p>
<ul>
<li>1000spp（rand）
<ul>
<li>1789 s</li>
</ul></li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/CornellBox-rand-2box-1000spp.png"></p>
<h3 id="实例化-1">(2) 实例化</h3>
<ul>
<li>一些对 box 的操作，平移旋转
<ul>
<li><strong>这里不支持矩阵的变换</strong></li>
</ul></li>
<li>平移，旋转的设计
<ul>
<li>包装，形成一个新的实例</li>
</ul></li>
<li>平移为例</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">translate</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">        vec3 offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>平移的的实现比较简单
<ul>
<li>保存一个内部的物体、平移的量</li>
<li>求交的时候可以先将光线的起点进行相同的平移，然后和内部物体进行判断求交</li>
<li>如果有交点，那么修正交点即可（加上平移量）
<ul>
<li>法线是不变的</li>
</ul></li>
</ul></li>
<li>旋转则比较麻烦
<ul>
<li>法线也会变化</li>
<li>绕一个方向旋转的时候，法线变换和旋转变换相同
<ul>
<li>正交矩阵：<span class="math inline">\((M^{-1})^{T}=M\)</span></li>
</ul></li>
<li>光线求交的时候先<strong>逆向</strong>旋转内部物体处（起点 +
方向）</li>
<li>如果有交点，则对交点的位置和法向进行修正（<strong>初始</strong>的旋转，即<strong>正向</strong>的旋转）</li>
</ul></li>
<li>10000spp（rand）
<ul>
<li>耗时 18480 s</li>
</ul></li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/CornellBox-rand-2box-10000spp-cost-18480s.png"></p>
<h2 id="体积渲染">9. 体积渲染</h2>
<ul>
<li>参与介质
<ul>
<li>participating media</li>
<li>volume</li>
</ul></li>
<li>如果真的按照体渲染的方式进行渲染的话，需要对整个架构进行修改，和表面渲染大不相同</li>
<li>一个实现的 trick
<ul>
<li>用一个物体表示，但是它的表面以一定概率存在</li>
<li>构造虚假的穿透效果</li>
</ul></li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/fig-2.08-ray-vol.jpg" style="zoom: 50%;"></p>
<ul>
<li>光线可能直接穿过这个物体，可能在内部发生散射</li>
<li>求出光线在内部的长度（在这段区域的任何部分都有可能被散射）</li>
<li>假定密度为 1 的物体，散射距离为 <span class="math inline">\(\infty\)</span>，那么在内部光线长度为 <span class="math inline">\(l\)</span> 的散射概率如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> distance_inside_boundary = (rec2.t - rec1.t) * ray_length;</span><br><span class="line"><span class="comment">// eps 为了防止 0 的出现, 理论是 0 是无穷似乎没问题</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> hit_distance = neg_inv_density * <span class="built_in">log</span>(<span class="built_in">random_double</span>(<span class="number">1e-8</span>, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (hit_distance &gt; distance_inside_boundary) &#123;</span><br><span class="line">    <span class="comment">// 不散射</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 散射</span></span><br></pre></td></tr></table></figure>
<ul>
<li>密度用于调整参与介质的大小，密度越大，可以散射的范围越小（分母越小），更容易散射</li>
</ul>
<h2 id="最终场景">10. 最终场景</h2>
<ul>
<li>1000spp</li>
<li>400 x 400</li>
<li>26287s = 7.30h</li>
</ul>
<p><img src="/2021/11/16/CG/Kits/rtnw/final_scene_1000spp_26287s.png"></p>
<h2 id="随机数生成器的问题">11. 随机数生成器的问题</h2>
<ul>
<li><p>应该是 openmp 的理解问题，转换成单线程之后，mt19937
就没有亮带问题了</p></li>
<li><p>学习一下 openmp</p></li>
<li><p>随机数生成性能对比</p>
<ul>
<li>单线程来看二者是差不多的，甚至 rand 更快一些</li>
</ul>
<p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">10spp</span><br><span class="line">mt19937: 19s</span><br><span class="line">rand:    16s</span><br></pre></td></tr></table></figure></p></li>
<li><p>所以感觉是 openmp 没有处理 mt19937
的问题，造成了相关性，之后再看看具体内容</p></li>
<li><p>27 核使用 mt19937 的并行结果快了 4 倍，但是使用 rand
和原来基本一样的速度</p>
<ul>
<li>rand 在实现的时候加锁了，麻了，并行了，但是完全没有并行</li>
</ul></li>
<li><p><a href="https://www.zhihu.com/question/266324703">网上一篇文章也谈到这个问题</a></p></li>
<li><p>确实是<strong>相关性问题</strong>导致的，改进随机数的生成方式</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个随机数 [0, 1)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">thread_local</span> std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">thread_local</span> std::mt19937 <span class="title">generator</span><span class="params">(omp_get_thread_num())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">distribution</span>(generator);</span><br><span class="line">    <span class="comment">// return rand() / (RAND_MAX + 1.0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/16/CG/Kits/rtnw/thread_local-1000spp.png"></p>
<ul>
<li>同时也发现了，inline 好像真的会有比较大的效率提升，大概是 2 倍
<ul>
<li>把所有的函数都修改为不是 inline 之后，运行时间是原来的 2 倍左右</li>
</ul></li>
<li>如何真正的提高并行的效率呢？看了下别人写的代码，时间比能达到 16
倍（震撼）</li>
<li>使用最终场景测试，发现好像不改之前的代码，openmp 也能有 15
倍的提升，看不懂了</li>
</ul>
]]></content>
      <categories>
        <category>CG.Kits</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>Ray Tracing-The Rest of Your Life(2)</title>
    <url>/2022/03/23/CG/Kits/rtyl-1/</url>
    <content><![CDATA[<h1 id="ray-tracing-the-rest-of-your-life">Ray Tracing-The Rest of Your
Life</h1>
<ul>
<li><a href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html"><em>Ray
Tracing: The Rest of Your Life</em></a></li>
</ul>
<h2 id="light-scattering">4. Light Scattering</h2>
<ul>
<li>光线散射（反射、折射）</li>
</ul>
<h3 id="albedo">Albedo</h3>
<ul>
<li><span class="math inline">\(A\)</span>：albedo（whiteness 的拉丁语）
<ul>
<li>物体以概率 <span class="math inline">\(A\)</span> 散射光线，以概率
<span class="math inline">\(1-A\)</span> 吸收光线</li>
</ul></li>
<li><span class="math inline">\(A\)</span>
一般被定义为反射率，可以随着颜色、入射角的方向而变化</li>
</ul>
<h3 id="scattering">Scattering</h3>
<ul>
<li>很多基于物理的渲染器会使用一组不同波长的光表示光的颜色
<ul>
<li>我们之前使用的是
RGB，可以认为是一种对于长、中、短波的光的一种近似</li>
</ul></li>
<li>我们实际看到的颜色就是如下的积分式子</li>
</ul>
<p><span class="math display">\[
Color=\int A\cdot s(dir)\cdot\text{color}(dir)
\]</span></p>
<ul>
<li>这里的 dir表示的是 ray 的出射方向
<ul>
<li>因为光路是可逆的，我们使用<strong>从相机出发的 ray</strong>
效果是一样的</li>
</ul></li>
<li><span class="math inline">\(s(dir)\)</span> 表示朝着方向 dir
出射的概率
<ul>
<li><span class="math inline">\(s()\)</span> 描述的就是一个出射方向的
pdf</li>
<li>当然，<span class="math inline">\(s()\)</span>
可能和入射方向也有关，这样的话可以进一步描述为 <span class="math inline">\(s(view\_dir,dir)\)</span>
<ul>
<li><span class="math inline">\(view\_dir\)</span>
表示入射光的方向，也就是视线的方向</li>
</ul></li>
</ul></li>
<li><span class="math inline">\(\mathrm{color}(dir)\)</span> 表示朝着
dir 这个方向的颜色，是递归定义</li>
</ul>
<h3 id="散射-pdf">散射 pdf</h3>
<ul>
<li>利用 MC 框架进行计算</li>
</ul>
<p><span class="math display">\[
Color=\dfrac{A\cdot s(dir)\cdot\text{color}(dir)}{p(dir)}
\]</span></p>
<ul>
<li><span class="math inline">\(p(dir)\)</span> 是我们用于采样的
pdf</li>
</ul>
<h4 id="lambertian-材质">Lambertian 材质</h4>
<p><span class="math display">\[
s(dir)=k\cos\theta
\]</span></p>
<ul>
<li><span class="math inline">\(\theta\)</span> 表示出射方向 dir
和法线的夹角</li>
<li>我们是对立体角进行采样，等价于在球的表面进行采样，需要转化为 <span class="math inline">\(dS\)</span>
<ul>
<li>法向半球采样</li>
</ul></li>
</ul>
<p><span class="math display">\[
\int k\cos\theta\;\mathrm{d}S
=\int_{0}^{2\pi}\int_{0}^{\pi/2}k\cos\theta\sin\theta\;\mathrm{d}\theta\mathrm{d}\phi
=k\pi=1
\]</span></p>
<ul>
<li>于是有</li>
</ul>
<p><span class="math display">\[
s(dir)=\dfrac{\cos\theta}{\pi}
\]</span></p>
<ul>
<li>我们可以使用和 <span class="math inline">\(s(dir)\)</span>
相同的采样方式，<span class="math inline">\(p(dir)=s(dir)\)</span>
<ul>
<li>这样子方差也不是为 0，方差为 0 的话应该是 <span class="math inline">\(p(dir)=s(dir)\cdot \mathrm{color}(dir)\)</span>
<ul>
<li>还得归一化</li>
</ul></li>
</ul></li>
<li>于是我们得到</li>
</ul>
<p><span class="math display">\[
Color=A\cdot\text{color}(dir)
\]</span></p>
<ul>
<li>这和我们之前得到的形式是一致的，但是我们需要泛化他，这样才能够结合新的采样方式
<ul>
<li>不一定是均匀采样，可能是对高贡献的方向多采样（例如导向光源）</li>
</ul></li>
<li>文献中更多使用 BRDF 来描述
<ul>
<li>Bidirectional Reflectance Distribution Function</li>
</ul></li>
<li>BRDF 定义如下</li>
</ul>
<p><span class="math display">\[
BRDF=\dfrac{A\cdot s(dir)}{\cos\theta}
\]</span></p>
<ul>
<li>朗伯材质的表面散射的 BRDF 如下</li>
</ul>
<p><span class="math display">\[
BRDF=\dfrac{A}{\pi}
\]</span></p>
<ul>
<li>也就是说</li>
</ul>
<p><span class="math display">\[
Color=\dfrac{BRDF\cdot\cos\theta}{p(dir)}\cdot\text{color}(dir)
\]</span></p>
<ul>
<li>对于参与介质而言，通常称 albedo 为 scattering albedo，城 scattering
pdf 为 phase function
<ul>
<li>participation media (volumes)</li>
</ul></li>
</ul>
<h2 id="importance-sampling-material">5. Importance Sampling
Material</h2>
<ul>
<li>我们可以使用任意的 pdf 进行采样，<strong>任意的 pdf
都会让结果是无偏的</strong>，只是会影响收敛速度</li>
<li>我们期望我们结果的图片不要有太多噪点，希望采样到更多更亮的点
<ul>
<li><strong>更多的向光源采样</strong></li>
</ul></li>
<li>我们记之前和 <span class="math inline">\(s()\)</span> 相关的 pdf 为
<span class="math inline">\(\text{pSurface}(dir)\)</span>，和光源相关的
pdf 为 <span class="math inline">\(\text{pLight}(dir)\)</span></li>
<li>我们可以对这两种方式进行一个组合</li>
<li>如下是一个例子</li>
</ul>
<p><span class="math display">\[
p(dir) = \frac{1}{2}\cdot \text{Light}(dir)
                  + \frac{1}{2}\cdot \text{pSurface}(dir)
\]</span></p>
<ul>
<li>事实上，任意 <span class="math inline">\(0\le\alpha\le1\)</span>
都是一个 pdf</li>
</ul>
<p><span class="math display">\[
p(dir) = \alpha\cdot \text{Light}(dir)
                  + (1-\alpha)\cdot \text{pSurface}(dir)
\]</span></p>
<ul>
<li>我们选择 pdf 的参考就是让 pdf 尽可能接近于 <span class="math inline">\(s(dir)\cdot\text{color}(dir)\)</span>
<ul>
<li>简单地说，<span class="math inline">\(s(dir)\cdot\text{color}(dir)\)</span>
越大的地方，我们期望 pdf 值越大</li>
</ul></li>
<li>对于朗伯材质而言，一个猜测是，<span class="math inline">\(\text{color}(dir)\)</span> 越大，pdf 越大</li>
<li>镜面材质，special case，出射方向比较小</li>
</ul>
<h3 id="cornell-box1000spp">Cornell Box(1000spp)</h3>
<ul>
<li>以这个为例，开始降噪
<ul>
<li>166s</li>
</ul></li>
</ul>
<p><img src="/2022/03/23/CG/Kits/rtyl-1/1000spp-166s.png"></p>
<ul>
<li>更新材质类，提供 pdf 功能</li>
<li>Lambertian 余弦采样</li>
<li>171s</li>
</ul>
<p><img src="/2022/03/23/CG/Kits/rtyl-1/pdf-1000spp-171s.png"></p>
<ul>
<li>修改 pdf，法向半球采样
<ul>
<li>感觉噪点变重了，<strong>但是确实也是无偏的</strong></li>
</ul></li>
</ul>
<p><img src="/2022/03/23/CG/Kits/rtyl-1/pdf-hemi-1000spp-181s.png"></p>
<h2 id="如何采样分布">6. 如何采样分布</h2>
<ul>
<li>简单化
<ul>
<li>将 <span class="math inline">\(z\)</span> 轴作为法向量方向</li>
<li>只处理关于 <span class="math inline">\(z\)</span>
轴旋转对称的情况</li>
</ul></li>
<li>我们记 <span class="math inline">\(dir\)</span> 和法向的夹角为 <span class="math inline">\(\theta\)</span>，此时有</li>
</ul>
<p><span class="math display">\[
p(dir)=f(\theta)
\]</span></p>
<ul>
<li>我们指定一个分布 <span class="math inline">\(p(dir)=f(\theta)\)</span></li>
<li>我们都是认为在球面上采样</li>
</ul>
<p><span class="math display">\[
\int f(\theta)\;\mathrm{d}S=1
\]</span></p>
<ul>
<li>转化为 <span class="math inline">\(\theta,\phi\)</span> 如下</li>
</ul>
<p><span class="math display">\[
\int_{0}^{2\pi}\int_{0}^{\pi}
f(\theta)\sin\theta\;\mathrm{d}\theta\mathrm{d}\phi=1
\]</span></p>
<ul>
<li>我们能够得到边缘分布如下</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
a(\phi)
&amp;=\int_{0}^{\pi} f(\theta)\sin\theta\;\mathrm{d}\theta\\
&amp;=\dfrac{1}{2\pi}\int_{0}^{2\pi}\int_{0}^{\pi}
f(\theta)\sin\theta\;\mathrm{d}\theta\mathrm{d}x\\
&amp;=\dfrac{1}{2\pi}\\
\end{aligned}
\]</span></p>
<p><span class="math display">\[
b(\theta)=\int_{0}^{2\pi}f(\theta)\sin\theta\;\mathrm{d}\phi=2\pi
f(\theta)\sin\theta
\]</span></p>
<ul>
<li>我们指定 <span class="math inline">\(r_1,r_2\)</span> 为满足 <span class="math inline">\([0,1]\)</span> 均匀分布的随机变量，如何产生 <span class="math inline">\(\theta,\phi\)</span> 呢？
<ul>
<li>利用<a href="/2022/03/11/CG/Kits/rtyl/">之前的知识</a>即可，cdf
相同或者直接求逆（单射）</li>
</ul></li>
</ul>
<h3 id="球面均匀采样">球面均匀采样</h3>
<p><span class="math display">\[
f(\theta)=\dfrac{1}{4\pi}
\]</span></p>
<ul>
<li>利用 cdf 相同，可以求得</li>
</ul>
<p><span class="math display">\[
\phi=2\pi r_1
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;\Pr(R_2\le r_2)=\Pr(\Theta\le\theta)\\
\Longrightarrow&amp;\;r_2=\int_{0}^{\theta} 2\pi f(t)\sin
t\;\mathrm{d}t=\dfrac{1-\cos\theta}{2}\\
\Longrightarrow&amp;\;\cos\theta=1-2r_2\\
\end{aligned}
\]</span></p>
<ul>
<li>根据 <span class="math inline">\(x,y,z\)</span> 变换</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
x = \cos(\phi) \cdot \sin(\theta)\\
y = \sin(\phi) \cdot \sin(\theta)\\
z = \cos(\theta)\\
\end{array}
\]</span></p>
<ul>
<li>得到</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
x = \cos(2\pi r_1) \cdot 2 \sqrt{r_2(1 - r_2)}\\
y = \sin(2\pi r_1) \cdot 2 \sqrt{r_2(1 - r_2)}\\
z = 1-2r_2\\
\end{array}
\]</span></p>
<ul>
<li>如此，我们得到了一个球面上的均匀采样</li>
</ul>
<h3 id="半球均匀采样">半球均匀采样</h3>
<h4 id="半球均匀采样-1">半球均匀采样</h4>
<p><span class="math display">\[
f(\theta)=\dfrac{1}{2\pi}
\]</span></p>
<ul>
<li>类似的我们可以得到</li>
</ul>
<p><span class="math display">\[
\phi=2\pi r_1,\cos\theta=1-r_2
\]</span></p>
<ul>
<li>于是</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
x = \cos(2\pi r_1) \cdot \sqrt{r_2(2 - r_2)}\\
y = \sin(2\pi r_1) \cdot \sqrt{r_2(2 - r_2)}\\
z = 1-r_2\\
\end{array}
\]</span></p>
<h4 id="例子">例子</h4>
<ul>
<li>一个<strong>半球采样</strong>的例子如下（朗伯反射）</li>
</ul>
<p><span class="math display">\[
p(dir)=\dfrac{\cos\theta}{\pi}
\]</span></p>
<ul>
<li>计算</li>
</ul>
<p><span class="math display">\[
r_2=\int_{0}^{\theta} 2\pi\dfrac{\cos t}{\pi}\sin
t\;\mathrm{d}t=1-\cos^2\theta
\]</span></p>
<p><span class="math display">\[
\phi=2\pi r_1
\]</span></p>
<ul>
<li>变换
<ul>
<li>因为是半球，因此 <span class="math inline">\(z\ge0\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
x = \cos(2\pi r_1) \cdot \sqrt{r_2}\\
y = \sin(2\pi r_1) \cdot \sqrt{r_2}\\
z = \sqrt{1-r_2}\\
\end{array}
\]</span></p>
<h2 id="正交基">7. 正交基</h2>
<ul>
<li>正交基：orthonormal basis (ONB)
<ul>
<li>3 个正交向量</li>
</ul></li>
<li>上面我们讨论了如何生成关于 <span class="math inline">\(z\)</span>
轴旋转对称的分布，如何将其变换到关于法向对称分布？
<ul>
<li><strong>坐标变换</strong></li>
</ul></li>
<li>我们使用的是简化版的坐标变换，只需要将 <span class="math inline">\(z\)</span>
轴（局部坐标系）变换到法向（全局坐标系）即可</li>
</ul>
<h3 id="构建局部坐标系">构建局部坐标系</h3>
<ul>
<li>有 <span class="math inline">\(\mathbf{n}\)</span>（法线）</li>
<li>生成一个与 <span class="math inline">\(\mathbf{n}\)</span>
不平行的方向 <span class="math inline">\(\mathbf{a}\)</span>
<ul>
<li>判断 <span class="math inline">\(\mathbf{n}\)</span>
是否为特定轴，如果不是则选取 <span class="math inline">\(\mathbf{a}\)</span> 为某个轴即可</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n.x &gt; <span class="number">0.9</span>):</span><br><span class="line">    a = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    a = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{array}{c}
\mathbf{t}=\text{unit_vector}(\mathbf{a}\times \mathbf{n})\\
\mathbf{s}=\mathbf{t}\times \mathbf{n}\\
\end{array}
\]</span></p>
<ul>
<li>现在得到了标准正交基 <span class="math inline">\(\mathbf{s},\mathbf{t},\mathbf{n}\)</span></li>
</ul>
<h3 id="变换">变换</h3>
<ul>
<li>标准正交基 <span class="math inline">\(\mathbf{s},\mathbf{t},\mathbf{n}\)</span>
中方向坐标为 <span class="math inline">\((x,y,z)\)</span></li>
<li>全局坐标系中的方向为 <span class="math inline">\((x&#39;,y&#39;,z&#39;)\)</span></li>
</ul>
<p><span class="math display">\[
\begin{pmatrix} \mathbf{s}^t\\\mathbf{t}^t\\\mathbf{n}^t\end{pmatrix}
\begin{pmatrix} x&#39;\\y&#39;\\z&#39; \end{pmatrix}
=
\begin{pmatrix} x\\y\\z \end{pmatrix}
\]</span></p>
<ul>
<li>于是</li>
</ul>
<p><span class="math display">\[
\begin{pmatrix} x&#39;\\y&#39;\\z&#39; \end{pmatrix}
=
\begin{pmatrix} \mathbf{s}^t\\\mathbf{t}^t\\\mathbf{n}^t\end{pmatrix}^t
\begin{pmatrix} x\\y\\z \end{pmatrix}
=
\begin{pmatrix} \mathbf{s}&amp;\mathbf{t}&amp;\mathbf{n}\end{pmatrix}
\begin{pmatrix} x\\y\\z \end{pmatrix}
=x\mathbf{s}+y\mathbf{t}+z\mathbf{n}
\]</span></p>
<ul>
<li>此时利用上面说的方式采样，结果图如下</li>
</ul>
<p><span class="math display">\[
p(dir)=\dfrac{\cos\theta}{\pi}
\]</span></p>
<p><img src="/2022/03/23/CG/Kits/rtyl-1/pdf-hemi-true-1000spp-174s.png"></p>
<ul>
<li>说实话看不出来很大区别</li>
</ul>
]]></content>
      <categories>
        <category>CG.Kits</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>Ray Tracing-The Rest of Your Life(3)</title>
    <url>/2022/03/28/CG/Kits/rtyl-2/</url>
    <content><![CDATA[<h1 id="ray-tracing-the-rest-of-your-life">Ray Tracing-The Rest of Your
Life</h1>
<ul>
<li><a href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html"><em>Ray
Tracing: The Rest of Your Life</em></a></li>
</ul>
<h2 id="直接对光源采样">8. 直接对光源采样</h2>
<p><img src="https://raytracing.github.io/images/fig-3.07-shape-onto-pdf.jpg" style="zoom: 50%;"></p>
<ul>
<li>在一块面积为 <span class="math inline">\(A\)</span>
的区域上均匀采样</li>
</ul>
<p><span class="math display">\[
p_q(q)\cdot\mathrm{d}A=\dfrac{1}{A}\cdot\mathrm{d}A
\]</span></p>
<ul>
<li>需要转化到单位球面上</li>
</ul>
<p><span class="math display">\[
\dfrac{\mathrm{d}\omega}{1^2}=\dfrac{\mathrm{d}A\cdot
\cos\alpha}{\text{distance}^2(p,q)}
\]</span></p>
<ul>
<li>转化为<strong>等价在单位球面上均匀采样</strong></li>
</ul>
<p><span class="math display">\[
p_q(q)\cdot\mathrm{d}A=p(dir)\cdot\mathrm{d}\omega
\]</span></p>
<p><span class="math display">\[
p(dir)\;\mathrm{d}\omega=p(dir)\cdot\dfrac{\cos\alpha}{\text{distance}^2(p,q)}\;\mathrm{d}A=\dfrac{1}{A}\cdot\mathrm{d}A
\]</span></p>
<p><span class="math display">\[
p(dir)=\dfrac{\text{distance}^2(p,q)}{A\cdot\cos\alpha}
\]</span></p>
<h3 id="对比图">对比图</h3>
<ul>
<li>常规采样：10spp，2s</li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/10spp.png"></p>
<ul>
<li>直接对光源采样：10spp，1s
<ul>
<li>问题：只有直接光照（1-bounce）</li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/10spp-sample-the-light-directly.png"></p>
<ul>
<li>光源边上的亮斑
<ul>
<li>代码中的光源是两面的（two-sided）</li>
<li>光源位于屋顶下面一点点（不是完全重合）</li>
</ul></li>
<li>如果使用定向光，则不会出现这种情况
<ul>
<li>效果如下</li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/10spp-sample-the-light-directly-noflip.png"></p>
<ul>
<li>默认的 <code>rect_xz</code> 法向向上，加入 <code>flip_face</code>
包装类，需要修改法向方向</li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/10spp-sample-the-light-directly-flip.png"></p>
<ul>
<li>跑一个 1000 spp 看看
<ul>
<li>54s</li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/1000spp-sample-the-light-directly-flip.png"></p>
<ul>
<li>那确实就变成了实时渲染中的直接光照了（其实也不是，这里的软阴影还是有的hh）</li>
<li>准确的来说，这种方法是有偏的，<strong>因为 pdf
的非零值的定义域没有覆盖到整个积分域上</strong></li>
<li>下面这种混合 pdf 则是无偏的，因为其覆盖了整个积分域</li>
</ul>
<h2 id="混合-pdf">9. 混合 pdf</h2>
<h3 id="重构-pdf-类">重构 pdf 类</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">pdf</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">pdf</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">pdf</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 按照给定的 pdf 返回一个方向</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 返回 pdf(direction)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>新的 pdf 采样都继承自这个类</li>
<li>例如构造一个朝着某个物体采样的 pdf（<code>hittable_pdf</code>）</li>
</ul>
<h3 id="混合-pdf-1">混合 pdf</h3>
<ul>
<li>结合对光源直接采样、常规采样</li>
<li>简单使用平均两种 pdf</li>
</ul>
<p><span class="math display">\[
\text{mixture}_\text{pdf}(dir) = \frac{1}{2}
\text{reflection}_\text{pdf}(dir)
                                          + \frac{1}{2}
\text{light}_\text{pdf}(dir)
\]</span></p>
<ul>
<li>实现</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">if (random_double() &lt; 0.5)</span><br><span class="line">    pick direction according to pdf_reflection</span><br><span class="line">else</span><br><span class="line">    pick direction according to pdf_light</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">mixture_pdf::generate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">random_double</span>() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p[<span class="number">0</span>]-&gt;<span class="built_in">generate</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p[<span class="number">1</span>]-&gt;<span class="built_in">generate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">mixture_pdf::value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> * (p[<span class="number">0</span>]-&gt;<span class="built_in">value</span>(direction) + p[<span class="number">1</span>]-&gt;<span class="built_in">value</span>(direction));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="效果比较">效果比较</h3>
<h4 id="spp">10 spp</h4>
<ul>
<li>混合 pdf，1s</li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/10spp-mixture_pdf.png"></p>
<ul>
<li>常规采样：2s</li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/10spp.png"></p>
<ul>
<li>直接对光源采样：1s</li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/10spp-sample-the-light-directly.png"></p>
<h4 id="spp-1">1000 spp</h4>
<ul>
<li>直接对光源采样：54s</li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/1000spp-sample-the-light-directly-flip.png"></p>
<ul>
<li>常规采样：177s</li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/1000spp.png"></p>
<ul>
<li>混合采样：117s</li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/1000spp-mixture_pdf.png"></p>
<h2 id="架构的建议">10. 架构的建议</h2>
<ul>
<li>上面的混合采样方法，对光源方向给予更大的采样比例，能够让场景收敛的更快</li>
<li>一些问题
<ul>
<li>pdf 采样现在是硬编码在 <code>ray_color()</code>
函数里面的，应该是要放到材质里面去</li>
<li>镜面材质</li>
<li>背景色</li>
<li>使用光谱代替 RGB</li>
</ul></li>
</ul>
<h2 id="管理-pdf">11. 管理 PDF</h2>
<ul>
<li>放到材质里面去</li>
<li>如何让一种物体有两种材质的效果
<ul>
<li>varnished wood：漆木</li>
<li>部分 diffuse：木</li>
<li>部分 specular：漆</li>
</ul></li>
<li>修改不同材质的 <code>scatter()</code> 函数即可</li>
<li>把左边的 box 材质替换为镜面
<ul>
<li>左上角应该是反射（1000 spp）</li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/1000spp-cornell-box-specular.png"></p>
<ul>
<li>50000 spp
<ul>
<li>5339s</li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/50000spp-cornell-box-specular-5339s.png"></p>
<h3 id="对球体采样">对球体采样</h3>
<ul>
<li>之前我们只写了对一个长方形采样，现在增加其他的部分
<ul>
<li>修改 object 的 <code>random()</code> 函数</li>
</ul></li>
<li>计算 pdf
<ul>
<li>采样一个单位长度的出射方向, 起点在 (0,0,0), 方向和球体有交点</li>
<li>在这个立体角内部均匀后采样</li>
</ul></li>
</ul>
<h4 id="求-theta_max">求 <span class="math inline">\(\theta_{\max}\)</span></h4>
<ul>
<li><span class="math inline">\(\theta_{\max}\)</span> 如下图所示</li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/fig-3.08-sphere-enclosing-cone.jpg" style="zoom:50%;">
<span class="math display">\[
\sin(\theta_{\max})=\dfrac{R}{\Vert\mathbf{c}-\mathbf{p}\Vert_2}
\]</span></p>
<p><span class="math display">\[
\cos(\theta_{\max})=\sqrt{1-\dfrac{R^2}{\Vert\mathbf{c}-\mathbf{p}\Vert_2^2}}
\]</span></p>
<h4 id="采样">采样</h4>
<ul>
<li>最大张角为 <span class="math inline">\(\theta_{\max}\)</span></li>
</ul>
<p><span class="math display">\[
f(\theta)=\dfrac{1}{\int_{0}^{2\pi}\int_{0}^{\theta_{\max}}\sin\theta\;\mathrm{d}\theta\mathrm{d}\phi}=\dfrac{1}{2\pi(1-\cos\theta_{\max})}
\]</span></p>
<ul>
<li>求出对应关系</li>
</ul>
<p><span class="math display">\[
\phi=2\pi r_1
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;\Pr(R_2\le r_2)=\Pr(\Theta\le\theta)\\
\Longrightarrow&amp;\;r_2=\int_{0}^{\theta} 2\pi f(t)\sin
t\;\mathrm{d}t=\dfrac{1-\cos\theta}{1-\cos\theta_{\max}}\\
\Longrightarrow&amp;\;\cos\theta=1-r_2(1-\cos\theta_{\max})\\
\end{aligned}
\]</span></p>
<ul>
<li>因此 <span class="math inline">\(x,y,z\)</span> 表达如下</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
z = \cos(\theta)=1+r_2(\cos\theta_{\max}-1)\\
x = \cos(2\pi r_1) \cdot \sqrt{1-z^2}\\
y = \sin(2\pi r_1) \cdot \sqrt{1-z^2}\\
\end{array}
\]</span></p>
<h4 id="效果展示">效果展示</h4>
<ul>
<li>朝着光源采样
<ul>
<li>100spp，10s</li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/100spp-towards-light.png"></p>
<ul>
<li>朝着玻璃球采样
<ul>
<li>100spp，24s</li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/100spp-towards-glass.png"></p>
<ul>
<li>效果并没有直接对光源采样好</li>
</ul>
<h3 id="对一组对象采样">对一组对象采样</h3>
<ul>
<li>可以使用这样的方式</li>
</ul>
<p><span class="math display">\[
\text{mixture}_\text{pdf}(dir) = \frac{1}{2}
\text{reflection}_\text{pdf}(dir)
                                          + \frac{1}{2}
\text{hittable_list}_\text{pdf}(dir)
\]</span></p>
<p><span class="math display">\[
\text{hittable_list}_\text{pdf}(dir)=\dfrac{1}{N}\sum_{\text{object}\;\in\;\text{hittable_list}}\text{object}_\text{pdf}(dir)
\]</span></p>
<ul>
<li>这样只需要修改 <code>hittable_list</code> 的 <code>random()</code>
和 <code>pdf_value()</code> 函数即可</li>
<li>此时把光源和玻璃球都加入到建议采样方向上
<ul>
<li>100spp，17s</li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/100spp-towards-glass-and-light.png"></p>
<h3 id="outlier">outlier</h3>
<ul>
<li>每次得到颜色的时候，去除 NaN</li>
</ul>
<h2 id="结果">12. 结果</h2>
<ul>
<li><p><strong>中间是一个镜子</strong></p></li>
<li><p>1spp，0s</p></li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/toyscene-1spp-0s.png"></p>
<ul>
<li>10spp，1s</li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/toyscene-10spp-1s.png"></p>
<ul>
<li>100spp，10s</li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/toyscene-100spp-10s.png"></p>
<ul>
<li>1000spp，107s</li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/toyscene-1000spp-107s.png"></p>
<ul>
<li>10000spp，1108s</li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/toyscene-10000spp-1108s.png"></p>
<ul>
<li>100000spp，10332s</li>
</ul>
<p><img src="/2022/03/28/CG/Kits/rtyl-2/toyscene-100000spp-10332s.png"></p>
]]></content>
      <categories>
        <category>CG.Kits</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>Ray Tracing-The Rest of Your Life</title>
    <url>/2022/03/11/CG/Kits/rtyl/</url>
    <content><![CDATA[<ul>
<li><a href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html">Ray
Tracing: The Rest of Your Life</a></li>
</ul>
<h1 id="ray-tracing-the-rest-of-your-life">Ray Tracing-The Rest of Your
Life</h1>
<h2 id="蒙特卡洛采样">1. 蒙特卡洛采样</h2>
<ul>
<li>Monte Carlo (MC)</li>
</ul>
<p><img src="/2022/03/11/CG/Kits/rtyl/fig-3.01-circ-square.jpg"> <span class="math display">\[
\dfrac{\pi r^2}{(2r)^2}=\dfrac{\pi}{4}
\]</span></p>
<h3 id="stratified-samples-jittering">(1) Stratified Samples
(Jittering)</h3>
<ul>
<li>我们很快能够得到一个 <span class="math inline">\(\pi\)</span>
的估计，但是收敛的很慢
<ul>
<li>收益递减定律：law of diminishing return</li>
</ul></li>
<li>可以通过分层来降低影响</li>
</ul>
<p><img src="/2022/03/11/CG/Kits/rtyl/fig-3.02-jitter.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常规的 MC</span></span><br><span class="line"><span class="type">double</span> x = <span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">double</span> y = <span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (x * x + y * y &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    ++circle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分层 MC</span></span><br><span class="line"><span class="comment">// 分成了 sqrt_N * sqrt_N 个</span></span><br><span class="line">x = <span class="number">2</span> * ((i + <span class="built_in">random_double</span>()) / sqrt_N) - <span class="number">1</span>;</span><br><span class="line">y = <span class="number">2</span> * ((j + <span class="built_in">random_double</span>()) / sqrt_N) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x * x + y * y &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    ++circle_j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Regular    Estimate of PI: 3.1416273200</span><br><span class="line">Stratified Estimate of PI: 3.1415919200</span><br></pre></td></tr></table></figure>
<ul>
<li>效果确实好了，估计得更准确，收敛的也更快
<ul>
<li>为什么呢？<strong>分层采样的方差更小</strong></li>
<li><a href="/2022/03/15/CG/Kits/StratifiedSampling/">分层采样的方差分析</a></li>
</ul></li>
<li>这个优势会随着维度的增加而递减，例如把上面的代码应用到 3D
的球和正方体，用体积占比算 PI
<ul>
<li>维度的诅咒： Curse of Dimensionality</li>
</ul></li>
</ul>
<h2 id="一维-mc">2. 一维 MC</h2>
<h3 id="例子">例子</h3>
<p><span class="math display">\[
I=\int_{0}^{2}x^2\;\mathrm{d}x
\]</span></p>
<ul>
<li><span class="math inline">\([0,2]\)</span> 上均匀采样，<span class="math inline">\(p(x)=\dfrac{1}{2}\)</span></li>
</ul>
<p><span class="math display">\[
\hat{I}=\dfrac{1}{N}\sum_{i=1}^{N}\dfrac{X_i^2}{p(X_i)}=\dfrac{1}{N}\sum_{i=1}^{N}2X_i^2
\]</span></p>
<ul>
<li>结果如下：<span class="math inline">\(\dfrac{8}{3}\)</span></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.6671368997</span><br><span class="line">2.6669793315</span><br><span class="line">2.6669378018</span><br></pre></td></tr></table></figure>
<ul>
<li>MC 适用于一些很难显式求出积分的问题，例如</li>
</ul>
<p><span class="math display">\[
I=\int_{1}^{2}\log(\sin x)\;\mathrm{d}x
\]</span></p>
<h3 id="pdf">PDF</h3>
<ul>
<li>pdf：<em>probability density function</em>
<ul>
<li><span class="math inline">\(p(x)\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\int_{\infty}^{\infty}p(x)\;\mathrm{d}x=1
\]</span></p>
<ul>
<li>cdf：<em>cumulative probability distribution function</em>
<ul>
<li><span class="math inline">\(F(x)\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
F(x_0)=\int_{-\infty}^{x_0}p(x)\;\mathrm{d}x
\]</span></p>
<h3 id="采样特定分布">采样特定分布</h3>
<ul>
<li>如何从一个均匀分布采样得到另外一个分布呢？</li>
<li>目标 cdf 为 <span class="math inline">\(F(x)\)</span>，目标 pdf 为
<span class="math inline">\(p(x)\)</span>，<span class="math inline">\(p(x)\)</span> 在 <span class="math inline">\([0,1]\)</span> 上非零，<span class="math inline">\(U\)</span> 表示 <span class="math inline">\([0,1]\)</span> 上的均匀分布</li>
<li>我们需要找函数 <span class="math inline">\(f(u(x))\)</span>，使得
pdf 为 <span class="math inline">\(p(x)\)</span></li>
<li>设 <span class="math inline">\(X=f(U)\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
F(x)&amp;=\Pr(X\le x)\\
&amp;=\Pr\Big(f(U)\le x\Big)\\
&amp;=\Pr\Big(U\le f^{-1}(x)\Big)\\
&amp;=f^{-1}(x)
\end{aligned}
\]</span></p>
<ul>
<li>于是有</li>
</ul>
<p><span class="math display">\[
f(x)=F^{-1}(x)
\]</span></p>
<ul>
<li>于是我们便可以产生指定分布的样本</li>
</ul>
<h4 id="例子-1">例子</h4>
<ul>
<li>指定 <span class="math inline">\(p(x)=\dfrac{x}{2},0\le
x\le2\)</span></li>
<li><span class="math inline">\(F(x)=\dfrac{x^2}{4}\)</span></li>
<li><span class="math inline">\(f(x)=\sqrt{4y}\)</span></li>
<li>样本生成：<span class="math inline">\(X=2\sqrt{U}\)</span></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimate_x_x_pdf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = <span class="number">100000000</span>;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0.0</span>, ans_pdf = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ++num;</span><br><span class="line">        <span class="type">double</span> x = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        ans += <span class="number">2</span> * x * x;</span><br><span class="line"></span><br><span class="line">        x = <span class="number">2</span> * <span class="built_in">sqrt</span>(<span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">        ans_pdf += x * <span class="number">2</span>;  <span class="comment">// x*x/p(x) = x*x*2/x = x*2</span></span><br><span class="line">        <span class="keyword">if</span> (num % N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">                <span class="string">&quot;uniform: %.10lf\n&quot;</span></span><br><span class="line">                <span class="string">&quot;pdf=x/2: %.10lf\n\n&quot;</span>,</span><br><span class="line">                ans / num, ans_pdf / num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="importance-sampling">Importance Sampling</h3>
<ul>
<li>重要性采样</li>
<li>我们期望在积分值比较大的地方采样更多的样本，这样可以得到更小的噪声，而且收敛更快</li>
<li>我们试图将采样引导向分布中比较重要的部分，这也是我们为什么要设计一个<strong>非均匀分布采样</strong>的原因
<ul>
<li>这被称为重要性采样</li>
</ul></li>
<li>例如我们如果令 <span class="math inline">\(p(x)=\dfrac{f(x)}{\int
f(x)}\)</span>，此时 <span class="math inline">\(E(X)=X,Var[X]=0\)</span>，直接一次采样返回结果</li>
</ul>
<h3 id="mc-方法流程">MC 方法流程</h3>
<ul>
<li>一个积分函数</li>
</ul>
<p><span class="math display">\[
I=\int_{\Omega}G(X)\;\mathrm{d}X=\int_{\Omega}g(X)\rho(X)\;\mathrm{d}X
\]</span></p>
<ul>
<li>一个在 <span class="math inline">\(\Omega\)</span> 上不为 0
的分布函数 pdf <span class="math inline">\(p(X)\)</span></li>
<li>采样计算结果</li>
</ul>
<p><span class="math display">\[
\hat{I}=\dfrac{1}{N}\sum_{i=1}^{N}\dfrac{G(X_i)}{p(X_i)}
\]</span></p>
<h2 id="球面-mc">3. 球面 MC</h2>
<p><img src="/2022/03/11/CG/Kits/rtyl/image-20220316190428847.png"></p>
<ul>
<li>3D 中的方向可以表示为单位球上的一个点</li>
</ul>
<p><span class="math display">\[
X=(\theta,\phi)
\]</span></p>
<ul>
<li>考虑球面均匀采样</li>
</ul>
<p><span class="math display">\[
\int_{\Omega}\;\mathrm{d}S=4\pi
\]</span></p>
<p><span class="math display">\[
\mathrm{d}S=\sin\theta\;\mathrm{d}\theta\;\mathrm{d}\phi
\]</span></p>
<h3 id="例子-2">例子</h3>
<p><span class="math display">\[
I=\int\cos^2\theta\;\mathrm{d}S=\dfrac{4\pi}{3}
\]</span></p>
<h4 id="方法一">方法一</h4>
<ul>
<li>均匀采样 <span class="math inline">\(x,y\)</span>，等价于对 <span class="math inline">\(\phi,\cos{\theta}\)</span> 均匀采样</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">vec3::random_on_unit_sphere_surface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如何在一个球面上均匀采样 ? 单位球上的面积(r=1)</span></span><br><span class="line">    <span class="comment">// dA = \sin&#123;\theta&#125;d&#123;\theta&#125;d&#123;\phi&#125; = \cos&#123;\theta&#125;d&#123;\phi&#125;</span></span><br><span class="line">    <span class="comment">// 应该是对 \phi, \cos&#123;\theta&#125; 均匀采样</span></span><br><span class="line">    <span class="type">double</span> phi = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">2</span> * pi);</span><br><span class="line">    <span class="type">double</span> z = <span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">double</span> r = std::<span class="built_in">sqrt</span>(<span class="number">1</span> - z * z);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(r * std::<span class="built_in">cos</span>(phi), r * std::<span class="built_in">sin</span>(phi), z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二">方法二</h4>
<p><span class="math display">\[
I=\int_{0}^{\pi}\left(\int_{0}^{2\pi}\cos^2\theta\sin\theta\;\mathrm{d}\theta\right)\;\mathrm{d}\phi
\]</span></p>
<ul>
<li>对 <span class="math inline">\(\phi,\theta\)</span>
均匀采样，此时的估计如下</li>
</ul>
<p><span class="math display">\[
p(\theta,\phi)=\dfrac{1}{\int_{\Omega}\;\mathrm{d}\theta\;\mathrm{d}\phi}=\dfrac{1}{2\pi^2}
\]</span></p>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// I = \int_&#123;\Omega&#125;\cos^2\theta</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimate_cos_sphere</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = <span class="number">20000000</span>;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0.0</span>, ans1 = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> <span class="type">const</span> pi4 = pi * <span class="number">4</span>;</span><br><span class="line">    <span class="type">double</span> <span class="type">const</span> pi22 = <span class="number">2</span> * pi * pi;</span><br><span class="line">    <span class="type">double</span> <span class="type">const</span> result = pi4 / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ++num;</span><br><span class="line">        <span class="comment">// p(x) = 0.5, 0&lt;=x&lt;=2</span></span><br><span class="line">        vec3 x = vec3::<span class="built_in">random_on_unit_sphere_surface</span>();</span><br><span class="line">        <span class="comment">// p(X) = 1/(4*pi)</span></span><br><span class="line">        ans += x.<span class="built_in">z</span>() * x.<span class="built_in">z</span>() * pi4;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> theta = <span class="built_in">random_double</span>(<span class="number">0</span>, pi);</span><br><span class="line">        <span class="type">double</span> phi = <span class="built_in">random_double</span>(<span class="number">0</span>, pi2);</span><br><span class="line">        <span class="type">double</span> t = <span class="built_in">cos</span>(theta);</span><br><span class="line">        <span class="comment">// p(X) = 1/(2*pi*pi)</span></span><br><span class="line">        ans1 += t * t * <span class="built_in">sin</span>(theta) * pi22;</span><br><span class="line">        <span class="keyword">if</span> (num % N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">                <span class="string">&quot;standard                :   %.10lf\n&quot;</span></span><br><span class="line">                <span class="string">&quot;dS uniform              :   %.10lf\n&quot;</span></span><br><span class="line">                <span class="string">&quot;d(theta), d(phi) uniform:   %.10lf\n&quot;</span>,</span><br><span class="line">                result, ans / num, ans1 / num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">standard                :   4.1887902048</span><br><span class="line">dS uniform              :   4.1888837271</span><br><span class="line">d(theta), d(phi) uniform:   4.1887124194</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CG.Kits</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES203.黄其兴.00.说明</title>
    <url>/2021/07/20/CG/HQX-GAMES203/00/</url>
    <content><![CDATA[<ul>
<li>GAMES203：3D Reconstruction and Understanding
<ul>
<li>三维重建和理解</li>
</ul></li>
<li><a href="https://www.cs.utexas.edu/~huangqx/Games_3D_Recons_Understanding.html">课程主页</a></li>
<li>授课老师：黄其兴</li>
<li>视频地址：<a href="https://www.bilibili.com/video/BV1pw411d7aS">B站</a></li>
<li>内容
<ul>
<li><strong>Reconstruction</strong></li>
<li><strong>Representation</strong></li>
<li><strong>Analysis</strong></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES203</category>
        <category>0</category>
        <category>CG</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>CG</tag>
        <tag>HQX</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES102.刘利刚.00.说明与课程介绍</title>
    <url>/2021/07/22/CG/LLG-GAMES102/00/</url>
    <content><![CDATA[<h1 id="说明">说明</h1>
<h2 id="课程信息">课程信息</h2>
<ul>
<li>GAMES102：Geometry Modeling and Processing (GMP)
<ul>
<li>几何建模与处理</li>
</ul></li>
<li><a href="http://staff.ustc.edu.cn/~lgliu/Courses/GAMES102_2020/default.html">课程主页</a></li>
<li>授课老师：<a href="http://staff.ustc.edu.cn/~lgliu/">刘利刚</a></li>
<li>视频地址：<a href="https://www.bilibili.com/video/BV1NA411E7Yr">B站</a></li>
<li>内容
<ul>
<li>曲线曲面的基本理论、参数样条曲线曲面、三角网格曲面、离散微分几何、细分曲面及隐式曲面、网格曲面处理（去噪、参数化、纹理合成、简化、编辑、修复）
、形状分析与理解</li>
</ul></li>
</ul>
<h2 id="课程介绍">课程介绍</h2>
<ul>
<li>计算机图形学
<ul>
<li>建模（设计）：model</li>
<li>动画（仿真）：animation</li>
<li>渲染（绘制）：rendering</li>
</ul></li>
</ul>
<h3 id="图像">图像</h3>
<ul>
<li>照片（图像）：<strong>记录</strong>真实世界投影在相机成像平面的<strong>影像</strong></li>
<li>离散表达：<strong>光栅</strong>
<ul>
<li>现在的光栅化显示器</li>
<li>分辨率：图像的像素个数</li>
</ul></li>
</ul>
<h3 id="图形">图形</h3>
<ul>
<li>2D 图形：矢量/几何图形
<ul>
<li>具有数学表达的<strong>几何对象</strong>（点、线、面）</li>
<li>点、先、多边形（曲线）、区域（封闭多边形）</li>
</ul></li>
<li>矢量图形的光栅化：扫描转化
<ul>
<li>走样问题</li>
</ul></li>
</ul>
<h3 id="光栅化">光栅化</h3>
<ul>
<li>直线的光栅化</li>
</ul>
<p><img src="/2021/07/22/CG/LLG-GAMES102/00/image-20210723114412572.png" style="zoom:67%;"></p>
<ul>
<li>多边形的光栅化</li>
</ul>
<p><img src="/2021/07/22/CG/LLG-GAMES102/00/image-20210723131304296.png" style="zoom: 67%;"></p>
<ul>
<li>三角形的光栅化</li>
</ul>
<p><img src="/2021/07/22/CG/LLG-GAMES102/00/image-20210723131318620.png" style="zoom: 67%;"></p>
<ul>
<li>文字的光栅化</li>
</ul>
<p><img src="/2021/07/22/CG/LLG-GAMES102/00/image-20210723131343859.png" style="zoom: 67%;"></p>
<h3 id="栅格图像与矢量图形">栅格图像与矢量图形</h3>
<ul>
<li>矢量图形再放大后重新计算光栅化，因此也被称为是无穷分辨率的</li>
</ul>
<p><img src="C:/Users/神秘嘉宾990/AppData/Roaming/Typora/typora-user-images/image-20210723131550186.png"></p>
<h3 id="绘画艺术">绘画艺术</h3>
<ul>
<li>绘画艺术：创造 “虚拟” 世界的影像
<ul>
<li>抽象型、表意型、写实型</li>
</ul></li>
<li>能否通过计算机自动生成？</li>
</ul>
<h3 id="图像成像的原理">图像成像的原理</h3>
<ul>
<li>光与物体的相互作用</li>
</ul>
<p><img src="/2021/07/22/CG/LLG-GAMES102/00/image-20210723131921992.png" style="zoom: 67%;"></p>
<h3 id="渲染成像">渲染成像</h3>
<ul>
<li>渲染成像：<strong>光</strong>的计算科学</li>
<li>Blinn-Phong 模型</li>
<li>渲染方程</li>
<li>需要知道什么信息？
<ul>
<li>光源、几何、纹理、材质</li>
</ul></li>
</ul>
<h3 id="真实感渲染">真实感渲染</h3>
<ul>
<li>照片级的渲染</li>
</ul>
<h3 id="仿真动画">仿真动画</h3>
<ul>
<li>运动的计算科学</li>
<li>解方程（偏微分方程）
<ul>
<li>欧拉视角</li>
<li>拉格朗日视角</li>
</ul></li>
</ul>
<h3 id="计算机图形学">计算机图形学</h3>
<ul>
<li><strong>创造</strong> “虚拟” 世界</li>
<li>电影《头号玩家》
<ul>
<li>VR 的未来</li>
</ul></li>
</ul>
<h3 id="数据的获取">数据的获取</h3>
<ul>
<li>制作三维数据
<ul>
<li><p>几何数据</p></li>
<li><p>UV 展开</p></li>
<li><p>贴图（纹理）</p></li>
<li><p>材质</p></li>
<li><p>灯光</p></li>
<li><p>动画</p></li>
</ul></li>
<li>几何内容的生成仍然是计算机图形学应用的瓶颈问题之一
<ul>
<li>复杂几何如何表达出来？</li>
</ul></li>
<li>课程目的：怎么构建这些数据</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES102</category>
        <category>0</category>
        <category>CG</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>LLG</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES102.刘利刚.01.数据拟合(Data Fitting)(02)</title>
    <url>/2021/07/23/CG/LLG-GAMES102/01-1/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1NA411E7Yr</li>
</ul>
<h1 id="数据拟合">数据拟合</h1>
<h2 id="函数拟合问题">函数拟合问题</h2>
<ul>
<li>输入：一些观察（采样）的数据点 <span class="math inline">\(\{x_i,y_i\}_{i=0}^n\)</span></li>
<li>输出：你和数据点的函数 <span class="math inline">\(y=f(x)\)</span>，并用于<strong>预测</strong></li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210723165025691.png" alt="image-20210723165053604" style="zoom:80%;"></p>
<ul>
<li><strong>这样的拟合函数有无穷个</strong></li>
</ul>
<h3 id="拟合函数的好坏评价">拟合函数的好坏评价</h3>
<h4 id="分段线性插值函数">分段线性插值函数</h4>
<ul>
<li><span class="math inline">\(y=f_1(x)\)</span></li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210723165151352.png" style="zoom:80%;"></p>
<ul>
<li>数据误差为 0</li>
<li>函数性质不够好
<ul>
<li>只有 <span class="math inline">\(C^0\)</span> 连续，不光滑
<ul>
<li>一阶导数不连续</li>
<li>数值计算很麻烦</li>
</ul></li>
</ul></li>
</ul>
<h4 id="光滑插值函数">光滑插值函数</h4>
<ul>
<li><span class="math inline">\(y=f_2(x)\)</span></li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210723165402251.png" style="zoom:80%;"></p>
<ul>
<li>数据误差为 0</li>
<li>可能被 “差数据” 带歪，导致函数性质不好、预测不可靠
<ul>
<li>噪声，outliers（游离点）</li>
</ul></li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210723165634809.png" style="zoom:80%;"></p>
<h4 id="逼近拟合函数">逼近拟合函数</h4>
<ul>
<li><span class="math inline">\(y=f_3(x)\)</span></li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210723165832341.png" style="zoom:80%;"></p>
<ul>
<li>数据误差不为 0，但是足够小</li>
<li>能够抵抗一些 “差数据” 的影响</li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210723165919053.png" style="zoom:80%;"></p>
<h3 id="选择什么拟合函数">选择什么拟合函数</h3>
<ul>
<li>应用驱动，除非知道数据的先验，找到一个合适的拟合函数时一个比较复杂的过程
<ul>
<li>先验：领域知识</li>
</ul></li>
<li>大部分的实际应用问题
<ul>
<li>可建模为：找一个映射/变换/函数</li>
<li>输入不一样、变量不一样、维数不一样</li>
</ul></li>
<li>三步曲方法论：
<ul>
<li><strong>到哪找？</strong>
<ul>
<li>确定某个函数集合/空间</li>
</ul></li>
<li><strong>找哪个？</strong>
<ul>
<li>度量哪个函数是好的 “最好” 的</li>
</ul></li>
<li><strong>怎么找？</strong>
<ul>
<li>求解或优化：不同的优化方法与技巧，既要快、又要好 ···</li>
</ul></li>
</ul></li>
</ul>
<h3 id="数据拟合的方法论">数据拟合的方法论</h3>
<ul>
<li><strong>到哪找？</strong>
<ul>
<li>确定函数的表达形式（函数集、空间）
<ul>
<li><span class="math inline">\(L=span\{b_0(x),\cdots,b_n(x)\}\)</span></li>
</ul></li>
<li>待定基函数的组合系数（求解变量）
<ul>
<li><span class="math inline">\(f_\lambda(x)=\sum_{k=0}^n\lambda_ib_i(x)\)</span></li>
</ul></li>
</ul></li>
<li><strong>找哪个？</strong>
<ul>
<li>优化模型（最小化问题）
<ul>
<li>能量项 = 误差项 + 正则项</li>
<li>正则项
<ul>
<li><span class="math inline">\(\int
|f&#39;&#39;|^2\;\mathrm{d}x\)</span> 度量光滑性</li>
<li><span class="math inline">\(\int \Vert \nabla
f\Vert\;\mathrm{d}x\)</span> 弧长尽量小</li>
</ul></li>
</ul></li>
<li>统计模型、规划模型 ···</li>
</ul></li>
<li><strong>怎么找？</strong>
<ul>
<li>求解误差函数的驻点（导数为 0 之处）</li>
<li>转化为系数的方程组
<ul>
<li>如果是欠定的（有无穷多组解），则修正模型
<ul>
<li>改进/增加 各种正则项：Lasso、岭回归、系数正则项 ···</li>
<li>返回修改模型</li>
</ul></li>
</ul></li>
<li>如果时非凸的、欠定的则变成难解问题</li>
</ul></li>
</ul>
<h2 id="函数插值定义">函数插值定义</h2>
<ul>
<li><span class="math inline">\(f(x)\)</span> 为定义在区间 <span class="math inline">\([a, b]\)</span> 上的函数，<span class="math inline">\(x_0, x_1,\cdots, x_n\)</span> 为区间上 <span class="math inline">\(n+1\)</span> 个互不相同的点，<span class="math inline">\(\Phi\)</span> 为给定的某一函数类</li>
<li>求 <span class="math inline">\(\Phi\)</span> 上的函数 <span class="math inline">\(\phi(x)\)</span>，满足：</li>
</ul>
<p><span class="math display">\[
\phi(x_i)=f(x_i),\quad i=0,\cdots,n
\]</span></p>
<ul>
<li>则称 <span class="math inline">\(\phi(x)\)</span> 为 <span class="math inline">\(f(x)\)</span> 关于节点 <span class="math inline">\(x_0, x_1,\cdots, x_n\)</span> 在 <span class="math inline">\(\Phi\)</span> 上的插值函数</li>
<li>称 <span class="math inline">\(x_0, x_1,\cdots, x_n\)</span>
为插值节点</li>
<li>称 <span class="math inline">\((x_i, f(x_i))\)</span>为插值点</li>
</ul>
<h2 id="多项式插值">多项式插值</h2>
<h3 id="多项式插值定理">多项式插值定理</h3>
<ul>
<li>若 <span class="math inline">\(x_i\)</span> 两两不同，则对任意给定的
<span class="math inline">\(y_i\)</span>，存在唯一的次数至多是 <span class="math inline">\(n\)</span> 次的多项式 <span class="math inline">\(p_n\)</span>，使得 <span class="math inline">\(p_n(x_i)=y_i,\quad i = 0, \cdots,n\)</span></li>
<li>证明如下：范德蒙德行列式不为 0</li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210723173310958.png" style="zoom:80%;"></p>
<h3 id="技巧1构造插值问题的通用解">技巧1：构造插值问题的通用解</h3>
<ul>
<li>如果每次都需要求解方程组，则比较麻烦</li>
<li><strong>预先</strong>构造插值问题的通用解</li>
<li>给定 <span class="math inline">\(n+1\)</span> 个点 <span class="math inline">\(\{(x_0,y_0),\cdots,(x_n,y_n)\}\)</span>，寻找一组次数为
<span class="math inline">\(n\)</span> 的多项式基函数 <span class="math inline">\(l_i\)</span> 使得</li>
</ul>
<p><span class="math display">\[
l_i(x_j)=\left\{\begin{aligned}
&amp;1,\mathrm{if}\;i=j\\
&amp;0,\mathrm{if}\;i\ne j
\end{aligned}\right.
\]</span></p>
<ul>
<li>插值问题的解为</li>
</ul>
<p><span class="math display">\[
P(x)=y_0l_0(x)+y_1l_1(x)+\cdots+y_nl_n(x)=\sum_{i=0}^{n}y_il_i(x)
\]</span></p>
<h4 id="怎么计算多项式-l_ix">怎么计算多项式 <span class="math inline">\(l_i(x)\)</span></h4>
<ul>
<li><span class="math inline">\(n\)</span> 阶多项式，且有以下 <span class="math inline">\(n\)</span> 个根</li>
</ul>
<p><span class="math display">\[
x_0,x_1,\cdots,x_{i-1},x_{i+1},\cdots,x_n
\]</span></p>
<ul>
<li>故可表示为</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
l_i(x)&amp;=C_i(x-x_0)(x-x_1)\cdots(x-x_{i-1})(x-x_{i+1})\cdots(x-x_n)\\
&amp;=C_i\prod_{i=0\land j\ne i}^{n}(x-x_j)
\end{aligned}
\]</span></p>
<ul>
<li>由 <span class="math inline">\(l_i(x_i)=1\)</span> 可以得到</li>
</ul>
<p><span class="math display">\[
1=C_i\prod_{i=0\land j\ne i}^{n}(x_i-x_j)\Rightarrow
C_i=\dfrac{1}{\prod_{i=0\land j\ne i}^{n}(x_i-x_j)}
\]</span></p>
<ul>
<li>最终的多项式基函数为</li>
</ul>
<p><span class="math display">\[
l_i(x)=\dfrac{\prod_{i=0\land j\ne i}^{n}(x-x_j)}{\prod_{i=0\land j\ne
i}^{n}(x_i-x_j)}
\]</span></p>
<ul>
<li><span class="math inline">\(l_i(x)\)</span>
被称为<strong>拉格朗日多项式</strong></li>
</ul>
<h3 id="技巧2更方便的求解表达">技巧2：更方便的求解表达</h3>
<ul>
<li>Newton 插值：具有相同 “导数”（差商）的多项式构造（n 阶 Taylor
展开）</li>
</ul>
<h4 id="差商定义">差商定义</h4>
<ul>
<li>一阶差商</li>
</ul>
<p><span class="math display">\[
f[x_0,x_1]=\dfrac{f(x_1)-f(x_0)}{x_1-x_0}
\]</span></p>
<ul>
<li>k 阶差商
<ul>
<li>设 <span class="math inline">\(\{x_0,x_1,\cdots,x_n\}\)</span>
互不相同，<span class="math inline">\(f(x)\)</span> 关于 <span class="math inline">\(\{x_0,x_1,\cdots,x_n\}\)</span> 的 k
阶差商如下</li>
</ul></li>
</ul>
<p><span class="math display">\[
f[x_0,\cdots,x_{k}]=\dfrac{f[x_1,\cdots,x_{k}]-f[x_0,\cdots,x_{k-1}]}{x_k-x_0}
\]</span></p>
<ul>
<li>所以 Newton 插值多项式表示为</li>
</ul>
<p><span class="math display">\[
N_n(x)=f(x_0)+f[x_0,x_1](x-x_0)+\cdots+f[x_0,\cdots,x_n](x-x_0)\cdots(x-x_{n-1})
\]</span></p>
<ul>
<li><strong>有一点巧妙</strong></li>
</ul>
<h3 id="多项式插值存在的问题">多项式插值存在的问题</h3>
<ul>
<li>系数矩阵稠密</li>
<li>依赖于基函数选取，矩阵可能病态，导致难于求解（求逆）</li>
</ul>
<h3 id="病态矩阵举例">病态矩阵举例</h3>
<ul>
<li><strong>对于扰动很敏感</strong></li>
<li>对于如下方程组</li>
</ul>
<p><span class="math display">\[
\left\{\begin{aligned}
&amp;x_1+0.5x_2=1.5\\
&amp;0.667x_1+0.333x_2=1\\
\end{aligned}\right.
\Rightarrow
\left\{\begin{aligned}
&amp;x_1=1\\
&amp;x_2=1\\
\end{aligned}\right.
\]</span></p>
<ul>
<li>对等式右边进行扰动 0.001</li>
</ul>
<p><span class="math display">\[
\left\{\begin{aligned}
&amp;x_1+0.5x_2=1.5\\
&amp;0.667x_1+0.333x_2=0.999\\
\end{aligned}\right.
\Rightarrow
\left\{\begin{aligned}
&amp;x_1=0\\
&amp;x_2=3\\
\end{aligned}\right.
\]</span></p>
<ul>
<li>对系数矩阵进行扰动 0.001</li>
</ul>
<p><span class="math display">\[
\left\{\begin{aligned}
&amp;x_1+0.5x_2=1.5\\
&amp;0.667x_1+0.334x_2=1\\
\end{aligned}\right.
\Rightarrow
\left\{\begin{aligned}
&amp;x_1=2\\
&amp;x_2=-1\\
\end{aligned}\right.
\]</span></p>
<h3 id="病态问题">病态问题</h3>
<ul>
<li>输入数据的细微变化导致输出（解）的剧烈变化</li>
<li>将线性方程看成直线（超平面）
<ul>
<li><strong>当系统病态时，直线变为近似平行</strong></li>
<li>求解（即直线求交）变得困难、不精确</li>
</ul></li>
</ul>
<h3 id="矩阵条件数">矩阵条件数</h3>
<ul>
<li>通过矩阵条件数刻画病态程度</li>
</ul>
<p><span class="math display">\[
\kappa_2(A)=\dfrac{\max_{x\ne0}\dfrac{\Vert Ax\Vert}{\Vert
x\Vert}}{\min_{x\ne0}\dfrac{\Vert Ax\Vert}{\Vert x\Vert}}
\]</span></p>
<ul>
<li>等于最大特征值和最小特征值之间比例</li>
<li>条件数大意味着基元之间有太多相关性</li>
</ul>
<h3 id="多项式插值问题是病态的">多项式插值问题是病态的</h3>
<ul>
<li>对于等距分布的数据点 <span class="math inline">\(x_i\)</span>，范德蒙矩阵的条件数随着数据点数 <span class="math inline">\(n\)</span> 呈指数级增长
<ul>
<li>多项式最高次数为 <span class="math inline">\(n-1\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210723200509899.png" style="zoom: 80%;"></p>
<h3 id="幂函数带来的问题">幂函数带来的问题</h3>
<ul>
<li>幂（单项式）函数基
<ul>
<li>幂函数之间差别随着次数增加而减小</li>
<li>不同幂函数之间唯一差别为增长速度（<span class="math inline">\(x^i\)</span> 比 <span class="math inline">\(x^{i-1}\)</span> 增长快）</li>
</ul></li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210723200713694.png" style="zoom: 33%;"></p>
<ul>
<li>单项式
<ul>
<li>从左往右</li>
<li>首先常数 1 主宰</li>
<li>接着 <span class="math inline">\(x\)</span> 增长最快</li>
<li>接着 <span class="math inline">\(x^2\)</span> 增长最快</li>
<li>···</li>
</ul></li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210723200834022.png" style="zoom:33%;"></p>
<ul>
<li>趋势
<ul>
<li><strong>好的基函数一般需要系数交替</strong></li>
<li>互相抵消问题</li>
</ul></li>
</ul>
<h3 id="解决方法">解决方法</h3>
<ul>
<li>使用正交多项式基</li>
<li>如何获得？
<ul>
<li>Gram‐Schmidt 正交化</li>
</ul></li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210723201104228.png" style="zoom:33%;"></p>
<h3 id="多项式插值结果">多项式插值结果</h3>
<ul>
<li>振荡（龙格 Runge）现象和对插值点数的高度敏感性</li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210723201206658.png" style="zoom: 33%;"></p>
<h3 id="结论">结论</h3>
<ul>
<li>多项式插值不稳定
<ul>
<li>控制点的微小变化可导致完全不同的结果</li>
</ul></li>
<li>振荡（Runge）现象
<ul>
<li>多项式随着插值点数（可以是细微）增加而摆动</li>
</ul></li>
<li>需要更好的基函数来做插值
<ul>
<li>Bernstein 基函数</li>
<li>分片多项式</li>
</ul></li>
</ul>
<h2 id="多项式逼近">多项式逼近</h2>
<h3 id="为什么逼近">为什么逼近</h3>
<ul>
<li>数据点含噪声、outliers 等</li>
<li>更紧凑的表达</li>
<li>计算简单、更稳定</li>
</ul>
<h3 id="最小二乘逼近">最小二乘逼近</h3>
<h4 id="逼近问题">逼近问题</h4>
<ul>
<li>给定一组线性无关的连续函数集合 <span class="math inline">\(B=\{b_1,\cdots,b_n\}\)</span> 和一组节点 <span class="math inline">\(\{(x_1,y_1),\cdots,(x_m,y_m)\}\)</span>
<ul>
<li>其中 <span class="math inline">\(m\ge n\)</span></li>
</ul></li>
<li>在 B 张成空间中那个函数 <span class="math inline">\(f\in
span\{B\}\)</span> 对节点的逼近最好</li>
<li>示例：给定一组点，找到最佳逼近的线性函数</li>
<li>怎么定义 “最佳逼近”？</li>
</ul>
<h4 id="最小二乘逼近-1">最小二乘逼近</h4>
<p><span class="math display">\[
\mathop{\arg\min}_{f\in span\{B\}}\sum_{j=1}^{m}\Big(f(x_j)-y_j\Big)^2
\]</span></p>
<ul>
<li>系数 <span class="math inline">\(\lambda_1,\cdots,\lambda_n\)</span></li>
</ul>
<p><span class="math display">\[
M=\left(
\begin{aligned}
b_1(x_1)\quad&amp;\cdots\quad b_n(x_1)\\
\cdots\quad&amp;\cdots\quad\cdots\\
b_1(x_n)\quad&amp;\cdots\quad b_n(x_n)\\
\end{aligned}
\right)
\]</span></p>
<ul>
<li>转化</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\sum_{j=1}^{m}\Big(f(x_j)-y_j\Big)^2&amp;=\sum_{j=1}^{m}\Big(\sum_{i=1}^{n}\lambda_ib_i(x_j)-y_j\Big)^2\\
&amp;=(M\lambda-y)^T(M\lambda-y)\\
&amp;=\lambda^TM^TM\lambda-y^TM\lambda-\lambda^TM^Ty+y^Ty\\
&amp;=\lambda^TM^TM\lambda-2y^TM\lambda+y^Ty
\end{aligned}
\]</span></p>
<h4 id="求解">求解</h4>
<ul>
<li>怎么求 <span class="math inline">\(\lambda\)</span></li>
<li>关于 <span class="math inline">\(\lambda\)</span> 的二次多项式</li>
</ul>
<p><span class="math display">\[
\lambda^TM^TM\lambda-2y^TM\lambda+y^Ty
\]</span></p>
<ul>
<li>法方程，最小解满足
<ul>
<li>求导即可</li>
</ul></li>
</ul>
<p><span class="math display">\[
M^TM\lambda=y^TM
\]</span></p>
<ul>
<li>转化为最小化二次目标函数
<ul>
<li>最小化二次目标函数 <span class="math inline">\(x^TAx+b^Tx+c\)</span></li>
<li>充要条件：<span class="math inline">\(2Ax=-b\)</span></li>
</ul></li>
</ul>
<h2 id="函数空间及基函数">函数空间及基函数</h2>
<h3 id="为什么用多项式">为什么用多项式</h3>
<ul>
<li>易于计算，表现良好，光滑</li>
<li>稠密性与完备性
<ul>
<li><strong>表达能力足够</strong></li>
<li>维尔斯特拉斯定理 （Weierstrass）</li>
</ul></li>
</ul>
<h4 id="维尔斯特拉斯定理">维尔斯特拉斯定理</h4>
<ul>
<li>令 <span class="math inline">\(f\)</span> 为闭区间 <span class="math inline">\([a,b]\)</span> 上的任意连续函数，则对任意给定的
<span class="math inline">\(\epsilon\)</span>，存在 <span class="math inline">\(n\)</span> 会让多项式 <span class="math inline">\(P_n\)</span> 满足</li>
</ul>
<p><span class="math display">\[
\vert f(x)-P_n(x) \vert&lt;\epsilon,\forall x\in[a,b]
\]</span></p>
<ul>
<li>定理只证明了存在性，未给出多项式</li>
<li>实际应用中 <span class="math inline">\(n\)</span>
需要通过尝试确定</li>
</ul>
<h3 id="伯恩斯坦多项式">伯恩斯坦多项式</h3>
<ul>
<li>用 Bernstein 多项式做逼近</li>
<li>对 <span class="math inline">\([0,1]\)</span> 区间上任意连续函数
<span class="math inline">\(f(x)\)</span> 和任意正整数 <span class="math inline">\(n\)</span>，以下不等式对所有的 <span class="math inline">\(x\in[0,1]\)</span> 成立</li>
</ul>
<p><span class="math display">\[
\vert f(x)-B_n(f,x) \vert&lt;\dfrac{9}{4}m_{f,n}
\]</span></p>
<ul>
<li><span class="math inline">\(m_{f,n}\)</span> 如下</li>
</ul>
<p><span class="math display">\[
m_{f,n}=\mathrm{lower\;upper\;bound}\vert f(y_1)-f(y_2)\vert
\]</span></p>
<p><span class="math display">\[
y_1,y_2\in[0,1]\land\vert y_1-y_2\vert&lt;\dfrac{1}{\sqrt{n}}
\]</span></p>
<ul>
<li><span class="math inline">\(B_n(f,x)\)</span> 如下，其中 <span class="math inline">\(x_j=\dfrac{j}{n}\)</span> 为 <span class="math inline">\([0,1]\)</span> 上的等距采样点</li>
</ul>
<p><span class="math display">\[
B_n(f,x)=\sum_{j=0}^{n}f(x_j)b_{n,j}(x)
\]</span></p>
<ul>
<li><strong>伯恩斯坦多项式</strong>如下</li>
</ul>
<p><span class="math display">\[
b_{n,j}={n\choose j}x_j(1-x)^{n-j}
\]</span></p>
<ul>
<li>不同次数的伯恩斯坦多项式的基空间</li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210724215909989.png" style="zoom: 50%;"></p>
<ul>
<li><strong>矩阵：不同的基函数空间的变换</strong></li>
</ul>
<h4 id="用-bernstein-多项式做逼近">用 Bernstein 多项式做逼近</h4>
<ul>
<li>Bernstein 基函数的良好性质：非常好的几何意义！
<ul>
<li>正性、权性（和为1）<span class="math inline">\(\to\)</span> 凸包性
<ul>
<li><span class="math inline">\(b_{n,j}&gt;0\)</span>（非边界）</li>
<li><span class="math inline">\(\sum_{j} b_{n,j}(x)=1\)</span></li>
</ul></li>
<li>变差缩减性</li>
<li>递归线性求解方法</li>
<li>细分性</li>
<li>···</li>
</ul></li>
<li>Bernstein多项式逼近示例
<ul>
<li>逼近结果优秀</li>
<li>需要高阶</li>
</ul></li>
<li>丰富的理论：CAGD 课程（计算机辅助几何设计）</li>
</ul>
<h4 id="bernstein-函数">Bernstein 函数</h4>
<p><span class="math display">\[
B_n(f,x)=\sum_{j=0}^{n}f(\dfrac{j}{n})b_{n,j}(x)
\]</span></p>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210724220750863.png" style="zoom:67%;"></p>
<ul>
<li>蓝色为采样点，红色线为 Bernstein 多项式拟合出来的结果</li>
<li>当 <span class="math inline">\(n\to\infty\)</span>，即采样点足够多的时候，<span class="math inline">\(B_n(f,x)\)</span> 一致收敛到 <span class="math inline">\(f(x)\)</span></li>
</ul>
<h5 id="两种观点">两种观点</h5>
<ul>
<li>代数观点
<ul>
<li>权性</li>
<li>把 <span class="math inline">\(f(\dfrac{i}{n})\)</span>
看作是一系列的点，<span class="math inline">\(b_{n,f}(x)\)</span>
对其进行加权，得到新的点</li>
</ul></li>
<li>几何观点
<ul>
<li><span class="math inline">\(b_{n,f}(x)\)</span>
是一系列的函数，使用系数 <span class="math inline">\(f(\dfrac{i}{n})\)</span>
去组合它，得到新的函数</li>
</ul></li>
<li>这两种观点可以用于之后的交互式设计控制顶点、曲线的设计</li>
</ul>
<h2 id="rbf-函数插值逼近">RBF 函数插值/逼近</h2>
<ul>
<li>低维中叫高斯函数</li>
</ul>
<h3 id="高斯函数">高斯函数</h3>
<ul>
<li>Gauss</li>
<li>两个参数：均值 <span class="math inline">\(\mu\)</span>，方差 <span class="math inline">\(\sigma\)</span></li>
</ul>
<p><span class="math display">\[
g_{\mu,\sigma}(x)=\dfrac{1}{\sqrt{2\pi}}\;\exp\left(-\dfrac{(x-\mu)^2}{2\sigma^2}\right)
\]</span></p>
<ul>
<li>几何意义
<ul>
<li><span class="math inline">\(\mu\)</span>：位置</li>
<li><span class="math inline">\(\sigma\)</span>：支集宽度</li>
</ul></li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210724221807136.png" style="zoom: 50%;"></p>
<ul>
<li>标准高斯函数</li>
</ul>
<p><span class="math display">\[
g_{0,1}=\dfrac{1}{\sqrt{2\pi}}\;\exp\left(-\dfrac{x^2}{2}\right)
\]</span></p>
<ul>
<li><strong>不同均值和方差的高斯函数都线性无关</strong>
<ul>
<li>可以作为一组基函数</li>
</ul></li>
</ul>
<h3 id="rrf-函数拟合">RRF 函数拟合</h3>
<ul>
<li>RBF 函数</li>
</ul>
<p><span class="math display">\[
f(x)=b_0+\sum_{i=1}^{n}b_ig_i(x)
\]</span></p>
<ul>
<li>一个通用的方法
<ul>
<li>给定一些采样点，在这些采样点的周围放置一些基函数</li>
<li>待定系数，求导得出结果</li>
</ul></li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210724222650560.png" style="zoom:67%;"></p>
<ul>
<li>一些问题
<ul>
<li>需要人为选取 <span class="math inline">\(\mu,\sigma\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210724222841841.png" style="zoom: 67%;"></p>
<ul>
<li>怎么控制选取 <span class="math inline">\(\mu,\sigma\)</span>
<ul>
<li>能否将 <span class="math inline">\(\sigma,\mu\)</span> 一起来优化？
<ul>
<li>可以的</li>
</ul></li>
</ul></li>
</ul>
<h2 id="从另一个角度来看拟合函数">从另一个角度来看拟合函数</h2>
<h3 id="guass-拟合函数">Guass 拟合函数</h3>
<ul>
<li>一般 Gauss 函数表达为标准 Gauss 函数的形式</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
g_{\mu,\sigma}(x)&amp;=\dfrac{1}{\sqrt{2\pi}}\;\exp\left(-\dfrac{(x-\mu)^2}{2\sigma^2}\right)\\
&amp;=\dfrac{1}{\sqrt{2\pi}}\;\exp\left(-\dfrac{1}{2}\left(\dfrac{x}{\sigma}-\dfrac{\mu}{\sigma}\right)^2\right)\\
&amp;=g_{0,1}(\dfrac{1}{\sigma}x-\dfrac{\mu}{\sigma})\\
&amp;=g_{0,1}(ax+b)\\
\end{aligned}
\]</span></p>
<ul>
<li>将上面的函数进行转化
<ul>
<li>此时可以同时优化 <span class="math inline">\(\mu,\sigma\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
f(x)=b_0+\sum_{i=1}^{n}b_ig_i(x)
\]</span></p>
<p><span class="math display">\[
f(x)=\omega_0+\sum_{i=1}^{n}\omega_ig_{0,1}(a_ix+b_i)
\]</span></p>
<ul>
<li><p>基函数是由一个基本函数通过平移和伸缩变换而来的</p></li>
<li><p>理论上可以证明：<span class="math inline">\(a_i,b_i\)</span>
足够多，上述多项式也能逼近所有的函数</p></li>
</ul>
<h3 id="换个方式看函数神经网络">换个方式看函数：神经网络</h3>
<ul>
<li>将Gauss函数看成网络
<ul>
<li><span class="math inline">\((x,1)\)</span>
是齐次坐标的用法，可以把平移也结合进去</li>
</ul></li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210724224553825.png" style="zoom: 80%;"></p>
<ul>
<li>这就是 RBF 网络</li>
<li><span class="math inline">\(n\)</span>
对应隐层结点个数，激活函数是标准高斯函数</li>
</ul>
<h4 id="抽象神经元">抽象：神经元</h4>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210724225121760.png" style="zoom:80%;"></p>
<h4 id="rbf-神经网络">RBF 神经网络</h4>
<ul>
<li>高维情形：RBF (Radial Basis Function)，径向基函数</li>
<li>一种特殊的 BP 网络
<ul>
<li>优化：BP 算法
<ul>
<li>反向传播</li>
</ul></li>
</ul></li>
<li>核函数思想</li>
<li>Gauss 函数的特性：拟局部性</li>
<li>求 <span class="math inline">\(a_i,b_i\)</span>时候需要求导，结果是非线性非凸的，很难求出极值
<ul>
<li>落入局部极值</li>
<li>初值选取很重要</li>
</ul></li>
<li>神经网络就是一个函数</li>
</ul>
<h4 id="思考激活函数的选择">思考：激活函数的选择</h4>
<ul>
<li>启发：由一个简单的函数通过（仿射）变换构造出一组基函数，张成一个函数空间</li>
<li>表达能力是否足够强：是否完备/稠密的？</li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210724225813266.png" style="zoom: 40%;"></p>
<h4 id="高维情形多元函数">高维情形：多元函数</h4>
<ul>
<li>每一个神经元的输入是 <span class="math inline">\((x_1,\cdots,x_n)\)</span> 的齐次坐标 <span class="math inline">\((x_1,\cdots,x_n,1)\)</span>
<ul>
<li>变量的多个分量的线性组合： <span class="math inline">\(g_{0,1}(a_i^1x_1+\cdots+a_n^ix_n+b_i)\)</span></li>
</ul></li>
<li>单隐层神经网络函数</li>
</ul>
<p><span class="math display">\[
f(x_1,\cdots,x_n)=\omega_0+\sum_{i=1}^{n}w_ig_{0,1}(a_i^1x_1+\cdots+a_n^ix_n+b_i)
\]</span></p>
<h4 id="多层神经网络">多层神经网络</h4>
<ul>
<li>单层</li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210725105959363.png" style="zoom:80%;"></p>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210725110010791.png" style="zoom:80%;"></p>
<ul>
<li>多层
<ul>
<li>线性函数和非线性函数的多重复合</li>
</ul></li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210725105814720.png" style="zoom: 80%;"></p>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210725105856303.png" style="zoom:80%;"></p>
<h4 id="用神经网络函数来拟合数据">用神经网络函数来拟合数据</h4>
<ul>
<li>回归问题</li>
<li>Regression problem:
<ul>
<li>Input: Given training set (x1, y1), (x2, y2), (x3, y3 ),...</li>
<li>Output: Adjust parameters <span class="math inline">\(\theta\)</span> (for every node) to make: <span class="math inline">\(h(x_i)\approx y_i\)</span></li>
</ul></li>
</ul>
<h4 id="万能逼近定理自由度足够多">万能逼近定理：自由度足够多</h4>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210725110327544.png" style="zoom:80%;"></p>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01-1/image-20210725110252080.png" style="zoom:80%;"></p>
<ul>
<li>与传统拟合一样存在同样的问题：函数个数如何选?
<ul>
<li><strong>调参</strong></li>
</ul></li>
</ul>
<h4 id="使用深度学习的方法">使用深度学习的方法</h4>
<ul>
<li>问题建模
<ul>
<li>理解问题、问题分解（多个映射级联）、…</li>
</ul></li>
<li>找哪个？
<ul>
<li>损失函数、各种 Penalty、正则项、…</li>
</ul></li>
<li>到哪找？
<ul>
<li>神经网络函数、网络简化、···</li>
</ul></li>
<li>怎么找？
<ul>
<li>优化方法（BP方法）</li>
<li>初始值、参数、···</li>
</ul></li>
<li>调参：有耐心、有直觉、···</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES102</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>LLG</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES102.刘利刚.01.数据拟合(Data Fitting)</title>
    <url>/2021/07/23/CG/LLG-GAMES102/01/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1NA411E7Yr</li>
</ul>
<h1 id="数据拟合">数据拟合</h1>
<h2 id="数学基础">数学基础</h2>
<ul>
<li>科学研究过程
<ul>
<li>问题 <span class="math inline">\(\to\)</span> 模型、算法、代码</li>
</ul></li>
<li>数学语言：抽象的思维</li>
</ul>
<h3 id="集合">集合</h3>
<ul>
<li>集合</li>
<li>基数</li>
<li>有限集、无限集</li>
<li>可数集、不可数集</li>
<li>集合运算：并、交、差</li>
</ul>
<h3 id="线性空间">线性空间</h3>
<ul>
<li>元素之间有运算：加法、数乘</li>
<li>线性结构：对加法和数乘封闭
<ul>
<li>加法交换律、结合律，数乘分配律，···</li>
</ul></li>
<li>基 / 维数：<span class="math inline">\(L=span\{V_1,V_2,\cdots,V_n\}=\{\sum_{i}^{n}a_iV_i\vert
a_i\in R\}\)</span>
<ul>
<li>每个元素表达为 n 个实数，即一个向量 <span class="math inline">\((a_1,a_2,\cdots,a_n)\)</span></li>
</ul></li>
<li>例子
<ul>
<li>欧氏空间：1D实数、2D平面、3D空间、···</li>
<li>n 次多项式：<span class="math inline">\(f(x)=\sum_{k=0}^{n}a_kx^k\)</span></li>
</ul></li>
</ul>
<h3 id="映射">映射</h3>
<ul>
<li>两个非空集合 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 的映射 <span class="math inline">\(f:A\to B\)</span>
<ul>
<li>对 <span class="math inline">\(A\)</span> 中的任何一个元素 <span class="math inline">\(a\)</span>，有唯一的一个 <span class="math inline">\(B\)</span> 中的元素 <span class="math inline">\(b\)</span> 与之对应，记为 <span class="math inline">\(f(a)=b\)</span></li>
<li><span class="math inline">\(b\)</span> 称为 <span class="math inline">\(a\)</span> 的象，<span class="math inline">\(a\)</span> 称为 <span class="math inline">\(b\)</span> 的原象</li>
<li><span class="math inline">\(A\)</span> 称为定义域，<span class="math inline">\(\{b\vert\exists a\in A(f(a)=b)\}\)</span>
称为值域</li>
</ul></li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01/image-20210723134200919.png" style="zoom: 80%;"></p>
<h3 id="函数">函数</h3>
<ul>
<li>非空实数集之间的映射称为（一元）函数 <span class="math inline">\(y=f(x)\)</span>，或变换
<ul>
<li><span class="math inline">\(f:R^1\to R^1\)</span></li>
</ul></li>
<li>函数的图像（可视化）：所有的有序数对 <span class="math inline">\((x,y)\)</span> 组成的集合</li>
</ul>
<h3 id="函数的集合">函数的集合</h3>
<ul>
<li>函数空间</li>
<li>用若干简单函数（“基函数”）线性组合张成一个函数空间</li>
<li><span class="math inline">\(L=span\{f_1,f_2,\cdots,f_n\}=\{\sum_{i}^{n}a_if_i(x)\vert
a_i\in R\}\)</span></li>
<li>每个函数就表达（对应）为 n 个实数，即系数向量 <span class="math inline">\((a_1,a_2,\cdots,a_n)\)</span></li>
<li>多项式函数空间（幂基）</li>
</ul>
<p><span class="math display">\[
f(x)=\sum_{k=0}^{n}w_kx^k
\]</span></p>
<ul>
<li>三角函数空间（三角函数基）</li>
</ul>
<p><span class="math display">\[
f(x)=a_0+\sum_{k=1}^{n}(a_k\cos kx+b_k\sin kx)
\]</span></p>
<ul>
<li>函数空间的<strong>完备性</strong>
<ul>
<li>这个函数空间是否可以表示（逼近）<strong>任意函数</strong></li>
</ul></li>
<li>泛函分析</li>
</ul>
<h3 id="赋范空间">赋范空间</h3>
<ul>
<li>内积诱导范数、距离</li>
</ul>
<p><span class="math display">\[
\langle f,g\rangle=\int_{a}^{b}f(x)g(x)\;\mathrm{d}x
\]</span></p>
<ul>
<li>度量空间：可度量函数之间的距离
<ul>
<li>Lp 范数</li>
</ul></li>
<li>赋范空间 + 完备性 = 巴拿赫空间</li>
<li>内积空间（无限维）+ 完备性 = 希尔伯特空间</li>
</ul>
<h3 id="万能逼近定理">万能逼近定理</h3>
<ul>
<li>Weierstrass 逼近定理
<ul>
<li>定理1：闭区间上的连续函数可用多项式级数一致逼近</li>
<li>定理2：闭区间上周期为 <span class="math inline">\(2\pi\)</span>
的连续函数可用三角函数级数一致逼近</li>
</ul></li>
</ul>
<h3 id="傅里叶级数">傅里叶级数</h3>
<p><span class="math display">\[
f(t)=A_0+\sum_{n=1}^{n}(a_n\cos(n\omega t)+b_k\sin(n\omega t))
\]</span></p>
<p><span class="math display">\[
f(t)=A_0+\sum_{n=1}^{n}(A_n\sin(n\omega t+\psi_n))
\]</span></p>
<h3 id="函数复合">函数复合</h3>
<p><span class="math display">\[
f=f_k\circ f_{k-1}\circ\cdots\circ f_0
\]</span></p>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01/image-20210723140657754.png" style="zoom:67%;"></p>
<h3 id="如何求满足要求的函数">如何求满足要求的函数</h3>
<ul>
<li>大部分的实际应用问题
<ul>
<li>可建模为：找一个映射/变换/函数</li>
<li>输入不一样、变量不一样、维数不一样</li>
</ul></li>
<li><strong>如何找函数的三步曲</strong>
<ul>
<li>到哪找？
<ul>
<li>确定某个函数集合/空间</li>
</ul></li>
<li>找哪个？
<ul>
<li>度量哪个函数是好的/“最好”的</li>
</ul></li>
<li>怎么找？
<ul>
<li>求解或优化：不同的优化方法与技巧，既要快、又要好</li>
</ul></li>
</ul></li>
</ul>
<h4 id="逆向工程">逆向工程</h4>
<ul>
<li>求船型曲线</li>
<li>已知：某条船的侧面投影曲线图</li>
<li>求：该投影轮廓线的表达函数？</li>
<li>方法
<ul>
<li>从投影曲线上描（采样）一系列点</li>
<li>找一个函数拟合这些采样点</li>
</ul></li>
</ul>
<h4 id="曲线-曲面拟合">曲线 / 曲面拟合</h4>
<ul>
<li>输入：一些型值（采样）点集</li>
<li>输出：一条拟合这些点集的曲线 / 曲面</li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01/image-20210723141055412.png" style="zoom: 67%;"></p>
<h2 id="函数拟合">函数拟合</h2>
<h3 id="拟合问题">拟合问题</h3>
<ul>
<li>输入：一些观察的数据点</li>
<li>输出：反映这些数据规律的函数 <span class="math inline">\(y=f(x)\)</span>
<ul>
<li>暂时限制 <span class="math inline">\(x\in R^1,y\in R^1\)</span></li>
</ul></li>
<li>拟合问题三部曲：到哪找、找哪个、怎么找</li>
</ul>
<h4 id="到哪找">(1) 到哪找</h4>
<ul>
<li>选择一个函数空间
<ul>
<li>线性函数空间 <span class="math inline">\(A=span\{B_0(x),\cdots,B_n(x)\}\)</span>
<ul>
<li>多项式函数</li>
<li>RBF 函数</li>
<li>三角函数</li>
</ul></li>
</ul></li>
<li>函数表达</li>
</ul>
<p><span class="math display">\[
f(x)=\sum_{k=0}^{n}a_kB_k(x)
\]</span></p>
<ul>
<li>确定 <span class="math inline">\(n+1\)</span> 个系数 <span class="math inline">\((a_0,\cdots,a_k)\)</span>
<ul>
<li>待定系数法</li>
</ul></li>
</ul>
<h4 id="找哪个">(2) 找哪个</h4>
<ul>
<li>确定一个损失函数（目标）</li>
</ul>
<h5 id="插值">[1] 插值</h5>
<ul>
<li>函数经过每个数据点</li>
<li><strong>零误差</strong></li>
</ul>
<h5 id="逼近">[2] 逼近</h5>
<ul>
<li>函数尽量靠近数据点</li>
<li>例如：平方和误差（比较好求解）</li>
</ul>
<p><span class="math display">\[
\min\sum_{i=0}^{n}(y_i-f(x_i))^2
\]</span></p>
<h4 id="怎么找">(3) 怎么找</h4>
<h5 id="插值-1">[1] 插值</h5>
<ul>
<li>联立求解线性方程组</li>
</ul>
<p><span class="math display">\[
y_i=f(x_i)=\sum_{i=0}^{n}a_kB_k(x_i),\qquad i=0,1,\cdots,n
\]</span></p>
<ul>
<li>求解 <span class="math inline">\((n+1)\times(n+1)\)</span>
线性方程组</li>
<li><span class="math inline">\(n\)</span> 次拉格朗日插值多项式</li>
<li>病态问题
<ul>
<li>系数矩阵条件数高时，求解不稳定</li>
</ul></li>
</ul>
<h6 id="n-阶拉格朗日插值多项式">n 阶拉格朗日插值多项式</h6>
<ul>
<li>插值 n+1 个点、次数不超过 n 的多项式是存在而且是唯一的
<ul>
<li>n+1个变量，n+1个方程</li>
</ul></li>
<li>插值函数的自由度 = 未知量个数 - 已知量个数</li>
</ul>
<h5 id="逼近-1">[2] 逼近</h5>
<p><span class="math display">\[
\min\sum_{i=0}^{n}(y_i-f(x_i))^2
\]</span></p>
<ul>
<li><strong>最小二乘法</strong></li>
<li>对各系数求导，得到一个线性方程组（法方程 normal equation）</li>
<li><span class="math inline">\(AX=b\)</span></li>
<li>实际应用一般都是使用逼近的方法，采集到的数据可能会有误差</li>
<li>问题：怎么选择多项式次数是一个比较难的问题
<ul>
<li>点多，系数少：表达能力不够</li>
<li>点少，系数多：过拟合</li>
</ul></li>
</ul>
<h3 id="插值-vs-逼近">插值 vs 逼近</h3>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01/image-20210723144613806.png" style="zoom:67%;"></p>
<h3 id="过拟合与欠拟合">过拟合与欠拟合</h3>
<ul>
<li>过拟合（overfitting）
<ul>
<li>交叉验证</li>
</ul></li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01/image-20210723144753396.png" style="zoom: 50%;"></p>
<ul>
<li>欠拟合</li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01/image-20210723144909245.png" style="zoom:67%;"></p>
<ul>
<li>需要根据不同的应用与需求，不断尝试（不断 “调参”）</li>
</ul>
<h4 id="避免过拟合的常用方法">避免过拟合的常用方法</h4>
<ul>
<li>数据去噪
<ul>
<li>剔除训练样本中噪声</li>
</ul></li>
<li>数据增广
<ul>
<li>增加样本数，或者增加样本的代表性和多样性
<ul>
<li>让采样可能性小的点也能够被采到</li>
</ul></li>
</ul></li>
<li>模型简化
<ul>
<li>预测模型过于复杂，拟合了训练样本中的噪声</li>
<li>选用更简单的模型，或者对模型进行裁剪</li>
</ul></li>
<li>正则约束
<ul>
<li>适当的正则项，比如方差正则项、稀疏正则项</li>
</ul></li>
</ul>
<h3 id="正则项">正则项</h3>
<h4 id="岭回归正则项">岭回归正则项</h4>
<ul>
<li>选择一个函数空间
<ul>
<li>基函数的线性表达</li>
<li><span class="math inline">\(W=(w_0,w_1,\cdots,w_n)\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
y=f(x)=\sum_{i=0}^{n}w_iB_i(x)
\]</span></p>
<ul>
<li>最小二乘拟合</li>
</ul>
<p><span class="math display">\[
\min_{W}\Vert Y-XW\Vert^2
\]</span></p>
<ul>
<li>Ridge regression （岭回归）</li>
</ul>
<p><span class="math display">\[
\min_{W}\Vert Y-XW\Vert^2+\mu\Vert W\Vert_2^2
\]</span></p>
<ul>
<li>让回归问题变得更加稳定</li>
</ul>
<h4 id="稀疏学习稀疏正则化">稀疏学习：稀疏正则化</h4>
<ul>
<li>冗余基函数（过完备）</li>
<li>通过优化来选择合适的基函数
<ul>
<li>系数向量的 <span class="math inline">\(L_0\)</span>
模（非0元素个数）尽量小
<ul>
<li><strong>让选择的基函数越少越好</strong></li>
</ul></li>
<li>挑选（“学习”）出合适的基函数</li>
</ul></li>
<li>两种等价表示形式</li>
</ul>
<p><span class="math display">\[
\min_{\alpha}\Vert Y-XW\Vert^2+\mu\Vert W\Vert_0
\]</span></p>
<p><span class="math display">\[
\min_{\alpha}\Vert Y-XW\Vert^2,\quad s.t.\;\Vert W\Vert_0\le\beta
\]</span></p>
<h4 id="压缩感知">压缩感知</h4>
<ul>
<li><span class="math inline">\(M &lt;&lt; N\)</span></li>
</ul>
<p><img src="/2021/07/23/CG/LLG-GAMES102/01/image-20210723150906247.png"></p>
<ul>
<li>已知 <span class="math inline">\(y\)</span> 和 <span class="math inline">\(\Phi\)</span> ，有无穷多解 <span class="math inline">\(x\)</span></li>
<li>对于<strong>稀疏信号</strong> <span class="math inline">\(x\)</span>，可通过优化能完全重建 <span class="math inline">\(x\)</span>
<ul>
<li>在一定条件下（<span class="math inline">\(\Phi\)</span>）[Candes and
Tao 2005]</li>
</ul></li>
<li><span class="math inline">\(L_0\)</span> 优化</li>
</ul>
<p><span class="math display">\[
\min\Vert x\Vert_0,\quad s.t.\;\Phi x=y
\]</span></p>
<h2 id="思考">思考</h2>
<ul>
<li>非函数型的曲线拟合
<ul>
<li>分段（怎么保证连接点光滑）</li>
</ul></li>
<li>高维函数的拟合</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES102</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>LLG</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES102.刘利刚.03.三次样条函数</title>
    <url>/2021/08/16/CG/LLG-GAMES102/03/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1NA411E7Yr</li>
</ul>
<h1 id="三次样条函数">三次样条函数</h1>
<h2 id="几何设计">几何设计</h2>
<ul>
<li>发动机的曲面设计，很巧妙
<ul>
<li>高速旋转</li>
<li>减小阻力、出风量大</li>
</ul></li>
<li>几何设计
<ul>
<li>传统的概念更多指的是 “外形设计”</li>
</ul></li>
<li>概念设计
<ul>
<li>先由艺术家绘制草图，然后根据草图计算数学表达</li>
</ul></li>
</ul>
<p><img src="/2021/08/16/CG/LLG-GAMES102/03/image-20210816152659298.png" style="zoom:80%;"></p>
<ul>
<li>设计图纸
<ul>
<li>双视图 / 三视图</li>
</ul></li>
</ul>
<p><img src="/2021/08/16/CG/LLG-GAMES102/03/image-20210816152820010.png" style="zoom:80%;"></p>
<ul>
<li>计算机出现以后
<ul>
<li>三维设计：三维 CAD</li>
</ul></li>
<li>从设计到数学（几何）表达</li>
</ul>
<h2 id="计算机出现之前的设计过程">计算机出现之前的设计过程</h2>
<ul>
<li>把设计图画出来</li>
</ul>
<p><img src="/2021/08/16/CG/LLG-GAMES102/03/image-20210816153115701.png" style="zoom: 40%;"></p>
<p><img src="/2021/08/16/CG/LLG-GAMES102/03/image-20210816153127113.png" style="zoom:40%;"></p>
<ul>
<li>放样方法
<ul>
<li>沿着艺术家画出来的曲线描点（关键点），</li>
</ul></li>
</ul>
<p><img src="/2021/08/16/CG/LLG-GAMES102/03/image-20210816153412573.png"></p>
<p><img src="/2021/08/16/CG/LLG-GAMES102/03/image-20210816153433900.png" style="zoom:40%;"></p>
<ul>
<li>样条与压铁
<ul>
<li>样条：具有一定弹性的软木条（可以弯折）</li>
<li>压铁：较重的铁块，用来固定样条所经过的点</li>
</ul></li>
</ul>
<p><img src="/2021/08/16/CG/LLG-GAMES102/03/image-20210816153908522.png"></p>
<ul>
<li>样条所形成的曲线的数学表达
<ul>
<li>通过描出来的关键点，拟合出曲线</li>
</ul></li>
</ul>
<h2 id="自由曲线">自由曲线</h2>
<ul>
<li>在产品初始设计阶段，描述其外形的曲线或曲面常常只有大致形状或只知道它通过一些空间点列（称为型值点），这类没有数学表达式的曲线或曲面称为<strong>自由曲线</strong>或<strong>自由曲面</strong>（Free
formcurve/surface）</li>
<li>造型方法
<ul>
<li>拟合(fitting)</li>
<li>插值(interpolation)</li>
<li>逼近(approximation)</li>
</ul></li>
<li>自由曲线造型的特点
<ul>
<li>参数形式的向量函数</li>
<li><strong>分段多项式</strong>表示</li>
<li>满足一定的连续阶</li>
<li>光顺（光滑、顺眼）</li>
</ul></li>
</ul>
<h2 id="三次样条函数-1">三次样条函数</h2>
]]></content>
      <categories>
        <category>CG.GAMES102</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>LLG</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES102.刘利刚.02.参数曲线拟合</title>
    <url>/2021/08/15/CG/LLG-GAMES102/02/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1NA411E7Yr</li>
</ul>
<h1 id="参数曲线拟合">参数曲线拟合</h1>
<h2 id="一元函数">一元函数</h2>
<ul>
<li><span class="math inline">\(y=f(x)\)</span>
<ul>
<li><span class="math inline">\(f:R^1\to R^1\)</span></li>
</ul></li>
<li>数据拟合的方法
<ul>
<li>三步曲：到哪找、 找哪个、怎么找</li>
</ul></li>
<li>到哪找
<ul>
<li>确定某个函数集合（“池子”），具有某种结构容易表达（比如线性函数空间），且尽量广泛（<strong>表达能力强</strong>）</li>
</ul></li>
<li>找哪个
<ul>
<li>度量哪个函数是好的/ “最好”
的，定义<strong>损失函数</strong>，包括<strong>数据误差项</strong>（逼近数据的度量）与<strong>正则项</strong>（对函数性质的度量）</li>
</ul></li>
<li>怎么找
<ul>
<li><strong>优化求解</strong>：不同的优化方法与技巧
<ul>
<li>线性问题：解线性方程或线性方程组</li>
<li>非线性问题：
<ul>
<li>凸问题：有理论保证</li>
<li>非凸问题：难！数值求解（ 梯度下降法、牛顿法、拟牛顿法、L‐BFGS,
···），须选择合适初值、步长等；一般要根据具体的优化问题形式及特点来设计合适的优化方法！
<ul>
<li>很难找到全局的最值</li>
<li>蚁群算法、遗传算法、模拟退火算法、···</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="多元函数">多元函数</h2>
<ul>
<li><p>多个变量的函数</p></li>
<li><p><span class="math inline">\(y=f(x_1,x_2,\cdots,x_n)\)</span></p>
<ul>
<li><span class="math inline">\(f:R^n\to R^1\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{pmatrix}
x_1\\
\cdots\\
x_n\\
\end{pmatrix}
\to y
\]</span></p>
<ul>
<li>一个二元函数的例子
<ul>
<li><span class="math inline">\(z=f(x,y),(x,y)\in[0,1]\times[0,1]\)</span></li>
<li>升维可视化：<span class="math inline">\(\Big(x,y,f(z,y)\Big)\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210815222015691.png" style="zoom:67%;"></p>
<ul>
<li>三元函数可视化则变得困难
<ul>
<li>升维则是四维</li>
</ul></li>
<li>高维函数不容易直观看到结果</li>
</ul>
<h2 id="二元多元函数的基函数构造">二元/多元函数的基函数构造</h2>
<h3 id="张量积">张量积</h3>
<ul>
<li><strong>张量积形式</strong>
<ul>
<li>即用两个一元函数的<strong>基函数</strong>的相互乘积来定义</li>
</ul></li>
<li>例如：<strong>二次二元多项式函数</strong> <span class="math inline">\(z=f(x,y)\)</span> 的基函数 <span class="math inline">\(\{1,x,y,x^2,xy,y^2\}\)</span></li>
</ul>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210815222438224.png" style="zoom:67%;"></p>
<ul>
<li>拟合的方法和之前相似，就是拟合上面各个项的系数</li>
<li><strong>也可以使用其他的基函数，不一定是多项式基函数</strong></li>
<li>三次二元多项式函数
<ul>
<li>取次数不超过 <span class="math inline">\(3\)</span>
的，和上面一样画三角形</li>
</ul></li>
</ul>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210815222710829.png" style="zoom:67%;"></p>
<ul>
<li>两个方向的基函数也可以不同
<ul>
<li>但是这样处理起来比较麻烦</li>
<li>使用相同的基函数称为<strong>共享基函数</strong>，方便计算处理</li>
</ul></li>
</ul>
<h4 id="张量积评价">张量积评价</h4>
<ul>
<li>优点
<ul>
<li>定义简单，多个一元基函数的乘积形式</li>
</ul></li>
<li>不足
<ul>
<li>随着维数增加，基函数个数急剧增加，导致变量急剧增加</li>
<li>（求解系统规模急剧增加，求解代价大）</li>
<li><span class="math inline">\(O(\dfrac{n^2}{2})\)</span></li>
</ul></li>
</ul>
<h3 id="多元函数的神经网络表达">多元函数的神经网络表达</h3>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210815224035636.png" style="zoom:67%;"></p>
<ul>
<li>用一个单变量函数 <span class="math inline">\(\sigma(x)\)</span>
（称为激活函数）的不同仿射变换来构造
“基函数”：<strong>基函数数目可控</strong></li>
<li>维数由中间结点数目的个数决定
<ul>
<li>梯度下降 + 链式法则</li>
<li>反向传播算法</li>
</ul></li>
<li>存在的问题
<ul>
<li>中间结点个数选择：过拟合 / 欠拟合</li>
</ul></li>
<li>多层网络结构
<ul>
<li>多隐层</li>
</ul></li>
<li>把 n 维空间的一个点转化到 m
维空间的一个点（还可以进行变换），这样可能可以让这些点的分布散开</li>
<li>神经网络的本质就是进行函数拟合</li>
<li>卷积、池化
<ul>
<li>一些特殊的操作</li>
<li>共用参数、降维</li>
</ul></li>
</ul>
<h2 id="向量值函数">向量值函数</h2>
<ul>
<li>多个应变量</li>
</ul>
<h3 id="单变量">单变量</h3>
<ul>
<li><span class="math inline">\(f:R^1\to R^m\)</span></li>
</ul>
<p><span class="math display">\[
x\to
\begin{pmatrix}
y_1\\
\cdots\\
y_m\\
\end{pmatrix}
\]</span></p>
<ul>
<li>看成<strong>多个单变量函数</strong>，<strong>各个函数独立无关</strong>
<ul>
<li>在某些情况下，可能要求函数之间有一些相关性</li>
<li>一般会用同样的基函数（<strong>共享基函数</strong>）
<ul>
<li>结构一样，但是系数是不一样的</li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{lr}
y_1=f_1(x)\\
\cdots\\
y_m=f_m(x)\\
\end{array}
\right.
\]</span></p>
<ul>
<li>几何解释
<ul>
<li>一个实数 <span class="math inline">\(x\in R^1\)</span> 映射到 m
维空间 <span class="math inline">\(R^m\)</span> 的一个点，轨迹构成 <span class="math inline">\(R^m\)</span> 的一条 “曲线”</li>
<li>本质维度（本征维度）为 1
<ul>
<li>嵌入空间是 <span class="math inline">\(m\)</span> 维的</li>
<li>曲线的本质维度为 1</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210815231453148.png" style="zoom:67%;"></p>
<h3 id="特例平面参数曲线">特例：平面参数曲线</h3>
<ul>
<li><span class="math inline">\(f:R^1\to R^2\)</span></li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{**lr**}
x=x(t)\\
y=y(t)\\
\end{array}
\right.
t\in[0,1]
\]</span></p>
<ul>
<li>几何解释：
<ul>
<li>一条曲线由一个变量参数 <span class="math inline">\(t\)</span>
决定，也称为<strong>单参数曲线</strong></li>
<li>参数 <span class="math inline">\(t\)</span> 可看成该曲线的 “时间”
变量</li>
<li>可灵活表达<strong>非函数型</strong>的曲线（<strong>任意曲线</strong>）</li>
</ul></li>
</ul>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210816090642687.png" style="zoom:67%;"></p>
<h3 id="特例空间参数曲线">特例：空间参数曲线</h3>
<ul>
<li><span class="math inline">\(f:R^1\to R^3\)</span></li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{**lr**}
x=x(t)\\
y=y(t)\\
z=z(t)\\
\end{array}
\right.
t\in[0,1]
\]</span></p>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210815232021522.png" style="zoom:67%;"></p>
<h3 id="特例参数曲面">特例：参数曲面</h3>
<ul>
<li><span class="math inline">\(f:R^2\to R^3\)</span></li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{**lr**}
x=x(u,v)\\
y=y(u,v)\\
z=z(u,v)\\
\end{array}
\right.
(u,v)\in[0,1]\times[0,1]
\]</span></p>
<ul>
<li>几何解释
<ul>
<li>一张曲面由两个参数 u，v 决定，也称为<strong>双参数曲面</strong></li>
<li>可灵活表达<strong>非函数型的任意曲面</strong></li>
</ul></li>
</ul>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210816091105602.png" style="zoom:67%;"></p>
<ul>
<li><strong>流形</strong>
<ul>
<li>只是位于三维空间中的一层，称为<strong>流形</strong></li>
<li>虽然处在三维空间中，本质上是二维的</li>
</ul></li>
<li>流形：任何一个点，其周围无穷小的区域等价于平面的一个圆盘</li>
</ul>
<h3 id="特例二维映射">特例：二维映射</h3>
<ul>
<li><span class="math inline">\(f:R^2\to R^2\)</span></li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{**lr**}
x=x(u,v)\\
y=y(u,v)\\
\end{array}
\right.
(u,v)\in[0,1]\times[0,1]
\]</span></p>
<ul>
<li>几何解释
<ul>
<li>二维区域之间的映射</li>
<li>可看成特殊的曲面（第三个维度始终为0）</li>
<li>应用：图像变形</li>
</ul></li>
</ul>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210816092739345.png" style="zoom:67%;"></p>
<h3 id="特例三维映射">特例：三维映射</h3>
<ul>
<li><span class="math inline">\(f:R^3\to R^3\)</span></li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{**lr**}
x=x(u,v,w)\\
y=y(u,v,w)\\
z=z(u,v,w)\\
\end{array}
\right.
(u,v,w)\in[0,1]^3
\]</span></p>
<ul>
<li>几何解释：
<ul>
<li>三维体区域之间的映射</li>
<li>应用：<strong>体形变</strong>、<strong>体参数化</strong></li>
</ul></li>
</ul>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210816092929659.png" style="zoom:67%;"></p>
<ul>
<li>有限元方法</li>
</ul>
<h3 id="特例降维映射低维投影">特例：降维映射（低维投影）</h3>
<ul>
<li>降维映射一般有信息丢失
<ul>
<li>丢失的信息大部分情况下不可逆，即无法恢复</li>
</ul></li>
</ul>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210816093431605.png" style="zoom:67%;"></p>
<ul>
<li>AE：AutoEncoder 自编码器
<ul>
<li>先映射到低维度，再映射到高维度</li>
<li>要求<strong>中间层的最低维度</strong>不能低于<strong>原始的本征维度</strong>，否则无法复原</li>
</ul></li>
</ul>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210816094656909.png" style="zoom:67%;"></p>
<h3 id="一般映射">一般映射</h3>
<ul>
<li><span class="math inline">\(f:R^m\to R^n\)</span></li>
<li>如果 <span class="math inline">\(n&lt;m\)</span>
，为低维到高维的映射（高维的超曲面，n 维流形曲面），<strong>本征维度为
<span class="math inline">\(n\)</span></strong></li>
<li>如果 <span class="math inline">\(n&gt;m\)</span>，为降维映射
<ul>
<li>一般信息有损失</li>
<li>如果 <span class="math inline">\(R^n\)</span> 中的点集刚好位于一个 m
维（或小于 m）的流形上，则映射可能是无损的，即可以被恢复的</li>
</ul></li>
</ul>
<h4 id="低维空间之间的函数">低维空间之间的函数</h4>
<ul>
<li>课程主要集中讨论橙色部分</li>
</ul>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210816101907497.png" style="zoom: 33%;"></p>
<h2 id="曲线拟合">曲线拟合</h2>
<h3 id="曲线拟合问题">曲线拟合问题</h3>
<ul>
<li>非函数型</li>
<li>输入：给定平面上系列点 <span class="math inline">\((x_i,y_i),i=1,2,\cdots,n\)</span></li>
<li>输出：一条参数曲线，拟合这些点
<ul>
<li><span class="math inline">\(f:R^1\to R^2\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{**lr**}
x=x(t)\\
y=y(t)\\
\end{array}
\right.
t\in[0,1]
\]</span></p>
<ul>
<li>如果使用之前单变量的拟合方法，看成两个函数，用 <span class="math inline">\(x_i\)</span> 去拟合 <span class="math inline">\(x(t)\)</span>，需要找到点对 <span class="math inline">\((t_i,x_i)\)</span>
<ul>
<li>然而并没有这些点对，不能简单的这么做</li>
<li>现在相当于需要找每一个点对应的 <span class="math inline">\(t_i\)</span>
<ul>
<li><strong>参数化</strong></li>
</ul></li>
</ul></li>
</ul>
<h4 id="转换">转换</h4>
<ul>
<li>问题：对数据点 <span class="math inline">\((x_i,y_i)\)</span>，对应哪个参数 <span class="math inline">\(t_i\)</span>？</li>
<li>矢量符号化表达</li>
</ul>
<p><span class="math display">\[
\mathbf{p}=\mathbf{p}(t)=
\begin{pmatrix}
x(t)\\
y(t)\\
\end{pmatrix}
\]</span></p>
<ul>
<li>误差度量</li>
</ul>
<p><span class="math display">\[
E=\sum_{i=1}^{n}
\left\Vert
\begin{pmatrix}
x(t)\\
y(t)\\
\end{pmatrix}
-
\begin{pmatrix}
x_i\\
y_i\\
\end{pmatrix}
\right\Vert^2
=
\sum_{i=1}^{n}
\left\Vert
\mathbf{p}(t)-\mathbf{p_i}
\right\Vert^2
\]</span></p>
<h3 id="参数化问题">参数化问题</h3>
<ul>
<li>求数据点所对应的参数：一个降维的问题</li>
</ul>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210816142815840.png" style="zoom:67%;"></p>
<ul>
<li>使用一组基函数（共享基函数）</li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{**lr**}
x=x(t)=\sum(a_iB_i(t))\\
y=y(t)=\sum(b_iB_i(t))\\
\end{array}
\right.
t\in[0,1]
\]</span></p>
<ul>
<li>然后极小化误差度量：<span class="math inline">\(E\)</span></li>
</ul>
<p><span class="math display">\[
E=\sum_{i=1}^{n}\left\Vert\mathbf{p}(t)-\mathbf{p_i}\right\Vert^2
\]</span></p>
<h3 id="点列的参数化">点列的参数化</h3>
<ul>
<li>Equidistant (uniform) parameterization
<ul>
<li><span class="math inline">\(t_{i+1}-t_{i}\)</span> 为常数 const
<ul>
<li>起始点为 0，终止点为 1</li>
<li>中间的点均匀划分，例如 n 个点，<span class="math inline">\(t_i=\dfrac{i}{n}\)</span></li>
</ul></li>
<li>Geometry of the data points is not
considered（没有考虑数据的信息）</li>
</ul></li>
<li>Chordal parameterization
<ul>
<li><span class="math inline">\(t_{i+1}-t_{i}=\Vert\mathbf{k}_{i+1}-\mathbf{k}_i\Vert\)</span>
<ul>
<li>按照弦长去分配</li>
<li>可以归一化到 <span class="math inline">\([0,1]\)</span> 之间</li>
</ul></li>
<li>Parameter intervals proportional to the distances of neighbored
control points
<ul>
<li>区间和弦长成正比</li>
</ul></li>
</ul></li>
<li>Centripetal parameterization
<ul>
<li><span class="math inline">\(t_{i+1}-t_{i}=\sqrt{\Vert\mathbf{k}_{i+1}-\mathbf{k}_i\Vert}\)</span></li>
</ul></li>
<li>Foley parameterization
<ul>
<li>Involvement of angles in the control
polygon（考虑边之间的夹角）</li>
</ul></li>
</ul>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210816144057450.png" style="zoom:67%;"></p>
<h3 id="例子">例子</h3>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210816144444605.png" style="zoom:67%;"></p>
<ul>
<li>点的参数化对曲线拟合的影响很大，需要好的参数化</li>
</ul>
<h2 id="曲面的参数化">曲面的参数化</h2>
<ul>
<li>三维的点找二维的参数：一个降维的问题</li>
</ul>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210816144905788.png" style="zoom:67%;"></p>
<ul>
<li>好的参数化：保持邻域内的几何结构</li>
</ul>
<h3 id="应用">应用</h3>
<ul>
<li>地图绘制（地理学）</li>
</ul>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210816145003788.png" style="zoom:67%;"></p>
<ul>
<li>纹理映射
<ul>
<li>uv 图</li>
</ul></li>
</ul>
<p><img src="/2021/08/15/CG/LLG-GAMES102/02/image-20210816145325370.png" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>CG.GAMES102</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>LLG</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES104.王希.00.课程介绍</title>
    <url>/2022/03/30/CG/WX-GAMES104/00/</url>
    <content><![CDATA[<h1 id="课程介绍">课程介绍</h1>
<ul>
<li>GAMES104：现代游戏引擎：从入门到实践</li>
<li><a href="https://games104.boomingtech.com/sc/">课程主页</a></li>
<li>授课老师：王希</li>
<li>视频地址：<a href="https://space.bilibili.com/512313464/channel/collectiondetail?sid=292637">B站</a></li>
</ul>
<h2 id="内容">内容</h2>
<ul>
<li><strong>Pilot Engine</strong></li>
<li>本课程将介绍现代游戏引擎所涉及的系统架构，技术点，引擎系统相关的知识</li>
<li>通过该课程，你能够对游戏引擎建立起一个全面且完整的了解</li>
<li>如果你动手能力足够强，你将能够跟随课程，从 0 到 1
搭建起一个完整的迷你游戏引擎</li>
<li>本课程适合相关专业领域的学生、研究者，以及所有对游戏引擎设计和开发感兴趣的人</li>
</ul>
]]></content>
      <categories>
        <category>0</category>
        <category>CG.GAMES104</category>
        <category>CG</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WX</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES104.王希.01.游戏引擎导论</title>
    <url>/2022/03/30/CG/WX-GAMES104/01/</url>
    <content><![CDATA[<p><a href="https://space.bilibili.com/512313464/channel/collectiondetail?sid=292637">Bilibili
课程链接</a></p>
<h1 id="游戏引擎导论">游戏引擎导论</h1>
<ul>
<li>Overview of Game Engine</li>
<li>王希：<strong>不鸣科技</strong></li>
</ul>
<h2 id="算法-vs-系统">算法 vs 系统</h2>
<ul>
<li>写算法 <span class="math inline">\(\to\)</span> 做系统</li>
<li>将算法集成到系统中</li>
<li>算法大家都会，但是如何做出一个好的系统</li>
<li>Game：Miracle of Modern Computer Technology</li>
<li>游戏引擎：The Diamond on the Crown</li>
</ul>
<h2 id="游戏引擎的应用">游戏引擎的应用</h2>
<ul>
<li>虚拟人（MetaHuman）</li>
<li>影视行业（Cinematic &amp; Animation）
<ul>
<li>离线渲染</li>
<li>在线，可以在现场调整光照</li>
</ul></li>
<li>模拟（simulation）
<ul>
<li>战争模拟</li>
</ul></li>
<li>数字孪生（Digital Town）
<ul>
<li>无人驾驶汽车，90% 的场景都是在虚拟系统中跑的</li>
</ul></li>
</ul>
<h2 id="游戏引擎的历史">游戏引擎的历史</h2>
<ul>
<li>红白机
<ul>
<li>FC（Famicon）</li>
<li>魂斗罗、马里奥 ······</li>
<li>没有游戏引擎的概念</li>
<li>如何在存储限制的条件下做出游戏
<ul>
<li>各种技巧用于减少存储容量</li>
</ul></li>
</ul></li>
<li>游戏引擎之父：John Carmark
<ul>
<li>写游戏的时候很多代码能够重用 <span class="math inline">\(\to\)</span> 游戏引擎</li>
<li>Wolfenstein 3D（1992）
<ul>
<li>德军总部 3D</li>
<li>FPS 游戏始祖</li>
<li>First-person Shooting game
<ul>
<li>第一人称视角射击游戏</li>
</ul></li>
</ul></li>
<li>Doom
<ul>
<li>毁灭战士</li>
<li>这个游戏的核心代码变成了游戏引擎，授权给了要另外的公司，做了另一款游戏
ShadowCaster
<ul>
<li>在商业上成功了！</li>
<li>算是第一款游戏引擎，但是这个时候更多的知识代码的复用</li>
</ul></li>
</ul></li>
</ul></li>
<li>Quake
<ul>
<li>经典的射击对战游戏</li>
<li>Quake 的引擎
<ul>
<li>提供了 3D 的渲染</li>
<li>早期的显卡 3D 加速（OpenGL）</li>
</ul></li>
<li>一部分原因：<strong>显卡出现了</strong></li>
</ul></li>
<li>硬件的发展推动了游戏引擎的进步
<ul>
<li>同时也让游戏引擎系统变得更加复杂</li>
</ul></li>
<li>现在的游戏引擎如下</li>
</ul>
<h3 id="游戏引擎">游戏引擎</h3>
<p><img src="/2022/03/30/CG/WX-GAMES104/01/image-20220330232038252.png"></p>
<ul>
<li>游戏大厂一般都有自己的游戏引擎
<ul>
<li>EA（Electronic Arts）：Frostbite Engine（寒霜引擎）</li>
<li>育碧（Ubisoft）：
<ul>
<li>UBIart Framework</li>
<li>雪花莲引擎（Snowdrop Engine）</li>
<li>铁砧（Anvil）
<ul>
<li>刺客信条</li>
</ul></li>
</ul></li>
<li>V 社（Valve）：起源引擎（source）</li>
</ul></li>
<li>开源免费的引擎：轻量级、2D</li>
<li>商业引擎：功能更加完善、系统级别</li>
</ul>
<h3 id="中间件">中间件</h3>
<ul>
<li>Middlewares</li>
</ul>
<p><img src="/2022/03/30/CG/WX-GAMES104/01/image-20220330233439112.png" style="zoom:80%;"></p>
<ul>
<li>物理模拟、声音、渲染、植被场景生成</li>
<li>中间件公司寿命都不长hhh，但是在游戏引擎生态中很重要</li>
</ul>
<h2 id="什么是游戏引擎">什么是游戏引擎</h2>
<ul>
<li>3 个特点
<ul>
<li>Technology Foundation of Matrix
<ul>
<li>黑客帝国</li>
</ul></li>
<li>Productivity Tools of Creation：
<ul>
<li>生产力的工具，能够通过过游戏引擎实现我们的想象</li>
</ul></li>
<li>Art of Complexity
<ul>
<li>复杂性的艺术，复杂的系统</li>
</ul></li>
</ul></li>
</ul>
<h3 id="组成">组成</h3>
<p><img src="/2022/03/30/CG/WX-GAMES104/01/image-20220330234550622.png" style="zoom:80%;"></p>
<ul>
<li>看得到的
<ul>
<li>渲染系统、动画系统 ······</li>
</ul></li>
<li>看不到的
<ul>
<li>物理碰撞系统、控制系统、网络同步 ······</li>
</ul></li>
<li><strong>游戏引擎不仅仅是渲染</strong></li>
</ul>
<p><img src="/2022/03/30/CG/WX-GAMES104/01/image-20220330234756955.png" style="zoom:80%;"></p>
<h3 id="游戏引擎的挑战">游戏引擎的挑战</h3>
<ul>
<li>有限的资源、算力、带宽</li>
<li>数据传输的延迟</li>
<li>实时性
<ul>
<li>对算法复杂性的要求很高</li>
<li>帧率</li>
</ul></li>
<li>引擎不仅仅是算法，而是一个生产力的工具
<ul>
<li>早期游戏引擎：简单的一个软件</li>
<li>现在的游戏引擎：很多工具链（实现不同功能）
<ul>
<li>面向设计师、艺术家，不仅仅是程序员</li>
</ul></li>
</ul></li>
<li>对程序员的要求
<ul>
<li>引擎二次开发的能力，可扩展性</li>
<li>可协作的能力（团队协作）
<ul>
<li>Nvidia Omniverse</li>
</ul></li>
<li>工具人实锤，服务于设计师</li>
<li>Update the Engine On the Fly
<ul>
<li>在迭代过程中需要保证现有工程的稳定</li>
</ul></li>
</ul></li>
</ul>
<h2 id="如何学习游戏引擎">如何学习游戏引擎</h2>
<ul>
<li><a href="https://github.com/miloyip/game-programmer/">game-programmer</a></li>
</ul>
<p><img src="/2022/03/30/CG/WX-GAMES104/01/image-20220330235623302.png"></p>
<ul>
<li>课程不会细究某个技术点，而是向我们展示整个框架</li>
<li>让我们知道如何去学习，知道什么知识该去寻找什么资料，知道去哪里寻找</li>
<li>方法论的教学</li>
</ul>
<h2 id="课程内容">课程内容</h2>
<ul>
<li>20 节课</li>
<li>Basic Elements
<ul>
<li>游戏引擎的架构</li>
<li>数据的组织与管理</li>
<li>学完之后知道如何下手去看一个游戏引擎的源码</li>
<li><code>Update()</code> 函数</li>
</ul></li>
<li>Rendering（渲染）
<ul>
<li>模型、材质、shader、纹理</li>
<li>光照与阴影</li>
<li>渲染管线
<ul>
<li>deferred rendering、forward rendering</li>
</ul></li>
<li>天空、地形</li>
<li>半透明与透明材质</li>
<li>卡通渲染</li>
<li>可定制的渲染管线</li>
</ul></li>
<li>Animation（动画）
<ul>
<li>动画的基本概念</li>
<li>Animation Structure and Pipeline</li>
<li>如何让设计师能够参与进来</li>
<li>如何交互</li>
</ul></li>
<li>Physics（物理模拟）
<ul>
<li>物理系统的基本概念
<ul>
<li>几何原体</li>
<li>刚体、弹性体、流体</li>
</ul></li>
<li>性能优化</li>
<li>Gameplay Application</li>
</ul></li>
<li>Gameplay
<ul>
<li>事件系统（Event System）</li>
<li>脚本系统（Scripts System）</li>
<li>图形化的驱动（Graph Driven）</li>
<li>编程：设计，写代码、模块化组合都算编程</li>
</ul></li>
<li>Misc. Systems
<ul>
<li>特效系统（Effects）</li>
<li>寻路系统（Navigation）</li>
<li>相机系统（Camera）</li>
</ul></li>
<li>Tool Set（工具链）
<ul>
<li>C++ 反射体系</li>
<li>Data Schema</li>
</ul></li>
<li>Online Gaming（网络）
<ul>
<li><strong>同步与一致性</strong></li>
<li>Lockstep Synchronization</li>
<li>State Synchronization</li>
<li>Consistency</li>
</ul></li>
<li>Advanced Technology
<ul>
<li>Motion Matching</li>
<li>PCG（Procedural Contenct Generation）</li>
<li>DOP（Data-Oriented Programming）</li>
<li>Job System（任务系统），多线程</li>
<li>UE5：Lumen、Nanite</li>
</ul></li>
</ul>
<h2 id="其他">其他</h2>
<ul>
<li>推荐读物
<ul>
<li>Jason Gregroy, “Game Engine Architecture”, 3rd or later
editions</li>
</ul></li>
<li>Mini Engine
<ul>
<li>课程的小引擎</li>
</ul></li>
</ul>
<p><img src="/2022/03/30/CG/WX-GAMES104/01/image-20220331111521220.png" style="zoom:80%;"></p>
<ul>
<li>课程目标
<ul>
<li>能够做出一个简单的<strong>联网对战游戏</strong></li>
</ul></li>
<li><strong>可视化编程</strong>将会是未来的大趋势
<ul>
<li><strong>蓝图</strong></li>
</ul></li>
<li>元宇宙
<ul>
<li>挑战很大</li>
<li>电影：头号玩家（Ready Player One）</li>
</ul></li>
<li>不同游戏引擎总体架构类似，但是会有一些特定领域的优化</li>
<li>ECS（Entity Object System）
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/270927422">漫谈Entity
Component System (ECS)</a></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES104</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WX</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES104.王希.02.引擎架构分层</title>
    <url>/2022/03/31/CG/WX-GAMES104/02/</url>
    <content><![CDATA[<ul>
<li><a href="https://space.bilibili.com/512313464/channel/collectiondetail?sid=292637">Bilibili
课程链接</a></li>
</ul>
<h1 id="引擎架构分层与整体-pipeline">引擎架构分层与整体 pipeline</h1>
<ul>
<li>Layered Architecture of Game Engine</li>
<li>如何开始看游戏引擎的海量代码？</li>
<li>现代游戏引擎的 5 层架构
<ul>
<li>工具层、功能层、资源层、核心层、平台层</li>
<li>第三方库</li>
</ul></li>
</ul>
<h2 id="游戏引擎分层简介">游戏引擎分层简介</h2>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220404231020106.png" style="zoom:80%;"></p>
<h3 id="工具层">工具层</h3>
<ul>
<li>Tool Layer</li>
<li>Chain of Editors</li>
<li>在游戏引擎中，首先看到的是各种各样的编辑器</li>
</ul>
<h3 id="功能层">功能层</h3>
<ul>
<li>Function Layer</li>
<li>让游戏能过够运行起来
<ul>
<li>Make It Visible, Movable and Playable</li>
</ul></li>
<li>动画、渲染、物理系统、脚本、FSM（有限状态自动机）、AI、相机、交互界面、HUD（抬头显视设备）、输入输出</li>
<li>HUD</li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220405130231900.png" style="zoom:80%;"></p>
<h3 id="资源层">资源层</h3>
<ul>
<li>Resource Layer</li>
<li>数据和文件：Data And Files</li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220405130852206.png" style="zoom:80%;"></p>
<h3 id="核心层">核心层</h3>
<ul>
<li>Core Layer</li>
<li>将底层代码封装成核心函数库</li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220405131023605.png" style="zoom:80%;"></p>
<h3 id="平台层">平台层</h3>
<ul>
<li>Platform Layer</li>
<li>兼容不同的平台
<ul>
<li>硬件平台</li>
<li>软件平台</li>
</ul></li>
<li>兼容不同的输入设备</li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220405131147048.png" style="zoom:80%;"></p>
<ul>
<li>不同的输入设备都需要翻译成游戏中的一个统一的语言</li>
</ul>
<h3 id="第三方库">第三方库</h3>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220406223349330.png" style="zoom:80%;"></p>
<ul>
<li>SDK 形式，直接集成到引擎里面，编译的时候就需要编译进去</li>
<li>第三方工具，和游戏引擎的数据交换通过文件形式
<ul>
<li>simplygon：面片简化工具</li>
</ul></li>
</ul>
<h2 id="层架构">5 层架构</h2>
<ul>
<li>如何实现 5 层架构？</li>
<li>如果想实现一个动起来的角色，5 层架构分别要做些什么？</li>
<li>以这个问题为线索，说明各层的作用</li>
</ul>
<h2 id="资源层-1">资源层</h2>
<h3 id="数据引擎化">数据引擎化</h3>
<ul>
<li>拿到了资源之后，怎么样导入使用这些资源？</li>
<li>能不能直接加载？
<ul>
<li>在游戏引擎这么复杂的软件里面，我们不可能去逐个问资源的具体格式</li>
<li>另外，很多软件的数据格式是为了软件好操作而建构的，可能比较复杂，存在很多无效信息，直接加载效率非常低</li>
</ul></li>
<li>会先将资源做一个转换（import），转换成引擎的高效数据，变成资产（asset）</li>
<li>例如图片，我们将可以图片都转成 dds 这种 GPU 友好的图片格式
<ul>
<li>dds：DirectDraw Surface，是 DirectX 纹理压缩（DirectX Texture
Compression，简称 DXTC）的产物</li>
</ul></li>
<li>另外一个例子，word <span class="math inline">\(\to\)</span> txt
<ul>
<li>word 本身提供各种功能，导致文件很大，如果只需要里面的文字，转成
txt，则文件很小</li>
</ul></li>
<li>在预处理之后的 asset，加载和使用都会非常块</li>
</ul>
<h3 id="资产关联">资产关联</h3>
<ul>
<li>composite asset</li>
<li>将不同的资产关联在一起，表明数据之间的关系</li>
<li>GUID：唯一识别号
<ul>
<li>Globally Unique Identifier</li>
<li>为每一个资产设定一个 GUID（类似人的身份证）</li>
</ul></li>
<li>例如如下的资产关联模式</li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220406231307713.png" style="zoom:80%;"></p>
<ul>
<li>通过引用关联</li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220406231356768.png" style="zoom:80%;"></p>
<h3 id="运行时管理">运行时管理</h3>
<ul>
<li>Runtime Asset Manager</li>
<li>一个虚拟的文件系统，通过文件路径来加载/卸载 assets</li>
<li>handle system：管理资产的生命周期、引用</li>
<li>资源的内存管理（<strong>内存是有限的</strong>）</li>
<li>资产的生命周期
<ul>
<li><strong>垃圾回收</strong>（GC）</li>
<li><strong>延迟加载</strong></li>
</ul></li>
<li>在现代游戏引擎架构中，GC 很重要
<ul>
<li>例如关卡切换的时候，如果 GC
没写好，很可能导致卡顿（大量资源的回收和生成）</li>
</ul></li>
<li>延迟加载：边玩边加载</li>
</ul>
<h2 id="功能层-1">功能层</h2>
<h3 id="tick">Tick</h3>
<ul>
<li>如何让角色动起来？</li>
<li><em>tick</em></li>
<li>在每一个 <em>tick</em> 时间，执行一遍所有操作</li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220406230653182.png" style="zoom:80%;"></p>
<ul>
<li>游戏每一帧的逻辑如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">tickLogic</span>(deltaTime);</span><br><span class="line">    <span class="built_in">tickRender</span>(deltaTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220406231518503.png" style="zoom:80%;"></p>
<ul>
<li>不管渲染还是不渲染，游戏世界中的时间都是向前推进的（事件都是在发生的）</li>
<li>logic 和 render 在代码是线上需要分开，不能混在一起
<ul>
<li>本身做的就是两件事</li>
</ul></li>
<li>功能层很复杂，为游戏本身提供了很多功能模块</li>
<li>游戏中的循环周期性的更新系统的状态</li>
<li>游戏和游戏引擎关系复杂
<ul>
<li>有些模块到底是该位于游戏还是游戏引擎说不清楚</li>
<li>例如某个游戏可能需要有相机摇晃的感觉，这个功能应该是游戏还是游戏引擎呢？</li>
<li>一个评论：业务与底层的关系，但是业务可以沉到底层实现复用</li>
</ul></li>
<li>有些功能是很清晰的属于游戏引擎的
<ul>
<li>绘制、pipeline、资产管理</li>
</ul></li>
</ul>
<h3 id="多线程">多线程</h3>
<ul>
<li>多种架构</li>
<li>入门级实现
<ul>
<li>Entry（Fixed Thread）：某个线程只做固定的事</li>
</ul></li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220406232847663.png" style="zoom:80%;"></p>
<ul>
<li>主流架构
<ul>
<li>Mainstream（Thread Fork/Join）</li>
<li>将一些容易并行的计算使用多线程实现</li>
</ul></li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220406232931885.png" style="zoom:80%;"></p>
<ul>
<li>未来游戏引擎的实现
<ul>
<li>Advanced（JOB System）</li>
</ul></li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220406233107813.png" style="zoom:80%;"></p>
<ul>
<li>多线程的问题
<ul>
<li>需要处理数据依赖</li>
</ul></li>
<li>未来的引擎架构一定是多核的</li>
</ul>
<h2 id="核心层-1">核心层</h2>
<h3 id="数学库">数学库</h3>
<ul>
<li>变换</li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220406233408505.png" style="zoom:80%;"></p>
<ul>
<li>为什么要抽象成一个库？
<ul>
<li>追求效率</li>
<li><span class="math inline">\(\dfrac{1}{\sqrt{x}}\)</span>：Quake-III
实现如下
<ul>
<li><a href="https://thatonegamedev.com/math/fast-square-root-quake-iii/">解析</a></li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">Q_rsqrt</span><span class="params">( <span class="type">float</span> number )</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">float</span> x2, y;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> threehalfs = <span class="number">1.5F</span>;</span><br><span class="line">    x2 = number * <span class="number">0.5F</span>;</span><br><span class="line">    y  = number;</span><br><span class="line">    i  = * ( <span class="type">long</span> * ) &amp;y;</span><br><span class="line">    i  = <span class="number">0x5f3759df</span> - ( i &gt;&gt; <span class="number">1</span> );</span><br><span class="line">    y  = * ( <span class="type">float</span> * ) &amp;i;</span><br><span class="line">    y  = y * ( threehalfs - ( x2 * y * y ) );</span><br><span class="line">    y  = y * ( threehalfs - ( x2 * y * y ) );</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>SIMD：Single Instruction Multiple Data，单指令流多数据流
<ul>
<li>多个同样的运算同时进行</li>
</ul></li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220406234251685.png" style="zoom:80%;"></p>
<h3 id="数据结构和容器">数据结构和容器</h3>
<ul>
<li>C++ STL 的实现可能不适用于游戏中的应用场景</li>
<li>我们需要设计自己的数据结构，尽可能减少内存碎片，提高访问效率</li>
</ul>
<h3 id="内存管理">内存管理</h3>
<ul>
<li>提高内存使用效率
<ul>
<li>Memory Pool / Allocator</li>
<li>Reduce cache miss</li>
<li>Memory alignment</li>
</ul></li>
<li>Polymorphic Memory Resource (PMR)
<ul>
<li>多态内存分配器</li>
</ul></li>
<li>高效内存管理
<ul>
<li>Put data together：把数据放到一起</li>
<li>Access data in order：访问数据的时候尽可能顺序访问</li>
<li>Allocate and de-allocate as a block：读写的时候尽可能一起去读写</li>
</ul></li>
</ul>
<h3 id="核心层特点">核心层特点</h3>
<ul>
<li>高效的设计与实现</li>
<li>高质量的代码</li>
<li>一般不轻易改动</li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220406235206152.png" style="zoom:80%;"></p>
<h2 id="平台层-1">平台层</h2>
<ul>
<li>平台无关性，掩盖平台的差异，上层调用能够无视平台特征</li>
</ul>
<h3 id="例子">例子</h3>
<ul>
<li>文件路径</li>
<li>渲染引擎
<ul>
<li>Windows：DirectX（DX11、DX12）</li>
<li>MAC：Metal</li>
<li>Android：OpenGLES、Vulkan</li>
<li>重新定义一层 graphics 的 API，隐藏平台特征
<ul>
<li>Render Hardware Interface (RHI)
<ul>
<li>对不同的 GPU 架构和 SDK 都是透明的，隐藏差异</li>
<li>对目标平台及其进行自动优化</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220406235659880.png" style="zoom:80%;"></p>
<ul>
<li>CPU 架构可能都不一样
<ul>
<li>Core variants: PPU and SPUs</li>
<li>UMA: unified memory access</li>
</ul></li>
<li>平台层的设计很影响游戏引擎的效率，一个贴合硬件、指令集的编译能让效率提高很多</li>
</ul>
<h2 id="工具层-1">工具层</h2>
<ul>
<li>逻辑编辑器：蓝图</li>
<li>材质编辑器：保证预览的效果和实际游戏的效果都是一样的</li>
<li>level editor：以地图编辑器为主的各种编辑器</li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220407001323964.png" style="zoom:80%;"></p>
<ul>
<li>工具层是真正生产力的工具，能够实现你的各种想象，允许别人去创造游戏内容</li>
<li>涉及到游戏运行的代码需要注重效率，一般使用 C++ 开发</li>
<li>实现可以有很多灵活的选择，因为只是一个开发工具，和游戏的实时运行无关
<ul>
<li>C++ Qt：开发效率优先</li>
<li>C# WPF：控件</li>
<li>H5</li>
</ul></li>
</ul>
<h3 id="ddc">DDC</h3>
<ul>
<li>Digital Content Creation</li>
<li>Assets Conditioning Pipeline
<ul>
<li>将不同的编辑器生成的资源通过统一的管线导入到我们的引擎中，生成
Assets</li>
<li>就是很多的导入/导出器，实现数据之间的互导
<ul>
<li>通用的数据格式</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220407102823342.png" style="zoom:80%;"></p>
<ul>
<li>工具层 = 我们开发的编辑器 + 资产的导入器/导出器</li>
</ul>
<h2 id="为什么要分层">为什么要分层</h2>
<ul>
<li>解耦（decoupling）和降低复杂度
<ul>
<li>底层实现和上层是无关的</li>
<li>上层不需要知道下层是怎么实现的</li>
</ul></li>
<li>封装</li>
<li>类比于城市</li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220407103456141.png" style="zoom:80%;"></p>
<ul>
<li>一般而言底层的代码不会经常修改，追求稳定
<ul>
<li>修改了可能会影响上层架构</li>
</ul></li>
<li>上层代码为了追求效率、追求新功能经常会修改</li>
<li>越往上层越灵活（customizable），越往下层越稳定（stable）</li>
<li>分层架构是很重要的，清晰的架构，只能允许上层调用下层，不允许下层调用上层
<ul>
<li>设计一个特性的时候，必须先考虑这是需要放在哪一层</li>
</ul></li>
</ul>
<h2 id="pilot">Pilot</h2>
<ul>
<li>课程的 Mini Engine
<ul>
<li>逐步开放</li>
</ul></li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/image-20220407104005734.png" style="zoom:80%;"></p>
<ul>
<li><a href="https://github.com/BoomingTech/Pilot">Github</a></li>
<li>分层架构、支持基本引擎的功能</li>
<li>ECS 架构</li>
</ul>
<p><img src="/2022/03/31/CG/WX-GAMES104/02/A9R8g7g6v_1oufq0p_nw.png" style="zoom: 50%;"></p>
]]></content>
      <categories>
        <category>CG.GAMES104</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WX</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES104.王希.03.如何构建游戏世界</title>
    <url>/2022/04/10/CG/WX-GAMES104/03/</url>
    <content><![CDATA[<ul>
<li><a href="https://space.bilibili.com/512313464/channel/collectiondetail?sid=292637">Bilibili
课程链接</a></li>
</ul>
<h1 id="如何构建游戏世界">如何构建游戏世界</h1>
<ul>
<li>How to Build a Game World</li>
<li>游戏世界由什么组成？</li>
<li>我们如何描述这些东西？</li>
<li>这些东西是如何组织的？</li>
</ul>
<h2 id="游戏世界中的物体">游戏世界中的物体</h2>
<ul>
<li>Dynamic Game Object（动态的游戏物体）
<ul>
<li>移动的 NPC</li>
<li>马</li>
</ul></li>
<li>Static Game Object（静态物）
<ul>
<li>房子</li>
<li>树木</li>
</ul></li>
<li>Environments
<ul>
<li>天空（sky）、地形（terrain）、植被（vegetation）</li>
<li>tod：time of the day</li>
</ul></li>
<li>Other Game Objects
<ul>
<li>空气墙（air wall）</li>
<li>检测体（trigger area）
<ul>
<li>例如巫师三检测玩家走到了世界的尽头</li>
<li>例如玩家走到特定区域才会触发剧情，走到特定区域的检测使用
trigger</li>
</ul></li>
<li>游戏规则</li>
</ul></li>
<li>任何东西都是游戏物体（Game Object）</li>
<li>GO：Game Object
<ul>
<li>将游戏世界中的物体都抽象成 GO</li>
</ul></li>
</ul>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/image-20220410233953487.png" style="zoom:80%;"></p>
<h2 id="如何描述-go">如何描述 GO</h2>
<ul>
<li>属性（property） + 行为（behavior）</li>
</ul>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/image-20220410234248032.png" style="zoom:80%;"></p>
<ul>
<li>继承（inheritance）</li>
</ul>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/image-20220410234438417.png" style="zoom:80%;"></p>
<ul>
<li>问题：当物体变多的时候，父子关系并不明显</li>
<li><strong>组件化</strong>（component base）</li>
</ul>
<h3 id="组件化">组件化</h3>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/image-20220410234637034.png" style="zoom:80%;"></p>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/image-20220410234658392.png" style="zoom:80%;"></p>
<ul>
<li>代码
<ul>
<li><code>tick()</code> 用于更新组件的状态</li>
</ul></li>
</ul>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/image-20220410235613126.png" style="zoom:80%;"></p>
<ul>
<li>无人机组件化</li>
</ul>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/image-20220410234957263.png" style="zoom:80%;"></p>
<ul>
<li>现代游戏引擎架构的理念
<ul>
<li>开发者好维护、好理解</li>
<li>要符合艺术家设计师对于游戏的理解（游戏引擎是生产力工具）</li>
</ul></li>
<li>商业引擎也是基于组件化的设计</li>
<li>unreal
<ul>
<li>这里的 UObject 更像是 java 中的 Object 集类，用于内存管理、GC
之类的（生命周期控制），和我们上面讲的 GO 还有所不同，这里的 AActor
更像是 GO</li>
</ul></li>
</ul>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/unreal.jpg"></p>
<ul>
<li>unity</li>
</ul>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/unity.jpg"></p>
<h2 id="如何让世界动起来">如何让世界动起来</h2>
<h3 id="运动">运动</h3>
<ul>
<li>Object-based Tick</li>
<li>每一个 GO 里面的 component 调用 <code>tick()</code> 进行更新</li>
</ul>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/image-20220411220525108.png" style="zoom:80%;"></p>
<ul>
<li>但是在实际的游戏引擎里面，一般是逐系统
<code>tick()</code>，而不是逐对象 <code>tick()</code>
<ul>
<li>为了效率（pipeline）</li>
<li>一个系统的数据通常放在一起（cache）</li>
</ul></li>
</ul>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/image-20220411220837382.png" style="zoom:80%;"></p>
<ul>
<li>对比</li>
</ul>
<table>
<colgroup>
<col style="width: 45%">
<col style="width: 54%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Object-based tick</th>
<th style="text-align: center;">Component-based tick</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Simple and intuitive<br>Easy to
debug</td>
<td style="text-align: center;">Parallelized processing<br>Reduced
cache miss</td>
</tr>
</tbody>
</table>
<h3 id="交互">交互</h3>
<ul>
<li>GO 之间的交互
<ul>
<li>例如我砍了你一刀，你要受伤</li>
</ul></li>
<li>hardcode
<ul>
<li>效率很低，新加入 GO 则需要修改大量代码</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bomb::explode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span>(go_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> GoType.human_type : &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> GoType.drone_type : &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> GoType.tank_type : &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> GoType.stone_type : &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> : &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>事件机制（event）
<ul>
<li>GO 和 component 的解耦合</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bomb::explode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">sendExplodeEvent</span>(go_id);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>商业引擎中的 event 机制</li>
<li>unity</li>
</ul>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/unity_event.jpg" style="zoom: 50%;"></p>
<ul>
<li>unreal</li>
</ul>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/unreal_event.jpg" style="zoom: 50%;"></p>
<ul>
<li>游戏引擎的工作
<ul>
<li>允许用户定制事件</li>
<li>允许用户在组件中对事件进行处理</li>
</ul></li>
</ul>
<p>总结</p>
<h2 id="如何管理-go">如何管理 GO</h2>
<ul>
<li>GO 的查询
<ul>
<li>通过 GO 的唯一标识（unique game object id）</li>
<li>通过 GO 的位置</li>
</ul></li>
</ul>
<h3 id="场景管理">场景管理</h3>
<ul>
<li>不管理
<ul>
<li>事件发生（例如爆炸），向场景中的所有 GO
都发一遍消息（全都扫描一遍）</li>
<li><span class="math inline">\(n^2\)</span>
的挑战，场景中每个物体都扫描一遍其他物体
<ul>
<li>对于场景中物体不多的情况下，还是可行的</li>
<li>场景中 GO 增加，则带来大量的计算负担</li>
</ul></li>
</ul></li>
<li>Grid
<ul>
<li>只向周围 Grid 进行发送消息</li>
<li>当 GO 在场景中分散的不均匀的时候，又慢又浪费</li>
</ul></li>
</ul>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/image-20220411223454788.png" style="zoom:80%;"></p>
<ul>
<li>四叉树（QuadTree）
<ul>
<li>层级结构</li>
</ul></li>
</ul>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/image-20220411223707121.png" style="zoom:80%;"></p>
<ul>
<li>其他空间数据结构
<ul>
<li>BVH：层次包围盒
<ul>
<li>子弹打中某个物体 <span class="math inline">\(\Longleftrightarrow\)</span> 光线和物体求交</li>
</ul></li>
<li>BSP：空间划分</li>
<li>Octree：八叉树</li>
<li>Scene Graph：场景图</li>
</ul></li>
</ul>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/image-20220411223827832.png" style="zoom:80%;"></p>
<h2 id="总结">总结</h2>
<ul>
<li>Everything is a game object in the game world
<ul>
<li>游戏世界中的所有东西都是 GO</li>
</ul></li>
<li>Game object could be described in the component-based way
<ul>
<li>GO 使用组件化的方式描述</li>
</ul></li>
<li>States of game objects are updated in tick loops
<ul>
<li>GO 的状态通过调用 <code>tick()</code> 进行更新</li>
</ul></li>
<li>Game objects interact with each other via event mechanism
<ul>
<li>GO 之间通过事件机制进行交互</li>
</ul></li>
<li>Game objects are managed in a scene with efficient strategies
<ul>
<li>GO 在场景中使用搞笑的空间数据结构进行管理</li>
</ul></li>
</ul>
<h2 id="其他内容">其他内容</h2>
<h3 id="绑定">绑定</h3>
<ul>
<li>Binding</li>
<li>物体之间的绑定、联动
<ul>
<li>例如你骑上马之后，你和马之间应该有相同的移动</li>
</ul></li>
<li>更新的时候按照父子关系更新
<ul>
<li>先更新父结点，子结点再更新（基于父节点更新）</li>
<li>顺序很重要</li>
</ul></li>
</ul>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/image-20220411225311245.png" style="zoom:80%;"></p>
<h3 id="事件">事件</h3>
<ul>
<li>允许 GO 之间直接通信，可能会导致不一致情况的发生
<ul>
<li>因为 <code>tick()</code>
可能是并行的，并行情况下执行顺序可能会不一致</li>
<li>精彩回放：只是记录了玩家的输入，由于游戏引擎保证了一致性，回放和之前的画面是完全相同的
<ul>
<li>一致性：同样的用户输入，引擎运行之后得到的结果是相同的</li>
</ul></li>
</ul></li>
<li>引入第三方，用于控制时序</li>
</ul>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/image-20220411225235133.png" style="zoom:80%;"></p>
<ul>
<li>解决时序问题
<ul>
<li><code>pre_tick()</code>、<code>post_tick()</code></li>
</ul></li>
</ul>
<h3 id="依赖">依赖</h3>
<ul>
<li>玩家从走路变成跑步，此时速度会变化，如果此时玩家的动作影响了环境（例如腿碰到其他物体），环境会反过来影响玩家的状态</li>
</ul>
<p><img src="/2022/04/10/CG/WX-GAMES104/03/image-20220411225514073.png" style="zoom:80%;"></p>
<ul>
<li>如何更新？
<ul>
<li>变化马上在这一帧更新？下一帧更新？</li>
<li>精妙的设计</li>
</ul></li>
</ul>
<h2 id="qa">QA</h2>
<ul>
<li>一个 <code>tick()</code> 的时间过长怎么办？
<ul>
<li>每一个 <code>tick()</code> 的时候传入步长，补偿计算</li>
<li>跳过一个 <code>tick()</code></li>
<li>更多的是去优化引擎设计
<ul>
<li>例如保证突然产生很多物体，一帧处理不过来，可以分散到相邻几帧去做（人眼看不出来）</li>
</ul></li>
</ul></li>
<li>渲染线程和逻辑线程的同步
<ul>
<li>一般而言，<code>tick_logic()</code>
会更早一点，<code>tick_logic(),tick_render()</code>
二者会放在不同的线程处理</li>
<li><strong>输入延迟</strong>，<code>tick_logic()</code> 比
<code>tick_render()</code> 早了几帧
<ul>
<li><code>frame_buffer</code> 的交换还需要一帧</li>
</ul></li>
<li>如何实时响应是引擎设计中的一个重要问题</li>
</ul></li>
<li>空间划分如何处理动态的 GO
<ul>
<li>BVH 比 BSP 更新效率更高</li>
<li>一般需要引擎支持多种空间划分的数据结构，用于适应不同的应用场景</li>
</ul></li>
<li>组件模式的缺点
<ul>
<li>效率可能比 <code>class</code>
低（为了弥补讲相同组件的数据放到一起，快速更新）</li>
<li>组件之间越需要有通信机制，但是组件之间并不知道对方是否一定存在，因此需要询问，高频的询问会影响效率</li>
</ul></li>
<li>Debug
<ul>
<li>逐帧分析</li>
<li>可视化 debug</li>
<li><code>Log</code></li>
</ul></li>
<li>物理和动画互相影响的时候如何处理？
<ul>
<li>插值过渡：一开始更多地使用定义好的动画，后面一步步转向物理计算的结果</li>
<li>设计感 + 物理真实感</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES104</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WX</tag>
      </tags>
  </entry>
  <entry>
    <title>(PBRT) 阅读笔记.00.说明</title>
    <url>/2021/07/25/CG/PBRT/00/</url>
    <content><![CDATA[<h1 id="介绍">介绍</h1>
<ul>
<li><a href="https://www.pbr-book.org/3ed-2018/contents">PBRT.v3</a></li>
<li>Physically Based Rendering: From Theory To Implementation
<ul>
<li>Matt Pharr, Wenzel Jakob, and Greg Humphreys</li>
<li>第三版</li>
</ul></li>
<li><a href="https://github.com/mmp/pbrt-v3/">源代码</a></li>
</ul>
<h1 id="目录">目录</h1>
<div>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Preface.html">Preface</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Preface/Further_Reading.html">Further
Reading</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Preface_to_the_Online_Edition.html">
Preface to the Online Edition</a>
</li>
<ul style="list-style:none;">
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Introduction.html">1
Introduction</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Introduction/Literate_Programming.html">1.1
Literate Programming</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html">1.2
Photorealistic Rendering and the Ray-Tracing Algorithm</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Introduction/pbrt_System_Overview.html">1.3
pbrt: System Overview</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Introduction/Parallelization_of_pbrt.html">1.4
Parallelization of pbrt</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Introduction/How_to_Proceed_through_This_Book.html">1.5
How to Proceed through This Book</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Introduction/Using_and_Understanding_the_Code.html">1.6
Using and Understanding the Code</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Introduction/A_Brief_History_of_Physically_Based_Rendering.html">1.7
A Brief History of Physically Based Rendering</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Introduction/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Introduction/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Geometry_and_Transformations.html">2
Geometry and Transformations</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Coordinate_Systems.html">2.1
Coordinate Systems</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Vectors.html">2.2
Vectors</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Points.html">2.3
Points</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Normals.html">2.4
Normals</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Rays.html">2.5
Rays</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Bounding_Boxes.html">2.6
Bounding Boxes</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Transformations.html">2.7
Transformations</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Applying_Transformations.html">2.8
Applying Transformations</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Animating_Transformations.html">2.9
Animating Transformations</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Interactions.html">2.10
Interactions</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Shapes.html">3 Shapes</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Shapes/Basic_Shape_Interface.html">3.1
Basic Shape Interface</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Shapes/Spheres.html">3.2
Spheres</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Shapes/Cylinders.html">3.3
Cylinders</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Shapes/Disks.html">3.4
Disks</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Shapes/Other_Quadrics.html">3.5
Other Quadrics</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Shapes/Triangle_Meshes.html">3.6
Triangle Meshes</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Shapes/Curves.html">3.7
Curves</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Shapes/Subdivision_Surfaces.html">3.8
Subdivision Surfaces</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Shapes/Managing_Rounding_Error.html">3.9
Managing Rounding Error</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Shapes/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Shapes/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Primitives_and_Intersection_Acceleration.html">4
Primitives and Intersection Acceleration</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html">4.1
Primitive Interface and Geometric Primitives</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Primitives_and_Intersection_Acceleration/Aggregates.html">4.2
Aggregates</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Primitives_and_Intersection_Acceleration/Bounding_Volume_Hierarchies.html">4.3
Bounding Volume Hierarchies</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Primitives_and_Intersection_Acceleration/Kd-Tree_Accelerator.html">4.4
Kd-Tree Accelerator</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Primitives_and_Intersection_Acceleration/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Primitives_and_Intersection_Acceleration/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Color_and_Radiometry.html">5
Color and Radiometry</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Color_and_Radiometry/Spectral_Representation.html">5.1
Spectral Representation</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Color_and_Radiometry/The_SampledSpectrum_Class.html">5.2
The SampledSpectrum Class</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Color_and_Radiometry/RGBSpectrum_Implementation.html">5.3
RGBSpectrum Implementation</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Color_and_Radiometry/Radiometry.html">5.4
Radiometry</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Color_and_Radiometry/Working_with_Radiometric_Integrals.html">5.5
Working with Radiometric Integrals</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Color_and_Radiometry/Surface_Reflection.html">5.6
Surface Reflection</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Color_and_Radiometry/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Color_and_Radiometry/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Camera_Models.html">6 Camera
Models</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Camera_Models/Camera_Model.html">6.1
Camera Model</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Camera_Models/Projective_Camera_Models.html">6.2
Projective Camera Models</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Camera_Models/Environment_Camera.html">6.3
Environment Camera</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Camera_Models/Realistic_Cameras.html">6.4
Realistic Cameras</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Camera_Models/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Camera_Models/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction.html">7
Sampling and Reconstruction</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Sampling_Theory.html">7.1
Sampling Theory</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Sampling_Interface.html">7.2
Sampling Interface</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Stratified_Sampling.html">7.3
Stratified Sampling</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/The_Halton_Sampler.html">7.4
The Halton Sampler</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/(0,_2)-Sequence_Sampler.html">7.5
(0, 2)-Sequence Sampler</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Maximized_Minimal_Distance_Sampler.html">7.6
Maximized Minimal Distance Sampler</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Sobol_Sampler.html">7.7
Sobol’ Sampler</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Image_Reconstruction.html">7.8
Image Reconstruction</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html">7.9
Film and the Imaging Pipeline</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Reflection_Models.html">8
Reflection Models</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Reflection_Models/Basic_Interface.html">8.1
Basic Interface</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Reflection_Models/Specular_Reflection_and_Transmission.html">8.2
Specular Reflection and Transmission</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Reflection_Models/Lambertian_Reflection.html">8.3
Lambertian Reflection</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Reflection_Models/Microfacet_Models.html">8.4
Microfacet Models</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Reflection_Models/Fresnel_Incidence_Effects.html">8.5
Fresnel Incidence Effects</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Reflection_Models/Fourier_Basis_BSDFs.html">8.6
Fourier Basis BSDFs</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Reflection_Models/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Reflection_Models/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Materials.html">9
Materials</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Materials/BSDFs.html">9.1
BSDFs</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Materials/Material_Interface_and_Implementations.html">9.2
Material Interface and Implementations</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Materials/Bump_Mapping.html">9.3
Bump Mapping</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Materials/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Materials/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Texture.html">10 Texture</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Texture/Sampling_and_Antialiasing.html">10.1
Sampling and Antialiasing</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Texture/Texture_Coordinate_Generation.html">10.2
Texture Coordinate Generation</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Texture/Texture_Interface_and_Basic_Textures.html">10.3
Texture Interface and Basic Textures</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Texture/Image_Texture.html">10.4
Image Texture</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Texture/Solid_and_Procedural_Texturing.html">10.5
Solid and Procedural Texturing</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Texture/Noise.html">10.6
Noise</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Texture/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Texture/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Volume_Scattering.html">11
Volume Scattering</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Volume_Scattering/Volume_Scattering_Processes.html">11.1
Volume Scattering Processes</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Volume_Scattering/Phase_Functions.html">11.2
Phase Functions</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Volume_Scattering/Media.html">11.3
Media</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Volume_Scattering/The_BSSRDF.html">11.4
The BSSRDF</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Volume_Scattering/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Volume_Scattering/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Sources.html">12 Light
Sources</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Sources/Light_Emission.html">12.1
Light Emission</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Sources/Light_Interface.html">12.2
Light Interface</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Sources/Point_Lights.html">12.3
Point Lights</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Sources/Distant_Lights.html">12.4
Distant Lights</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Sources/Area_Lights.html">12.5
Area Lights</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Sources/Infinite_Area_Lights.html">12.6
Infinite Area Lights</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Sources/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Sources/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration.html">13
Monte Carlo Integration</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Background_and_Probability_Review.html">13.1
Background and Probability Review</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/The_Monte_Carlo_Estimator.html">13.2
The Monte Carlo Estimator</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Sampling_Random_Variables.html">13.3
Sampling Random Variables</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Metropolis_Sampling.html">13.4
Metropolis Sampling</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Transforming_between_Distributions.html">13.5
Transforming between Distributions</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/2D_Sampling_with_Multidimensional_Transformations.html">13.6
2D Sampling with Multidimensional Transformations</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Russian_Roulette_and_Splitting.html">13.7
Russian Roulette and Splitting</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Careful_Sample_Placement.html">13.8
Careful Sample Placement</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Bias.html">13.9
Bias</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Importance_Sampling.html">13.10
Importance Sampling</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection.html">14
Light Transport I: Surface Reflection</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Reflection_Functions.html">14.1
Sampling Reflection Functions</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources.html">14.2
Sampling Light Sources</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Direct_Lighting.html">14.3
Direct Lighting</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/The_Light_Transport_Equation.html">14.4
The Light Transport Equation</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Path_Tracing.html">14.5
Path Tracing</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering.html">15
Light Transport II: Volume Rendering</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering/The_Equation_of_Transfer.html">15.1
The Equation of Transfer</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering/Sampling_Volume_Scattering.html">15.2
Sampling Volume Scattering</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering/Volumetric_Light_Transport.html">15.3
Volumetric Light Transport</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering/Sampling_Subsurface_Reflection_Functions.html">15.4
Sampling Subsurface Reflection Functions</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering/Subsurface_Scattering_Using_the_Diffusion_Equation.html">15.5
Subsurface Scattering Using the Diffusion Equation</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_III_Bidirectional_Methods.html">16
Light Transport III: Bidirectional Methods</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_III_Bidirectional_Methods/The_Path-Space_Measurement_Equation.html">16.1
The Path-Space Measurement Equation</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_III_Bidirectional_Methods/Stochastic_Progressive_Photon_Mapping.html">16.2
Stochastic Progressive Photon Mapping</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_III_Bidirectional_Methods/Bidirectional_Path_Tracing.html">16.3
Bidirectional Path Tracing</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_III_Bidirectional_Methods/Metropolis_Light_Transport.html">16.4
Metropolis Light Transport</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_III_Bidirectional_Methods/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Light_Transport_III_Bidirectional_Methods/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Retrospective_and_The_Future.html">17
Retrospective and The Future</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Retrospective_and_The_Future/Design_Retrospective.html">17.1
Design Retrospective</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Retrospective_and_The_Future/Alternative_Hardware_Architectures.html">17.2
Alternative Hardware Architectures</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Retrospective_and_The_Future/Conclusion.html">17.3
Conclusion</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Retrospective_and_The_Future/Further_Reading.html">Further
Reading</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Utilities.html">A
Utilities</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Utilities/Main_Include_File.html">A.1
Main Include File</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Utilities/Image_File_Input_and_Output.html">A.2
Image File Input and Output</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Utilities/Communicating_with_the_User.html">A.3
Communicating with the User</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Utilities/Memory_Management.html">A.4
Memory Management</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Utilities/Mathematical_Routines.html">A.5
Mathematical Routines</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Utilities/Parallelism.html">A.6
Parallelism</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Utilities/Statistics.html">A.7
Statistics</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Utilities/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Utilities/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Scene_Description_Interface.html">B
Scene Description Interface</a>
</li>
<ul style="list-style:none;">
<li>
<a href="https://www.pbr-book.org/3ed-2018/Scene_Description_Interface/Parameter_Sets.html">B.1
Parameter Sets</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Scene_Description_Interface/Initialization_and_Rendering_Options.html">B.2
Initialization and Rendering Options</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Scene_Description_Interface/Scene_Definition.html">B.3
Scene Definition</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Scene_Description_Interface/Adding_New_Object_Implementations.html">B.4
Adding New Object Implementations</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Scene_Description_Interface/Further_Reading.html">Further
Reading</a>
</li>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Scene_Description_Interface/Exercises.html">Exercises</a>
</li>
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/References.html">
References</a>
</li>
<ul style="list-style:none;">
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Index_of_Fragments.html">
Index of Fragments</a>
</li>
<ul style="list-style:none;">
</ul>
<li>
<a href="https://www.pbr-book.org/3ed-2018/Index_of_Identifiers.html">
Index of Identifiers</a>
</li>
<ul style="list-style:none;">
</ul>
</ul>
</div>
]]></content>
      <categories>
        <category>0</category>
        <category>CG.PBRT</category>
        <category>CG</category>
        <category>book.directory</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>PBRT</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学.李胜.00.说明</title>
    <url>/2021/01/26/CG/LS/00/</url>
    <content><![CDATA[<h1 id="说明">1. 说明</h1>
<ul>
<li>李胜老师开设的课程《计算机图形学》学习笔记</li>
</ul>
]]></content>
      <categories>
        <category>0</category>
        <category>CG.LS</category>
        <category>CG</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学.李胜.01.图形学概述</title>
    <url>/2021/01/26/CG/LS/01/</url>
    <content><![CDATA[<ul>
<li><p>4 Minutes for 40 Years_ A Brief Review of Modern Computer
Graphics</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=lEbzFSRZcm0&amp;ab_channel=RaymondYunFei">youtube地址</a></li>
<li><a href="https://www.bilibili.com/video/BV1YK4y1Z75s/">bilibili搬运</a></li>
</ul></li>
<li><p>计算机图形学是研究如何利用计算机生成、处理和显示图形的一门学科</p></li>
<li><p>光栅化图形学、光线跟踪</p></li>
<li><p>OpenGL，vulkan，DirectX</p></li>
<li><p>light and matter：光线与物体</p>
<ul>
<li>simulation，abstraction，representation</li>
</ul></li>
<li><p>应用</p>
<ul>
<li>工业：CAD，精确表示，能不能做出来</li>
<li>娱乐：逼真</li>
<li>军事/交互：表现力、真实感</li>
</ul></li>
<li><p>CAD：波音777（boeing 777），无纸设计</p></li>
<li><p>昆仑发动机（An-70）</p></li>
<li><p>CAD，CAE，CAM一体化</p>
<ul>
<li>Design，Engineering，Manufactoring</li>
<li>不仅仅是几何体，加入动力学参数等</li>
</ul></li>
<li><p>3D打印</p></li>
<li><p>动画 Geri's Game</p>
<ul>
<li>subdivision：细分（人物表情）</li>
</ul></li>
<li><p>GPU -&gt; shader -&gt; tessellation shader（做细分工作）</p></li>
<li><p>modeling and rendering</p>
<ul>
<li>建模与渲染</li>
</ul></li>
<li><p>绘制理论方法与技术</p>
<ul>
<li>光照明技术即材质表示与建模</li>
<li>真实感绘制技术</li>
<li>加速、实时（25-30帧/秒）</li>
</ul></li>
<li><p>应用</p>
<ul>
<li>医学：可视化</li>
<li>动画</li>
<li>全局光照明</li>
<li>细微</li>
<li>头发：非规则 + 多</li>
<li>人脸：人的真假（很难）</li>
</ul></li>
<li><p>NPR：non-photorealistic-rendering</p>
<ul>
<li>非真实感绘制</li>
</ul></li>
<li><p>艺术馆风格绘制</p></li>
<li><p>VR：virtual reality</p></li>
<li><p>kinect：夹用交互娱乐设备</p></li>
<li><p>GPU</p></li>
<li><p>米开朗基罗计划</p>
<ul>
<li>点云大数据处理</li>
<li>几何优化</li>
</ul></li>
<li><p>游戏引擎</p>
<ul>
<li>引擎只是个框架，游戏开发者只需要填内容</li>
<li>QuakeIII，Unreal Tournament</li>
</ul></li>
<li><p>游戏研发：引擎 + 美工</p></li>
<li><p>图形（Graphics）与图象（Image）</p>
<ul>
<li>图象纯指计算机内以位图（Bitmap）形式存在的灰度或者彩色信息</li>
<li>图形含有<strong>几何</strong>属性，或者说更强调场景的几何表示是由<strong>场景的几何模型</strong>和<strong>景物的物理属性</strong>共同组成的</li>
</ul></li>
<li><p>相关学科</p>
<ul>
<li>CACD（Computer Aided Geometry Design）</li>
<li>图象处理</li>
<li>计算数学（逼近论）</li>
<li>代数与几何</li>
<li>计算机视觉与模式识别</li>
</ul></li>
<li><p>图形与视觉</p>
<ul>
<li>灭点</li>
<li>错觉</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.LS</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学.李胜.03.3D图形绘制流水线基础与图形编程</title>
    <url>/2021/01/26/CG/LS/03/</url>
    <content><![CDATA[<h1 id="programmable-3d-graphics-pipeline">Programmable 3D Graphics
Pipeline</h1>
<h2 id="vertex-assembly">1. Vertex Assembly</h2>
<ul>
<li><p>顶点装配</p></li>
<li><p>position（坐标）</p></li>
<li><p>normal（法向）</p></li>
<li><p>texture coordinate（纹理坐标）</p></li>
</ul>
<h2 id="vertex-shader">2. Vertex Shader</h2>
<ul>
<li>顶点着色器</li>
</ul>
<h3 id="transform">(1) transform</h3>
<ul>
<li>TL：Transform and Lighting
<ul>
<li>坐标变换、光照计算</li>
</ul></li>
<li><span class="math inline">\(P_{clip} =
(M_{model-view-projection})(P_{model})\)</span>
<ul>
<li>model to world：<span class="math inline">\(P_{world}=(M_{model})(P_{model})\)</span></li>
<li>world to eye：<span class="math inline">\(P_{eye}=(M_{view})(P_{world})\)</span></li>
<li>eye to clip：<span class="math inline">\(P_{clip}=(M_{projection})(P_{eye})\)</span></li>
</ul></li>
</ul>
<h3 id="vertex---modified-vertex">(2) vertex -&gt; modified vertex</h3>
<ul>
<li>Perform additional per-vertex computations
<ul>
<li>modify, add or remove attributes passed down the pipeline</li>
</ul></li>
<li>uniforms：常量</li>
<li>matrices：矩阵</li>
<li>texture：几何细节更加丰富</li>
<li>修改几何属性</li>
<li>displacement mapping：位移贴图（映射）</li>
</ul>
<h2 id="primitive-assembly">3. Primitive Assembly</h2>
<ul>
<li><p>图元</p></li>
<li><p><strong>group vertex</strong></p>
<ul>
<li>triangle，lines，...</li>
</ul></li>
<li><p>逻辑坐标转化为物理坐标</p></li>
<li><p>裁剪</p></li>
</ul>
<h2 id="rasterizer">4. Rasterizer</h2>
<ul>
<li><p>光栅化</p></li>
<li><p>二维图元转化为<strong>像素点</strong></p></li>
<li><p>图元属性与 vertex assembly 中一致</p></li>
<li><p>aliasing：走样问题</p></li>
</ul>
<h2 id="fragment-shader">5. Fragment Shader</h2>
<ul>
<li>又被称为是 pixel shader</li>
<li>根据光照和物体上色
<ul>
<li>线性插值，双线性插值</li>
<li>输出颜色</li>
</ul></li>
<li>光照计算，下述一般不会同时存在
<ul>
<li>per-fragment lighting（更好，更精细）</li>
<li>per-vertex lighting</li>
</ul></li>
<li>texture：<strong>贴图</strong></li>
<li>bump mapping：凹凸贴图
<ul>
<li>扰动法向</li>
</ul></li>
</ul>
<h2 id="per-fragment-tests">6. Per-Fragment Tests</h2>
<h3 id="scissor-test">(1) scissor test</h3>
<ul>
<li><p>裁剪：裁剪掉窗口之外的部分</p></li>
<li><p>原因：</p>
<ul>
<li>For performance</li>
<li>Post-processing effects</li>
<li>Multipass rendering</li>
</ul></li>
</ul>
<h3 id="stencil-test">(2) stencil test</h3>
<ul>
<li>模板（ 蒙板 ）测试：
<ul>
<li>可以丢弃窗口中任意区域（以fragment 为单位）</li>
<li>根据 stencil buffer 的内容，来丢弃不需要的 fragments</li>
</ul></li>
<li><strong>位运算操作</strong></li>
<li>实现：将模板写入模板缓冲区（stencil
buffer），之后在测试中可以使用</li>
</ul>
<h3 id="depth-test">(3) depth test</h3>
<ul>
<li>又被称为 <strong>z-test</strong></li>
<li>深度测试
<ul>
<li>例子：等高线，小偏移</li>
<li>如果没有深度测试，那么由于深度相同/浮点精度问题，线时隐时现</li>
</ul></li>
</ul>
<h2 id="blending">7. Blending</h2>
<ul>
<li>混合</li>
<li>Combine fragment color with framebuffer color
<ul>
<li>Can weight each color</li>
<li>Can use different operations: +, -, etc.</li>
</ul></li>
<li>实现半透明（Translucency）的效果</li>
</ul>
<h2 id="framebuffer">8. FrameBuffer</h2>
<ul>
<li>输出到 FrameBuffer</li>
</ul>
<h1 id="evolution-of-the-programmable">Evolution of the
Programmable</h1>
<h2 id="s-之前">1990s 之前</h2>
<ul>
<li>显卡</li>
<li>无 GPU 的概念，处理能力很弱</li>
<li>图形工作站</li>
</ul>
<h2 id="s">90s</h2>
<ul>
<li><p>Pre GPU</p></li>
<li><p>software rendering：软件渲染</p></li>
<li><p>为什么选择 GPU</p>
<ul>
<li><strong>并行</strong>
<ul>
<li>Pipeline parallel</li>
<li>Data parallel</li>
<li>CPU and GPU executing in parallel</li>
</ul></li>
<li><strong>硬件支持</strong>
<ul>
<li>texture filtering</li>
<li>rasterization</li>
<li>sqrt</li>
</ul></li>
</ul></li>
</ul>
<h2 id="section">1996</h2>
<ul>
<li>3dfx Voodoo</li>
<li>软件：
<ul>
<li>vertex assembly，vertex shader，primitive assembly</li>
</ul></li>
<li>硬件：
<ul>
<li>rasterizer，fragment shader，pre-fragment
tests，blend，framebuffer</li>
<li><strong>Fixed-function</strong> rasterization, texture mapping,
depth testing, etc</li>
<li><strong>4-6MB</strong> memory</li>
<li><strong>PCI bus</strong>
<ul>
<li>Peripheral Component Interconnect</li>
<li>外围组件互连</li>
</ul></li>
</ul></li>
</ul>
<h2 id="section-1">1999</h2>
<ul>
<li>Nvidia Geforce 256</li>
<li><span style="color:red">全硬件实现</span></li>
<li><strong>Fixed-function</strong> vertex shading（T&amp;L）</li>
<li>Multi-texturing：bump maps, light maps, etc.</li>
<li><span style="color:red">Direct3D</span> 7</li>
<li><strong>AGP bus</strong>
<ul>
<li>Accelerated Graphics Port</li>
<li>加速图形端口</li>
</ul></li>
</ul>
<h2 id="section-2">2001</h2>
<ul>
<li>Nvidia Geforce 3</li>
<li>全硬件实现，但是 vertex shader 可以支持编程</li>
<li>fragment shader 支持的不太好</li>
<li>Direct3D 8</li>
</ul>
<h2 id="section-3">2004</h2>
<ul>
<li>Nvidia Geforce 6</li>
<li>支持很好的 vertex shader，fragment shader 编程</li>
<li>vertex shader 可以支持读取 texture</li>
<li>Multiple render targets
<ul>
<li>执行一遍就能输出多个渲染目标</li>
</ul></li>
<li><strong>PCIe bus</strong>
<ul>
<li>peripheral component interconnect express</li>
<li>一种高速串行计算机扩展总线标准，2001年提出，旨在代替 PCI，PCI-X 和
AGP 总线标准</li>
</ul></li>
<li><span style="color:red">OpenGL</span> 2 / Direct3D 9</li>
<li>架构：某一部分的架构是固定的，负载不均衡
<ul>
<li>6 vertex shader processors</li>
<li>16 fragment shader processors</li>
</ul></li>
</ul>
<h2 id="section-4">2006</h2>
<ul>
<li>Nvidia Geforce 8</li>
<li>在渲染管线 Vertex Shader 之后加入了 <span style="color:red;font-weight:bold">Geometry Shader</span>
<ul>
<li>Geometry Shader：1-&gt;n，一个几何图元生成多个几何图元</li>
<li>Vertex Shader：1-&gt;1</li>
</ul></li>
<li><span style="color:red">Unified shader
processors</span>：统一着色器处理器</li>
<li>OpenGL 3 / Direct3D 10</li>
<li>Support for GPU Compute</li>
<li>Geometry Shader
<ul>
<li>可以读取 texture</li>
<li><strong>粒子系统</strong>：Partical System
<ul>
<li>All-GPU Particle Systems</li>
</ul></li>
<li>实例化：Instance
<ul>
<li>可以对原先数据作微小的变化，从而生成很多图案</li>
</ul></li>
</ul></li>
<li>任意点 O，三角形顶点 A，B，C，三角形 ABC 中任意一点 P</li>
</ul>
<p><span class="math display">\[
\vec{OP}=\frac{S_{\Delta_{PBC}}\cdot\vec{OA}+S_{\Delta_{PCA}}\cdot\vec{OB}+S_{\Delta_{PAB}}\cdot\vec{OC}}{S_{\Delta_{PBC}}+S_{\Delta_{PCA}}+S_{\Delta_{PAB}}}
\]</span></p>
<ul>
<li><p>证明方法：延长 AP 交 BC 于 D，之后反复利用如下定理即可</p>
<ul>
<li>线段 AB 上一点 C</li>
</ul>
<p><span class="math display">\[
  \vec{OC}=\frac{|\vec{CB}|\cdot\vec{OA}}{|\vec{AB}|}+\frac{|\vec{CA}|\cdot\vec{OB}}{|\vec{AB}|}
  \]</span></p></li>
<li><p>如果 P 为重心 G，那么有</p></li>
</ul>
<p><span class="math display">\[
S_{\Delta_{GBC}}=S_{\Delta_{GCA}}=S_{\Delta_{GAB}} \\
\vec{OG}=\frac{\vec{OA}+\vec{OB}+\vec{OC}}{3}
\]</span></p>
<ul>
<li>做细分：subdivision</li>
<li>勾边</li>
<li>1 -&gt; n</li>
</ul>
<h3 id="procedural-geometry">Procedural Geometry</h3>
<ul>
<li>Procedural Geometry Dynamic Vine Growth on the GPU</li>
<li>藤蔓生长</li>
<li>提供更多细分模板</li>
</ul>
<h3 id="patched-control-points">Patched / Control Points</h3>
<ul>
<li>Hull shader：参数</li>
<li>Tessellation：镶嵌</li>
<li>Domain Shader：实际生成的顶点位置</li>
</ul>
<h3 id="displacement-mapping">Displacement Mapping</h3>
<h2 id="nivdia-g80">Nivdia G80</h2>
<ul>
<li><strong>unify</strong></li>
<li>统一了，没有物理上区分处理器处理哪一个部分（线程分配）</li>
<li>发展趋势
<ul>
<li>全部可编程</li>
<li>流程可以修改</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.LS</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学.李胜.02.图形硬件设备与系统</title>
    <url>/2021/01/26/CG/LS/02/</url>
    <content><![CDATA[<h1 id="硬件发展">硬件发展</h1>
<ul>
<li>1950 MIT 旋风一号（Whirlwind I）</li>
<li>1958 Calcomp 公司滚动式绘图仪</li>
<li>1963 SKETCHPAD</li>
<li>60年代中期：随机扫描显示器</li>
<li>60年代后期：存储管式显示器</li>
<li>1969：初期的显示器缓冲存储器</li>
<li>80年代：光栅显示器，图形工作站</li>
<li>90年代：液晶显示器</li>
<li>90年代末：图形加速卡</li>
</ul>
<h1 id="图形绘制核心问题">图形绘制核心问题</h1>
<ul>
<li>1960s <strong>解决可见性问题</strong>
<ul>
<li>隐藏线消除算法 Roberts (1963), Appel (1967)</li>
<li>隐藏面消除算法 Warnock (1969), Watkins (1970)</li>
<li>可见性 排序算法 Sutherland (1974)</li>
</ul></li>
<li>1970s <strong>光栅化图形学</strong>
<ul>
<li>漫反射光照 Gouraud (1971)</li>
<li>镜面反射光照 Phong (1974)</li>
<li>曲面表面 纹理映射 Blinn (1974)</li>
<li>Z-buffer隐藏面消除算法 Catmull (1974)</li>
<li>反混淆 Crow (1977)
<ul>
<li>混淆：锯齿、闪烁</li>
</ul></li>
</ul></li>
<li>1980s早期 <strong>全局光照明</strong>
<ul>
<li>光线跟踪 Whitted (1980)</li>
<li>辐射度方法 Goral, Torrance et al. (1984), Cohen (1985)</li>
<li>绘制方程 Kajiya (1986)</li>
</ul></li>
<li>1980s后期 <strong>照片真实感绘制技术</strong>
<ul>
<li>shade trees （层次绘制树） Cook (1984)</li>
<li>shading languages （高级绘制语言） Perlin (1985)</li>
<li>RenderMan（真实感绘制工具） Hanrahan and Lawson (1990)</li>
</ul></li>
<li>1990s早期 <strong>非照片真实感绘制</strong>
<ul>
<li>体绘制 Drebin et al. (1988), Levoy (1988)</li>
<li>印象绘画风格 Haeberli (1990)</li>
<li>自动钢笔画插图 Salesin et al. (1994-)</li>
<li>美术绘制 Meier (1996)</li>
</ul></li>
<li>2010 <strong>面向VR的渲染技术</strong>
<ul>
<li>显示位置不同</li>
<li>双目</li>
<li>头盔</li>
<li>镜面</li>
</ul></li>
<li>2015 <strong>基于深度学习的图形渲染</strong></li>
</ul>
<h1 id="图形处理器">图形处理器</h1>
<ul>
<li>显卡
<ul>
<li>普通显卡：跑游戏卡不卡，超频性能好不好</li>
<li>专业显卡：强大的性能、稳定性、绘图的精确</li>
</ul></li>
<li><strong>GPU</strong> vs <strong>CPU</strong></li>
<li>图形处理器 GPU
<ul>
<li>早期：简单的存储器和帧缓冲区
<ul>
<li>只起到图形的存储与传递作用</li>
<li>一切操作由 CPU 控制</li>
</ul></li>
<li>现在：不仅仅存储图形，能完成大部分图形函数
<ul>
<li>专业的图形卡已经具备很强的 3D 处理能力</li>
</ul></li>
</ul></li>
<li>图形处理器
<ul>
<li>显示主芯片：显卡的核心，俗称 GPU</li>
<li>显示缓存：存储将要显示的图形信息和保存图形运算的中间数据</li>
</ul></li>
<li>帧缓冲器
<ul>
<li>用来存储像素颜色（灰度）值的存储器就称为帧缓冲存储器</li>
<li>一般比屏幕大小大得多
<ul>
<li>可存放多个页面，每个页面存放一幅位图</li>
<li>离屏渲染： GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作
<ul>
<li>正在渲染的不是当前帧</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>GTX</strong> vs <strong>RTX</strong></li>
<li>RTX：图灵架构
<ul>
<li>增加了 tensor core 以及 ray tracing core</li>
</ul></li>
<li>传统光栅扫描显示系统
<ul>
<li>电子束按固定的扫描顺序进行扫描N条扫描线，每条扫描线有M个像素</li>
<li>显示器的分辨率：M*N</li>
<li>逻辑部件：
<ul>
<li>帧缓冲存储器(Frame Buffer)、视频控制器(video Controller
)、显示处理器、CRT显示器
<ul>
<li>CRT 阴极射线管</li>
</ul></li>
<li>帧缓存是数字设备，光栅显示器是模拟设备</li>
</ul></li>
</ul></li>
<li>点状影孔板工作原理
<ul>
<li>三支电子枪</li>
<li>电子枪、影孔板中的一个小孔和一个像素呈一直线
<ul>
<li>小孔成像</li>
<li>一个像素包括三色荧光点（很小并且充分靠近）<img src="/2021/01/26/CG/LS/02/pic1.jpg"></li>
</ul></li>
<li>调节各电子枪发生的电子束中所含<strong>电子的数目</strong>，即可控制<strong>各色光点亮度</strong></li>
</ul></li>
<li>LCD/LED 显示器
<ul>
<li>不会产生CRT那样的因为刷新频率低而出现的闪烁现象</li>
<li><strong>没有电磁辐射</strong>，对人体健康没有任何影响</li>
<li><strong>液晶</strong>
<ul>
<li>电压 -&gt; 通过光的折射角度变化</li>
</ul></li>
</ul></li>
<li>扫描仪 / 三维扫描仪
<ul>
<li>光学分辨率：dpi（dot per inch）</li>
<li>应用
<ul>
<li>在线检测</li>
<li>实物到CAD模型的转换</li>
<li>复杂面型的快速测量等方面</li>
<li>影视特技制作</li>
<li>虚拟现实</li>
<li>高级游成</li>
<li>文物保护</li>
</ul></li>
<li>类别
<ul>
<li>接触式与非接触式</li>
<li>三维扫描仪与三维彩色扫描仪</li>
<li>外表面扫描与内部扫描</li>
<li>色扫描、线扫描与面扫描</li>
</ul></li>
</ul></li>
</ul>
<h1 id="一些应用">一些应用</h1>
<ul>
<li><p><strong>CAVE</strong></p>
<ul>
<li>A room with walls and/or floor formed by rear projection
screens</li>
<li>一种基于投影的沉浸式虚拟现实显示系统</li>
<li>handled -&gt; 3D Ready LCD -&gt; 3D Ready TV -&gt; CAVE</li>
</ul></li>
<li><p>immersive virtual simulation</p>
<ul>
<li>沉浸式虚拟现实</li>
<li>real people using simulated equipment in a (immersive) simulated
world/virtual environment</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">level</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">outside</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">inside</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;">inside + perspective</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;">inside + perspective + stereo</td>
</tr>
</tbody>
</table></li>
<li><p>Gaming and Emerging Technology Laboratory
(<strong>GET</strong>)</p></li>
<li><p>Kinect：流行的体感交互设备</p>
<ul>
<li><strong>Kinect传感器</strong>
<ul>
<li>CMOS红外传感器</li>
<li>该传感器通过黑白光谱的方式来感知环境：
<ul>
<li>纯黑代表无穷远，纯白代表无穷近</li>
<li>黑白间的灰色地带对应物体到传感器的物理距离</li>
<li>形成一幅代表周围环境的景深图像</li>
</ul></li>
</ul></li>
<li><strong>图像处理器</strong>
<ul>
<li>前景背景分割，并跟踪提取前景的变化和运动信息</li>
</ul></li>
<li><strong>人工智能机器学习部件</strong>
<ul>
<li>分割后玩家图像的每一个像素都被传送进一个辨别人体部位的机器学习系统中</li>
<li>随后该系统将给出了某个特定像素属于哪个身体部位的可能性</li>
</ul></li>
<li><strong>骨架系统</strong>
<ul>
<li>根据追踪到的20个关节点来生成一幅骨架系统</li>
</ul></li>
</ul></li>
<li><p><strong>3D打印</strong></p>
<ul>
<li>分层加工、叠加成型</li>
<li>每一层的打印过程分为两步
<ul>
<li>在需要成型的区域喷洒一层特殊胶水，胶水液滴本身很小，且不易扩散</li>
<li>是喷洒一层均匀的粉末，粉末遇到胶水会迅速固化黏结，而没有胶水的区域仍保持松散状态</li>
</ul></li>
<li>3D打印是断层扫描的逆过程</li>
</ul></li>
<li><p>增强现实/混合现实眼镜</p>
<ul>
<li>Google Glasses
<ul>
<li>失败了，眩晕，散热</li>
</ul></li>
<li>HoloLens（微软）
<ul>
<li>成功了</li>
</ul></li>
<li>微型投影仪 + 摄像头 + 传感器 + 存储传输 + 操控设备</li>
</ul></li>
</ul>
<h1 id="图形软件系统">图形软件系统</h1>
<ul>
<li>图形软件系统
<ul>
<li>基本图形软件：<strong>支撑软件</strong></li>
<li>应用图形软件：<strong>专用软件</strong></li>
</ul></li>
<li>基本图形软件实现方法
<ul>
<li>图形软件包</li>
<li>修改高级语言</li>
<li>专用高级图形语言</li>
</ul></li>
<li>图形支撑软件
<ul>
<li>第一层次是面向系统的，主要解决图形设备与计算机的通讯接口等问题，称为<strong>设备驱动程序</strong>，包括一些最基本的输入、输出程序，事实上，设备驱动程序现在已被作为操作系统一部分，由操作系统或设备硬件厂商开发</li>
<li>第二层次是建立在驱动程序之上，完成图元的生成、设备的管理等功能，目前这个层次上的图形支撑软件已经标准化，如CGI等</li>
<li>第三层次是在中间层基础上编写的，其主要任务是建立图形数据结构，定义、修改和输出图形，它是面向用户的，要求具有较强的交互功能，使用方便，风格好，概念明确，容易阅读，便于维护和移植，GKS、PHIGS、OpenGL、DirectX便属于这一层次的软件</li>
</ul></li>
<li>可移植性的四个方面
<ul>
<li>应用程序在不同系统间的可移植性</li>
<li>应用程序和图形设备的可移植性</li>
<li>图形数据的可移植性</li>
<li>程序员的可移植性</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.LS</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学.李胜.04.几何变换</title>
    <url>/2021/01/28/CG/LS/04/</url>
    <content><![CDATA[<h1 id="二维基本变换">二维基本变换</h1>
<h2 id="平移变换">1. 平移变换</h2>
<ul>
<li><p><span class="math inline">\(\vec{P&#39;}=\vec{P}+\vec{T}\)</span></p></li>
<li><p><span class="math display">\[
  \begin{bmatrix} x&#39; \\ y&#39; \end{bmatrix} = \begin{bmatrix} x \\
y \end{bmatrix}+\begin{bmatrix}t_x \\ t_y\end{bmatrix}
  \]</span></p></li>
</ul>
<h2 id="旋转变换">2. 旋转变换</h2>
<ul>
<li><p><span class="math inline">\(\vec{P&#39;}=R_{\theta}\cdot\vec{P}\)</span></p></li>
<li><p><span class="math display">\[
  R_{\theta}=\begin{bmatrix}\cos
  \theta &amp; -\sin\theta  \\ \sin\theta&amp;\cos\theta\end{bmatrix}
  \]</span></p></li>
<li><p><span class="math inline">\(R_{\theta}=R_{-\theta}^{-1}\)</span></p></li>
</ul>
<h2 id="尺度变换">3. 尺度变换</h2>
<ul>
<li><p><span class="math inline">\(\vec{P&#39;}=S\cdot\vec{P}\)</span></p></li>
<li><p><span class="math display">\[
  S=\begin{bmatrix}s_x &amp; 0 \\ 0 &amp; s_y \end{bmatrix}
  \]</span></p></li>
</ul>
<h1 id="齐次坐标">齐次坐标</h1>
<ul>
<li><strong>统一变换</strong></li>
<li>n 维向量使用 <span style="color:red;font-weight:bold">n+1</span>
维向量表示
<ul>
<li>使用直线来表示点</li>
</ul></li>
<li><span class="math inline">\((x,y)\)</span> 使用 <span class="math inline">\((hx,hy,h),h\ne 0\)</span> 来表示
<ul>
<li>标准齐次坐标：<span class="math inline">\(h=1\)</span></li>
</ul></li>
<li>统一变换为 <span class="math inline">\(\vec{P&#39;}=M\cdot\vec{P}\)</span></li>
</ul>
<h2 id="平移变换-1">1. 平移变换</h2>
<ul>
<li><p><strong>translate</strong></p></li>
<li><p><span class="math display">\[
  M=T(t_x,t_y)=\begin{bmatrix}1 &amp; 0 &amp; t_x \\ 0 &amp; 1 &amp; t_y
\\ 0 &amp; 0 &amp; 1 \end{bmatrix}
  \]</span></p></li>
</ul>
<h2 id="旋转变换-1">2. 旋转变换</h2>
<ul>
<li></li>
<li><span class="math display">\[
  M=R(\theta)=\begin{bmatrix}\cos\theta &amp; -\sin\theta &amp; 0 \\
\sin\theta &amp; \cos\theta &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}
  \]</span></li>
</ul>
<h2 id="尺度变换-1">3. 尺度变换</h2>
<ul>
<li></li>
<li><span class="math display">\[
  M=S(s_x,s_y)=\begin{bmatrix}s_x &amp; 0 &amp; 0 \\ 0 &amp; s_y &amp; 0
\\ 0 &amp; 0 &amp; 1 \end{bmatrix}
  \]</span></li>
</ul>
<h2 id="复杂的变换">4. 复杂的变换</h2>
<ul>
<li><span style="color:red;font-weight:bold">解构成基本变换</span></li>
</ul>
<h3 id="对任意点的旋转">(1) 对任意点的旋转</h3>
<ul>
<li><p>平移参考点到原点</p></li>
<li><p>旋转</p></li>
<li><p>将参考点移回去</p></li>
<li><p>3 个矩阵变换</p>
<ul>
<li><strong>注意矩阵乘法不可交换</strong>，需要正确考虑顺序</li>
</ul></li>
<li><p><strong>两种模式</strong></p>
<ul>
<li>固定坐标系模式：先调用的先执行</li>
<li>活动坐标系模式：后调用的先执行（<span style="color:red;font-weight:bold">OpenGL</span>）
<ul>
<li>变换结束之后更新的是坐标系</li>
</ul></li>
</ul></li>
<li><p>左乘 vs 右乘</p>
<ul>
<li><p>左乘：行变换</p>
<ul>
<li><span class="math display">\[
  M\begin{pmatrix}x_1 \\ x_2 \\ x_3 \end{pmatrix}
  \]</span></li>
</ul></li>
<li><p>右乘：列变换</p>
<ul>
<li><span class="math display">\[
  \begin{pmatrix}x_1, x_2, x_3 \end{pmatrix}M
  \]</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="对任意参考点的放缩">(2) 对任意参考点的放缩</h3>
<ul>
<li>同理</li>
</ul>
<h2 id="对称变换">5. 对称变换</h2>
<ul>
<li><strong>symmetric</strong></li>
</ul>
<h3 id="关于-x-轴的对称变换">(1) 关于 x 轴的对称变换</h3>
<ul>
<li><p><span class="math inline">\(y\rightarrow -y\)</span></p></li>
<li><p><span class="math display">\[
  M=\begin{bmatrix}1 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 \\ 0 &amp; 0
&amp; 1 \end{bmatrix}
  \]</span></p></li>
</ul>
<h3 id="关于-y-轴的对称变换">(2) 关于 y 轴的对称变换</h3>
<ul>
<li><p><span class="math inline">\(x\rightarrow -x\)</span></p></li>
<li><p><span class="math display">\[
  M=\begin{bmatrix}1 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 \\ 0 &amp; 0
&amp; 1 \end{bmatrix}
  \]</span></p></li>
</ul>
<h3 id="关于任意轴的对称变换">(3) 关于任意轴的对称变换</h3>
<ul>
<li><strong>解构</strong></li>
<li>步骤
<ul>
<li>平移轴至过原点</li>
<li>绕原点旋转轴至与 x 轴或 y 轴重合</li>
<li>对称变换</li>
<li>旋转回去</li>
<li>平移回去</li>
</ul></li>
</ul>
<h2 id="错切变换">6. 错切变换</h2>
<ul>
<li><strong>shear</strong></li>
</ul>
<h3 id="以-y-轴为依赖轴y0-为参考轴">(1) 以 y 轴为依赖轴，y=0
为参考轴</h3>
<ul>
<li><p>y 不变，x 错切</p></li>
<li><p><span class="math display">\[
  M=\begin{bmatrix}1 &amp; sh_x &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp;
0 &amp; 1 \end{bmatrix},sh_x=tan\alpha
  \]</span></p></li>
</ul>
<p><img src="/2021/01/28/CG/LS/04/shear_y_y=0.png" alt="img" style="zoom:30%;"></p>
<h3 id="以-y-轴为依赖轴yy_ref-为参考轴">(2) 以 y 轴为依赖轴，<span class="math inline">\(y=y_{ref}\)</span> 为参考轴</h3>
<ul>
<li><p>平移，错切（y=0），反平移</p></li>
<li><p><span class="math display">\[
  M=\begin{bmatrix}1 &amp; sh_x(1-y_{ref}) &amp; 0 \\ 0 &amp; 1 &amp; 0
\\ 0 &amp; 0 &amp; 1 \end{bmatrix},sh_x=tan\alpha
  \]</span></p></li>
</ul>
<p><img src="/2021/01/28/CG/LS/04/shear_y_y_ref.png" alt="img" style="zoom: 50%;"></p>
<h3 id="以-x-轴为依赖轴x0-为参考轴">(3) 以 x 轴为依赖轴，x=0
为参考轴</h3>
<ul>
<li><p>x 不变，y 错切</p></li>
<li><p><span class="math display">\[
  M=\begin{bmatrix}1 &amp; 0 &amp; 0 \\ sh_y &amp; 1 &amp; 0 \\ 0 &amp;
0 &amp; 1 \end{bmatrix},sh_x=tan\beta
  \]</span></p></li>
</ul>
<p><img src="/2021/01/28/CG/LS/04/shear_x_x=0.png" alt="img" style="zoom: 40%;"></p>
<h3 id="以-x-轴为依赖轴xx_ref-为参考轴">(4) 以 x 轴为依赖轴，<span class="math inline">\(x=x_{ref}\)</span> 为参考轴</h3>
<ul>
<li><span class="math display">\[
  M=\begin{bmatrix}1 &amp; 0 &amp; 0 \\ sh_y(1-x_{ref}) &amp; 1 &amp; 0
\\ 0 &amp; 0 &amp; 1 \end{bmatrix},sh_x=tan\beta
  \]</span></li>
</ul>
<p><img src="/2021/01/28/CG/LS/04/shear_x_x=ref.png" alt="1611837351710" style="zoom:50%;"></p>
<h2 id="仿射变换">7. 仿射变换</h2>
<ul>
<li><p>以上提到的变换都是仿射变换</p></li>
<li><p>Affine Transform</p></li>
<li><p>保持直线的平行性</p></li>
<li><p>正交投影属于仿射变换，透视投影不属于仿射变换</p></li>
<li><p>矩阵特征</p></li>
<li><p><span class="math display">\[
  \begin{bmatrix}a &amp; b &amp; c \\ d &amp; e &amp; f \\ 0 &amp; 0
&amp; 1 \end{bmatrix}
  \]</span></p></li>
</ul>
<h1 id="二维图形的显示流程">二维图形的显示流程</h1>
<ul>
<li>世界坐标系（world coordinate）
<ul>
<li>或者称作用户坐标系（user coordinate）</li>
</ul></li>
<li>局部坐标系（local coordinate）</li>
<li>屏幕坐标系（screen coordinate）
<ul>
<li>或者称作设备坐标系（device coordinate）</li>
</ul></li>
<li><strong>窗口</strong> 与 <strong>视区</strong>
<ul>
<li>窗口：在世界坐标系中指定的矩形区域，用来指定要显示的图形</li>
<li>视区：在设备坐标系上指定的矩形区域，用来指定窗口内的图形在屏幕上显示的大小及位置</li>
</ul></li>
</ul>
<h1 id="三维几何变换">三维几何变换</h1>
<ul>
<li>三维齐次坐标：<span class="math inline">\((x_h,y_h,z_h,h),h\ne
0\)</span></li>
<li>标准齐次坐标：<span class="math inline">\((x,y,z,1)\)</span></li>
<li>右手系：<span class="math inline">\(\vec{x} \times \vec{y} =
\vec{z}\)</span></li>
</ul>
<p><img src="/2021/01/28/CG/LS/04/xyz_right.png" alt="1611884054147" style="zoom:50%;"></p>
<h2 id="平移-translate">1. 平移 translate</h2>
<p><span class="math display">\[
T(t_x,t_y,t_z)=
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; t_x \\
0 &amp; 1 &amp; 0 &amp; t_y \\
0 &amp; 0 &amp; 1 &amp; t_z \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<h2 id="尺度放缩-scale">2. 尺度（放缩） scale</h2>
<p><span class="math display">\[
S(s_x,s_y,s_z)=
\begin{bmatrix}
s_x &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; s_y &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; s_z &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<h2 id="旋转-rotate">3. 旋转 rotate</h2>
<ul>
<li>正方向：大拇指指向绕的轴的方向，四指的方向即为正方向</li>
</ul>
<h3 id="绕-x-轴">(1) 绕 x 轴</h3>
<ul>
<li>x 不变</li>
<li>相当于在 <strong>yOz</strong> 平面旋转 <span class="math inline">\(\theta\)</span></li>
<li>划去 x 对应的列和行之后和二维相同</li>
</ul>
<p><span class="math display">\[
R_x(\theta)=
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \cos\theta &amp; -\sin\theta &amp; 0 \\
0 &amp; \sin\theta &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<h3 id="绕-y-轴">(2) 绕 y 轴</h3>
<ul>
<li>y 不变</li>
<li>在 <strong>zOx</strong> 平面旋转 <span class="math inline">\(\theta\)</span>
<ul>
<li>在 <strong>xOz</strong> 平面旋转 <span class="math inline">\(-\theta\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
R_y(\theta)=
\begin{bmatrix}
\cos\theta &amp; 0 &amp; \sin\theta &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0 \\
-\sin\theta &amp; 0 &amp; \cos\theta &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<h3 id="绕-z-轴">(3) 绕 z 轴</h3>
<ul>
<li>z 不变</li>
<li>绕 <strong>xOy</strong> 平面旋转 <span class="math inline">\(\theta\)</span></li>
</ul>
<p><span class="math display">\[
R_z(\theta)=
\begin{bmatrix}
\cos\theta &amp; -\sin\theta &amp; 0 &amp; 0\\
\sin\theta &amp; \cos\theta  &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<h2 id="错切-shear">4. 错切 shear</h2>
<ul>
<li>z 轴为依赖轴，z=0 平面为参考平面</li>
</ul>
<p><span class="math display">\[
SH_z(sh_x,sh_y)=
\begin{bmatrix}
1 &amp; 0 &amp; sh_x &amp; 0 \\
0 &amp; 1 &amp; sh_y &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<h2 id="对称变换-1">5. 对称变换</h2>
<ul>
<li>关于 z=0(xOy) 平面的对称变换</li>
</ul>
<p><span class="math display">\[
SY_{xy}=
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<h2 id="仿射变换一般形式">6. 仿射变换一般形式</h2>
<p><span class="math display">\[
A =
\begin{bmatrix}
a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} \\
a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} \\
a_{31} &amp; a_{32} &amp; a_{33} &amp; a_{34} \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
=
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; a_{14} \\
0 &amp; 1 &amp; 0 &amp; a_{24} \\
0 &amp; 0 &amp; 1 &amp; a_{34} \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\cdot
\begin{bmatrix}
a_{11} &amp; a_{12} &amp; a_{13} &amp; 0 \\
a_{21} &amp; a_{22} &amp; a_{23} &amp; 0 \\
a_{31} &amp; a_{32} &amp; a_{33} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
= T\cdot M
\]</span></p>
<ul>
<li>T 表示平移变换，M 表示其他变换
<ul>
<li>注意拆解顺序</li>
</ul></li>
</ul>
<h3 id="法向变换">7. 法向变换</h3>
<ul>
<li>点坐标：<span class="math inline">\((x,y,z,{\color{red}1})\)</span>
<ul>
<li><strong>点</strong></li>
</ul></li>
<li>法向坐标：<span class="math inline">\((x,y,z,{\color{red}0})\)</span>
<ul>
<li><strong>向量</strong></li>
</ul></li>
<li>验证：
<ul>
<li>点 - 点 = 向量</li>
<li>向量 + 向量 = 向量</li>
<li>点 + 向量 = 点</li>
</ul></li>
<li><strong>向量变换</strong>
<ul>
<li>取向量上两个不同点 <span class="math inline">\(x_1,x_2\)</span>，变换矩阵 <span class="math inline">\(A\)</span></li>
<li>原来的向量：<span class="math inline">\(x_2-x_1\)</span></li>
<li>新的向量：<span class="math inline">\(Ax_2-Ax_1\)</span></li>
</ul></li>
<li>切向量：<span class="math inline">\(T\)</span>
<ul>
<li>变化矩阵 <span class="math inline">\(M\)</span></li>
<li><span class="math inline">\(Mx_1-Mx_2=M(x_1-x_2)=M\cdot
T\)</span></li>
</ul></li>
<li>法向量：<span class="math inline">\(N\)</span>
<ul>
<li>原始条件：<span class="math inline">\(N\cdot T=N^TT=0\)</span></li>
<li><span class="math inline">\(N&#39;\cdot
T&#39;=(GN)\cdot(MT)=0\)</span></li>
<li>以上是向量乘法，转化为等价的矩阵乘法</li>
<li><span class="math inline">\((GN)\cdot
(MT)=(GN)^T(MT)=N^TG^TMT=0\)</span></li>
<li><span class="math inline">\(\Rightarrow G^TM=I\)</span></li>
</ul></li>
<li>即法向量的变换矩阵 <span class="math inline">\({\color{red}G=(M^{-1})^T}\)</span>
<ul>
<li>当矩阵 <span class="math inline">\(M\)</span>
为正交矩阵的时候，<span class="math inline">\(G=M\)</span></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.LS</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学.李胜.05.投影(2)</title>
    <url>/2021/01/31/CG/LS/05-1/</url>
    <content><![CDATA[<h1 id="opengl-中的投影矩阵">OpenGL 中的投影矩阵</h1>
<ul>
<li>vmath:Frusutm()</li>
</ul>
<p><span class="math display">\[
\begin{bmatrix}
\dfrac{2near}{right-left}&amp;0&amp;A&amp;0\\
0&amp;\dfrac{2near}{top-bottom}&amp;B&amp;0\\
0&amp;0&amp;C&amp;D\\
0&amp;0&amp;-1&amp;0\\
\end{bmatrix}
\]</span></p>
<ul>
<li>其中 <span class="math inline">\(A,B,C,D\)</span> 含义如下</li>
</ul>
<p><span class="math display">\[
A=\dfrac{left+right}{right-left}
\]</span></p>
<p><span class="math display">\[
B=\dfrac{top+bottom}{top-bottom}
\]</span></p>
<p><span class="math display">\[
C=-\dfrac{far+near}{far-near}
\]</span></p>
<p><span class="math display">\[
D=-\dfrac{2far\cdot near}{far-near}
\]</span></p>
<ul>
<li>其中 <span class="math inline">\(far,near,top,bottom,left,right\)</span>
表示6个裁剪面
<ul>
<li>实际的裁剪面
<ul>
<li><span class="math inline">\(far,near\)</span> 使用的是绝对值
<ul>
<li>因为一定是负数</li>
</ul></li>
<li><span class="math inline">\({\color{red}-far,-near},top,bottom,left,right\)</span></li>
</ul></li>
</ul></li>
<li>坐标变换：
<ul>
<li><strong>现实坐标系中的视见体</strong> 转化为
<strong>OpenGL中的立方体</strong> <span class="math inline">\([-1,1]\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/01/31/CG/LS/05-1/xyz_OpenGL.png"></p>
<ul>
<li>投影中心 <span class="math inline">\((0,0,0)\)</span></li>
<li>投影平面 <span class="math inline">\(z=-near\)</span></li>
<li>推导过程中裁剪面使用单词首字母代替</li>
</ul>
<h2 id="推导一投影角度">推导一：投影角度</h2>
<ul>
<li>投影+规范化</li>
</ul>
<h3 id="投影">(1) 投影</h3>
<ul>
<li>将视见体中的点投影到 <span class="math inline">\(z=-n\)</span>
上</li>
<li>以俯视图为例推导坐标关系（<span class="math inline">\(x,z\)</span>）</li>
</ul>
<p><img src="/2021/01/31/CG/LS/05-1/projection_01.png" alt="1612082808631" style="zoom:50%;"></p>
<ul>
<li><span class="math inline">\(z_p=-n\)</span></li>
<li><span class="math inline">\(x_p=\dfrac{nx_e}{-z_e}\)</span></li>
<li>利用侧视图可以得到 <span class="math inline">\(y_p=\dfrac{ny_e}{-z_e}\)</span></li>
</ul>
<h3 id="规范化">(2) 规范化</h3>
<ul>
<li><p><span class="math inline">\(x_p\in[l,r]\rightarrow
x_n\in[-1,1]\)</span></p></li>
<li><p><span class="math inline">\(y_p\in[b,t]\rightarrow
y_n\in[-1,1]\)</span></p></li>
<li><p>以 <span class="math inline">\(x\)</span> 的推导为例</p>
<ul>
<li><span class="math inline">\(\dfrac{x_p-l}{r-l}=\dfrac{x_n-(-1)}{1-(-1)}\)</span></li>
<li><span class="math inline">\(x_n=2\dfrac{x_p-l}{r-l}-1=\dfrac{2}{r-l}x_p-\dfrac{r+l}{r-l}=\dfrac{2n}{-z_e(r-l)}x_e-\dfrac{r+l}{r-l}\)</span></li>
<li><span class="math inline">\(x_n=\dfrac{\dfrac{2n}{r-l}x_e+\dfrac{z_e(r+l)}{r-l}}{-z_e}\)</span></li>
</ul></li>
<li><p>同理</p>
<ul>
<li><span class="math inline">\(y_n=\dfrac{\dfrac{2n}{t-b}y_e+\dfrac{z_e(t+b)}{t-b}}{-z_e}\)</span></li>
</ul></li>
<li><p>写成矩阵的形式</p>
<ul>
<li><p>为了计算的方便，我们把分母放到最终的齐次坐标化简中去</p></li>
<li><p><span class="math inline">\(w_c=-z_e,x_n=\dfrac{x_c}{w_c},y_n=\dfrac{y_c}{w_c}\)</span></p></li>
<li><p><span class="math display">\[
  \begin{bmatrix}
  \dfrac{2n}{r-l}&amp;0&amp;\dfrac{r+l}{r-l}&amp;0\\
  0&amp;\dfrac{2n}{t-b}&amp;\dfrac{t+b}{t-b}&amp;0\\
  \cdot&amp;\cdot&amp;\cdot&amp;\cdot\\
  0&amp;0&amp;-1&amp;0
  \end{bmatrix}
  \begin{bmatrix}
  x_e\\y_e\\z_e\\w_e
  \end{bmatrix}
  =
  \begin{bmatrix}
  x_c\\y_c\\z_c\\w_c
  \end{bmatrix}
  \]</span></p></li>
</ul></li>
</ul>
<h3 id="记录深度信息">(3) 记录深度信息</h3>
<p><span class="math display">\[
\begin{bmatrix}
\dfrac{2n}{r-l}&amp;0&amp;\dfrac{r+l}{r-l}&amp;0\\
0&amp;\dfrac{2n}{t-b}&amp;\dfrac{t+b}{t-b}&amp;0\\
0&amp;0&amp;A&amp;B\\
0&amp;0&amp;-1&amp;0
\end{bmatrix}
\begin{bmatrix}
x_e\\y_e\\z_e\\w_e
\end{bmatrix}
=
\begin{bmatrix}
x_c\\y_c\\z_c\\w_c
\end{bmatrix}
\]</span></p>
<ul>
<li><p>我们可以看到， <span class="math inline">\(z_n\)</span>
并没有被用上，我们可以用来记录深度信息</p></li>
<li><p><span class="math inline">\(z_n=\dfrac{z_c}{w_c}=\dfrac{Az_e+Bw_e}{w_c}=\dfrac{Az_e+B}{-z_e}=-A+\dfrac{B}{-z_e}\)</span></p></li>
<li><p><span class="math inline">\(z_e\in[{\color{red}-f},-n]\rightarrow
z_n\in[{\color{red}1},-1]\)</span></p>
<ul>
<li><span style="color:red;font-weight:bold">深度值越远越大</span></li>
</ul></li>
<li><p><span class="math display">\[
  \left\{
  \begin{array}{**lr**}
  1=-A+\dfrac{B}{f}\\
  -1=-A+\dfrac{B}{n}
  \end{array}
  \right.
  \Rightarrow
  \left\{
  \begin{array}{**lr**}
  A=-\dfrac{f+n}{f-n}\\
  B=-\dfrac{2nf}{f-n}
  \end{array}
  \right.
  \]</span></p></li>
</ul>
<h2 id="推导二变换角度">推导二：变换角度</h2>
<ul>
<li>错切+缩放+规范化</li>
</ul>
<h3 id="错切">(1) 错切</h3>
<ul>
<li>错切至关于 z 轴中心对称</li>
</ul>
<p><img src="/2021/01/31/CG/LS/05-1/projection_02.png" alt="1612084162326" style="zoom:50%;"></p>
<ul>
<li><span class="math inline">\(-x\)</span> 方向：<span class="math inline">\(\tan\theta_x=\dfrac{1}{2}\cdot\dfrac{l+r}{-n}\)</span>
<ul>
<li><span class="math inline">\(\Rightarrow
+x:\tan\theta_x&#39;=\dfrac{l+r}{2n}\)</span></li>
</ul></li>
<li><span class="math inline">\(-y\)</span> 方向：<span class="math inline">\(\tan\theta_y=\dfrac{1}{2}\cdot\dfrac{t+b}{-n}\)</span>
<ul>
<li><span class="math inline">\(\Rightarrow
+y:\tan\theta_y&#39;=\dfrac{t+b}{2n}\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
M_1=
\begin{bmatrix}
1&amp;0&amp;\dfrac{l+r}{2n}&amp;0\\
0&amp;1&amp;\dfrac{t+b}{2n}&amp;0\\
0&amp;0&amp;1&amp;0\\
0&amp;0&amp;0&amp;1
\end{bmatrix}
\]</span></p>
<h3 id="缩放">(2) 缩放</h3>
<ul>
<li>缩放的结果
<ul>
<li><span class="math inline">\(x:[l,r]\to[-1,1]\)</span></li>
<li><span class="math inline">\(y:[b,t]\to[-1,1]\)</span></li>
<li><span class="math inline">\(z:[{\color{red}-f},-n]\to
[{\color{red}-1},-\dfrac{f}{n}]\)</span>
<ul>
<li>因此，对应着投影平面 <span class="math inline">\(z=-1\)</span>
的是后裁剪面 <span class="math inline">\(z=-f\)</span></li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
M_2=
\begin{bmatrix}
\dfrac{2n}{(r-l)f}&amp;0&amp;0&amp;0\\
0&amp;\dfrac{2n}{(t-b)f}&amp;0&amp;0\\
0&amp;0&amp;\dfrac{1}{f}&amp;0\\
0&amp;0&amp;0&amp;1
\end{bmatrix}
\]</span></p>
<ul>
<li>等价于 <span class="math inline">\(M_2&#39;\)</span>（化成标准齐次坐标是一样的）</li>
</ul>
<p><span class="math display">\[
M_2&#39;=
\begin{bmatrix}
\dfrac{2n}{r-l)f}&amp;0&amp;0&amp;0\\
0&amp;\dfrac{2n}{t-b}&amp;0&amp;0\\
0&amp;0&amp;1&amp;0\\
0&amp;0&amp;0&amp;f
\end{bmatrix}
\]</span></p>
<ul>
<li>以上形成的视见体其实是一个棱台
<ul>
<li>顶点为 <span class="math inline">\((0,0,0)\)</span> 底面为 <span class="math inline">\((-1,-1,0),(-1,1,0),(1,1,0),(1,-1,0)\)</span>
的四棱锥被平面 <span class="math inline">\(z=-\dfrac{n}{f}\)</span>
截成的四棱锥</li>
</ul></li>
</ul>
<h3 id="透视平行">(3) 透视=&gt;平行</h3>
<ul>
<li>将透视投影的规范视见体变换为平行投影的规范视见体
<ul>
<li>将上述四棱锥转换为长方体</li>
<li><span class="math inline">\(x:[-1,1]\to[-1,1]\)</span></li>
<li><span class="math inline">\(y:[-1,1]\to[-1,1]\)</span></li>
<li><span class="math inline">\(z:[{\color{red}-1},-\dfrac{f}{n}]\to
[-1,0]\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
M_3=
\begin{bmatrix}
1&amp;0&amp;0&amp;0\\
0&amp;1&amp;0&amp;0\\
0&amp;0&amp;\dfrac{1}{1-n_{min}}&amp;\dfrac{n_{min}}{1-n_{min}}\\
0&amp;0&amp;-1&amp;0
\end{bmatrix}
\]</span></p>
<ul>
<li><span class="math inline">\(z_{min}\ge0\)</span></li>
</ul>
<p><span class="math display">\[
M_3=
\begin{bmatrix}
1&amp;0&amp;0&amp;0\\
0&amp;1&amp;0&amp;0\\
0&amp;0&amp;\dfrac{f}{f-n}&amp;\dfrac{n}{f-n}\\
0&amp;0&amp;-1&amp;0
\end{bmatrix}
\]</span></p>
<ul>
<li>推导过程和 <strong>推导一的投影</strong> 相似
<ul>
<li><span class="math inline">\(\dfrac{x_p}{z_p}=\dfrac{x_n}{-1},\dfrac{y_p}{z_p}=\dfrac{y_n}{-1}\)</span></li>
<li><span class="math inline">\(x_n=\dfrac{x_p}{-z_p},y_n=\dfrac{y_p}{-z_p}\)</span></li>
</ul></li>
<li>得到矩阵如下</li>
</ul>
<p><span class="math display">\[
M_3=
\begin{bmatrix}
1&amp;0&amp;0&amp;0\\
0&amp;1&amp;0&amp;0\\
\cdot&amp;\cdot&amp;\cdot&amp;\cdot\\
0&amp;0&amp;-1&amp;0
\end{bmatrix}
\]</span></p>
<ul>
<li>将第三行用于记录深度信息</li>
</ul>
<p><span class="math display">\[
M_3=
\begin{bmatrix}
1&amp;0&amp;0&amp;0\\
0&amp;1&amp;0&amp;0\\
0&amp;0&amp;A&amp;B\\
0&amp;0&amp;-1&amp;0
\end{bmatrix}
\]</span></p>
<ul>
<li><p><span class="math inline">\(z_n=\dfrac{Az_p+B}{-z_p}=-A+\dfrac{B}{-z_p}\)</span></p>
<ul>
<li><span class="math display">\[
  \left\{
  \begin{array}{**lr**}
  -1=-A+\dfrac{B}{1}\\
  0=-A+\dfrac{B}{n_{min}}
  \end{array}
  \right.
  \Rightarrow
  \left\{
  \begin{array}{**lr**}
  A=\dfrac{1}{1-n_{min}}\\
  B=\dfrac{n_{min}}{1-n_{min}}
  \end{array}
  \right.
  \]</span></li>
</ul></li>
</ul>
<h3 id="平移">(4) 平移</h3>
<ul>
<li><span class="math inline">\(x:[-1,-1]\to[-1,1]\)</span></li>
<li><span class="math inline">\(y:[-1,-1]\to[-1,1]\)</span></li>
<li><span class="math inline">\(z:[-1,0]\to
-[\dfrac{1}{2},\dfrac{1}{2}]\)</span></li>
</ul>
<p><span class="math display">\[
M_4=
\begin{bmatrix}
1&amp;0&amp;0&amp;0\\
0&amp;1&amp;0&amp;0\\
0&amp;0&amp;1&amp;\dfrac{1}{2}\\
0&amp;0&amp;0&amp;1
\end{bmatrix}
\]</span></p>
<h3 id="尺缩">(5) 尺缩</h3>
<ul>
<li><span class="math inline">\(x:[-1,-1]\to[-1,1]\)</span></li>
<li><span class="math inline">\(y:[-1,-1]\to[-1,1]\)</span></li>
<li><span class="math inline">\(z:[-\dfrac{1}{2},\dfrac{1}{2}]\to
[-1,1]\)</span></li>
</ul>
<p><span class="math display">\[
M_5=
\begin{bmatrix}
1&amp;0&amp;0&amp;0\\
0&amp;1&amp;0&amp;0\\
0&amp;0&amp;2&amp;0\\
0&amp;0&amp;0&amp;1
\end{bmatrix}
\]</span></p>
<h3 id="深度变换">(6) 深度变换</h3>
<ul>
<li>深度越大 <span class="math inline">\(z\)</span> 越大</li>
</ul>
<p><span class="math display">\[
M_6=
\begin{bmatrix}
1&amp;0&amp;0&amp;0\\
0&amp;1&amp;0&amp;0\\
0&amp;0&amp;-1&amp;0\\
0&amp;0&amp;0&amp;1
\end{bmatrix}
\]</span></p>
<h3 id="结果">(7) 结果</h3>
<ul>
<li>与上面一致</li>
</ul>
<p><span class="math display">\[
M_6M_5M_4M_3M_2&#39;M_1
\]</span></p>
]]></content>
      <categories>
        <category>CG.LS</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学.李胜.06.隐藏面的消除</title>
    <url>/2021/02/02/CG/LS/06/</url>
    <content><![CDATA[<h1 id="基本概念">基本概念</h1>
<ul>
<li>空间遮挡关系</li>
<li>隐藏面/线、可见面/线</li>
<li>不同模型
<ul>
<li><strong>表面模型</strong>：<strong>面消隐</strong></li>
<li><strong>线框模型</strong>：<strong>线消隐</strong></li>
</ul></li>
<li>深度
<ul>
<li>早期的深度：<strong>近大远小</strong></li>
<li>现在的深度：<strong>近小远大</strong></li>
<li>因此在消隐算法中会有初始化以及比大小的不同</li>
</ul></li>
</ul>
<h2 id="消隐的两类方法">消隐的两类方法</h2>
<ul>
<li>以像素为循环核心</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(窗口内的每一个像素) &#123;</span><br><span class="line">    确定距视点最近的物体;</span><br><span class="line">    用该物体表面的颜色显示像素;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以物体为循环核心</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(场景中的每一个物体) &#123;</span><br><span class="line">    将该物体与场景中的其它物体进行比较, 确定其表面的可见部分;</span><br><span class="line">    显示该物体表面的可见部分;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="提高消隐算法效率的常用方法">提高消隐算法效率的常用方法</h1>
<h2 id="利用连贯性">利用连贯性</h2>
<ul>
<li>物体、面、区域、扫描线</li>
</ul>
<h2 id="将透视投影变换为平行投影">将透视投影变换为平行投影</h2>
<ul>
<li>消隐与投影方式有关
<ul>
<li>投影中心位置，投影方向</li>
</ul></li>
<li>平行投影的遮挡关系更好确定</li>
<li>现代硬件的实现一般都是 <strong>z-buffer</strong></li>
</ul>
<h2 id="包围盒技术">包围盒技术</h2>
<ul>
<li>包围盒：包围目标的简单形体</li>
<li>常用包围盒：长方体、球、圆柱</li>
<li><strong>避免盲目求交</strong>
<ul>
<li>如果包围盒不相交，那么物体也一定不会相交</li>
<li>包围盒的求交比物体更加简单</li>
</ul></li>
<li>初级的筛查</li>
</ul>
<h2 id="常用的包围盒方法">常用的包围盒方法</h2>
<ul>
<li>OBB：面平行
<ul>
<li>紧致的包围盒</li>
<li>包围盒的所有面和物体切平面平行</li>
<li>可以使用 PCA 的方法找出主轴（3D有3根主轴）</li>
</ul></li>
<li>AABB：轴平齐
<ul>
<li>例如3D，包围盒的所有面都是和轴垂直的简单，不准确</li>
</ul></li>
</ul>
<p><img src="/2021/02/02/CG/LS/06/OBB-AABB.png"></p>
<ul>
<li>k-DoP：划分为多个轴，每个轴向找切线</li>
</ul>
<p><img src="/2021/02/02/CG/LS/06/4-DoP-2D.png" alt="1612319866629" style="zoom:70%;"></p>
<p><img src="/2021/02/02/CG/LS/06/8-DoP-2D.png" alt="1612319889825" style="zoom:70%;"></p>
<ul>
<li>层次包围盒
<ul>
<li>树状结构</li>
<li>包围盒套包围盒</li>
<li>从根出来进行逐个判断，提高效率</li>
</ul></li>
</ul>
<h2 id="背面剔除">背面剔除</h2>
<ul>
<li>前向面和后向面（背面）
<ul>
<li>背面是不可见的</li>
</ul></li>
<li>使用法向判断</li>
<li>需要指定 FrontFace
<ul>
<li>顺时针（CW）clockwise</li>
<li>逆时针（CCW）counterclockwise</li>
</ul></li>
</ul>
<h2 id="空间分割技术">空间分割技术</h2>
<ul>
<li>并行渲染</li>
</ul>
<h2 id="物体的分层表示">物体的分层表示</h2>
<ul>
<li>小汽车
<ul>
<li>车身
<ul>
<li>车头</li>
<li>车尾</li>
</ul></li>
<li>左前轮</li>
<li>左后轮</li>
<li>右后轮</li>
<li>右前轮</li>
</ul></li>
</ul>
<h1 id="消隐算法">消隐算法</h1>
<ul>
<li>消隐的基本（核心）问题：<span style="color:red;font-weight:bold">排序</span></li>
<li>整体排序：画家算法</li>
<li>点排序：z-buffer算法、光线投射算法</li>
<li>区间排序：扫描线算法</li>
<li>区域排序：区域子分算法</li>
</ul>
<h2 id="画家算法">画家算法</h2>
<ul>
<li><p>3D 待绘制的物体进行排序，<strong>远处先画，近处后画</strong></p>
<ul>
<li>对场景中的多边形按深度进行排序</li>
<li>形成深度优先级表</li>
<li>按从远到近的顺序显示多边形</li>
</ul></li>
<li><p>一维空间（数轴）上点的排序</p></li>
<li><p>二维平面上直线段的排序</p>
<ul>
<li>两条直线段可能相交
<ul>
<li>分类讨论，包围盒</li>
</ul></li>
</ul>
<p><img src="/2021/02/02/CG/LS/06/2D-sort.png" alt="1612321712197" style="zoom:70%;"></p></li>
<li><p>三维空间中多边形的排序</p>
<ul>
<li>连环套问题
<ul>
<li>解套：拆分单个面片</li>
</ul></li>
</ul>
<p><img src="/2021/02/02/CG/LS/06/3D-sort.png" alt="1612322086268" style="zoom:70%;"></p></li>
</ul>
<h2 id="z-buffer-算法">z-buffer 算法</h2>
<ul>
<li>窗口与缓冲器
<ul>
<li>绘图窗口</li>
<li>帧缓冲器：存放对应像素的颜色</li>
<li>z（深度）缓冲器：存放对应像素的深度值</li>
</ul></li>
<li>z 缓冲器算法
<ul>
<li>初始化所有像素深度值为 1（最大深度），颜色值为背景色</li>
<li>对多边形的投影区域的每一个像素循环
<ul>
<li>逐像素比较深度，若小于 z-buffer 中存的深度，则更新两个缓冲器</li>
</ul></li>
</ul></li>
<li>优点
<ul>
<li>算法简单、稳定</li>
<li>便于硬件加速</li>
<li>不需要整个场景的几何数据</li>
</ul></li>
<li>缺点
<ul>
<li>需要 z 缓冲器</li>
<li>计算复杂度大
<ul>
<li>需要计算的像素深度值次数 = 多边形个数*多边形平均占据的像素个数</li>
</ul></li>
</ul></li>
</ul>
<h2 id="扫描线-z-buffer-算法">扫描线 z-buffer 算法</h2>
<ul>
<li><p>经典但是过时的算法</p></li>
<li><p>早期在 z-buffer 数量不够时提出的算法</p></li>
<li><p>需要的 z-buffer 数目从原来的<span style="color:red;font-weight:bold">整个窗口</span>减少到<span style="color:red;font-weight:bold">一条扫描线</span></p>
<ul>
<li>随着技术发展，z-buffer
已经不再是稀缺资源，可以支持整个窗口，因此现在很少用</li>
</ul></li>
<li><p>扫描线 z-buffer 算法</p>
<ul>
<li>将窗口划分为多条扫描线
<ul>
<li>初始化扫描线对应的两个缓冲器</li>
<li>对每个多边形循环
<ul>
<li>求出每个多边形的投影区域与扫描线的的相交区间</li>
<li>比较深度与对应像素在 z-buffer
中的深度值，看是否需要更新两个缓冲器</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>复杂度高</p>
<ul>
<li>每一条扫描线都需要和多边形进行相交测试</li>
<li>需要计算相交区间的深度值</li>
</ul></li>
</ul>
<h3 id="数据结构">数据结构</h3>
<h4 id="多边形顶点数组">(1) 多边形顶点数组</h4>
<ul>
<li>二维数组 <span class="math inline">\(P[i][j]\)</span>，元素是三维坐标
<ul>
<li>第 i 个多边形的第 j 个顶点</li>
</ul></li>
</ul>
<h4 id="多边形">(2) 多边形</h4>
<ul>
<li>平面信息：a,b,c,d</li>
<li>多边形所在平面：<span class="math inline">\(f(u,v,n)=au+bv+cn+d=0\)</span></li>
<li>多边形颜色值：color</li>
<li>投影的最大 v 坐标：<span class="math inline">\(v_{max}\)</span></li>
<li>多边形的序号：PI</li>
<li>指向下一个多边形结构的指针：nextP</li>
</ul>
<h4 id="多边形分类表-pt">(3) 多边形分类表 PT</h4>
<ul>
<li>一维数组，长度等于绘图窗口内扫描线的数目，元素为多边形</li>
<li>如果一个多边形的投影的最小 v 坐标为 v，那么它就属于 v 类</li>
</ul>
<h4 id="活化多边形表-apl">(4) 活化多边形表 APL</h4>
<ul>
<li>记录投影与当前扫描线相交的多边形</li>
<li>多边形在 APL 中的顺序无关紧要</li>
</ul>
<h4 id="边">(5) 边</h4>
<ul>
<li>用于记录多边形的一条边</li>
<li>边结构
<ul>
<li>边投影<strong>上</strong>端点的 v 坐标：<span class="math inline">\(v_{max}\)</span></li>
<li>边投影<strong>下</strong>端点的 u 坐标：u</li>
<li>边投影<strong>下</strong>端点的 n 坐标：n</li>
<li>在该边上 v 值增加一个单位时，u 坐标的变化量：<span class="math inline">\(\Delta u\)</span></li>
<li>指向下一个边结构的指针：nextE</li>
</ul></li>
</ul>
<h4 id="边分类表-et">(6) 边分类表 ET</h4>
<ul>
<li>当一个多边形<strong>进入</strong>活化多边形表的时候，需要为其建立一个边分类表
<ul>
<li>不处理的就不需要建立了</li>
</ul></li>
<li>对非水平边进行分类的一维数组</li>
<li>一维数组，长度等于扫描线的数目，元素为边</li>
<li>若一条边的下端点的 v 坐标为 v，则将该边归为第 v 类</li>
</ul>
<h4 id="边对">(7) 边对</h4>
<ul>
<li>在一条扫描线上，同一多边形的相邻两条边称为边对</li>
</ul>
<p><img src="/2021/02/02/CG/LS/06/edge-pair.jpg"></p>
<ul>
<li>扫描线 3 对应的边对：<span class="math inline">\(e_0e_1\)</span></li>
<li>扫描线 6 对应的边对：<span class="math inline">\(e_0e_4,e_3e_2\)</span></li>
<li>边对中包含了大量信息，是该消隐算法的核心单元</li>
</ul>
<h5 id="边对包含信息">边对包含信息</h5>
<ul>
<li><span class="math inline">\(u_l\)</span>：边对左侧边与扫描线交点的 u
坐标</li>
<li><span class="math inline">\(\Delta u_l\)</span>：当沿左侧边 v
坐标递增一个像素时，u 坐标的增量</li>
<li><span class="math inline">\(v_{lmax}\)</span>：左侧边投影的上端点的
v 坐标</li>
<li><span class="math inline">\(u_r,\Delta u_r,v_{rmax}\)</span></li>
<li><span class="math inline">\(n_l\)</span>：左侧边与扫描线的交点处的多边形的 n
坐标（深度）</li>
<li><span class="math inline">\(\Delta n_u\)</span>：当沿着扫描线 u
递增一个像素时，多边形所在平面的 n 坐标的增量
<ul>
<li><span class="math inline">\(f(u,v,n)=au+bv+cn+d=0\Rightarrow\Delta
n_u=\dfrac{-a}{c}(c\ne0)\)</span></li>
</ul></li>
<li><span class="math inline">\(\Delta
n_v=\dfrac{-b}{c}(c\ne0)\)</span></li>
<li>PI：多边形序号</li>
<li>nextEP：指向下一个边对结构的指针，用于将边连接成链表</li>
</ul>
<h4 id="活化边对表-aepl">(8) 活化边对表 AEPL</h4>
<ul>
<li>记录了活化多边形表中与当前扫描线相交的边对（顺序无关紧要）</li>
</ul>
<h3 id="算法">算法</h3>
<ul>
<li><p>建立多边形分类表 PT</p></li>
<li><p>置活化多边形表 APL 为空，置活化边对表为空</p></li>
<li><p>对每条扫描线执行以下操作</p>
<ul>
<li>置帧缓冲器第 v 行的各单元为背景色</li>
<li>置 z 缓冲器个单元的值为 1（最大的深度值）</li>
<li>检查 PT 的第 v 类是否非空，如果非空，则将该类的多边形去除加入到 APL
中</li>
<li>对新加入 APL 的每个多边形，为其建立边分类表 ET</li>
<li>对新加入 APL 的每个多边形，若他的 ET 中第 v
类非空，将其中的边对出插入 APEL 中</li>
<li>对 APEL 中的每一个边对，执行以下步骤</li>
</ul>
<p><span class="math display">\[
  \begin{aligned}
  &amp;深度值 n=n_l\\
  &amp;for(u = u_l; u &lt;= u_r; u = u + 1) \{\\
  &amp;\qquad if(n &lt; z 缓冲器中第 u 个单元的深度值) \{\\
  &amp;\qquad\qquad 置帧缓冲器第 (u,v)
单元的值为当前便对所属的多边形的颜色;\\
  &amp;\qquad\qquad 置 z 缓冲器第 u 单元的值为 n;\\
  &amp;\qquad\}\\
  &amp;\qquad n = n + \Delta n_u; // 计算下一个像素 (u + 1,v)
处的深度值\\
  &amp;\}\\
\end{aligned}
  \]</span></p>
<ul>
<li>检查 APL，删除那些满足 <span class="math inline">\(v=v_{max}\)</span> 的多边形，释放该多边形的
ET，并从 AEPL 中删除属于该多边形的边对</li>
<li>检查 AEPL 中的边对，执行以下步骤
<ul>
<li>若 <span class="math inline">\(v_{lmax}=v\)</span> 或者 <span class="math inline">\(v_{rmax}=v\)</span> ，删除边对的左侧边或者右侧边
<ul>
<li>若边对的左侧边和右侧边都被删除了，则从 AEPL 中将这个边对删去</li>
<li>若边对只被删去一条边，那么从其所属的多边形找另一条边和其配对成为新的边对，加入
APEL</li>
</ul></li>
</ul></li>
<li>将扫描线向下移动一个像素 v = v + 1</li>
</ul></li>
</ul>
<h3 id="算法说明">算法说明</h3>
<ul>
<li>一定配对
<ul>
<li>一条直线和封闭多边形相交的边数为偶数（不计直线和多边形顶点的相交）</li>
</ul></li>
<li>删除 AEPL 中的边对
<ul>
<li>扫描线<strong>从下向上</strong>移动</li>
<li>删除时整个边对之间的区域都被上色了</li>
</ul></li>
</ul>
<h3 id="评价">评价</h3>
<ul>
<li>和 z 缓冲器相比改进的地方
<ul>
<li>将窗口分割成扫描线，只需要一条扫描线的 z-buffer</li>
<li>采用多边形分类表、活化多边形表避免多边形与扫描线的盲目求交</li>
<li>利用边、边的分类表、边对、活化边对表避免边与扫描线的盲目求交</li>
<li>利用连贯性计算深度</li>
</ul></li>
<li>缺点
<ul>
<li>在每一个被多边形覆盖像素处需要计算深度值</li>
<li>被多个多边形覆盖的像素需要多次计算深度值</li>
</ul></li>
</ul>
<h2 id="扫描线算法">扫描线算法</h2>
<ul>
<li><p>相较于 z-buffer 扫描线算法的改进</p>
<ul>
<li>在一条扫描线上，以区间为单位确定多边形的可见性
<ul>
<li>在一条扫描线上，每个区间只需要计算一次深度值</li>
</ul></li>
<li>不需要 z-buffer</li>
</ul></li>
<li><p>算法思想</p>
<ul>
<li>两个多边形（记作 <span class="math inline">\(P_1,P_2\)</span>）
的边界将扫描线分割为多个区间</li>
<li>覆盖每段区间的多边形可能有 0 个或者多个，但是只有一个可见</li>
<li>因此对于每段区间，我们只需要任取一个点，计算深度，找到深度最小的点，用它所在多边形的颜色为当前像素点上色即可（帧缓冲器）</li>
</ul></li>
<li><p>算法局限</p>
<ul>
<li>要求多边形不能相互贯穿</li>
</ul>
<p><img src="/2021/02/02/CG/LS/06/scanline.png"></p>
<ul>
<li>否则需要计算多边形相交的点作分界（让算法复杂度变高）</li>
<li>如上图
<ul>
<li>区间 <span class="math inline">\([0,u_1],[u_1,u_2],[u_2,u_3],[u_3,u_4],[u_4,u_{max}]\)</span></li>
<li>出现贯穿的情况，在区间 <span class="math inline">\(,[u_2,u_3]\)</span> 中出现深度变化</li>
</ul></li>
</ul></li>
</ul>
<h2 id="区域子分算法">区域子分算法</h2>
<ul>
<li>不把像素孤立起来看待，考虑<strong>区域连贯性</strong>
<ul>
<li>扫描线算法中的区间本质也是一种对于区域连贯性的考虑</li>
</ul></li>
<li>利用区域的连贯性提高排序的效率
<ul>
<li>分割窗口直到窗口足够简单</li>
</ul></li>
<li>窗口足够简单：满足以下几种条件之一即可
<ul>
<li>窗口为空：所有多边形和当前窗口的关系都是<strong>分离</strong></li>
<li>窗口内仅包含一个多边形：仅有一个多边形与当前窗口<strong>相交</strong>或者<strong>包含</strong>于当前窗口</li>
<li>窗口被一个多边形<strong>包围</strong>，并且它是离视点最近的</li>
</ul></li>
<li><strong>四叉树</strong></li>
</ul>
<h2 id="光线投射算法">光线投射算法</h2>
<ul>
<li>基本问题：光线与物体表面求交</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(v = <span class="number">0</span>; v &lt;= vmax; v++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(u = <span class="number">0</span>; u &lt;= umax; u++) &#123;</span><br><span class="line">        形成通过像素(u,v)的投影线;</span><br><span class="line">        <span class="keyword">for</span>(场景中的每一个多边形)&#123;</span><br><span class="line">            将投影线与多边形求交;</span><br><span class="line">            <span class="keyword">if</span>(有交点) &#123;</span><br><span class="line">                以最近交点所属多边形的颜色显示像素(u,v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                以背景颜色显示像素(u,v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>特殊情况
<ul>
<li>光线穿越物体的边缘 / 顶点</li>
<li>需要自己定义 visible / invisible</li>
</ul></li>
</ul>
<h1 id="半透明问题">(半)透明问题</h1>
<ul>
<li>z-buffer test：用于确定物体的深度关系</li>
<li>如果物体透明怎么办？</li>
<li>顺序？
<ul>
<li>需要考虑混合顺序：排序</li>
<li>去除透明物体，融合半透明物体与最近的不透明物体</li>
</ul></li>
</ul>
<p><img src="/2021/02/02/CG/LS/06/transparent.png"></p>
<ul>
<li>排序
<ul>
<li>order dependent transparency：物体级别的排序
<ul>
<li>显式对物体进行排序</li>
</ul></li>
<li>order independent transparency：片元级别的排序</li>
</ul></li>
</ul>
<h2 id="a-buffer-算法">A-buffer 算法</h2>
<ul>
<li>order dependent transparency</li>
<li>对于每个像素，形成一个链表结构
<ul>
<li>链表内按照深度排序，之后可以通过类似于之前的方式进行上色</li>
</ul></li>
</ul>
<h2 id="depth-peeling-深度剥离">Depth Peeling 深度剥离</h2>
<ul>
<li>order independent transparency</li>
<li>多次渲染
<ul>
<li>每次渲染去除之前已经渲染的片元，把剩下的片元都当作不透明的处理</li>
<li>相当于每次渲染得到深度最小的片元结果，将其存到一个 buffer 里面</li>
<li>最后融合这些 buffer</li>
</ul></li>
<li>浪费了大量片元，大量空间都是空白的</li>
</ul>
<h2 id="半透明顺序">半透明顺序</h2>
<ul>
<li>如提前知道半透明的顺序，直接排序即可</li>
<li>如果不知道，可以使用 A-buffer 或者 Depth Peeling 等算法</li>
</ul>
<h2 id="dual-depth-peeling-双向深度剥离">Dual Depth Peeling
双向深度剥离</h2>
<ul>
<li>渲染次数减半</li>
</ul>
<h2 id="光线跟踪">光线跟踪</h2>
<ul>
<li><strong>非传统渲染管线</strong></li>
<li>直接考虑了半透明的信息</li>
</ul>
]]></content>
      <categories>
        <category>CG.LS</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学.李胜.05.投影(1)</title>
    <url>/2021/01/29/CG/LS/05/</url>
    <content><![CDATA[<h1 id="三维图形的基本问题">三维图形的基本问题</h1>
<ul>
<li>在二维屏幕上显示三维物体
<ul>
<li><strong>投影</strong></li>
</ul></li>
<li>三维形体的表示
<ul>
<li><strong>各种用于形体表示的理论、模型、方法</strong></li>
</ul></li>
<li>反映遮挡关系
<ul>
<li><strong>消除隐藏面与隐藏线</strong></li>
</ul></li>
<li>产生真实感图形
<ul>
<li><strong>建立光照明模型、开发真实感图形绘制方法</strong></li>
</ul></li>
</ul>
<h1 id="平面几何投影">平面几何投影</h1>
<ul>
<li>投影
<ul>
<li>将 n 维的店变换成小于 n 维的点</li>
<li>3 =&gt; 2</li>
</ul></li>
<li>投影中心
<ul>
<li><strong>COP</strong>：Center Of Projection</li>
<li>视觉系统：观察点、视点</li>
<li>电影放映机：光源</li>
</ul></li>
<li>投影平面
<ul>
<li>又称为观察平面 VP（View Plane）</li>
<li><strong>不经过投影中心</strong></li>
<li>平面（照相机底片），曲面（球幕电影、视网膜）</li>
</ul></li>
<li>投影线
<ul>
<li>从投影中心向物体上各点发出的射线</li>
<li>直线：光线</li>
<li>曲线：光线跟踪</li>
</ul></li>
<li>平面几何投影
<ul>
<li>投影面为平面</li>
<li>投影线为直线</li>
<li>包括透视投影和平行投影
<ul>
<li><strong>透视投影</strong>：投影中心与投影平面之间的距离<strong>有限</strong></li>
<li><strong>平行投影</strong>：投影中心与投影平面之间的距离<strong>无限</strong></li>
</ul></li>
</ul></li>
<li>透视投影
<ul>
<li><strong>灭点</strong>：不平行于投影平面的平行线，经过透视投影之后收敛于一点，称为灭点</li>
<li><strong>主灭点</strong>：平行于坐标轴的平行线的灭点</li>
<li>按照主灭点个数分类
<ul>
<li>一点透视：投影平面平行于 xOy 平面</li>
<li>两点透视：投影平面平行于 y 轴，与 x、z 轴都有交点</li>
<li>三点透视：投影平面与 x、y、z 轴都有交点</li>
</ul></li>
<li>产生<strong>近大远小</strong>的视觉效果，由它产生的<strong>图形深度感强</strong>，看起来更加真实</li>
</ul></li>
<li>《最后的晚餐》：只有一个主灭点，耶稣的头部</li>
<li>平行投影</li>
<li>正投影与斜投影
<ul>
<li>正投影：投影方向<strong>垂直</strong>于投影平面</li>
<li>斜投影：投影方向<strong>不垂直</strong>投影平面</li>
</ul></li>
<li>三视图
<ul>
<li>正视图、侧视图、俯视图</li>
<li><span style="color:red;font-weight:bold">不能无误的重现原模型</span></li>
</ul></li>
</ul>
<h1 id="观察坐标系中的投影变换">观察坐标系中的投影变换</h1>
<ul>
<li><p>观察坐标系：</p>
<ul>
<li><strong>VRC</strong>：View Reference Coordinate</li>
<li>照相机所在坐标系</li>
</ul></li>
<li><p>建立观察坐标系</p>
<ul>
<li><p>坐标原点：<strong>VRP</strong>（View Reference Point）</p>
<ul>
<li>聚焦参考点与投影平面上的投影</li>
</ul></li>
<li><p>n 轴</p>
<ul>
<li>照相机的镜头方向（<strong>投影平面的法向</strong>）</li>
</ul></li>
<li><p>v 轴</p>
<ul>
<li>照相机向上的方向（<strong>观察正向 VUP
在投影平面的投影</strong>）</li>
</ul></li>
<li><p>u 轴</p>
<ul>
<li><p><span class="math inline">\(u=v\times n\)</span></p></li>
<li><p>叉乘转化为矩阵</p>
<ul>
<li><p><span class="math inline">\(\vec{a}\times\vec{b}=(a_2b_3-b_2a_3,a_3b_1-b_3a_1,a_1b_2-b_1a_2)\)</span></p>
<ul>
<li><span class="math inline">\((a_1\vec{i}+a_2\vec{j}+a_3\vec{k})\times(b_1\vec{i}+b_2\vec{j}+b_3\vec{k})\)</span>
展开即可</li>
</ul></li>
<li><p><span class="math display">\[
  \begin{bmatrix}
  0 &amp; -a_3 &amp; a_2 \\
  a_3 &amp; 0 &amp; -a_1 \\
  -a_2 &amp; a_1 &amp; 0
  \end{bmatrix}
  \begin{bmatrix}
  b_1 \\
  b_2 \\
  b_3
  \end{bmatrix}
  \]</span></p></li>
</ul></li>
</ul></li>
</ul></li>
<li><p><span class="math inline">\((u,v,n)\)</span></p></li>
<li><p>投影平面：<span class="math inline">\(n=0\)</span></p></li>
<li><p>投影中心：<span class="math inline">\((0,0,d)\)</span></p></li>
<li><p>视见体：三维裁剪窗口</p>
<ul>
<li>6 个裁剪面</li>
</ul></li>
<li><p>投影参考点：<strong>PRP</strong>（Projection Reference
Point）</p>
<ul>
<li>透视投影：COP = PRP</li>
<li>平行投影：投影方向（DOP）= 窗口中心 CW 和 PRP 的连线</li>
</ul></li>
<li><p>投影参数表</p></li>
</ul>
<table>
<colgroup>
<col style="width: 26%">
<col style="width: 73%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">参数</th>
<th style="text-align: center;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">投影类型</td>
<td style="text-align: center;">定义投影是平行投影还是透视投影</td>
</tr>
<tr class="even">
<td style="text-align: center;">观察参考点 <span class="math inline">\(VRP\)</span></td>
<td style="text-align: center;">在世界坐标系中指定，为观察坐标系原点</td>
</tr>
<tr class="odd">
<td style="text-align: center;">观察平面法向 <span class="math inline">\(VPN\)</span></td>
<td style="text-align: center;">在世界坐标系中指定，为观察坐标的 <span class="math inline">\(n\)</span> 轴</td>
</tr>
<tr class="even">
<td style="text-align: center;">观察正向 <span class="math inline">\(VUP\)</span></td>
<td style="text-align: center;">在世界坐标系中指定，确定观察坐标系的
<span class="math inline">\(v\)</span> 轴</td>
</tr>
<tr class="odd">
<td style="text-align: center;">投影参考点 <span class="math inline">\(PRP\)</span></td>
<td style="text-align: center;">在观察坐标系中指定确定投影中心或投影方向</td>
</tr>
<tr class="even">
<td style="text-align: center;">前裁剪面裁距 <span class="math inline">\(F\)</span></td>
<td style="text-align: center;">在观察坐标系中指定，<span class="math inline">\(n=F\)</span> 为前裁剪面</td>
</tr>
<tr class="odd">
<td style="text-align: center;">后裁剪面裁距 <span class="math inline">\(B\)</span></td>
<td style="text-align: center;">在观察坐标系中指定，<span class="math inline">\(n=B\)</span> 为后裁剪面</td>
</tr>
<tr class="even">
<td style="text-align: center;">窗口 <span class="math inline">\(u_{min},u_{max},v_{min},v_{max}\)</span></td>
<td style="text-align: center;">在观察坐标系的uv平面上指定，确定窗口与视见体</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>窗口不一定关于原点对称</strong></li>
</ul>
<h2 id="三维空间直线参数方程">三维空间直线参数方程</h2>
<ul>
<li>过顶点 <span class="math inline">\(A(x_0,y_0,z_0)\)</span>，方向向量
<span class="math inline">\((m,n,p)\)</span>，直线参数方程如下</li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{**lr**}
x=t(m-x_0)+x_0\\
y=t(n-y_0)+y_0\\
z=t(p-z_0)+z_0
\end{array}
\right.or
\left\{
\begin{array}{**lr**}
x=tm+x_0\\
y=tn+y_0\\
z=tp+z_0
\end{array}
\right.
\]</span></p>
<h2 id="透视投影变换求解">透视投影变换求解</h2>
<ul>
<li><p>投影中心<span class="math inline">\((0,0,d)\)</span>，待投影点
<span class="math inline">\(P(u_p,v_p,n_p)\)</span>，求解在投影平面
<span class="math inline">\(n=0\)</span> 的投影点 <span class="math inline">\(Q(u_q,v_q,n_q)\)</span></p></li>
<li><p>投影线的参数方程（经过投影中心<span class="math inline">\((0,0,d)\)</span>） <span class="math display">\[
  \left\{
  \begin{array}{**lr**}
  u=tu_p &amp;  \\
  v=tv_p &amp; t\ge 0\\
  n=t(n_p-d)+d &amp;
  \end{array}
  \right.
  \]</span></p></li>
<li><p>求解，令 <span class="math inline">\(n=0\)</span></p></li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{**lr**}
u_q=\dfrac{u_p}{1-\dfrac{n_p}{d}} \\
v_q=\dfrac{v_p}{1-\dfrac{n_p}{d}} \\
n_q=0
\end{array}
\right.
\]</span></p>
<ul>
<li>将其写作矩阵形式 <span class="math inline">\(Q=M_{per}P\)</span>
<ul>
<li>注意得到的结果需要进行标准化 <span class="math inline">\(h\ne
1\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; -\dfrac{1}{d} &amp;1\\
\end{bmatrix}
\]</span></p>
<h2 id="平行投影变换求解">平行投影变换求解</h2>
<ul>
<li>投影平面 <span class="math inline">\(n=0\)</span>，投影方向 <span class="math inline">\((0,0,-1)\)</span>，待投影点为 <span class="math inline">\(P(u_p,v_p,n_p)\)</span>，求投影点 <span class="math inline">\(Q(u_q,v_q,n_q)\)</span></li>
<li><span class="math inline">\(Q(u_p,v_p,0)\)</span></li>
<li>将其写作矩阵形式 <span class="math inline">\(Q=M_{ori}P\)</span></li>
</ul>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}
\]</span></p>
<ul>
<li><span class="math inline">\(\lim_\limits{d\to\infty}M_{per}=M_{ori}\)</span></li>
</ul>
<h1 id="世界坐标系wc到观察坐标系vrc的变换">世界坐标系WC到观察坐标系VRC的变换</h1>
<ul>
<li>条件
<ul>
<li>WC：xyz，VRC：uvn</li>
<li><strong>VRC</strong> 的坐标原点 <strong>VRP</strong> <span class="math inline">\((VRP_x,VRP_y,VRP_z)\)</span></li>
<li>投影平面法向 <span class="math inline">\(\vec{VPN}\)</span></li>
<li>观察正向 <span class="math inline">\(\vec{VUP}\)</span></li>
</ul></li>
<li>做如下记号</li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{**lr**}
\vec{n}=\dfrac{\vec{VPN}}{|\vec{VPN}|}=[n_x,n_y,n_z]\\
\vec{u}=\dfrac{\vec{VUP}\times\vec{VPN}}{|\vec{VUP}\times\vec{VPN}|}=[u_x,u_y,u_z]
\\
\vec{v}=\vec{n}\times\vec{u}
\end{array}
\right.
\]</span></p>
<ul>
<li>先平移后旋转</li>
</ul>
<p><span class="math display">\[
M_{WC\to VRC}=
\begin{bmatrix}
u_x &amp; u_y &amp; u_z &amp; 0\\
v_x &amp; v_y &amp; v_z &amp; 0\\
n_x &amp; n_y &amp; n_z &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; -VRP_x\\
0 &amp; 1 &amp; 0 &amp; -VRP_y\\
0 &amp; 0 &amp; 1 &amp; -VRP_z\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}
=RT
\]</span></p>
<ul>
<li><p>证明1：直接通过线性代数的知识，两个空间的正交变换为 <span class="math inline">\(R\)</span></p>
<ul>
<li>直接验证结果也是显然正确的</li>
</ul></li>
<li><p>证明2：参考《计算机图形学 倪眀田 吴良芝》P143-145</p>
<ul>
<li><p>平移变换显然，我们只考虑两个坐标系的原点相同旋转部分</p></li>
<li><p>通过解构的方法证明</p></li>
<li><p>步骤如下</p>
<p><img src="/2021/01/29/CG/LS/05/001.jpg" style="zoom:Infinity%;"></p>
<ul>
<li><p>绕 x 轴旋转角度 <span class="math inline">\(\theta_x\)</span>
使得 n 轴落于 xOz 平面 <span class="math display">\[
  \cos\theta_x=\dfrac{n_z}{\sqrt{n_y^2+n_z^2}},\qquad
  \sin\theta_x=\dfrac{n_y}{\sqrt{n_y^2+n_z^2}}
  \]</span></p></li>
<li><p>绕 y 轴旋转角度 <span class="math inline">\(\theta_y\)</span>
使得 n 轴和 z 轴同向且重合 <span class="math display">\[
  \cos\theta_y=\sqrt{n_y^2+n_z^2},\qquad
      \sin\theta_y=n_x
  \]</span></p></li>
<li><p>绕 z 轴旋转角度 <span class="math inline">\(\theta_z\)</span>
使得 u 轴和 x 轴同向且重合</p>
<ul>
<li><p>这一部分比较麻烦，可以先用上面的变换得到在世界坐标系中单位向量对应的点
<span class="math inline">\(\vec{u}\)</span> 的位置</p></li>
<li><p>注意有</p>
<ul>
<li><span class="math inline">\(\vec{u}\cdot\vec{n}=u_xn_x+u_yn_y+u_zn_z=0\)</span></li>
<li><span class="math inline">\(\vec{n}\times\vec{u}=(n_yu_z-u_yn_z,n_zu_x-u_zn_x,n_xu_y-u_xn_y)=(v_x,v_y,v_z)\)</span></li>
</ul></li>
<li><p><span class="math display">\[
  R_y(\theta_y)=
    \begin{bmatrix}
    \sqrt{n_y^2+n_z^2} &amp; 0 &amp; -n_x &amp; 0\\
    0 &amp; 1 &amp; 0 &amp; 0\\
    n_x &amp; 0 &amp; \sqrt{n_y^2+n_z^2} &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 1\\
    \end{bmatrix}\\
  \]</span></p></li>
<li><p><span class="math display">\[
  R_x(\theta_x)=
    \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0\\
    0 &amp; \dfrac{n_z}{\sqrt{n_y^2+n_z^2}} &amp;
-\dfrac{n_y}{\sqrt{n_y^2+n_z^2}} &amp; 0\\
    0 &amp; \dfrac{n_y}{\sqrt{n_y^2+n_z^2}} &amp;
\dfrac{n_z}{\sqrt{n_y^2+n_z^2}} &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 1\\
    \end{bmatrix}\\
  \]</span></p></li>
<li><p><span class="math display">\[
  R_y(\theta_y)R_x(\theta_x)=
    \begin{bmatrix}
    \sqrt{n_y^2+n_z^2} &amp; -\dfrac{n_xn_y}{\sqrt{n_y^2+n_z^2}} &amp;
-\dfrac{n_xn_z}{\sqrt{n_y^2+n_z^2}} &amp; 0\\
    0 &amp; \dfrac{n_z}{\sqrt{n_y^2+n_z^2}} &amp;
-\dfrac{n_y}{\sqrt{n_y^2+n_z^2}} &amp; 0\\
    n_x &amp; n_y &amp; n_z &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 1\\
    \end{bmatrix}
  \]</span></p></li>
<li><p><span class="math display">\[
\vec{u}=R_y(\theta_y)R_x(\theta_x)\begin{bmatrix}
       u_x\\ u_y\\ u_z\\ 1
       \end{bmatrix}
       =
       \begin{bmatrix}
       \dfrac{u_x}{\sqrt{n_y^2+n_z^2}}\\
       \dfrac{u_yn_z-u_zn_y}{\sqrt{n_y^2+n_z^2}}\\
       0\\
       1\\
       \end{bmatrix}
\]</span></p></li>
<li><p>此时的 <span class="math inline">\(|\vec{u}|=1\)</span>，旋转不改变长度</p>
<ul>
<li>那么同时就会有 <span class="math inline">\(u_x^2+v_x^2+n_x^2=1\)</span></li>
</ul></li>
<li><p>或者直接计算</p>
<ul>
<li><p><span class="math display">\[
  \begin{aligned}
  &amp;u_x^2+(u_yn_z-u_zn_y)^2 \\
  =\ &amp;u_x^2+v_x^2\\
  &amp; u_x^2+(u_yn_z-u_zn_y)^2 \\
  =\ &amp;u_x^2+u_y^2n_z^2+u_z^2n_y^2-2n_yu_yn_zu_z\\
  =\
&amp;u_x^2+u_y^2(1-n_x^2-n_y^2)+u_z^2(1-n_x^2-n_z^2)-2n_yu_yn_zu_z\\
  =\ &amp;1-u_y^2n_x^2-u_y^2n_y^2-u_z^2n_x^2-u_z^2n_z^2-2n_yu_yn_zu_z\\
  =\ &amp;1-u_y^2n_x^2-u_z^2n_x^2-(u_yn_y+u_zn_z)^2\\
  =\ &amp;1-u_y^2n_x^2-u_z^2n_x^2-(u_xn_x)^2\\
  =\ &amp;1-n_x^2\\
  \end{aligned}
  \]</span></p></li>
<li><p><span class="math inline">\(\Rightarrow
u_x^2+v_x^2+n_x^2=1\)</span></p></li>
</ul></li>
<li><p>此时可以推导出 <span class="math inline">\(\theta_z\)</span></p></li>
<li><p><span class="math display">\[
\cos(-\theta_z)=\dfrac{u_x}{\sqrt{n_y^2+n_z^2}}
\]</span></p></li>
<li><p><span class="math display">\[
\sin(-\theta_z)=\dfrac{u_yn_z-u_zn_y}{\sqrt{n_y^2+n_z^2}}
\]</span></p></li>
<li><p><span class="math display">\[
\cos(\theta_z)=\dfrac{u_x}{\sqrt{n_y^2+n_z^2}}=\dfrac{v_yn_z-n_yv_z}{\sqrt{n_y^2+n_z^2}}
\]</span></p></li>
<li><p><span class="math display">\[
\sin(\theta_z)=-\dfrac{u_yn_z-u_zn_y}{\sqrt{n_y^2+n_z^2}}=\dfrac{v_x}{\sqrt{n_y^2+n_z^2}}
\]</span></p></li>
<li><p>乘法时根据次数把 <span class="math inline">\(\sin\theta_x,\cos\theta_z\)</span> 展开为不同形式
<span class="math display">\[
R_z(\theta_z)=
  \begin{bmatrix}
  \cos\theta_z &amp; -\sin\theta_z &amp; 0 &amp; 0\\
  \sin\theta_z  &amp; \cos\theta_z &amp; 0 &amp; 0\\
  0 &amp; 0 &amp; 1 &amp; 0\\
  0 &amp; 0 &amp; 0 &amp; 1\\
  \end{bmatrix}\\
\]</span></p></li>
<li><p><span class="math display">\[
R_z(\theta_z)R_y(\theta_y)R_x(\theta_x)=
\begin{bmatrix}
u_x &amp; u_y &amp; u_z &amp; 0\\
v_x &amp; v_y &amp; v_z &amp; 0\\
n_x &amp; n_y &amp; n_z &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}
\]</span></p></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.LS</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学.李胜.05.投影(3)</title>
    <url>/2021/01/31/CG/LS/05-2/</url>
    <content><![CDATA[<h1 id="三维图形的显示流程图">三维图形的显示流程图</h1>
<ul>
<li><p>模型坐标系</p>
<ul>
<li>模型变换 <span class="math inline">\(\downarrow\)</span></li>
</ul></li>
<li><p>世界坐标系</p>
<ul>
<li>观察变换 <span class="math inline">\(\downarrow\)</span></li>
</ul></li>
<li><p>观察坐标系</p>
<ul>
<li>规范化变换 <span class="math inline">\(\downarrow\)</span></li>
</ul></li>
<li><p>规范化投影坐标系</p>
<ul>
<li>关于视见体的裁剪 <span class="math inline">\(\downarrow\)</span></li>
<li>投影 <span class="math inline">\(\downarrow\)</span></li>
</ul></li>
<li><p>投影平面</p>
<ul>
<li>窗口至视区的变换 <span class="math inline">\(\downarrow\)</span></li>
</ul></li>
<li><p>设备坐标系</p>
<ul>
<li>显示</li>
</ul></li>
</ul>
<h2 id="模型变换">模型变换</h2>
<ul>
<li>模型坐标系 Modeling Coordinate
<ul>
<li>物体的局部坐标系</li>
<li>在模型坐标系中物体的<strong>表示简单</strong></li>
</ul></li>
<li>模型变换 Modeling Transformation</li>
<li>将物体从本身的模型坐标系变换到上层物体的模型坐标系（或世界坐标系）的几何变换</li>
</ul>
<h2 id="何时裁剪">何时裁剪</h2>
<ul>
<li>投影之前：三维裁剪
<ul>
<li>裁剪相对复杂</li>
<li>只需要对可见的物体进行投影变换</li>
</ul></li>
<li>投影之后：二位裁剪
<ul>
<li>裁剪相对简单</li>
<li>需要对所有的物体进行投影变换</li>
</ul></li>
<li>为什么需要在投影之前进行裁剪
<ul>
<li>三维物体的表面通常被离散表示成多边形或折线，而这类简单图元的三维裁剪比较简单</li>
<li>三维图形在显示过程中需要被消隐，消隐需要图形的深度信息，所以必须在投影之前完成</li>
</ul></li>
</ul>
<h2 id="规范视见体">规范视见体</h2>
<ul>
<li>规范视见体的引入可以<strong>简化裁剪</strong></li>
<li>规范化变化：将任意视见体变换成规范视见体的变换</li>
<li>规范投影坐标（三维屏幕坐标 ）：经规范化的观察坐标系</li>
</ul>
<h3 id="平行投影的规范视见体">平行投影的规范视见体</h3>
<ul>
<li>半立方体</li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{**lr**}
u=-1,u=1\\
v=-1,v=1\\
n=-1,n=0
\end{array}
\right.
\]</span></p>
<h3 id="透视投影的规范视见体">透视投影的规范视见体</h3>
<ul>
<li>四棱台</li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{**lr**}
u=-n,u=n\\
v=-n,v=n\\
n=-1,n=-n_{min}
\end{array}
\right.
\]</span></p>
<h3 id="平行投影视见体的规范化">平行投影视见体的规范化</h3>
<ul>
<li>将任意的平行投影视见体变换为规范平行投影视见体</li>
<li>变换的分解与合成</li>
<li>例如之前的 OpenGL 的变换推导</li>
</ul>
<h3 id="透视投影视见体的规范化">透视投影视见体的规范化</h3>
<ul>
<li>将任意的透视投影视见体变换为规范透视投影视见体</li>
<li>变换的分解与合成</li>
<li>例如之前的 OpenGL 的变换推导</li>
</ul>
<h3 id="规范视见体之间的变换">规范视见体之间的变换</h3>
<ul>
<li>将透视投影的规范视见体变换为平行投影的规范视见体</li>
<li>原因
<ul>
<li>关于长方体的裁剪较关于正四棱台的裁剪简单</li>
<li>平行投影较透视投影简单</li>
<li>透视投影与平行投影都采用同一套裁剪与投影程序，处理一致，便于用硬件实现</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{bmatrix}
1&amp;0&amp;0&amp;0\\
0&amp;1&amp;0&amp;0\\
0&amp;0&amp;\dfrac{1}{1-n_{min}}&amp;\dfrac{n_{min}}{1-n_{min}}\\
0&amp;0&amp;-1&amp;0
\end{bmatrix}
\]</span></p>
<ul>
<li><span class="math inline">\(n_{min}\ge0\)</span></li>
</ul>
<h1 id="三维裁剪">三维裁剪</h1>
<h2 id="两种方法">两种方法</h2>
<ul>
<li>将齐次坐标转换为三维坐标，在三维空间对视见体裁剪
<ul>
<li>三维裁剪相对容易</li>
<li>需要将齐次坐标转换为三维坐标</li>
</ul></li>
<li>直接在四维齐次坐标空间中进行裁剪
<ul>
<li>不需要将齐次坐标转换为三维坐标</li>
<li>有理曲线曲面可以直接用齐次坐标来表示，对它们的裁剪只能在齐次坐标空间中进行</li>
<li>四维裁剪相对复杂</li>
</ul></li>
</ul>
<h2 id="关于规范视见体的裁剪">关于规范视见体的裁剪</h2>
<ul>
<li>直线段裁剪的Cohen_Sutherland算法、梁_Barskey算法的直接推广</li>
<li>多边形裁剪的Sutherland_Hodgman算法的直接推广</li>
<li>齐次坐标空间中的裁剪
<ul>
<li>四维裁剪体的定义</li>
</ul></li>
</ul>
<h1 id="相机的任意控制">相机的任意控制</h1>
<h2 id="欧拉变换">欧拉变换</h2>
<ul>
<li><p>Euler 变换</p></li>
<li><p>缺省视域方向</p>
<ul>
<li>视线为 -z 轴</li>
<li>头顶朝向为 +y 轴</li>
<li>右手系</li>
</ul></li>
<li><p><span class="math inline">\(E(h,p,r)=R_z(r)R_x(p)R_y(h)\)</span></p>
<ul>
<li>旋转顺序：<span class="math inline">\({\color{red}yzx}\)</span></li>
</ul></li>
<li><p>正交矩阵 <span class="math inline">\(E\)</span></p>
<ul>
<li><span class="math inline">\(E^{-1}=E^T=(R_zR_xR_y)^T=R_y^TR_x^TR_z^T\)</span></li>
</ul></li>
<li><p>方向规定：</p>
<ul>
<li><span class="math inline">\(head/yaw:z\to x\)</span></li>
<li><span class="math inline">\(pitch:y\to z\)</span></li>
<li><span class="math inline">\(roll:y\to x\)</span>
<ul>
<li><span style="color:red;font-weight:bold">和右手系相反</span></li>
</ul></li>
</ul></li>
<li><p>Gimbal lock：万向锁</p>
<ul>
<li>一个自由度缺失</li>
<li>旋转一直都是在物体所在的局部坐标系变换
<ul>
<li>在旋转的过程中，某个轴旋转的时候与一开始的某个其他轴重合</li>
</ul></li>
</ul></li>
<li><p><span class="math inline">\(c\)</span> 表示 <span class="math inline">\(\cos\)</span>，<span class="math inline">\(s\)</span> 表示 <span class="math inline">\(\sin\)</span></p></li>
</ul>
<p><span class="math display">\[
E(h,p,r)=
\begin{bmatrix}
c_yc_z-s_xs_ys_z&amp;-c_xc_z&amp;s_yc_z+s_xc_ys_z&amp;0\\
c_ys_z+s_xs_yc_z&amp;c_xc_z&amp;s_ys_z-s_xc_yc_z&amp;0\\
-s_yc_x&amp;s_x&amp;c_xc_y&amp;0\\
0&amp;0&amp;0&amp;1
\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
E(h,p,r)=
\begin{bmatrix}
c_hc_r-s_ps_hs_r&amp;-c_pc_r&amp;s_hc_r+s_pc_hs_r&amp;0\\
c_hs_r+s_ps_hc_r&amp;c_pc_r&amp;s_hs_r-s_pc_hc_r&amp;0\\
-s_hc_p&amp;s_p&amp;c_pc_h&amp;0\\
0&amp;0&amp;0&amp;1
\end{bmatrix}
\]</span></p>
<ul>
<li>当 <span class="math inline">\(p=\dfrac{\pi}{2}\)</span>
时，自由度损失</li>
</ul>
<p><span class="math display">\[
E(h,p,r)=
\begin{bmatrix}
c_hc_r-s_hs_r&amp;0&amp;s_hc_r+c_hs_r&amp;0\\
c_hs_r+s_hc_r&amp;0&amp;s_hs_r-c_hc_r&amp;0\\
0&amp;1&amp;0&amp;0\\
0&amp;0&amp;0&amp;1
\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
E(h,p,r)=
\begin{bmatrix}
\cos(h+r)&amp;0&amp;\sin(h+r)&amp;0\\
\sin(h+r)&amp;0&amp;-\cos(h+r)&amp;0\\
0&amp;1&amp;0&amp;0\\
0&amp;0&amp;0&amp;1
\end{bmatrix}
\]</span></p>
<ul>
<li>万向锁产生，<span class="math inline">\(h,r\)</span> 共轴</li>
</ul>
<h2 id="四元数-quaternion">四元数 Quaternion</h2>
<ul>
<li>最早由 Sir William Rowan Hamilton 于 1843
年提出，从复数推广到四维空间</li>
<li>1985年，Shoemake 把四元数引入计算机图形学</li>
<li>在表示旋转和朝向方面，优于Euler角。具有表示紧凑，朝向插值稳定的优点，在虚拟现实系统中，常用于表示各种视点（camera）的旋转变换</li>
<li>定义
<ul>
<li><span class="math inline">\(\vec{q}=(\vec{q_v},q_w)=(iq_x+jq_y+kq_z+q_w)=\vec{q_v}+q_w\)</span></li>
<li><span class="math inline">\(\vec{q_v}=(iq_x+jq_y+kq_z)=(q_x,q_y,q_z)\)</span></li>
<li><span class="math inline">\(i^2=j^2=k^2=1,ij=-ji=k,jk=-kj=i,ki=-ik=j\)</span>
<ul>
<li>感觉和 xyz 坐标系差不多</li>
</ul></li>
<li><span class="math inline">\(q_w\)</span>
称为<strong>实部</strong>，<span class="math inline">\(\vec{q_v}\)</span> 称为<strong>虚部</strong></li>
<li><span class="math inline">\(i,j,k\)</span> 称为虚轴</li>
</ul></li>
</ul>
<h3 id="四元数性质">四元数性质</h3>
<ul>
<li>四元数乘法：直接展开即可</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\vec{q}\vec{r}=&amp;(iq_x+jq_y+kq_z+q_w)(ir_x+jr_y+kr_z+r_w)\\
=&amp;(\vec{q_v}\times\vec{r_v}+r_w\vec{q_v}+q_w\vec{r_v},q_wr_w-\vec{q_v}\cdot\vec{r_w})\\
=&amp;(q_yr_z-q_zr_y+r_wq_x+q_wr_x,\\
&amp;q_zr_x-q_xr_z+r_wq_y+q_wr_y,\\
&amp;q_xr_y-q_yr_x+r_wq_z+q_wr_z,\\
&amp;q_wr_w-q_xr_x-q_yr_y-q_zr_z)
\end{aligned}
\]</span></p>
<ul>
<li>四元数加法：实部虚部分开做加法
<ul>
<li><span class="math inline">\(\vec{q}+\vec{r}=(\vec{q_v}+\vec{r_v},q_w+r_w)\)</span></li>
</ul></li>
<li>四元数共轭
<ul>
<li><span class="math inline">\(\vec{q}^\star=(-\vec{q_v},q_w)\)</span></li>
</ul></li>
<li>四元数范数
<ul>
<li><span class="math inline">\(n(\vec{q})= \Vert \vec{q}^2\Vert
=\vec{q}\vec{q}^\star=\vec{q}^\star\vec{q}=\vec{q_v}\cdot\vec{q_v}+q_w^2=\vec{q_x}^2+\vec{q_y}^2+\vec{q_z}^2+q_w^2\)</span></li>
</ul></li>
<li>四元数的逆
<ul>
<li><span class="math inline">\(\vec{q}^{-1}=\dfrac{\vec{q}^\star}{\Vert\vec{q}^2\Vert}\)</span></li>
</ul></li>
<li>共轭法则
<ul>
<li><span class="math inline">\((\vec{q}^\star)^\star=\vec{q}\)</span></li>
<li><span class="math inline">\((\vec{q}+\vec{r})^\star=\vec{q}^\star+\vec{r}^\star\)</span></li>
<li><span class="math inline">\((\vec{q}\vec{r})^\star=\vec{r}^\star\vec{q}^\star\)</span></li>
</ul></li>
<li>范数法则
<ul>
<li><span class="math inline">\(n(\vec{q})=n(\vec{q}^\star)\)</span></li>
<li><span class="math inline">\(n(\vec{q}\vec{r})=n(\vec{q})n(\vec{r})\)</span></li>
</ul></li>
<li>线性性质
<ul>
<li><span class="math inline">\(\vec{p}(s\vec{q}+t\vec{r})=s\vec{p}\vec{q}+t\vec{p}\vec{r}\)</span></li>
<li><span class="math inline">\((s\vec{q}+t\vec{r})\vec{p}=s\vec{q}\vec{p}+t\vec{r}\vec{p}\)</span></li>
</ul></li>
<li>交换律
<ul>
<li><span class="math inline">\((\vec{p}\vec{q})\vec{r}=\vec{p}(\vec{q}\vec{r})\)</span></li>
</ul></li>
<li>单位四元数
<ul>
<li><span class="math inline">\(n(\vec{q})=1\)</span></li>
<li>可以写成 <span class="math inline">\(\vec{q}=(\sin\phi\vec{u_q},\cos\phi)=\sin\phi\vec{u_q}+\cos\phi\)</span>，其中
<span class="math inline">\(\Vert\vec{u_q}\Vert=1\)</span></li>
<li><span class="math inline">\(\vec{q}=\sin\phi\vec{u_q},\cos\phi=e^{\phi\vec{u_q}}\)</span>
<ul>
<li>参照单位复数 <span class="math inline">\(\cos\phi+i\sin\phi=e^{i\phi}\)</span></li>
</ul></li>
</ul></li>
<li>单位四元数对数运算
<ul>
<li><span class="math inline">\(\ln\vec{q}=\phi\vec{u_q}\)</span></li>
</ul></li>
<li>单位四元数指数运算
<ul>
<li><span class="math inline">\(\vec{q}^t=e^{t\phi\vec{u_q}}=\sin(t\phi)\vec{u_q}+\cos(t\phi)\)</span></li>
</ul></li>
</ul>
<h3 id="四元数变换">四元数变换</h3>
<ul>
<li>单位四元数的最重要性质：能表示任意、旋转，而且表示简单、紧凑</li>
<li>给定向量 <span class="math inline">\(\vec{p}=(p_x,p_y,p_z,p_w)^T\)</span> 和单位四元数
<span class="math inline">\(\vec{q}=(\sin\phi\vec{u_q},\cos\phi)\)</span>
<ul>
<li><span class="math inline">\(\vec{q}\vec{p}\vec{q}^{-1}\)</span> 把
<span class="math inline">\(p\)</span> 绕单位轴 <span class="math inline">\(\vec{u_q}\)</span> 旋转 <span class="math inline">\({\color{red}2\phi}\)</span> 角度</li>
<li><span class="math inline">\({\color{red}\mathrm{Proof}}\)</span>
<ul>
<li>可以通过最原始的旋转进行验证
<ul>
<li>以单位旋转轴为 z 轴建立新坐标系，坐标系变换</li>
<li>套用旋转矩阵</li>
<li>坐标系逆变换</li>
</ul></li>
<li>对比得到的矩阵是否一致</li>
</ul></li>
<li>旋转模长不变是显然的
<ul>
<li><span class="math inline">\(\Vert\vec{q}\vec{p}\vec{q}^{-1}\Vert=\Vert\vec{q}\Vert\Vert\vec{p}\Vert\Vert\vec{q}^\star\Vert=\Vert\vec{p}\Vert\)</span></li>
</ul></li>
</ul></li>
</ul>
<h4 id="绕任意单位轴的旋转矩阵">绕任意单位轴的旋转矩阵</h4>
<ul>
<li>绕单位轴 <span class="math inline">\((a,b,c)\)</span> 旋转 <span class="math inline">\(\theta\)</span> 的旋转矩阵</li>
</ul>
<h5 id="建立新坐标系">(1) 建立新坐标系</h5>
<ul>
<li><span class="math inline">\(n=(n_x,n_y,n_z)\)</span></li>
<li><span class="math inline">\(u=(0,\dfrac{-n_z}{\sqrt{n_y^2+n_z^2}},\dfrac{n_y}{\sqrt{n_y^2+n_z^2}})\)</span></li>
<li><span class="math inline">\(v=n\times
u=(\sqrt{n_y^2+n_z^2},\dfrac{-n_xn_y}{\sqrt{n_y^2+n_z^2}},\dfrac{-n_xn_z}{\sqrt{n_y^2+n_z^2}})\)</span></li>
</ul>
<h5 id="坐标变换矩阵">(2) 坐标变换矩阵</h5>
<ul>
<li><span class="math inline">\(xyz\to uvn\)</span></li>
</ul>
<p><span class="math display">\[
M_1=\begin{bmatrix}
u_x &amp; u_y &amp; u_z &amp; 0\\
v_x &amp; v_y &amp; v_z &amp; 0\\
n_x &amp; n_y &amp; n_z &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}
\]</span></p>
<h5 id="绕-nz-轴旋转角度-theta">(3) 绕 n(z) 轴旋转角度 <span class="math inline">\(\theta\)</span></h5>
<p><span class="math display">\[
M_2=
\begin{bmatrix}
\cos\theta &amp; -\sin\theta &amp; 0 &amp; 0\\
\sin\theta &amp; \cos\theta &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1&amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}
\]</span></p>
<h5 id="坐标变换逆变换">(4) 坐标变换逆变换</h5>
<ul>
<li>正交矩阵 <span class="math inline">\(M_1\)</span></li>
</ul>
<p><span class="math display">\[
M_3=M_1^{-1}=M_1^T
\]</span></p>
<h5 id="结果">(5) 结果</h5>
<ul>
<li><span class="math inline">\(M_3M_2M_1\)</span></li>
<li><span class="math inline">\(c\)</span> 表示 <span class="math inline">\(\cos\theta\)</span>，<span class="math inline">\(s\)</span> 表示 <span class="math inline">\(\sin\theta\)</span></li>
</ul>
<p><span class="math display">\[
\begin{bmatrix}
n_x^2+(u_x^2+v_x^2)c&amp;n_xn_y-n_zs+(u_xu_y+v_xv_y)c&amp;n_xn_z+n_ys+(u_xu_z+v_xv_z)c&amp;0\\
n_xn_y+n_xs+(u_xu_y+v_xv_y)c&amp;(u_y^2+v_y^2)c+n_y^2&amp;n_yn_z-n_xs+(u_yu_z+v_yv_z)c&amp;0\\
n_xn_z-n_ys+(u_xu_z+v_xv_z)c&amp;n_yn_z+n_xs+(u_yu_z+v_yv_z)c&amp;(u_z^2+v_z^2)c+n_z^2&amp;0\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
M(\vec{n},\theta)=M_3M_2M_1=
\begin{bmatrix}
n_x^2(1-c)+c &amp; n_xn_y(1-c)-n_zs&amp; n_xn_z(1-c)+n_ys&amp; 0\\
n_xn_y(1-c)+n_zs &amp; n_y^2(1-c)+c &amp; n_yn_z(1-c)-n_xs &amp; 0\\
n_xn_z(1-c)-n_ys &amp; n_yn_z(1-c)+n_xs &amp; n_z^2(1-c)+c &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}
\]</span></p>
<h4 id="四元数转化为矩阵形式">四元数转化为矩阵形式</h4>
<p><span class="math display">\[
\begin{aligned}
\vec{q}\vec{p}\vec{q}^{-1}=&amp;(q_x,q_y,q_z,q_w)(p_x,p_y,p_z,p_w)(-q_x,-q_y,-q_z,q_w)\\
=&amp;(q_yp_z-q_zp_y+p_wq_x+q_wp_x,\\
&amp;q_zp_x-q_xp_z+p_wq_y+q_wp_y,\\
&amp;q_xp_y-q_yp_x+p_wq_z+q_wp_z,\\
&amp;q_wp_w-q_xp_x-q_yp_y-q_zp_z)(-q_x,-q_y,-q_z,q_w)\\
=&amp;\cdots
\end{aligned}
\]</span></p>
<ul>
<li>展开即可
<ul>
<li>展开第一项，后面的可以根据循环对称性进行推导</li>
</ul></li>
<li>表示方便，我们写成矩阵形式 <span class="math inline">\(\vec{q}\vec{p}\vec{q}^{-1}=M^q\vec{p}\)</span></li>
</ul>
<p><span class="math display">\[
M^q=
\begin{bmatrix}
1-2(q_y^2+q_z^2)&amp;2(q_xq_y-q_zq_w)&amp;2(q_xq_z+q_yq_w)&amp;0\\
2(q_xq_y+q_zq_w)&amp;1-2(q_x^2+q_z^2)&amp;2(q_yq_z-q_xq_w)&amp;0\\
2(q_xq_z-q_yq_w)&amp;2(q_yq_z+q_xq_w)&amp;1-2(q_x^2+q_y^2)&amp;0\\
0&amp;0&amp;0&amp;1
\end{bmatrix}
\]</span></p>
<ul>
<li>如果 <span class="math inline">\(\vec{q}\)</span>
不是单位四元数，那么上面的 <span class="math inline">\(2\)</span>
全部得换成 <span class="math inline">\(\dfrac{2}{n(\vec{q})}\)</span></li>
<li>对比 <span class="math inline">\(M(\vec{n},\theta)\)</span>
确实是一致的
<ul>
<li><span class="math inline">\(\vec{q}=(n_x\sin\phi,n_y\sin\phi,n_z\sin\phi,\cos\phi)\)</span></li>
<li><span class="math inline">\(\theta=2\phi\)</span></li>
<li>逐个验证即可</li>
</ul></li>
</ul>
<h4 id="矩阵形式转化为四元数">矩阵形式转化为四元数</h4>
<ul>
<li>根据矩阵的性质来进行计算四元数 <span class="math inline">\(\vec{q}\)</span></li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{**lr**}
tr(M)=4q_w^2\\
m_{21}-m_{12}=4q_xq_w\\
m_{02}-m_{20}=4q_yq_w\\
m_{10}-m_{01}=4q_zq_w
\end{array}
\right.
\]</span></p>
<p><span class="math display">\[
\left\{
\begin{array}{**lr**}
q_w=\dfrac{1}{2}\sqrt{tr(M)}\\
q_x=\dfrac{m_{21}-m_{12}}{4q_w}\\
q_y=\dfrac{m_{02}-m_{20}}{4q_w}\\
q_z=\dfrac{m_{10}-m_{01}}{4q_w}
\end{array}
\right.
\]</span></p>
]]></content>
      <categories>
        <category>CG.LS</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学.李胜.07.三维实体的表示</title>
    <url>/2021/02/03/CG/LS/07/</url>
    <content><![CDATA[<h1 id="表示形体的两种模型">表示形体的两种模型</h1>
<h2 id="数据模型">数据模型</h2>
<ul>
<li>完全以数据表示
<ul>
<li>例如：以 8 个顶点表示的立方体，以半径和中心表示的球体</li>
<li>以数据文件的形式存在</li>
<li>包括
<ul>
<li>特征表示、空间分割表示、推移表示、边界表示、构造实体集合表示等</li>
</ul></li>
</ul></li>
</ul>
<h3 id="线框模型">(1) 线框模型</h3>
<ul>
<li>将形体表示成一组<strong>轮廓线</strong>的集合</li>
<li>简单、处理速度快</li>
<li>与形体之间不存在一一对应关系，是真实物体的高度抽象、不适合真实感显示</li>
</ul>
<h3 id="表面模型">(2) 表面模型</h3>
<ul>
<li>将形体表示成一组<strong>表面</strong>的集合</li>
<li>形体与其表面一一对应，适合真实感显示</li>
</ul>
<h3 id="实体模型">(3) 实体模型</h3>
<ul>
<li>用来描述<strong>实体</strong>，主要用于 CAD/CAM</li>
<li>包含了描述一个实体所需要的较多信息（几何信息、拓扑信息等）</li>
</ul>
<h2 id="过程模型">过程模型</h2>
<ul>
<li>以一个过程和相应的控制参数描述</li>
<li>例如：用一些控制参数和一个生成规则描述的植物</li>
<li>以一个数据文件和一段代码的形式存在</li>
<li>包括
<ul>
<li>粒子系统、L系统、迭代函数系统</li>
</ul></li>
</ul>
<h1 id="实体的定义">实体的定义</h1>
<ul>
<li><p>抽象带来的问题</p>
<ul>
<li>计算机中的数学方法表示的物体可能无效</li>
<li>不能够客观存在
<ul>
<li>CAD / CAM 需要客观存在</li>
</ul></li>
</ul></li>
<li><p>客观存在（有效）—— <strong>实体的定义</strong></p>
<ul>
<li>具有一定的形状</li>
<li>具有封闭的边界（表面）</li>
<li>内部连通</li>
<li>占据有限的空间</li>
<li>经过运算之后仍是有效的实体</li>
</ul></li>
<li><p>实体看作点集（使用集合论的方法描述）</p>
<ul>
<li>内点：具有完全包含于该点集的充分小的领域的点</li>
<li>边界点：物体上除了内点之外的点</li>
<li>取内点运算：<span class="math inline">\(i\)</span></li>
<li>取闭包运算：<span class="math inline">\(c\)</span></li>
<li>正则运算：<span class="math inline">\(r\)</span>
<ul>
<li>先取内点，再取闭包</li>
<li><span class="math inline">\(r\cdot A=c\cdot i\cdot A\)</span></li>
<li>一个例子</li>
</ul></li>
</ul>
<p><img src="/2021/02/03/CG/LS/07/r.png"></p>
<ul>
<li>正则点集 <span class="math inline">\(A\)</span> 满足 <span class="math inline">\(r\cdot A=A\)</span></li>
</ul></li>
<li><p>正则点集一定是实体吗？<span style="color:red;font-weight:bold">不一定</span></p>
<ul>
<li>内部不连通</li>
</ul></li>
</ul>
<p><img src="/2021/02/03/CG/LS/07/r-not-real.png"></p>
<ul>
<li>实体可计算的条件
<ul>
<li>正则点集</li>
<li>表面是二维流形
<ul>
<li>二维流形：其上任意一点存在充分小的领域与平面圆盘同构（存在连续的一一映射）</li>
</ul></li>
<li>同构
<ul>
<li>内点 <span class="math inline">\(\cong\)</span> 圆盘</li>
<li>边界点 <span class="math inline">\(\cong\)</span> 半圆盘</li>
</ul></li>
</ul></li>
</ul>
<h1 id="正则集合运算">正则集合运算</h1>
<h2 id="为什么需要正则集合运算">为什么需要正则集合运算</h2>
<ul>
<li>集合运算式构造物体的有效方法</li>
<li>普通的集合运算会产生无效物体</li>
</ul>
<h2 id="正则并交差">正则并/交/差</h2>
<h3 id="正则运算定义">正则运算定义</h3>
<ul>
<li><span class="math inline">\(A\ op^\star\ B=r\cdot(A\ op\
B)\)</span></li>
<li>正则并：<span class="math inline">\(A\cup^\star B=r\cdot(A\cup
B)\)</span></li>
<li>正则交：<span class="math inline">\(A\cap^\star\ B=r\cdot(A\cap
B)\)</span></li>
<li>正则差：<span class="math inline">\(A-^\star\
B=r\cdot(A-B)\)</span></li>
</ul>
<h3 id="边界-bs">边界 bS</h3>
<ul>
<li>内部 <span class="math inline">\(iS\)</span>，边界 <span class="math inline">\(bS\)</span>，外部 <span class="math inline">\(eS\)</span></li>
<li><span class="math inline">\(S=bS\cup iS\)</span></li>
</ul>
<h4 id="求边界确定实体">求边界确定实体</h4>
<ul>
<li><span class="math inline">\(bA=(bA\cap iB)\cup(bA\cap bB)\cup(bA\cap
eB)\)</span></li>
<li><span class="math inline">\(bB=(bB\cap iA)\cup(bB\cap bA)\cup(bB\cap
eA)\)</span></li>
<li>公共边界 <span class="math inline">\(bA\cap bB=bB\cap bA\)</span>
可以分为两个部分
<ul>
<li>同侧：实体 A 和 B 位于边界的同侧</li>
<li>异侧：实体 A 和 B 位于边界的异侧</li>
<li><span class="math inline">\(bA\cap bB=(bA\cap bB)_{同侧}\cup(bA\cap
bB)_{异侧}\)</span></li>
</ul></li>
<li>通过讨论边界的组成得到以下结论
<ul>
<li>正则并
<ul>
<li><span class="math inline">\(b(A\cup^\star B)=(bA\cap eB)\cup(bB\cap
eA)\cup(bA\cap bB)_{同侧}\)</span></li>
</ul></li>
<li>正则交
<ul>
<li><span class="math inline">\(b(A\cap^\star B)=(bA\cap iB)\cup(bB\cap
iA)\cup(bA\cap bB)_{同侧}\)</span></li>
</ul></li>
<li>正则差
<ul>
<li><span class="math inline">\(b(A-^\star B)=(bA\cap eB)\cup(bB\cap
iA)\cup(bA\cap bB)_{异侧}\)</span></li>
</ul></li>
</ul></li>
</ul>
<h1 id="特征表示">特征表示</h1>
<ul>
<li>用一组特征参数表示一组类似的物体</li>
<li>特征包括<strong>形状特征</strong>、<strong>材料特征</strong>等</li>
<li>适用于工业上标准件的表示</li>
<li>例子
<ul>
<li>圆柱体：R，H</li>
<li>立方体：边长a</li>
</ul></li>
</ul>
<h1 id="空间分割表示">空间分割表示</h1>
<h2 id="空间枚举表示">(1) 空间枚举表示</h2>
<ul>
<li>选择一个立方体空间，将其均匀划分</li>
<li>使用三维数组表示物体，数组中的元素与单位小立方体一一对应
<ul>
<li>1/0：是否被物体占据</li>
</ul></li>
<li>优点
<ul>
<li>可以表示任何物体</li>
<li>容易实现物体间的集合运算</li>
<li>容易计算物体的整体性质，如体积等</li>
</ul></li>
<li>缺点
<ul>
<li>占据大量的存储空间</li>
<li>没有边界信息，不适于图形显示</li>
<li>对物体进行几何变换困难，例如非90度的旋转</li>
<li>是物体的非精确表示
<ul>
<li>量化走样</li>
</ul></li>
</ul></li>
</ul>
<h2 id="八叉树">(2) 八叉树</h2>
<ul>
<li>对空间位置枚举表示的空间分割方法做了改进
<ul>
<li>均匀分割 <span class="math inline">\(\rightarrow\)</span>
自适应分割</li>
</ul></li>
<li>对绘制有好处</li>
</ul>
<h3 id="八叉树的建立">八叉树的建立</h3>
<ul>
<li>根结点对应整个物体空间</li>
<li>从根结点开始，对于一个结点
<ul>
<li>如果该结点完全被物体占据则记为 <span class="math inline">\(F\)</span>（Full）</li>
<li>如果该结点内部没有物体则记为 <span class="math inline">\(E\)</span>（Empty）</li>
<li>如果被物体部分占据则记作 <span class="math inline">\(P\)</span>（Partitial）
<ul>
<li>同时将其分割为 8
个立方体，每个立方体作为一个新的结点，进行同样的操作</li>
</ul></li>
</ul></li>
</ul>
<h3 id="八叉树的应用">八叉树的应用</h3>
<ul>
<li>Voxel based GI：基于八叉树的全局光照明</li>
<li>SVOGI：Sparse Voxel Octree Global Illumination
<ul>
<li>全局光渲染</li>
</ul></li>
<li>Voxelization（体素化）
<ul>
<li>将物体的几何形式表示转换成最接近该物体的体素表示形式，产生体数据集</li>
<li>不透明度属性/法向/发光向/材质/······</li>
</ul></li>
<li>待渲染场景 <span class="math inline">\(\rightarrow\)</span> 体素化
<span class="math inline">\(\rightarrow\)</span> 八叉树构造</li>
</ul>
<h3 id="cone-tracing">cone tracing</h3>
<ul>
<li>结合八叉树</li>
<li>点向周围展开圆锥（立体角）</li>
<li>全局光照明：计算间接光照的时候，使用圆锥内的光照进行近似
<ul>
<li>在圆锥中，根据大小找到对应的不同粒度的八叉树，使用保存的属性</li>
<li>不同粒度，八叉树最小结点的大小不同（层次）</li>
</ul></li>
</ul>
<p><img src="/2021/02/03/CG/LS/07/core-tracing.png" style="zoom:100%;"></p>
<ul>
<li>求光照
<ul>
<li>蒙特卡洛采样积分：复杂度高</li>
<li>core tracing：复杂度相对较低</li>
</ul></li>
</ul>
<h3 id="八叉树评价">八叉树评价</h3>
<ul>
<li>优点
<ul>
<li>可以表示任何物体</li>
<li>容易实现物体间的集合运算</li>
<li>容易计算物体的整体性质，如体积等</li>
<li>相较于空间位置枚举表示占用的存贮空间少</li>
</ul></li>
<li>缺点
<ul>
<li>没有边界信息，不适于图形显示</li>
<li>对物体进行几何变换困难，例如非90度的旋转</li>
<li>是物体的非精确表示</li>
</ul></li>
</ul>
<h2 id="单元分解表示">(3) 单元分解表示</h2>
<ul>
<li>对空间位置枚举表示的空间分割方法做了改进
<ul>
<li>单一体素 <span class="math inline">\(\rightarrow\)</span>
多种体素</li>
</ul></li>
</ul>
<p><img src="/2021/02/03/CG/LS/07/multi-voxel.png"></p>
<ul>
<li>优点
<ul>
<li>表示简单</li>
<li>容易实现几何变换</li>
<li>基本提速可以按需选择，表示范围较广</li>
<li>可以精确表示物体</li>
</ul></li>
<li>缺点
<ul>
<li>物体表示不唯一</li>
<li>物体有效性难以保证</li>
</ul></li>
</ul>
<h1 id="空间层次划分">空间层次划分</h1>
<h2 id="kd-tree">KD-Tree</h2>
<ul>
<li>适合静态场景的光线追踪</li>
<li>降低算法查找的复杂度
<ul>
<li>静态：一次建立，多次查找</li>
<li><span class="math inline">\(\log n\)</span></li>
</ul></li>
<li>只进行横向和纵向的划分
<ul>
<li>分割线只有水平和竖直</li>
</ul></li>
<li>KD-Tree 降低了每一步判断在哪一个区域的复杂度
<ul>
<li>只需要和某几个维度比较（降维）</li>
</ul></li>
<li>判断点在分割线的哪个部分（2D）
<ul>
<li>任意直线：<span class="math inline">\(ax+by+c\)</span> 和 <span class="math inline">\(0\)</span> 作比较</li>
<li>KD-Tree：
<ul>
<li>水平：<span class="math inline">\(x\)</span> 和 <span class="math inline">\(0\)</span> 作比较</li>
<li>竖直：<span class="math inline">\(y\)</span> 和 <span class="math inline">\(0\)</span> 作比较</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/02/03/CG/LS/07/kd-tree.png"></p>
<ul>
<li>基于 kd-tree 的光子映射算法 photon mapping
<ul>
<li>给定一个点（位置），搜索在某个邻域之内散落的光子</li>
<li>KNN 的方法</li>
<li>KD-Tree 能够很好支持</li>
</ul></li>
</ul>
<h2 id="bvh-层次包围盒">BVH 层次包围盒</h2>
<ul>
<li>Bounding Volumn Hierarchy</li>
<li>适合动态场景的表示以及碰撞检测</li>
</ul>
<h1 id="推移表示">推移表示</h1>
<ul>
<li>sweep 体（扫掠）
<ul>
<li>将物体 A 沿着轨迹 P 推移得到物体 B，称 B 为 sweep 体</li>
</ul></li>
<li>平移 sweep
<ul>
<li>将一个二维区域沿着一个矢量方向推移</li>
</ul></li>
<li>旋转 sweep
<ul>
<li>将一个二维区域绕旋转轴旋转一周</li>
</ul></li>
<li>广义 sweep
<ul>
<li>任意物体沿着任意轨迹推移</li>
<li>推移过程中物体可以变形</li>
</ul></li>
<li>优点
<ul>
<li>表示简单、直观</li>
<li>适合做图形输入手段</li>
</ul></li>
<li>缺点
<ul>
<li>做集合运算困难，正则集合运算下非封闭</li>
</ul></li>
<li>应用
<ul>
<li>CAD 中工件的表示</li>
</ul></li>
</ul>
<h1 id="边界表示">边界表示</h1>
<ul>
<li>思想：物体的边界与物体一一对应，确定了物体的边界也就确定了物体本身</li>
<li>用于表示物体边界的有平面多边形、曲面片</li>
<li><strong>平面多边体</strong>
<ul>
<li>表面由平面多边形组成的多面体</li>
<li>严格要求每条边只属于两个多边形</li>
</ul></li>
<li>简单多面体
<ul>
<li>与球拓扑同构</li>
</ul></li>
<li><strong>欧拉公式</strong>：<span class="math inline">\(V-E+F=2\)</span>
<ul>
<li>顶点数 - 边数 + 面数 = 2</li>
<li>图论角度，从<strong>树</strong>开始推导</li>
</ul></li>
</ul>
<p><img src="/2021/02/03/CG/LS/07/Euler.png"></p>
<ul>
<li>欧拉公式是实体的<strong>必要条件</strong>
<ul>
<li>其他条件：边共享，顶点共享</li>
<li>一条边只能被两个面共享（<span class="math inline">\({\color{red}2}\)</span>）</li>
</ul></li>
</ul>
<p><img src="/2021/02/03/CG/LS/07/Euler-not-real.png"></p>
<ul>
<li><strong>广义欧拉公式</strong>：<span class="math inline">\(V-E+F-R=2(S-H)\)</span>
<ul>
<li>顶点数 - 边数 + 面数 - 孔的个数 = 2(体的个数 - 洞的个数)</li>
<li>孔和洞的区别在于洞是<strong>贯穿</strong>的</li>
<li>非简单多面体</li>
</ul></li>
</ul>
<p><img src="/2021/02/03/CG/LS/07/Euler-general.png"></p>
<ul>
<li>torus：亏格
<ul>
<li>面包圈形态：亏格为1（<span class="math inline">\(H=1\)</span>）</li>
<li>亏格为0的实体可以和<strong>球</strong>同构</li>
</ul></li>
<li>多边形的顶点顺序与法向量
<ul>
<li>规定一个顶点顺序，确定法向量</li>
<li>法向量：正反面，光照，几何计算等</li>
</ul></li>
<li>空间多边形的平面方程计算
<ul>
<li>顶点可能不共面：<strong>最小二乘法</strong>
拟合出一个平面，使其到所有顶点的距离之和最小</li>
</ul></li>
<li>边界表示的<strong>数据结构</strong>
<ul>
<li><strong>半边结构</strong>
<ul>
<li>一条边当作两条半边</li>
<li>好处
<ul>
<li>确定边的方向</li>
<li>确定一个边的搜索顺序</li>
<li>确定边被哪些平面共享
<ul>
<li>在几何造型时有用，单纯显示没有必要</li>
<li>例如删除某个平面，此时相关联的边也需要修改（修改拓扑结构）</li>
</ul></li>
</ul></li>
<li>下图：方向为规定的正方向，红色为半边的方向</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/02/03/CG/LS/07/half-edge.png"></p>
<ul>
<li>边界表示优点
<ul>
<li>精确表示物体</li>
<li>表示能力强</li>
<li>几何变换容易</li>
<li>适于显示处理</li>
</ul></li>
<li>边界表示缺点
<ul>
<li>表示复杂</li>
<li>有效性难以保证</li>
<li>集合运算复杂</li>
</ul></li>
</ul>
<h1 id="构造实体的几何表示">构造实体的几何表示</h1>
<ul>
<li>将物体表示成一棵二叉树，<strong>CSG树</strong></li>
<li>叶节点：基本体素
<ul>
<li>立方体，圆柱体等</li>
</ul></li>
<li>中间节点：正则运算集合
<ul>
<li>并交差</li>
</ul></li>
</ul>
<p><img src="/2021/02/03/CG/LS/07/CSG-Tree.png"></p>
<ul>
<li>面
<ul>
<li>环</li>
<li>边
<ul>
<li>半边（1，2）</li>
</ul></li>
</ul></li>
<li>优点
<ul>
<li>表示简单、直观</li>
<li>是物体的构造方法，可用作图形输入手段</li>
<li>容易计算物体的整体性质</li>
<li>物体的有效性自动得到保证</li>
</ul></li>
<li>缺点
<ul>
<li>表示不唯一</li>
<li>不能直接用于显示</li>
<li>求交计算麻烦</li>
</ul></li>
</ul>
<h1 id="不规则形体的建模方法">不规则形体的建模方法</h1>
<ul>
<li>迭代函数系统</li>
<li>基于文法的模型</li>
<li>粒子系统</li>
</ul>
<h2 id="迭代函数系统">迭代函数系统</h2>
<ul>
<li>IFS：Iterated Function System</li>
<li>分形</li>
<li>具有 5 个基本特征
<ul>
<li>形态的不规则性</li>
<li>结构的精细性</li>
<li>局部与整体的自相似性</li>
<li>为数的非整数性</li>
<li>生成的迭代性</li>
</ul></li>
</ul>
<h2 id="l-系统">L 系统</h2>
<ul>
<li>由生物学家 <strong>Lindenmayer</strong> 创立</li>
<li>基本思想
<ul>
<li>用文法表示植物的拓扑结构
<ul>
<li>BNF</li>
</ul></li>
<li>通过图形学的方法生成逼真的画面</li>
</ul></li>
<li>DOL系统（确定的上下文无关的L系统）
<ul>
<li>定义为三元组 <span class="math inline">\(&lt;V,w,P&gt;\)</span>
<ul>
<li><span class="math inline">\(V\)</span>
表示字母集合，<strong>字母表</strong></li>
<li><span class="math inline">\(Y^\star\)</span> 表示 <span class="math inline">\(V\)</span>
上的<strong>所有单词</strong>的集合</li>
<li><span class="math inline">\(w\)</span> 是一个非空单词（<span class="math inline">\(V\)</span> 中元素的非空排列，称为公理）</li>
<li><span class="math inline">\(P\)</span> <strong>产生式</strong>集合
<ul>
<li><span class="math inline">\(\forall a\in V,\exists x\in
V^\star\)</span> 使得 <span class="math inline">\(a\to x\)</span>
<ul>
<li>有且只有（唯一）的 <span class="math inline">\(x\)</span></li>
</ul></li>
<li>若无明显的产生式，则令 <span class="math inline">\(a\to
a\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="koch-雪花">Koch 雪花</h3>
<ul>
<li><span class="math inline">\(V:\{F,+,-\}\)</span></li>
<li><span class="math inline">\(w:F\)</span></li>
<li><span class="math inline">\(P:F\to F-F++F-F\)</span></li>
<li>几何解释：
<ul>
<li><span class="math inline">\(F\)</span>：向前画一条直线</li>
<li><span class="math inline">\(+\)</span>：右转 <span class="math inline">\(\alpha\)</span></li>
<li><span class="math inline">\(-\)</span>：左转 <span class="math inline">\(\beta\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/02/03/CG/LS/07/koch.png"></p>
<h3 id="bracketed-l系统">Bracketed L系统</h3>
<ul>
<li><span class="math inline">\(V:\{F,+,-,[,]\}\)</span></li>
<li><span class="math inline">\(w:F\)</span></li>
<li><span class="math inline">\(P:F\to F[+F]F[-F]F\)</span></li>
<li>几何解释：
<ul>
<li><span class="math inline">\(F\)</span>：向前画一条直线</li>
<li><span class="math inline">\(+\)</span>：右转 <span class="math inline">\(\alpha\)</span></li>
<li><span class="math inline">\(-\)</span>：左转 <span class="math inline">\(\beta\)</span></li>
<li><span class="math inline">\([\)</span>：压栈</li>
<li><span class="math inline">\([\)</span>：出栈</li>
</ul></li>
</ul>
<p><img src="/2021/02/03/CG/LS/07/bracketed-L.png"></p>
<h1 id="粒子系统">粒子系统</h1>
<h2 id="particle-systems">Particle Systems</h2>
<ul>
<li>simulate and render objects / phenomena that do not have clear
surface definitions
<ul>
<li>fire, water, snow, explosion, smoke, swarm, fountain ...
<ul>
<li>火焰、水、雪、爆炸、烟雾、群、喷泉</li>
</ul></li>
</ul></li>
<li>Particles are entities (e.g.points) with attributes acting
independently and collectively
<ul>
<li>带有属性的实体，实体之间的属性相互独立或联系</li>
</ul></li>
<li>Typical attributes: position, velocity, color, life span, etc.
<ul>
<li>位置、速度、颜色、生命周期</li>
</ul></li>
</ul>
<h2 id="一些特点">一些特点</h2>
<ul>
<li>An object is represented as clouds of primitive particles that
define its volume.
<ul>
<li>单个粒子很简单，物体的形态由集群的粒子表现</li>
</ul></li>
<li>dynamic, changing form and moving with the passage of time.
<ul>
<li>动态的、变化的，处于不同生命周期时间段的例子有不一样的状态</li>
</ul></li>
<li>Object is not deterministic, its shape and form are not completely
specified.
<ul>
<li>非确定性的，形状或者样式不是完全规定好的</li>
</ul></li>
<li>Different force rules and different renderings give all the
different types of behaviors.
<ul>
<li>例字在面对不同的条件或者规则会有不一样的行为</li>
</ul></li>
</ul>
<h2 id="粒子的属性">粒子的属性</h2>
<ul>
<li>Position：<strong>位置</strong>
<ul>
<li>the change of the particle position is affected by its velocity</li>
</ul></li>
<li>velocity：<strong>速度</strong>
<ul>
<li>affected by force/acceleration</li>
</ul></li>
<li>Lifetime：<strong>生命周期</strong>
<ul>
<li>the remain life time before the extinction of the particle</li>
<li>It is decremented every frame.</li>
<li>It may affect may other attributes</li>
</ul></li>
<li>Size：<strong>大小</strong>
<ul>
<li>may vary during its life span</li>
</ul></li>
<li>Weight：<strong>质量</strong>
<ul>
<li>useful to calculate acceleration from force</li>
</ul></li>
<li>Visual representation：<strong>可视化形式</strong>
<ul>
<li>3D points：3D
的<strong>点</strong>，适用于比较远的点（看不出来差异）
<ul>
<li>for remote scene</li>
</ul></li>
<li>Lines：<strong>线</strong>（粒子轨迹）
<ul>
<li>a trace of particle trajectory</li>
</ul></li>
<li>Texture-mapped quads：带纹理的四边形
<ul>
<li>very flexible &amp; widely used</li>
</ul></li>
</ul></li>
<li>Color：<strong>颜色</strong>
<ul>
<li>may change during its life span</li>
</ul></li>
</ul>
<h2 id="粒子的集群控制">粒子的集群控制</h2>
<ul>
<li>Particle list：<strong>粒子的列表</strong></li>
<li>Particle generation：<strong>粒子的产生</strong>
<ul>
<li>Position：<strong>位置信息</strong>
<ul>
<li>default, Random or fixed.</li>
</ul></li>
<li>Emission rate：<strong>生成速率</strong>
<ul>
<li>how often particles are created.</li>
</ul></li>
<li>Default particle attributes：<strong>初始属性</strong>
<ul>
<li>Random or fixed.</li>
</ul></li>
</ul></li>
<li>Particle kill：<strong>粒子的湮灭</strong>（生命周期）
<ul>
<li>kill particles if their lifetimes become <strong>0</strong> or
<strong>certain conditions</strong> happen</li>
</ul></li>
<li>Particle Animation：<strong>粒子的动画</strong>（每一帧的动画）
<ul>
<li>The remaining particles are moved and transformed according to their
dynamic attributes.</li>
</ul></li>
<li>Rendering：<strong>渲染器</strong>
<ul>
<li>An image of the particles is rendered in the frame buffer, often
using special purpose algorithms.</li>
</ul></li>
<li>Force field：<strong>交互，外界的影响</strong> affector
<ul>
<li>assign a force (can be different) to each particles to produce
acceleration</li>
</ul></li>
</ul>
<h2 id="其他">其他</h2>
<ul>
<li>与环境交互
<ul>
<li>火焰吹风，得动起来</li>
<li>小球沿着坡滚下来</li>
</ul></li>
<li>粒子的行为
<ul>
<li>行为规则（内在）</li>
<li>环境（外在，交互）</li>
</ul></li>
<li>粒子湮灭
<ul>
<li>Lifetime decremented each frame, particle is killed when it reaches
zero</li>
<li>Kill particles that no longer contribute to image
(<strong>transparency below a certain threshold</strong>, etc.).</li>
</ul></li>
<li>粒子系统很好玩，但是很难做
<ul>
<li>粒子系统引擎</li>
<li>交互式编辑（灵活、泛化）</li>
<li>给定一个任意场景（环境因素）
<ul>
<li>给定一个山形，构建一个符合这个山形的瀑布（很难）</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.LS</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学.李胜.08.真实感绘制之光照明(2)</title>
    <url>/2021/02/06/CG/LS/08-1/</url>
    <content><![CDATA[<h1 id="整体光照明模型">整体光照明模型</h1>
<ul>
<li>全局光照明 / 整体光照明</li>
<li>还要考虑周围环境的光对物体表面的影响（<strong>间接光照</strong>）
<ul>
<li>光亮平滑的物体会将环境中其它物体映象在表面上</li>
<li>透过透明物体可以看到其后的环境景象</li>
</ul></li>
<li>更精致的真实感图形的绘制还要考虑物体表面的<strong>细节纹理</strong>（纹理映射）</li>
</ul>
<h2 id="物体表面入射光的构成">物体表面入射光的构成</h2>
<ol type="1">
<li><p>光源直接照射</p></li>
<li><p>其他物体的反射光</p></li>
<li><p>透射光</p></li>
</ol>
<ul>
<li>局部光照明模型仅考虑了 (1)</li>
</ul>
<h2 id="整体光照明方程">整体光照明方程</h2>
<ul>
<li>Whitted 模型</li>
</ul>
<p><span class="math display">\[
I_\lambda=I_{l\lambda}+K_sC_{c\lambda}I_{s\lambda}+K_tC_{t\lambda}T_{t\lambda}
\]</span></p>
<ul>
<li>局部光照明 + 其他表面光的反射光 + 物体背面的透射光</li>
</ul>
<h2 id="分类">分类</h2>
<ul>
<li>辐射度类
<ul>
<li>VPL：Virtual Point Light</li>
<li>辐射度方法</li>
</ul></li>
<li>光线跟踪类
<ul>
<li>metropolis light</li>
<li>photon mapping</li>
<li>蒙特卡洛光线追踪</li>
</ul></li>
</ul>
<h2 id="其他概念">其他概念</h2>
<ul>
<li>路径追踪
<ul>
<li>狭义：蒙特卡洛光线跟踪</li>
<li>广义：光线跟踪</li>
</ul></li>
</ul>
<h1 id="初级光线跟踪法">初级光线跟踪法</h1>
<ul>
<li>光线跟踪法
<ul>
<li>1968，Apple A
研究隐藏面消除算法时[APPL68]，给出了光线跟踪算法的描述</li>
<li>1979，Kay 和 Greenberg 的研究考虑了光的折射[KAY79]</li>
<li>1980，Whitted 提出了第一个整体光照 Whitted模型[WHIT80]</li>
</ul></li>
<li>注意光线跟踪不走经典的 pipeline（不同于经典的绘制管线）</li>
<li>光的传播过程
<ul>
<li>光源 <span class="math inline">\(\rightarrow\)</span> 物体表面 <span class="math inline">\(\rightarrow\)</span> 物体表面 <span class="math inline">\(\rightarrow\dots\rightarrow\)</span> 物体表面
<span class="math inline">\(\rightarrow\)</span> 人眼</li>
</ul></li>
<li>光线跟踪过程——光线传播的逆过程
<ul>
<li><strong>逆过程</strong>：不从光源出发，而从视点出发</li>
<li>若从光源出发，光线进入人眼的概率<strong>极低</strong></li>
</ul></li>
</ul>
<p><img src="/2021/02/06/CG/LS/08-1/ray-tracing.png"></p>
<ul>
<li>是一个递归的过程</li>
<li>列出方程，求解
<ul>
<li>模拟解 $ $</li>
<li>数值解 <span class="math inline">\(\times\)</span></li>
</ul></li>
</ul>
<h2 id="光线跟踪的关键问题">光线跟踪的关键问题</h2>
<ul>
<li>光线与物体表面的<strong>求交</strong></li>
<li>逢交点考察<strong>反射</strong>和<strong>折射</strong></li>
<li>阴影测试线
<ul>
<li>判断待计算点是否对光源可见</li>
</ul></li>
<li>终止条件
<ul>
<li>虽然在理想情况下，光线可以在物体之间进行无限的反射和折射</li>
<li>但是在实际的算法进行过程中，我们不可能进行无穷的光线跟踪</li>
<li>因而需要给出一些跟踪的终止条件</li>
</ul></li>
</ul>
<h2 id="几种可行的终止条件">几种可行的终止条件</h2>
<ul>
<li>该光线未碰到任何物体</li>
<li>该光线碰到了背景</li>
<li>光线在经过许多次反射和折射以后，就会产生衰减，光线对于视点的光强贡献很小
<ul>
<li>小于某个设定值</li>
</ul></li>
<li>光线反射或折射次数即跟踪深度大于一定值</li>
</ul>
<h2 id="算法">算法</h2>
<ul>
<li>从视点出发，对于视屏上的每一个象素点，从视点作一条到该象素点的射线，调用该算法函数就可以确定这个象素点的颜色</li>
<li>对所得的全部交点进行排序，确定可见点</li>
</ul>
<h2 id="hall-模型">Hall 模型</h2>
<p><span class="math display">\[
I=I_{ed}+I_{ld}+I_{ls}+I_{tr}
\]</span></p>
<ul>
<li>环境起的漫反射光亮度 + 光源引起的漫反射光度 + 光源引起的面反射光亮度
+ 光源引起的规则透射亮度</li>
<li>漫反射 + 透射高光</li>
<li>算法一些要点
<ul>
<li>光强衰减：终止条件</li>
<li>反射 + 折射</li>
</ul></li>
</ul>
<h2 id="光线与物体表面求交">光线与物体表面求交</h2>
<h3 id="分类求交">分类求交</h3>
<ul>
<li>光线与平面求交</li>
<li>光线与球面求交</li>
<li>光线与圆柱面求交</li>
<li>光线与二次曲面求交</li>
<li>光线与参数曲面求交</li>
</ul>
<h2 id="光线跟踪算法的加速">光线跟踪算法的加速</h2>
<ul>
<li>提高求交速度</li>
<li>减少求交次数
<ul>
<li>减少无效求交</li>
</ul></li>
<li>减少光线条数
<ul>
<li>下采样</li>
</ul></li>
<li>采用并行算法</li>
</ul>
<h2 id="减少求交次数">减少求交次数</h2>
<h3 id="包围盒及层次结构">包围盒及层次结构</h3>
<ul>
<li>树状结构</li>
<li>景物的分布情况，将相距较近的景物组成一组局部场景，相邻各组又组成更大的组，这样，将整个景物空间组织成树状的层次结构</li>
</ul>
<h3 id="三维-dda-算法">三维 DDA 算法</h3>
<ul>
<li>是一个增量算法
<ul>
<li>在一个迭代算法中，每一步的 x、y
值是用前一步的值加上一个增量来获得</li>
</ul></li>
<li>基本思想
<ul>
<li>将景物空间剖分为网络，由于空间的连贯性，被跟踪的光线从起始点出发，依次穿越它所经过的空间网格，直至第一个交点，这种方法称为空间剖分技术，可以利用这种空间相关性来加速光线跟踪</li>
</ul></li>
<li>三维 DDA 网格跨越过程，根据 d
空间八叉树剖分技术确定两组始面和终面，并得到最终终面，以此终面为下一个穿越立方格</li>
<li>算法对于稠密的场景，选取适当的空间剖分分辨率，可以使算法非常有效</li>
</ul>
<h3 id="空间八叉树剖分技术">空间八叉树剖分技术</h3>
<ul>
<li>空间非均匀网格剖分算法</li>
<li>利用了空间连贯性</li>
</ul>
<h2 id="减少光线条数">减少光线条数</h2>
<ul>
<li>随机采样：蒙特卡洛采样
<ul>
<li>存在噪声</li>
<li>采样点越多，噪声越小</li>
</ul></li>
<li>神经网络</li>
</ul>
<h2 id="光线跟踪算法评价">光线跟踪算法评价</h2>
<ul>
<li>实现<strong>全局光照明</strong>，易于实现光滑物体之间彼此反射的影响，因此显示效果<strong>十分逼真</strong></li>
<li>有<strong>消隐</strong>功能：采用光线跟踪方法，在显示的同时，自然完成消隐功能</li>
<li>有<strong>阴影</strong>效果：光线跟踪能完成阴影的生成和显示</li>
<li>该算法具有<strong>并行</strong>性质
<ul>
<li>每条光线的处理过程相同，结果彼此独立，因此可以大并行处理的硬件上快速实现光线跟踪算法</li>
</ul></li>
<li>光线跟踪算法的缺点是<strong>计算量非常大</strong>，因此，显示速度极慢，随视点变化而重新计算</li>
</ul>
<h2 id="glossy-reflection-refraction">Glossy reflection &amp;
refraction</h2>
<ul>
<li>带有光泽的反射与折射</li>
</ul>
<p><img src="/2021/02/06/CG/LS/08-1/cone.png"></p>
<ul>
<li>控制圆锥顶角的大小，从而控制粗糙度（镜面高光/漫反射）</li>
</ul>
<h2 id="photon-mapping">Photon Mapping</h2>
<ul>
<li>光子映射</li>
<li>对于透明物体的高光模拟的很好
<ul>
<li>焦散（caustics）</li>
<li>焦散是指当光线穿过一个透明物体时，由于对象表面的不平整，使得光线折射并没有平行发生，出现漫折射，投影表面出现光子分散</li>
</ul></li>
</ul>
<h2 id="光线跟踪算法评价-1">光线跟踪算法评价</h2>
<ul>
<li>较好地模拟了光在光滑物体表面之间的反射和折射现象</li>
<li>无法模拟光在景物之间<strong>漫反射</strong>引起的<strong>彩色渗透</strong>现象（多重漫反射效果）</li>
</ul>
<h1 id="初级辐射度算法">初级辐射度算法</h1>
<ul>
<li>面对早期的光线跟踪算法只能处理光滑表面而产生的</li>
<li>1984，美国 Cornell
大学和日本广岛大学的学者分别将<strong>热辐射工程</strong>中的<strong>辐射度方法</strong>引入到计算机图形学中</li>
<li>辐射度方法
<ul>
<li>将场景看作一个<strong>封闭的系统</strong>，<strong>能量多重反射</strong>，最终达到<strong>平衡</strong>状态。</li>
<li>根据<strong>能量守恒定律</strong>，计算出每一个表面上的能量</li>
<li>选定观察点，采用绘制算法计算出被观察点的颜色</li>
<li>与<strong>视点</strong>无关：广泛用于<strong>虚拟漫游</strong></li>
<li>主要问题：<strong>提高算法效率</strong></li>
</ul></li>
</ul>
<h2 id="主要问题">主要问题</h2>
<ul>
<li>求解场景的辐射度积分方程
<ul>
<li>数值解，利用Gauss-Siedel迭代，Southwell迭代</li>
</ul></li>
<li>景物表面网格剖分及其形状因子
<ul>
<li>有限元方法，半立方体法</li>
</ul></li>
</ul>
<h2 id="基础理论原理">基础理论原理</h2>
<h3 id="立体角">立体角</h3>
<ul>
<li><span class="math inline">\(d\omega=\dfrac{dS}{r^2}\)</span></li>
</ul>
<p><img src="/2021/02/06/CG/LS/08-1/SolidAngle.png" style="zoom:50%;"></p>
<ul>
<li><span class="math inline">\(dA_2=dS=rd\theta\ast r\sin\theta
d\psi\)</span>
<ul>
<li>矩形近似，边长为弧长</li>
</ul></li>
<li><span class="math inline">\(d\omega=\sin\theta d\theta
d\psi\)</span></li>
</ul>
<p><img src="/2021/02/06/CG/LS/08-1/SolidAngle2.png"></p>
<ul>
<li>球的立体角：<span class="math inline">\(4\pi\)</span></li>
</ul>
<h3 id="光强度">光强度</h3>
<ul>
<li>光通量：单位时间通过的光能
<ul>
<li>单位：流明</li>
<li>图形学中往往讲瞬时，因此往往将光通量和光能混用</li>
</ul></li>
<li>为表征物体在某一方向上的发光情况，定义<strong>某方向</strong>上<strong>单位立体角</strong>内的<strong>光通量</strong>为该方向上的光强度，记为
<span class="math inline">\(J\)</span></li>
<li><span class="math inline">\(J=\dfrac{dF}{d\omega}\)</span></li>
</ul>
<h3 id="光亮度">光亮度</h3>
<ul>
<li>将<span style="color:red;font-weight:bold">发光面元</span><strong>单位面积</strong>上向某方向辐射的光能称为光亮度，记为
<span class="math inline">\(I\)</span></li>
<li><span class="math inline">\(I=\dfrac{J\cdot \cos
i}{dS_i}=\dfrac{dF\cdot\cos i}{dS_i\cdot d\omega}\)</span>
<ul>
<li>这里 <span class="math inline">\(i\)</span>
是法向和辐射法向的夹角</li>
</ul></li>
<li>光亮度决定了人眼接收的光能的大小和色彩组成</li>
<li>光能接受面元所对应的立体角大小
<ul>
<li><span class="math inline">\(dw&#39;=\dfrac{\cos\theta
dA(x)}{r^2}\)</span>
<ul>
<li><span class="math inline">\(A(x)\)</span>：面积</li>
<li><span class="math inline">\(\theta\)</span>：两个面的法向夹角</li>
<li><span class="math inline">\(r\)</span>：距离</li>
</ul></li>
</ul></li>
</ul>
<h3 id="辐射度算法的假设">辐射度算法的假设</h3>
<ul>
<li>假设一封闭环境中，景物表面均为理想漫反射表面
<ul>
<li>景物表面上，每一点向周围各方向辐射的<strong>光亮度</strong>是相同的</li>
<li>表面各点处的光亮度只与位置有关，与辐射的方向无关</li>
</ul></li>
<li>假设 <span class="math inline">\(dP\)</span>
为表面某一点处<strong>单位面积</strong>上朝<strong>某辐射方向</strong>发出的<strong>光通量</strong>，则与该点处沿同一方向的光亮度
<span class="math inline">\(I\)</span> 的关系为
<ul>
<li><span class="math inline">\(dP=I\cos\theta d\omega\)</span></li>
<li>其中 <span class="math inline">\(\theta\)</span>
为该点处的法向与辐射方向之间的夹角</li>
<li>Lambert 漫反射模型</li>
</ul></li>
<li>则该点处单位面积面元向其四周半空间辐射的总能量（总辐射度 <span class="math inline">\(B\)</span>）</li>
</ul>
<p><span class="math display">\[
B=\int_{\Omega}dP=\int_{\Omega}I\cos\theta
d\omega=I\int_0^{2\pi}\int_0^{\dfrac{\pi}{2}}\cos\theta\sin\theta
d\theta d\psi=I\pi
\]</span></p>
<ul>
<li>理想漫反射表面每一点处的<strong>辐射度值</strong>与<strong>光亮度值</strong>之比为一常数因子，因而表面各点的光亮度计算可通过求解整个场景的辐射度方程而得到</li>
<li>假设周围环境为一封闭系统，则表面上每一点处微面元向周围环境辐射的能量由它自身所具有的辐射光能和它接受来自环境中其他景物表面向该点辐射的光能组成
<ul>
<li>周围环境入射到微面元上的光能为 <span class="math inline">\(H(x)\)</span></li>
<li>该表面在此处的漫反射率 <span class="math inline">\(\rho(x)\)</span></li>
<li>则微面元对环境入射光能的反射而产生的那部分辐射光能为 <span class="math inline">\(\rho(x)H(x)\)</span></li>
<li>由此，此点处的辐射度满足 <span class="math inline">\(B(x)dA(x)=E(x)dA(x)+\rho(x)H(x)\)</span>
<ul>
<li><span class="math inline">\(dA(x)\)</span> 为微面元 <span class="math inline">\(dS(x)\)</span> 的面积</li>
<li><span class="math inline">\(E(x)\)</span> 为该表面在 <span class="math inline">\(x\)</span> 点处的<strong>自身辐射度</strong>
<ul>
<li>若该表面为漫反射光源，<span class="math inline">\(E(x)&gt;0\)</span>
，否则 <span class="math inline">\(E(x)=0\)</span></li>
</ul></li>
<li>自发光 + 周围照射</li>
</ul></li>
</ul></li>
<li>可以对每个面元离散化，使用矩阵求解</li>
</ul>
<p><span class="math display">\[
\begin{bmatrix}
B_1\\
B_2\\
\vdots\\
B_n
\end{bmatrix}
=
\begin{bmatrix}
E_1\\
E_2\\
\vdots\\
E_n
\end{bmatrix}
+
\begin{bmatrix}
&amp;\cdots\\
\rho_iF_{i1}&amp;\cdots&amp;\rho_iF_{in}\\
&amp;\cdots\\
\end{bmatrix}
\begin{bmatrix}
B_1\\
B_2\\
\vdots\\
B_n
\end{bmatrix}
\]</span></p>
<ul>
<li>辐射度算法：色彩柔和（基于漫反射）</li>
</ul>
<h1 id="其他">其他</h1>
<ul>
<li>Fluoresence（荧光效果）</li>
<li>海面模拟</li>
<li>折射：单层 / 双层
<ul>
<li>入射、出射的折射</li>
</ul></li>
</ul>
<p><img src="/2021/02/06/CG/LS/08-1/refraction.png"></p>
]]></content>
      <categories>
        <category>CG.LS</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学.李胜.09.纹理映射</title>
    <url>/2021/02/20/CG/LS/09/</url>
    <content><![CDATA[<h1 id="纹理及纹理映射基本原理">纹理及纹理映射基本原理</h1>
<h2 id="纹理">纹理</h2>
<ul>
<li>纹理 / 贴图</li>
<li>纹理是物体表面的细小结构</li>
<li><strong>颜色纹理</strong>、<strong>几何纹理</strong></li>
<li>纹素：纹理像素</li>
</ul>
<h3 id="颜色纹理">颜色纹理</h3>
<ul>
<li>光滑表面的花纹、图案</li>
</ul>
<h3 id="几何纹理">几何纹理</h3>
<ul>
<li>基于物体表面的微观几何形状的表面纹理</li>
<li>粗糙的表面
<ul>
<li>例：桔子表面的皱纹)</li>
</ul></li>
<li><strong>修改几何</strong>、<strong>法向扰动</strong></li>
</ul>
<h2 id="模拟物体表面细节">模拟物体表面细节</h2>
<h3 id="模拟细节多边形">模拟细节多边形</h3>
<ul>
<li>根据代生成的纹理构造细节多边形</li>
<li>将细节多边形贴到物体表面</li>
<li><strong>很麻烦</strong></li>
</ul>
<p><img src="/2021/02/20/CG/LS/09/T.png"></p>
<ul>
<li>例如上图中的前向面
<ul>
<li>如果使用纹理贴图的话，只需要两张图即可（底层浅灰色+T的深灰色）</li>
<li>如果使用模拟多边形的话，需要将整个面划分为<strong>若干个三角形</strong>，将这些三角形分别着色（灰/深灰）</li>
</ul></li>
</ul>
<h2 id="纹理映射">纹理映射</h2>
<h3 id="纹理的表示">纹理的表示</h3>
<h4 id="图象纹理">图象纹理</h4>
<ul>
<li>将二维纹理图案映射到三维物体表面，绘制物体表面上一点时，采用相应的纹理图案中相应点的颜色值</li>
</ul>
<h4 id="函数纹理">函数纹理</h4>
<ul>
<li>用数学函数定义简单的二维纹理图案，如方格地毯</li>
<li>或用数学函数定义随机高度场，生成表面粗糙纹理即几何纹理
<ul>
<li>噪声</li>
</ul></li>
</ul>
<h3 id="纹理映射-1">纹理映射</h3>
<ul>
<li>当物体表面是<strong>多边形</strong>时，直接给定多边形顶点的纹理坐标</li>
<li>当物体表面是<strong>参数曲面</strong>时，给定参数与纹理坐标之间的关系</li>
</ul>
<h3 id="纹理映射的步骤">纹理映射的步骤</h3>
<ul>
<li>将屏幕像素的四个角点映射到景物坐标空间中可见的物体表面上</li>
<li>将景物坐标空间映射到纹理坐标空间</li>
<li>将像素所对应的纹理坐标空间中的四边形内的所有纹素的值作<strong>加权平均</strong>，结果作为<strong>物体表面的漫反射系数参与颜色计算</strong>
<ul>
<li>加权平均只是其中一种方法</li>
<li>作为漫反射系数参与计算只是其中一种用途</li>
</ul></li>
</ul>
<p><img src="/2021/02/20/CG/LS/09/mapping.png"></p>
<h3 id="一些纹理映射">一些纹理映射</h3>
<ul>
<li>纹理图象模拟国际象棋上黑白相间的方格</li>
</ul>
<h3 id="常用的纹理映射方法">常用的纹理映射方法</h3>
<h4 id="圆柱面映射">圆柱面映射</h4>
<p><img src="/2021/02/20/CG/LS/09/cylindrical.png"></p>
<ul>
<li>参数方程</li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{**lr**}
x=\cos(2\pi u) &amp;0\le u\le1\\
y=\sin(2\pi u) &amp;0\le v\le1\\
z=v
\end{array}
\right.
\]</span></p>
<ul>
<li>反求参数</li>
</ul>
<p><span class="math display">\[
(u,v)=
\left\{
\begin{array}{**lr**}
(y,z)&amp;,x=0\\
(x,z)&amp;,y=0\\
(\dfrac{\sqrt{x^2+y^2}-|y|}{x},z)&amp;,else
\end{array}
\right.
\]</span></p>
<h4 id="球面映射">球面映射</h4>
<ul>
<li>参数方程</li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{**lr**}
x=\cos(2\pi u)\cos(2\pi v) &amp;0\le u\le1\\
y=\sin(2\pi u)\cos(2\pi v) &amp;0\le v\le1\\
z=\sin(2\pi v)
\end{array}
\right.
\]</span></p>
<ul>
<li>反求参数</li>
</ul>
<p><span class="math display">\[
(u,v)=
\left\{
\begin{array}{**lr**}
(0,0)&amp;,(x,y)=(0,0)\\
(\dfrac{1-\sqrt{1-(x^2+y^2)}}{x^2+y^2}x,\dfrac{1-\sqrt{1-(x^2+y^2)}}{x^2+y^2}y&amp;,else
\end{array}
\right.
\]</span></p>
<h3 id="两步法纹理映射">两步法纹理映射</h3>
<ul>
<li>Bier 和 Sloan 提出，应用于三维曲面上</li>
</ul>
<h4 id="步骤">步骤</h4>
<ul>
<li>先映射到一个简单的三维曲面上，如平面，柱面，球面或者立方体上（<strong>中介曲面</strong>）</li>
<li>把变形后的映射结果映射到最终曲面上</li>
</ul>
<h4 id="从中介曲面到物体表面的映射方式">从中介曲面到物体表面的映射方式</h4>
<ul>
<li>反射光线法</li>
<li>物体法向法</li>
<li>物体中心法</li>
<li>中介表面法向法</li>
</ul>
<h3 id="一些问题">一些问题</h3>
<ul>
<li>大片屏幕区域使用同一个纹素（<strong>色块效应</strong>）</li>
<li>一个像素对应很大区域的纹素</li>
<li><strong>纹理的走样</strong></li>
</ul>
<h1 id="特殊类别纹理映射">特殊类别纹理映射</h1>
<h2 id="环境映射">环境映射</h2>
<ul>
<li>Blinn 和 Newell 提出</li>
<li><strong>环境被映照到一个大的球面上</strong></li>
</ul>
<h3 id="解决的问题">解决的问题</h3>
<ul>
<li>如果目的是为了渲染场景中的一个杯子（小物体），若利用光线跟踪方法，需要对整个场景进行建模渲染，<strong>计算量极大</strong></li>
<li>效果比光线跟踪差，但是计算量要小很多</li>
</ul>
<h3 id="方法">方法</h3>
<ul>
<li>从视点出发，向待绘制的物体表面上一点发出一条光线，求在该点的反射光线与环境球面的交点</li>
<li>平面情况处理，用虚视点方法</li>
<li>环境纹理的获取
<ul>
<li><strong>实拍</strong></li>
<li><strong>生成</strong></li>
</ul></li>
</ul>
<h3 id="一种环境映射-cube-map">一种环境映射 cube map</h3>
<p><img src="/2021/02/20/CG/LS/09/cube-map1.png" style="zoom:80%;"></p>
<p><img src="/2021/02/20/CG/LS/09/cube-map2.png" style="zoom:80%;"></p>
<h2 id="过程纹理">过程纹理</h2>
<ul>
<li>一个小的纹理样本，通过一些简单的变化（相关到那时不一样）形成一片纹理</li>
<li>例如：斑马纹、豹纹等</li>
<li>木头纹理</li>
<li>三维体纹理
<ul>
<li>二维纹理图象或纹理函数 sweep（平移、旋转等）</li>
<li>Fourier合成</li>
<li>噪声函数随机合成</li>
</ul></li>
</ul>
<h2 id="d-体纹理">3D 体纹理</h2>
<ul>
<li>动物毛皮（制作得很真实极难）</li>
<li>精细建模：计算量很大</li>
<li>不精细建模：整体效果粗糙，边界粗糙</li>
</ul>
<h3 id="体纹理绘制方法">体纹理绘制方法</h3>
<ul>
<li>基于 shells 的绘制策略</li>
<li>初始的带点的一张图片，通过微小的偏移形成毛发效果</li>
</ul>
<p><img src="/2021/02/20/CG/LS/09/shells.png"></p>
<ul>
<li>毛发绘制真实感
<ul>
<li>加入阴影</li>
<li>可变长度</li>
</ul></li>
</ul>
<h2 id="纹理反走样">纹理反走样</h2>
<h3 id="mipmapping-反走样">MipMapping 反走样</h3>
<ul>
<li><strong>图象金字塔</strong></li>
<li>从高分辨率到低分辨率，<strong>分层存储</strong></li>
<li>纹理颜色的平均，正方形滤波器作卷积</li>
<li>解决的问题：纹素分辨率与渲染图像分辨率不匹配
<ul>
<li>假使原先是匹配的，视点的改变也会导致不匹配（距离变化）</li>
</ul></li>
</ul>
<p><img src="/2021/02/20/CG/LS/09/mipmap.png"></p>
<ul>
<li>使用的时候按照距离的远近选择不同的分辨率</li>
<li>例如：每次缩小一半
<ul>
<li>RGB 3通道，一个方便的存储方式</li>
</ul></li>
</ul>
<p><img src="/2021/02/20/CG/LS/09/rgb-mipmap.png" style="zoom:80%;"></p>
<ul>
<li>使用 mipmap 之后过度更加柔和</li>
</ul>
<h3 id="sat-表反走样">SAT 表反走样</h3>
<ul>
<li>将屏幕像素的4个顶点做映射，找到在纹理中中对应的4个点，对这4个点围成的区域中的纹素表示屏幕像素的纹理
<ul>
<li>表示方式：均值、滤波等</li>
</ul></li>
<li>相对低效，因此会采用矩形近似的方法（横平竖直的矩形）</li>
</ul>
<p><img src="/2021/02/20/CG/LS/09/SAT.png"></p>
<ul>
<li>加速
<ul>
<li>动态规划加速</li>
<li>每个顶点记录和原点组成的矩形内像素的<strong>和</strong></li>
</ul></li>
</ul>
<h2 id="三维纹理域的映射">三维纹理域的映射</h2>
<ul>
<li>物体中每一个点 <span class="math inline">\((x,y,z)\)</span>
均有一个纹理值 <span class="math inline">\(t(x,y,z)\)</span>，其值由纹理函数 <span class="math inline">\(t(x,y,z)\)</span> 唯一确定</li>
<li>三维纹理映射的纹理空间定义在三维空间上，与物体空间维数相同，在纹理映射的时候，只需把场景中的物体变换到纹理空间的局部坐标系中去即可</li>
</ul>
<h2 id="几何纹理之法向扰动法">几何纹理之法向扰动法</h2>
<ul>
<li><strong>效果很棒</strong></li>
<li>目标：产生几何纹理，模拟凸凹不平的物体表面</li>
<li>应用：自然界中植物的表皮等</li>
<li>方法：对物体表面微观形状进行扰动</li>
</ul>
<h3 id="bump-map凹凸贴图">bump map（凹凸贴图）</h3>
<ul>
<li>凹凸贴图是指计算机图形学中在三维环境中通过纹理方法来产生表面凹凸不平的视觉效果。它主要的原理是通过<strong>改变表面光照方程的法线</strong>，而不是表面的几何法线来模拟凹凸不平的视觉特征，如褶皱、波浪等等。凹凸贴图的实现方法主要有：偏移向量凹凸纹理和改变高度场（百度百科）</li>
</ul>
<h3 id="法向扰动">法向扰动</h3>
<ul>
<li>对物体表面几何性质作微小扰动，产生凹凸不平的细节效果，给物体表面图象加上一个粗糙的外观</li>
<li>物体表面上的每一个点 <span class="math inline">\(P(u,v)\)</span>，都沿该点处的法向量方向位移 <span class="math inline">\(F(u,v)\)</span> 个单位长度，新表面位置 <span class="math inline">\(\widetilde{P}(u,v)=P(u,v)+F(u,v)*N(u,v)\)</span></li>
<li>新表面的计算方法：通过对两个偏导数求叉积得到</li>
</ul>
<p><span class="math display">\[
\widetilde{N}=\widetilde{P_u}\times\widetilde{P_v}\\
\widetilde{P_u}=\dfrac{d(P+FN)}{du}=P_u+F_uN+FN_u\\
\widetilde{P_v}=\dfrac{d(P+FN)}{dv}=P_u+F_vN+FN_v\\
\]</span></p>
<ul>
<li>由于 <span class="math inline">\(F\)</span> 很小，作近似计算</li>
</ul>
<p><span class="math display">\[
\widetilde{N}\approx(P_u+F_uN)\times(P_u+F_vN)
\]</span></p>
<h4 id="几何纹理实现">几何纹理实现</h4>
<ul>
<li>扰动后的法向量<strong>单位化</strong>，用于计算曲面的明暗度，产生凹凸不平的几何纹理</li>
<li><span class="math inline">\(F\)</span>
的偏导数的计算，可以用中心差分实现</li>
<li>几何纹理函数定义可以用统一的图案纹理记录
<ul>
<li>图案中较暗的颜色对应较小 <span class="math inline">\(F\)</span>
值</li>
<li>较亮的颜色对应较大 <span class="math inline">\(F\)</span> 值</li>
<li>把各象素的值一个二维数组记录下来</li>
</ul></li>
<li>在实际操作中直接给每个点新的法向即可（即上述说的记录）</li>
</ul>
<h1 id="parallax-mapping-relief-mapping">parallax mapping &amp; relief
mapping</h1>
<h2 id="parallax-mapping">parallax mapping</h2>
<ul>
<li><strong>视差贴图</strong></li>
<li>普通纹理映射存在的问题：<strong>立体感不强</strong>
<ul>
<li>原因是因为之前的纹理并没有考虑实际场景中的物体内容</li>
<li>在视角变化下，实际看到的纹理内容会有变化
<ul>
<li>实际看到的是 <span class="math inline">\(T_{ideal}\)</span> 而不是
<span class="math inline">\(T\)</span></li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/02/20/CG/LS/09/parallax-mapping-01.png" style="zoom:50%;"></p>
<ul>
<li>视差贴图的纹理与<strong>内容相关</strong>，估计/计算真正的纹理位置</li>
<li>Kaneko (2001)
<ul>
<li>take an educated guess of what should be seen in a pixel by
examining the height of what was found to be visible
<ul>
<li>在高度场（height field）中检测像素的可见性</li>
</ul></li>
<li>Height field texture can be stored in unused color channel (alpha)
<ul>
<li>将高度场信息保存在透明度通道</li>
</ul></li>
</ul></li>
</ul>
<h3 id="方法1">方法1</h3>
<ul>
<li>直接给定一个 offset​（箭头表示视线）</li>
</ul>
<p><span class="math display">\[
P_{adj}=P+\dfrac{h\cdot v_{xy}}{v_z}=p+h\tan\theta
\]</span></p>
<ul>
<li><span class="math inline">\(v_z,v_{xy}\)</span> 视线的偏移量</li>
</ul>
<p><img src="/2021/02/20/CG/LS/09/parallax-mapping-02.png" style="zoom:50%;"></p>
<ul>
<li>不准确
<ul>
<li>尤其是浅视角（Shallow viewing angle）的时候，<span class="math inline">\(v_z\)</span> 很小，偏移量极大</li>
</ul></li>
</ul>
<h3 id="方法2">方法2</h3>
<ul>
<li>offset-limited，对 offset 进行限制没最多让其为 h
<ul>
<li>对 <span class="math inline">\(v_{xy}\)</span>
进行归一化（0-1）</li>
</ul></li>
</ul>
<p><span class="math display">\[
P_{adj}=P+h\cdot v_{xy}
\]</span></p>
<p><img src="/2021/02/20/CG/LS/09/parallax-mapping-03.png" style="zoom: 80%;"></p>
<ul>
<li>纹理内容 <span class="math inline">\(\rightarrow\)</span> 高度场
<span class="math inline">\(\rightarrow\)</span> 新的纹理坐标</li>
</ul>
<h2 id="同类技术的多种名称">同类技术的多种名称</h2>
<ul>
<li>Independently discovered under different names
<ul>
<li>parallax occlusion mapping</li>
<li>relief mapping</li>
<li>steep parallax mapping</li>
<li>inverse displacement mapping</li>
</ul></li>
<li>改进的方向：<strong>快速</strong>、<strong>效果</strong></li>
</ul>
<h2 id="relief-texture-mapping">Relief Texture Mapping</h2>
<ul>
<li>纹理 <span class="math inline">\(\rightarrow\)</span>
提炼出深度图作为高度场信息</li>
<li>如果视线和高度场只有一个交点，通过二分的方式进行查找交点，从而找到正确的纹理坐标</li>
</ul>
<p><img src="/2021/02/20/CG/LS/09/relief-texture-mapping.png"></p>
<ul>
<li>如果交点不止一个怎么办？
<ul>
<li>从外界开始步进探测视线与高度场的第一个交点（粗糙查找）</li>
<li>步进找到粗糙的位置之后，进行二分检测（精确）</li>
<li>32 步一定能找到</li>
</ul></li>
</ul>
<p><img src="/2021/02/20/CG/LS/09/relief-texture-mapping-03.png"></p>
<p><img src="/2021/02/20/CG/LS/09/relief-texture-mapping-02.jpg"></p>
<h2 id="阴影计算">阴影计算</h2>
<ul>
<li>在找到位置之后，直接计算光照</li>
<li>在找纹理位置的同时就已经解决了阴影的问题</li>
</ul>
<p><img src="/2021/02/20/CG/LS/09/relief-texture-mapping-04.png"></p>
<h2 id="更加复杂的纹理">更加复杂的纹理</h2>
<ul>
<li>Relief mapping of non-height-field surface details
<ul>
<li>Fabio Policarpo, Manuel M. Oliveira</li>
</ul></li>
<li>多层次高度场</li>
</ul>
<p><img src="/2021/02/20/CG/LS/09/relief-texture-mapping-05.png"></p>
<h1 id="其他">其他</h1>
<ul>
<li>遵照物理模型的自然现象模拟</li>
<li>夜空光照</li>
<li>不同时刻不同散射系数的天空光</li>
<li>天空体积云及光照</li>
<li>云状物及爆照效果</li>
<li>火焰</li>
<li>烟雾</li>
<li>间接阴影</li>
<li>复杂材质光照特性</li>
<li>焦散</li>
<li>半透明材质</li>
</ul>
]]></content>
      <categories>
        <category>CG.LS</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学.李胜.10.高级光照模型与绘制理论</title>
    <url>/2021/02/22/CG/LS/10/</url>
    <content><![CDATA[<h1 id="brdf反射模型">BRDF反射模型</h1>
<ul>
<li>Bidirectional Reflectance Distribution Function</li>
<li>双向反射率分布函数</li>
<li>用来描述物体的<strong>材料属性</strong>，表示光如何从一个表面反射出去</li>
<li>输入参数：5
<ul>
<li>入射光和发射光的方位角 <span class="math inline">\(\phi\)</span>、仰角 <span class="math inline">\(\theta\)</span></li>
<li>入射光的波长 <span class="math inline">\(\lambda\)</span></li>
</ul></li>
<li>输出一个无单位的值
<ul>
<li>表示对于给定的入射方向，在发射方向反射出去能量的<strong>比例</strong></li>
<li>BRDF 给出了入射光子在某一方向离开的<strong>概率</strong>
<ul>
<li>立体角对应的面上的能量</li>
</ul></li>
</ul></li>
<li>incoming / outgoing</li>
</ul>
<p><img src="/2021/02/22/CG/LS/10/brdf.png" style="zoom:60%;"></p>
<ul>
<li>BRDF
描述了入射辐射亮度和发射辐射亮度是如何相互联系的，但没有解释材料是如何在物理上与光相互作用的</li>
</ul>
<h2 id="brdf-的性质">BRDF 的性质</h2>
<ul>
<li>Helmholtz互反定理（Helmholtz reciprocity）
<ul>
<li>Value of BRDF remains unchanged if the incident and outgoing
directions are interchanged</li>
<li><strong>输入和输出角切换后函数值相同</strong></li>
</ul></li>
<li>能量守恒定律
<ul>
<li>the total amount of power reflected all directions must be less than
or equal to the total amount of power incident on the surface</li>
<li><strong>发射的能量小于等于入射的能量</strong></li>
</ul></li>
</ul>
<h2 id="brdf-的例子">BRDF 的例子</h2>
<h3 id="diffuse-漫反射">Diffuse 漫反射</h3>
<p><span class="math display">\[
F_r=\dfrac{\rho_d}{2\pi}
\]</span></p>
<ul>
<li><span class="math inline">\(\rho_d\)</span>
表示出射光占入射光的比例，0-1</li>
</ul>
<p><img src="/2021/02/22/CG/LS/10/diffuse.png" style="zoom: 50%;"></p>
<h3 id="specular-镜面高光">specular 镜面高光</h3>
<p><span class="math display">\[
Exitant\ direction:R=2(N\cdot\Psi)N-\Psi
\]</span></p>
<p><img src="/2021/02/22/CG/LS/10/specular.png" alt="1613960000494" style="zoom:50%;"></p>
<h3 id="一般物体">一般物体</h3>
<p><img src="/2021/02/22/CG/LS/10/brdf-normal.png" style="zoom:50%;"></p>
<h2 id="bssrdf">BSSRDF</h2>
<ul>
<li>BRDF
是更一般方程<strong>双向表面散射反射率分布函数</strong>的一种逼近
<ul>
<li>Bidirectional Surface Scattering Reflectance Distribution Function
(BSSRDF)</li>
</ul></li>
<li>BRDF 没有考虑表面内光的散射
<ul>
<li>大理石</li>
</ul></li>
<li>BSSRDF
通过把<strong>入射光的位置</strong>和<strong>发射光的位置</strong>作为函数的输入覆盖了散射现象
<ul>
<li>它描述的是光从入射方向在表面的<strong>某一点</strong>入射，然后在<strong>另一点</strong>沿发射方向发射的比率</li>
</ul></li>
</ul>
<h2 id="反射方程">反射方程</h2>
<ul>
<li>Reflectance Equation</li>
<li>给定一 BRDF
和入射辐射亮度分布，反射方程决定了表面在给定视域方向的发射辐射亮度。它通过在表面的半球面上对所有方向的入射辐射亮度进行积分得到</li>
</ul>
<p><span class="math display">\[
L(\theta_o,\phi_o)=\iint_{\Omega}f(\theta_o,\phi_o,\theta_i,\phi_i)L(\theta_i,\phi_i)\cos(\theta_i)d\sigma(\theta_i,\phi_i)
\]</span></p>
<ul>
<li><span class="math inline">\(i,o\)</span> 入射出射方向</li>
<li><span class="math inline">\(f\)</span> 表示 BRDF</li>
<li><span class="math inline">\(L\cos(\theta_i)\)</span>
将光线转化为正向入射</li>
<li>在<strong>半球面</strong>上积分</li>
<li>该方程对三个颜色分量<strong>单独</strong>计算</li>
</ul>
<h3 id="点光源的反射方程">点光源的反射方程</h3>
<ul>
<li><strong>点光源</strong>，简化为</li>
</ul>
<p><span class="math display">\[
L(\theta_o,\phi_o)=f(\theta_o,\phi_o,\theta_i,\phi_i)L(\theta_i,\phi_i)\cos(\theta_i)
\]</span></p>
<ul>
<li><span class="math inline">\((\theta_i,\phi_i)\)</span>
表示光源方向</li>
<li>向量表示</li>
</ul>
<p><span class="math display">\[
L(\vec{\omega_o})=f(\vec{\omega_o},\vec{\omega_i})L(\vec{\omega_i})(\vec{n}\cdot\vec{\omega_i})
\]</span></p>
<h2 id="brdf分布图">BRDF分布图</h2>
<ul>
<li>理解 BRDF
的一种方法为把入射方向保持恒定，然后观察其输出结果。对于给定方向的入射光，发射能量的分布不同。</li>
<li>交点附近的球面部分为漫反射项。椭圆形部分的为反射叶(reflectance
lobe)（镜面项），通常在入射光的反射方向。</li>
<li>Torrance-Sparrow 模型：镜面高光并非在反射方向最强</li>
</ul>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 37%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">漫反射表面</th>
<th style="text-align: center;">Phong/Blinn 高光 + 漫反射</th>
<th style="text-align: center;">Torrance-Sparrow模型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Ward’s各向异性模型</td>
<td style="text-align: center;">Hapke的BRDF模型</td>
<td style="text-align: center;">Lommel-Seeliger散射模型</td>
</tr>
</tbody>
</table>
<p><img src="/2021/02/22/CG/LS/10/brdf-01.png" alt="1613960889148" style="zoom:80%;"></p>
<h2 id="微面元">微面元</h2>
<ul>
<li><strong>microfacet</strong></li>
<li>微面元是物体表面上一种<strong>微小</strong>的、<strong>平坦</strong>的<strong>镜面</strong>，具有<strong>随机的大小和角度</strong></li>
</ul>
<p><img src="/2021/02/22/CG/LS/10/mmicrofacet.png" style="zoom:50%;"></p>
<ul>
<li>在 BRDF 模型中，一般处理成高斯分布
<ul>
<li>处理方便</li>
</ul></li>
<li>微面元描述典型反射
<ul>
<li><strong>镜面反射</strong>可以用一些微面元的<strong>直接反射</strong>来描述</li>
<li><strong>漫反射</strong>可以用微面元间的<strong>相互反射</strong>来描述</li>
<li>微面元之间还可以互相投射阴影</li>
</ul></li>
<li>当<strong>微面元的大小</strong>与<strong>光的波长</strong>相近时，还有一个重要概念
height correlation, 可用来模拟干涉、衍射等物理现象</li>
</ul>
<h2 id="菲涅尔反射">菲涅尔反射</h2>
<ul>
<li>Fresnel Reflectance</li>
<li>塑料、玻璃和水等绝缘体或电介质材料</li>
<li>当电介质材料以接近掠角（Grazing
angle）的角度观察时，反射会更厉害（但对于金属，该角度引起的反射变化相对较小）
<ul>
<li>当用最浅的掠角时，所有的材料变成全反射</li>
</ul></li>
<li>现象
<ul>
<li>手拿一本书，对准计算机的显示器，以很浅的角度去看其中的页面，在一个极端浅的角度，你可以看到屏幕在书上的反射</li>
</ul></li>
</ul>
<h3 id="菲涅尔反射公式">菲涅尔反射公式</h3>
<ul>
<li>菲涅尔反射的公式与折射率、衰减系数、入射角有关
<ul>
<li>绝缘体的折射率可设成是1.5</li>
<li>若衰减系数未知，可设置为0</li>
</ul></li>
<li>菲涅尔反射公式如下</li>
</ul>
<p><span class="math display">\[
F=\dfrac{1}{2}\dfrac{(g+c)^2}{(g-c)^2}(1+\dfrac{[c(g+c)-1]^2}{[c(g-c)+1]^2})
\]</span></p>
<p><span class="math display">\[
c=\vec{v}\cdot\vec{h}
\]</span></p>
<p><span class="math display">\[
g=\sqrt{n^2+c^2-1}
\]</span></p>
<ul>
<li><span class="math inline">\(\vec{v}\)</span> 为视线矢量，<span class="math inline">\(\vec{h}\)</span> 为半角矢量，<span class="math inline">\(n\)</span> 为折射率
<ul>
<li><span class="math inline">\(\vec{h}=\dfrac{1}{2}(\vec{v}+\vec{l})\)</span></li>
<li>入射光矢量、视线矢量</li>
</ul></li>
<li>一个 <span class="math inline">\(n=1.5\)</span> 的例子</li>
</ul>
<p><img src="/2021/02/22/CG/LS/10/fresnel.png" style="zoom: 80%;"></p>
<h2 id="torrance-sparrow-cook-torrance-brdf">Torrance-Sparrow /
Cook-Torrance BRDF</h2>
<ul>
<li>描述较光滑的表面</li>
<li>基于微面元
<ul>
<li>通过光线在微面元上的相互作用计算出一个衰减因子 <span class="math inline">\(G\)</span>
<ul>
<li>geometric attenuation factor</li>
<li>0-1：total shadowing - no shadowing</li>
</ul></li>
</ul></li>
</ul>
<h3 id="光线在微面元上传播的一些情况">光线在微面元上传播的一些情况</h3>
<h4 id="unblocked">unblocked</h4>
<h3 id="section"></h3>
<p><img src="/2021/02/22/CG/LS/10/unblocked.png" style="zoom:50%;"></p>
<h4 id="masking">masking</h4>
<ul>
<li>部分/全部出射光线被遮挡</li>
</ul>
<p><img src="/2021/02/22/CG/LS/10/masking.png" style="zoom:50%;"></p>
<h4 id="shadowing">shadowing</h4>
<ul>
<li>入射光线部分/全部被遮挡</li>
</ul>
<p><img src="/2021/02/22/CG/LS/10/shadowing.png" style="zoom:50%;"></p>
<h3 id="brdf">BRDF</h3>
<p><span class="math display">\[
\dfrac{F(l,h)G(l,v)D(h)}{4(n\cdot l)(n\cdot v)}
\]</span></p>
<ul>
<li><span class="math inline">\(l\)</span>：光源方向，<span class="math inline">\(v\)</span>：视线方向，<span class="math inline">\(n\)</span>：法向，<span class="math inline">\(h\)</span>：半角矢量</li>
<li><span class="math inline">\(G(l,v)\)</span>：Geometric Attenuation
Factor
<ul>
<li>reduces the output based on the amount of <strong>shadowing</strong>
or <strong>masking</strong> that occurs</li>
</ul></li>
<li><span class="math inline">\(F(l,h)\)</span>：Fresnel
term（菲涅尔反射）</li>
<li><span class="math inline">\(D(h)\)</span>：Distribution
<ul>
<li>distribution function determines what percentage of microfacet are
oriented to reflect in the viewer direction</li>
</ul></li>
<li><span class="math inline">\((n\cdot l)\)</span>：How much of the
macroscopic surface is visible to the light source</li>
<li><span class="math inline">\((n\cdot v)\)</span>：How much of the
macroscopic surface is visible to the viewer</li>
</ul>
<h2 id="如何获取-brdf">如何获取 BRDF</h2>
<ul>
<li>BRDF 理论模型的一个问题是它们不能表示特定的材料</li>
<li>获取真实表面的 BRDF
<ul>
<li>角度测定法（goniometers）</li>
<li>双向反射计成像法（imaging bidrectional reflectometers）</li>
<li>基于图像的方法（image-based methods）</li>
</ul></li>
<li>公开数据库下载
<ul>
<li>http://people.csail.mit.edu/wojciech/BRDFDatabase/
<ul>
<li>无法访问？</li>
</ul></li>
</ul></li>
</ul>
<h2 id="brdf-绘制实现方法">BRDF 绘制实现方法</h2>
<ul>
<li>应用 BRDF
的直接方法为计算顶点的颜色并把结果传到流水线。但其缺点是：如果 BRDF
反射在一些象素上的变化速度太快，线性插值会导致丢失或过分突出这种反射变化。一个解决方法是把表面加细，但会降低算法的性能。</li>
<li>对于给定的材料，如果有一种存取快速的简凑的表示方法，可以带来如下好处
<ul>
<li>避免精确理论模型的计算耗费</li>
<li>减少存贮量</li>
<li>减少实验获取BRDF中的噪声</li>
</ul></li>
<li>在实时绘制中，主要采用两种简凑的BRDF表示方法
<ul>
<li>Factorization 因数分解法</li>
<li>Environment map filtering 环境图滤波</li>
</ul></li>
</ul>
<h3 id="因数分解法">因数分解法</h3>
<ul>
<li>一种表示 BRDF 的方法为把 BRDF
表示成乘积项的和（而不是一系列基函数的加权和），其中每个乘积项包含两项</li>
<li>思想：把 BRDF
转化为一系列二维纹理对。每对纹理通过四维参数存取（2个入射角和2个发射角），返回的纹理值相乘后再相加，得到象素的颜色</li>
<li>初始的 BRDF 有两个方向矢量，入射矢量和发射矢量。因数分解法就是把
BRDF 表示成简单函数对乘积的和</li>
</ul>
<p><span class="math display">\[
f(\vec{\omega_i},\vec{\omega_o})\approx\sum_{j=1}^np_j(\vec{\omega_i})q_j(\vec{\omega_o})
\]</span></p>
<ul>
<li>因数分解法蕴涵的思想为把入射和发射方向映射为纹理上的象素，使得上式中的
n 尽量小，并且方向矢量可以通过纹理的线性插值来得到</li>
<li>存取的纹理与环境映照具有相同的形式：球面图、抛物面图、立方体图
<ul>
<li>其中立方体图的质量最高</li>
</ul></li>
<li>我们的目标是构造纹理对
<ul>
<li>入射纹理：通过入射方向存取</li>
<li>发射纹理：通过发射方向存取</li>
</ul></li>
<li>在实践中，我们发现这种参数化结果并不好，会导致需要很多纹理对（n很大）才能较好地逼近
BRDF。在三角形内的线性插值结果也不好，会导致严重的误差</li>
<li>好的参数化方法与材料的类型有关（并非完全是一个科学问题）</li>
</ul>
<h4 id="矩阵分解计算纹理对">矩阵分解计算纹理对</h4>
<ul>
<li>为了计算纹理对，需要构造一大型矩阵（可以采用预计算的方法）</li>
<li>入射纹理的每个纹素表示该矩阵的行下标，发射纹理的每个纹素表示该矩阵的列下标</li>
<li>矩阵的每个元素表示 BRDF 的反射系数值</li>
<li>矩阵分解通常采用两种方法
<ul>
<li>奇异值分解(SVD, Singular Value Decomposition),</li>
<li>规范化分解(ND, Normalized Decomposition)</li>
</ul></li>
<li>把分解得到的行矢量和列矢量对存入纹理对，便得到我们所需要的纹理对</li>
<li>规范化分解的缺点是结果不太精确，但比SVD简单、存贮量小，并且纹理值都是正的
<ul>
<li>用的不多</li>
</ul></li>
<li><strong>矩阵分解可看成是一种数据压缩方式</strong>
<ul>
<li>四维的 BRDF
转化为纹理对，然后由图形硬件进行解压。由于纹理可以用球面图或抛物面图来表示，因此该技术可在任何图形硬件上运行</li>
</ul></li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>对于每个光源，至少需要一对纹理</li>
<li>只适合点光源和方向光。不能捕获从面光源、天空光和其它物体来的辐射亮度</li>
</ul>
<h3 id="环境图滤波">环境图滤波</h3>
<ul>
<li>BRDF 是一个方向，对多个反射方向进行滤波（漫反射效果）</li>
<li>前面我们讲过，环境图可以用来绘制理想的发光表面（perfectly shiny
surface）</li>
<li>这个概念同样可以推广到光滑面（glossy surface）和漫反射面</li>
<li>为了模拟表面<strong>不同程度的粗糙度</strong>，我们可以对纹理的环境表示进行<strong>滤波</strong>
<ul>
<li>通过对环境图进行<strong>模糊操作</strong>，我们可以使得镜面反射呈现**粗糙的视觉效果*</li>
</ul></li>
<li>理论上，模糊操作应以非线性的方式进行。也就是说，纹理的不同部分应以不同的方式进行模糊。但因为<strong>整体的反射效果通常比精确的反射更重要</strong>，所以我们可以直接采用对环境图进行<strong>均匀模糊</strong>的方法</li>
<li>一个物理上更真实的方法为采用 Phong
镜面方程来对环境图进行滤波。镜面叶决定采样环境映照中的哪些纹素，并决定每个纹素的相对贡献</li>
<li>滤波方式
<ul>
<li>理想镜面反射</li>
<li>反射光线的<strong>镜面叶</strong></li>
<li>对表面上的余弦加权半球面进行求和来得到漫反射分量中入射光的贡献</li>
</ul></li>
</ul>
<p><img src="/2021/02/22/CG/LS/10/environment.png"></p>
<ul>
<li>其思想是把环境映照 EM 看成是罩在物体外面的一个球面。EM
上的每个纹素表示球面上的不同面积，其值为常数。由纹素构成的四边形实际上描述了一个球面四边形，其面积可用两个平面三角形来简单逼近。为了建立模拟表面模糊效果的图，首先进行预处理，计算纹素四个角点的单位化法向和纹素的面积。</li>
<li>算法思想
<ul>
<li>对于每个反射方向，找到每个EM纹素对该方向的贡献</li>
<li>假设反射方向附近有一个光源，直接从反射方向来的光具有最大的贡献，越偏离该方向,
贡献越小</li>
<li>EM纹素的面积乘上该纹素的 BRDF
贡献给出了该纹素的相对影响，把结果相加来计算q。s为加权贡献的和</li>
<li>最后的结果 q/s 为在反射方向叶上积分得到的整体颜色</li>
</ul></li>
</ul>
<h1 id="绘制方程">绘制方程</h1>
<h2 id="反射方程-1">反射方程</h2>
<ul>
<li>Reflected Light(Output Image)
<ul>
<li>Emission</li>
<li>Incident Light (from light source) x BRDF x Cosine of Incident
angle</li>
</ul></li>
<li>自发光 + 反射光</li>
</ul>
<h3 id="点光源">点光源</h3>
<p><img src="/2021/02/22/CG/LS/10/one-light.png" style="zoom: 70%;"> <span class="math display">\[
L_r(x,\vec{\omega_r})=L_e(x,\vec{\omega_r})+L_i(x,\vec{\omega_i})f(x,\omega_i,\omega_r)(\omega_i\cdot
n)
\]</span></p>
<h3 id="多光源">多光源</h3>
<p><span class="math display">\[
L_r(x,\vec{\omega_r})=L_e(x,\vec{\omega_r})+\sum
L_i(x,\vec{\omega_i})f(x,\omega_i,\omega_r)(\omega_i\cdot n)
\]</span></p>
<h3 id="面光源">面光源</h3>
<ul>
<li>立体角积分</li>
</ul>
<p><span class="math display">\[
L_r(x,\vec{\omega_r})=L_e(x,\vec{\omega_r})+\int_\Omega
L_i(x,\vec{\omega_i})f(x,\omega_i,\omega_r)(\omega_i\cdot n)d\omega_i
\]</span></p>
<h3 id="全局光照明">全局光照明</h3>
<ul>
<li>其他表面的反射光</li>
<li>$ L_r(x',-)$ <strong>未知</strong></li>
</ul>
<p><span class="math display">\[
L_r(x,\vec{\omega_r})=L_e(x,\vec{\omega_r})+\int_\Omega
L_r(x&#39;,-\vec{\omega_i})f(x,\omega_i,\omega_r)(\omega_i\cdot
n)d\omega_i
\]</span></p>
<h2 id="渲染方程">渲染方程</h2>
<ul>
<li>上面的全局光照明</li>
<li>直接光与间接光
<ul>
<li>Direct (local ) illumination
<ul>
<li>Light directly from light sources</li>
<li>No shadows</li>
</ul></li>
<li>Indirect (global ) illumination
<ul>
<li>Hard and soft shadows</li>
<li>Diffuse interreflections (radiosity)
<ul>
<li>interreflections ：相互反射</li>
</ul></li>
<li>Glossy interreflections (caustics)
<ul>
<li>caustics：焦散</li>
</ul></li>
</ul></li>
</ul></li>
<li>挑战：入射光出射光互相依赖
<ul>
<li>To evaluate the reflection equation the incoming radiance must be
known</li>
<li>To evaluate the incoming radiance the reflected radiance must be
known</li>
</ul></li>
<li>Surface Balance Equation
<ul>
<li>[outgoing] = [emitted] + [reflected]</li>
<li>[outgoing] = [emitted] + [reflected] + [transmitted]
<ul>
<li>BTDF：透射光（下面透射上来、透射下去）</li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
L_o(x,\vec{\omega_o})=L_e(x,\vec{\omega_o})+L_r(x,\vec{\omega_o})+L_t(x,\vec{\omega_o})
\]</span></p>
<p><span class="math display">\[
L_r(x,\vec{\omega_o})=\int_{H_+^2}
L_i(x&#39;,\vec{\omega_i})f_r(x,\omega_i\to\omega_o)(\cos\theta_i)d\omega_i
\]</span></p>
<p><span class="math display">\[
L_t(x,\vec{\omega_o})=\int_{H_-^2}
L_i(x&#39;,\vec{\omega_t})f_r(x,\omega_t\to\omega_o)(\cos\theta_t)d\omega_t
\]</span></p>
<ul>
<li>可以利用法向合并</li>
</ul>
<p><span class="math display">\[
H_+^2(n):\omega_o\cdot n(x)&gt;0\\
H_-^2(n):\omega_o\cdot n(x)&lt;0
\]</span></p>
<p><span class="math display">\[
L(x,\vec{\omega})=L_e(x,\vec{\omega})+\int_{H^2}
L(x^\ast(x,\omega&#39;),\vec{\omega})f_r(x,\omega&#39;\to\omega)(\cos\theta&#39;)d\omega&#39;
\]</span></p>
<ul>
<li><span class="math inline">\(x^\ast(x,\omega&#39;)\)</span>
中间包含路径衰减等因素（传输因子）</li>
<li>推到得到矩阵形式</li>
</ul>
<p><span class="math display">\[
l(u)=e(u)+\int l(v)K(u,v)dv
\]</span></p>
<p><span class="math display">\[
L=E+KL
\]</span></p>
<ul>
<li>矩阵 <span class="math inline">\(K\)</span>
表示在光的传播过程中其他各点的贡献</li>
<li>L, E are vectors, K is the light transport matrix</li>
</ul>
<h3 id="解渲染方程的方法">解渲染方程的方法</h3>
<ul>
<li>All global illumination methods try to solve (approximations of) the
rendering equation
<ul>
<li>Too hard for analytic solution: numerical methods</li>
<li>General theory of solving integral equations</li>
</ul></li>
<li>Radiosity (usually diffuse surfaces)
<ul>
<li>General class numerical finite element methods (divide surfaces in
scene into a finite set elements or patches)</li>
<li>Set up linear system (matrix) of simultaneous equations</li>
<li>Solve <strong>iteratively</strong></li>
</ul></li>
<li>ray tracing and extensions
<ul>
<li><span class="math inline">\(L=(I-K)^{-1}E\)</span></li>
<li><span class="math inline">\(L=(I+K+K^2+K^3+K^2+\cdots)E\)</span>
<ul>
<li><span class="math inline">\(E\)</span>：Emission directly（From
light sources）</li>
<li><span class="math inline">\(KE\)</span>：Direct Illumination on
surfaces</li>
<li><span class="math inline">\(KE^2\)</span>：Global Illumination (One
bounce indirect)[Mirrors, Refraction]</li>
<li><span class="math inline">\(KE^3\)</span>：Global Illumination (Two
bounce indirect)[Caustics etc]</li>
</ul></li>
<li>OpenGL：L=E+KE</li>
</ul></li>
<li>将立体角转变为我们常用的离散面片</li>
</ul>
<p><img src="/2021/02/22/CG/LS/10/omega2a.png" style="zoom: 60%;"></p>
<ul>
<li>加入可见性检测 <span class="math inline">\(V(x,x&#39;)\)</span></li>
</ul>
<p><span class="math display">\[
L_r(x,\vec{\omega_r})=L_e(x,\vec{\omega_r})+\int_\Omega
L_r(x&#39;,-\vec{\omega_i})f(x,\omega_i,\omega_r)\cos\theta_id\omega_i
\]</span></p>
<p><span class="math display">\[
L_r(x,\vec{\omega_r})=L_e(x,\vec{\omega_r})+\int_\Omega
L_r(x&#39;,-\vec{\omega_i})f(x,\omega_i,\omega_r)V(x,x&#39;)\dfrac{\cos\theta_i\cos
\theta_0}{|x-x&#39;|^2}dA&#39;
\]</span></p>
<p><span class="math display">\[
L_r(x,\vec{\omega_r})=L_e(x,\vec{\omega_r})+\int_\Omega
L_r(x&#39;,-\vec{\omega_i})f(x,\omega_i,\omega_r)V(x,x&#39;)G(x,x&#39;)dA&#39;
\]</span></p>
]]></content>
      <categories>
        <category>CG.LS</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学.李胜.11.物理模拟</title>
    <url>/2021/02/22/CG/LS/11/</url>
    <content><![CDATA[<ul>
<li>游戏、动画，谋求逼真的效果（指视觉上的逼真效果）</li>
</ul>
<h1 id="rigging">Rigging</h1>
<h2 id="workflow制作电影的工作流程">Workflow（制作电影的工作流程）</h2>
<ul>
<li>Story
<ul>
<li>故事绘本</li>
</ul></li>
<li>Video footage
<ul>
<li>小样</li>
</ul></li>
<li>Concept drawing
<ul>
<li>虚拟生物等草图绘制</li>
</ul></li>
<li>Modeling
<ul>
<li>建模</li>
</ul></li>
<li>Rigging and simulation
<ul>
<li>动起来</li>
</ul></li>
<li>Rendering
<ul>
<li>渲染</li>
</ul></li>
<li>Composites
<ul>
<li>把以上内容合成在一起</li>
<li>另外可能还有
<ul>
<li>motion blur</li>
<li>camera shake</li>
<li>character（角色动画）</li>
<li>color lighting</li>
<li>effects（特效）</li>
</ul></li>
</ul></li>
</ul>
<h2 id="what-is-rigging">What Is Rigging</h2>
<ul>
<li>Rig come from Puppet（木偶）</li>
<li>How character’s motion is driven</li>
<li>rig vs skin
<ul>
<li>skin：蒙皮、运动中的变化
<ul>
<li>rig 的一个部分</li>
</ul></li>
<li>Skinning just solve surface motion for display</li>
<li>Rig is more general
<ul>
<li>加骨骼、运动控制、运动中表皮的变化</li>
</ul></li>
<li>Part of rigging process</li>
</ul></li>
</ul>
<h3 id="rigging-movie-in-history">Rigging Movie in History</h3>
<ul>
<li>Jurassic Park [1993] , milestone in digital art.</li>
<li>Rigging + simple secondary muscle motion.</li>
<li>Use many real models.</li>
<li>People do composite job on dinosaurs on YOUTUBE</li>
</ul>
<h3 id="rigging-types">Rigging Types</h3>
<ul>
<li>Performance rig
<ul>
<li>a motion and control system providing control of the character to
animation artists.</li>
<li>骨架驱动的对象运动形态</li>
</ul></li>
<li>Simulation rig
<ul>
<li>物理、基于动力学模拟出来的</li>
<li>Dynamic behavior(g)</li>
<li>Collision</li>
<li>Cloth</li>
<li>Spring</li>
<li>soft and rigid‐body</li>
<li>Bake to animation sequence</li>
</ul></li>
<li>Deformation rig
<ul>
<li>形变的时候，外表皮如何生成</li>
<li>character’s skin relative to the motion of the performance rig</li>
<li>Know as Skinning as we have mentioned</li>
<li>T pose</li>
</ul></li>
<li>Facial rig
<ul>
<li>人脸（复杂、逼真很难）
<ul>
<li>人对人脸看的很多，很容易判断一张人脸是否是合成的</li>
</ul></li>
<li>Blend shapes
<ul>
<li>Face can be defined with limited set</li>
<li>Synthesis, transfer, interpolate</li>
<li>Recent hot in graphics and vision</li>
<li>Also need manual rig in production</li>
</ul></li>
<li>现在电影的开销：演员、动画师
<ul>
<li>演员是否会被替代？逼真人脸的制作</li>
</ul></li>
</ul></li>
<li>Muscle rig
<ul>
<li>解剖学：肌肉驱动</li>
<li>Most complicated rig</li>
<li>Also is collision object with skin</li>
<li>Need experience in anatomy, how muscle works</li>
<li>Generally don’t use it</li>
</ul></li>
<li>Clothing and accoutrements rig</li>
<li>Motion capture/tracking rig
<ul>
<li>Usually used as an input to the performance rig.</li>
<li>Lots of company building tracking hardware</li>
<li>阿凡达电影</li>
</ul></li>
</ul>
<h3 id="standard-performance-rig">Standard Performance Rig</h3>
<ul>
<li>Joint Placement/Orientation(lock some DOF)
<ul>
<li>结点的放置/朝向，锁定自由度</li>
<li>例如人的手有些方向是不能动的</li>
</ul></li>
<li>Add Controller (cage select detail hard)
<ul>
<li>cage：模型的几何代理、类似于包围盒的粗糙盒子
<ul>
<li>通过调整盒子的变化控制模型的形变</li>
</ul></li>
</ul></li>
<li>Attach FK/IK to the controller
<ul>
<li>FK：forward kinematics（运动学）
<ul>
<li>给定怎么从 A 状态运动到 B 状态</li>
</ul></li>
<li>IK：inverse kinematics（逆运动学）
<ul>
<li>给定两个状态，通 过计算得到运动方式</li>
</ul></li>
</ul></li>
<li>Paint the skinning weights
<ul>
<li>蒙皮刷权重</li>
<li>可能会出现一些奇异的情况（不符合现实），因此需要蒙皮刷权重</li>
</ul></li>
<li>special handling
<ul>
<li>一些风格化的渲染</li>
</ul></li>
</ul>
<h1 id="simulation">Simulation</h1>
<ul>
<li>更真实展现自然界的现象</li>
</ul>
<p><img src="/2021/02/22/CG/LS/11/simulation.png"></p>
<ul>
<li>弹性体、弹塑性体
<ul>
<li>碰撞
<ul>
<li>恢复</li>
<li>弹塑性材料：部分恢复</li>
</ul></li>
<li>应变的计算</li>
</ul></li>
<li>多体碰撞、多点接触
<ul>
<li>怎么计算力的作用</li>
<li>离散化大量离散点的碰撞</li>
</ul></li>
<li>固体：非穿越条件
<ul>
<li><span class="math inline">\(t_0\)</span> 未接触，但是 <span class="math inline">\(t_0+\Delta t\)</span> 就穿越了</li>
<li>解决：时间片 <span class="math inline">\(\Delta t\)</span>
选择更小（<span class="math inline">\(10^{-5},10^{-6}\)</span>级别）</li>
</ul></li>
<li>绳子的模拟
<ul>
<li>扭转、剪切</li>
</ul></li>
<li>布料的模拟
<ul>
<li>褶皱多，且互不穿越</li>
<li>自碰撞检测</li>
</ul></li>
<li>刚体
<ul>
<li>碰撞碎裂</li>
</ul></li>
<li>流体
<ul>
<li>粘性流体：蜂蜜</li>
<li>沙子：湿 / 干 <span class="math inline">\(\Rightarrow\)</span> 固体
/ 流体
<ul>
<li>形态转换</li>
<li>湿沙子，沙子颗粒之间有液桥力</li>
</ul></li>
<li>胶体</li>
</ul></li>
<li>Collision, Contact, Friction
<ul>
<li>碰撞、接触、摩擦</li>
</ul></li>
<li>海洋表面的模拟</li>
</ul>
<h2 id="核心原理-物体运动方程">核心原理： 物体运动方程</h2>
<h3 id="流体">流体</h3>
<ul>
<li>纳维斯托克斯方程</li>
</ul>
<p><span class="math display">\[
\rho\dfrac{dv}{dt}=\rho g-\triangledown p+\mu\triangledown^2v
\]</span></p>
<ul>
<li><span class="math inline">\(\rho\)</span>：密度</li>
<li><span class="math inline">\(p\)</span>：压强</li>
<li><span class="math inline">\(\mu\)</span>：粘滞系数</li>
</ul>
<h3 id="两大流派">两大流派</h3>
<ul>
<li>拉格朗日流派：粒子
<ul>
<li>拉格朗日法着眼于研究各个流体质点的运动，描述的流体质点至始至终的运动过程以及它们的物理量随时间
t 的变化规律</li>
</ul></li>
<li>欧拉流派：栅格
<ul>
<li>欧拉法着眼于空间点，描述的是各个时刻，各个空间点（场论的概念）中流体质点物理量的变化情况。物理量在空间中的分布称为物理场，如速度场、压力场、密度场等，这些所有的物理量场统称为流场</li>
</ul></li>
</ul>
<h3 id="刚体">刚体</h3>
<ul>
<li>平动与转动</li>
</ul>
<p><span class="math display">\[
\dfrac{d}{dt}(X_t)=d\left(
\begin{array}{ccc}
x_t\\
R_t
\end{array}
\right)
=\left(
\begin{array}{ccc}
v_t\\
w_t\times R_t
\end{array}
\right)
\]</span></p>
<h3 id="弹性体">弹性体</h3>
<ul>
<li>有限元方法</li>
</ul>
<h2 id="动画计算的一般流程">动画计算的一般流程</h2>
<ul>
<li>离散化</li>
<li>方程初始化</li>
<li>仿真计算与迭代</li>
<li>仿真中止</li>
<li>真实感渲染</li>
</ul>
<p><img src="/2021/02/22/CG/LS/11/animation.png"></p>
<h3 id="示例绳子弹簧模型">示例：绳子（弹簧模型）</h3>
<h4 id="离散化">(1) 离散化</h4>
<ul>
<li>分成一段一段的，弹簧质点模型</li>
<li>质点 <span class="math inline">\(x_0,x_1,...,x_{n+1}\)</span></li>
<li>弹簧 <span class="math inline">\(e_0,e_1,...,e_n\)</span></li>
</ul>
<h4 id="方程初始化">(2) 方程初始化</h4>
<ul>
<li>质量 <span class="math inline">\(m_0,m_1,...,m_{n+1}\)</span></li>
<li>初速度 <span class="math inline">\(v_0,v_1,...,v_{n+1}\)</span></li>
<li>弹性系数 <span class="math inline">\(k_0,k_1,...,k_n\)</span></li>
</ul>
<h4 id="仿真迭代计算">(3) 仿真迭代计算</h4>
<ul>
<li>将连续的运动过程离散到一系列时间点
<ul>
<li>时间片划分</li>
</ul></li>
<li>在相邻的时间点之间更新运动状态
<ul>
<li><span class="math inline">\(v^t\to v^{t+1}\)</span></li>
<li><span class="math inline">\(x^t\to x^{t+1}\)</span></li>
</ul></li>
<li>更新规则：胡克定律 <span class="math inline">\(m\dfrac{d^2x}{dt^2}=k\Delta l\)</span></li>
</ul>
<h4 id="渲染">(4) 渲染</h4>
<h2 id="热点与难点">热点与难点</h2>
<h3 id="固体">固体</h3>
<ul>
<li>非光滑的多体接触碰撞
<ul>
<li>扑克牌塔（静摩擦处于稳定状态）
<ul>
<li>算法不稳定会导致崩塌</li>
</ul></li>
</ul></li>
<li>大场景快速而稳定的仿真计算
<ul>
<li>碰撞摩擦</li>
</ul></li>
</ul>
<h3 id="形变体">形变体</h3>
<ul>
<li>大形变不能产生畸变</li>
<li>复杂拓扑修改</li>
<li>艺术指导的形变</li>
</ul>
<h3 id="碎裂">碎裂</h3>
<ul>
<li>断裂面跟踪</li>
<li>设计碎裂模式
<ul>
<li>一碰就裂</li>
<li>慢慢的产生裂纹，裂开</li>
</ul></li>
</ul>
<h3 id="流体-1">流体</h3>
<ul>
<li>精细薄片特征</li>
<li>表面波纹</li>
</ul>
<h3 id="流体烟雾及其耦合">流体、烟雾及其耦合</h3>
<ul>
<li>湍流效果</li>
<li>多种形态耦合作用</li>
</ul>
<h3 id="产生声音">产生声音</h3>
<ul>
<li>从动力学的角度产生声音</li>
<li>振动模态可以从动力学产生</li>
</ul>
<h3 id="开源代码">开源代码</h3>
<ul>
<li>https://github.com/yuanming-hu/difftaichi</li>
</ul>
<h1 id="工业界与研究">工业界与研究</h1>
<ul>
<li>industry &amp; research</li>
<li>相辅相成、互相促进</li>
</ul>
<h2 id="exhaust-the-existing-techniques">exhaust the existing
techniques</h2>
<ul>
<li>detailed smoke</li>
<li>flip particles</li>
</ul>
<h2 id="megamind-fluid-simulation">megamind fluid simulation</h2>
<ul>
<li>large scale</li>
<li>serious simulation</li>
</ul>
<h1 id="一些研究工作">一些研究工作</h1>
<ul>
<li>以固体的仿真为核心，研究固体的运动、碰撞、形变、碎裂现象的物理机理和仿真建模，模拟固体多体之间的相互作用以及液体与固体多体的相互作用的仿真计算
<ul>
<li>并行的快速连续碰撞检测</li>
<li>刚性固体的破碎</li>
<li>复杂物体表面破碎裂纹的仿真</li>
<li>弹性固体的仿真</li>
<li>具有材料属性的固体交互编辑和仿真</li>
<li>不可压流体的高效模拟
<ul>
<li>基于表面张力波的流体细节仿真</li>
</ul></li>
<li>固液耦合的交错光滑例子动力学</li>
<li>精确的摩擦计算的多点接触刚体系统</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.LS</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学.李胜.08.真实感绘制之光照明(1)</title>
    <url>/2021/02/05/CG/LS/08/</url>
    <content><![CDATA[<h1 id="真实感绘制流程">真实感绘制流程</h1>
<ul>
<li>动机：图形真实感的需求</li>
<li>真实感：产生幻觉（illusion）</li>
<li>基于用户评估，没有一个确定的标准</li>
<li>例子：树皮
<ul>
<li>光线：产生阴影</li>
<li>边界：粗糙的感觉</li>
</ul></li>
</ul>
<h2 id="光照明模型发展历史">光照明模型发展历史</h2>
<ul>
<li>早期光照明模型
<ul>
<li>基于<strong>经验</strong></li>
<li>只能反映<strong>光源直接照射</strong>的情况</li>
</ul></li>
<li>比较精确的模型
<ul>
<li>模拟物体之间光的相互作用</li>
<li><strong>间接光照</strong></li>
</ul></li>
<li>更精确的模型
<ul>
<li>模拟物体自身的光照相互作用</li>
<li>模拟光源至物体表面以及物体表面至视点之间光的传播</li>
<li>光传播的介质（雾）、物体表面形态、视点位置变化、体数据</li>
</ul></li>
<li>2005 siggraph achievement：Nishita 东京大学
<ul>
<li>截止：光在大气中传播的模拟</li>
<li>participating media：参与介质</li>
</ul></li>
</ul>
<h2 id="真实感图形绘制的四个步骤">真实感图形绘制的四个步骤</h2>
<h3 id="d流水线">3D流水线</h3>
<ul>
<li>三维形体 <span class="math inline">\(\rightarrow\)</span> 变换 <span class="math inline">\(\rightarrow\)</span> 明暗处理（光照）<span class="math inline">\(\rightarrow\)</span> 光栅化 <span class="math inline">\(\rightarrow\)</span> 真实感图像</li>
</ul>
<h3 id="几何建模">(1) 几何建模</h3>
<ul>
<li>用数学方法建立所需三维场景的几何描述</li>
<li>通常是由三维造型系统完成</li>
<li>场景的几何描述直接影响了图形的复杂性和图形绘制的计算开销</li>
</ul>
<h3 id="投影">(2) 投影</h3>
<ul>
<li>将三维几何描述转换为二维透视图</li>
<li>通过对场景的透视变换来完成</li>
</ul>
<h3 id="确定形状">(3) 确定形状</h3>
<ul>
<li>隐藏面消除</li>
<li>确定场景中的所有可见面</li>
<li>将视野之外或被其它物体遮挡的不可见面消去</li>
</ul>
<h3 id="确定色彩">(4) 确定色彩</h3>
<ul>
<li>计算场景中可见面的颜色</li>
<li>根据基于光学物理的光照明模型计算可见面投射到观察者眼中的光亮度大小和色彩组成，并将它转换成适合图形设备的颜色值，从而确定投影画面上每一象素的颜色（或者与纹理相结合），最终生成图形</li>
</ul>
<h1 id="简单光照明模型">简单光照明模型</h1>
<h2 id="简单光照明模型的假设">简单光照明模型的假设</h2>
<ul>
<li>仅考虑光源照射在物体表面产生的<strong>反射光</strong></li>
<li>通常假定物体表面是<strong>光滑</strong>的且由<strong>理想材料</strong>构成，只考虑<strong>被照明物体的几何</strong>对反射和透射光的影响</li>
<li>忽略光源的颜色和几何形状（<strong>点光源白光照明</strong>）</li>
<li>可以模拟出<strong>不透明物体</strong>表面的明暗过渡，具有一定的真实感。
但真实感较差，阴影区域边界尖锐</li>
</ul>
<h2 id="基础">基础</h2>
<ul>
<li>反射
<ul>
<li>理想漫反射（diffuse reflection）</li>
<li>镜面高光（specular highlight）</li>
</ul></li>
<li>环境光
<ul>
<li>ambient lighting</li>
</ul></li>
<li>直接光：直接反射/折射</li>
<li>间接光：间接反射/折射
<ul>
<li>简单光照明不考虑间接光</li>
</ul></li>
<li><strong>以下提到的方向向量均为单位向量</strong></li>
</ul>
<h2 id="环境光">环境光</h2>
<ul>
<li>光线在场景中经过复杂传播之后，形成的弥漫于整个空间的光线</li>
<li><strong>事实上是不存在的</strong>
<ul>
<li>由于难以模拟，假想出来的</li>
</ul></li>
<li><span class="math inline">\(I_e=K_aI_a\)</span>
<ul>
<li>物体表面呈现的亮度 = 环境光反射系数 x 环境光亮度</li>
</ul></li>
</ul>
<h2 id="漫反射">漫反射</h2>
<ul>
<li>点光源
<ul>
<li>向周围辐射等强度的光</li>
</ul></li>
<li>漫反射
<ul>
<li>粗糙、无光泽物体（如粉笔）表面对光的反射</li>
</ul></li>
<li><span class="math inline">\(I_d=I_pK_d\cos\theta=I_pK_d(\vec{L}\cdot\vec{N})\)</span>
<ul>
<li>物体表面呈现的亮度 = 点光源的亮度 x 漫反射系数 x <span class="math inline">\(\cos\)</span>(入射角)</li>
</ul></li>
</ul>
<p><img src="/2021/02/05/CG/LS/08/diffuse-reflection.png"></p>
<h2 id="镜面反射与-phong-模型">镜面反射与 Phong 模型</h2>
<ul>
<li>光滑物体表面，高光效果</li>
</ul>
<h3 id="理想镜面反射">理想镜面反射</h3>
<ul>
<li>难以捕获：要求视点恰好在反射光 R 的方向上</li>
<li><span class="math inline">\(\vec{R}=2(\vec{L}\cdot\vec{N})\vec{N}-\vec{L}\)</span></li>
<li><span class="math inline">\(\vec{R}+\vec{L}=(2|\vec{R}|\cos\theta)\vec{N}=(2\cos\theta)\vec{N}=2(\vec{N}\cdot\vec{L})\vec{N}\)</span></li>
</ul>
<p><img src="/2021/02/05/CG/LS/08/ideal-specular-highlight.png"></p>
<h3 id="非理想镜面反射">非理想镜面反射</h3>
<ul>
<li>锥形区域：中心轴为 R，圆锥角 <span class="math inline">\(2\beta\)</span>
<ul>
<li>圆锥内部：光强由中心向四周递减</li>
<li>圆锥外部：光强为 0</li>
</ul></li>
</ul>
<p><img src="/2021/02/05/CG/LS/08/specular-highlight.png"></p>
<ul>
<li>Phong 模型
<ul>
<li><span class="math inline">\(I_s=I_pK_s(\cos\alpha)^n=I_pK_s(\vec{V}\cdot\vec{R})^n\)</span></li>
<li>n 为镜面反射系数
<ul>
<li>n 越大，高光越集中</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/02/05/CG/LS/08/phong-n.png"></p>
<ul>
<li>定义 <span class="math inline">\(\vec{H_0}=\dfrac{1}{2}(\vec{L}+\vec{V}),\vec{H}=\dfrac{\vec{H_0}}{\Vert\vec{H_0}\Vert}=\dfrac{\vec{H_0}}{\cos\theta}\)</span>
<ul>
<li>可以用 <span class="math inline">\(\vec{H}\cdot\vec{N}\)</span> 代替
<span class="math inline">\(\vec{V}\cdot\vec{R}\)</span></li>
<li>趋势是一致的
<ul>
<li><span class="math inline">\(\vec{H}\cdot\vec{N}=\dfrac{\cos\theta+\cos(\theta+\alpha)}{2\cos\theta}\)</span>
<ul>
<li><span class="math inline">\(\alpha\in[0,\dfrac{\pi}{2}]\to[1,1-\tan\theta]\)</span></li>
</ul></li>
<li><span class="math inline">\(\vec{V}\cdot\vec{R}=\cos\alpha\)</span>
<ul>
<li><span class="math inline">\(\alpha\in[0,\dfrac{\pi}{2}]\to[1,0]\)</span></li>
</ul></li>
<li><span class="math inline">\(&lt;\vec{H},\vec{N}&gt;=\dfrac{&lt;\vec{V},\vec{R}&gt;}{2}\)</span></li>
</ul></li>
</ul></li>
</ul>
<h2 id="光线的衰减">光线的衰减</h2>
<h3 id="光在光源到物体表面过程中的衰减">(1)
光在光源到物体表面过程中的衰减</h3>
<ul>
<li><span class="math inline">\(f(d)=\min(\dfrac{1}{c_0+c_1d+c_2d^2},1)\)</span>
<ul>
<li>经验函数</li>
</ul></li>
</ul>
<h3 id="光在物体表面到人眼过程中的衰减">(2)
光在物体表面到人眼过程中的衰减</h3>
<ul>
<li>Depth Cueing 技术（深度暗示技术）
<ul>
<li>使用深度值代替表示距离（几乎等价）</li>
</ul></li>
<li>线性插值
<ul>
<li>front/back：前/后参考面，并且赋予比例因子 <span class="math inline">\(S_f,S_b\in[0,1]\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
S_0=
\begin{cases}
S_b,&amp;Z_0&lt;Z_b\\
S_b+\dfrac{Z_0-Z_b}{Z_f-Z_b}(S_f-S_b),&amp;Z_0\in[Z_b,Z_f],\\
S_f,&amp;Z_0&gt;Z_f
\end{cases}
\]</span></p>
<p><img src="/2021/02/05/CG/LS/08/depth-cueing.png"></p>
<ul>
<li><span class="math inline">\(I&#39;=S_0I+(1-S_0)I_{dc}\)</span>
<ul>
<li><span class="math inline">\(I_{dc}\)</span>
为融合亮度，是用户指定的</li>
</ul></li>
<li>特别的：<span class="math inline">\(S_f=1,S_b=0,I_{dc}=0\)</span></li>
</ul>
<p><span class="math display">\[
S_0=
\begin{cases}
0,&amp;Z_0&lt;Z_b\\
\dfrac{Z_0-Z_b}{Z_f-Z_b},&amp;Z_0\in[Z_b,Z_f],\\
1,&amp;Z_0&gt;Z_f
\end{cases}
\]</span></p>
<p><span class="math display">\[
I&#39;=
\begin{cases}
0,&amp;Z_0&lt;Z_b\\
\dfrac{Z_0-Z_b}{Z_f-Z_b}I,&amp;Z_0\in[Z_b,Z_f],\\
I,&amp;Z_0&gt;Z_f
\end{cases}
\]</span></p>
<ul>
<li>衰减为 0 <span class="math inline">\(\rightarrow\)</span> 部分衰减
<span class="math inline">\(\rightarrow\)</span> 不衰减
<ul>
<li>真实感较好</li>
</ul></li>
</ul>
<h2 id="简单光照明模型-1">简单光照明模型</h2>
<ul>
<li><span class="math inline">\(I=I_aK_a+f(d)I_p[K_d(\vec{L}\cdot
\vec{N})+K_s(\vec{V}\cdot\vec{R})^n]\)</span></li>
<li>环境光是不衰减的</li>
</ul>
<h2 id="彩色">彩色</h2>
<ul>
<li>选择合适的颜色模型：RGB模型</li>
<li>为颜色模型中的每一种基色建立光照明方程</li>
<li><span class="math inline">\(I=I_{a\lambda}K_{a\lambda}+f(d)I_{p\lambda}[K_{d\lambda}(\vec{L}\cdot
\vec{N})+K_{s\lambda}(\vec{V}\cdot\vec{R})^n]\)</span>
<ul>
<li><span class="math inline">\(\lambda\in\{R,G,B\}\)</span></li>
</ul></li>
</ul>
<h2 id="多光源">多光源</h2>
<ul>
<li>为每个光源建立光照明模型
<ul>
<li>注意环境光只有一个</li>
</ul></li>
<li>如下，<span class="math inline">\(m\)</span> 个光源​</li>
</ul>
<p><span class="math display">\[
I=I_{a\lambda}K_{a\lambda}+\sum_{i=1}^{m}\{f(d_i)I_{p_i\lambda}[K_{d_i\lambda}(\vec{L_i}\cdot
\vec{N})+K_{s_i\lambda}(\vec{V}\cdot\vec{R})^n]\}
\]</span></p>
<h2 id="多边形绘制着色方法">多边形绘制着色方法</h2>
<ul>
<li>shading</li>
<li>计算完<strong>顶点</strong>信息之后如何对<strong>内部的点</strong>上色
<ul>
<li>统一着色（constant shading）</li>
<li>均匀着色（flat shading）</li>
<li>光滑着色 (smooth shading)
<ul>
<li>Gouraud着色方法 (Gouraud shading)</li>
<li>Phong着色方法 (Phong shading)</li>
</ul></li>
</ul></li>
</ul>
<h3 id="统一着色">统一着色</h3>
<ul>
<li>constant shading</li>
<li>每个<strong>物体</strong>着同一种颜色</li>
</ul>
<h3 id="均匀着色">均匀着色</h3>
<ul>
<li>flat shading</li>
<li>每个<strong>表面</strong>着同一种颜色</li>
<li>着色方法
<ul>
<li>任取多边形上一点，利用光照明方程计算出它的颜色</li>
<li>用这个颜色填充整个多边形</li>
</ul></li>
<li>适用情况：<strong>同一表面差别不大</strong>
<ul>
<li>光源在无穷远处</li>
<li>视点在无穷远处</li>
<li>多边形是物体表面的精确表示</li>
</ul></li>
<li>优点
<ul>
<li>每个多边形只需计算一次光照明方程，<strong>速度快</strong></li>
</ul></li>
<li>缺点
<ul>
<li>相邻多边形颜色<strong>过渡十分不光滑</strong></li>
</ul></li>
</ul>
<h3 id="光滑着色">光滑着色</h3>
<ul>
<li>方法：<strong>插值</strong>
<ul>
<li>颜色插值 <span class="math inline">\(\rightarrow\)</span> Gouraud
着色方法</li>
<li>法矢量插值 <span class="math inline">\(\rightarrow\)</span> Phong
着色方法</li>
</ul></li>
</ul>
<h4 id="gouraud-着色方法">Gouraud 着色方法</h4>
<ul>
<li>面法向量 <span class="math inline">\(\rightarrow\)</span> 顶点法向量
<span class="math inline">\(\rightarrow\)</span> 计算颜色 <span class="math inline">\(\rightarrow\)</span> 颜色插值</li>
</ul>
<h5 id="步骤">步骤</h5>
<ul>
<li>计算多边形的单位法矢量（<strong>面法向量</strong>）
<ul>
<li>面内两个向量叉乘</li>
</ul></li>
<li>计算多边形顶点的单位法矢量（<strong>顶点法向量</strong>）
<ul>
<li>拟合</li>
<li>简单的拟合方式：使用 1 邻域的面法向量的均值
<ul>
<li>1 邻域：直接相邻的面</li>
<li>2 邻域：直接相邻的面以及和这些面直接相邻的面</li>
</ul></li>
</ul></li>
<li>利用光照明方程计算顶点颜色</li>
<li>对多边形顶点颜色进行<strong>双线性插值</strong>，获得多边形内部各点的颜色
<ul>
<li>如下图：需要求得点 <span class="math inline">\(P\)</span> 的颜色
<ul>
<li>第三步求出了顶点 <span class="math inline">\(P_1,P_2,P_3\)</span>
的颜色</li>
<li>通过<strong>线性插值</strong>求出点 <span class="math inline">\(A,B\)</span> 的颜色</li>
<li>对 <span class="math inline">\(A,B\)</span> 进行线性插值求得点 <span class="math inline">\(P\)</span> 的颜色</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/02/05/CG/LS/08/bilinear-interpolation.png"> <span class="math display">\[
I_a=I_1\dfrac{y_a-y_2}{y_1-y_2}+I_2\dfrac{y_1-y_a}{y_1-y_2}\\
I_b=I_1\dfrac{y_a-y_3}{y_1-y_3}+I_2\dfrac{y_1-y_a}{y_1-y_3}\\
I_p=I_a\dfrac{x_p-x_a}{x_b-x_a}+I_b\dfrac{x_p-x_a}{x_b-x_a}
\]</span></p>
<h5 id="缺点">缺点</h5>
<ul>
<li>不能正确模拟高光</li>
</ul>
<h4 id="phong-着色方法">Phong 着色方法</h4>
<ul>
<li>面法向量 <span class="math inline">\(\rightarrow\)</span> 顶点法向量
<span class="math inline">\(\rightarrow\)</span>法向量插值 <span class="math inline">\(\rightarrow\)</span> 计算颜色</li>
</ul>
<h5 id="步骤-1">步骤</h5>
<ul>
<li>计算多边形单位法矢量</li>
<li>计算多边形顶点单位法矢量</li>
<li>对多边形顶点法矢量进行双线性插值，获得内部各点的法矢量</li>
</ul>
<p><img src="/2021/02/05/CG/LS/08/normal-bilinear-interpolation.png"></p>
<ul>
<li>利用光照明方程计算多边形内部各点颜色</li>
</ul>
<p><img src="/2021/02/05/CG/LS/08/contrast-flat-gouraud-phong.png"></p>
<h4 id="方法对比">方法对比</h4>
<ul>
<li>计算颜色时期的不同：插值总是在<strong>光栅化</strong>阶段（rasterization）
<ul>
<li>Gouraud：vertex shader</li>
<li>Phong：fragment shader</li>
</ul></li>
<li>高光
<ul>
<li>Gouraud：缺失</li>
<li>Phong：还不错</li>
</ul></li>
</ul>
<p><img src="/2021/02/05/CG/LS/08/highlight-gouraud-phong.png" style="zoom: 25%;"></p>
<h4 id="插值方法存在的问题">插值方法存在的问题</h4>
<ul>
<li>不光滑的物体轮廓
<ul>
<li>模型离散化道中的</li>
<li>解决方案：使用法相贴图，将需要求的法向值给定，这样就无需插值拟合</li>
</ul></li>
<li>透视变形
<ul>
<li>我们的插值是在投影平面上进行的，实际上应该在三维空间中插值</li>
<li>这样在趋势上会有所差别</li>
</ul></li>
</ul>
<p><img src="/2021/02/05/CG/LS/08/interpolation-projection.png" style="zoom:50%;"></p>
<ul>
<li>方向依赖性
<ul>
<li>双线性插值的方向依赖性</li>
<li>早期的问题，现在已经能够解决</li>
</ul></li>
</ul>
<p><img src="/2021/02/05/CG/LS/08/interpolation-direction.png" style="zoom:50%;"></p>
<ul>
<li>公共顶点颜色不连续
<ul>
<li>下图的绿点
<ul>
<li>对于左上角的小矩形来说，是顶点（计算产生）</li>
<li>对于右上角的的矩形来说，不是顶点（插值产生）</li>
</ul></li>
<li>因此其周围的点颜色可能不连续</li>
</ul></li>
</ul>
<p><img src="/2021/02/05/CG/LS/08/interpolation-continue.png" style="zoom:50%;"></p>
<ul>
<li>顶点方向不具有代表性
<ul>
<li>如果使用定顶点进行插值，区分不出来两种类型的面（颜色都一样）</li>
<li>解决方案：<strong>将面进行更加细致的剖分</strong>，这样就可以减少这种情况的发生</li>
</ul></li>
</ul>
<p><img src="/2021/02/05/CG/LS/08/interpolation-point-normal.png" style="zoom:50%;"></p>
<h2 id="阴影">阴影</h2>
<ul>
<li>阴影
<ul>
<li>光源不能直接照射的区域</li>
<li>对光源来说，不可见的面（隐藏面）</li>
</ul></li>
<li>考虑阴影的光照明方程</li>
</ul>
<p><span class="math display">\[
I=I_{a\lambda}K_{a\lambda}+\sum_{i=1}^{m}\{S_if(d_i)I_{p_i\lambda}[K_{d_i\lambda}(\vec{L_i}\cdot
\vec{N})+K_{s_i\lambda}(\vec{V}\cdot\vec{R})^n]\}\\
\]</span></p>
<p><span class="math display">\[
S_i=
\begin{cases}
0,&amp;位于第i个光源的阴影中\\
1,&amp;else
\end{cases}
\]</span></p>
<ul>
<li>简单：点光源</li>
<li>复杂：体光源、面光源</li>
</ul>
<h3 id="基于-gpu-硬件的-shadow-map-算法">基于 GPU 硬件的 shadow map
算法</h3>
<ul>
<li><strong>像素</strong>级别精确的阴影算法</li>
<li><strong>点光源</strong></li>
<li>利用 z-buffer 消隐
<ul>
<li>将物体变换到光源坐标系中，消隐，记录下可见的最小深度值（z-buffer）</li>
<li>将物体变换到光源坐标系中，计算深度，如果大于记录值则不可见，否则可见（只可能<strong>等于</strong>）</li>
</ul></li>
</ul>
<h4 id="算法步骤">算法步骤</h4>
<ul>
<li>将所有景物变换到光源坐标系中，利用 z
缓冲器算法按光线方向对景物进行消隐，把那些距光源最近的物体表面上点的深度值保存在阴影缓冲器中</li>
<li>利用Z缓冲器算法按视线方向对景物进行消隐，将得到的每一个可见点变换到光源坐标系中，若
它在光源坐标系中的深度值比阴影缓冲器中相应单元的值小，则说明该可见点位于阴影中，否则不是</li>
</ul>
<h4 id="优点">优点</h4>
<ul>
<li>算法简单，易于实现</li>
<li>已经可以在GPU硬件上直接实现</li>
</ul>
<h4 id="缺点-1">缺点</h4>
<ul>
<li>每个光源需要一个阴影缓冲器</li>
<li>在阴影的边界上容易形成锯齿效果
<ul>
<li>量化误差（算法精度、z-buffer大小、深度值精度）</li>
</ul></li>
</ul>
<h3 id="rsmreflective-shadow-map">RSM：Reflective Shadow Map</h3>
<ul>
<li>shadow map 第一次渲染只生成了一张深度图，太浪费（代价太大）</li>
<li>第一次渲染的时候同时生成一些其他信息
<ul>
<li>光源直接照到部分的深度 <span class="math inline">\(\rightarrow\)</span>
光源直接照到部分的深度、颜色、法向</li>
</ul></li>
<li>第二次绘制利用第一次绘制生成的信息可以计算<strong>单次间接光照</strong></li>
</ul>
<h3 id="阴影反混淆">阴影反混淆</h3>
<ul>
<li>边界锯齿 <span class="math inline">\(\rightarrow\)</span> 平滑过渡
<ul>
<li>锯齿的光栅化过程产生的</li>
<li>走样</li>
</ul></li>
<li>反走样
<ul>
<li>时域：连续帧中，远方亮点的忽隐忽现（flick）</li>
<li>空域：边界锯齿</li>
</ul></li>
<li>反走样方法
<ul>
<li>SSAA：Super Sampling Anti-Aliasing
<ul>
<li>超采样反走样</li>
<li>每个采样点进行进一步的<strong>细分</strong>
<ul>
<li>x2，x3，x4 <span class="math inline">\(\rightarrow\)</span>
每个采样点细分为为 4，9，16个采样点</li>
</ul></li>
</ul></li>
<li>MSAA：Multi-Sampling AA
<ul>
<li>多采样反走样</li>
<li>SSAA 的计算量非常大，SSAA 的改进</li>
<li>寻找出物体边缘部分的像素，然后对它们进行超采样处理
<ul>
<li>这样忽略掉了不会产生锯齿的内部像素，减少了计算量</li>
</ul></li>
<li>光栅化而言，MSAA 跟 SSAA
差不多，覆盖和遮挡信息在更大的分辨率上进行的</li>
<li>着色的时候，通过计算原始的一个采样点细分出来的不同采样点的颜色混合得到原始采样点的颜色</li>
</ul></li>
<li>CSAA：Coverage Sampling AA
<ul>
<li>覆盖取样抗锯齿</li>
</ul></li>
<li>TAA
<ul>
<li>temporal AA</li>
</ul></li>
</ul></li>
<li>方法对比
<ul>
<li>SSAA
中，每个取样表示了着色颜色、储存的颜色/Z/模板、和覆盖，本质上增加了渲染到一个过大的缓存并向下取样</li>
<li>MSAA
通过从储存的颜色和覆盖中分离出着色取样，减少了这项操作的着色器开销；这允许应用程序使用抗锯齿来处理更少的着色取样同时维持同样质量的颜色/Z/模板和覆盖取样</li>
<li>CSAA通过从颜色/Z/模板分离出覆盖进一步优化了这个过程，从而减少带宽和存储开销</li>
</ul></li>
<li>反走样方法
<ul>
<li>光栅化图形显示必然的问题问题</li>
<li>trade off（时间与质量）</li>
</ul></li>
</ul>
<h3 id="基于gpu硬件-的-shadow-volume">基于GPU硬件 的 Shadow Volume</h3>
<ul>
<li><strong>几何</strong>级别精确的阴影算法
<ul>
<li>没有阴影锯齿问题</li>
</ul></li>
<li>光源 <span class="math inline">\(\rightarrow\)</span>
<strong>物体轮廓</strong>
<ul>
<li>光源和轮廓形成的锥体向远处拉伸，形成<strong>阴影体</strong></li>
</ul></li>
<li>关键问题
<ul>
<li>找出轮廓</li>
<li>如何判断物体是否处于阴影中</li>
</ul></li>
</ul>
<h4 id="如何判断物体处于阴影体中">如何判断物体处于阴影体中</h4>
<ul>
<li>直接对所有的几何体和阴影体求交、求交线
<ul>
<li>复杂度很高</li>
</ul></li>
<li>利用 buffer</li>
</ul>
<h5 id="累积缓冲">累积缓冲</h5>
<h6 id="思路">思路</h6>
<p><img src="/2021/02/05/CG/LS/08/accumulative.png" style="zoom:80%;"></p>
<ul>
<li>光源和物体形成射线</li>
<li>视点和需要求的点形成<strong>线段</strong>（方向为视点到待求的点），在线段上求累积值</li>
<li>正向面 +1，负向面 -1
<ul>
<li>朝向视点的面/远离视点的面</li>
</ul></li>
<li>求累计值
<ul>
<li>若大于 0，则处于阴影中</li>
<li>若等于 0，则不在阴影中</li>
</ul></li>
</ul>
<h6 id="怎么形成线段">怎么形成线段</h6>
<ul>
<li>怎么去掉物体之后的视线部分，上述黄线的绿点右边部分</li>
<li><strong>绘制顺序、绘制状态</strong></li>
</ul>
<h6 id="具体步骤">具体步骤</h6>
<ul>
<li>绘制出整个场景（非阴影体），确定整个场景的深度（记录到深度缓冲器中）</li>
<li>画阴影体（正向面/反向面），顺序没有关系
<ul>
<li>和记录的深度值比较
<ul>
<li>若比记录的小，则根据自己是正向面还是反向面更新累计缓冲值</li>
<li>若大，则不更新累计缓冲值</li>
</ul></li>
<li>只进行深度判断，不进行深度更新（不修改深度缓冲器的值）</li>
<li>阴影体是虚拟的，是我们人为加入的</li>
</ul></li>
</ul>
<h6 id="问题特例">问题（特例）</h6>
<ul>
<li><p>视点位于阴影体内部</p>
<ul>
<li>解决方法：在视线上，从无穷远到待求的点这条线段上进行累计缓冲计数
<ul>
<li>比较计数的时候，只比较深度大于待求点的阴影体
<ul>
<li>z-fail：计数的点是没有通过深度检测的阴影体（解决特例的方法）</li>
<li>z-pass：计数的点是通过深度检测的阴影体（常规方法）</li>
</ul></li>
<li>无穷远是客观的（无穷远不在阴影内部）</li>
</ul></li>
<li>问题：无穷远在阴影中，出错</li>
</ul>
<p><img src="/2021/02/05/CG/LS/08/error.png" style="zoom:60%;"></p></li>
<li><p>视见体把某些物体裁剪掉了，导致阴影体减少了</p>
<ul>
<li>上述算法出错</li>
</ul></li>
</ul>
<h3 id="软影以及动态光源阴影的生成">软影以及动态光源阴影的生成</h3>
<ul>
<li>面光源、体光源
<ul>
<li>软影（本影、半影）</li>
<li>笨的方法：将光源进行<strong>点采样</strong>
<ul>
<li>慢，效率低下</li>
</ul></li>
<li><strong>阴影楔</strong>
<ul>
<li>A Geometry-based Soft Shadow Volume Algorithm
<ul>
<li>实时图像渲染</li>
<li>Tomas Akenine-Möller</li>
</ul></li>
</ul></li>
</ul></li>
<li>光源形态发生变化（火焰）</li>
<li>待渲染的物体变化</li>
</ul>
<h2 id="透明现象">透明现象</h2>
<h3 id="简单透明">简单透明</h3>
<ul>
<li>简单透明不考虑折射现象</li>
</ul>
<h4 id="插值透明">插值透明</h4>
<p><img src="/2021/02/05/CG/LS/08/simple-transparent.png"></p>
<ul>
<li><span class="math inline">\(I_\lambda=(1-K_{t_1})I_{\lambda_1}+K_{t_1}I_{\lambda_2}\)</span>
<ul>
<li><span class="math inline">\(K_{t_1}=1\)</span>：1 完全透明，2
完全不透明</li>
<li><span class="math inline">\(K_{t_1}=0\)</span>：2 完全透明，1
完全不透明</li>
</ul></li>
</ul>
<h4 id="过滤透明">过滤透明</h4>
<ul>
<li><span class="math inline">\(I_\lambda=I_{\lambda_1}+K_{t_1}C_{t\lambda}I_{\lambda_2}\)</span>
<ul>
<li><span class="math inline">\(K_{t_1}\)</span>：透射系数，越大颜色透射得越多</li>
<li><span class="math inline">\(C_{t\lambda}\)</span>：不同颜色系数不同</li>
</ul></li>
</ul>
<h3 id="折射">折射</h3>
<ul>
<li>折射定律</li>
</ul>
<p><img src="/2021/02/05/CG/LS/08/refraction.png"></p>
<ul>
<li><span class="math inline">\(\dfrac{\sin\theta_i}{\sin\theta_t}=\dfrac{\eta_t}{\eta_i}=\dfrac{1}{\eta}\)</span></li>
<li><span class="math inline">\(\vec{T}=(\eta\cos\theta_i-\cos\theta_t)\vec{N}-\eta\vec{I}\)</span></li>
</ul>
<p><img src="/2021/02/05/CG/LS/08/refraction2.png"></p>
]]></content>
      <categories>
        <category>CG.LS</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.00.说明与课程介绍</title>
    <url>/2021/11/20/CG/WHM-GAMES103/00/</url>
    <content><![CDATA[<h1 id="说明">说明</h1>
<h2 id="课程信息">课程信息</h2>
<ul>
<li>Games 103：基于物理的计算机动画入门</li>
<li><a href="http://games-cn.org/games103/">课程主页</a></li>
<li>授课教师：王华民</li>
<li>视频地址：<a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili</a></li>
<li>内容
<ul>
<li>刚体模拟</li>
<li>质点弹簧、约束与布料模拟</li>
<li>基于有限元的弹性体模拟</li>
<li>流体模拟</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>0</category>
        <category>CG</category>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.01.Intro to Physics-Based Animation</title>
    <url>/2021/11/20/CG/WHM-GAMES103/01/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="intro-to-physics-based-animation">Intro to Physics-Based
Animation</h1>
<ul>
<li>会介绍一些物理引擎算法（优缺点、对比）
<ul>
<li>PBD（Position-Based Dynamics）</li>
</ul></li>
<li><strong>主动学习很重要</strong>
<ul>
<li>read more, write more, think more</li>
</ul></li>
<li>涵盖内容
<ul>
<li>刚体模拟</li>
<li>质点弹簧、约束与布料模拟</li>
<li>基于有限元的弹性体模拟</li>
<li>流体模拟</li>
</ul></li>
</ul>
<h2 id="图形学简介">图形学简介</h2>
<ul>
<li>What’s computer graphics?</li>
<li>3d 世界 <span class="math inline">\(\to\)</span> 2D 图像
<ul>
<li>3d digital world <span class="math inline">\(\to\)</span> 2d digital
image</li>
</ul></li>
<li>图形学的方向
<ul>
<li>Geometry：几何
<ul>
<li>Modeling the 3D world</li>
</ul></li>
<li>Rendering：渲染
<ul>
<li>Visualize the 3D world</li>
</ul></li>
<li>Animation：动画
<ul>
<li>Animate the 3D world</li>
</ul></li>
</ul></li>
</ul>
<h3 id="实时渲染的渲染管线">实时渲染的渲染管线</h3>
<p><img src="/2021/11/20/CG/WHM-GAMES103/01/image-20211120201541226.png" style="zoom:80%;"></p>
<ul>
<li>几何建模可以不需要实时，动画和渲染需要是实时的</li>
<li>帧率：frame rate
<ul>
<li>游戏（强交互应用）：60 fps</li>
<li>电影（没有交互）：24 fps</li>
<li>图形学实时一般的标准帧率：30 fps</li>
</ul></li>
<li>实时动画和实时渲染是比较难的</li>
<li>取舍
<ul>
<li>动画部分做成离线，渲染是实时的
<ul>
<li>游戏的过场动画等</li>
<li>电商的展示</li>
</ul></li>
<li>渲染也做成离线的
<ul>
<li>动画电影（没有实时交互的要求）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="几何">几何</h3>
<ul>
<li>三维表示</li>
</ul>
<h4 id="mesh">Mesh</h4>
<ul>
<li>网格：Mesh</li>
<li>组成部分
<ul>
<li>顶点：vertices（nodes）</li>
<li>多边形元素
<ul>
<li>三角形（图形学的渲染管线一般都是基于三角形）</li>
<li>多边形（符合人们的设计习惯，CAD
设计软件中会使用，软体模拟中会使用）</li>
</ul></li>
</ul></li>
<li>问题
<ul>
<li>Meshing (Delaunay triangulation)
<ul>
<li>希望所有的三角形都是比较正的（60 度）</li>
</ul></li>
<li>Simplification/subdivision
<ul>
<li>简化、细分</li>
</ul></li>
<li>Mesh optimization (smoothing, flows…)
<ul>
<li>网格的优化</li>
</ul></li>
<li>Volume mesh
<ul>
<li>如何处理四面体网格</li>
</ul></li>
</ul></li>
<li>类型
<ul>
<li>structured mesh
<ul>
<li>有些算法可以利用结构进行优化</li>
</ul></li>
<li>unstructured mesh
<ul>
<li>通用性更强</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/11/20/CG/WHM-GAMES103/01/image-20211120202730359.png" style="zoom: 80%;"></p>
<h4 id="point-cloud">Point Cloud</h4>
<ul>
<li>点云</li>
<li>可以通过扫描得到</li>
<li>问题
<ul>
<li>如何从点云中重建出 mesh（点云无法直接用于渲染）</li>
<li>re-sampling：重新采样
<ul>
<li>原始点云可能稀疏程度不一致，如何对其重新采样让其稀疏程度一致</li>
</ul></li>
<li>neighborhood search
<ul>
<li>周围点的查找</li>
<li>给定一个点，如何找到周围的点，算法上会用到</li>
</ul></li>
</ul></li>
</ul>
<h4 id="grid">Grid</h4>
<ul>
<li>volumetric grid：三维的格子</li>
<li>体素</li>
<li>CT 的原始数据就是这样的</li>
<li>问题
<ul>
<li>内存消耗可能非常大
<ul>
<li>八叉树（octree）结构的优化</li>
</ul></li>
<li>如何渲染？
<ul>
<li>volumetric rendering</li>
</ul></li>
</ul></li>
</ul>
<h3 id="渲染">渲染</h3>
<ul>
<li>真实感渲染：Photorealistic</li>
<li>非真实感渲染：Non-Photorealistic</li>
<li>真实感渲染的两种类型
<ul>
<li>基于传统渲染管线</li>
<li>基于光线追踪</li>
</ul></li>
<li>材质获取
<ul>
<li>材质扫描：material scan
<ul>
<li>photo</li>
<li>vrscan</li>
</ul></li>
<li>构造 BRDF</li>
</ul></li>
<li>人体扫描：body scan
<ul>
<li>曲面的，而不是平面的</li>
<li>技术：light stage</li>
<li>下图：Body Scan by a Light Stage
<ul>
<li>不同摄像头拍摄不同灯光、不同角度</li>
</ul></li>
<li>人体：BSSRDF（次表面散射）</li>
</ul></li>
</ul>
<p><img src="/2021/11/20/CG/WHM-GAMES103/01/image-20211120203537926.png"></p>
<h3 id="动画">动画</h3>
<ul>
<li>两类动画
<ul>
<li>人体动画：character animation</li>
<li>物理动画：physics-based animation</li>
</ul></li>
<li>虚拟数字人</li>
</ul>
<h2 id="计算机图形学的应用">计算机图形学的应用</h2>
<ul>
<li><p>What’s computer graphics used for?</p></li>
<li><p>游戏（games）</p></li>
<li><p>特效（special effects）</p></li>
<li><p>娱乐行业：抖音等</p></li>
<li><p>设计</p>
<ul>
<li><p>制造业（mechanics）</p></li>
<li><p>建筑行业（architecture）</p></li>
<li><p>艺术（art）</p></li>
<li><p>时尚产业（fashion）</p></li>
<li><p>设计虚拟服装</p>
<ul>
<li>style3D（凌迪科技）的软件</li>
</ul></li>
</ul></li>
<li><p>电商（智能制造）</p>
<ul>
<li>产业链</li>
</ul></li>
<li><p>虚拟衣服的渲染</p></li>
<li><p>VR、AR、metaverse（元宇宙）</p></li>
</ul>
<h2 id="什么是动画">什么是动画</h2>
<ul>
<li>What’s physics-based animation?</li>
</ul>
<h3 id="动画的流程">动画的流程</h3>
<p><img src="/2021/11/20/CG/WHM-GAMES103/01/image-20211120204911312.png" style="zoom:80%;"></p>
<ul>
<li>有很多时间点，在这些时间点上更新物体的状态</li>
<li>可能需要更新的状态
<ul>
<li>position/orientation：位置朝向等</li>
<li>velocity：速度</li>
<li>appearance：外观
<ul>
<li>变色龙</li>
</ul></li>
<li>density：密度
<ul>
<li>特效</li>
</ul></li>
</ul></li>
<li>time step（步长）：两个时间之间的间隔
<ul>
<li>可以和帧率相同</li>
<li>也可能一帧之内模拟好几次</li>
</ul></li>
</ul>
<h3 id="物理模拟的-4-大方向">物理模拟的 4 大方向</h3>
<ul>
<li>rigid bodies：刚体模拟</li>
<li>cloth and hair：衣服和头发
<ul>
<li>窄细的物体</li>
</ul></li>
<li>soft bodies：弹性体、软体</li>
<li>fluids：流体和气体</li>
</ul>
<p><img src="/2021/11/20/CG/WHM-GAMES103/01/image-20211120205405717.png" style="zoom:80%;"></p>
<ul>
<li>表示方式</li>
</ul>
<table>
<colgroup>
<col style="width: 14%">
<col style="width: 21%">
<col style="width: 19%">
<col style="width: 21%">
<col style="width: 21%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Contents</th>
<th style="text-align: center;">Effects</th>
<th style="text-align: center;">Mesh</th>
<th style="text-align: center;">Particle</th>
<th style="text-align: center;">Grid</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>Rigid Bodies</strong></td>
<td style="text-align: center;">Contacts</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>Rigid Bodies</strong></td>
<td style="text-align: center;">Fracture</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;">meshless</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Cloth and Hair</strong></td>
<td style="text-align: center;">Cloth</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">contact</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>Cloth and Hair</strong></td>
<td style="text-align: center;">Hair</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">contact</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Soft Bodies</strong></td>
<td style="text-align: center;">Elastic</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>Soft Bodies</strong></td>
<td style="text-align: center;">plastic</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Fluids</strong></td>
<td style="text-align: center;">Smoke</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>Fluids</strong></td>
<td style="text-align: center;">Drops and Waves</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Fluids</strong></td>
<td style="text-align: center;">Splashes</td>
<td style="text-align: center;">?</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
</tr>
</tbody>
</table>
<h4 id="刚体头发布料软体">刚体、头发布料、软体</h4>
<ul>
<li>一般使用 mesh 模拟
<ul>
<li>Physics-Inspired Adaptive Fracture Refinement (SIGGRAPH 2014)
<ul>
<li>刚体破碎</li>
</ul></li>
<li>GPU-Based Simulation of Cloth Wrinkles at Submillimeter Levels
(SIGGRAPH 2021)
<ul>
<li>衣服布料模拟</li>
</ul></li>
<li>Descent Methods for Elastic Body Simulation on the GPU (SIGGRAPH
Asia 2016)
<ul>
<li>弹性体</li>
</ul></li>
<li>Example-based Plastic Deformation of Rigid Bodies (SIGGRAPH 2016)
<ul>
<li>塑性形变（永久形变）</li>
</ul></li>
</ul></li>
<li>一些特例
<ul>
<li>实验性质，可能有计算量可能变大、细节处理不好等问题</li>
<li>用 particle 粒子去模拟刚体的破裂
<ul>
<li>因为没有 mesh，因此不需要去管破裂之后 mesh 的更新
<ul>
<li>avoid remeshing</li>
</ul></li>
<li>Meshless animation of fracturing solids (SIGGRAPH 2005)</li>
</ul></li>
<li>使用 grid 网格的方式去模拟布料和头发
<ul>
<li>简化碰撞的处理
<ul>
<li>simplify contact</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="流体">流体</h4>
<ul>
<li>各种各样</li>
<li>smoke（烟）
<ul>
<li>particle、grid</li>
<li>可以做成实时的效果（particle）</li>
</ul></li>
<li>drops and wawes（水滴和波）
<ul>
<li>基本上还是个整体</li>
<li>mesh：实时模拟</li>
<li>grid：高逼真度的模拟</li>
<li>Water Surface Wavelets (SIGGRAPH 2018)
<ul>
<li>引入小波，实时模拟，可以和物体有交互</li>
</ul></li>
</ul></li>
<li>splashes：水花
<ul>
<li>很复杂，实时比较难</li>
<li>基本上基于 particle 和 grid 进行
<ul>
<li>基于 mesh 的比较少，基本上是实验性质</li>
</ul></li>
<li>Versatile Rigid-Fluid Coupling for Incompressible SPH (SIGGRAPH
2012)</li>
</ul></li>
</ul>
<h4 id="hybrid-methods">hybrid methods</h4>
<ul>
<li>MPM：Material Point Method
<ul>
<li>粒子和网格结合的方法</li>
<li>想要这样子的方法兼具粒子、网格的优点</li>
<li>模拟雪（<strong>粘滞的物体</strong>）
<ul>
<li>A Material Point Method for Snow Simulation (SIGGRAPH 2013)</li>
</ul></li>
</ul></li>
<li>Coupling
<ul>
<li>怎么样模拟不同性质的物体的之间的交互？</li>
<li>例如：水落在衣服上</li>
</ul></li>
</ul>
<h2 id="课程涉及的内容">课程涉及的内容</h2>
<ul>
<li>What are the topics to be studied in this class?</li>
</ul>
<p><img src="/2021/11/20/CG/WHM-GAMES103/01/image-20211120212321947.png" style="zoom:80%;"></p>
<ul>
<li>刚体破碎方面会涉及很多 remeshing 的内容
<ul>
<li>游戏引擎中的破碎一般是<strong>预计算</strong>做的</li>
<li>Unity 不支持实时的破碎</li>
</ul></li>
<li>形变的 3 个阶段
<ul>
<li>弹性形变、塑性形变、破碎形变</li>
</ul></li>
<li>PBD：Position Based Dynamics
<ul>
<li>PBD 是预估点的下一位置，然后通过 constrain 把它 project
到最终位置，并用这个位置去更新速度</li>
</ul></li>
<li>Constraint Dynamics：基于拉格朗日算子的，基于约束的模拟</li>
<li>mesh 和 grid
<ul>
<li>mesh 定义在物体上的</li>
<li>grid 是定义在整个 3D 场景上的</li>
</ul></li>
<li>老师个人经历</li>
</ul>
<p><img src="/2021/11/20/CG/WHM-GAMES103/01/image-20211120213016904.png" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.02.Math Background(2)</title>
    <url>/2021/11/21/CG/WHM-GAMES103/02-1/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="math-background">Math Background</h1>
<h2 id="matrices">Matrices</h2>
<ul>
<li>图形学中常见的 <span class="math inline">\(4\times4,3\times3\)</span> 的矩阵</li>
</ul>
<h3 id="基本操作">基本操作</h3>
<ul>
<li>转置：transpose</li>
<li>对称矩阵：symmetric
<ul>
<li><span class="math inline">\(\mathbf{A}^{\mathbf{T}}=\mathbf{A}\)</span></li>
</ul></li>
<li>对角矩阵：diagonal</li>
<li>单位矩阵：identity
<ul>
<li><span class="math inline">\(\mathbf{I}\)</span></li>
</ul></li>
<li>乘法
<ul>
<li>矩阵 乘 向量</li>
<li>矩阵 乘 矩阵
<ul>
<li>满足结合律，一般不满足交换律</li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
(\mathbf{AB})^{\mathbf{T}}=\mathbf{B}^{\mathbf{T}}\mathbf{A}^{\mathbf{T}}
\]</span></p>
<p><span class="math display">\[
(\mathbf{A}\mathbf{A}^{\mathbf{T}})^{\mathbf{T}}=\mathbf{A}\mathbf{A}^{\mathbf{T}}
\]</span></p>
<p><span class="math display">\[
(\mathbf{A}+\mathbf{A}^{\mathbf{T}})^{\mathbf{T}}=\mathbf{A}+\mathbf{A}^{\mathbf{T}}
\]</span></p>
<ul>
<li>求逆</li>
</ul>
<p><span class="math display">\[
\mathbf{A}\mathbf{A}^{-1}=\mathbf{I}
\]</span></p>
<p><span class="math display">\[
(\mathbf{AB})^{-1}=\mathbf{B}^{-1}\mathbf{A}^{-1}
\]</span></p>
<ul>
<li>正交矩阵</li>
</ul>
<p><span class="math display">\[
\mathbf{A}\mathbf{A}^{\mathbf{T}}=\mathbf{I}
\]</span></p>
<p><span class="math display">\[
\mathbf{A}^{-1}=\mathbf{A}^{\mathbf{T}}
\]</span></p>
<ul>
<li><strong>旋转变换</strong>：正交矩阵
<ul>
<li>旋转矩阵就是新的 <span class="math inline">\(xyz\)</span>
轴在原来坐标系中对应的位置组成的矩阵</li>
</ul></li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02-1/image-20211121214552150.png" style="zoom:80%;"></p>
<ul>
<li><strong>放缩变换</strong></li>
</ul>
<h3 id="奇异值分解">奇异值分解</h3>
<ul>
<li>SVD
<ul>
<li>Singular Value Decomposition</li>
</ul></li>
<li><strong>任意矩阵</strong>的奇异值分解
<ul>
<li>对角矩阵 <span class="math inline">\(\mathbf{D}\)</span></li>
<li>正交矩阵 <span class="math inline">\(\mathbf{U},\mathbf{V}\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\mathbf{A}=\mathbf{U}\mathbf{D}\mathbf{V}^{\mathbf{T}}
\]</span></p>
<ul>
<li>图形学中的某个解释</li>
<li>任何线性变换都可以通过如下三步实现
<ul>
<li>旋转 <span class="math inline">\(\mathbf{V}^{\mathbf{T}}\)</span>、缩放 <span class="math inline">\(\mathbf{D}\)</span>、旋转 <span class="math inline">\(\mathbf{U}\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02-1/image-20211123161229370.png" style="zoom:80%;"></p>
<h3 id="特征值分解">特征值分解</h3>
<ul>
<li><p><strong>对称矩阵</strong>的特征值分解</p>
<ul>
<li><p>对角矩阵 <span class="math inline">\(\mathbf{D}\)</span></p></li>
<li><p>正交矩阵 <span class="math inline">\(\mathbf{U}\)</span></p></li>
</ul></li>
</ul>
<p><span class="math display">\[
\mathbf{A}=\mathbf{U}\mathbf{D}\mathbf{U}^{\mathbf{T}}
\]</span></p>
<ul>
<li><span class="math inline">\(\mathbf{D}\)</span>
的对角元素为特征值，<span class="math inline">\(\mathbf{U}\)</span>
的列向量为特征向量</li>
</ul>
<p><span class="math display">\[
\mathbf{A}\mathbf{u}_i=\mathbf{U}\mathbf{D}\mathbf{U}^{\mathbf{T}}\mathbf{u}_i=d_i\mathbf{u}_i
\]</span></p>
<ul>
<li>图形学中大多考虑的都是对称矩阵
<ul>
<li>非对称矩阵特征值可能会有虚数，图形学中不考虑虚数</li>
</ul></li>
</ul>
<h3 id="对称正定矩阵">对称正定矩阵</h3>
<ul>
<li>Symmetric Position Definiteness
<ul>
<li>s.p.d.</li>
</ul></li>
<li>对称正定：<span class="math inline">\(\mathbf{v}^{\mathbf{T}}\mathbf{A}\mathbf{v}&gt;0\)</span></li>
<li>对称半正定：<span class="math inline">\(\mathbf{v}^{\mathbf{T}}\mathbf{A}\mathbf{v}\ge0\)</span></li>
<li><strong>对称正定</strong> <span class="math inline">\(\Longleftrightarrow\)</span> <strong>特征值都大于
0</strong></li>
<li><strong>对角占优矩阵</strong> <span class="math inline">\(\Longrightarrow\)</span>
<strong>正定的</strong>（不一定是对称的）
<ul>
<li>每一行中，对角元素的绝对值大于剩余元素绝对值之和</li>
</ul></li>
<li>对称正定矩阵一定是可逆的</li>
</ul>
<p><span class="math display">\[
\mathbf{A}^{-1}=\mathbf{U}\mathbf{D}^{-1}\mathbf{U}^{\mathbf{T}}
\]</span></p>
<h3 id="quiz">Quiz</h3>
<ul>
<li><span class="math inline">\(\mathbf{A}\)</span> 是对称正定的，证明
<span class="math inline">\(\mathbf{B}\)</span> 是对称半正定的</li>
</ul>
<p><span class="math display">\[
\mathbf{B}=
\begin{bmatrix}
-\mathbf{A}&amp;\mathbf{A}\\
\mathbf{A}&amp;-\mathbf{A}\\
\end{bmatrix}
\]</span></p>
<ul>
<li>定义出发证明即可</li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02-1/image-20211123164404374.png" style="zoom:80%;"></p>
<ul>
<li>在物理模拟中经常遇到这样的矩阵，比较重要的性质</li>
</ul>
<h3 id="线性方程组求解问题">线性方程组求解问题</h3>
<ul>
<li><a href="/2021/10/02/computation/pyr/03/">参考</a></li>
<li>Linear Solver</li>
</ul>
<p><span class="math display">\[
\mathbf{A}{\color{red}\mathbf{x}}=\mathbf{b}
\]</span></p>
<ul>
<li>方阵 <span class="math inline">\(\mathbf{A}\)</span>
<ul>
<li>square matrix</li>
</ul></li>
<li>边界条件 <span class="math inline">\(\mathbf{b}\)</span>
<ul>
<li>boundary vector</li>
</ul></li>
<li><span class="math inline">\(\mathbf{x}=\mathbf{A}^{-1}\mathbf{b}\)</span>
<ul>
<li><span class="math inline">\(\mathbf{A}^{-1}\)</span> 很难计算</li>
<li>带来计算问题、存储问题
<ul>
<li>稀疏矩阵 <span class="math inline">\(\mathbf{A}\)</span>
可以优化存储，但是它的逆不稀疏</li>
</ul></li>
</ul></li>
</ul>
<h4 id="lu-分解">LU 分解</h4>
<ul>
<li>直接法求解线性方程组</li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02-1/image-20211123165051173.png" style="zoom:80%;"></p>
<ul>
<li>LU 分解之后，求解矩阵的开销从 <span class="math inline">\(O(n^3)\)</span> 变成 <span class="math inline">\(O(n^2)\)</span></li>
</ul>
<h5 id="特点">特点</h5>
<ul>
<li>如果 <span class="math inline">\(\mathbf{A}\)</span> 是稀疏的，<span class="math inline">\(\mathbf{L},\mathbf{U}\)</span> 则没有那么稀疏
<ul>
<li>可以通过改变行列的顺序让 <span class="math inline">\(\mathbf{L},\mathbf{U}\)</span> 的稀疏性变好</li>
<li>在进行 LU 分解之前会进行 permutation（重排行列）</li>
</ul></li>
<li>计算分为两步
<ul>
<li>第一步分解 <span class="math inline">\(O(n^3)\)</span>
<ul>
<li>如果 <span class="math inline">\(\mathbf{A}\)</span>
固定，则只需要做一次</li>
</ul></li>
<li>第二步求解 <span class="math inline">\(O(n^2)\)</span></li>
</ul></li>
<li>难以并行
<ul>
<li>Intel oneMKL库
<ul>
<li><a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl.html">Math
Kernel Library</a></li>
</ul></li>
</ul></li>
</ul>
<h4 id="迭代方法求解">迭代方法求解</h4>
<ul>
<li><a href="/2021/10/10/computation/pyr/03-1/">参考</a></li>
<li>松弛方法</li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02-1/image-20211123170129319.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(\mathbf{I}-\alpha\mathbf{A}\mathbf{M}^{-1}\)</span>
的谱半径小于 1 时收敛
<ul>
<li>spectral radius</li>
</ul></li>
<li><span class="math inline">\(\mathbf{M}\)</span> 需要容易计算
<ul>
<li>雅可比方法：<span class="math inline">\(\mathbf{M}=\mathbf{I}\)</span></li>
<li>高斯赛德尔方法：<span class="math inline">\(\mathbf{M}=\mathrm{lower}(\mathbf{A})\)</span></li>
</ul></li>
<li>共轭梯度法</li>
<li>切比雪夫加速</li>
</ul>
<h5 id="特点-1">特点</h5>
<ul>
<li>好处
<ul>
<li>简单</li>
<li>不需要精确解的情况下，求解比较快</li>
<li>容易并行</li>
</ul></li>
<li>缺点
<ul>
<li>存在收敛性问题
<ul>
<li>在某些情况下是能够保证收敛的</li>
</ul></li>
<li>求精确解可能比较慢</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.02.Math Background</title>
    <url>/2021/11/21/CG/WHM-GAMES103/02/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="math-background">Math Background</h1>
<ul>
<li>数学预备知识介绍</li>
<li>Vector, Matrix and Tensor Calculus
<ul>
<li>向量、矩阵、张量微积分</li>
</ul></li>
</ul>
<h2 id="vectors">Vectors</h2>
<h3 id="geometry-vector">Geometry Vector</h3>
<ul>
<li>矢量的定义（有几何含义）</li>
<li>An (Euclidean) vector
<ul>
<li>A geometric entity endowed with <strong>magnitude</strong> and
<strong>direction</strong></li>
</ul></li>
<li>向量（矢量）
<ul>
<li>带有大小和方向的量</li>
</ul></li>
<li>论文中区分标量和矢量
<ul>
<li>矢量：黑体 <span class="math inline">\(\mathbf{p}\)</span></li>
<li>标量：斜体 <span class="math inline">\(p\)</span></li>
<li>矩阵：大写 <span class="math inline">\(\mathbf{M}\)</span></li>
</ul></li>
</ul>
<h3 id="坐标系">坐标系</h3>
<ul>
<li>右手系、左手系</li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02/image-20211121151451454.png" style="zoom:80%;"></p>
<ul>
<li>左手系的好处
<ul>
<li>屏幕空间中，物体一般是在屏幕后面，那么物体的 <span class="math inline">\(z\)</span> 值都是正的</li>
</ul></li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02/image-20211121151925689.png" style="zoom:80%;"></p>
<h3 id="stacked-vector">Stacked Vector</h3>
<ul>
<li>矢量的定义（没有几何含义）</li>
<li>可以只是由一堆数字组成，而不具备表示三维空间中的方向等几何含义</li>
<li>常用于物体的描述</li>
<li>例如用 11 个点表示一个闪电</li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02/image-20211121152250317.png" style="zoom:80%;"></p>
<h3 id="矢量的运算">矢量的运算</h3>
<ul>
<li>矢量 <span class="math inline">\(\pm\)</span> 矢量</li>
<li>矢量的范数
<ul>
<li>2-范数：长度</li>
<li>p-范数</li>
<li>1-范数：曼哈顿距离</li>
<li>无穷范数</li>
</ul></li>
<li>单位矢量：unit vector
<ul>
<li>适量的单位化：normalization</li>
</ul></li>
<li>点乘
<ul>
<li><span class="math inline">\(\mathbf{p}\cdot\mathbf{q}=0\)</span>：向量垂直、正交</li>
</ul></li>
</ul>
<p><span class="math display">\[
\mathbf{p}\cdot\mathbf{q}=\langle\mathbf{p},\mathbf{q}\rangle=\mathbf{p}^{\mathbf{T}}\mathbf{q}
\]</span></p>
<ul>
<li>叉乘
<ul>
<li>右手系：<span class="math inline">\(\mathbf{p},\mathbf{q},\mathbf{r}\)</span></li>
<li><span class="math inline">\(\Vert{r}\Vert=\Vert{p}\Vert\Vert{q}\Vert\sin\theta\)</span></li>
<li><span class="math inline">\(\mathbf{p}\times\mathbf{q}=0\)</span>：向量平行</li>
</ul></li>
</ul>
<p><span class="math display">\[
\mathbf{r}=
\mathbf{p}\times\mathbf{q}=
\begin{pmatrix}
p_yq_z-p_zq_y\\
p_zq_x-p_xq_z\\
p_xq_y-p_yq_x\\
\end{pmatrix}
\]</span></p>
<ul>
<li></li>
</ul>
<h3 id="示例">示例</h3>
<h4 id="表示基础量">(1) 表示基础量</h4>
<ul>
<li>Linear Representation</li>
<li>矢量可以被用于描述如下的量
<ul>
<li>位置、速度、力、直线、光线、线段</li>
</ul></li>
<li>匀速运动的粒子的位置</li>
</ul>
<p><span class="math display">\[
\mathbf{p}(t)=\mathbf{p}+t\mathbf{v}
\]</span></p>
<ul>
<li>直线，两个点 <span class="math inline">\(\mathbf{p},\mathbf{q}\)</span>
<ul>
<li>直线：<span class="math inline">\(t\in\mathbf{R}\)</span></li>
<li>线段：<span class="math inline">\(0&lt;t&lt;1\)</span></li>
<li>射线（光线）：<span class="math inline">\(t&gt;0\)</span></li>
</ul></li>
<li>直线两种形式：运动形式、插值形式</li>
</ul>
<p><span class="math display">\[
\mathbf{p}(t)=\mathbf{p}+t(\mathbf{q}-\mathbf{p})
\]</span></p>
<p><span class="math display">\[
\mathbf{p}(t)=(1-t)\mathbf{p}+t\mathbf{q}
\]</span></p>
<h4 id="点到直线的投影">(2) 点到直线的投影</h4>
<ul>
<li>Paticle-Line Projection</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
s=(\mathbf{q}-\mathbf{o})^{\mathbf{T}}\dfrac{\mathbf{v}}{\Vert\mathbf{v}\Vert_2^2}=(\mathbf{q}-\mathbf{o})^{\mathbf{T}}\overline{\mathbf{v}}\\
\mathbf{s}=\mathbf{o}+s\overline{\mathbf{v}}
\end{array}
\]</span></p>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02/image-20211121154056584.png" style="zoom:80%;"></p>
<h4 id="平面的表示">(3) 平面的表示</h4>
<ul>
<li>Plane Representation</li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02/image-20211121154614919.png" style="zoom:80%;"> <span class="math display">\[
s=(\mathbf{p}-\mathbf{c})^{\mathbf{T}}\mathbf{n}
\left\{
\begin{array}{rl}
&gt;0,&amp;在平面上方\\
=0,&amp;在平面内部\\
&lt;0,&amp;在平面下方\\
\end{array}
\right.
\]</span></p>
<ul>
<li>有向距离 <span class="math inline">\(s\)</span>
<ul>
<li>可以用于位置的判定</li>
</ul></li>
<li>如何判断一个点在多面体内部？
<ul>
<li>在每个面的下方</li>
</ul></li>
</ul>
<h4 id="粒子和球的碰撞">(4) 粒子和球的碰撞</h4>
<ul>
<li>Particle-Sphere Collision</li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02/image-20211121155203945.png" style="zoom:80%;"></p>
<ul>
<li>判断如下式子是否有解</li>
</ul>
<p><span class="math display">\[
\Vert\mathbf{p}(t)-\mathbf{c}\Vert=r^2
\]</span></p>
<ul>
<li>展开</li>
</ul>
<p><span class="math display">\[
(\mathbf{v}\cdot\mathbf{v})t^2+2(\mathbf{p}-\mathbf{c})\cdot\mathbf{v}t+(\mathbf{p}-\mathbf{c})\cdot(\mathbf{p}-\mathbf{c})r^2=0
\]</span></p>
<ul>
<li><span class="math inline">\(t\ge0\)</span> + 最近的点（最小的 <span class="math inline">\(t\)</span>）</li>
</ul>
<h4 id="三角形面积和法向">(5) 三角形面积和法向</h4>
<ul>
<li>Triangle Normal and Area</li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02/image-20211121160109062.png" style="zoom:80%;"></p>
<ul>
<li>记号</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
\mathbf{x}_{10}=\mathbf{x}_{1}-\mathbf{x}_{0}\\
\mathbf{x}_{20}=\mathbf{x}_{2}-\mathbf{x}_{0}\\
\end{array}
\]</span></p>
<ul>
<li>法向（单位向量）</li>
</ul>
<p><span class="math display">\[
\mathbf{n}=\dfrac{\mathbf{x}_{10}\times\mathbf{x}_{20}}{\Vert\mathbf{x}_{10}\times\mathbf{x}_{20}\Vert}
\]</span></p>
<ul>
<li>面积</li>
</ul>
<p><span class="math display">\[
S=\dfrac{\Vert\mathbf{x}_{10}\times\mathbf{x}_{20}\Vert}{2}
\]</span></p>
<ul>
<li>定义三角形的时候，<strong>顶点顺序很重要</strong></li>
<li>如何判定三点共线？
<ul>
<li>叉乘为 0</li>
</ul></li>
</ul>
<h4 id="判定点是否在三角形内部">(6) 判定点是否在三角形内部</h4>
<ul>
<li>Triangle Inside/Outside Test</li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02/image-20211121160823119.png" style="zoom:80%;"></p>
<ul>
<li>或者直接 3 个叉乘符号值相同即可
<ul>
<li>使用上面的判定方式能够更快排除掉点不在内部的情况</li>
</ul></li>
</ul>
<h4 id="重心坐标系">(7) 重心坐标系</h4>
<ul>
<li>Barycentric Coordinate</li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02/image-20211121161301785.png" style="zoom:80%;"></p>
<ul>
<li>表示面积大小</li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02/image-20211121161429572.png" style="zoom:80%;"></p>
<ul>
<li>有向面积大小</li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02/image-20211121161606356.png" style="zoom:80%;"></p>
<ul>
<li>重心坐标系</li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02/image-20211121161629906.png" style="zoom:80%;"></p>
<ul>
<li>使用重心坐标系对三角形内部的属性进行插值
<ul>
<li>Gouraud Shading
<ul>
<li>早期硬件计算较弱的时候，使用这种方式减小 shading 的开销
<ul>
<li>计算插值比 shading 计算快</li>
</ul></li>
<li>现在不流行了</li>
</ul></li>
<li><strong>双线性插值</strong>，利用扫描线算法进行插值</li>
</ul></li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02/image-20211121161842334.png" style="zoom:80%;"></p>
<h4 id="四面体体积计算">(8) 四面体体积计算</h4>
<ul>
<li>Tetrahedral Volume</li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02/image-20211121192415170.png" style="zoom:80%;"></p>
<ul>
<li>边向量</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
\mathbf{x}_{10}=\mathbf{x}_{1}-\mathbf{x}_{0}\\
\mathbf{x}_{20}=\mathbf{x}_{2}-\mathbf{x}_{0}\\
\mathbf{x}_{30}=\mathbf{x}_{3}-\mathbf{x}_{0}\\
\end{array}
\]</span></p>
<ul>
<li>体积</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
V&amp;=\dfrac{1}{3}Sh=
\dfrac{1}{3}
\left(\dfrac{1}{2}\Vert\mathbf{x}_{10}\times\mathbf{x}_{20}\Vert_2\right)
\left(\mathbf{x}_{30}\cdot\mathbf{n}\right)\\
&amp;=\dfrac{1}{3}
\left(\dfrac{1}{2}\Vert\mathbf{x}_{10}\times\mathbf{x}_{20}\Vert_2\right)
\left(\mathbf{x}_{30}\cdot\dfrac{\mathbf{x}_{10}\times\mathbf{x}_{20}}{\Vert\mathbf{x}_{10}\times\mathbf{x}_{20}\Vert_2}\right)\\
&amp;=\dfrac{1}{6}\mathbf{x}_{30}\cdot(\mathbf{x}_{10}\times\mathbf{x}_{20})
\end{aligned}
\]</span></p>
<ul>
<li>行列式表示方式：<span class="math inline">\(4\times4\)</span></li>
</ul>
<p><span class="math display">\[
V=\left|\begin{array}{cccc}
\mathbf{x}_1&amp;\mathbf{x}_2&amp;\mathbf{x}_3&amp;\mathbf{x}_0\\
1&amp;1&amp;1&amp;1\\
\end{array}\right|
\]</span></p>
<ul>
<li>体积是带正负的</li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02/image-20211121194156637.png" style="zoom:80%;"></p>
<h4 id="重心坐标系-1">(9) 重心坐标系</h4>
<ul>
<li>Barycentric Weights</li>
<li>中间的点将四面体划分为 4 个部分，4
个部分的体积占比对应对面的顶点的权重</li>
</ul>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02/image-20211121194404133.png" style="zoom:80%;"></p>
<h4 id="移动粒子和三角形求交">(10) 移动粒子和三角形求交</h4>
<p><img src="/2021/11/21/CG/WHM-GAMES103/02/image-20211121194644496.png" style="zoom:80%;"></p>
<ul>
<li>首先求得时间 <span class="math inline">\(\mathbf{p}\)</span>
和平面相交的时间 <span class="math inline">\(t\)</span></li>
</ul>
<p><span class="math display">\[
(\mathbf{p}(t)-\mathbf{x}_0)\cdot(\mathbf{x}_{10}\times\mathbf{x}_{20})=0
\]</span></p>
<p><span class="math display">\[
t=-\dfrac
{(\mathbf{p}-\mathbf{x}_0)\cdot(\mathbf{x}_{10}\times\mathbf{x}_{20})}
{\mathbf{v}\cdot(\mathbf{x}_{10}\times\mathbf{x}_{20})}
\]</span></p>
<ul>
<li>然后再判断 <span class="math inline">\(\mathbf{p}(t)\)</span>
是否落在三角形内部</li>
</ul>
<h3 id="其他">其他</h3>
<ul>
<li>某论文
<ul>
<li>Vega: Nonlinear FEM Deformable Object Simulator</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.04.Rigid Contacts</title>
    <url>/2021/12/04/CG/WHM-GAMES103/04/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="刚体碰撞">刚体碰撞</h1>
<h2 id="大纲">大纲</h2>
<ul>
<li>粒子的碰撞检测与响应
<ul>
<li>penalty methods</li>
<li>impulse methods</li>
</ul></li>
<li>基于 impulse methods 的刚体碰撞检测与响应</li>
<li>shape matching 方法
<ul>
<li><strong>物理无关</strong></li>
</ul></li>
</ul>
<h2 id="粒子碰撞">粒子碰撞</h2>
<ul>
<li>Particle Collision Detection and Response</li>
</ul>
<h3 id="有向距离函数">有向距离函数</h3>
<ul>
<li>Signed Distance Function</li>
<li>用于表示一个点到某个表面的距离
<ul>
<li>正负表示内外
<ul>
<li>内部：负</li>
<li>外部：正</li>
</ul></li>
<li>大小表示距离</li>
</ul></li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204155434956.png" style="zoom:80%;"></p>
<ul>
<li>正好在表面上：zero surface</li>
</ul>
<h4 id="例子">例子</h4>
<ul>
<li>表面、球体、无限长圆柱</li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204155705442.png" style="zoom:80%;"></p>
<h4 id="相交计算">相交计算</h4>
<ul>
<li>Intersection</li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204160524098.png" style="zoom:80%;"></p>
<ul>
<li>如果都小于 0，则在内部；否则在外部</li>
<li>在内部的时候，取 <span class="math inline">\(\max\)</span>，因为都是<strong>负数</strong></li>
<li>在外部的时候，距离函数不一定是 <span class="math inline">\(\max\)</span>，可能和这三个值都不相关
<ul>
<li>对应最小值的那个点，可能不在相交的区域内部</li>
</ul></li>
<li>但是碰撞检测我们都不关心外部的情况，因此不需要考虑具体的值（<strong>只有内部才相交</strong>）</li>
</ul>
<h4 id="求并计算">求并计算</h4>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204161123769.png" style="zoom:80%;"></p>
<ul>
<li>对应求并，在外部则直接取 <span class="math inline">\(\min\)</span></li>
<li>在内部则不一定，因为距离最小值对应的点可能不在并集的边界上（例如上图）
<ul>
<li>假设点比较靠近并集的外表面，可以使用取 <span class="math inline">\(\min\)</span> 近似</li>
</ul></li>
<li>另外一种做法，分别对这两个物体做碰撞检测</li>
</ul>
<h3 id="碰撞检测">碰撞检测</h3>
<ul>
<li>利用有向距离函数做碰撞检测</li>
<li>有 <span class="math inline">\(\phi(\mathbf{x})&lt;0\)</span>，则发生碰撞</li>
</ul>
<h3 id="碰撞响应">碰撞响应</h3>
<h4 id="penalty-method">Penalty Method</h4>
<ul>
<li>设置一个处罚的力，把粒子从内部推出来</li>
<li>效果是滞后的，在下一步迭代中这个力才会生效</li>
</ul>
<h5 id="quadratic-penalty-method">Quadratic Penalty Method</h5>
<ul>
<li>penalty potential is quadratic
<ul>
<li>二次</li>
</ul></li>
<li>弹簧力的大小正比于 <span class="math inline">\(\phi(\mathbf{x})\)</span></li>
<li>弹簧力的方向为对应 <span class="math inline">\(\phi(\mathbf{x})\)</span> 的点的法向</li>
<li>示意图</li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204162037357.png" style="zoom:80%;"></p>
<ul>
<li>表达式
<ul>
<li><span class="math inline">\(k\)</span>：penalty strength</li>
</ul></li>
</ul>
<p><span class="math display">\[
\mathbf{f}=-k\;\phi(\mathbf{x})\;\mathbf{N}
\]</span></p>
<ul>
<li>问题：只有粒子在内部才产生力
<ul>
<li>因此只有在穿模发生，才会有里把他推出来</li>
<li>artifacts</li>
</ul></li>
</ul>
<h5 id="quadratic-penalty-method-with-a-buffer">Quadratic Penalty Method
with a Buffer</h5>
<ul>
<li>可以预先加一个范围，当 <span class="math inline">\(\phi(\mathbf{x})&lt;\epsilon\)</span>，则认为碰撞发生</li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204162347993.png" style="zoom:80%;"></p>
<ul>
<li>表达式</li>
</ul>
<p><span class="math display">\[
\mathbf{f}=k\;(\epsilon-\phi(\mathbf{x}))\;\mathbf{N}
\]</span></p>
<ul>
<li>还是有问题
<ul>
<li>如何设置 <span class="math inline">\(k\)</span> ？
<ul>
<li>太大：一碰就直接飞走了（over shooting）</li>
<li>太小：推不出来</li>
</ul></li>
</ul></li>
</ul>
<h5 id="log-barrier-penalty-method">Log-Barrier Penalty Method</h5>
<ul>
<li>动态调整 <span class="math inline">\(k\)</span>
的大小，和距离相关</li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204162919967.png" style="zoom:80%;"></p>
<ul>
<li><strong>认为在内部不会发生</strong>
<ul>
<li>这样需要调整 <span class="math inline">\(\Delta{t}\)</span>
的大小才能满足</li>
<li><strong>小步长</strong></li>
</ul></li>
<li>为什么叫做 Log-Barrier Penalty Method
<ul>
<li>力可以认为是能量的导数，能量表达式中有 <span class="math inline">\(\log\)</span> 的形式</li>
</ul></li>
<li>问题
<ul>
<li>over shooting 的发生还是很难避免
<ul>
<li>离得很近</li>
</ul></li>
<li>可能穿透
<ul>
<li>如果穿透，则会越陷越深</li>
</ul></li>
</ul></li>
</ul>
<h5 id="penalty-method-总结">Penalty Method 总结</h5>
<ul>
<li>需要调整步长
<ul>
<li>减少 overshooting 问题</li>
<li>保证 log-barrier 不穿透</li>
</ul></li>
<li>可以给 log-barrier 方法加一个 buffer
<ul>
<li>Li et al. 2020. <em>Incremental Potential Contact: Intersection- and
Inversion-free Large Deformation Dynamics</em>. TOG.</li>
<li>Wu et al. 2020. <em>A Safe and Fast Repulsion Method for GPU-based
Cloth Self Collisions</em>. TOG.</li>
</ul></li>
<li>很难做摩擦
<ul>
<li>Frictional contacts are difficult to handle</li>
</ul></li>
</ul>
<h4 id="impulse-method">Impulse Method</h4>
<ul>
<li>希望施加的力在这次迭代中马上有效果，而不滞后</li>
<li>在检测到碰撞之后，马上设置新的状态 <span class="math inline">\(\mathbf{x},\mathbf{v}\)</span></li>
</ul>
<h5 id="位置设定">位置设定</h5>
<ul>
<li>直接平移到表面</li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204164200371.png" style="zoom:80%;"></p>
<h5 id="速度设置">速度设置</h5>
<ul>
<li>考虑摩擦</li>
<li>速度分解：法向 + 切向</li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204164530566.png" style="zoom:80%;"></p>
<ul>
<li>判断速度是否还是继续向物体内部，如果向物体内部则将其修改为朝外
<ul>
<li><strong>法向分量</strong>反向</li>
<li>乘上一个 <span class="math inline">\([0,1]\)</span> 之间的系数 <span class="math inline">\(\mu_{\mathbf{N}}\)</span></li>
</ul></li>
<li>考虑摩擦力
<ul>
<li><strong>切向分量</strong>乘上一个摩擦系数 <span class="math inline">\(a\)</span></li>
</ul></li>
<li>如何设置 <span class="math inline">\(a\)</span>
<ul>
<li><span class="math inline">\(a\)</span>
期望速度下降的最多（越小越好）</li>
<li>需要满足库仑摩擦定律
<ul>
<li>切向上速度变化不能小于法向上速度变化乘以系数 <span class="math inline">\(\mu_{\mathbf{T}}\)</span>
<ul>
<li><strong>摩擦力跟作用在摩擦面上的正压力成正比</strong></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204165238393.png" style="zoom:80%;"></p>
<ul>
<li>流程图</li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204164746076.png" style="zoom:80%;"></p>
<ul>
<li>优点是能够加入对<strong>摩擦力</strong>的控制</li>
<li>处理起来相对比较麻烦</li>
<li>实际应用中
<ul>
<li>刚体模拟：impulse 方法还是挺多的</li>
<li>布料、弹性体：penalty 方法比较多</li>
</ul></li>
</ul>
<h2 id="刚体碰撞-1">刚体碰撞</h2>
<h3 id="碰撞检测-1">碰撞检测</h3>
<ul>
<li>如果物体由很多个点组成，可以对这些点遍历，对每一个点进行碰撞检测
<ul>
<li>如果有一个点碰撞上了，则就是碰撞上了</li>
<li>这种方法比较慢，但是也可以接受</li>
</ul></li>
</ul>
<h3 id="碰撞响应-1">碰撞响应</h3>
<ul>
<li>对于每一个节点，计算出来他们的位置 <span class="math inline">\(\mathbf{x}_i\)</span> 和速度 <span class="math inline">\(\mathbf{v}_i\)</span>
<ul>
<li>不能直接用这些点去更新，因为这些点都是虚拟的，直接更新不能满足刚体的性质</li>
<li>对于刚体而言，只有<strong>质心的 4 个属性</strong>（<span class="math inline">\(\mathbf{x,v,q,\omega}\)</span>）</li>
</ul></li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204181812387.png" style="zoom:80%;"></p>
<h4 id="impulse-方法">impulse 方法</h4>
<ul>
<li>使用简化的 impulse 方法进行更新
<ul>
<li>不更新位置，只更新速度</li>
<li>对于刚体而言，直接修改位置状态比较麻烦，修改速度和角速度则相对简单</li>
</ul></li>
<li>对整体施加一个冲量 <span class="math inline">\(\mathbf{j}\)</span>，实现对 <span class="math inline">\(\mathbf{x,v}\)</span> 的更新</li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204182625832.png" style="zoom:80%;"></p>
<ul>
<li>如何设置冲量 <span class="math inline">\(\mathbf{j}\)</span></li>
<li>考虑对整体设置了这样的冲量之后对单点的影响，因为我们能够通过上面的方式求得对单点的影响，因此能够反推求出
<span class="math inline">\(\mathbf{j}\)</span></li>
<li>如此便能够通过设定 <span class="math inline">\(\mathbf{j}\)</span>
控制 <span class="math inline">\(\mathbf{v}_i,\mathbf{\omega}_i\)</span>
的变化</li>
</ul>
<h4 id="对单点的影响">对单点的影响</h4>
<ul>
<li>那么这样施加的冲量对每一个点造成的影响如下</li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204183412318.png" style="zoom:80%;"></p>
<ul>
<li>叉乘 <span class="math inline">\(\mathbf{r}\times\)</span>
等价于一个矩阵乘 <span class="math inline">\(\mathbf{r}^{\ast}\)</span></li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204183124737.png" style="zoom:80%;"></p>
<ul>
<li>进一步统一如下</li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204183522866.png" style="zoom:80%;"></p>
<h4 id="算法">算法</h4>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204184204630.png" style="zoom:80%;"></p>
<h4 id="实现细节">实现细节</h4>
<ul>
<li>有多个点碰撞怎么处理？
<ul>
<li>求出这些点<strong>位置的平均值</strong>，对<strong>这个点</strong>做碰撞响应、计算冲量即可</li>
<li>不建议把每个点都算一遍，这样会导致最终计算得到的冲量偏大
<ul>
<li>因为其实你这个点计算得到的冲量也会对其他点造成影响</li>
</ul></li>
</ul></li>
<li>因为重力的存在，会导致物体一直在地面上抖动，掉下来弹上去，掉下来弹上去（oscillation）
<ul>
<li>加上一个衰减系数 <span class="math inline">\(\mu_{\mathbf{N}}\)</span></li>
</ul></li>
<li>为什么不直接更新位置？
<ul>
<li>非线性问题，需要保持刚体的形状，直接更新可能会不满足刚体原来的形状</li>
</ul></li>
</ul>
<h4 id="多个物体的碰撞">多个物体的碰撞</h4>
<ul>
<li>求解线性系统，因为他们直接互相影响</li>
<li><a href="https://graphics.pixar.com/pbm2001">参考</a></li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204185451962.png" style="zoom:80%;"></p>
<h2 id="shape-matching">Shape Matching</h2>
<ul>
<li>思想
<ul>
<li>首先让所有的点沿着速度的方向运动（类似粒子系统）
<ul>
<li>处理碰撞、摩擦</li>
</ul></li>
<li>然后再将形成的新节点聚回去，形成原来的形状</li>
</ul></li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204185911026.png" style="zoom:80%;"></p>
<ul>
<li>第一步就是做一步简单的粒子模拟</li>
<li>第二步加限制求解比较复杂</li>
</ul>
<h3 id="限制求解">限制求解</h3>
<ul>
<li>质心 <span class="math inline">\(\mathbf{c}\)</span>，旋转矩阵 <span class="math inline">\(\mathbf{R}\)</span> 不知道，需要求解这两个量</li>
<li><strong>最小二乘</strong></li>
</ul>
<p><span class="math display">\[
\{\mathbf{c},\mathbf{R}\}=\arg\min\sum_{i}\Vert{\mathbf{c}+\mathbf{R}\mathbf{r}_i-\mathbf{y}_i}\Vert
\]</span></p>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204190500400.png" style="zoom:80%;"></p>
<ul>
<li>放松限制，任意矩阵 <span class="math inline">\(\mathbf{A}\)</span>
代替旋转矩阵</li>
<li>求极值，求导</li>
<li>求 <span class="math inline">\(\mathbf{c}\)</span>
<ul>
<li><span class="math inline">\(\sum\mathbf{r}_i=\mathbf{0}\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204190627569.png" style="zoom:80%;"></p>
<ul>
<li>求 <span class="math inline">\(\mathbf{R}\)</span></li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204190902123.png" style="zoom:80%;"></p>
<ul>
<li>为什么对 <span class="math inline">\(\mathbf{A}\)</span> 做 polar
deformation 能够得到旋转矩阵 <span class="math inline">\(\mathbf{R}\)</span>
<ul>
<li>奇异值分解能够得到 3 个变换</li>
<li>经过处理我们能够将其转化为局部旋转 <span class="math inline">\(\times\)</span> 形变的部分</li>
<li>因为是刚体，我们没有形变，舍去 <span class="math inline">\(\mathbf{A}\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204191646285.png" style="zoom:80%;"></p>
<ul>
<li>polar deformation
<ul>
<li>直接法求解
<ul>
<li>AN ALGORITHM TO COMPUTE THE SQUARE ROOT OF A 3 X 3 POSITIVE DEFINITE
MATRIX</li>
</ul></li>
<li>迭代法求解
<ul>
<li>NUMERICAL RECIPES in C - The Art of Scientific Computing</li>
</ul></li>
</ul></li>
</ul>
<h3 id="算法流程">算法流程</h3>
<ul>
<li>每一个顶点都有自己的位置、速度</li>
</ul>
<p><img src="/2021/12/04/CG/WHM-GAMES103/04/image-20211204192421730.png" style="zoom:80%;"></p>
<h3 id="评价">评价</h3>
<ul>
<li>很容易实现</li>
<li>能够很好的模拟其他基于点的系统
<ul>
<li>布料、软体、粒子的流体</li>
</ul></li>
<li>很难严格保证所有的约束都满足
<ul>
<li>满足一个约束可能会破坏其他约束</li>
<li>可以通过迭代的方式</li>
</ul></li>
<li>当摩擦不是很重要的时候，可以使用 shape matching
<ul>
<li>接触不频繁，例如衣服上的纽扣</li>
</ul></li>
</ul>
<h3 id="论文">论文</h3>
<ul>
<li>Muller et al. 2005. <em>Meshless Deformations Based on Shape
Matching.</em> TOG (SIGGRAPH).</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.05.Physics-Based Cloth Simulation</title>
    <url>/2022/01/17/CG/WHM-GAMES103/05/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="布料模拟">布料模拟</h1>
<ul>
<li>刚体的其他话题
<ul>
<li>Articulation Body
<ul>
<li>关节体（人体骨骼动画）</li>
</ul></li>
</ul></li>
<li>方法：物理仿真模拟、基于约束的（PBD）、两者结合</li>
</ul>
<h2 id="主题">主题</h2>
<ul>
<li>弹簧质点系统（Mass-Spring System）
<ul>
<li>隐式积分、显式积分</li>
</ul></li>
<li>弯曲（bending）、弯曲带来的 locking 问题</li>
<li>Co-Rotational Method
<ul>
<li>类似于 shape matching</li>
</ul></li>
</ul>
<h2 id="弹簧质点系统">弹簧质点系统</h2>
<ul>
<li>Mass-Spring System</li>
<li>理想弹簧满足<strong>胡克定律</strong>
<ul>
<li>Hooke's Law</li>
</ul></li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220117152000052.png" style="zoom:80%;"></p>
<h3 id="一维">一维</h3>
<ul>
<li>弹簧原长（rest length）<span class="math inline">\(L\)</span></li>
<li>能量</li>
</ul>
<p><span class="math display">\[
E(x)=\dfrac{1}{2}k(x-L)^2
\]</span></p>
<ul>
<li>弹簧力：能量对位置的<strong>负导数</strong></li>
</ul>
<p><span class="math display">\[
f(x)=-\dfrac{\mathrm{d}E(x)}{x}=-k(x-L)
\]</span></p>
<ul>
<li><span class="math inline">\(k\)</span>：弹性系数（spring
stiffness）</li>
</ul>
<h3 id="二维">二维</h3>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220117152646068.png" style="zoom:80%;"></p>
<ul>
<li>能量</li>
</ul>
<p><span class="math display">\[
E(\mathbf{x})=\dfrac{1}{2}k(\Vert{\mathbf{x}_i-\mathbf{x}_j}\Vert-L)^2
\]</span></p>
<ul>
<li>弹簧力：能量对位置的<strong>负梯度</strong>
<ul>
<li>分别对 <span class="math inline">\(\mathbf{x}_i,\mathbf{x}_j\)</span> 求导</li>
</ul></li>
</ul>
<p><span class="math display">\[
f_i(\mathbf{x})=-\nabla_i
E(\mathbf{x})=-k(\Vert{\mathbf{x}_i-\mathbf{x}_j}\Vert-L)\dfrac{\mathbf{x}_i-\mathbf{x}_j}{\Vert{\mathbf{x}_i-\mathbf{x}_j}\Vert}
\]</span></p>
<p><span class="math display">\[
f_j(\mathbf{x})=-\nabla_j
E(\mathbf{x})=-k(\Vert{\mathbf{x}_i-\mathbf{x}_j}\Vert-L)\dfrac{\mathbf{x}_j-\mathbf{x}_i}{\Vert{\mathbf{x}_i-\mathbf{x}_j}\Vert}
\]</span></p>
<p><span class="math display">\[
f_j(\mathbf{x})=-f_i(\mathbf{x})
\]</span></p>
<ul>
<li><a href="/2021/11/28/CG/WHM-GAMES103/02-2/#计算向量范数的偏导">推导</a></li>
</ul>
<h3 id="多根弹簧">多根弹簧</h3>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220117155237258.png" style="zoom:80%;"></p>
<ul>
<li>能量和力都是可以叠加的
<ul>
<li>能量：标量和</li>
<li>力：矢量和</li>
</ul></li>
</ul>
<p><span class="math display">\[
E=\sum_{e=0}^{3}\dfrac{1}{2}k(\Vert{\mathbf{x}_i-\mathbf{x}_e}\Vert-L_e)^2
\]</span></p>
<p><span class="math display">\[
\mathbf{f}_i=-\nabla_iE=\sum_{e=0}^{3}-k(\Vert{\mathbf{x}_i-\mathbf{x}_e}\Vert-L)\dfrac{\mathbf{x}_i-\mathbf{x}_e}{\Vert{\mathbf{x}_i-\mathbf{x}_e}\Vert}
\]</span></p>
<h3 id="结构化的弹簧网络">结构化的弹簧网络</h3>
<ul>
<li>Structured Spring Networks</li>
<li>弹簧类型
<ul>
<li>Horizontal（水平方向）</li>
<li>Vertical（竖直方向）</li>
<li>Diagonal（对角的）</li>
<li>Bending（弯曲的）
<ul>
<li>防止面料任意的弯折</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220121103213022.png" style="zoom:80%;"></p>
<ul>
<li>简化的弹簧网络
<ul>
<li>每一个小单元只保留 45 度或者 135 度的对角弹簧</li>
<li>不能都使用 45 度或者 135
度的，这样会让模拟有<strong>偏向性</strong></li>
</ul></li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220121103415168.png" style="zoom:80%;"></p>
<h3 id="非结构化的弹簧网络">非结构化的弹簧网络</h3>
<ul>
<li>Unstructured Spring Networks</li>
<li>面料不规则的版型</li>
<li>使用<strong>三角网格</strong>设计</li>
<li>弹簧
<ul>
<li>Edges：每一条边都认为是一条弹簧</li>
<li>Bending：相邻的两个三角形的<strong>相对的两个顶点</strong>加一根弹簧
<ul>
<li>用于抵抗弯曲</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220121104016856.png" style="zoom:80%;"></p>
<ul>
<li>三角网格的表示
<ul>
<li><strong>顶点</strong>列表 + <strong>索引</strong>列表</li>
</ul></li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220121104838812.png" style="zoom:80%;"></p>
<ul>
<li>从上面的三角网格中获取到边的信息（表示<strong>边</strong>）</li>
<li>不能简单的直接把每个三角形的拿出来作为弹簧，因为存在<strong>重复边</strong>
<ul>
<li>内部边被两个三角形共享</li>
</ul></li>
<li>Topological Construction（拓扑结构）
<ul>
<li>几何处理</li>
</ul></li>
</ul>
<h2 id="表示弹簧边">表示弹簧边</h2>
<ul>
<li>构造一个<strong>三元组</strong>列表（Triple list）
<ul>
<li>（顶点1，顶点2，三角形序号）
<ul>
<li>顶点1 &lt; 顶点2</li>
</ul></li>
</ul></li>
<li>对这个三元组列表进行排序
<ul>
<li>排序规则：逐个比较三元组中的元素</li>
<li>排序之后重复的边位置会<strong>相邻</strong></li>
</ul></li>
<li>去除重复边，与此同时得到<strong>弯曲边</strong>
<ul>
<li>重复边：顶点1、2的索引都相同</li>
<li>弯曲边：重复边对应一条弯曲边
<ul>
<li>可以获取到相邻的两个三角形的信息</li>
<li>检查这两个三角形，获取到 Bending Edge</li>
</ul></li>
<li>可以直接保存弯曲边，也可以保存相邻三角形对</li>
</ul></li>
<li>算法过程如下</li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220122103225874.png" style="zoom:80%;"></p>
<ul>
<li>参考代码
<ul>
<li>lab2</li>
</ul></li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220122105219411.png" style="zoom:80%;"></p>
<h2 id="模拟系统显式积分">模拟系统（显式积分）</h2>
<ul>
<li>Explicit Integration</li>
<li>简单的粒子系统
<ul>
<li>对于每一个结点，计算他所受到的力
<ul>
<li>遍历每一根弹簧，把力叠加到结点上</li>
</ul></li>
<li>通过力计算加速度</li>
<li>更新速度</li>
<li>更新位置</li>
</ul></li>
<li>算法如下
<ul>
<li>先算<strong>所有的力</strong>，再更新</li>
</ul></li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220122110445660.png" style="zoom:80%;"></p>
<h3 id="显式积分的问题">显式积分的问题</h3>
<ul>
<li>numerical instability（数值上是不稳定的）</li>
<li>overshooting 问题
<ul>
<li>弹簧的弹性系数 <span class="math inline">\(k\)</span> 非常大 /
时间间隔 <span class="math inline">\(\Delta t\)</span> 非常小 <span class="math inline">\(\to\)</span> 力非常大</li>
</ul></li>
<li>例子如下
<ul>
<li>状态1弹簧力非常大 <span class="math inline">\(\to\)</span>
计算得到状态2</li>
<li>状态2弹簧力更大 <span class="math inline">\(\to\)</span>
计算得到状态3</li>
<li>状态3弹簧力更大 <span class="math inline">\(\to\cdots\)</span></li>
</ul></li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220122131340389.png" style="zoom:80%;"></p>
<ul>
<li>简单的解决方案：使用更小的时间间隔 <span class="math inline">\(\Delta t\)</span>
<ul>
<li>让整个数值模拟过程变<strong>慢</strong></li>
</ul></li>
<li>其他解决方案：隐式积分</li>
</ul>
<h2 id="模拟系统隐式积分">模拟系统（隐式积分）</h2>
<ul>
<li><span class="math inline">\(\mathbf{x}\)</span> 表示所有顶点（<span class="math inline">\(\mathbb{R}^{3N}\)</span>），<span class="math inline">\(\mathbf{M}\)</span>
表示每个顶点的质量（<strong>对角矩阵</strong>）（<span class="math inline">\(\mathbb{R}^{3N\times3N}\)</span>）</li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220122131953880.png" style="zoom:80%;"></p>
<ul>
<li>左边
<ul>
<li>当前时刻是 <span class="math inline">\([1]\)</span>，我们不知道
<span class="math inline">\(\mathbf{f}^{[1]}\)</span></li>
</ul></li>
<li>右边
<ul>
<li>消元 <span class="math inline">\(\mathbf{v}^{[1]}\)</span>，重写第二个式子</li>
<li>转化为如何求得 <span class="math inline">\(\mathbf{x}^{[1]}\)</span></li>
</ul></li>
<li>我们做如下假设，<span class="math inline">\(\mathbf{f}^{[1]}\)</span> 之和位置 <span class="math inline">\(\mathbf{x}^{[1]}\)</span>
相关（<strong>不一定是线性的</strong>），此时转化为如下的方程</li>
</ul>
<p><span class="math display">\[
\mathbf{x}^{[1]}=\mathbf{x}^{[0]}+\Delta t\mathbf{v}^{[0]}+\Delta
t^2\mathbf{M}^{-1}\mathbf{f}(\mathbf{x}^{[1]})
\]</span></p>
<ul>
<li>就是<strong>计算方法中学的隐式积分</strong></li>
<li>等价于如下的<strong>优化问题</strong>，<span class="math inline">\(E(\mathbf{x})\)</span> 是能量的表达式
<ul>
<li>保守力才能够表示为能量的形式，非保守力不能</li>
<li><span class="math inline">\(\Vert{\mathbf{x}}\Vert^2_{\mathbf{M}}=\mathbf{x}^{\mathbf{T}}\mathbf{M}\mathbf{x}\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
F(\mathbf{x})=\dfrac{1}{2\Delta
t^2}\Vert{\mathbf{x}-\mathbf{x}^{[0]}+\Delta
t\mathbf{v}^{[0]}}\Vert^{2}_{\mathbf{M}}+E(\mathbf{x})
\]</span></p>
<p><span class="math display">\[
\mathbf{x}^{[1]}=\arg\max{F(\mathbf{x})}
\]</span></p>
<ul>
<li><span class="math inline">\(\nabla F(\mathbf{x})=0\)</span>
就是上面的方程
<ul>
<li><span class="math inline">\(\mathbf{f}(\mathbf{x})=-\nabla
E(\mathbf{x})\)</span></li>
</ul></li>
<li><strong>这个方法不仅仅能够使用在弹簧系统中，也适用于其他系统</strong></li>
</ul>
<h3 id="牛顿法">牛顿法</h3>
<ul>
<li>Newton-Raphson Method</li>
<li>对于优化问题 <span class="math inline">\(\mathbf{x}^{[1]}=\arg\max{F(\mathbf{x})}\)</span>，要求
<span class="math inline">\(F(\mathbf{x})\)</span>
是利普希茨连续的（Lipschitz continuous）</li>
<li>一阶泰勒展开</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
0=F&#39;(x)
&amp;\approx F&#39;(x^{(k)})+F&#39;&#39;(x^{(k)})(x-x^{(k)})\\
&amp;=F&#39;(x^{(k)})+F&#39;&#39;(x^{(k)})\Delta x\\
\end{aligned}
\]</span></p>
<ul>
<li>牛顿迭代法</li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220122152127797.png" style="zoom:80%;"></p>
<ul>
<li>问题
<ul>
<li>可能会陷入<strong>局部最优</strong>
<ul>
<li>随机扰动</li>
</ul></li>
<li>找到的可能是极大值或者极小值
<ul>
<li>如果二阶导恒大于等于 0，没有极大值，存在唯一的极小值</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220122153034090.png" style="zoom:80%;"></p>
<h3 id="高维牛顿法">高维牛顿法</h3>
<p><span class="math display">\[
\begin{aligned}
\mathbf{0}=\nabla F(\mathbf{x})
&amp;\approx \nabla F(\mathbf{x}^{(k)})+\dfrac{\partial
F^{2}(\mathbf{x}^{(k)})}{\partial
\mathbf{x}^2}(\mathbf{x}-\mathbf{x}^{(k)})\\
&amp;= \nabla F(\mathbf{x}^{(k)})+\dfrac{\partial
F^{2}(\mathbf{x}^{(k)})}{\partial \mathbf{x}^2}\Delta\mathbf{x}\\
\end{aligned}
\]</span></p>
<ul>
<li>一阶导数是一个向量，二阶导数是一个矩阵</li>
<li>算法</li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220122154100978.png" style="zoom:80%;"></p>
<h3 id="牛顿法求解上述问题">牛顿法求解上述问题</h3>
<p><span class="math display">\[
F(\mathbf{x})=\dfrac{1}{2\Delta
t^2}\Vert{\mathbf{x}-\mathbf{x}^{[0]}+\Delta
t\mathbf{v}^{[0]}}\Vert^{2}_{\mathbf{M}}+E(\mathbf{x})
\]</span></p>
<ul>
<li>在方法中的参数如下</li>
</ul>
<p><span class="math display">\[
\nabla F(\mathbf{x}^{(k)})=\dfrac{1}{\Delta
t^2}\mathbf{M}\left({\mathbf{x}^{(k)}-\mathbf{x}^{[0]}+\Delta
t\mathbf{v}^{[0]}}\right)-\mathbf{f}(\mathbf{x}^{(k)})
\]</span></p>
<p><span class="math display">\[
\dfrac{\partial F^{2}(\mathbf{x}^{(k)})}{\partial \mathbf{x}^2}
=\dfrac{1}{\Delta t^2}\mathbf{M}+\mathbf{H}(\mathbf{x}^{(k)})
\]</span></p>
<ul>
<li>算法如下</li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220122160151863.png" style="zoom:80%;"></p>
<ul>
<li>黄色部分：求解线性系统 <span class="math inline">\(\mathbf{A}\Delta\mathbf{x}=\mathbf{b}\)</span>
<ul>
<li>之前比较老的方法就是求解一次线性方程组，得到近似结果</li>
<li>牛顿法是多次求解，直到满足容差</li>
</ul></li>
<li>还有一个问题，如何求解上面的 Hessian 矩阵 <span class="math inline">\(\mathbf{H}(\mathbf{x}^{(k)})\)</span> ?</li>
</ul>
<h4 id="spring-hessian">Spring Hessian</h4>
<ul>
<li><a href="/2021/11/28/CG/WHM-GAMES103/02-2/#例子弹簧">一根弹簧的
Hessain 矩阵</a></li>
<li>两个顶点 <span class="math inline">\(i,j\)</span>（每个顶点都是 3
维的）</li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220122162118751.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(\mathbf{x}_{ij}=\mathbf{x}_i-\mathbf{x}_j\)</span></li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220122162407803.png" style="zoom:80%;"></p>
<ul>
<li>绿色是 s.p.d.（半正定的）
<ul>
<li><span class="math inline">\(\mathbf{x}^{\mathbf{T}}\mathbf{V}\mathbf{x}\ge0\)</span></li>
<li>右边：<strong>柯西不等式</strong></li>
</ul></li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220122163021374.png" style="zoom:80%;"></p>
<ul>
<li>如果黄色部分大于等于 0（<strong>弹簧被拉伸</strong>），则 <span class="math inline">\(\mathbf{H}_e\)</span> 是半正定的，因此 <span class="math inline">\(\mathbf{H}(\mathbf{x})\)</span> 也是半正定的
<ul>
<li>拉伸的时候，整个系统会更加稳定</li>
</ul></li>
<li>黄色部分小于 0（<strong>弹簧被压缩</strong>），可能是不正定的</li>
<li>整个参数</li>
</ul>
<p><span class="math display">\[
\dfrac{\partial F^{2}(\mathbf{x}^{(k)})}{\partial \mathbf{x}^2}
=\dfrac{1}{\Delta t^2}\mathbf{M}+\mathbf{H}(\mathbf{x}^{(k)})
\]</span></p>
<ul>
<li>如果 Spring Hessian 是半正定的，那么函数存在唯一解，是极小值
<ul>
<li><span class="math inline">\(\Delta t\)</span> 越小，越正定</li>
</ul></li>
</ul>
<h4 id="压缩弹簧多解的例子">压缩弹簧多解的例子</h4>
<ul>
<li>弹簧受挤压，可能会有多种状态</li>
<li>2D：向上或者向下</li>
</ul>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220122163801125.png" style="zoom:80%;"></p>
<ul>
<li>1D 没有这个问题，<span class="math inline">\(k&gt;0\)</span></li>
<li>2D、3D 会有这个问题</li>
</ul>
<h4 id="正定性">正定性</h4>
<ul>
<li>正定与否可能会影响某些算法的稳定性</li>
<li>某些算法可能只适用于正定矩阵</li>
<li>保证正定：在检测到弹簧是压缩状态的时候，<strong>直接舍去后面一项</strong>
<ul>
<li>比较粗暴的方法（近似）</li>
</ul></li>
<li>其他方法
<ul>
<li>Choi and Ko. 2002. Stable But Responive Cloth. TOG (SIGGRAPH)</li>
</ul></li>
</ul>
<h3 id="解线性方程组">解线性方程组</h3>
<ul>
<li><span class="math inline">\(\mathbf{A}\Delta\mathbf{x}=\mathbf{b}\)</span></li>
</ul>
<h4 id="直接求解">直接求解</h4>
<ul>
<li>方法
<ul>
<li>LU 分解、LDLT 分解、Cholesky 分解</li>
</ul></li>
<li>代价高，得到精确解</li>
<li>对矩阵 <span class="math inline">\(\mathbf{A}\)</span> 限制少</li>
<li>适合 CPU 计算</li>
</ul>
<h4 id="迭代求解">迭代求解</h4>
<ul>
<li>如果需要得到精确解的话代价大，但是可以根据容差控制</li>
<li>要让方法收敛的话，对矩阵 <span class="math inline">\(\mathbf{A}\)</span>
有比较严格的限制（例如<strong>正定</strong>）</li>
<li>CPU、GPU 都行</li>
<li>实现比较容易</li>
<li>有很多加速算法</li>
</ul>
<h4 id="雅各比方法">雅各比方法</h4>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220122164736088.png" style="zoom:80%;"></p>
<ul>
<li>传统的雅各比方法：<span class="math inline">\(\alpha=1\)</span>
<ul>
<li>如果矩阵式<strong>对角占优</strong>的（diagonal
dominant），那么能够保证收敛到唯一解</li>
</ul></li>
<li>控制 <span class="math inline">\(\alpha\)</span>
的值，让更多情况下都尽可能收敛到解</li>
</ul>
<h4 id="切比雪夫加速的雅各比方法">切比雪夫加速的雅各比方法</h4>
<p><img src="/2022/01/17/CG/WHM-GAMES103/05/image-20220122202515318.png" style="zoom:80%;"></p>
<h4 id="课后阅读">课后阅读</h4>
<ul>
<li>Baraff and Witkin. 1998. Large Step in Cloth Simulation. SIGGRAPH.
<ul>
<li>最早使用隐式积分左布料模拟</li>
<li>将非线性方程线性化，等价于做了一次牛顿迭代</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.03.rigid body dynamic</title>
    <url>/2021/12/02/CG/WHM-GAMES103/03/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="rigid-body-dynamics">rigid body dynamics</h1>
<ul>
<li>刚体动力学</li>
</ul>
<h2 id="刚体">刚体</h2>
<ul>
<li>没有<strong>形变</strong></li>
<li>现实生活中形变比较小的物体
<ul>
<li>石头、硬币、积木</li>
</ul></li>
<li>游戏
<ul>
<li>愤怒的小鸟（2D）</li>
<li>弹珠</li>
</ul></li>
<li>Unity
<ul>
<li>Rigidbody</li>
</ul></li>
</ul>
<h2 id="刚体模拟">刚体模拟</h2>
<ul>
<li>模拟：根据时间更新物体的状态量</li>
</ul>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211202231110626.png" style="zoom:80%;"></p>
<ul>
<li>怎么描述刚体的状态量</li>
<li>刚体只允许两种运动：<strong>平移</strong>、<strong>旋转</strong></li>
<li>变换</li>
<li>在局部坐标系中旋转，平移到世界坐标系中
<ul>
<li>局部坐标系
<ul>
<li>local space</li>
<li>reference</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211202231344477.png" style="zoom:80%;"></p>
<h3 id="平移变换">平移变换</h3>
<ul>
<li>translation motion</li>
<li>更新位置 <span class="math inline">\(\mathbf{x}\)</span>、速度 <span class="math inline">\(\mathbf{v}=\dot{\mathbf{x}}\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\mathbf{v}(t^{[1]})&amp;=\mathbf{v}(t^{[0]})+M^{-1}\int_{t^{[0]}}^{t^{[1]}}\mathbf{f}(\mathbf{x}(t),\mathbf{v}(t),t)dt\\
\mathbf{x}(t^{[1]})&amp;=\mathbf{x}(t^{[0]})+M^{-1}\int_{t^{[0]}}^{t^{[1]}}\mathbf{v}(t)dt\\
\end{aligned}
\]</span></p>
<ul>
<li>求解常微分方程的初值问题</li>
</ul>
<h4 id="一维示例">一维示例</h4>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211202232921927.png" style="zoom:80%;"></p>
<h5 id="显式欧拉法">显式欧拉法</h5>
<ul>
<li>Explicit Euler</li>
<li>一阶估计：长方形近似</li>
<li>使用 <span class="math inline">\(t^{[0]}\)</span> 时刻速度估计</li>
</ul>
<p><span class="math display">\[
\int_{t^{[0]}}^{t^{[1]}}\mathbf{v}(t)dt\approx\Delta
t\mathbf{v}(t^{[0]})
\]</span></p>
<ul>
<li>根据泰勒展开，发现这是一阶精确的
<ul>
<li>1st-order accurate</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\int_{t^{[0]}}^{t^{[1]}}\mathbf{v}(t)dt
&amp;=\Delta t\mathbf{v}(t^{[0]})+\dfrac{\Delta
t^2}{2}\mathbf{v}&#39;(t^{[0]})+\cdots\\
&amp;=\Delta t\mathbf{v}(t^{[0]})+O(\Delta t^2)\\
\end{aligned}
\]</span></p>
<h5 id="隐式欧拉法">隐式欧拉法</h5>
<ul>
<li>Implicit Euler</li>
<li>使用 <span class="math inline">\(t^{[1]}\)</span> 时刻速度估计</li>
</ul>
<p><span class="math display">\[
\int_{t^{[0]}}^{t^{[1]}}\mathbf{v}(t)dt\approx\Delta
t\mathbf{v}(t^{[1]})
\]</span></p>
<ul>
<li>也是一阶精确的</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\int_{t^{[0]}}^{t^{[1]}}\mathbf{v}(t)dt
&amp;=\Delta t\mathbf{v}(t^{[1]})-\dfrac{\Delta
t^2}{2}\mathbf{v}&#39;(t^{[1]})+\cdots\\
&amp;=\Delta t\mathbf{v}(t^{[1]})+O(\Delta t^2)\\
\end{aligned}
\]</span></p>
<h5 id="中点法">中点法</h5>
<ul>
<li>Mid-point</li>
<li>二阶精确的</li>
</ul>
<p><span class="math display">\[
\int_{t^{[0]}}^{t^{[1]}}\mathbf{v}(t)dt\approx\Delta
t\mathbf{v}(t^{[0.5]})
\]</span></p>
<p><span class="math display">\[
\mathbf{v}(t^{[0.5]})=\dfrac{\mathbf{v}(t^{[0]})+\mathbf{v}(t^{[1]})}{2}
\]</span></p>
<ul>
<li>都在 <span class="math inline">\(t^{[0.5]}\)</span>
点上进行泰勒展开</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\int_{t^{[0]}}^{t^{[1]}}\mathbf{v}(t)dt
=&amp;\int_{t^{[0]}}^{t^{[0.5]}}\mathbf{v}(t)dt+\int_{t^{[0.5]}}^{t^{[1]}}\mathbf{v}(t)dt\\
=&amp;\quad\dfrac{1}{2}\Delta t\mathbf{v}(t^{[0.5]})-\dfrac{\Delta
t^2}{4}\mathbf{v}&#39;(t^{[0.5]})+O(\Delta t^3)\\
&amp;+\dfrac{1}{2}\Delta t\mathbf{v}(t^{[0.5]})+\dfrac{\Delta
t^2}{4}\mathbf{v}&#39;(t^{[0.5]})+O(\Delta t^3)\\
=&amp;\Delta t\mathbf{v}(t^{[0.5]}))+O(\Delta t^3)\\
\end{aligned}
\]</span></p>
<h4 id="平移变换-1">平移变换</h4>
<ul>
<li>两个变量</li>
<li><span class="math inline">\(\mathbf{v}\)</span>
使用显式欧拉法，<span class="math inline">\(\mathbf{x}\)</span>
使用隐式欧拉法</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\mathbf{v}^{[1]}&amp;=\mathbf{v}^{[0]}+\Delta tM^{-1}\mathbf{f}^{[0]}\\
\mathbf{x}^{[1]}&amp;=\mathbf{x}^{[0]}+\Delta t\mathbf{v}^{[1]}\\
\end{aligned}
\]</span></p>
<ul>
<li>也被称为是<strong>半欧拉法</strong>
<ul>
<li>semi-implicit</li>
</ul></li>
<li>本质上是<strong>中点法</strong>，错开 <span class="math inline">\(\mathbf{v},\mathbf{x}\)</span>
<ul>
<li>称为是 leapfrog method</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\mathbf{v}^{[0.5]}&amp;=\mathbf{v}^{[-0.5]}+\Delta
tM^{-1}\mathbf{f}^{[0]}\\
\mathbf{x}^{[1]}&amp;=\mathbf{x}^{[0]}+\Delta t\mathbf{v}^{[0.5]}\\
\end{aligned}
\]</span></p>
<ul>
<li>leapfrog
<ul>
<li><span class="math inline">\(\mathbf{v},\mathbf{x}\)</span>
间隔着更新</li>
</ul></li>
</ul>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204113555272.png" style="zoom:80%;"></p>
<h4 id="力">力</h4>
<ul>
<li>重力
<ul>
<li>gravity force</li>
<li><span class="math inline">\(\mathbf{f}^{[0]}_{\mathrm{gravity}}=M\mathbf{g}\)</span></li>
</ul></li>
<li>摩擦力（阻力）
<ul>
<li>drag force</li>
<li><span class="math inline">\(\mathbf{f}^{[0]}_{\mathrm{drag}}=-\sigma\mathbf{v}^{[0]}\)</span></li>
<li>简单的近似：<span class="math inline">\(\mathbf{v}^{[1]}=\alpha\mathbf{v}^{[0]}\)</span>
<ul>
<li>直接简单的衰减速度，不精确，但是挺有用的</li>
</ul></li>
</ul></li>
</ul>
<h4 id="刚体模拟-1">刚体模拟</h4>
<ul>
<li>流程
<ul>
<li>根据当前时刻每一个质点的位置、速度求出每一个质点的力</li>
<li>求出合力</li>
<li>对整体的速度做更新</li>
<li>对整体的位置做更新</li>
</ul></li>
</ul>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204122135998.png" style="zoom:80%;"></p>
<ul>
<li>Unity 本身有位置的定义，但是没有定义速度，需要自己定义</li>
</ul>
<h3 id="旋转变换">旋转变换</h3>
<ul>
<li>rotational motion</li>
</ul>
<h4 id="表示方式">表示方式</h4>
<ul>
<li>矩阵、欧拉角、四元数</li>
</ul>
<h4 id="x3-矩阵">3x3 矩阵</h4>
<ul>
<li>存在冗余性，旋转自由度是 3，而不是 9</li>
<li>不直观</li>
<li>很难计算时间微分</li>
</ul>
<h4 id="欧拉角">欧拉角</h4>
<ul>
<li>Euler Angle</li>
<li>直观</li>
<li>由 3 个轴的旋转角来定义旋转
<ul>
<li>Unity 界面上有这样的定义</li>
</ul></li>
<li>对时间求微分也比较困难</li>
<li>万向锁：gimbal lock
<ul>
<li>在某些情况下，自由度减少</li>
<li>例如右图，有两个旋转轴重合了</li>
</ul></li>
</ul>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204122943683.png" style="zoom:80%;"></p>
<h4 id="四元数">四元数</h4>
<ul>
<li><a href="/2021/01/31/CG/LS/05-2/">参考</a></li>
<li>Quaternion</li>
<li>一个复数可以描述二维空间中的点
<ul>
<li>可以定义加减乘除</li>
</ul></li>
<li>三维空间的点？
<ul>
<li>3d 向量不能定义除法</li>
<li>使用类似复数的方式：<strong>四元数</strong></li>
</ul></li>
</ul>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204123356799.png" style="zoom:80%;"></p>
<h5 id="四元数计算法则">四元数计算法则</h5>
<ul>
<li>四元数 <span class="math inline">\(\mathbf{q}=[s\;\mathbf{v}]\)</span></li>
<li>实数，向量</li>
</ul>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204123647172.png" style="zoom:80%;"></p>
<ul>
<li>Unity 里面有四元数，但是只提供了乘法的计算
<ul>
<li><span class="math inline">\([w,x,y,z]\)</span></li>
</ul></li>
</ul>
<h5 id="使用四元数表示旋转">使用四元数表示旋转</h5>
<ul>
<li>绕着轴 <span class="math inline">\(\mathbf{v}\)</span> 旋转 <span class="math inline">\(\theta\)</span> 角度
<ul>
<li>模长为一限制为单位四元数</li>
</ul></li>
</ul>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204124439044.png" style="zoom:80%;"></p>
<ul>
<li>很直观，Unity 默认的表达方式</li>
<li>转化为矩阵</li>
</ul>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204124948136.png" style="zoom:80%;"></p>
<h5 id="unity">Unity</h5>
<ul>
<li>可以通过设置其中的某一个形式的值，从而获取到另一种表达方式的值</li>
</ul>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204125024353.png" style="zoom:80%;"></p>
<h4 id="角速度">角速度</h4>
<ul>
<li>旋转角对于时间求微分</li>
<li>使用<strong>四元数</strong>来表示旋转角（取向 / orientation）</li>
<li>使用 <strong>3d 向量</strong>描述角速度</li>
</ul>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204125502418.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(\omega\)</span>
的方向表示旋转方向，<span class="math inline">\(\omega\)</span>
的大小表示角速度的大小</li>
</ul>
<h4 id="力矩与转动惯量">力矩与转动惯量</h4>
<ul>
<li><strong>力矩</strong>：torque
<ul>
<li>和<strong>力</strong>对应，能够让物体产生旋转的趋势</li>
</ul></li>
<li><strong>转动惯量</strong>：inertia
<ul>
<li>和<strong>质量</strong>对应</li>
</ul></li>
</ul>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204134948056.png" style="zoom:80%;"></p>
<h5 id="更新流程">更新流程</h5>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204130150385.png" style="zoom:80%;"></p>
<h5 id="力矩">力矩</h5>
<ul>
<li>力矩 <span class="math inline">\(\tau\)</span></li>
<li><span class="math inline">\(\mathbf{r}_i\)</span>：上一时刻的位置</li>
<li><span class="math inline">\(\mathbf{R}\)</span>：旋转矩阵</li>
<li><span class="math inline">\(\mathbf{f}_i\)</span>：力</li>
<li><span class="math inline">\(\tau=(\mathbf{Rr}_i)\times
\mathbf{f}_i\)</span>
<ul>
<li>和 <span class="math inline">\(\mathbf{Rr}_i\)</span>
方向一致的时候，不会引发旋转</li>
</ul></li>
</ul>
<h5 id="转动惯量">转动惯量</h5>
<ul>
<li>转动惯量 <span class="math inline">\(\mathbf{I}\)</span></li>
<li>在旋转中等效于质量</li>
<li>是一个 <strong>3x3 矩阵</strong></li>
<li>为什么是一个矩阵，而不是一个实数？
<ul>
<li>质量抵抗移动，转动惯量抵抗旋转</li>
<li>这种抵抗和旋转轴相关</li>
<li>如下图
<ul>
<li>左边的抵抗更强</li>
<li>右边质量都集中在轴上</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204152206215.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(\mathbf{I}_{\mathrm{ref}}\)</span>
是固定的，参照状态中的 <span class="math inline">\(\mathbf{r}_i\)</span>
也是固定的，<span class="math inline">\(\mathbf{Rr}_i\)</span>
随着时间变化而变化</li>
<li>在实际运动中，<span class="math inline">\(\mathbf{r}_i\)</span>
在变换</li>
<li>简化公式
<ul>
<li>只需要计算一次 <span class="math inline">\(\mathbf{I}_{\mathrm{ref}}\)</span>，通过矩阵 <span class="math inline">\(\mathbf{R}\)</span> 快速计算 <span class="math inline">\(\mathbf{I}\)</span></li>
<li>不需要每次对<strong>所有点</strong>求一次</li>
<li>注意 <span class="math inline">\(\mathbf{R}\)</span>
是正交矩阵，<span class="math inline">\(\mathbf{r}_i^{\mathbf{T}}\mathbf{r}_i\)</span>
是实数，<span class="math inline">\(\mathbf{1}\)</span> 是 3x3
单位矩阵</li>
</ul></li>
</ul>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204152745851.png" style="zoom:80%;"></p>
<h3 id="刚体模拟流程">刚体模拟流程</h3>
<h4 id="流程">流程</h4>
<ul>
<li>模拟平移变换、旋转变换</li>
<li>注意 <span class="math inline">\(\mathbf{q}\)</span> 需要归一化</li>
</ul>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204131353003.png" style="zoom:80%;"></p>
<h4 id="更加细致的流程">更加细致的流程</h4>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204131526707.png" style="zoom:80%;"></p>
<ul>
<li>最后需要对 <span class="math inline">\(\mathbf{q}\)</span>
归一化</li>
</ul>
<h4 id="证明">证明</h4>
<ul>
<li><span class="math inline">\(\dot{\mathbf{q}}=\dfrac{1}{2}[0,\mathrm{\omega}]\mathbf{q}\)</span>
的证明
<ul>
<li><a href="https://graphics.pixar.com/pbm2001/pdf/notesg.pdf">参考</a></li>
<li>Appendix B</li>
</ul></li>
<li><span class="math inline">\(\mathbf{q}(t)\)</span> 表示如下</li>
</ul>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204154434119.png" style="zoom:80%;"></p>
<ul>
<li>求微分即可，计算 <span class="math inline">\(t=t_0\)</span>
时的值即可</li>
</ul>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204154618970.png" style="zoom:80%;"></p>
<p><img src="/2021/12/02/CG/WHM-GAMES103/03/image-20211204154646684.png" style="zoom:80%;"></p>
<ul>
<li>代入即得到上面的结果</li>
</ul>
<h3 id="实现建议">实现建议</h3>
<ul>
<li>平移、旋转分开调试</li>
<li>调试旋转的时候，先把 <span class="math inline">\(\omega\)</span>
设置为常数，看能否旋转</li>
<li><strong>重力不会造成力矩</strong>
<ul>
<li>自由落体不会自发旋转</li>
</ul></li>
<li><a href="https://graphics.pixar.com/pbm2001/">参考教程</a>
<ul>
<li>Rigid Body Dynamics</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.06.Constrained Approaches(PBD, PD and others)(2)</title>
    <url>/2022/02/24/CG/WHM-GAMES103/06-1/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="约束方法">约束方法</h1>
<ul>
<li>在现实生活中，布料对于拉伸的抵抗比较强，只能有少量拉伸</li>
<li>简单的调大弹性系数 <span class="math inline">\(k\)</span>
会带来如下问题，导致<strong>计算量变得很大</strong>
<ul>
<li>显示积分不稳定</li>
<li>隐式积分中的线性系统会变成病态的（ill-conditioned）</li>
</ul></li>
<li>约束方法就是为了解决拉伸的问题而被提出的</li>
</ul>
<h2 id="一根弹簧">一根弹簧</h2>
<ul>
<li>写出约束如下</li>
</ul>
<p><img src="/2022/02/24/CG/WHM-GAMES103/06-1/image-20220223224102833.png" style="zoom:80%;"></p>
<ul>
<li><strong>投影函数</strong>需要让边趋向于原长（如下图），如何构造？</li>
</ul>
<p><img src="/2022/02/24/CG/WHM-GAMES103/06-1/image-20220223224219294.png" style="zoom:80%;"></p>
<ul>
<li>投影问题描述如下
<ul>
<li>两个点是 6 维的，看成 6 维空间中的一个点，我们需要将这个点移动到 6
维空间中的可行区域中，而且需要让移动距离<strong>尽可能小</strong></li>
</ul></li>
<li>图示</li>
</ul>
<p><img src="/2022/02/24/CG/WHM-GAMES103/06-1/image-20220223224657159.png" style="zoom:80%;"></p>
<ul>
<li>数学描述如下</li>
</ul>
<p><img src="/2022/02/24/CG/WHM-GAMES103/06-1/image-20220223224736350.png" style="zoom:80%;"></p>
<ul>
<li>投影函数，计算结果如下
<ul>
<li>质心不变</li>
<li>点移动距离和质量反相关</li>
</ul></li>
</ul>
<p><img src="/2022/02/24/CG/WHM-GAMES103/06-1/image-20220223230117179.png" style="zoom:80%;"></p>
<ul>
<li>代入验证，新位置满足约束条件</li>
<li>质量设置
<ul>
<li>为了方便，一般设置为相同</li>
<li>固定点，质量设置为无穷大
<ul>
<li>固定点直接不更新（作业）</li>
</ul></li>
</ul></li>
</ul>
<h2 id="多根弹簧">多根弹簧</h2>
<h3 id="gauss-seidel-approach">Gauss-Seidel Approach</h3>
<ul>
<li>高斯塞达尔方法（A Gauss-Seidel Approach）</li>
<li>分别处理每根弹簧
<ul>
<li>因为处理完一根弹簧之后，会影响其他弹簧的位置，因此是一个反复迭代更新的过程</li>
</ul></li>
</ul>
<p><img src="/2022/02/24/CG/WHM-GAMES103/06-1/image-20220223230608615.png" style="zoom:80%;"></p>
<ul>
<li>算法如下</li>
</ul>
<p><img src="/2022/02/24/CG/WHM-GAMES103/06-1/image-20220223230800043.png" style="zoom:80%;"></p>
<ul>
<li>无法保证所有边都满足限制，但是迭代次数越多能够尽可能让更多边满足</li>
<li>循环的时候，边的顺序会影响计算结果
<ul>
<li>可能会造成偏向性（artifact）</li>
<li>可能会影响收敛速度</li>
</ul></li>
</ul>
<h3 id="jacobi-approach">Jacobi Approach</h3>
<ul>
<li>两个目的
<ul>
<li>减少由于边的顺序带来的 artifact</li>
<li>尽可能可以并行（更容易并行）</li>
</ul></li>
<li>思路：每条边计算得到的偏移量不直接更新，而是记录下来，最后计算完了再加权更新</li>
<li>算法如下</li>
</ul>
<p><img src="/2022/02/24/CG/WHM-GAMES103/06-1/image-20220223232112020.png" style="zoom:80%;"></p>
<ul>
<li>问题：收敛率更低</li>
<li>同样的，迭代次数越多效果越好</li>
</ul>
<h2 id="pbd">PBD</h2>
<ul>
<li>Position Based Dynamics</li>
<li>基于上面的投影函数提出的算法
<ul>
<li>自由模拟 + 约束修正
<ul>
<li>和刚体的 shape matching 思路一致</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/02/24/CG/WHM-GAMES103/06-1/image-20220223232445662.png" style="zoom:80%;"></p>
<h3 id="特点">特点</h3>
<ul>
<li>没有能量、力的概念
<ul>
<li>弹性系数是由一些非物理因素控制的
<ul>
<li>迭代次数：迭代次数越多，约束满足的越好，显得弹性系数很大（硬）</li>
<li>网格分辨率：顶点数量很少，则能够很快收敛，显得弹性系数很大（硬）</li>
</ul></li>
</ul></li>
<li>速度更新很重要
<ul>
<li>为什么是 <span class="math inline">\(v+\)</span>，因为需要考虑原始速度</li>
</ul></li>
<li>这样的方法还可以适用于其他约束
<ul>
<li>形状约束、体积约束、碰撞约束</li>
</ul></li>
</ul>
<h3 id="评价">评价</h3>
<h4 id="pros">Pros</h4>
<ul>
<li>很容易并行，适合于 GPU
<ul>
<li>PhysX</li>
</ul></li>
<li>容易实现</li>
<li>低分辨率下运行很快
<ul>
<li>1000 点以内可以满足实时性</li>
</ul></li>
<li>通用性很强</li>
</ul>
<h4 id="cons">Cons</h4>
<ul>
<li>没有什么物理含义，不是物理准确的
<ul>
<li>弹性手网格分辨率、迭代次数影响，难控制</li>
</ul></li>
<li>高分辨率下运行慢
<ul>
<li>层次结构
<ul>
<li>Hierarchical approaches (can cause oscillation and other issues…)
<ul>
<li>Muller. 2008. <em>Hierarchical Position Based Dynamics.</em>
VRIPHYS.</li>
</ul></li>
</ul></li>
<li>加速方式（Chebyshev）</li>
</ul></li>
</ul>
<h4 id="评价-1">评价</h4>
<ul>
<li>适合游戏开发中低分辨率的网格衣服的模拟</li>
<li><strong>低精度实时模拟</strong></li>
</ul>
<h2 id="strain-limiting">Strain Limiting</h2>
<ul>
<li>整个思想的提出比 PBD 要早</li>
<li>但是这个方法可以认为是 PBD 的改进版</li>
<li>和 PBD 类似，但是 Strain Limiting 只是使用 projection function
进行纠正</li>
</ul>
<p><img src="/2022/02/24/CG/WHM-GAMES103/06-1/image-20220225143855278.png" style="zoom:80%;"></p>
<h3 id="弹簧">弹簧</h3>
<ul>
<li>Spring Strain Limit
<ul>
<li>strain：描述形变的量 <span class="math inline">\(\sigma-1\)</span></li>
</ul></li>
<li>定义拉伸比例（stretching ratio）
<ul>
<li>长度除以原长</li>
</ul></li>
</ul>
<p><img src="/2022/02/24/CG/WHM-GAMES103/06-1/image-20220225144058559.png" style="zoom:80%;"></p>
<ul>
<li>可以认为是约束放宽了的 PBD</li>
<li>投影函数如下</li>
</ul>
<p><img src="/2022/02/24/CG/WHM-GAMES103/06-1/image-20220225144418911.png" style="zoom:80%;"></p>
<ul>
<li>Why Strain Limiting？
<ul>
<li>模拟很多面料在拉伸到一定程度之后变得很 stiff 的情况</li>
<li>让数值模拟的过程更稳定</li>
</ul></li>
</ul>
<h3 id="三角形面积">三角形面积</h3>
<ul>
<li>Triangle Area Limit</li>
<li>思路和上面差不多
<ul>
<li>质心不变，进行缩放</li>
</ul></li>
<li>约束条件</li>
</ul>
<p><img src="/2022/02/24/CG/WHM-GAMES103/06-1/image-20220225145140917.png" style="zoom:80%;"></p>
<ul>
<li>目标函数</li>
</ul>
<p><img src="/2022/02/24/CG/WHM-GAMES103/06-1/image-20220225145239226.png" style="zoom:80%;"></p>
<ul>
<li>质心不变
<ul>
<li>数学上：三个顶点的运动量最小</li>
<li>物理上：没有新的动量，不会因为约束而产生奇怪的运动</li>
</ul></li>
</ul>
<h3 id="评价-2">评价</h3>
<ul>
<li>可以保证在模拟的过程中不发生大形变
<ul>
<li>更稳定</li>
<li>更少的 artifact</li>
</ul></li>
<li>可以模拟布料在形变比较小的时候可以被拉伸，拉伸到一定程度之后变得
stiff 的效果
<ul>
<li>另外一种方式：形变比较小的时候使用上面的模型，比较大的时候使用
strain limiting</li>
</ul></li>
</ul>
<p><img src="/2022/02/24/CG/WHM-GAMES103/06-1/image-20220225225157275.png" style="zoom:80%;"></p>
<ul>
<li>能够帮助解决 locking issue
<ul>
<li>第一个阶段使用比较小的弹性系数进行模拟（减轻 locking issue）</li>
</ul></li>
</ul>
<h3 id="论文">论文</h3>
<ul>
<li>Provot. 1995. <em>Deformation Constraints in a Mass-Spring Model to
Describe Rigid Cloth Behavior.</em> Graphics Interface.(optional)</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.02.Math Background(3)</title>
    <url>/2021/11/28/CG/WHM-GAMES103/02-2/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="math-background">Math Background</h1>
<h2 id="tensor-calculus">Tensor Calculus</h2>
<ul>
<li>张量微积分</li>
</ul>
<h3 id="一阶导">一阶导</h3>
<h4 id="实数对向量求导">实数对向量求导</h4>
<ul>
<li><span class="math inline">\(f(\mathbf{x})\in\mathbb{R}\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
df&amp;=\dfrac{\partial{f}}{\partial{x}}dx+\dfrac{\partial{f}}{\partial{y}}dy+\dfrac{\partial{f}}{\partial{z}}dz\\
&amp;=
\begin{bmatrix}
\dfrac{\partial{f}}{\partial{x}}&amp;
\dfrac{\partial{f}}{\partial{y}}&amp;
\dfrac{\partial{f}}{\partial{z}}
\end{bmatrix}
\begin{bmatrix}
dx\\dy\\dz\\
\end{bmatrix}
\end{aligned}
\]</span></p>
<ul>
<li>记号</li>
</ul>
<p><span class="math display">\[
\dfrac{\partial{f}}{\partial{\mathbf{x}}}=
\begin{bmatrix}
\dfrac{\partial{f}}{\partial{x}}&amp;
\dfrac{\partial{f}}{\partial{y}}&amp;
\dfrac{\partial{f}}{\partial{z}}
\end{bmatrix}
\]</span></p>
<ul>
<li>梯度（gradient）</li>
</ul>
<p><span class="math display">\[
\nabla{f(\mathbf{x})}=
\begin{bmatrix}
\dfrac{\partial{f}}{\partial{x}}\\
\dfrac{\partial{f}}{\partial{y}}\\
\dfrac{\partial{f}}{\partial{z}}
\end{bmatrix}
\]</span></p>
<ul>
<li>梯度的方向：函数值上升最快的方向</li>
</ul>
<p><img src="/2021/11/28/CG/WHM-GAMES103/02-2/image-20211128211102415.png" style="zoom:80%;"></p>
<h4 id="向量对向量求导">向量对向量求导</h4>
<p><span class="math display">\[
\mathbf{f}(\mathbf{x})=
\begin{bmatrix}
f(\mathbf{x})\\
g(\mathbf{x})\\
h(\mathbf{x})\\
\end{bmatrix}
\in\mathbb{R}^3
\]</span></p>
<ul>
<li>雅可比矩阵（Jacobian）</li>
</ul>
<p><span class="math display">\[
\mathbf{J}(x)
=\dfrac{\partial{\mathbf{f}}}{\partial{\mathbf{x}}}
=\begin{bmatrix}
\dfrac{\partial{f}}{\partial{x}}&amp;
\dfrac{\partial{f}}{\partial{y}}&amp;
\dfrac{\partial{f}}{\partial{z}}\\
\dfrac{\partial{g}}{\partial{x}}&amp;
\dfrac{\partial{g}}{\partial{y}}&amp;
\dfrac{\partial{g}}{\partial{z}}\\
\dfrac{\partial{h}}{\partial{x}}&amp;
\dfrac{\partial{h}}{\partial{y}}&amp;
\dfrac{\partial{h}}{\partial{z}}
\end{bmatrix}
\]</span></p>
<ul>
<li>散度（Divergence）：雅可比矩阵对角和</li>
</ul>
<p><span class="math display">\[
\nabla\cdot{\mathbf{f}}=\dfrac{\partial{f}}{\partial{x}}+\dfrac{\partial{g}}{\partial{y}}+\dfrac{\partial{h}}{\partial{z}}
\]</span></p>
<ul>
<li>旋度（Curl）</li>
</ul>
<p><span class="math display">\[
\nabla\times\mathbf{f}=\begin{bmatrix}
\dfrac{\partial{h}}{\partial{y}}-\dfrac{\partial{g}}{\partial{z}}\\
\dfrac{\partial{f}}{\partial{z}}-\dfrac{\partial{h}}{\partial{x}}\\
\dfrac{\partial{g}}{\partial{x}}-\dfrac{\partial{f}}{\partial{y}}\\
\end{bmatrix}
\]</span></p>
<ul>
<li>把 <span class="math inline">\(\nabla\)</span> 当作算子</li>
</ul>
<p><span class="math display">\[
\nabla=\begin{bmatrix}
\dfrac{\partial}{\partial{x}}&amp;\dfrac{\partial}{\partial{y}}&amp;\dfrac{\partial}{\partial{z}}
\end{bmatrix}
\]</span></p>
<h3 id="二阶导">二阶导</h3>
<h4 id="实数对向量求导-1">实数对向量求导</h4>
<ul>
<li>海森矩阵（Hessian）
<ul>
<li>求导顺序不影响结果</li>
</ul></li>
</ul>
<p><span class="math display">\[
\mathbf{H}=\mathbf{J}(\nabla f(\mathbf{x}))=\begin{bmatrix}
\dfrac{\partial^2{f}}{\partial^2{x}}
&amp;\dfrac{\partial^2{f}}{\partial{x}\partial{y}}
&amp;\dfrac{\partial^2{f}}{\partial{x}\partial{z}}\\
\dfrac{\partial^2{f}}{\partial{x}\partial{y}}
&amp;\dfrac{\partial^2{f}}{\partial^2{y}}
&amp;\dfrac{\partial^2{f}}{\partial{y}\partial{z}}\\
\dfrac{\partial^2{f}}{\partial{x}\partial{z}}
&amp;\dfrac{\partial^2{f}}{\partial{y}\partial{z}}
&amp;\dfrac{\partial^2{f}}{\partial^2{z}}\\
\end{bmatrix}
\]</span></p>
<ul>
<li>拉普拉斯（Laplacian）
<ul>
<li>海森矩阵对角线的和</li>
</ul></li>
</ul>
<p><span class="math display">\[
\nabla\cdot\nabla f(\mathbf{x})=\nabla^2f(\mathbf{x})=\Delta
f(\mathbf{x})
=\dfrac{\partial^2{f}}{\partial^2{x}}
+\dfrac{\partial^2{f}}{\partial^2{y}}
+\dfrac{\partial^2{f}}{\partial^2{z}}
\]</span></p>
<h3 id="泰勒展开">泰勒展开</h3>
<ul>
<li><span class="math inline">\(f(x)\in\mathbb{R}\)</span></li>
</ul>
<p><span class="math display">\[
f(x)=f(x_0)+\dfrac{\partial{f(x_0)}}{\partial{x}}(x-x_0)+\dfrac{1}{2}\dfrac{\partial^2{f(x_0)}}{\partial^2{x}}(x-x_0)^2+\cdots
\]</span></p>
<ul>
<li><span class="math inline">\(f(\mathbf{x})\in\mathbb{R}\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
f(\mathbf{x})&amp;=f(\mathbf{x}_0)+\dfrac{\partial{f(\mathbf{x}_0)}}{\partial{\mathbf{x}}}(\mathbf{x}-\mathbf{x}_0)+\dfrac{1}{2}\dfrac{\partial^2{f(\mathbf{x}_0)}}{\partial^2{\mathbf{x}}}+\cdots\\
&amp;=f(\mathbf{x}_0)
+\nabla f(\mathbf{x}_0)(\mathbf{x}-\mathbf{x}_0)
+\dfrac{1}{2}(\mathbf{x}-\mathbf{x}_0)^{\mathbf{T}}\mathbf{H}(\mathbf{x}-\mathbf{x}_0)+\cdots\\
\end{aligned}
\]</span></p>
<h3 id="计算向量范数的偏导">计算向量范数的偏导</h3>
<p><span class="math display">\[
\begin{aligned}
\dfrac{\partial{\Vert{\mathbf{x}}\Vert}}{\partial{\mathbf{x}}}
&amp;=\dfrac{\partial({\mathbf{x}^{\mathbf{T}}\mathbf{x}})^{1/2}}{\partial{\mathbf{x}}}\\
&amp;=\dfrac{1}{2}({\mathbf{x}^{\mathbf{T}}\mathbf{x}})^{-1/2}\dfrac{\partial({\mathbf{x}^{\mathbf{T}}\mathbf{x}})}{\partial{\mathbf{x}}}\\
&amp;=\dfrac{1}{2}({\mathbf{x}^{\mathbf{T}}\mathbf{x}})^{-1/2}\cdot2\mathbf{x}^{\mathbf{T}}\\
&amp;=\dfrac{\mathbf{x}^{\mathbf{T}}}{\Vert{\mathbf{x}}\Vert}\\
\end{aligned}
\]</span></p>
<ul>
<li>结论</li>
</ul>
<p><span class="math display">\[
\dfrac{\partial{\Vert{\mathbf{x}}\Vert}}{\partial{\mathbf{x}}}
=\dfrac{\mathbf{x}^{\mathbf{T}}}{\Vert{\mathbf{x}}\Vert}\\
\]</span></p>
<ul>
<li>细节</li>
</ul>
<p><span class="math display">\[
\dfrac{\partial({\mathbf{x}^{\mathbf{T}}\mathbf{x}})}{\partial{\mathbf{x}}}
=\dfrac{\partial(x^2+y^2+z^2)}{\partial{\mathbf{x}}}
=\begin{bmatrix}
2x&amp;2y&amp;2z
\end{bmatrix}
=2\mathbf{x}^{\mathbf{T}}
\]</span></p>
<ul>
<li>直观理解：长度变长的最快方向就是自身方向</li>
</ul>
<h4 id="例子弹簧">例子：弹簧</h4>
<ul>
<li>Choi and Ko. 2002. Stable But Responive Cloth. TOG (SIGGRAPH)</li>
</ul>
<p><img src="/2021/11/28/CG/WHM-GAMES103/02-2/image-20211128223258229.png" style="zoom:80%;"></p>
<ul>
<li>弹簧能量
<ul>
<li>Energy</li>
</ul></li>
</ul>
<p><span class="math display">\[
E(\mathbf{x})=\dfrac{k}{2}(\Vert\mathbf{x}\Vert-L)^{2}
\]</span></p>
<ul>
<li>弹簧力（物理推导）
<ul>
<li>Force</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\mathbf{f}(\mathbf{x})&amp;=-\nabla E(\mathbf{x})\\
&amp;=-k(\Vert\mathbf{x}\Vert-L)\left(\dfrac{\partial{\Vert{\mathbf{x}}\Vert}}{\partial{\mathbf{x}}}\right)^{\mathbf{T}}\\
&amp;=-k(\Vert\mathbf{x}\Vert-L)\dfrac{\mathbf{x}}{\Vert{\mathbf{x}}\Vert}
\end{aligned}
\]</span></p>
<ul>
<li>Hessian
<ul>
<li>Tangent stiffness
<ul>
<li>曲面二阶导</li>
<li><span class="math inline">\(\mathbf{x}\)</span> 是一维，那么就是
<span class="math inline">\(k\)</span></li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\mathbf{H}(\mathbf{x})&amp;=-\dfrac{\partial
f(\mathbf{x})}{\partial\mathbf{x}}\\
&amp;=k\left(
\dfrac{\mathbf{x}\mathbf{x}^{\mathbf{T}}}{\Vert{\mathbf{x}}\Vert^2}
+(\Vert\mathbf{x}\Vert-L)\left(
\dfrac{\mathbf{I}}{\Vert{\mathbf{x}}\Vert}-\dfrac{\mathbf{x}}{\Vert{\mathbf{x}}\Vert^2}\dfrac{\mathbf{x}^{\mathbf{T}}}{\Vert{\mathbf{x}}\Vert}
\right)\right)\\
&amp;=k\left(
\dfrac{\mathbf{x}\mathbf{x}^{\mathbf{T}}}{\Vert{\mathbf{x}}\Vert^2}
+(1-\dfrac{L}{\Vert\mathbf{x}\Vert})\left(
\mathbf{I}-\dfrac{\mathbf{x}\mathbf{x}^{\mathbf{T}}}{\Vert{\mathbf{x}}\Vert^2}
\right)\right)\\
\end{aligned}
\]</span></p>
<ul>
<li>两个点都是活动点
<ul>
<li><span class="math inline">\(\mathbf{x}\)</span> 是 6
维的，两个点的位置</li>
</ul></li>
</ul>
<p><img src="/2021/11/28/CG/WHM-GAMES103/02-2/image-20211128225402157.png" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.06.Constrained Approaches(PBD, PD and others)</title>
    <url>/2022/01/24/CG/WHM-GAMES103/06/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="布料模拟">布料模拟</h1>
<h2 id="bending-issue">Bending Issue</h2>
<ul>
<li>弯曲问题</li>
<li>在弹簧质点系统中，我们加上一条弯曲边，用于防止布料的弯折</li>
</ul>
<p><img src="/2022/01/24/CG/WHM-GAMES103/06/image-20220124112842941.png" style="zoom:80%;"></p>
<ul>
<li>但是当布料平放在桌面上的时候，微小的弯曲导致弹簧的形变也比较小，此时抵抗力比较小，呈现出布料弯曲的样子，这与事实不符</li>
</ul>
<p><img src="/2022/01/24/CG/WHM-GAMES103/06/image-20220124113051137.png" style="zoom:80%;"></p>
<ul>
<li>如何构造弯曲的抵抗？
<ul>
<li><strong>角度</strong>：使用两个三角形的夹角来构造抵抗弯曲的力</li>
<li><strong>二面角方法</strong></li>
</ul></li>
</ul>
<h2 id="二面角弯曲模型">二面角弯曲模型</h2>
<ul>
<li>A Dihedral Angle Model</li>
<li>用于解决 Bending 问题</li>
<li>将弹簧的弯曲力写成二面角的形式</li>
</ul>
<p><span class="math display">\[
\mathbb{f}_i=f(\theta)\mathbb{u}_i
\]</span></p>
<ul>
<li><span class="math inline">\(f(\theta)\)</span>：力的大小</li>
<li><span class="math inline">\(\mathbb{u}_i\)</span>：力的方向</li>
</ul>
<p><img src="/2022/01/24/CG/WHM-GAMES103/06/image-20220223203945500.png" style="zoom:80%;"></p>
<ul>
<li>一个二面角涉及到 4 个点</li>
</ul>
<h3 id="方向">方向</h3>
<ul>
<li><span class="math inline">\(\mathbb{u}_1,\mathbb{u}_2\)</span>
应该在三角形对应的<strong>法向上</strong></li>
<li><span class="math inline">\(\mathbb{u}_3-\mathbb{u}_4\)</span>
应该和 <span class="math inline">\(\mathbb{x}_3\mathbb{x}_4\)</span>
这条边垂直
<ul>
<li>不将这条边进行拉伸</li>
<li>此时 <span class="math inline">\(\mathbb{u}_3-\mathbb{u}_4\)</span>
是 <span class="math inline">\(\mathbb{n}_1,\mathbb{n}_2\)</span>
的线性组合
<ul>
<li>法向都和 <span class="math inline">\(\mathbb{x}_3\mathbb{x}_4\)</span> 这条边垂直</li>
</ul></li>
</ul></li>
<li>合力为 <span class="math inline">\(\mathbb{0}\)</span>
<ul>
<li><span class="math inline">\(\Rightarrow\mathbb{u}_3+\mathbb{u}_4\)</span> 是
<span class="math inline">\(\mathbb{n}_1,\mathbb{n}_2\)</span>
的线性组合</li>
<li><span class="math inline">\(\Rightarrow\mathbb{u}_3,\mathbb{u}_4\)</span> 是
<span class="math inline">\(\mathbb{n}_1,\mathbb{n}_2\)</span>
的线性组合</li>
</ul></li>
<li>结果如下</li>
</ul>
<p><img src="/2022/01/24/CG/WHM-GAMES103/06/image-20220223205122355.png" style="zoom:80%;"></p>
<h3 id="大小">大小</h3>
<p><img src="/2022/01/24/CG/WHM-GAMES103/06/image-20220223205327055.png" style="zoom:80%;"></p>
<ul>
<li>planar case：放松的时候是平面的</li>
<li>non-planar case：放松的时候有一个夹角 <span class="math inline">\(\theta_0\)</span></li>
</ul>
<h3 id="细节">细节</h3>
<ul>
<li>Bridson et al. 2003. <em>Simulation of Clothing with Folds and
Wrinkles</em>. SCA.
<ul>
<li><strong>经典文献</strong></li>
</ul></li>
<li>还提到了一些其他问题
<ul>
<li>自碰撞处理</li>
<li>积分模拟
<ul>
<li>显示积分</li>
<li>隐式积分：<strong>求导非常难算</strong></li>
</ul></li>
</ul></li>
<li>问题
<ul>
<li>所有推导都是基于力，没有谈到任何关于能量的信息</li>
</ul></li>
</ul>
<h2 id="二次弯曲模型">二次弯曲模型</h2>
<ul>
<li>A Quadratic Bending Model</li>
<li>处理弯曲问题</li>
<li>两个假设
<ul>
<li>静止放松的时候是<strong>平面</strong></li>
<li>没有什么形变（拉伸非常小），只有弯曲导致的形变</li>
</ul></li>
<li>根据<strong>拉普拉斯变换</strong>推导出来如下能量表示形式</li>
</ul>
<p><img src="/2022/01/24/CG/WHM-GAMES103/06/image-20220223214736768.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(\mathbb{q}\in\mathbb{R}^{12\times3}\)</span></li>
<li>表达式变化改写如下</li>
</ul>
<p><span class="math display">\[
E(\mathbb{x})=\dfrac{3\Vert\mathbb{q}^{\mathbb{T}}\mathbb{x}\Vert^{2}}{2(A_0+A_1)}
\]</span></p>
<ul>
<li>上面的式子在估算两个三角形的曲率（拉普拉斯）</li>
<li>平的时候，曲率为 0，<span class="math inline">\(E(\mathbb{x})=0\)</span></li>
<li>推导是基于数学中<strong>曲率</strong>的定义推导得到的，而不是物理测量得到的</li>
</ul>
<h3 id="评价">评价</h3>
<h4 id="pros">Pros</h4>
<ul>
<li>二阶的形式，很容易计算力，因此很容易实现</li>
</ul>
<p><img src="/2022/01/24/CG/WHM-GAMES103/06/image-20220223220001115.png" style="zoom:80%;"></p>
<ul>
<li>容易使用隐式积分模拟的方式</li>
</ul>
<h4 id="cons">Cons</h4>
<ul>
<li>拉伸很厉害的话，模拟不再准确</li>
<li>如果两个三角形在静止的时候不是平面的话，模拟不准确
<ul>
<li>改进：cubic shell model</li>
<li>其他：projective dynamics model</li>
</ul></li>
</ul>
<h3 id="细节-1">细节</h3>
<ul>
<li>Bergou et al. 2006. <em>A Quadratic Bending Model for Inextensible
Surfaces</em>. SCA.</li>
</ul>
<h2 id="locking-issue">Locking Issue</h2>
<ul>
<li>如下图，如果弹簧很难弯曲，此时，右边的方式很难弯曲
<ul>
<li>原因是我们认为中间的弹簧只能被压缩，不能被弯曲</li>
</ul></li>
</ul>
<p><img src="/2022/01/24/CG/WHM-GAMES103/06/image-20220223221041332.png" style="zoom:80%;"></p>
<ul>
<li>上面的问题就是 locking issue</li>
<li>本质上是由于<strong>自由度的丢失</strong>导致的
<ul>
<li>DoFs：degrees of freedoms</li>
</ul></li>
<li>Euler Fomula
<ul>
<li>对于 manifold mesh，边数 = 3 <span class="math inline">\(\times\)</span> 顶点数 - 3 - 边缘上的边数
<ul>
<li><code>#edges=3#vertices-3-#boundary_edges</code></li>
</ul></li>
</ul></li>
<li>变量数：3 <span class="math inline">\(\times\)</span> 顶点数
<ul>
<li>因此自由度仅仅是 <code>3+#boundary_edges</code></li>
</ul></li>
<li>如果模拟的布是方块形的，自由度更少（边缘上的边更少）</li>
<li>解决方式
<ul>
<li>弹簧在压缩的时候，弹性系数设置的小一点</li>
<li>弹簧在一定范围内没有力，可以自由伸缩</li>
<li>把自由度定在边上
<ul>
<li>English and Bridson. 2008. <em>Animating Developable Surfaces Using
Nonconforming Elements</em>. SIGGRAPH. (optional)</li>
</ul></li>
</ul></li>
<li>弹簧弹性很弱、网格分辨率很低的时候，locking issue 会很明显
<ul>
<li>顶点数多了，自由度不变，但是顶点更密会让这种现象缓解（根本问题没有解决）</li>
</ul></li>
</ul>
<h2 id="shape-matching">Shape Matching</h2>
<ul>
<li>没讲</li>
</ul>
<p><img src="/2022/01/24/CG/WHM-GAMES103/06/image-20220223222533227.png" style="zoom:80%;"></p>
<p><img src="/2022/01/24/CG/WHM-GAMES103/06/image-20220223222612427.png" style="zoom:80%;"></p>
<p><img src="/2022/01/24/CG/WHM-GAMES103/06/image-20220223222637004.png" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.07.Other Constrained Methods and Finite Element Method I(2)</title>
    <url>/2022/02/27/CG/WHM-GAMES103/07-1/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="有限元方法">有限元方法</h1>
<ul>
<li>方法
<ul>
<li>The linear finite element method (FEM)</li>
<li>The finite volume method (FVM)</li>
<li>Hyperelastic models</li>
</ul></li>
<li>对于 linear element（三角形、四面体），FEM、FVM 是一样的</li>
</ul>
<h2 id="fem">FEM</h2>
<ul>
<li><strong><span style="color:red">这里的例子都是 2D
的</span></strong></li>
<li>Linear Finite Element Method</li>
<li>线性有限元：对于一个三角形，假定内部的形变是均匀的
<ul>
<li>对于内部形变，可以使用一个统一的公式描述</li>
</ul></li>
</ul>
<p><span class="math display">\[
\mathbf{x}=\mathbf{F}\mathbf{X}+\mathbf{c}
\]</span></p>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07-1/image-20220227193957313.png" style="zoom:80%;"></p>
<ul>
<li>对于</li>
<li><span class="math inline">\(\mathbf{F}\)</span>：表示形变和旋转
<ul>
<li>形变梯度：<span class="math inline">\(\mathbf{F}=\partial{\mathbf{x}}/\partial{\mathbf{X}}\)</span></li>
</ul></li>
<li><span class="math inline">\(\mathbf{c}\)</span>：表示平移</li>
</ul>
<h3 id="形变梯度">形变梯度</h3>
<h4 id="求解">求解</h4>
<ul>
<li>如何求 <span class="math inline">\(\mathbf{F}\)</span>？</li>
<li>对于一条边（两个点），我们有如下结论</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07-1/image-20220227194926469.png" style="zoom:80%;"></p>
<ul>
<li>通过两条边联立方程组求解</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07-1/image-20220227195222219.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(\mathbf{F}\)</span>
中还含有旋转成分，如何去掉旋转成分？</li>
</ul>
<h4 id="分析">分析</h4>
<ul>
<li>形变过程：<span class="math inline">\(\mathbf{F}=\mathbf{U}\mathbf{D}\mathbf{V}^{\textbf{T}}\)</span></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07-1/image-20220227195644981.png" style="zoom:80%;"></p>
<ul>
<li>只有 <span class="math inline">\(\mathbf{D}\mathbf{V}^{\textbf{T}}\)</span>
这两个分量和形变相关
<ul>
<li><span class="math inline">\(\mathbf{D}\)</span>：形变</li>
<li><span class="math inline">\(\mathbf{V}^{\textbf{T}}\)</span>：朝着哪个方向形变</li>
</ul></li>
<li>去掉和形变不相关的成分 <span class="math inline">\(\mathbf{U}\)</span>？
<ul>
<li>SVD 分解之后去除：麻烦、计算量大</li>
</ul></li>
<li>我们发现</li>
</ul>
<p><span class="math display">\[
\mathbf{F}^{\textbf{T}}\mathbf{F}
=\mathbf{V}\mathbf{D}\mathbf{U}^{\textbf{T}}\mathbf{U}\mathbf{D}\mathbf{V}^{\textbf{T}}
=\mathbf{V}\mathbf{D}^2\mathbf{V}^{\textbf{T}}
\]</span></p>
<ul>
<li>定义 Green Strain</li>
</ul>
<h4 id="green-strain">Green Strain</h4>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07-1/image-20220227200331316.png" style="zoom:80%;"></p>
<ul>
<li>strain：描述形变的一个量
<ul>
<li>在没有形变的时候为 0</li>
<li>大小和形变的大小正相关</li>
</ul></li>
<li><span class="math inline">\(\mathbf{G}\)</span>
是<strong>旋转无关</strong>的
<ul>
<li>加上一个旋转变换 <span class="math inline">\(\mathbf{RF}\)</span>，计算得到的 <span class="math inline">\(\mathbf{G}\)</span> 还是一样的</li>
<li><strong>对称矩阵</strong></li>
</ul></li>
</ul>
<h3 id="能量密度函数">能量密度函数</h3>
<ul>
<li>利用形变（形变梯度 <span class="math inline">\(\mathbf{F}\)</span>
），定义能量密度 <span class="math inline">\(\mathbf{W}(\mathbf{G})\)</span></li>
<li>能量密度：单位面积的能量
<ul>
<li>Strain Energy Density Function</li>
</ul></li>
<li>整个三角形的能量通过积分得到</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07-1/image-20220227201051740.png" style="zoom:80%;"></p>
<ul>
<li>三角形内部的 <span class="math inline">\(\mathbf{F}\)</span>
相同，于是 <span class="math inline">\(\mathbf{W}(\mathbf{G})\)</span>
也相同</li>
</ul>
<h4 id="stvk">StVK</h4>
<ul>
<li>Saint Venant-Kirchhoff Model</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07-1/image-20220227201548944.png" style="zoom:80%;"></p>
<ul>
<li>物理模拟里面实际上用的并不是很多，图形学中用的多（因为简单）</li>
<li>求导</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07-1/image-20220227201904641.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(\mathbf{S}\)</span>：和力相关</li>
<li>问题：如果四面体反转了，没有办法翻回来</li>
</ul>
<h3 id="求力">求力</h3>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07-1/image-20220227202450371.png" style="zoom:80%;"></p>
<ul>
<li>绿色部分能够算出来（上面的 <span class="math inline">\(\mathbf{S}\)</span> ）</li>
<li>需要求灰色部分</li>
<li>从定义出发，推导如下
<ul>
<li>a,b,c,d 指代矩阵中的元素</li>
</ul></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07-1/image-20220227202851256.png" style="zoom:80%;"></p>
<ul>
<li>上面很复杂！！！</li>
<li>但是可以简化成矩阵形式！！！</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07-1/image-20220227203147601.png" style="zoom:80%;"></p>
<ul>
<li>另外一个点的力，可以通过合力为 0 求得</li>
</ul>
<p><span class="math display">\[
\mathbf{f}_0=-\mathbf{f}_1-\mathbf{f}_2
\]</span></p>
<h3 id="泛化">泛化</h3>
<ul>
<li>对于 linear element，推导思路都是一样的</li>
</ul>
<h3 id="实现">实现</h3>
<ul>
<li>Volino et al. 2009. <em>A simple approach to nonlinear tensile
stiffness for accurate cloth simulation</em>. TOG</li>
<li>如果对于四面体：所有东西都变为 3 维</li>
</ul>
<h3 id="其他">其他</h3>
<ul>
<li>没有考虑内部的力</li>
<li>力是怎么来的？
<ul>
<li>积分得到的，靠近顶点的一块区域里的积分得到，施加在顶点上</li>
</ul></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07-1/image-20220227203741003.png" alt="image-20220227203741003" style="zoom:80%;"></p>
<ul>
<li>衣服的三维模拟，形变梯度是 <span class="math inline">\(2\times3\)</span> 的矩阵
<ul>
<li>参考状态是二维的，实际状态是三维的</li>
</ul></li>
<li>目前主流的布料模拟方法
<ul>
<li>弹簧系统 + 隐式积分 + 近似（高分辨率、高质量）</li>
<li>PBD（低分辨率）</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.07.Other Constrained Methods and Finite Element Method I</title>
    <url>/2022/02/27/CG/WHM-GAMES103/07/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="约束方法">约束方法</h1>
<h2 id="projective-dynamics">Projective Dynamics</h2>
<ul>
<li>PBD 中使用投影函数直接改变顶点位置</li>
<li>PD
利用投影函数计算出来的新位置定义一个<strong>二次能量函数</strong>（而不是直接修改顶点位置），利用构造出来的能量函数进行模拟</li>
</ul>
<h3 id="三角形">三角形</h3>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227153322024.png" style="zoom:80%;"></p>
<ul>
<li>利用 PBD
的投影函数，两个顶点之间的记录计算之后应该就是<strong>弹簧原长</strong>，进一步变形如下</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227153835473.png" style="zoom:80%;"></p>
<ul>
<li><strong>化简之后发现和弹簧的能量表达形式相同</strong></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227154107136.png" style="zoom:80%;"></p>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227154014434.png" style="zoom:80%;"></p>
<ul>
<li>能量对位置求负梯度得到力
<ul>
<li><strong><span style="color:red">假设 <span class="math inline">\(\mathbf{x}_{e,i}^{\textrm{new}}\)</span> 和 <span class="math inline">\(\mathbf{x}_{e}\)</span> 无关</span></strong></li>
</ul></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227154303774.png" style="zoom:80%;"></p>
<ul>
<li>根据投影函数</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227154555020.png" style="zoom:80%;"></p>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227154625676.png" style="zoom:80%;"></p>
<ul>
<li><strong>力和弹簧的力也是一样的</strong></li>
<li>因此这个模型和正常弹簧系统的模拟是一样的，只不过引入了两个中间变量
<span class="math inline">\(\mathbf{x}_{e,i}^{\textrm{new}},\mathbf{x}_{e,j}^{\textrm{new}}\)</span></li>
<li>为什么使用这个模型而不是原来的弹簧模型？
<ul>
<li><strong>Hessian 不一样</strong></li>
</ul></li>
</ul>
<h3 id="hessian">Hessian</h3>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227154942251.png" style="zoom:80%;"></p>
<ul>
<li>Hessian 的可以利用拓扑结构得到（和计算一致）
<ul>
<li>对角线：从图上看相邻了几条边就是几</li>
<li>非对角线：存的是边，有就是 <span class="math inline">\(-\mathbf{I}\)</span>，否则为 <span class="math inline">\(\mathbf{0}\)</span></li>
</ul></li>
</ul>
<h3 id="pd-的好处">PD 的好处</h3>
<ul>
<li>利用上面的假设：<strong><span style="color:red">假设 <span class="math inline">\(\mathbf{x}_{e,i}^{\textrm{new}}\)</span> 和 <span class="math inline">\(\mathbf{x}_{e}\)</span> 无关</span></strong></li>
<li>能够将 Hessian 简化为一个常数矩阵
<ul>
<li>常数矩阵能够直接从<strong>拓扑结构</strong>中得到（和计算一致）</li>
</ul></li>
<li>Hessian 矩阵是常数之后能够带来大量的计算量上的减少
<ul>
<li><a href="/2021/10/02/computation/pyr/03/#lu-分解">LU 分解</a>求解
<span class="math inline">\(Ax=b\)</span>
<ul>
<li>在求解方程组的解的时候，需要进行分解操作（计算量很大）</li>
<li>如果是一个常数的话，对所有方程组求解的只需要<strong>分解一次</strong></li>
</ul></li>
</ul></li>
</ul>
<h3 id="牛顿法">牛顿法</h3>
<ul>
<li>算法流程和隐式积分差不多，但是在方程组求解的部分简化了计算量
<ul>
<li>可以理解为就是在隐式积分的过程中，使用了一种方法对 Hessain
矩阵进行了近似</li>
</ul></li>
<li>PD 利用牛顿法求解如下</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227160433512.png" style="zoom:80%;"></p>
<ul>
<li>对于弹簧系统而言，力的计算和弹簧的力相同，Hessain又是常数，因此投影这一步完全可以省略
<ul>
<li>有些系统是需要保留投影计算这一步的</li>
</ul></li>
</ul>
<h3 id="shape-matching">Shape Matching</h3>
<ul>
<li>没讲</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227162444348.png" style="zoom:80%;"></p>
<h3 id="可行性分析">可行性分析</h3>
<ul>
<li>为什么这样对 Hessian 的计算也可以比较好的模拟？</li>
<li>本质上是对 Hessian 的一个合理近似</li>
<li>效率取决于对 Hessian 近似的好不好</li>
</ul>
<h3 id="其他">其他</h3>
<ul>
<li>游戏中的布料模拟
<ul>
<li>例如衣服，更多的是利用人体骨骼驱动，在加上 PBD 的方法</li>
<li>在实际游戏模拟过程中，主要开销是在<strong>内存访问</strong>上，计算开销并不大</li>
<li>PBD
对于内存的访问很少（只需要访问顶点位置），其他方法可能还有一些其他的物理变量需要访问</li>
<li>高性能的优化，内存访问是一个关键</li>
</ul></li>
</ul>
<h3 id="评价">评价</h3>
<ul>
<li>红色：PD</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227162531368.png" style="zoom:80%;"></p>
<h4 id="pros">Pros</h4>
<ul>
<li>和 PBD 相比，是有物理含义的</li>
<li>在 CPU 上，作为直接法求解，效率很高（只需要分解一次）</li>
<li>在前几次迭代过程中收敛很快</li>
</ul>
<h4 id="cons">Cons</h4>
<ul>
<li>GPU 上比较慢
<ul>
<li>LU 分解在 GPU 上不太合适</li>
<li>直接法在 GPU 上支持的都不太好</li>
</ul></li>
<li>整体而言，收敛的比较慢（假设中没有考虑 projection 导致的
Hessian）</li>
<li>约束改变之后，修改起来比较麻烦（Hessain 矩阵需要修改）
<ul>
<li>例如破碎 fracture</li>
</ul></li>
</ul>
<h3 id="论文">论文</h3>
<ul>
<li>Bouaziz et al. 2014. <em>Projective Dynamics: Fusing Constraint
Projections for Fast Simulation. TOG (SIGGRAPH)</em>.</li>
</ul>
<h2 id="constrained-dynamics">Constrained Dynamics</h2>
<ul>
<li>为了处理非常 stiff 的约束
<ul>
<li>更多的用在刚体模拟</li>
<li>例如人体的约束，大臂和小臂连接点的限制（这个约束很强，必须要满足，否则很诡异）</li>
</ul></li>
<li>预先引入一个新的变量 <span class="math inline">\(\mathbf{\lambda}\)</span>，这样能够处理非常 stiff
的情况</li>
</ul>
<h3 id="转换">转换</h3>
<ul>
<li>约束还是一样</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227164038504.png" style="zoom:80%;"></p>
<ul>
<li>能量写成矩阵形式，力也一样</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227164106876.png" style="zoom:80%;"></p>
<ul>
<li>之前做隐式积分只有一个变量，现在有两个（<span class="math inline">\(\mathbf{x}/\mathbf{v},\mathbf{\lambda}\)</span>）</li>
<li>动量守恒：冲量 = 动量的变化量</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227164810005.png" style="zoom:80%;"></p>
<ul>
<li>近似
<ul>
<li>泰勒展开</li>
<li>位置变化量 = 速度 <span class="math inline">\(\times\)</span>
时间</li>
</ul></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227164927403.png" style="zoom:80%;"></p>
<ul>
<li>把上面两个约束放到同一个矩阵中（一起更新）</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227165239458.png" style="zoom:80%;"></p>
<h3 id="求解">求解</h3>
<h4 id="method-1">Method 1</h4>
<ul>
<li>primal dual method：两个变量一起求解</li>
<li>直接求解矩阵</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227165239458.png" style="zoom:80%;"></p>
<ul>
<li>系数矩阵不一定是正定的</li>
</ul>
<h4 id="method-2">Method 2</h4>
<ul>
<li>消元，先求解 <span class="math inline">\(\mathbf{\lambda}^{\textrm{new}}\)</span></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227165527129.png" style="zoom:80%;"></p>
<ul>
<li>消元不一定很简单</li>
</ul>
<h3 id="好处">好处</h3>
<ul>
<li>stiffness 很大的时候，<span class="math inline">\(k\to\infty\Longrightarrow\mathbf{C}\to\mathbf{0}\)</span></li>
<li>原来 <span class="math inline">\(k\to\infty\)</span> 不好模拟，但是
<span class="math inline">\(\mathbf{C}\to\mathbf{0}\)</span>
让模拟更简单了</li>
</ul>
<h3 id="应用">应用</h3>
<ul>
<li>Articulated Rigid Bodies (<strong>ragdoll animation</strong>)
<ul>
<li>假设人体是有很多刚体构成的，刚体和刚体之间有很多约束</li>
</ul></li>
</ul>
<h2 id="stable-constrained-dynamics">Stable Constrained Dynamics</h2>
<ul>
<li>没讲</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227165239458.png" style="zoom:80%;"></p>
<ul>
<li>上面矩阵求解如果把 <span class="math inline">\(mathbf{\lambda}\)</span>
消去之后，则和隐式积分相同，但是 Hessian
有一部分消失了，如果把这部分加上去，模拟会更加稳定</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227170954309.png" style="zoom:80%;"></p>
<h3 id="推导">推导</h3>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227170805317.png" style="zoom:80%;"></p>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227170938428.png" style="zoom:80%;"></p>
<h3 id="论文-1">论文</h3>
<ul>
<li>Tournier et al. 2015. <em>Stable Constrained Dynamics. TOG
(SIGGRAPH)</em>.</li>
</ul>
<h2 id="对比">对比</h2>
<p><img src="/2022/02/27/CG/WHM-GAMES103/07/image-20220227171406617.png" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.08.Linear Finite Element Method II(2)</title>
    <url>/2022/03/28/CG/WHM-GAMES103/08-1/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="有限元模拟">有限元模拟</h1>
<h2 id="hyperelastic-models">Hyperelastic Models</h2>
<ul>
<li>之前使用的 Stvk 模型存在很多局限性
<ul>
<li>不能处理反转情况</li>
<li>真实材料力学的工程里面 Stvk 模型使用的很少</li>
<li>图形学中为了简化，使用的比较多</li>
</ul></li>
<li>通用模型：Hyperelastic models
<ul>
<li>通过能量密度推出来的</li>
<li>如何构造一个从 G 到 S（stress）的映射</li>
<li>能量/力与变形过程无关，只与当前时刻的形状有关</li>
<li>可以势能描述</li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220417131248809.png" style="zoom:80%;"></p>
<h2 id="各向同性材料">各向同性材料</h2>
<ul>
<li>isotropic material</li>
<li>first piola-kirchhoff stress 是 <span class="math inline">\(\mathbf{F}\)</span> 的一个函数</li>
</ul>
<p><span class="math display">\[
\mathbf{P}(\mathbf{F})=\mathbf{P}(\mathbf{UDV^{\text{T}}})
\]</span></p>
<ul>
<li>对于各向同性的材质来说，可以把旋转项提出来
<ul>
<li>F：旋转 + 拉伸 + 旋转</li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220328233200009.png" style="zoom:80%;"></p>
<ul>
<li>principal stretches：主拉伸量</li>
<li>在论文中常常这样描述 <span class="math inline">\(\mathbf{P}\)</span></li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220328233444619.png" style="zoom:80%;"></p>
<ul>
<li>然而这里实际上，由于 <span class="math inline">\(\text{trace}(\mathbf{AB})=\text{trace}(\mathbf{BA})\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\text{trace}(\mathbf{F}^{\text{T}}\mathbf{F})
&amp;=\text{trace}(\mathbf{UDV^{\text{T}}VDU^{\text{T}}})\\
&amp;=\text{trace}(\mathbf{UD^2U^{\text{T}}})\\
&amp;=\text{trace}(\mathbf{U^{\text{T}}UD^2})\\
&amp;=\text{trace}(\mathbf{D^2})\\
\end{aligned}
\]</span></p>
<ul>
<li>类似的还有</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\text{trace}(\mathbf{C}^2)
&amp;=\text{trace}(\mathbf{UD^2U^{\text{T}}UD^2U^{\text{T}}})\\
&amp;=\text{trace}(\mathbf{UD^4U^{\text{T}}})\\
&amp;=\text{trace}(\mathbf{U^{\text{T}}UD^4})\\
&amp;=\text{trace}(\mathbf{D^4})\\
\end{aligned}
\]</span></p>
<ul>
<li>于是不同模型的描述如下</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220328233606260.png" style="zoom:80%;"></p>
<ul>
<li><strong><span style="color:red">注意这里的 stvk 模型</span></strong>
<ul>
<li>之前提到的模型长这样</li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220227201548944.png" style="zoom:80%;"></p>
<ul>
<li>我们可以将其展开，发现 <span class="math inline">\(\lambda,\mu\)</span> 和 <span class="math inline">\(s_0,s_1\)</span> 的关系如下（做 lab 3
的时候要注意）
<ul>
<li>证明方式就是把 <span class="math inline">\(\epsilon_{uu}\)</span>
等直接展开</li>
</ul></li>
</ul>
<p><span class="math display">\[
s_0={\color{red}\dfrac{1}{4}}\lambda,\;s_1=\mu
\]</span></p>
<ul>
<li>neo-Hookean 模型在真实的材料力学中使用的更多</li>
<li>这些模型都有两项
<ul>
<li>第一项：<strong>抵抗拉伸</strong></li>
<li>第二项：<strong>阻止体积/面积的改变</strong></li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220328233826900.png" style="zoom:80%;"></p>
<ul>
<li>其他模型
<ul>
<li>the Mooney-Rivlin model：neo-Hookean 的增强版、模拟橡胶</li>
<li>the Fung model：模仿人体组织</li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220328234006066.png" style="zoom:80%;"></p>
<ul>
<li>计算 stress</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220328234223076.png" style="zoom:80%;"></p>
<ul>
<li>于是对于各向同性的模型，我们可以如下计算</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220328234408686.png" style="zoom:80%;"></p>
<ul>
<li>对于同样的模型，这种方法和之前的方法计算结果应该是一样的</li>
<li>Stvk 模型的问题可视化
<ul>
<li>压缩的时候，<strong>压缩到一定程度之后，抵抗力反而变小了</strong></li>
<li>反转之后，不会回到原来的状态，而是反转后的一个平衡状态
<ul>
<li>反转：四面体的一个顶点跑到它所对的面的另一面去</li>
</ul></li>
<li>Irving et al. 2004. <em>Invertible Finite Elements For Robust
Simulation of Large Deformation. SCA</em></li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220328234702666.png" style="zoom: 67%;"></p>
<ul>
<li>不同模型的模拟
<ul>
<li>Descent Methods for Elastic Body Simulation on the GPU (SIGGRAPH
Asia 2016)</li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220328235145844.png" style="zoom:80%;"></p>
<ul>
<li>Poisson Effect：物体被拉伸的时候中间会凹进去
<ul>
<li>抵抗体积的改变</li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220328235352252.png" style="zoom: 67%;"></p>
<h2 id="hessianskip">Hessian(skip)</h2>
<ul>
<li>Xu et al. 2015. <em>Nonlinear Material Design Using Principal
Stretches</em>. TOG (SIGGRAPH).</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220328234408686.png" style="zoom:80%;"></p>
<ul>
<li>计算 Hessian（二阶导）</li>
<li>使用 <span class="math inline">\(\mathbf{d}_i\)</span>
简化表示，<span class="math inline">\(V\)</span>
表示体积（前面的那个常数）</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329231330099.png" style="zoom:80%;"></p>
<h3 id="计算过程">计算过程</h3>
<ul>
<li>绿色部分为常数，可以预计算</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329231449708.png" style="zoom:80%;"></p>
<h4 id="拆解">拆解</h4>
<ul>
<li>链式法则计算剩余部分</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329231847344.png" style="zoom:80%;"></p>
<ul>
<li>此时只有橙色部分需要计算，其他部分现在都能计算</li>
<li>利用 SVD 分解定义：<span class="math inline">\(\mathbf{U},\mathbf{V}\)</span> 为正交矩阵，<span class="math inline">\(\Lambda\)</span> 为对角矩阵
<ul>
<li><span class="math inline">\(\mathbf{U}^{\text{T}}\mathbf{U}=\mathbf{I},\mathbf{V}^{\text{T}}\mathbf{V}=\mathbf{I}\)</span></li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329232359568.png" style="zoom:80%;"></p>
<h4 id="反对称矩阵">反对称矩阵</h4>
<ul>
<li>如下证明 <span class="math inline">\(\mathbf{A},\mathbf{B}\)</span>
都是反对称矩阵
<ul>
<li>反对称矩阵定义如下：<span class="math inline">\(\mathbf{M}=-\mathbf{M}^{\text{T}}\)</span></li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329232805402.png" style="zoom:80%;"></p>
<ul>
<li>可以由正交性证明</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329233151356.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(\mathbf{B}\)</span> 同理</li>
</ul>
<h4 id="反对称矩阵好处">反对称矩阵好处</h4>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329232805402.png" style="zoom:80%;"></p>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329233325511.png" style="zoom:80%;"></p>
<ul>
<li>反对称矩阵和对角矩阵的乘积矩阵，对角元都为 0</li>
</ul>
<h4 id="展开求-a-和-b">展开求 A 和 B</h4>
<ul>
<li>回到上面的式子</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329233518032.png" style="zoom:80%;"></p>
<ul>
<li>根据反对称矩阵展开</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329234204313.png" style="zoom:80%;"></p>
<ul>
<li>进一步将其计算出来
<ul>
<li>左边是可以计算的</li>
<li>对应项相等，计算得到 <span class="math inline">\(\mathbf{A},\mathbf{B}\)</span>（6个变量，6个等式）</li>
<li>同时计算得到了 <span class="math inline">\(\dfrac{\partial\lambda_d}{\partial\mathbf{F}_{kl}}\)</span></li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329234348968.png" style="zoom:80%;"></p>
<ul>
<li>此时返回去，可以把需要求的项都计算出来了，于是我们得到了
Hessian</li>
</ul>
<h3 id="思路">思路</h3>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329234834259.png" style="zoom:80%;"></p>
<h2 id="隐式积分skip">隐式积分(skip)</h2>
<ul>
<li><p>计算出来 Hessian 之后，思路和之前完全一样</p></li>
<li><p><a href="https://banbao991.github.io/2022/01/17/CG/WHM-GAMES103/05/#%E6%A8%A1%E6%8B%9F%E7%B3%BB%E7%BB%9F%E9%9A%90%E5%BC%8F%E7%A7%AF%E5%88%86">隐式积分</a></p>
<ul>
<li>最上面的式子，单独算则是显式积分（不准确），同时求解 <span class="math inline">\(\mathbf{v},\mathbf{x}\)</span> 则是隐式积分</li>
<li>如果 <span class="math inline">\(\mathbf{f}\)</span> 仅依赖于 <span class="math inline">\(\mathbf{x}\)</span>，再根据 <span class="math inline">\(\mathbf{f}(\mathbf{x})=-\nabla
E(\mathbf{x})\)</span> ，则转化为下面的式子</li>
<li>变成最值问题</li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220330200836379.png" style="zoom:80%;"></p>
<ul>
<li>牛顿法求解</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220330202422363.png" style="zoom:80%;"></p>
<ul>
<li>代入 Jacobian 和 Hessian</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220330202600798.png" style="zoom:80%;"></p>
<h2 id="非线性优化">非线性优化</h2>
<ul>
<li>Nonlinear Optimization</li>
<li>现在很多物理模拟都是在做优化，在物理模型上创新不大，基本上都是之前的力学模型
<ul>
<li>GPU、CPU 端的优化</li>
<li>如何让几万个四面体的模型，在 GPU 上能够进行实时模拟</li>
</ul></li>
</ul>
<h3 id="梯度下降方法">梯度下降方法</h3>
<ul>
<li>Gradient Descent</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329215849804.png" style="zoom:80%;"></p>
<ul>
<li>算法流程</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329215929070.png" style="zoom:80%;"></p>
<ul>
<li>如何找到一个好的步长（step size）是一个困难/重要的问题（critical）
<ul>
<li>精确解（收敛快、计算代价高）
<ul>
<li>exact line search</li>
</ul></li>
<li>近似解（步长尽量大、值要下降）
<ul>
<li>backtracking line search</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329222908098.png" style="zoom:80%;"></p>
<h3 id="下降方法">下降方法</h3>
<ul>
<li>Descent Method</li>
<li>负梯度方向不一定是最好的方向</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329223335966.png" style="zoom: 80%;"></p>
<ul>
<li>如何找到一个能够下降的方向 <span class="math inline">\(\mathbf{d}(\mathbf{x})\)</span> ？</li>
</ul>
<p><span class="math display">\[
F(\mathbf{x})&gt;F(\mathbf{x}+\alpha\mathbf{d}(\mathbf{x}))
\]</span></p>
<ul>
<li><span class="math inline">\(\mathbf{d}(\mathbf{x})\)</span>
和负梯度方向在同侧（点积大于 0）</li>
</ul>
<p><span class="math display">\[
-\nabla F(\mathbf{x})\mathbf{d}(\mathbf{x})&gt;0
\]</span></p>
<ul>
<li>目的</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329224024889.png" style="zoom:80%;"></p>
<ul>
<li>算法流程</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329224041201.png" style="zoom:80%;"></p>
<h4 id="例子">例子</h4>
<ul>
<li>梯度下降法</li>
</ul>
<p><span class="math display">\[
\mathbf{d}(\mathbf{x})=-\nabla F(\mathbf{x})
\]</span></p>
<ul>
<li>牛顿法
<ul>
<li><strong>要求 Hessian 是正定的</strong></li>
<li>正定矩阵的逆矩阵也是正定矩阵</li>
</ul></li>
</ul>
<p><span class="math display">\[
\mathbf{d}(\mathbf{x})=-\left(\dfrac{\partial^2F(\mathbf{x})}{\partial\mathbf{x}^2}\right)\nabla
F(\mathbf{x})
\]</span></p>
<p><span class="math display">\[
-\nabla F(\mathbf{x})\mathbf{d}(\mathbf{x})=\nabla
F(\mathbf{x})\left(\dfrac{\partial^2F(\mathbf{x})}{\partial\mathbf{x}^2}\right)\nabla
F(\mathbf{x})&gt;0
\]</span></p>
<ul>
<li>推广，只要 <span class="math inline">\(\mathbf{P}\)</span>
是一个正定矩阵，如下方法都是一个下降方法
<ul>
<li>在 lab2
中的衣服模拟，我们使用一个很简单的对角矩阵（正定）也能够使得结果收敛</li>
</ul></li>
</ul>
<p><span class="math display">\[
\mathbf{d}(\mathbf{x})=-\mathbf{P}^{-1}\nabla F(\mathbf{x})
\]</span></p>
<h4 id="通用框架">通用框架</h4>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329224933299.png" style="zoom:80%;"></p>
<h4 id="计算代价">计算代价</h4>
<ul>
<li>总的计算代价 = 每次迭代的代价 <span class="math inline">\(\times\)</span> 迭代次数</li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329225052721.png" style="zoom: 80%;"></p>
<ul>
<li>对比
<ul>
<li>Wang. 2016. <em>Descent Methods for Elastic Body Simulation on the
GPU.</em> TOG (SIGGRAPH Asia).</li>
</ul></li>
</ul>
<p><img src="/2022/03/28/CG/WHM-GAMES103/08-1/image-20220329225216831.png" style="zoom: 80%;"></p>
<h2 id="其他">其他</h2>
<ul>
<li>真实感的模拟
<ul>
<li>serious 的应用</li>
<li>模拟对真实感的要求很高</li>
<li>例如服装产业，期望和实际成衣在模特上效果一致</li>
<li>设计对比实验
<ul>
<li>真实的物理实验，参数化特征，量化误差</li>
</ul></li>
</ul></li>
<li><strong>金属塑性形变</strong>一般使用**有限元模拟*</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.08.Finite Element Method II</title>
    <url>/2022/02/27/CG/WHM-GAMES103/08/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="有限元方法">有限元方法</h1>
<ul>
<li>方法
<ul>
<li>The linear finite element method (FEM)</li>
<li>The finite volume method (FVM)</li>
<li>Hyperelastic models</li>
</ul></li>
</ul>
<h2 id="fvm">FVM</h2>
<ul>
<li>有限体积方法
<ul>
<li>Finite Volumn Method</li>
</ul></li>
<li>对于四面体、三角形这种简单的、线性的 element 而言， 和之前的 FEM
方法是等价的</li>
<li>但是在推导和数学表示上，FVM 更清晰</li>
<li>FEM 用能量对顶点位置求导得到力，FVM 对 traction vector
积分得到力</li>
</ul>
<h3 id="traction">traction</h3>
<ul>
<li>考虑一个弹性体，被划分为上下两个部分</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/image-20220307230711478.png" style="zoom:80%;"></p>
<ul>
<li>计算单位长度的力（traction）
<ul>
<li>3D：单位面积</li>
</ul></li>
<li>那么合力就是积分</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/image-20220307232053043.png" style="zoom:80%;"></p>
<ul>
<li>定义 stress tensor
<ul>
<li><span class="math inline">\(\sigma\)</span></li>
<li><span class="math inline">\(\mathbf{n}\)</span>：法向</li>
</ul></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/image-20220307232253837.png" style="zoom:80%;"></p>
<h3 id="三角形">三角形</h3>
<ul>
<li>假设：一个顶点代表的不是一个点，而是一个区域</li>
<li>那么这个顶点受到的力就是外轮廓的积分
<ul>
<li>内力不对整体产生作用</li>
</ul></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/image-20220307232611573.png" style="zoom:80%;"></p>
<ul>
<li>绿色部分的力，绿色曲线上的积分</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/image-20220307232822404.png" style="zoom:80%;"></p>
<ul>
<li>如何定义绿色曲线？
<ul>
<li>假设穿过边的<strong>中点</strong>
<ul>
<li>力对 3 个顶点的作用是平均的</li>
</ul></li>
<li><strong>中间无所谓</strong></li>
</ul></li>
<li>stress 在三角形内部是均匀的（线性 element 假设），于是有
<ul>
<li><strong>封闭曲线上的法向量积分等于 0</strong></li>
</ul></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/image-20220307233150849.png" style="zoom:80%;"></p>
<ul>
<li>因此 <span class="math inline">\(L\)</span> 上的力如下
<ul>
<li>直线上的法向相同</li>
</ul></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/image-20220307234850333.png" style="zoom:80%;"></p>
<ul>
<li>每个小三角形的 stress 不同，因此总的积分不为 0</li>
</ul>
<h3 id="d">3D</h3>
<ul>
<li>3 维的情况就是面积分
<ul>
<li>对 3 个表面的积分（下图没有画出背面）</li>
</ul></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/image-20220309231411064.png" style="zoom:80%;"></p>
<ul>
<li>计算如下
<ul>
<li>其中 <span class="math inline">\(\dfrac{1}{3}\)</span>
也是想让面上的力对 3 个顶点的作用一样</li>
</ul></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/image-20220309231622611.png" style="zoom:80%;"></p>
<h3 id="stress">stress</h3>
<ul>
<li>如何计算 stress</li>
<li>这里的 stress 是将 normal 映射到 traction 的一个矩阵
<ul>
<li>FEM：stress 是定义在 reference 状态（没有形变）下的</li>
<li>FVM：stress 是定义在 deformed 状态（有形变）下的</li>
</ul></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/image-20220309232224384.png" style="zoom:80%;"></p>
<ul>
<li>不同的 stress，根据 normal/traction
定义在没有形变/有形变的状态下分类</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/image-20220309232708529.png" style="zoom:80%;"></p>
<ul>
<li>可以通过 <span class="math inline">\(\dfrac{\partial{W}}{\partial{G}}\)</span> 求得
<span class="math inline">\(\mathbf{S}\)</span></li>
<li>通过 <span class="math inline">\(\mathbf{FS}\)</span> 求得 <span class="math inline">\(\mathbf{P}\)</span>
<ul>
<li><span class="math inline">\(\mathbf{P}=\mathbf{FS}\)</span></li>
</ul></li>
<li>如何求得 <span class="math inline">\(\sigma\)</span> ？
<ul>
<li>如何表示形变前后的 normal 之间的关系？</li>
<li>结论：<span class="math inline">\(\sigma=\det^{-1}(\mathbf{F})\mathbf{P}\mathbf{F}^{\mathbf{T}}\)</span>
<ul>
<li><span class="math inline">\(\sigma=\det^{-1}(\mathbf{F})\mathbf{FS}\mathbf{F}^{\mathbf{T}}\)</span></li>
</ul></li>
<li>推导如下</li>
</ul></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/image-20220309233440050.png" style="zoom:80%;"></p>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/image-20220309233506410.png" style="zoom:80%;"></p>
<h3 id="stress-关系">stress 关系</h3>
<ul>
<li><a href="https://engcourses-uofa.ca/books/introduction-to-solid-mechanics/stress/first-and-second-piola-kirchhoff-stress-tensors/">参考</a></li>
</ul>
<h4 id="证明-1">证明 1</h4>
<ul>
<li>如果 <span class="math inline">\(M\)</span> 满足如下式子，那么有
<span class="math inline">\(\det(M)=\mathbf{a}\cdot(\mathbf{b}\times\mathbf{c})\)</span></li>
</ul>
<p><span class="math display">\[
M=\det\begin{pmatrix}\mathbf{a}^\text{T}\\\mathbf{b}^\text{T}\\\mathbf{c}^\text{T}\end{pmatrix}
=\det\begin{pmatrix}\mathbf{a}&amp;\mathbf{b}&amp;\mathbf{c}\end{pmatrix}
\]</span></p>
<ul>
<li>交换两行，行列式值改变符号</li>
</ul>
<p><span class="math display">\[
\mathbf{a}\cdot(\mathbf{b}\times\mathbf{c})
=\mathbf{a}\cdot\det\begin{pmatrix}&amp;\mathbf{b}^\text{T}&amp;\\&amp;\mathbf{c}^\text{T}&amp;\\i&amp;j&amp;k\end{pmatrix}
=\det\begin{pmatrix}\mathbf{b}^\text{T}\\\mathbf{c}^\text{T}\\\mathbf{a}^\text{T}\end{pmatrix}
=\det\begin{pmatrix}\mathbf{a}^\text{T}\\\mathbf{b}^\text{T}\\\mathbf{c}^\text{T}\end{pmatrix}
\]</span></p>
<h4 id="证明-2">证明 2</h4>
<ul>
<li>Nanson’s Formula</li>
<li>如果矩阵 <span class="math inline">\(M\in\mathbb{R}^{3\times3}\)</span> 可逆，而且
<span class="math inline">\(u,v\in\mathbb{R}^{3}\)</span>，那么有如下式子成立</li>
</ul>
<p><span class="math display">\[
Mu\times Mv=\det(M)M^{-T}(u\times v)
\]</span></p>
<ul>
<li>设 <span class="math inline">\(w\)</span> 是任意 <span class="math inline">\(\mathbb{R}^{3}\)</span> 向量，于是有</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
Mw\cdot(Mu\times Mv)
&amp;=\det\begin{pmatrix}Mw&amp;Mu&amp;Mv\end{pmatrix}\\
&amp;=\det(M)\det\begin{pmatrix}w&amp;u&amp;v\end{pmatrix}\\
&amp;=\det(M)\;w\cdot(u\times v)
\end{aligned}
\]</span></p>
<ul>
<li>于是</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
w\cdot\det(M)(u\times v)
&amp;=\det(M)\;w\cdot(u\times v)\\
&amp;=Mw\cdot(Mu\times Mv)\\
&amp;=w\cdot M^T(Mu\times Mv)\\
\end{aligned}
\]</span></p>
<ul>
<li>由于 <span class="math inline">\(w\)</span> 的任意性，于是有</li>
</ul>
<p><span class="math display">\[
M^{-T}(Mu\times Mv)=\det(M)(u\times v)
\]</span></p>
<ul>
<li>于是有</li>
</ul>
<p><span class="math display">\[
Mu\times Mv=\det(M)M^{-T}(u\times v)
\]</span></p>
<h4 id="开始证明">开始证明</h4>
<ul>
<li><strong>形变前/形变后</strong>
<ul>
<li>面积：<span class="math inline">\(A_{\text{ref}}/A\)</span></li>
<li>法线：<span class="math inline">\(A_\text{ref}\mathbf{N}/A\mathbf{n}\)</span></li>
<li>边：<span class="math inline">\(\mathbf{X}_{a0}/\mathbf{x}_{a0},\mathbf{X}_{b0}/\mathbf{x}_{b0}\)</span></li>
</ul></li>
<li>根据不同 stress 的定义，我们有如下等式（都是计算形变后的受力）</li>
</ul>
<p><span class="math display">\[
\mathbf{P}(A_{\text{ref}})\mathbf{N}=\sigma(A)\mathbf{n}
\]</span></p>
<ul>
<li>利用 Nanson’s Formula，可以得到</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
(A)\mathbf{n}
&amp;=\dfrac{A}{\Vert\mathbf{x}_{a0}\times\mathbf{x}_{b0}\Vert_2}(\mathbf{x}_{a0}\times\mathbf{x}_{b0})\\
&amp;=\dfrac{1}{2}(\mathbf{x}_{a0}\times\mathbf{x}_{b0})\\
&amp;=\dfrac{1}{2}(\mathbf{F}\mathbf{X}_{a0}\times\mathbf{F}\mathbf{X}_{b0})\\
&amp;=\dfrac{1}{2}\det(\mathbf{F})\mathbf{F}^{-\text{T}}(\mathbf{X}_{a0}\times\mathbf{X}_{b0})\\
&amp;=(A_{\text{ref}})\det(\mathbf{F})\mathbf{F}^{-\text{T}}\mathbf{N}\\
\end{aligned}
\]</span></p>
<ul>
<li>类似的</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
(A)\sigma\mathbf{n}
&amp;=\dfrac{A}{\Vert\mathbf{x}_{a0}\times\mathbf{x}_{b0}\Vert_2}\sigma(\mathbf{x}_{a0}\times\mathbf{x}_{b0})\\
&amp;=\dfrac{1}{2}\sigma(\mathbf{x}_{a0}\times\mathbf{x}_{b0})\\
&amp;=\dfrac{1}{2}\sigma(\mathbf{F}\mathbf{X}_{a0}\times\mathbf{F}\mathbf{X}_{b0})\\
&amp;=\dfrac{1}{2}\sigma\det(\mathbf{F})\mathbf{F}^{-\text{T}}(\mathbf{X}_{a0}\times\mathbf{X}_{b0})\\
&amp;=(A_{\text{ref}})\det(\mathbf{F})\sigma\mathbf{F}^{-\text{T}}\mathbf{N}\\
\end{aligned}
\]</span></p>
<ul>
<li>于是</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;(A_{\text{ref}})\mathbf{PN}=(A)\sigma\mathbf{n}\\
\Longrightarrow\;&amp;\mathbf{P}=\det(\mathbf{F})\sigma\mathbf{F}^{-\text{T}}\\
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\(\mathbf{S}\)</span> 的定义</li>
</ul>
<p><span class="math display">\[
f2_{\mathbf{N}}=\mathbf{S}(A_{\text{ref}})\mathbf{N}=\mathbf{F}^{-1}f_{\mathbf{n}}=\mathbf{F}^{-1}\sigma(A)\mathbf{n}
\]</span></p>
<ul>
<li>如下图示，<span class="math inline">\(a\)</span> 就表示 <span class="math inline">\(A_\text{ref}\)</span>
<ul>
<li><strong><span style="color:red">定义</span></strong>：<span class="math inline">\(\mathbf{F}f2_{\mathbf{N}}=f_{\mathbf{n}}\)</span></li>
</ul></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/Stresses.png" style="zoom: 80%;"></p>
<ul>
<li>根据</li>
</ul>
<p><span class="math display">\[
\mathbf{S}(A_{\text{ref}})\mathbf{N}=\mathbf{F}^{-1}\sigma(A)\mathbf{n},(A_{\text{ref}})\mathbf{PN}=(A)\sigma\mathbf{n}
\]</span></p>
<ul>
<li>能够得到</li>
</ul>
<p><span class="math display">\[
\mathbf{P}=\mathbf{FS}
\]</span></p>
<p><span class="math display">\[
\mathbf{S}=\det(\mathbf{F})\mathbf{F}^{-1}\sigma\mathbf{F}^{-\text{T}}
\]</span></p>
<h2 id="重新表示力">重新表示力</h2>
<ul>
<li>第一行到第二行使用了两种不同的 stress 的表示方式
<ul>
<li>第一行：Cauchy Stress</li>
<li>第二行：First Piola–Kirchhoff stress</li>
</ul></li>
<li>根据定义，两种表示都能计算得到力
<ul>
<li><span class="math inline">\(\mathbf{b}_1\)</span> 是简写</li>
</ul></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/image-20220309235834466.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(\mathbf{b}_1\)</span>
部分表示什么呢？</li>
<li>和三条边点乘
<ul>
<li>第二个式子：<span class="math inline">\(\mathbf{X}_{01}\times\mathbf{X}_{21}=\mathbf{X}_{01}\times(\mathbf{X}_{20}+\mathbf{X}_{01})=\mathbf{X}_{01}\times\mathbf{X}_{20}=\mathbf{X}_{20}\times\mathbf{X}_{10}\)</span></li>
</ul></li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/image-20220317113642475.png" style="zoom:80%;"></p>
<ul>
<li>于是我们得到如下形式</li>
</ul>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/image-20220317113943536.png" style="zoom:80%;"></p>
<h2 id="代码框架">代码框架</h2>
<p><img src="/2022/02/27/CG/WHM-GAMES103/08/image-20220317114137826.png" style="zoom:80%;"></p>
<ul>
<li>然后再用力去更新速度、更新位置</li>
<li>FEM、FVM 在一般情况下是不一样的，但是在简单的 linear element
是一样的</li>
</ul>
<h2 id="论文">论文</h2>
<ul>
<li>Teran et al. 2003. <em>Finite Volume Methods for the Simulation of
Skeleton Muscles</em>. SCA.</li>
<li>Volino et al. 2009. <em>A Simple Approach to Nonlinear Tensile
Stiffness for Accurate Cloth Simulation</em>. TOG.</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.09.Collision Handling</title>
    <url>/2022/04/12/CG/WHM-GAMES103/09/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="碰撞处理">碰撞处理</h1>
<ul>
<li>理论不复杂，但是实际工程写起来不简单</li>
<li>衣服布料的碰撞处理是最复杂的</li>
<li>流程：<strong>碰撞检测</strong> <span class="math inline">\(\to\)</span> <strong>碰撞响应</strong></li>
<li><em>collision handling</em> = <em>collision detection</em> +
<em>collision response</em></li>
</ul>
<h1 id="碰撞检测">碰撞检测</h1>
<ul>
<li>collision detection</li>
<li>笔记中的三角形只是一个代称，也可以是其他的几何原体、物体</li>
</ul>
<h2 id="pipeline">Pipeline</h2>
<ul>
<li>碰撞检测的 pipeline</li>
</ul>
<p><img src="/2022/04/12/CG/WHM-GAMES103/09/image-20220412225604349.png" style="zoom:80%;"></p>
<ul>
<li>不可能两两的对所有的三角形做碰撞检测，复杂度太高了
<ul>
<li><span class="math inline">\(O(n^2)\)</span></li>
</ul></li>
<li>因此需要分成两个部分
<ul>
<li>第一部分：Broad-Phase Collision Culling
<ul>
<li>去除完全不可能产生碰撞的三角形对</li>
</ul></li>
<li>第二部分：Narrow-Phase Collision Test
<ul>
<li>对候选的三角形对进行碰撞检测</li>
</ul></li>
</ul></li>
<li>碰撞检测结束之后，进一步处理碰撞</li>
<li>Collision Culling 的两种基本套路
<ul>
<li>Spatial Hashing（空间划分）</li>
<li>BVH（层次包围盒）</li>
</ul></li>
</ul>
<h2 id="collision-culling">Collision Culling</h2>
<h3 id="spatial-hashing">Spatial Hashing</h3>
<ul>
<li>Spatial Partitioning</li>
<li>空间划分</li>
<li>将世界划分为格子，然后把三角形存到格子中
<ul>
<li>如果三角形和这个格子有相交，则将其存入</li>
</ul></li>
<li>例子</li>
</ul>
<p><img src="/2022/04/12/CG/WHM-GAMES103/09/image-20220412230413131.png" style="zoom:80%;"></p>
<ul>
<li>此时可能产生碰撞的三角形对，一定存储相同的格子中
<ul>
<li>例如上面可能和 <span class="math inline">\(t_3\)</span>
产生碰撞的三角形只有 <span class="math inline">\(t_0,t_5\)</span></li>
</ul></li>
<li>如果三角形是在运动的话，将整个运动轨迹作为一个物体，如果格子和这个运动轨迹相交，则将其存入格子</li>
</ul>
<p><img src="/2022/04/12/CG/WHM-GAMES103/09/image-20220412230848250.png" style="zoom:80%;"></p>
<ul>
<li>实际操作可以在空间划分中做层次扩展
<ul>
<li>例如八叉树（Octree）</li>
</ul></li>
<li>问题：内存浪费严重
<ul>
<li>划分的格子可能很多</li>
<li>每一个格子中保存的三角形数目不确定
<ul>
<li>可能有少量格子中有大量三角形</li>
<li>绝大部分格子中都是空的</li>
</ul></li>
</ul></li>
<li>可以不事先分配内存，而是以三角形为基础建立（object-cell list）
<ul>
<li>先列出三角形所在的格子，形成 pair（<span class="math inline">\(t_i,\text{position}\)</span>），然后排序
<ul>
<li>根据相同的格子 id 中找出可能产生碰撞的三角形对</li>
</ul></li>
<li>占用内存较小，和三角形的数目相当</li>
</ul></li>
</ul>
<p><img src="/2022/04/12/CG/WHM-GAMES103/09/image-20220412234352198.png" style="zoom:80%;"></p>
<h4 id="morton-code">Morton Code</h4>
<ul>
<li>如何定义格子的 id</li>
<li>因为 cache 的存在，我们希望内存访问是相对连续的</li>
<li>morton code
<ul>
<li>目的就是让两次内存访问的地址更加接近，更好的利用缓存的局部性（locality）</li>
</ul></li>
<li>以 <code>Z</code> 字形为基础，不断细分</li>
</ul>
<p><img src="/2022/04/12/CG/WHM-GAMES103/09/image-20220412234804962.png" style="zoom:80%;"></p>
<ul>
<li>拼接 <code>XY</code>
轴，按照拼接形成的数字大小排序，形成一个顺序</li>
</ul>
<p><img src="/2022/04/12/CG/WHM-GAMES103/09/Z-curve.svg"></p>
<ul>
<li><a href="https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-32-broad-phase-collision-detection-cuda">cuda
上面的基于空间划分的碰撞检测</a></li>
</ul>
<h3 id="bvh">BVH</h3>
<ul>
<li>Bounding Volume Hierarchy</li>
<li>根据物体的拓扑结构，对物体进行层次划分</li>
</ul>
<p><img src="/2022/04/12/CG/WHM-GAMES103/09/image-20220412235719846.png"></p>
<ul>
<li>使用包围盒的目的
<ul>
<li>优化碰撞检测，如果包围盒都不相交，那么包围盒中的物体也不会相交</li>
</ul></li>
</ul>
<h4 id="包围盒类型">包围盒类型</h4>
<ul>
<li>AABB：axis-aligned bounding box
<ul>
<li>AABB 相交当且仅当每一个轴上都相交</li>
</ul></li>
<li>OBB：oriented bounding box</li>
<li>sphere</li>
</ul>
<h4 id="碰撞检测-1">碰撞检测</h4>
<ul>
<li>物体和 BVH 的碰撞检测流程
<ul>
<li>和根节点进行碰撞检测
<ul>
<li>如果有碰撞，递归的对子结点进行碰撞检测</li>
<li>如果没有碰撞，则没有碰撞</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/04/12/CG/WHM-GAMES103/09/image-20220417132144418.png" style="zoom:80%;"></p>
<h4 id="自相交的碰撞检测">自相交的碰撞检测</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以 A 为根节点的子树内部相交</span></span><br><span class="line"><span class="built_in">Process_Node</span>(A) &#123;</span><br><span class="line">    For every A’s child: <span class="function">B</span></span><br><span class="line"><span class="function">        <span class="title">Process_Node</span><span class="params">(B)</span></span>;</span><br><span class="line">    For every A’s children pair &lt;B, C&gt;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> B <span class="keyword">and</span> C intersect</span></span><br><span class="line"><span class="function">            <span class="title">Process_Pair</span><span class="params">(B, C)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 B,C 为根节点的子树之间相交</span></span><br><span class="line"><span class="built_in">Process_Pair</span>(B, C) &#123;</span><br><span class="line">    For every B’s child: B’</span><br><span class="line">        For every C’s child: C’</span><br><span class="line">            <span class="keyword">if</span> B’ <span class="keyword">and</span> C’ <span class="function">intersect</span></span><br><span class="line"><span class="function">                <span class="title">Process_Pair</span><span class="params">(B’, C’)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="局限性">局限性</h4>
<ul>
<li>虽然能够很快的提出远处不相交的物体，但是对周围的物体（靠的比较近）很难剔除</li>
<li>基于能量（形变）的碰撞检测
<ul>
<li>Zheng and James. 2012. <em>Energy-based Self-Collision Culling for
Arbitrary Mesh Deformations</em>. TOG (SIGGRAPH)</li>
</ul></li>
</ul>
<h3 id="对比">对比</h3>
<ul>
<li>SH（Spatial Hashing）
<ul>
<li>很容易实现</li>
<li>GPU 友好</li>
<li>当物体移动的时候需要重新计算</li>
</ul></li>
<li>BVH
<ul>
<li>实现复杂</li>
<li>GPU 不友好（对树结构不太友好）</li>
<li>更新起来比较简单（只需要更新 BV）</li>
</ul></li>
</ul>
<h2 id="collision-test">Collision Test</h2>
<p><img src="/2022/04/12/CG/WHM-GAMES103/09/image-20220417133958489.png" style="zoom:80%;"></p>
<ul>
<li>DCD：Discrete Collision Detection
<ul>
<li>离散碰撞检测</li>
<li>基本检测单位为 <code>edge-triangles</code> 对</li>
</ul></li>
<li>CCD：Continuous Collision Detection
<ul>
<li>连续碰撞检测</li>
<li>基本检测单位为 <code>vertex-triangle</code> 对和
<code>edge-edge</code> 对</li>
</ul></li>
</ul>
<h3 id="dcd">DCD</h3>
<ul>
<li>在每一个离散的时刻上检测是否存在碰撞
<ul>
<li>DCD tests if any intersection exists in each state at discrete time
instant: <span class="math inline">\(\mathbf{x}^{[0]},\mathbf{x}^{[1]},\cdots\)</span></li>
</ul></li>
<li>基本检测：边——三角形
<ul>
<li>检测边和三角形是否相交</li>
<li>线段 <span class="math inline">\(\mathbf{x}_{a}\mathbf{x}_{b}\)</span>
上任意一点可以表示为 <span class="math inline">\((1-t)\mathbf{x}_{a}+t\mathbf{x}_{b},t\in[0,1]\)</span></li>
</ul></li>
</ul>
<p><img src="/2022/04/12/CG/WHM-GAMES103/09/image-20220417134507721.png" style="zoom:80%;"></p>
<h4 id="问题">问题</h4>
<ul>
<li>问题：两个相邻的时刻 <span class="math inline">\(\mathbf{x}^{[0]},\mathbf{x}^{[1]}\)</span>
都不相交，但是实际上在这两个时刻之间发生了相交</li>
<li>上面这种情况的碰撞通过 DCD 检测不出来</li>
<li>示例：绿色三角形向下移动、蓝色三角形向上移动</li>
</ul>
<p><img src="/2022/04/12/CG/WHM-GAMES103/09/image-20220417135546324.png" style="zoom:80%;"></p>
<ul>
<li>优点：高效、简单、稳定</li>
<li>问题：
<ul>
<li>tunneling effects：隧穿效应</li>
<li>运动太快会出现这种问题
<ul>
<li>尤其是比较小、比较薄的物体，例如布料穿墙</li>
</ul></li>
<li>解决：要求物体运动的不能太快、减小时间步长</li>
</ul></li>
</ul>
<h3 id="ccd">CCD</h3>
<ul>
<li>检测任意的两个离散状态之间有没有相交（真正的碰撞检测）
<ul>
<li>CCD tests if any intersection exists between two states: <span class="math inline">\(\mathbf{x}^{[0]}\)</span> and <span class="math inline">\(\mathbf{x}^{[1]}\)</span></li>
</ul></li>
<li>基本检测：点——三角形检测、边——边检测</li>
<li>点——三角形检测：<strong>四点共面检测</strong>
<ul>
<li>比 DCD 复杂，第一步需要求解一个一元三次方程
<ul>
<li>求解尽量不要用求根公式，而使用<strong>二分法</strong>/牛顿法等数值方法</li>
<li>求根公式中的 <span class="math inline">\(x^{1/3}\)</span>
一项误差很大</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/04/12/CG/WHM-GAMES103/09/image-20220417140128294.png" style="zoom:80%;"></p>
<ul>
<li>边——边检测
<ul>
<li>先检测是否共面，在检测是否在内部相交</li>
</ul></li>
</ul>
<p><img src="/2022/04/12/CG/WHM-GAMES103/09/image-20220417140731014.png" style="zoom:80%;"></p>
<ul>
<li>只做<strong>点——三角形</strong>检测不行
<ul>
<li>六芒星：红色向屏幕内移动、蓝色向屏幕外移动</li>
</ul></li>
</ul>
<p><img src="/2022/04/12/CG/WHM-GAMES103/09/image-20220417141446762.png" style="zoom:80%;"></p>
<h4 id="问题-1">问题</h4>
<ul>
<li>实现相对困难</li>
<li>计算复杂度比 DCD 要大
<ul>
<li>有些观点：瓶颈在 collision culling 部分</li>
</ul></li>
<li>浮点精度的问题，计算误差大
<ul>
<li>可以使用 epsilon，放宽限制 <span class="math inline">\(t\in[-\epsilon,1+\epsilon]\)</span>
<ul>
<li>可能会导致 false positive</li>
</ul></li>
<li>游戏的 GPU 以单精度浮点数 float 为主</li>
</ul></li>
</ul>
<h3 id="课后阅读">课后阅读</h3>
<ul>
<li>Bridson et al. 2002. <em>Robust Treatment of Collisions, Contact and
Friction for Cloth Animation. TOG (SIGGRAPH)</em>.</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.09.Collision Handling(1)</title>
    <url>/2022/04/17/CG/WHM-GAMES103/09-1/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="碰撞响应">碰撞响应</h1>
<ul>
<li>检测到有碰撞之后如何处理？</li>
</ul>
<h1 id="ccd">CCD</h1>
<ul>
<li>我们想要在当前时刻将所有的状态都更新为没有碰撞的状态</li>
</ul>
<h2 id="两种处理方法">两种处理方法</h2>
<p><img src="/2022/04/17/CG/WHM-GAMES103/09-1/image-20220417142652017.png"></p>
<ul>
<li>当前时刻 <span class="math inline">\(\mathbf{x}^{[0]}\)</span>
不相交，模拟出来得到的下一时刻 <span class="math inline">\(\mathbf{x}^{[1]}\)</span> 是相交的</li>
<li>我们的目标：把 <span class="math inline">\(\mathbf{x}^{[1]}\)</span>
优化到不相交的地方 <span class="math inline">\(\bar{\mathbf{x}}^{[0]}\)</span>
<ul>
<li>内点法：从 <span class="math inline">\(\mathbf{x}^{[0]}\)</span>
出发，找到距离目标 <span class="math inline">\(\mathbf{x}^{[1]}\)</span>
最近的优化点
<ul>
<li>整个查找过程中的点都保证是在安全区域内的</li>
</ul></li>
<li>Impact Zone Optimization：从 <span class="math inline">\(\mathbf{x}^{[1]}\)</span>
出发，是的最终回到安全区域内
<ul>
<li>过程中的点是不安全的</li>
</ul></li>
</ul></li>
</ul>
<h3 id="评价">评价</h3>
<ul>
<li>内点法(Interior Point Methods)
<ul>
<li>计算的慢
<ul>
<li>一开始距离目标结果远</li>
<li>需要处理所有的顶点</li>
<li>小步长模拟</li>
</ul></li>
<li>永远都可以找到正确结果
<ul>
<li>过程中的点都是安全的</li>
<li>可以找到一个可以接受的解，即使没有计算到收敛</li>
</ul></li>
</ul></li>
<li>Impact Zone Optimization
<ul>
<li>计算的很快
<ul>
<li>距离目标结果近</li>
<li>只需要处理部分点（碰撞的点占少数）</li>
<li>可以使用大步长</li>
</ul></li>
<li>不一定能够成功</li>
</ul></li>
</ul>
<h2 id="interior-point-methods">Interior Point Methods</h2>
<h3 id="log-barrier-interior-point-methods">Log-Barrier Interior Point
Methods</h3>
<ul>
<li>定义一个基于 log 的距离函数的能量
<ul>
<li>距离为 0 的时候，力是无穷大的
<ul>
<li>黄线表示截断，限制力的作用范围</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/04/17/CG/WHM-GAMES103/09-1/image-20220417144205982.png" style="zoom:80%;"></p>
<ul>
<li>实现：定义一个优化的目标函数，优化它即可
<ul>
<li>具体的优化方法，可以选择其他的方法（不一定是得梯度下降法）</li>
</ul></li>
</ul>
<p><img src="/2022/04/17/CG/WHM-GAMES103/09-1/image-20220417144625122.png" style="zoom:80%;"></p>
<ul>
<li>步长 <span class="math inline">\(\alpha\)</span>，需要保证没有碰撞发生
<ul>
<li>需要碰撞检测</li>
</ul></li>
</ul>
<h2 id="impact-zone-optimizationskip">Impact Zone
Optimization(skip)</h2>
<ul>
<li>基于约束的优化</li>
<li>试图去将当前点更新到碰撞安全的区域（collision-free zone）
<ul>
<li>可能会因为 tunneling issue 出现问题，但是不常见</li>
</ul></li>
<li>优化目标：到 <span class="math inline">\(\mathbf{x}^{[1]}\)</span>
距离最小</li>
<li>约束条件：不相交
<ul>
<li>约束一：点在平面上方</li>
<li>约束二：一条边在另一条边上方，<span class="math inline">\(\mathbf{N}\)</span> 对应另一条边的法线</li>
</ul></li>
</ul>
<p><img src="/2022/04/17/CG/WHM-GAMES103/09-1/image-20220417164630241.png" style="zoom:80%;"></p>
<ul>
<li>利用上面的约束条件一步步更新位置
<ul>
<li>使用迭代方法更新：Jacobi / Gauss-Seidel</li>
</ul></li>
</ul>
<p><img src="/2022/04/17/CG/WHM-GAMES103/09-1/image-20220417171255629.png" style="zoom:80%;"></p>
<h3 id="augmented-lagrangian">Augmented Lagrangian</h3>
<ul>
<li>拉格朗日法
<ul>
<li>Tang et al. 2018. <em>I-Cloth: Incremental Collision Handling for
GPU-Based Interactive Cloth Simulation</em>. TOG. (SIGGRAPH Asia)</li>
<li><a href="https://min-tang.github.io/home/ICloth/">主页</a></li>
</ul></li>
</ul>
<p><img src="/2022/04/17/CG/WHM-GAMES103/09-1/image-20220417171525199.png" style="zoom:80%;"></p>
<ul>
<li>评价</li>
</ul>
<p><img src="/2022/04/17/CG/WHM-GAMES103/09-1/image-20220417171627076.png" style="zoom:80%;"></p>
<ul>
<li>小步长促进收敛</li>
</ul>
<p><img src="/2022/04/17/CG/WHM-GAMES103/09-1/image-20220417171729308.png" style="zoom:80%;"></p>
<h2 id="rigid-impact-zone">Rigid Impact Zone</h2>
<ul>
<li>经过前面的碰撞处理之后，发现还是有碰撞，那么就不处理
<ul>
<li>不处理：保持和上一帧一样</li>
</ul></li>
<li>把整个区域当作刚体</li>
<li>很简单、很安全，但是会有可见的 artifacts</li>
<li>问题很多：现在的论文用的少</li>
</ul>
<h2 id="一个思路">一个思路</h2>
<ul>
<li>先使用 Impace Zone Optimization，因为很快</li>
<li>如果解决不了，要么尝试内点法，要么就什么都不做</li>
</ul>
<p><img src="/2022/04/17/CG/WHM-GAMES103/09-1/image-20220417145524092.png" style="zoom:80%;"></p>
<h1 id="dcd">DCD</h1>
<ul>
<li>不关心碰撞，只是看相交</li>
<li>允许处理完后，在这一帧中还有相交存在，希望接下来几帧能够解决</li>
</ul>
<h2 id="intersection-elimination">Intersection Elimination</h2>
<ul>
<li>相交解除</li>
</ul>
<p><img src="/2022/04/17/CG/WHM-GAMES103/09-1/image-20220417150205044.png" style="zoom:80%;"></p>
<ul>
<li>思路
<ul>
<li>如果这一帧出现了相交，则试图去解除相交
<ul>
<li>如果解除了，那么就完成了</li>
<li>如果解除不了，下一帧继续</li>
</ul></li>
</ul></li>
<li>前面的碰撞处理都失败了，这也可以作为一个后续方案</li>
<li>如果有一个是有体积的，则比较简单，将物体推到有体积的物体外部即可（可以定义一个
SDF 实现）
<ul>
<li>例如：volume-volume，cloth-volume</li>
<li>示意图</li>
</ul></li>
</ul>
<p><img src="/2022/04/17/CG/WHM-GAMES103/09-1/image-20220417150259259.png" style="zoom:80%;"></p>
<ul>
<li>布料的相交就没有办法使用上面的方法
<ul>
<li>不是封闭曲面，无法定义 SDF</li>
<li>布料没有内外的概念</li>
</ul></li>
</ul>
<h2 id="untangling-cloth">Untangling Cloth</h2>
<h3 id="分段">分段</h3>
<ul>
<li>Baraff et al. 2003. Untangling Cloth. TOG (SIGGRAPH)</li>
<li>利用相交将布料分段，认为小的那一段时产生相交的区域，将其拉回来</li>
</ul>
<p><img src="/2022/04/17/CG/WHM-GAMES103/09-1/image-20220417161347464.png" style="zoom:80%;"></p>
<ul>
<li>相交解除</li>
</ul>
<p><img src="/2022/04/17/CG/WHM-GAMES103/09-1/image-20220417161421527.png" style="zoom:80%;"></p>
<ul>
<li>效果（2D 就是面积）</li>
</ul>
<p><img src="/2022/04/17/CG/WHM-GAMES103/09-1/image-20220417161539666.png" style="zoom:80%;"></p>
<ul>
<li>问题
<ul>
<li>对边界的处理不是很好</li>
<li>不容易在 GPU 上实现，分块的时候需要对整个面进行评估</li>
</ul></li>
</ul>
<h3 id="缩小相交曲线长度">缩小相交曲线长度</h3>
<ul>
<li>论文
<ul>
<li>Volino and Magnenat-Thalmann et al. 2006. <em>Resolving Surface
Collisions through Intersection Contour Minimization. TOG
(SIGGRAPH)</em>.</li>
</ul></li>
<li>思路
<ul>
<li>两块布料相交的时候会形成一块区域，论文试图去减小围城这块区域的曲线的长度（周长）</li>
</ul></li>
</ul>
<p><img src="/2022/04/17/CG/WHM-GAMES103/09-1/image-20220417163908319.png" style="zoom:80%;"></p>
<ul>
<li>GPU 友好</li>
<li>可以处理边界（但是不是都处理得很好）</li>
</ul>
<h1 id="其他">其他</h1>
<ul>
<li>处理摩擦
<ul>
<li>一种方法是简单的先处理完碰撞，然后再处理摩擦，精度低，速度快</li>
<li>碰撞和摩擦一起处理，处理复杂</li>
</ul></li>
<li>刚体、不可形变的、有体积的物体的碰撞处理简单很多</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.10.Surface Waves</title>
    <url>/2022/04/18/CG/WHM-GAMES103/10/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="流体模拟">流体模拟</h1>
<ul>
<li>Waves: An introduction to fluid simulation</li>
<li>流体呈现的形态是各种各样的，因此很难有一个通用的模拟算法能够很有效率的、很好的模拟各种效果
<ul>
<li>水、烟雾等</li>
</ul></li>
</ul>
<h2 id="两种视角">两种视角</h2>
<ul>
<li>拉格朗日视角
<ul>
<li>物理变量是定义在随物体运动而运动的一些物质点上的</li>
<li>之前做的刚体、弹性体的模拟可以认为是拉格朗日视角的</li>
</ul></li>
<li>欧拉视角
<ul>
<li>物理变量定义在空间网格中（不随物体运动而运动）</li>
</ul></li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418201634518.png" style="zoom:80%;"></p>
<h2 id="高度场">高度场</h2>
<ul>
<li>高度场 <span class="math inline">\(h(x)\)</span>
<ul>
<li>定义每一个点的高度值</li>
</ul></li>
<li>2D 中，一般认为高度场是 <strong>1.5D</strong> 的
<ul>
<li>因为高度场只能够表达函数能够表示的形式，是受限制的</li>
<li>不能表示非函数形式，例如一个 <span class="math inline">\(x\)</span>
对应多个 <span class="math inline">\(y\)</span> 值</li>
</ul></li>
<li>速度（场）
<ul>
<li>带方向，决定流体的流向</li>
</ul></li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418202303576.png" style="zoom:80%;"></p>
<h2 id="shallow-wave-equation">Shallow Wave Equation</h2>
<ul>
<li>论文：Kass and Miller. 1990. <em>Rapid, Stable Fluid Dynamics for
Computer Graphics</em>. Computer Graphics.</li>
</ul>
<h3 id="高度场更新">高度场更新</h3>
<p><span class="math display">\[
\dfrac{\mathrm{d}h(x)}{\mathrm{d}t}+\dfrac{\mathrm{d}(h(x)u(x))}{\mathrm{d}x}=0
\]</span></p>
<ul>
<li>从微分的定义去理解
<ul>
<li><strong>体积的减小</strong>等于<strong>这一个点向外输送的流体体积</strong></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;-\Big(h(x+\mathrm{d}x)u(x+\mathrm{d}x)\cdot\mathrm{d}t-h(x)u(x)\cdot\mathrm{d}t\Big)\\
=&amp;(h(x+\mathrm{d}x)-h(x))\cdot\mathrm{d}x\\
\Longrightarrow&amp;-\mathrm{d}(h(x)u(x))\cdot\mathrm{d}t=\mathrm{d}h(x)\cdot\mathrm{d}x\\
\end{aligned}
\]</span></p>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418202658906.png" style="zoom:80%;"></p>
<h3 id="速度场更新">速度场更新</h3>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418204200083.png" style="zoom:80%;"></p>
<ul>
<li>由好几个部分构成
<ul>
<li>advection：水流的速度会随着自身的运动被带走
<ul>
<li>想象某一个粒子，他的位置会随水流变化
<ul>
<li>上一时刻 <span class="math inline">\(x\)</span>
的速度，直接计算得到的并不是这一时刻 <span class="math inline">\(x\)</span> 的速度（位置变了）</li>
</ul></li>
</ul></li>
<li>external：外力
<ul>
<li>例如螺旋桨</li>
</ul></li>
<li>这里主要分析的部分</li>
</ul></li>
<li>不考虑 advection、external，我们得到如下的简化式子</li>
</ul>
<p><span class="math display">\[
\dfrac{\mathrm{d}u(x)}{\mathrm{d}t}=-\dfrac{1}{\rho}\dfrac{\mathrm{d}P(x)}{\mathrm{d}x}
\]</span></p>
<ul>
<li>物理量
<ul>
<li><span class="math inline">\(\rho\)</span>：密度</li>
<li><span class="math inline">\(P(x)\)</span>：压强</li>
</ul></li>
<li>直观理解
<ul>
<li><span class="math inline">\(P(x+\mathrm{d}x)\)</span>
大，则这个点的速度 <span class="math inline">\(u(x)\)</span> 减小 <span class="math inline">\(\to\)</span> 需要加一个负号</li>
<li><span class="math inline">\(\rho\)</span> 越大，越难推动</li>
<li><strong>量纲</strong></li>
</ul></li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418204628090.png" style="zoom:80%;"></p>
<ul>
<li>具体物理推导：牛顿第二定律
<ul>
<li>二维的，可以认为 <span class="math inline">\(\mathrm{d}V=h(x)\mathrm{d}x\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
P(x+\mathrm{d}x)=\rho gh(x+\mathrm{d}x)
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\dfrac{\mathrm{d}u(x)}{\mathrm{d}t}&amp;=a(x)\\
&amp;=-\dfrac{(\rho gh(x+\mathrm{d}x)-\rho gh(x))\cdot h(x)}{\rho
h(x)\mathrm{d}x}\\
&amp;=-\dfrac{\mathrm{d}P(x)}{\rho \mathrm{d}x}\\
\end{aligned}
\]</span></p>
<h3 id="shallow-wave-equation-1">Shallow Wave Equation</h3>
<ul>
<li>根据两个公式进行更新</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
\dfrac{\mathrm{d}h(x)}{\mathrm{d}t}+\dfrac{\mathrm{d}(h(x)u(x))}{\mathrm{d}x}=0\\
\dfrac{\mathrm{d}u(x)}{\mathrm{d}t}=-\dfrac{1}{\rho}\dfrac{\mathrm{d}P(x)}
{\mathrm{d}x}
\end{array}
\]</span></p>
<ul>
<li>Shallow Wave Equation
<ul>
<li>假设波很小，产生的都是小水波 <span class="math inline">\(\Rightarrow\dfrac{\mathrm{d}h}{\mathrm{d}x}\approx0\)</span></li>
<li>忽略高阶小项 <span class="math inline">\(\dfrac{\mathrm{d}h}{\mathrm{d}t}\cdot\dfrac{\mathrm{d}u}{\mathrm{d}x}\)</span></li>
</ul></li>
<li>链式法则展开</li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418210253952.png" style="zoom:80%;"></p>
<ul>
<li>合并得到 Shallow Wave Equation
<ul>
<li>好处是不用管速度场了</li>
</ul></li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418210654078.png" style="zoom:80%;"></p>
<ul>
<li>此时问题转变成了对上述方程的离散化求解</li>
</ul>
<h3 id="离散化">离散化</h3>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418211308148.png" style="zoom:80%;"></p>
<ul>
<li>如何将上面的微分算子和离散化之后的高度对应起来？</li>
</ul>
<h3 id="有限差分">有限差分</h3>
<h4 id="一阶导数">一阶导数</h4>
<ul>
<li>finite differencing</li>
<li>一阶近似：前向差分、后向差分</li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418211540863.png" style="zoom:80%;"></p>
<ul>
<li>二阶近似：中心差分</li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418211649584.png" style="zoom:80%;"></p>
<h4 id="二阶导数">二阶导数</h4>
<ul>
<li>先计算出来一阶导数，然后再计算二阶导数</li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418212102618.png" style="zoom:80%;"></p>
<ul>
<li>一维拉普拉斯算子：<span class="math inline">\([1,-2,1]\)</span></li>
<li>类似的可以计算：<span class="math inline">\(\dfrac{\mathrm{d}^2P(x)}{\mathrm{d}x^2}\)</span></li>
</ul>
<h3 id="离散化的-sw-方程">离散化的 SW 方程</h3>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418212502056.png" style="zoom:80%;"></p>
<ul>
<li>得到了一个离散化之后的 <span class="math inline">\(h(x)\)</span>
的更新函数</li>
</ul>
<h3 id="volume-preservation">Volume Preservation</h3>
<ul>
<li>保持水的体积不变（算法问题会导致体积变化）</li>
<li>保持水的体积不变：<span class="math inline">\(\sum_{i}h_i(t)=\sum_{i}h_i(t-\Delta
t)\)</span></li>
<li>算法问题：黄色部分不能保证为零</li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418212831018.png" style="zoom:80%;"></p>
<h4 id="solution1">solution1</h4>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418213034386.png" style="zoom:80%;"></p>
<ul>
<li>直观理解：<span class="math inline">\(h_{i}\)</span> 和 <span class="math inline">\(h_{i+1}\)</span> 的交换量相同</li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418213200765.png" style="zoom:80%;"></p>
<h4 id="solution2">solution2</h4>
<ul>
<li>使用常数替代 <span class="math inline">\(h_i\)</span></li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418221821541.png" style="zoom:80%;"></p>
<h3 id="压强">压强</h3>
<p><span class="math display">\[
P_i=\rho gh_i
\]</span></p>
<ul>
<li>替换 <span class="math inline">\(p_i\)</span></li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418222008762.png" style="zoom:80%;"></p>
<h3 id="viscosity">Viscosity</h3>
<ul>
<li>流体中的阻尼：粘滞</li>
<li>类似于阻尼控制动量的变化 <span class="math inline">\(v_i(t_0)-v_i(t_0-\Delta t)\)</span></li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418222211835.png" style="zoom:80%;"></p>
<h3 id="整体算法">整体算法</h3>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418222433481.png" style="zoom:80%;"></p>
<h2 id="其他细节">其他细节</h2>
<h3 id="边界处理">边界处理</h3>
<ul>
<li>Dirichlet boundary
<ul>
<li>模拟范围外的高度都为一个常数（<strong>空气墙</strong>）</li>
<li>一般用于模拟开放的水面（很大的海面）</li>
</ul></li>
<li>Neumann boundary
<ul>
<li>边界上的一阶导数为 0，边界没有流体交换（<strong>实体墙</strong>）
<ul>
<li>无限高的边界，水出不来</li>
</ul></li>
<li>一般用于模拟小的水面</li>
</ul></li>
</ul>
<h4 id="neumann-boundary-算法">neumann boundary 算法</h4>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418223206575.png" style="zoom:80%;"></p>
<h4 id="d">3D</h4>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418223445620.png" style="zoom:80%;"></p>
<h3 id="two-way-coupling">Two-Way Coupling</h3>
<ul>
<li>如何处理流体和其他物体的交互？
<ul>
<li>流体与刚体、流体与气泡</li>
</ul></li>
<li>Two-Way Coupling：影响是相互的
<ul>
<li>液体对小方块有浮力</li>
<li>小方块会把水排出去</li>
</ul></li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418223722975.png" style="zoom:80%;"></p>
<h4 id="方块对流体">方块对流体</h4>
<ul>
<li>关键问题：计算排水</li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418223847963.png" style="zoom:80%;"></p>
<ul>
<li>如何排水？
<ul>
<li>直接加到周围邻居的格子（当小方块占据空间很大时，不容易计算周围格子）</li>
<li>添加虚拟高度（因为我们就是利用高度查进行水面模拟的）</li>
</ul></li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418224115486.png" style="zoom:80%;"></p>
<ul>
<li>虚拟高度如何确定？如何计算虚拟高度使其排出定量的水？
<ul>
<li><span class="math inline">\(h_i^{\text{real_new}}=h_i-e_i\)</span></li>
<li><span class="math inline">\(e_i\)</span>：排水的高度（灰色部分）</li>
<li><span class="math inline">\(v_i\)</span>：增加的虚拟高度（绿色部分）</li>
<li><span class="math inline">\(h_i^{new}\)</span>：不添加虚拟高度模拟得到的结果</li>
</ul></li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418224357672.png" style="zoom:80%;"></p>
<ul>
<li>求解 <span class="math inline">\(v_i,v_{i+1}\)</span></li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418224943684.png" style="zoom:80%;"></p>
<ul>
<li>我们允许拖动小方块，因此需要排水的位置 <span class="math inline">\(i\)</span> 会变化，使用如下统一形式描述</li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418225304050.png" style="zoom:80%;"></p>
<ul>
<li>设置需要排水的位置的 <span class="math inline">\(b_i\)</span>，添加需要排水位置的 mask/tag</li>
<li>作业中使用共轭梯度法（PCG_Solver）求解</li>
<li>算法</li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418225557325.png" style="zoom:80%;"></p>
<ul>
<li>添加一个系数 <span class="math inline">\(\gamma\)</span>
<ul>
<li>当我们快速拖动小方块的时候，会发现水浪特别大</li>
<li>因为我们使用显示积分的方式计算，具有不稳定性</li>
<li>添加系数不是物理正确的，但是能够让模拟<strong>看上去稳定</strong></li>
</ul></li>
</ul>
<h4 id="流体对方块">流体对方块</h4>
<ul>
<li>阿基米德定律：<span class="math inline">\(F_{浮力}=\rho
gV_{排}\)</span></li>
</ul>
<p><img src="/2022/04/18/CG/WHM-GAMES103/10/image-20220418230306099.png" style="zoom:80%;"></p>
<ul>
<li>需要考虑不同小格子对小方块的力，考虑这些力对方块的作用
<ul>
<li>移动、旋转（力矩）</li>
</ul></li>
<li>旋转的准确模拟可能需要使用<strong>隐式积分</strong>的方式
<ul>
<li>高度场的隐式积分是可以做的</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.11.Incompressible Fluid Dynamics and Eulerian Fluids(2)</title>
    <url>/2022/10/09/CG/WHM-GAMES103/11-1/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="navier-stokes-方程">Navier-Stokes 方程</h1>
<ul>
<li>Low-speed, Incompressible, Viscous Navier Stokes’ equations
<ul>
<li>低速、不可压缩、带有粘滞性的流体</li>
</ul></li>
</ul>
<h2 id="ns-方程">NS 方程</h2>
<ul>
<li>流体速度场的更新：NS 方程</li>
<li>不可压缩条件（Incompressibility）</li>
</ul>
<p><span class="math display">\[
\nabla\cdot\mathbf{u}=0
\]</span></p>
<ul>
<li>动量（Momentum）</li>
</ul>
<p><img src="/2022/10/09/CG/WHM-GAMES103/11-1/NS-equation-momentum.png"></p>
<ul>
<li>如何求解上述偏微分方程？
<ul>
<li><strong>Method of Characteristics</strong>：拆分 PDE
的不同部分，分步求解</li>
</ul></li>
</ul>
<p><img src="/2022/10/09/CG/WHM-GAMES103/11-1/Method-of%20-Characteristics.png"></p>
<h1 id="求解-ns-方程">求解 NS 方程</h1>
<h2 id="s1-external-acceleration">S1-External Acceleration</h2>
<ul>
<li>在这里我们先假设外部加速度只有重力加速度</li>
</ul>
<p><span class="math display">\[
\dfrac{\partial{\mathbf{u}}}{\partial{t}}=\mathbf{g}
\]</span></p>
<ul>
<li>对所有的墙更新 <span class="math inline">\(u,v\)</span></li>
</ul>
<p><span class="math display">\[
v_{i,j}^{new}\leftarrow v_{i,j}+\Delta tg
\]</span></p>
<h2 id="s2-advection">S2-Advection</h2>
<p><span class="math display">\[
\dfrac{\partial{\mathbf{u}}}{\partial{t}}=-(\mathbf{u}\cdot\nabla)\mathbf{u}
\]</span></p>
<ul>
<li>展开如下</li>
</ul>
<p><span class="math display">\[
(\mathbf{u}\cdot\nabla)\mathbf{u}=
\begin{pmatrix}
u\cdot\dfrac{\partial{u}}{\partial{x}}
+
v\cdot\dfrac{\partial{u}}{\partial{y}}\\
u\cdot\dfrac{\partial{v}}{\partial{x}}
+
v\cdot\dfrac{\partial{v}}{\partial{y}}\\
\end{pmatrix}
\]</span></p>
<ul>
<li>求解方式1：计算得到右边的值，然后类似于 S1 的方式求解
<ul>
<li><strong>不稳定</strong></li>
<li>原因：当时间步长 <span class="math inline">\(\Delta t\)</span>
比较大的时候，估算得到的一阶导数不准确</li>
</ul></li>
</ul>
<h3 id="advection">advection</h3>
<p><img src="/2022/10/09/CG/WHM-GAMES103/11-1/advection.png"></p>
<ul>
<li>由于水分子的流动，<span class="math inline">\(t\)</span>
时刻网格内的水分子不再是 <span class="math inline">\(t-\Delta t\)</span>
时刻的水分子，因此需要用新的水分子的速度替换掉原来的速度</li>
<li>如上图所示，<span class="math inline">\(\mathbf{x}_1\)</span>
位置的水分子是上一时刻在 <span class="math inline">\(\mathbf{x}_0\)</span> 位置的水分子，因此需要使用
<span class="math inline">\(\mathbf{x}_0\)</span> 位置水分子的速度 <span class="math inline">\(\mathbf{u}(\mathbf{x}_1)\)</span> 替换掉 <span class="math inline">\(\mathbf{u}(\mathbf{x}_1)\)</span></li>
<li>拉格朗日方法没有这个问题，因为本身就是定义在粒子上的，这一时刻的粒子和上一时刻的粒子是同一个</li>
</ul>
<h3 id="semi-lagrangion-method">Semi-Lagrangion Method</h3>
<ul>
<li>半拉格朗日方法</li>
<li>思路：对于一个点 <span class="math inline">\(\mathbf{x}_0\)</span>，推断上一个时刻这个点的位置
<span class="math inline">\(\mathbf{x}_1\)</span>，然后用 <span class="math inline">\(\mathbf{x}_1\)</span> 的速度替换掉即可
<ul>
<li>下面的 <em>comupte</em> 就是利用双线性插值计算</li>
</ul></li>
</ul>
<p><img src="/2022/10/09/CG/WHM-GAMES103/11-1/Semi-Lagrangion-Method.png"></p>
<ul>
<li>对于交错网格，<span class="math inline">\(u,v\)</span> 分开计算</li>
<li>细分：小步长精度更高
<ul>
<li>数值方法</li>
</ul></li>
</ul>
<p><img src="/2022/10/09/CG/WHM-GAMES103/11-1/Semi-Lagrangion-Method-subdivision.png"></p>
<ul>
<li>边界问题：倒推之后发现在边界怎么办？
<ul>
<li><em>clamp</em>，不让它越界</li>
</ul></li>
<li>是个稳定的方法，但是大的步长会有误差
<ul>
<li>误差表现为模糊（源自插值）</li>
</ul></li>
</ul>
<h2 id="s3-diffusion">S3-Diffusion</h2>
<p><span class="math display">\[
\dfrac{\partial{\mathbf{u}}}{\partial{t}}=\mu\Delta\mathbf{u}
\]</span></p>
<ul>
<li>分别对 <span class="math inline">\(u,v\)</span> 做拉普拉斯平滑</li>
</ul>
<p><img src="/2022/10/09/CG/WHM-GAMES103/11-1/laplacion.png"></p>
<ul>
<li>大步长可能会不稳定（<span class="math inline">\(v\Delta t\)</span>
太大）</li>
<li>使用小步长计算</li>
</ul>
<p><img src="/2022/10/09/CG/WHM-GAMES103/11-1/laplacion-small-steps.png"></p>
<ul>
<li>可以使用隐式积分来做
<ul>
<li>比较复杂，利用小步长也能做出类似效果</li>
</ul></li>
</ul>
<h2 id="s4-pressure-projection">S4-Pressure Projection</h2>
<ul>
<li>利用压强进行更新</li>
</ul>
<p><span class="math display">\[
\dfrac{\partial{\mathbf{u}}}{\partial{t}}=-\nabla\mathbf{p}
\]</span></p>
<ul>
<li>压强定义在网格中心，因此表达起来很方便</li>
</ul>
<p><img src="/2022/10/09/CG/WHM-GAMES103/11-1/pressure-projection.png"></p>
<h3 id="压强">压强</h3>
<ul>
<li>如何计算/更新 <span class="math inline">\(\mathbf{p}\)</span></li>
<li>压强产生的原因：<strong>流体是不可压缩的</strong></li>
<li>因此从散度为 0 开始推导（<span class="math inline">\(\Delta\mathbf{u}^{new}=0\)</span>）</li>
</ul>
<p><img src="/2022/10/09/CG/WHM-GAMES103/11-1/pressure-deduction.png"></p>
<ul>
<li>因此得到方程组，把所有的方程组联立求解线性系统</li>
<li>边界条件
<ul>
<li>Dirichlet boundary (open) <span class="math inline">\(p_{i-1,j}=P\)</span></li>
<li>Neumann boundary (close) <span class="math inline">\(p_{i-1,j}=p_{i,j}\)</span>
<ul>
<li>真实的墙</li>
</ul></li>
</ul></li>
<li>求解得到 <span class="math inline">\(p\)</span>
之后便能够计算得到速度 <span class="math inline">\(u,v\)</span></li>
<li>pressure projection
<ul>
<li>利用压强对速度进行投影，使得更新之后的速度满足不可压缩的条件</li>
</ul></li>
</ul>
<h2 id="参考实现">参考实现</h2>
<ul>
<li>Jos Stam. 1999. <em>Stable Fluids. TOG (SIGGRAPH)</em>.</li>
</ul>
<h1 id="air-and-smoke">Air and Smoke</h1>
<h2 id="烟雾模拟">烟雾模拟</h2>
<ul>
<li>烟雾模拟的两个步骤
<ul>
<li>Step 1：更新速度</li>
<li>Step 2：更新其他物理量
<ul>
<li>烟雾：颜色、密度</li>
<li>可以利用 Semi-Lagrangian 的方法更新，理解和 advection
类似，这些物理量都是会被例子带着走的，因此可以通过找到之前的位置，使这个位置的物理量进行更新</li>
</ul></li>
</ul></li>
<li>边界
<ul>
<li>开放空间：Dirichlet boundaries</li>
<li>密闭空间（container）：Neumann boundaries</li>
</ul></li>
</ul>
<h2 id="水的模拟">水的模拟</h2>
<ul>
<li>水的模拟比较复杂</li>
<li>水是有形状的，我们实际上模拟的是水和空气的表面，但是我们实际上只会模拟水而不是一起模拟水和空气</li>
<li>水在整个过程中并不会占满整个空间，只会占据一部分空间，如何表达部分空间的占用？</li>
<li>水有自己一套表达的方式</li>
</ul>
<h3 id="表达方式">表达方式</h3>
<ul>
<li>Volume-of-fluid（VoF）：体积的表达方式
<ul>
<li>划分为小格子，然后告诉你这个格子中被液体占据的百分比</li>
<li>不精准</li>
</ul></li>
<li>SDF：有向距离场
<ul>
<li>保存到水面的距离</li>
</ul></li>
</ul>
<h3 id="更新方式">更新方式</h3>
<ul>
<li>Semi-Lagrangian</li>
<li>Level set：对距离函数进行更新的一种方法</li>
<li>问题：volume loss issue
<ul>
<li>上面两种方法在模拟过程中水的体积会发生改变，因此需要修正</li>
</ul></li>
</ul>
<h3 id="导出数据">导出数据</h3>
<ul>
<li>如何将得到的体数据导出为 mesh 用于渲染
<ul>
<li>marching cube</li>
</ul></li>
</ul>
<h2 id="实现">实现</h2>
<ul>
<li><a href="https://www.zhihu.com/question/27850677/answer/2034502427">知乎
matlab 实现</a></li>
</ul>
<h3 id="流体仿真书籍">流体仿真书籍</h3>
<ul>
<li>Level Set Methods and Dynamic Implicit Surfaces.
<ul>
<li>Osher and Fedkiw.</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES103.王华民.11.Incompressible Fluid Dynamics and Eulerian Fluids</title>
    <url>/2022/06/04/CG/WHM-GAMES103/11/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV12Q4y1S73g">Bilibili
课程链接</a></li>
</ul>
<h1 id="网格表示和有限差分">网格表示和有限差分</h1>
<ul>
<li>A Grid Representation and Finite Differencing</li>
<li>Incompressible, Viscous Navier Stokes’ equations
<ul>
<li>不可压缩、带有粘滞性的流体</li>
</ul></li>
<li>空气（air）、液体（liquid）</li>
</ul>
<h2 id="规则网格表示">规则网格表示</h2>
<ul>
<li><p>regular grid representation</p></li>
<li><p>在不做简化的前提下，模拟二维的流体，需要使用一个二维数组来表示</p></li>
<li><p>每一个格子都是一样大的正方形</p></li>
<li><p>每一个网格里可以定义一些物理量，表示网格中心的性质</p>
<ul>
<li>标量：标量场
<ul>
<li>Density/color、Pressure、Temperature</li>
</ul></li>
<li>矢量：矢量场
<ul>
<li>Velocities</li>
</ul></li>
</ul></li>
<li><p>利用网格的离散性，容易实现计算导数、进行微分（差分）计算</p></li>
</ul>
<h2 id="中心差分">中心差分</h2>
<ul>
<li>是 2 阶的</li>
</ul>
<p><img src="/2022/06/04/CG/WHM-GAMES103/11/central-differencing.png"></p>
<ul>
<li>网格表示利于实现差分计算</li>
</ul>
<p><img src="/2022/06/04/CG/WHM-GAMES103/11/Finite-Differencing-on-Grid.png"></p>
<ul>
<li>从 1 阶导数到 2 阶导数
<ul>
<li>先计算 1 阶导数，再计算 2 阶导数</li>
</ul></li>
</ul>
<p><img src="/2022/06/04/CG/WHM-GAMES103/11/Finite-Differencing-on-Grid-2-order.png"></p>
<ul>
<li>拉普拉斯算子</li>
</ul>
<p><span class="math display">\[
\Delta
f_{i,j}=\dfrac{\partial^2{f_{i,j}}}{\partial{x^2}}+\dfrac{\partial^2{f_{i,j}}}{\partial{y^2}}
\approx\dfrac{f_{i-1,j}+f_{i+1,j}+f_{i,j-1}+f_{i,j+1}-4f_{i,j}}{h^2}
\]</span></p>
<h2 id="边界条件">边界条件</h2>
<ul>
<li>A Dirichlet boundary：<span class="math inline">\(f_{i-1,j}=C\)</span></li>
<li>A Neumann boundary：边界和邻近边界的点具有某种关系
<ul>
<li>例：<span class="math inline">\(f_{i-1,j}=f_{i,j}\)</span></li>
</ul></li>
</ul>
<h2 id="拉普拉斯方程">拉普拉斯方程</h2>
<ul>
<li><span class="math inline">\(\Delta f=0\)</span></li>
</ul>
<p><span class="math display">\[
f_{i-1,j}+f_{i+1,j}+f_{i,j-1}+f_{i,j+1}-4f_{i,j}=0
\]</span></p>
<ul>
<li>整个场上的任意点都满足这个条件
<ul>
<li>离散化则表示每一个网格都得满足拉普拉斯方程</li>
</ul></li>
<li>边界条件中至少得有一个是 Dirichlet 边界条件，不能都是 Neumann 边界
<ul>
<li>如果全是 Neumann 边界，则问题会有无穷多个解</li>
<li>对于一个合理解，每一个点都加上一个常数 C，则还是合理解</li>
</ul></li>
<li>求解拉普拉斯方程：Jacobi</li>
</ul>
<p><img src="/2022/06/04/CG/WHM-GAMES103/11/laplacian-the-jacobi-method.png"></p>
<ul>
<li>拉普拉斯平滑：Laplacian Smoothing
<ul>
<li>直观理解：把当前点和邻居的点做平均</li>
</ul></li>
</ul>
<h3 id="扩散">扩散</h3>
<ul>
<li>应用拉普拉斯平滑的过程，在仿真里面称为平滑</li>
</ul>
<h2 id="中心差分的问题">中心差分的问题</h2>
<ul>
<li>计算得到的一阶导数没有定义在网格的中心点上（计算出来的值是在边界上的）</li>
</ul>
<p><img src="/2022/06/04/CG/WHM-GAMES103/11/central-differencing-problems.png"></p>
<ul>
<li>利用 <span class="math inline">\(f_{i+1,j},f_{i-1,j}\)</span> 计算
<span class="math inline">\(\dfrac{\partial{f_{i,j}}}{\partial{x}}\)</span>
<ul>
<li>有点奇怪，对于当前点的一阶导数计算竟然没有用到这个点本身的值</li>
</ul></li>
<li>解决方案：没有必要把所有的变量都定义在网格中心，可以把一部分变量定义在墙（faces）上</li>
</ul>
<h2 id="staggered-grid">Staggered Grid</h2>
<ul>
<li>交错网格</li>
<li>把一些物理量定义在墙上</li>
</ul>
<p><img src="/2022/06/04/CG/WHM-GAMES103/11/staggered-grid.png"></p>
<ul>
<li><strong>速度</strong>
<ul>
<li>把 <em>x</em> 方向的速度（<em>u</em>）定义在竖直的墙上</li>
<li>把 <em>y</em> 方向的速度（<em>v</em>）定义在水平的墙上</li>
</ul></li>
<li>这样的定义可以把速度理解为流速：单位时间通过墙的液体量
<ul>
<li>在流体中很常见</li>
</ul></li>
<li>应用：计算格子的<strong>净流出量</strong></li>
</ul>
<p><span class="math display">\[
(u_{i+1,j}+v_{i,j+1}-u_{i,j}-v_{i,j})\cdot\Delta{t}
\]</span></p>
<ul>
<li>好处：<strong>很直观</strong>的表示水流的变换</li>
</ul>
<h2 id="divergence-free-condition">Divergence-Free Condition</h2>
<ul>
<li><strong>不可压缩流体</strong>：每一个点的散度为 0</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\nabla\cdot\mathbf{u}_{i,j}&amp;=0\\
&amp;=\dfrac{\partial{u_{i,j}}}{\partial{x}}+\dfrac{\partial{v_{i,j}}}{\partial{y}}\\
&amp;=\dfrac{u_{i+1,j}-u_{i,j}}{h}+\dfrac{v_{i,j+1}-v_{i,j}}{h}\\
\end{aligned}
\]</span></p>
<ul>
<li>每一个网格的净流入、净流出为 0</li>
</ul>
<p><span class="math display">\[
u_{i+1,j}+v_{i,j+1}-u_{i,j}-v_{i,j}=0
\]</span></p>
<h2 id="bilinear-interlation">Bilinear Interlation</h2>
<ul>
<li>双线性插值</li>
<li>定义在网格中心的物理量</li>
</ul>
<p><img src="/2022/06/04/CG/WHM-GAMES103/11/Bilinear-Interlation.png"></p>
<ul>
<li>对定义在墙上的物理量进行插值
<ul>
<li>类似</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES103</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>WHM</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101.闫令琪.00.课程介绍</title>
    <url>/2021/03/13/CG/YLQ-GAMES101/00/</url>
    <content><![CDATA[<h1 id="课程介绍">课程介绍</h1>
<ul>
<li>GAMES101：现代计算机图形学入门</li>
<li><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">课程主页</a></li>
<li>授课老师：闫令琪</li>
<li>视频地址：<a href="https://www.bilibili.com/video/av90798049">B站</a></li>
<li><a href="https://www.notion.so/GAMES101-WSL-ea56a93aa3614e0aba911e21193baa8d">WSL
配置</a></li>
<li>内容
<ul>
<li>Rasterization （光栅化）</li>
<li>Geometry（几何）</li>
<li>Ray Tracing （光线追踪）</li>
<li>Animation / Simulation（动画与模拟）</li>
</ul></li>
</ul>
<h1 id="其他信息">其他信息</h1>
<h2 id="games">GAMES</h2>
<ul>
<li>图形学在线交流平台</li>
<li>GAMES: Graphics And Mixed Environment Symposium</li>
<li><a href="http://games-cn.org">网站</a></li>
<li>线上活动：
<ul>
<li>每周四晚8:00-9:30《在线报告》</li>
<li>2020年2月开始推出《在线课程》</li>
<li>所有活动的视频及PPT都可在线学习和下载</li>
</ul></li>
</ul>
<h2 id="chinagraph">Chinagraph</h2>
<ul>
<li>学术会议：Chinagraph 2020（第十三届中国计算机图形学大会）</li>
<li><a href="https://chinagraph2020.xmu.edu.cn/">主页</a></li>
</ul>
<h2 id="chinavr">ChinaVR</h2>
<ul>
<li>学术会议：ChinaVR 2020（第二十届中国虚拟现实大会）</li>
<li>主页：https://www.chinavr.info</li>
</ul>
<h2 id="其他的渲染课程">其他的渲染课程</h2>
<ul>
<li>GAMES202（实时渲染）
<ul>
<li><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games202.html">课程主页</a></li>
</ul></li>
<li>离线渲染
<ul>
<li>Advanced Image Synthesis（高级图像合成）</li>
</ul></li>
</ul>
<h2 id="渲染">渲染</h2>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/00/image-20210402143533594.png" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>0</category>
        <category>CG</category>
        <category>CG.GAMES101</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101.闫令琪.01.Lecture(01-06)</title>
    <url>/2021/03/13/CG/YLQ-GAMES101/01/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/av90798049</li>
</ul>
<h1 id="lecture-01">Lecture 01</h1>
<ul>
<li>Overview of Computer Graphics</li>
<li>计算机图形学概述</li>
</ul>
<h1 id="lecture-02">Lecture 02</h1>
<ul>
<li>Review of Linear Algebra</li>
<li>向量与线性代数</li>
</ul>
<h1 id="lecture-03">Lecture 03</h1>
<ul>
<li>Transformation</li>
<li>变换（二维与三维）</li>
</ul>
<h2 id="基本变换">基本变换</h2>
<ul>
<li>scale、rotate、shear、reflection
<ul>
<li>放缩、旋转、错切、对称</li>
</ul></li>
<li>translate
<ul>
<li>平移</li>
</ul></li>
<li><strong>变换顺序</strong>很重要</li>
</ul>
<h2 id="齐次坐标">齐次坐标</h2>
<ul>
<li>统一表示所有变换</li>
</ul>
<h1 id="lecture-04">Lecture 04</h1>
<ul>
<li>Transform Cont.</li>
<li>变换（模型、视图、投影）</li>
</ul>
<h2 id="欧拉角">欧拉角</h2>
<ul>
<li>表示任意旋转</li>
</ul>
<p><span class="math display">\[
R_{xyz}(\alpha,\beta,\gamma)=R_x(\alpha)R_y(\beta)R_(\gamma)
\]</span></p>
<ul>
<li>roll, pitch, yaw</li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/01/1615626783481.png" style="zoom:80%;"></p>
<ul>
<li>存在万向锁问题</li>
</ul>
<h2 id="绕任意轴的旋转">绕任意轴的旋转</h2>
<ul>
<li>Rodrigues’ Rotation Formula</li>
<li><a href="/2021/01/31/CG/LS/05-2/">推导</a></li>
<li>绕过原点的单位轴 <span class="math inline">\(\mathbf{n}\)</span>
逆时针旋转 <span class="math inline">\(\alpha\)</span> 角度</li>
</ul>
<p><span class="math display">\[
\mathbf{R}(\mathbf{n}, \alpha)=\cos (\alpha) \mathbf{I}+(1-\cos
(\alpha)) \mathbf{n} \mathbf{n}^{T}+\sin
(\alpha)\left(\begin{array}{ccc} 0 &amp; -n_{z} &amp; n_{y} \\ n_{z}
&amp; 0 &amp; -n_{x} \\ -n_{y} &amp; n_{x} &amp; 0 \end{array}\right)
\]</span></p>
<h2 id="mvp-变换">MVP 变换</h2>
<ul>
<li>model、view、projection</li>
</ul>
<h3 id="camera-相机">camera 相机</h3>
<ul>
<li>Position
<ul>
<li><span class="math inline">\(\vec{e}\)</span></li>
</ul></li>
<li>Look-at / gaze direction
<ul>
<li><span class="math inline">\(\vec{g}\)</span></li>
</ul></li>
<li>Up direction
<ul>
<li><span class="math inline">\(\vec{t}\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/01/1615627477778.png" style="zoom:50%;"></p>
<ul>
<li>通常变换的结果
<ul>
<li>Position
<ul>
<li>原点</li>
</ul></li>
<li>Look-at / gaze direction
<ul>
<li><span class="math inline">\(-z\)</span></li>
</ul></li>
<li>Up direction
<ul>
<li><span class="math inline">\(y\)</span></li>
</ul></li>
</ul></li>
<li>变换的过程
<ul>
<li>位置移动到原点
<ul>
<li><span class="math inline">\(-\mathbf{Position_{camera}}\)</span></li>
</ul></li>
<li>旋转（正交变换）
<ul>
<li><a href="/2021/01/29/CG/LS/05/">推导</a></li>
</ul></li>
</ul></li>
</ul>
<h3 id="投影变换">投影变换</h3>
<ul>
<li>Perspective projection 透视投影</li>
<li>Orthographic projection 正交投影</li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/01/1615628267875.png" style="zoom: 70%;"></p>
<ul>
<li>透视变换：变换到 <span class="math inline">\([-1,+1]^3\)</span>
<ul>
<li>Frustum 转变为 Cuboid（<strong>近裁剪面一样大</strong>）</li>
<li>平移、放缩</li>
</ul></li>
</ul>
<p><span class="math display">\[
M_{persp} = M_{ortho}M_{persp\to ortho} =
M_{scale}M_{translate}M_{persp\to ortho}
\]</span></p>
<p><span class="math display">\[
M_{persp\to ortho}=
\begin{bmatrix}
n &amp; 0 &amp; 0 &amp; 0\\
0 &amp; n &amp; 0 &amp; 0\\
0 &amp; 0 &amp; n+f &amp; -nf\\
0 &amp; 0 &amp; 1 &amp; 0\\
\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
M_{scale}=
\begin{bmatrix}
\dfrac{2}{r-l} &amp; 0 &amp; 0 &amp; 0\\
0 &amp; \dfrac{2}{t-b} &amp; 0 &amp; 0\\
0 &amp; 0 &amp; \dfrac{2}{n-f} &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
M_{translate}
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; -\dfrac{r+l}{2}\\
0 &amp; 1 &amp; 0 &amp; -\dfrac{t+b}{2}\\
0 &amp; 0 &amp; 1 &amp; -\dfrac{n+f}{2}\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
M_{ortho}=
\begin{bmatrix}
\dfrac{2}{r-l} &amp; 0 &amp; 0 &amp; -\dfrac{r+l}{r-l}\\
0 &amp; \dfrac{2}{t-b} &amp; 0 &amp; -\dfrac{t+b}{t-b}\\
0 &amp; 0 &amp; \dfrac{2}{n-f} &amp; -\dfrac{n+f}{n-f}\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}
\]</span></p>
<ul>
<li>OpenGL 中 z 方向乘了个 <span class="math inline">\(-1\)</span>
<ul>
<li><a href="/2021/01/31/CG/LS/05-1/">OpenGL 中的推导</a></li>
</ul></li>
</ul>
<h3 id="计算出参数">计算出参数</h3>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/01/1615630292201.png" style="zoom:50%;"></p>
<ul>
<li><span style="color:red">Vertical</span>
<strong>Field-of-View</strong> (fov<span style="color:red">Y</span>)
<ul>
<li>一个角度值</li>
</ul></li>
<li>Aspect ratio
<ul>
<li>width / height</li>
</ul></li>
<li>通过 <span class="math inline">\(n,f,fovY,aspect\)</span> 计算出
<span class="math inline">\(l,r,b,t\)</span>
<ul>
<li><span class="math inline">\(t=|n|\times\tan\dfrac{fovY}{2}\)</span></li>
<li><span class="math inline">\(r=t\times aspect\)</span></li>
</ul></li>
</ul>
<h1 id="lecture-05">Lecture 05</h1>
<ul>
<li>Rasterization 1 (Triangles)</li>
<li>光栅化（三角形的离散化）</li>
</ul>
<h2 id="光栅化">光栅化</h2>
<ul>
<li>直接采样
<ul>
<li>实际上采样点的坐标应该是 <span class="math inline">\((x+0.5,y+0.5)\)</span>
<img src="/2021/03/13/CG/YLQ-GAMES101/01/1615637516517.png" style="zoom:50%;"></li>
<li>中心在三角形内，就设置为三角形的颜色
<ul>
<li>边缘出现走样的问题</li>
</ul></li>
</ul></li>
<li>怎么判断在三角形内部：<strong>叉乘</strong></li>
<li>点 P 在三角形 ABC 内部，以下三个结果同号</li>
</ul>
<p><span class="math display">\[
\vec{AP}\times\vec{AB},\vec{BP}\times\vec{BC},\vec{CP}\times\vec{CA}
\]</span></p>
<ul>
<li>点同时在 3 个向量 <span class="math inline">\(\vec{AB},\vec{BC},\vec{CA}\)</span> 的左边 /
右边</li>
</ul>
<h2 id="光栅化加速优化">光栅化加速优化</h2>
<ul>
<li>基于三角形覆盖的区域较小</li>
</ul>
<h3 id="包围盒技术">包围盒技术</h3>
<ul>
<li>不需要对所有的点进行判断，只需要对包围盒内的点进行判断</li>
<li>AABB 包围盒
<ul>
<li>Axis-Aligned Bounding Box</li>
<li>横平竖直</li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/01/1615638505359.png" style="zoom:50%;"></p>
<ul>
<li>AABB 包围盒技术失效
<ul>
<li>包围盒大，但是三角形小</li>
<li>三角形斜着放</li>
</ul></li>
<li>如下方法可以解决 AABB 失效的问题
<ul>
<li>适合瘦小、斜置的三角形</li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/01/1615638748203.png" style="zoom:50%;"></p>
<h2 id="光栅化显示技术">光栅化显示技术</h2>
<ul>
<li>隔行扫描
<ul>
<li>每帧只渲染一半</li>
<li>快、看不出来</li>
</ul></li>
<li>像素
<ul>
<li>我们认为是不可分的</li>
<li>实际上在显示设备上可能是由更小的像素（条/点）组成的</li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/01/1615638916808.png" style="zoom:50%;"></p>
<ul>
<li>bayer pattern（iPhone 6S）
<ul>
<li>像素内分布方式</li>
</ul></li>
<li>像素内<strong>绿色多</strong>，密度大，红蓝差不多
<ul>
<li>人眼对绿色敏感</li>
</ul></li>
<li>屏幕：加色系统（初始黑，全加白）</li>
<li>打印机：减色系统（初始白，全加黑）</li>
</ul>
<h1 id="lecture-06">Lecture 06</h1>
<ul>
<li>Rasterization 2 (Antialiasing and Z-Buffering)</li>
<li>光栅化（深度测试与抗锯齿）</li>
</ul>
<h2 id="采样问题">采样问题</h2>
<ul>
<li>Sampling <strong>Artifacts</strong> in Computer Graphics
<ul>
<li>看上去不太对的东西，瑕疵</li>
<li>Errors / Mistakes / Inaccuracies</li>
</ul></li>
<li>锯齿 Jaggies</li>
<li>摩尔纹 Moire
<ul>
<li>奇数行、奇数列去掉，变成小的图，但是显示仍然是和原来一样大</li>
<li>手机拍显示器的屏幕产生的摩尔纹</li>
</ul></li>
<li>Wagon Wheel Illusion (False Motion)
<ul>
<li>高速行驶的汽车倒转</li>
<li>人眼在时间中的采样跟不上运动速度</li>
</ul></li>
</ul>
<h3 id="信号与系统的观点">信号与系统的观点</h3>
<ul>
<li>原始图像的频率过高，采样频率跟不上，导致原始的图像不能恢复</li>
<li>采样定理
<ul>
<li>当采样频率大于信号中最高频率的2倍时，采样之后的数字信号完整地保留了原始信号中的信息</li>
<li>采样过慢，频域上有混叠</li>
</ul></li>
<li>反走样的方法
<ul>
<li>提高采样频率</li>
<li>降低原始图像的频率
<ul>
<li><strong>采样之前先做模糊化</strong></li>
</ul></li>
</ul></li>
<li>反走样方法：<strong>采样之前先做模糊化</strong>
<ul>
<li>先模糊，后采样 OK</li>
<li>先采样，后模糊 NO</li>
</ul></li>
<li>模糊
<ul>
<li>频域相乘 <span class="math inline">\(\Leftrightarrow\)</span>
时域卷积</li>
</ul></li>
<li>傅里叶变换到频域上可视化
<ul>
<li>中间水平竖直线，信号强</li>
<li>原因是我们分析图片的时候，会将其看成是重复的（一张一张放一起），边界部分极其高频</li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/01/1615639807145.png" style="zoom:50%;"></p>
<h2 id="anti-aliasing">Anti Aliasing</h2>
<ul>
<li>MSAA 增大了计算量
<ul>
<li>使用更多的点去判断是否在三角形内</li>
<li>最后通过在三角形内部的采样点的比例计算出近似的覆盖率</li>
</ul></li>
<li>MSAA
解决的是对信号的模糊操作，得到<strong>近似的覆盖率</strong>（<strong>不是增加分辨率</strong>）
<ul>
<li>有点的复用</li>
<li>例如打开 2x2 的 MSAA 之后，帧率不会变为原来的 <span class="math inline">\(\dfrac{1}{4}\)</span></li>
</ul></li>
<li>工业界近似采样率的得到，不同的
pattern，<strong>点的复用</strong>，提高效率
<ul>
<li>MSAA 是 2x2 的正方形 pattern</li>
</ul></li>
<li>FXAA
<ul>
<li>Fast Approximate AA</li>
<li>先得到有锯齿的图片，然后做后期处理去除锯齿（图像匹配等方法）</li>
<li>和采样无关，是在图形层面上的抗锯齿</li>
</ul></li>
<li>TAA
<ul>
<li>Temporal AA</li>
<li>时间，复用上一帧的感知，把 MSAA 的采样点分布到不同帧</li>
</ul></li>
<li>Super resolution / super sampling 超分辨率
<ul>
<li>From low resolution to high resolution</li>
<li>Essentially still "not enough samples" problem</li>
<li>DLSS (Deep Learning Super Sampling)</li>
</ul></li>
</ul>
<h2 id="可见性">可见性</h2>
<ul>
<li>画家算法：先排序，再绘制</li>
<li>问题：互相遮挡</li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/01/1615640549993.png" style="zoom: 67%;"></p>
<h2 id="z-buffer">Z-Buffer</h2>
<ul>
<li>Depth Buffer</li>
<li>深度缓存</li>
<li>复杂度：<span class="math inline">\(O(n)\)</span>
<ul>
<li>指绘制 n 个三角形，每个三角形只覆盖常数个像素</li>
</ul></li>
<li>如果配合 MSAA，则应该是每个采样点对应一个深度，而不是每个像素</li>
</ul>
<h2 id="阴影">阴影</h2>
<h3 id="shadow-mapping-算法">Shadow Mapping 算法</h3>
<ul>
<li>光栅化比较难处理<strong>全局现象</strong></li>
<li>图像空间的做法</li>
<li>有走样现象</li>
<li>思想：<strong>如果点不在阴影里，光源可以看到这个点</strong></li>
<li>经典的 shadow mapping 算法只能处理 <strong>点光源/平行光</strong>
的阴影
<ul>
<li><strong>硬阴影</strong></li>
<li>非 0 即 1 的问题</li>
</ul></li>
<li>算法
<ul>
<li>变换到以光源为视点的观察坐标系中，记录深度图</li>
<li>正常渲染到以视点为观察坐标系中，将你看到的点转换到上一步的坐标系中，利用深度值怕段是否在阴影中（能否被光源看到）</li>
</ul></li>
<li>一些问题
<ul>
<li>浮点数判断相等困难，因此会出现黑白条纹的问题
<ul>
<li>shadow map 分辨率问题
<ul>
<li>一般游戏中选择阴影质量，就是修改分辨率</li>
</ul></li>
<li>记录值的精度问题</li>
</ul></li>
<li>加入一个 bias</li>
<li>需要渲染场景两遍</li>
</ul></li>
<li>软阴影与硬阴影</li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/01/1615962188769.png" style="zoom:50%;"></p>
<ul>
<li>物理上的本影与半影</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES101</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101.闫令琪.02.Shading(Lecture 07-09)</title>
    <url>/2021/03/13/CG/YLQ-GAMES101/02/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/av90798049</li>
</ul>
<h1 id="lecture-07">Lecture 07</h1>
<ul>
<li>Shading 1 (Illumination, Shading and Graphics Pipeline)</li>
<li>着色（光照与基本着色模型）</li>
</ul>
<h1 id="lecture-08">Lecture 08</h1>
<ul>
<li>Shading 2 (Shading, pipeline and texture mapping)</li>
<li>着色（着色频率、图形管线、纹理映射）</li>
</ul>
<h2 id="blinn-phong-模型">Blinn-Phong 模型</h2>
<ul>
<li>ambient + diffuse + specular</li>
<li>单位向量
<ul>
<li>光源方向：<span class="math inline">\(\vec{l}\)</span>（指向光源）</li>
<li>法向：<span class="math inline">\(\vec{n}\)</span></li>
<li>视线方向：<span class="math inline">\(\vec{v}\)</span></li>
<li>光线反射方向：<span class="math inline">\(\vec{r}\)</span></li>
</ul></li>
<li>光源到物体反射点的距离 <span class="math inline">\(r\)</span></li>
</ul>
<h3 id="diffuse">(1) Diffuse</h3>
<p><span class="math display">\[
L_d=k_d\dfrac{I}{r^2}\max(\vec{n}\cdot\vec{l},0)
\]</span></p>
<h3 id="specular">(2) Specular</h3>
<ul>
<li>半程向量：<span class="math inline">\(h\)</span></li>
</ul>
<p><span class="math display">\[
\vec{h}=bisector(\vec{v},\vec{l})=\dfrac{\vec{v}+\vec{n}}{||\vec{v}+\vec{n}||}
\]</span></p>
<p><span class="math display">\[
L_s=k_s\dfrac{I}{r^2}\max(\vec{n}\cdot\vec{h},0)^p
\]</span></p>
<ul>
<li>Phong 模型中使用 <span class="math inline">\(\vec{r}\cdot\vec{v}\)</span>
<ul>
<li>Blinn-Phong 模型是一个改进
<ul>
<li>相对好算</li>
<li><span class="math inline">\(\vec{v},\vec{r}\)</span>
的夹角大于90度时应该也能有部分高光
<ul>
<li>不会出现 Phong 模型中的高光断层问题</li>
</ul></li>
</ul></li>
</ul></li>
<li><span class="math inline">\(p\)</span> 限制反光范围
<ul>
<li>实际应用：100 - 200</li>
</ul></li>
</ul>
<h3 id="ambient">(3) Ambient</h3>
<ul>
<li>模拟间接光照</li>
<li>实际上是不存在的 <strong>FAKE</strong></li>
</ul>
<p><span class="math display">\[
L_a=k_aI_a
\]</span></p>
<ul>
<li>光源到物体的距离会引发能量损失，<span style="color:red;font-weight:bold">视点到物体的距离不会</span></li>
</ul>
<h2 id="shading-frequencies">Shading Frequencies</h2>
<ul>
<li><strong>着色频率</strong>：多大的区域应用一次着色算法
<ul>
<li>频率越高，着色算法应用的区域越小，着色算法使用的次数越多</li>
</ul></li>
<li>Flat Shading
<ul>
<li><strong>逐三角形</strong> Face</li>
<li>一个三角形只有一个法线，三角形内部没有颜色变化</li>
</ul></li>
<li>Gouraud Shading
<ul>
<li><strong>逐顶点</strong> Vertex</li>
<li>一个三角形的每一个顶点进行一次着色计算，内部颜色使用插值计算出来</li>
</ul></li>
<li>Phong Shading
<ul>
<li><strong>逐像素</strong> Pixel</li>
<li>对三角形所在区域的每一个像素进行光照计算</li>
</ul></li>
<li>模型足够复杂（面的细分够小）的时候，可能面的个数比像素多
<ul>
<li>逐三角形绘制可能耗时</li>
<li>逐像素绘制也不一定比逐三角形绘制效果好</li>
</ul></li>
</ul>
<h2 id="怎么知道顶点像素的法线">怎么知道顶点/像素的法线</h2>
<ul>
<li>如果知道已知模型，可以通过已知的几何模型中获取（例如本身是球体）</li>
<li>不知道的话，可以对这个顶点关联的面的法线求一个平均
<ul>
<li>亦可以加权平均</li>
</ul></li>
<li>像素的法线：插值
<ul>
<li>重心坐标</li>
</ul></li>
</ul>
<h2 id="graphics-pipelinereal-time-pipeline">Graphics
Pipeline（Real-time Pipeline）</h2>
<ul>
<li>vertex processing</li>
<li>triangle processing</li>
<li>rasterization</li>
<li>fragment processing</li>
<li>framebuffer processing</li>
</ul>
<h2 id="shader">Shader</h2>
<ul>
<li>vertex shader</li>
<li>fragment shader</li>
<li>OpenGL: GLSL</li>
</ul>
<h2 id="texture-mapping">Texture Mapping</h2>
<ul>
<li>纹理映射</li>
<li>纹理用于定义着色的时候所用的属性
<ul>
<li>一般用于代替漫反射系数 <span class="math inline">\(K_d\)</span></li>
</ul></li>
<li>3D 物体表面可以和一张 2D 表面相对应</li>
<li>空间中的三角形怎么和 2D 平面上的纹理相对应
<ul>
<li>美工设计</li>
<li>自动化：parametric（参数化）</li>
</ul></li>
<li>纹理坐标系 uv
<ul>
<li>通常认为 u,v 范围都是 [0, 1]</li>
</ul></li>
<li>纹理可以被重复使用
<ul>
<li>设计的好的时候，重复的时候可以无缝连接</li>
</ul></li>
<li>纹素：texel
<ul>
<li>a pixel on a texture</li>
</ul></li>
</ul>
<h1 id="lecture-09">Lecture 09</h1>
<ul>
<li>Texture Mapping</li>
<li>插值、高级纹理映射</li>
</ul>
<h2 id="barycentric-coordinates">Barycentric Coordinates</h2>
<ul>
<li>重心坐标</li>
<li>为了做三角形内的插值
<ul>
<li>知道顶点属性，可以平滑的插值三角形内部的属性</li>
</ul></li>
<li>三角形 <span class="math inline">\(ABC\)</span> 所在平面内的任意一点
<span class="math inline">\((x,y)\)</span> 都可以用 <span class="math inline">\(ABC\)</span> 三个顶点的坐标线性组合得出</li>
</ul>
<p><span class="math display">\[
(x,y)=\alpha A + \beta B+\gamma C,\alpha+\beta+\gamma=1
\]</span></p>
<ul>
<li>如果点 <span class="math inline">\((x,y)\)</span>
在三角形内部，<strong>系数不为负</strong>
<ul>
<li>系数与面积相关</li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/02/1615614278867.png" style="zoom:50%;"></p>
<ul>
<li>或者直接利用坐标计算</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\alpha
&amp;=\frac{-\left(x-x_{B}\right)\left(y_{C}-y_{B}\right)+\left(y-y_{B}\right)\left(x_{C}-x_{B}\right)}{-\left(x_{A}-x_{B}\right)\left(y_{C}-y_{B}\right)+\left(y_{A}-y_{B}\right)\left(x_{C}-x_{B}\right)}
\\
\beta
&amp;=\frac{-\left(x-x_{C}\right)\left(y_{A}-y_{C}\right)+\left(y-y_{C}\right)\left(x_{A}-x_{C}\right)}{-\left(x_{B}-x_{C}\right)\left(y_{A}-y_{C}\right)+\left(y_{B}-y_{C}\right)\left(x_{A}-x_{C}\right)}
\\
\gamma &amp;=1-\alpha-\beta
\end{aligned}
\]</span></p>
<ul>
<li>可以直接利用重心坐标进行属性插值</li>
<li>存在的一个问题，<strong>投影变换下重心坐标会变化</strong>
<ul>
<li>例如深度值的插值应该在世界坐标系/观察中进行，不能在投影坐标系下进行</li>
</ul></li>
</ul>
<h2 id="texture-mapping-1">Texture Mapping</h2>
<h3 id="simple-texture-mapping">Simple Texture Mapping</h3>
<ul>
<li>插值出 <span class="math inline">\((u,v)\)</span></li>
<li>然后再在纹理中采样</li>
</ul>
<h3 id="纹理放大">纹理放大</h3>
<ul>
<li>Texture Magnification</li>
</ul>
<h4 id="纹理太小了怎么办">(1) 纹理太小了怎么办</h4>
<ul>
<li>纹理分辨率太低</li>
<li>计算出非整数值：插值（Nearest、Bilinear、Bicubic）</li>
<li>双线性插值：Bilinear
<ul>
<li>使用临近的 4 个点进行双线性插值</li>
<li>两趟线性插值 lerp</li>
</ul></li>
<li>双三次插值：Bicubic
<ul>
<li>取邻近得到 16 个点进行插值</li>
<li>两趟 cubic 插值方法</li>
<li>运算量大，但是效果更好
<ul>
<li>trade off</li>
</ul></li>
</ul></li>
</ul>
<h4 id="纹理太大了怎么办">(2) 纹理太大了怎么办</h4>
<ul>
<li>更严重的问题
<ul>
<li>远处摩尔纹，近处锯齿</li>
</ul></li>
<li>远处占据了一块很大区域的纹理，简单的取中心点所在的坐标会出问题</li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/02/1615614006106.png" style="zoom:50%;"></p>
<ul>
<li>超采样，可以解决，但是计算量很大</li>
<li>不做采样，立刻知道的话就不会有问题
<ul>
<li>Mipmap</li>
</ul></li>
<li>经典问题：Point Query &amp; Range Query</li>
</ul>
<h4 id="mipmap">MipMap</h4>
<ul>
<li>允许范围查询
<ul>
<li><strong>正方形</strong>、近似的、快</li>
</ul></li>
<li>通过一张图，生成一系列分辨率的纹理图
<ul>
<li>原始分辨率 64x64</li>
<li>生成的一系列的纹理分辨率：64x64, 32x32, 16x16, 8x8, 4x4, 2x2, 1x1
<ul>
<li>Level 0 - 6</li>
</ul></li>
</ul></li>
<li>存储量变为原来的 <span class="math inline">\(\dfrac{4}{3}\)</span></li>
<li>怎么知道需要查询的是哪一张（层次）纹理
<ul>
<li>计算出来</li>
<li>取最大值，相当于用一个正方形近似</li>
<li><span class="math inline">\(D=\log_2L\)</span>，很巧妙
<ul>
<li>和上面生成纹理分辨率对比</li>
<li>L = 1 刚好是 Level 0（原始图像）</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/02/1615614093881.png" style="zoom:50%;"></p>
<ul>
<li>由于层是离散的，因此计算出来的层数是不连续的
<ul>
<li>利用三线性插值（Trilinear）计算</li>
<li>例如计算出来是 1.6 层，则在第 1 层和第 2 层上分别取最近的 4
个点进行一次双线性插值，然后在层与层之间进行一次线性插值</li>
</ul></li>
<li>MipMap 的问题
<ul>
<li>远处的细节全都被模糊掉了（和超采样相比）
<ul>
<li>三线性插值的近似</li>
<li>只能查询正方形，对长条形的区域可能会产生 Overblur</li>
</ul></li>
<li>一个解决方法：各向异性过滤 Anisotropic Filtering</li>
</ul></li>
</ul>
<h4 id="各向异性过滤-anisotropic-filtering">各向异性过滤 Anisotropic
Filtering</h4>
<ul>
<li>水平竖直缩小的倍数不一样，使用矩形去近似</li>
<li>部分解决问题，对于<strong>横平竖直的矩形</strong>查询相对更加准确</li>
<li>但是一些斜着的区域还是存在 Over Blur 的问题</li>
<li>存储开销变为原来的 4 倍</li>
<li>RipMap</li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/02/1615614525178.png"></p>
<ul>
<li>2x 指的是每个方向只压缩 1 次，左上角 4 张图
<ul>
<li>3x：左上角 9 张图（最小的压缩了两次）</li>
<li>nx：最终收敛到 4 倍存储开销</li>
</ul></li>
</ul>
<h4 id="ewa-filtering">EWA Filtering</h4>
<ul>
<li>不规则的图形利用<strong>圆形</strong>去近似</li>
<li>多次查询，覆盖这个不规则图形（耗时长）</li>
</ul>
<h2 id="纹理的应用">纹理的应用</h2>
<ul>
<li>In modern GPUs, <strong>texture = memory + range query</strong>
(filtering)<br>
</li>
<li>把纹理理解为一块数据，而不仅仅局限在图像上</li>
<li>Store microgeometry</li>
<li>Procedural textures</li>
<li>Solid modeling</li>
<li>Volume rendering</li>
</ul>
<h3 id="environment-lighting">Environment lighting</h3>
<ul>
<li>环境光照</li>
<li>Environment Map 环境贴图</li>
<li>认为光源无限远，没有深度意义，因此可以通过方向采样（不定义位置）</li>
</ul>
<h4 id="spherical-environment-map">Spherical Environment Map</h4>
<ul>
<li>球面光贴图</li>
<li>将整个环境光记录在球面上</li>
<li>展开到长方形平面上，极点部分会有扭曲的问题</li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/02/1615641364773.png" style="zoom:50%;"></p>
<h4 id="cube-map">Cube Map</h4>
<ul>
<li>解决扭曲问题而提出的</li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/02/1615641448166.png" style="zoom:70%;"></p>
<ul>
<li>产生的问题
<ul>
<li>球面采样更快，立方体需要先判断在哪一个面上</li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/02/1615641521532.png" style="zoom:60%;"></p>
<h3 id="凹凸贴图">凹凸贴图</h3>
<ul>
<li>凹凸贴图（法线贴图）</li>
<li>Bump Mapping / Normal Mapping</li>
<li>复杂的效果，粗糙效果</li>
<li>物体的几何信息没有改变，加入一个随机扰动（perturb）
<ul>
<li>常数用于表示凹凸贴图的影响程度</li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/02/1615641786775.png" style="zoom:80%;"></p>
<ul>
<li>蓝色的线是凹凸贴图定义的高度，重新计算法线
<ul>
<li>先算切线，再算法线</li>
</ul></li>
<li>3 维空间类似
<ul>
<li>原来的法线 <span class="math inline">\(n(p)=(0,0,1)\)</span></li>
<li><span class="math inline">\(\dfrac{dp}{du}=c1\ast[h(u+1)-h(u)]\)</span></li>
<li><span class="math inline">\(\dfrac{dp}{dv}=c2\ast[h(\mathbf{v}+1)-h(\mathbf{v})]\)</span></li>
<li>扰动后的法线（未归一化）<span class="math inline">\(n=(-\dfrac{dp}{du},-\dfrac{dp}{dv},1)\)</span></li>
<li>可以通过旋转矩阵推导，或者空间想象</li>
</ul></li>
<li>局部坐标系：切线空间 TBN</li>
</ul>
<h3 id="位移贴图">位移贴图</h3>
<ul>
<li>Displacement Map</li>
<li><strong>直接把顶点的位置移动了</strong>，而不是说简单的影响法线</li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/02/1615642434137.png"></p>
<ul>
<li>和凹凸贴图的区别
<ul>
<li>边缘</li>
<li>自己的阴影在自己上面</li>
<li>影子</li>
</ul></li>
<li>要求三角形足够细
<ul>
<li>如果三角形比较大，纹理定义的变换在三角形内部体现不出来</li>
<li>要求三角形定义的间隔比纹理间隔更下（频率更高）</li>
</ul></li>
<li>DirextX：动态曲面细分
<ul>
<li>根据需要做细分，而不是所有的三角形都这么细致</li>
</ul></li>
</ul>
<h3 id="d-procedural-noise-solid-model">3D Procedural Noise + Solid
Model</h3>
<ul>
<li>程序纹理</li>
<li>定义三维空间的噪声函数</li>
</ul>
<h3 id="provide-precomputed-shading">Provide Precomputed Shading</h3>
<ul>
<li>记录一些已经计算好的信息</li>
<li>OpenGL 帧缓冲</li>
<li>环境光遮蔽例子</li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/02/1615642847111.png" style="zoom:70%;"></p>
<h3 id="d-textures-and-volume-rendering">3D Textures and Volume
Rendering</h3>
<ul>
<li>体渲染</li>
<li>例如核磁共振分层扫描，返回了三维信息，把这些记录的信息当作纹理传入用于渲染</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES101</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101.闫令琪.03.几何(Lecture 10-12)</title>
    <url>/2021/03/13/CG/YLQ-GAMES101/03/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/av90798049</li>
</ul>
<h1 id="lecture-10">Lecture 10</h1>
<ul>
<li>Geometry (Introduction)</li>
<li>几何（基本表示方法）</li>
</ul>
<h2 id="现实">现实</h2>
<ul>
<li>曲面
<ul>
<li>现实生活中，我们不管离得多近，也看到不到小三角形，是真正的曲面</li>
</ul></li>
<li>布料，透明现象，摩擦力
<ul>
<li>纤维（fiber）</li>
<li>股（ply）</li>
<li>线（thread）</li>
<li>布料</li>
</ul></li>
<li>水滴
<ul>
<li>水花飞溅</li>
<li>水的表面张力</li>
</ul></li>
<li>城市
<ul>
<li>内部物体很多，树（树叶），草</li>
<li>怎么存储</li>
<li>怎么渲染这么多物体
<ul>
<li>Big Hero 6 （超能陆战队）</li>
<li>城市远景的渲染，怎么快，怎么优化</li>
</ul></li>
</ul></li>
<li>动物的毛发</li>
<li>细胞（微观几何）</li>
<li>树，树枝</li>
</ul>
<h2 id="几何的表示">几何的表示</h2>
<ul>
<li>隐式（Implicit）、显式（Explicit）</li>
</ul>
<h3 id="隐式表示方法">隐式表示方法</h3>
<ul>
<li>不告诉你点具体在哪，但是告诉你这些点满足的<strong>关系</strong></li>
<li>例如球：<span class="math inline">\(x^2+y^2+z^2=1\)</span></li>
<li>一般化的函数：<span class="math inline">\(f(x,y,z)=0\)</span></li>
</ul>
<h4 id="好处">好处</h4>
<ul>
<li>容易判断位置关系
<ul>
<li>例如判断一个点是否在内部</li>
</ul></li>
<li>很难找到所有满足关系的所有点，但是给定一个点后，容易判断是否在它上面</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>给你一个表达式，很难看出表达的是什么</li>
</ul>
<p><span class="math display">\[
f(x,y,z)=(2-\sqrt{x^2+y^2})^2+z^2-1=0
\]</span></p>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615648598629.png" style="zoom:70%;"></p>
<h3 id="显示的表达方法">显示的表达方法</h3>
<ul>
<li>直接给出点（given directly）
<ul>
<li>例如之前给出的三角形面</li>
</ul></li>
<li>通过参数映射的方法定义的表面（parameter mapping）
<ul>
<li>把 <span class="math inline">\((u,v)\)</span>
全过一遍就找到了结果</li>
<li><strong>类似纹理</strong></li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615648943112.png" style="zoom:70%;"></p>
<h4 id="缺点-1">缺点</h4>
<ul>
<li>很难判断一个点是否在内部 /上面</li>
</ul>
<p><span class="math display">\[
f(u,v)=(\cos u\sin v,\sin u\sin v,\cos v)
\]</span></p>
<ul>
<li>是一个球面（单位球），但是直接给你一个表达式很难看出，而且不好判断点和几何体的位置关系</li>
</ul>
<h2 id="隐式表示方法-1">隐式表示方法</h2>
<h3 id="algebraic-surfaces-implicit">Algebraic Surfaces (Implicit)</h3>
<ul>
<li>数学公式</li>
<li>如下是一个<strong>爱心</strong></li>
</ul>
<p><span class="math display">\[
(x^2+\dfrac{9y^2}{4}+z^2-1)^3=x^2z^3+\dfrac{9y^2z^3}{80}
\]</span></p>
<h3 id="constructive-solid-geometry-implicit">Constructive Solid
Geometry (Implicit)</h3>
<ul>
<li>CSD</li>
<li>通过定义几何体之间的集合运算获取新的集合体</li>
<li>布尔运算 Boolean operation</li>
</ul>
<h3 id="distance-functions-implicit">Distance Functions (Implicit)</h3>
<ul>
<li>距离函数</li>
<li>SDF：Signed Distance Function</li>
<li>对空间中的每一个点，都求其到物体表面的最短距离（外部为正、内部为负）</li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615649746896.png" style="zoom:80%;"></p>
<ul>
<li>对 SDF 进行 blend</li>
<li>一个例子
<ul>
<li>A 到 B 的一个运动状态，阴影表示被遮挡</li>
<li>想通过 A 和 B 得到中间状态（理想：左边一半黑色、右边一半白色）</li>
<li>直接作 blend，变成黑、灰、白各占 <span class="math inline">\(\dfrac{1}{3}\)</span></li>
<li>对 SDF 做 blend，与理想一致</li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615649813984.png" style="zoom:80%;"></p>
<ul>
<li>另外一个例子</li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615650031168.png"></p>
<ul>
<li><strong>距离函数很强</strong></li>
<li>怎么从距离函数还原出原来的点
<ul>
<li>把距离函数为 0 的位置全找出来就得到了表面</li>
</ul></li>
<li>距离函数不太好写成解析的形式
<ul>
<li>水平集方法</li>
</ul></li>
</ul>
<h3 id="level-set-methods-also-implicit">Level Set Methods (Also
implicit)</h3>
<ul>
<li>水平集方法</li>
<li>也是距离函数，把距离存在网格里，只是表示方式不同
<ul>
<li>非网格上的点：<strong>双线性插值</strong></li>
</ul></li>
<li>地理：等高线</li>
<li>三维空间水平集，纹理</li>
<li>医学：CT，MRI</li>
<li>Level Sets in Physical Simulatio
<ul>
<li>水滴滴到水里</li>
</ul></li>
</ul>
<h3 id="fractals-implicit">Fractals (Implicit)</h3>
<ul>
<li>分形</li>
<li>Exhibit self-similarity, detail at all scales</li>
<li>自相似性
<ul>
<li>渲染的时候会引起强烈的走样</li>
</ul></li>
</ul>
<h2 id="隐式表示方法评价">隐式表示方法评价</h2>
<ul>
<li>缺点
<ul>
<li>difficult to model complex shapes
<ul>
<li>复杂形体难以表示</li>
</ul></li>
</ul></li>
<li>优点
<ul>
<li>compact description (e.g., a function)
<ul>
<li>表示简单</li>
</ul></li>
<li>certain queries easy (inside object, distance to surface)
<ul>
<li>方便查询（内部、外部）</li>
</ul></li>
<li>good for ray-to-surface intersection (more later)
<ul>
<li>容易与光线求交（光线跟踪算法）</li>
</ul></li>
<li>for simple shapes, exact description / no sampling error
<ul>
<li>准确描述物体</li>
</ul></li>
<li>easy to handle changes in topology (e.g., fluid)
<ul>
<li>容易控制几何变化</li>
</ul></li>
</ul></li>
</ul>
<h1 id="lecture-11">Lecture 11</h1>
<ul>
<li>Geometry 2 (Curves and Surfaces)</li>
<li>曲线与曲面</li>
</ul>
<h2 id="显式表示方法">显式表示方法</h2>
<ul>
<li>triangle meshes</li>
<li>Bezier surfaces</li>
<li>subdivision surfaces</li>
<li>NURBS</li>
<li>point clouds</li>
</ul>
<h3 id="point-cloud-explicit">Point Cloud (Explicit)</h3>
<ul>
<li>点云</li>
<li>点表示的够细，就看不出来点与点之间的间隔</li>
<li>精细模型：特别密集的点</li>
<li>三维扫描的输出</li>
<li>点云如何变成（三角形的）面
<ul>
<li>一个研究问题</li>
</ul></li>
</ul>
<h3 id="polygon-mesh-explicit">Polygon Mesh (Explicit)</h3>
<ul>
<li>多边形面
<ul>
<li>三角形面、四边形面</li>
</ul></li>
<li>Perhaps <strong>most common</strong> representation in graph</li>
</ul>
<h4 id="文件格式-.obj">文件格式 .obj</h4>
<ul>
<li>The Wavefront Object File (.obj) Format</li>
<li>Just a text file that specifies vertices, normals, texture
coordinates and their connectivities</li>
<li>一个<strong>立方体</strong>的例子
<ul>
<li>以下数据存在冗余（自动建模产生的）</li>
<li>f 表示怎么形成三角形</li>
<li>f 5/1/1 1/2/1 4/3/1</li>
<li>三角形的三个顶点（v / vt / vn）
<ul>
<li>第 5 个顶点（第 1 个纹理坐标、第 1 个法线）</li>
<li>第 1 个顶点（第 2 个纹理坐标、第 1 个法线）</li>
<li>第 4 个顶点（第 3 个纹理坐标、第 1 个法线）</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615710980473.png"></p>
<h3 id="curves">Curves</h3>
<ul>
<li>曲线</li>
<li>Camera Path
<ul>
<li>摄像机沿着某条曲线运动（转换视点方向）</li>
</ul></li>
<li>定义字体</li>
</ul>
<h3 id="bezier-curvesexplict">Bezier Curves(Explict)</h3>
<ul>
<li>贝塞尔曲线</li>
<li>通过参数定义的，因此是显式的</li>
<li>通过控制点定义曲线（4/3）
<ul>
<li>控制点：定义切线、起始点、终点</li>
</ul></li>
</ul>
<h4 id="bézier-curves-de-casteljau-algorithm">Bézier Curves – de
Casteljau Algorithm</h4>
<ul>
<li>通过任意个控制点生成曲线</li>
<li>quadratic Bezier（3 个点）</li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615711727481.png" style="zoom:50%;"></p>
<ul>
<li><span class="math inline">\(b_0\)</span> 出发，<span class="math inline">\(b_2\)</span> 结束，<span class="math inline">\(b_1\)</span> 控制方向</li>
<li>Insert a point using linear interpolation</li>
<li>时间 0 在点 <span class="math inline">\(b_0\)</span>，时间 <span class="math inline">\(1\)</span> 在点 <span class="math inline">\(b_2\)</span>，问时间 t 点在哪里？</li>
<li>对当前的所有线段进行一个插值，直到无法插值（只有一条线段上的一个点）
<ul>
<li>每趟插值减少一条线段</li>
</ul></li>
<li>例如
<ul>
<li><span class="math inline">\(b_0b_1\)</span> 插值出 <span class="math inline">\(b_0^1\)</span>，<span class="math inline">\(b_1b_2\)</span> 插值出 <span class="math inline">\(b_1^1\)</span></li>
<li>例如 <span class="math inline">\(b_0^1b_1^1\)</span> 插值出 <span class="math inline">\(b_0^2\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615711935263.png" style="zoom:50%;"></p>
<h4 id="evaluating-bézier-curves-algebraic-formula">Evaluating Bézier
Curves Algebraic Formula</h4>
<ul>
<li>代数形式</li>
<li>4 个点</li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615712363260.png" style="zoom:50%;"></p>
<ul>
<li>3 个点</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
b_0^2&amp;=tb_0^1+(1-t)b_1^1\\
&amp;=t[tb_0+(1-t)b_1]+(1-t)[tb_1+(1-t)b_2]\\
&amp;=t^2b_0+2t(1-t)b_1+(1-t)^2b_2
\end{aligned}
\]</span></p>
<ul>
<li>4 个点</li>
</ul>
<p><span class="math display">\[
b^n(t)=b_0(1-t)^3+b_13t(1-t)^2+b_23t^2(1-t)+b_3t^3
\]</span></p>
<ul>
<li>是 1 的二项式展开</li>
</ul>
<p><span class="math display">\[
b^n(t)=b_0^n=\sum_{j=0}^{n}b_jB_j^n(t)
\]</span></p>
<p><span class="math display">\[
B_j^n(t)=\mathbf{C}_n^it^i(1-t)^{n-i}={n\choose i}t^i(1-t)^{n-i}
\]</span></p>
<ul>
<li>输入为三维坐标，三维贝塞尔曲线</li>
<li>一些性质（4个控制点情况下）
<ul>
<li><span class="math inline">\(b(0)=b_0\)</span></li>
<li><span class="math inline">\(b(1)=b_3\)</span></li>
<li><span class="math inline">\(b&#39;(0)=3(b_1-b_0)\)</span></li>
<li><span class="math inline">\(b&#39;(1)=3(b_3-b_2)\)</span></li>
</ul></li>
<li><strong>控制点做仿射变换后生成的贝塞尔曲线和原来的贝塞尔曲线仿射变换后形成的曲线是一样的</strong>
<ul>
<li>投影变换不行</li>
</ul></li>
<li>凸包性质
<ul>
<li>画出来的贝塞尔曲线一定在控制点形成的<strong>凸包</strong>内</li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615713622062.png" style="zoom:67%;"></p>
<h4 id="piecewise-bezier-curves">Piecewise Bezier Curves</h4>
<ul>
<li>分段考虑
<ul>
<li>在线演示：http://math.hws.edu/eck/cs424/notes2013/canvas/bezier.html</li>
</ul></li>
<li>控制点多了，不太好控制形成想要的形状</li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615713780545.png" style="zoom:50%;"></p>
<ul>
<li>每 4 个控制点定义一个贝塞尔曲线
<ul>
<li>广泛应用：fonts, paths, Illustrator, Keynote</li>
<li>PhotoShop 的钢笔工具</li>
</ul></li>
<li>怎么样让连接点光滑？
<ul>
<li>切线的斜率相同</li>
<li><span class="math inline">\(3(b_3-b_2)=3(b_4-b_3)\)</span></li>
<li><span class="math inline">\(b_2+b_4=2b_3\)</span></li>
</ul></li>
<li><span class="math inline">\(C^0\)</span> 连续：点是同一个点</li>
<li><span class="math inline">\(C^1\)</span>
连续：斜率（一阶导数）连续</li>
</ul>
<h4 id="其他问题">其他问题</h4>
<ul>
<li>高阶贝塞尔曲线转低阶</li>
</ul>
<h3 id="splines-样条">Splines 样条</h3>
<ul>
<li>a continuous curve constructed so as to pass through a given set of
points and have a certain number of continuous derivatives.</li>
<li>In short, a curve under control</li>
<li>通过这些点</li>
</ul>
<h3 id="b-splines">B-Splines</h3>
<ul>
<li>B样条曲线</li>
<li>basis splines（基函数样条）
<ul>
<li>伯恩斯坦多项式作为基函数，进行一个加权平均</li>
</ul></li>
<li>Require more information than Bezier curves</li>
<li>Satisfy all important properties that Bézier curves have (i.e.
superset)</li>
<li>提出动机
<ul>
<li>如果使用贝塞尔曲线，改动一个点，可能会影响整条曲线
<ul>
<li>分段贝塞尔曲线没有这个问题（边界问题）</li>
</ul></li>
<li>然而我们希望只影响<strong>局部</strong>的曲线</li>
</ul></li>
</ul>
<h3 id="nubrbs">NUBRBS</h3>
<ul>
<li>非均匀有理 B 样条</li>
</ul>
<h3 id="深入几何内容">深入几何内容</h3>
<ul>
<li>https://www.bilibili.com/video/av66548502</li>
</ul>
<h3 id="贝塞尔曲面">贝塞尔曲面</h3>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615718816431.png" style="zoom:50%;"></p>
<ul>
<li>双线性插值的思想</li>
<li>两个方向上做两趟贝塞尔曲线</li>
<li>复杂的问题：贝塞尔曲面的混合</li>
</ul>
<h2 id="网格计算">网格计算</h2>
<ul>
<li><p>网格细分：mesh subdivision</p>
<ul>
<li>upsampling</li>
</ul></li>
<li><p>网格简化：mesh simplification</p>
<ul>
<li>downsampling</li>
</ul></li>
<li><p>网格正则化：mesh regulation</p>
<ul>
<li>网格正则化</li>
<li>原来的三角形可能有大有小，渲染困难</li>
</ul></li>
</ul>
<h1 id="lecture-12">Lecture 12</h1>
<ul>
<li><p>Geometry (Mesh Operation)</p></li>
<li><p>几何（网格处理）</p></li>
<li><p>2019 图灵奖：Ed Catmull，Pat Hanrahan</p></li>
</ul>
<h2 id="细分-mesh-subdivision">细分 Mesh Subdivision</h2>
<ul>
<li>引入更多三角形</li>
<li>三角形的位置发生点变化，更加光滑</li>
</ul>
<h3 id="loop-subdivision">Loop Subdivision</h3>
<ul>
<li>Loop：发明这个算法的人叫 Loop</li>
<li>前提假设是原来表示物体的方式i就全都是<strong>三角形</strong></li>
<li>三角形分为 4 个</li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615957320024.png" style="zoom:50%;"></p>
<ul>
<li>将顶点划分为新/老顶点，使用不同的更新方法去更新
<ul>
<li>新：边的中间</li>
<li>老：原来存在的</li>
</ul></li>
<li>新的顶点的更新方法
<ul>
<li>AB 指更新的点所在的边（被两个三角形共享）</li>
<li>CD 指上面个的两个三角形剩下的两个点</li>
<li>直观上的理解：AB 近（贡献大），CD 远（贡献小）</li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615957373007.png" style="zoom:40%;"></p>
<ul>
<li>老的顶点的更新方式
<ul>
<li>老的顶点被若干（<span class="math inline">\(n\)</span>）个三角形共享，结点度为 <span class="math inline">\(n\)</span></li>
<li>考虑<strong>周围顶点</strong>的影响同时还要考虑<strong>自己原来</strong>的位置
<ul>
<li>周围顶点的平均 / 和</li>
<li>自己原来的位置</li>
</ul></li>
<li><span class="math inline">\(u\)</span> ：一个与 <span class="math inline">\(n\)</span> 相关的数</li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615957500126.png" style="zoom:40%;"></p>
<h3 id="catmull-clark-subdivision">Catmull-Clark Subdivision</h3>
<ul>
<li>适用于一般的形状表示</li>
<li>一些定义
<ul>
<li>Quad face：四边形面</li>
<li>Non-quad face：非四边形面</li>
<li>Extraordinary point：奇异点
<ul>
<li>度不为 4 的点</li>
</ul></li>
</ul></li>
</ul>
<h4 id="产生新的点">产生新的点</h4>
<ul>
<li>产生算法
<ul>
<li>对于每个面，我们取<strong>所有边的中点</strong>以及<strong>面上的中点</strong>（重心）</li>
<li>将边上的中点和面的中点连起来</li>
</ul></li>
<li>经过一次细分之后
<ul>
<li>奇异点
<ul>
<li>原来的奇异点还是奇异点</li>
<li>增加的奇异点个数：原来非四边形面的个数</li>
</ul></li>
<li>非四边形面
<ul>
<li>非四边形面全都消失了</li>
</ul></li>
<li><strong>每一个非四边形面都会消失，并且引入一个奇异点</strong></li>
</ul></li>
<li>Catmull-Clark 细分，在第一步操作时会引入 <span class="math inline">\(n\)</span> 个奇异点，之后的操作不会再引入奇异点
<ul>
<li><span class="math inline">\(n\)</span>：初始非四边形面的个数</li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615959072991.png" style="zoom: 33%;"></p>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615959044715.png" style="zoom:33%;"></p>
<h4 id="新的点的位置计算">新的点的位置计算</h4>
<ul>
<li>点分为 3 类
<ul>
<li>Face Point：在<strong>面的中心</strong>的<strong>新</strong>的点
<ul>
<li>关联的顶点</li>
</ul></li>
<li>Edge Point：在<strong>边的中心</strong>的<strong>新</strong>的点
<ul>
<li>关联的边的两个顶点、关联的边关联的面的中心</li>
</ul></li>
<li>Vertex Point：老的顶点
<ul>
<li>自己、关联的面的中心、关联的边的中心</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615959340053.png" style="zoom: 67%;"></p>
<ul>
<li>Geri's Game
<ul>
<li>最早的一批利用曲面细分做的动画</li>
</ul></li>
</ul>
<h2 id="简化-mesh-simplification">简化 Mesh Simplification</h2>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615959972772.png" style="zoom:70%;"></p>
<ul>
<li>简化需求的产生
<ul>
<li>如果一个物体离得很远，没必要划分得很细致
<ul>
<li>简化后，效果差不多，但是计算量小很多</li>
</ul></li>
<li>不同情况下我们会选用不同复杂程度的三角形（几何模型）</li>
</ul></li>
<li>几何层次结构的变化、切换很难
<ul>
<li>例如远处用精细模型，近处用简化模型，但是什么时候切换、怎么平滑切换是个问题</li>
</ul></li>
<li>怎么简化
<ul>
<li>不能直接删除三角形，会有洞</li>
</ul></li>
<li>一种方法：边坍缩（Collapsing An Edge）
<ul>
<li>找到一条边，然后把这条边收缩为一个点</li>
</ul></li>
</ul>
<h3 id="边坍缩">边坍缩</h3>
<ul>
<li>坍缩哪些点？怎么坍缩
<ul>
<li>二次误差度量</li>
</ul></li>
<li>二次误差度量（Quadric Error Metrics）
<ul>
<li>怎么放置新的点（下图为例）
<ul>
<li>5 点平均：矮了很多</li>
<li>3 点平均：还是会比轮廓矮</li>
<li>找一个点，满足这个点到原来 4 个面的平方和最小</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/03/13/CG/YLQ-GAMES101/03/1615960495957.png" style="zoom: 67%;"></p>
<ul>
<li>算法：为每一条边用最小二次误差进行打分，首先坍缩误差最小的边
<ul>
<li>算法问题
<ul>
<li>坍缩一条边之后会影响其他边的最小二次误差</li>
<li>需要重新计算被这条边影响的边的最小二次误差</li>
</ul></li>
<li>数据结构：堆（优先队列）</li>
<li>算法正确性
<ul>
<li>贪心算法，并不保证最重的是全局最优解（可能陷入局部最优）</li>
</ul></li>
<li>实际效果还不错
<ul>
<li>图形学本身的特点</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES101</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101.闫令琪.04.光线追踪(1).Whitted 风格的光线追踪(Lecture 13-14)</title>
    <url>/2021/03/17/CG/YLQ-GAMES101/04/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/av90798049</li>
</ul>
<h1 id="光栅化的问题">光栅化的问题</h1>
<ul>
<li>不好去表示一些全局的效果（Global Effects）</li>
<li>软阴影（Soft Shadow）
<ul>
<li>光栅化 VSM</li>
</ul></li>
<li>Glossy Reflection
<ul>
<li>Glossy：有高光的效果，但是同时本身具有粗糙性的材质</li>
</ul></li>
<li>间接光照（Indirect Illumination）
<ul>
<li>light bounce more than once</li>
<li>光栅化有一些效果可以模拟，但是效果不太好</li>
</ul></li>
<li>光栅化方法
<ul>
<li>快，但是是一种近似算法</li>
<li>Real-Time</li>
</ul></li>
<li>光线追踪方法
<ul>
<li>准确，但是慢</li>
<li>Offline（离线）</li>
</ul></li>
</ul>
<h1 id="ray-tracing">Ray Tracing</h1>
<h2 id="光线的-3-个假定">光线的 3 个假定</h2>
<ul>
<li>Light travels in straight lines (though this is wrong)
<ul>
<li>光沿直线传播</li>
</ul></li>
<li>Light rays do not “collide” with each other if they cross (though
this is still wrong)
<ul>
<li>光线发生交互的时候互不干扰</li>
</ul></li>
<li>Light rays travel from the light sources to the eye
<ul>
<li>(but the physics is invariant under path reversal -
reciprocity).</li>
<li>光线（光路）的可逆性</li>
</ul></li>
</ul>
<h2 id="ray-casting">Ray Casting</h2>
<ul>
<li>Appel 1968 - Ray casting
<ul>
<li>Generate an image by casting one ray per pixel
<ul>
<li>对每个像素，从视点向像素发出一条光线（reciprocity）</li>
</ul></li>
<li>Check for shadows by sending a ray to the light
<ul>
<li>对于找到的点，判断其是否处在阴影中（对光源可见）</li>
</ul></li>
</ul></li>
<li>其他的假设
<ul>
<li>视点就是一个点</li>
</ul></li>
<li>投射光线
<ul>
<li>eye ray：从眼睛射向像素的光线</li>
</ul></li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/04/1615966794240.png" style="zoom:50%;"></p>
<ul>
<li>判断是否可见，若可见利用之前的模型进行计算光照</li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/04/1615967125590.png" style="zoom: 50%;"></p>
<h1 id="recursive-whitted-style-ray-tracing">Recursive (Whitted-Style)
Ray Tracing</h1>
<ul>
<li>考虑第一次接触点的折射、反射
<ul>
<li>递归计算</li>
<li>shadow rays（判断是否对光源可见）</li>
<li>着色计算：对每一个接触点进行计算
<ul>
<li>多条光路的叠加</li>
</ul></li>
<li>需要考虑<strong>能量损失</strong></li>
</ul></li>
<li>eye ray 又被称为 primary ray</li>
<li>secondary ray：经过一次折射/反射之后的线</li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/04/1615967375006.png" style="zoom:50%;"></p>
<h1 id="光线求交">光线求交</h1>
<ul>
<li>Ray-Surface Intersection</li>
<li>光线的定义
<ul>
<li>光线的起点 <span class="math inline">\(\mathbf{o}\)</span></li>
<li>光线的方向 <span class="math inline">\(\mathbf{d}\)</span>
<ul>
<li>单位向量</li>
</ul></li>
</ul></li>
<li>光线的方程
<ul>
<li>Ray Equation</li>
<li><span class="math inline">\(\mathbf{r}(t)=\mathbf{o}+t\mathbf{d},0\le t\le
\infty\)</span></li>
</ul></li>
</ul>
<h2 id="光线与球体求交">光线与球体求交</h2>
<ul>
<li>Sphere
<ul>
<li><span class="math inline">\(\mathbf{p}:(\mathbf{p}-\mathbf{c})^2-R^2=0\)</span></li>
</ul></li>
<li>联立方程组求解即可
<ul>
<li>解的个数：<span class="math inline">\(0,1,2\)</span></li>
<li>不相交，相切，两个交点（取小的）</li>
</ul></li>
</ul>
<h2 id="一般的曲面">一般的曲面</h2>
<p><span class="math display">\[
\left\{
\begin{array}{**lr**}
    \mathbf{r}(t)=\mathbf{o}+t\mathbf{d},0\le t\le \infty\\
    f(\mathbf{p})=0
\end{array}
\right.
\]</span></p>
<h2 id="显式表面求交">显式表面求交</h2>
<ul>
<li>和三角形求交</li>
<li>可以用于判断点是否在物体内部
<ul>
<li>内部的点，引一条射线，和物体的交点必为<strong>奇数个</strong></li>
<li>外部的点，引一条射线，和物体的交点必为<strong>偶数个</strong></li>
</ul></li>
<li>很慢，每个三角都需要求交</li>
</ul>
<h3 id="光线和三角形求交方法">光线和三角形求交方法</h3>
<ul>
<li>光线和三角形所在的平面求交</li>
<li>判断这个交点是否在三角形内部</li>
<li>平面的定义
<ul>
<li>法线 <span class="math inline">\(\mathbf{N}\)</span></li>
<li>平面上任意一个点 <span class="math inline">\(\mathbf{p&#39;}\)</span></li>
</ul></li>
<li>平面上的一个点 <span class="math inline">\(\mathbf{p}:(\mathbf{p&#39;}-\mathbf{p})\cdot\mathbf{N}=0\)</span>
<ul>
<li>展开后和平面方程相同 <span class="math inline">\(ax+by+cz+d=0\)</span></li>
</ul></li>
<li>联立方程组求解</li>
</ul>
<h3 id="moller-trumbore-algorithm">Moller Trumbore Algorithm</h3>
<ul>
<li>怎么直接把结果解出来用于判断</li>
<li><strong>重心坐标</strong></li>
</ul>
<p><span class="math display">\[
\mathbf{r}(t)=\mathbf{o}+t\mathbf{d}=(1-b_1-b_2)\mathbf{P_0}+b_1\mathbf{P_1}+b_2\mathbf{P2}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;0\le t\le \infty\\
&amp;0\le b_1\le1\\
&amp;0\le b_2\le1\\
&amp;0\le 1-b_1-b_2\le1\\
\end{aligned}
\]</span></p>
<ul>
<li>3 个未知量，3 个方程（3维）</li>
<li>解的显式表达</li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/04/image-20210403111154716.png" style="zoom:50%;"></p>
<h1 id="加速求交">加速求交</h1>
<ul>
<li>Accelerating Ray-Surface Intersection</li>
<li>如果不加速，算法复杂度
<ul>
<li>pixels x triangles x bounces</li>
</ul></li>
</ul>
<h2 id="bounding-volumn">Bounding Volumn</h2>
<ul>
<li>包围盒：包围整个模型</li>
<li>先对包围盒求交，如果无交点，则不需要对模型求交</li>
<li>简单的包围盒：长方体
<ul>
<li>三个对面</li>
<li>box is the intersection of 3 pairs of slabs</li>
</ul></li>
</ul>
<h3 id="aabb">AABB</h3>
<ul>
<li>Axis-Aligned Bounding Box
<ul>
<li>轴对齐包围盒</li>
<li>计算快</li>
</ul></li>
<li>如何计算 （2D 的例子）
<ul>
<li>每个对面求交</li>
<li><span class="math inline">\(t_{enter}=\max\{t_{min}\},t_{exit}=\min\{t_{max}\}\)</span></li>
<li>思想
<ul>
<li>The ray enters the box only when it enters all pairs of slabs
<ul>
<li>三个对面都进入，才是进入</li>
</ul></li>
<li>The ray exits the box as long as it exits any pair of slabs
<ul>
<li>离开一个对面，即离开</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/04/1615973061088.png"></p>
<ul>
<li>如果不相交：<span class="math inline">\(t_{exit}\le
t_{enter}\)</span></li>
<li>光线是射线，考虑 <span class="math inline">\(t\)</span> 的正负
<ul>
<li><span class="math inline">\(t_{exit}&lt;0\)</span>：无交点（物体在光线背后）</li>
<li><span class="math inline">\(t_{enter}&lt;0,t_{exit}\ge0\)</span>：光源在物体里面</li>
</ul></li>
</ul>
<h1 id="gtc-一些新闻">GTC 一些新闻</h1>
<ul>
<li>GTC news: DLSS 2.0
<ul>
<li>https://zhuanlan.zhihu.com/p/116211994</li>
</ul></li>
<li>GTC news: RTXGI
<ul>
<li>https://developer.nvidia.com/rtxgi</li>
</ul></li>
</ul>
<h1 id="基于-aabb-的光线求交加速结构">基于 AABB 的光线求交加速结构</h1>
<ul>
<li>光线与 AABB 求交</li>
</ul>
<h2 id="均匀的格子">均匀的格子</h2>
<ul>
<li>Uniform Spatial Partitions (Grids)</li>
<li>场景预处理
<ul>
<li>网格化</li>
</ul></li>
<li>算法步骤
<ul>
<li>光线与沿途每个盒子求交</li>
<li>若盒子里面含有物体，则于保存的物体部分求交</li>
<li>没有物体，则光线前进（找下一个盒子）</li>
</ul></li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/04/1615974169938.png" style="zoom:50%;"></p>
<ul>
<li>基于想法如下
<ul>
<li><strong>光线和盒子求交比光线与物体求交快</strong></li>
</ul></li>
<li>光线与盒子求交
<ul>
<li>怎么找光线下一次相交的盒子
<ul>
<li>最朴素的想法：周围两个都算一遍（向前 2 个测试，向后的 2
个不用管）</li>
</ul></li>
<li>高级算法：类似于光栅化一条线的算法</li>
</ul></li>
</ul>
<h3 id="加速程度">加速程度</h3>
<ul>
<li>网格：1 x 1（无加速效果）</li>
<li>网格过于密集：与盒子求交的成本变大</li>
<li>经验性划分
<ul>
<li>#cells = C x #objs</li>
<li>C = 3 x 3 x 3</li>
</ul></li>
<li>适合场景
<ul>
<li>物体多，在场景中分布均匀</li>
</ul></li>
<li>不适合场景
<ul>
<li>场景较空，分布不均匀
<ul>
<li>大规模空白，和物体相交前需要经过大量空白</li>
</ul></li>
<li>"Teapot in a stadium" problem</li>
</ul></li>
</ul>
<h2 id="空间划分">空间划分</h2>
<ul>
<li>Spatial Partitions</li>
<li>划分方法
<ul>
<li>八叉树
<ul>
<li>维度相关（<span class="math inline">\(2^n\)</span> 叉树）</li>
</ul></li>
<li><strong>KD 树</strong>
<ul>
<li>每次只沿着一个轴展开（二叉树）</li>
<li>横竖交划分（相对均匀）</li>
</ul></li>
<li>BSP 树
<ul>
<li>空间二分</li>
<li>每次选择一个方向做划分</li>
<li>不是横平竖直的
<ul>
<li>维度高了就不好计算</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/04/1615975085492.png" alt="1615975085492" style="zoom:67%;"></p>
<h3 id="kd-tree">KD-Tree</h3>
<ul>
<li>在光线跟踪之前先建立 KD 树</li>
<li>数据结构
<ul>
<li>内部结点
<ul>
<li>记录划分方向（x，y，z）</li>
<li>记录划分位置（不一定是正中间）</li>
<li>子结点（指向子节点的指针）</li>
<li><strong>不需要存储物体信息</strong></li>
</ul></li>
<li>外部结点（叶结点）
<ul>
<li>存储物体列表</li>
</ul></li>
</ul></li>
<li>光线遍历
<ul>
<li>先判断和 A 是否有交点</li>
<li>有交点，接着和 A 的两个子结点判断是否有交点</li>
<li>1 有交点，但是是叶子结点了，计算光照
<ul>
<li>其实 1 还需要继续划分
<ul>
<li>内部还有多个物体，可能规则上认为可以停止</li>
</ul></li>
<li>但是这里已经当作叶子结点了，就不划分了</li>
</ul></li>
<li>B 有交点，重复上述步骤，进入 B</li>
</ul></li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/04/1615984666604.png" style="zoom:60%;"></p>
<ul>
<li>无交点的块不需要计算光照了</li>
</ul>
<h4 id="存在的问题">存在的问题</h4>
<ul>
<li>KD-Tree 的建立不简单</li>
<li>难以判断一个三角形和某个包围盒有交集
<ul>
<li>3 个顶点都在包围盒外也可能有交点
<ul>
<li>包围盒穿透三角形</li>
<li>截面整个在三角形内部</li>
</ul></li>
</ul></li>
<li>一个在边界的物体可能属于多个包围盒
<ul>
<li>多个叶子节点里面都需要计算光照</li>
</ul></li>
<li><strong>现在很少用这种方法了</strong></li>
</ul>
<h3 id="bvh">BVH</h3>
<ul>
<li>Bounding Volumn Hierarchy</li>
<li>基于<span style="color:red;font-weight:bold">物体</span>的划分</li>
<li>Object Partition</li>
<li><strong>现在常用的方法</strong></li>
<li>算法
<ul>
<li>把当前包围盒内的三角形做一个划分</li>
<li>然后把划分得到的两个部分分别求包围盒</li>
</ul></li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/04/1615985336608.png" style="zoom:50%;"></p>
<ul>
<li><strong>一个物体只可能属于一个叶子结点</strong></li>
<li>不需要求三角形和包围盒的交点</li>
<li>避免了 KD-Tree 的问题</li>
<li>但是 BVH 并没有把整个空间划分开，两个子结点可能有重合部分
<ul>
<li>一个好的划分，重叠部分尽量小</li>
<li>BVH 的研究</li>
</ul></li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/04/1615985641979.png" style="zoom:50%;"></p>
<ul>
<li>怎么选取划分方向
<ul>
<li>可以学习 KD-Tree，横竖交替划分，尽量均匀</li>
<li>但是可能有一个轴还是很长
<ul>
<li>所以可以每次选择较长的轴进行划分</li>
</ul></li>
<li>可以选取中间的物体进行划分
<ul>
<li>保证三角形数量差不多</li>
<li>树的深度小，更平衡
<ul>
<li>涉及排序问题，重心排序</li>
<li>找第 <span class="math inline">\(k\)</span> 大的数有 <span class="math inline">\(O(n)\)</span> 的算法
<ul>
<li>快排思想算法</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li>适合静态场景
<ul>
<li>动态需要修改</li>
</ul></li>
<li>BVH 的存储和 KD-Tree 类似</li>
<li>伪代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Intersect</span>(Ray ray, BVH node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ray misses node.bbox) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node is a leaf node)&#123;</span><br><span class="line">        test intersection with all objs;</span><br><span class="line">        <span class="keyword">return</span> closest intersection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hit1 = <span class="built_in">Intersect</span>(ray, node.child1);</span><br><span class="line">    hit2 = <span class="built_in">Intersect</span>(ray, node.child2);</span><br><span class="line">    <span class="keyword">return</span> the closer of hit1, hit2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CG.GAMES101</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
        <tag>RayTracing</tag>
        <tag>GI</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101.闫令琪.05.光线追踪(2).辐射度量学(Lecture 14-15)</title>
    <url>/2021/03/17/CG/YLQ-GAMES101/05/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/av90798049</li>
</ul>
<h1 id="辐射度量学">辐射度量学</h1>
<ul>
<li>Basic Radiometry</li>
<li>Blinn-Phong 模型只是一个近似模型</li>
<li>辐射度量学是一个精确模型
<ul>
<li>基于几何光学来做的</li>
<li>物理上的准确定义</li>
</ul></li>
<li>学习思路：WHY, WHAT, HOW</li>
<li>一些量的定义
<ul>
<li>Radiant Energy，Flux(Power)</li>
<li>Radiant Intensity，Irradiance， Radiance</li>
</ul></li>
<li>图形学中很少用能量的概念，都是考虑功率较多
<ul>
<li>能量则需要考虑时间</li>
<li>帧一般时间较短</li>
</ul></li>
</ul>
<h1 id="一些物理量的定义">一些物理量的定义</h1>
<h2 id="radiant-energy">Radiant Energy</h2>
<ul>
<li>电磁辐射的<strong>能量</strong></li>
<li>Radiant energy is the energy of electromagnetic radiation. It is
measured in units of joules, and denoted by the symbol:</li>
</ul>
<p><span class="math display">\[
Q\left[J=Joule\right]
\]</span></p>
<h2 id="radiant-flux-power">Radiant Flux / Power</h2>
<ul>
<li><strong>功率</strong></li>
<li>单位时间的能量</li>
<li>Radiant flux (power) is the <strong>energy</strong> emitted,
reflected, transmitted or received, <strong>per unit time</strong>.</li>
</ul>
<p><span class="math display">\[
\Phi\equiv\dfrac{dQ}{dt}\left[W=Watt\right]\left[lm=lumen\right]
\]</span></p>
<ul>
<li>单位：瓦特
<ul>
<li>光学中描述功率：<strong>流明</strong></li>
<li>灯泡多亮</li>
</ul></li>
<li>另外的定义
<ul>
<li>Flux – #photons flowing through a sensor in unit time</li>
<li>单位时间通过的光子数量</li>
</ul></li>
</ul>
<h2 id="一些感兴趣的量">一些感兴趣的量</h2>
<ul>
<li>Radiant Intensity，Irradiance， Radiance</li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/05/1616037426480.png" style="zoom:50%;"></p>
<h2 id="radiant-intensity">Radiant Intensity</h2>
<ul>
<li>The radiant (luminous) intensity is the <strong>power</strong>
<strong>per unit solid angle</strong> emitted by a point light
source.</li>
<li>单位立体角的 power（flux）</li>
</ul>
<p><span class="math display">\[
I(\omega)\equiv\dfrac{d\Phi}{d\omega}\left[\dfrac{W}{sr}\right]\left[\dfrac{lm}{sr}=cd=candela\right]
\]</span></p>
<ul>
<li>sr：立体角的单位</li>
<li>The candela is one of the <strong>seven SI base units</strong>.
<ul>
<li>坎德拉：基本单位之一</li>
</ul></li>
</ul>
<h3 id="立体角">立体角</h3>
<ul>
<li>球面面积占球面表面积的比例 x 一个常数，二维弧度制的延伸</li>
<li>A：投影到球面上的面积</li>
</ul>
<p><span class="math display">\[
\Omega=\dfrac{A}{r^2}
\]</span></p>
<ul>
<li>整个球的立体角：<span class="math inline">\(4\pi\)</span></li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/05/1616037958039.png" style="zoom:50%;"></p>
<ul>
<li>微分立体角</li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/05/1616038007273.png" style="zoom:50%;"> <span class="math display">\[
dA=r\sin\theta d\phi\cdot rd\theta=r^2\sin\theta d\theta d\phi
\]</span></p>
<ul>
<li>此时立体角</li>
</ul>
<p><span class="math display">\[
d\omega=\dfrac{dA}{r^2}=\sin\theta d\theta d\phi
\]</span></p>
<ul>
<li>球的立体角</li>
</ul>
<p><span class="math display">\[
\Omega=\int_{S^2}dw=\int_0^{2\pi}\int_0^{\pi}\sin\theta d\theta
d\phi=4\pi
\]</span></p>
<ul>
<li>各向同性点光源
<ul>
<li>Isotropic Point Source</li>
</ul></li>
</ul>
<p><span class="math display">\[
\Phi=\int_{S^2}Id\omega=4\pi I
\]</span></p>
<p><span class="math display">\[
I=\dfrac{\Phi}{4\pi}
\]</span></p>
<ul>
<li>LED 灯：标识的多少瓦实际上表示和白炽灯相比等价于多少瓦
<ul>
<li>标 60W 的 LED 灯实际开销只有 11W</li>
</ul></li>
</ul>
<h2 id="irradiance">Irradiance</h2>
<ul>
<li><strong>无方向性</strong></li>
<li>单位面积的 power</li>
<li>The irradiance is the <strong>power</strong> <strong>per unit
area</strong> incident on a surface point</li>
</ul>
<p><span class="math display">\[
E(x)\equiv
\dfrac{d\Phi(x)}{dA}\left[\dfrac{W}{m^2}\right]\left[\dfrac{lm}{m^2}=lux\right]
\]</span></p>
<ul>
<li>光线不垂直于面的时候，需要投影到垂直方向
<ul>
<li>一个例子：四季的产生</li>
</ul></li>
<li>解释现象
<ul>
<li>Blinn-Phong 模型中漫反射的计算</li>
<li>光线的衰减
<ul>
<li>Intensity 没有衰减，Irradiance 在衰减</li>
</ul></li>
</ul></li>
</ul>
<h2 id="radiance">Radiance</h2>
<ul>
<li><strong>有方向性</strong></li>
<li>描述光线</li>
<li>The radiance (luminance) is the <strong>power</strong> emitted,
reflected, transmitted or received by a surface, <strong>per unit solid
angle</strong>, <strong>per projected unit area</strong></li>
</ul>
<p><span class="math display">\[
L(p,\omega)\equiv\dfrac{d^2\Phi(p,\omega)}{d\omega dA
\cos\theta}\left[\dfrac{W}{sr\
m^2}\right]\left[\dfrac{cd}{m^2}=\dfrac{lm}{sr\ m^2}=nit\right]
\]</span></p>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/05/1616040769472.png" style="zoom:50%;"></p>
<ul>
<li>dA：发射光的面积</li>
<li><span class="math inline">\(\cos\theta\)</span>：投影</li>
<li>联系
<ul>
<li>Radiance: Irradiance per solid angle</li>
<li>Radiance: Intensity per projected unit area</li>
</ul></li>
</ul>
<h3 id="incident-radiance">Incident Radiance</h3>
<ul>
<li>it is the light arriving at the surface along a given ray (point on
surface and incident direction)</li>
</ul>
<p><span class="math display">\[
L(p,\omega) = \dfrac{dE(p)}{d\omega\cos\theta}
\]</span></p>
<h3 id="exiting-radiance">Exiting Radiance</h3>
<ul>
<li>for an area light it is the light emitted along a given ray (point
on surface and exit direction)</li>
</ul>
<p><span class="math display">\[
L(p,\omega) = \dfrac{dI(p,w)}{dA\cos\theta}
\]</span></p>
<h2 id="irradiance-和-radiance-的关系">Irradiance 和 Radiance
的关系</h2>
<ul>
<li>Radiance 在 Irradiance 的基础上增加了方向性</li>
<li>某个点接受/发射光线总能量：Irradiance</li>
<li>某个点从某个方向接受/向某个方向发射光线能量：Radiance</li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/05/1616041925127.png" style="zoom:50%;"></p>
<p><span class="math display">\[
\begin{array}{c}
dE(p,\omega)=L_i(p.\omega)\cos\theta d\omega\\
E(p,\omega)=\int_{H^2}L_i(p.\omega)\cos\theta d\omega\\
\end{array}
\]</span></p>
<h1 id="brdf">BRDF</h1>
<ul>
<li>Bidirectional Reflectance Distribution Function
<ul>
<li>双向反射分布函数</li>
</ul></li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/05/1616048740113.png" style="zoom:50%;"></p>
<ul>
<li>进入的 irradiance：<span class="math inline">\(dE(\omega_i)=L(\omega_i)\cos\theta_i
d\omega_i\)</span></li>
<li>出去的 radiance（某个特定方向）：<span class="math inline">\(dL_r(\omega_r)\)</span></li>
<li>The BRDF represents how much light is reflected into <strong>each
outgoing direction</strong> from <strong>each incoming
direction</strong>
<ul>
<li>是一个比例</li>
</ul></li>
</ul>
<p><span class="math display">\[
f_{r}(\omega_{i} \to \omega_{r})=\frac{d L_{r}(\omega_{r})}{d
E_{i}(\omega_{i})}=\frac{d L_{r}(\omega_{r})}{L_{i}(\omega_{i}) \cos
\theta_{i} d \omega_{i}}\left[\frac{1}{\mathrm{sr}}\right]
\]</span></p>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/05/1616049786681.png" style="zoom:50%;"></p>
<ul>
<li>BRDF 定义了物体的材质</li>
</ul>
<h2 id="反射方程">反射方程</h2>
<ul>
<li>对所有的入射方向求积分</li>
</ul>
<p><span class="math display">\[
L_{r}\left(p, \omega_{r}\right)=\int_{H^{2}} f_{r}\left(p, \omega_{i}
\rightarrow \omega_{r}\right) L_{i}\left(p, \omega_{i}\right) \cos
\theta_{i} d \omega_{i}
\]</span></p>
<ul>
<li><span class="math inline">\(p\)</span>：入射点</li>
<li><span class="math inline">\(\omega_r\)</span>：出射方向</li>
<li><span class="math inline">\(\omega_i\)</span>：入射方向</li>
</ul>
<h2 id="渲染方程">渲染方程</h2>
<ul>
<li><strong>Rendering Equation (Kajiya 86)</strong></li>
<li>加上自己的发光成分</li>
</ul>
<p><span class="math display">\[
L_{o}(p, \omega_{o})=L_{e}(p, \omega_{o})+\int_{\Omega^{+}} L_{i}(p,
\omega_{i}) f_{r}(p, \omega_{i}, \omega_{o})(n \cdot \omega_{i}) d
\omega_{i}
\]</span></p>
<h2 id="反射方程到渲染方程">反射方程到渲染方程</h2>
<h3 id="点光源">点光源</h3>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/05/1616051060406.png" style="zoom:50%;"></p>
<h3 id="多个光源">多个光源</h3>
<ul>
<li>求和</li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/05/1616051097562.png" style="zoom:50%;"></p>
<h3 id="面光源">面光源</h3>
<ul>
<li>积分</li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/05/1616051126190.png" style="zoom:50%;"></p>
<h3 id="渲染方程-1">渲染方程</h3>
<ul>
<li>间接光照</li>
<li>把物体当成是光源</li>
<li>现在解渲染方程，相当于求解 <span class="math inline">\(L\)</span></li>
</ul>
<p><img src="/2021/03/17/CG/YLQ-GAMES101/05/1616051477446.png" style="zoom:50%;"></p>
<h2 id="integral-equation">Integral Equation</h2>
<ul>
<li>渲染方程转化为积分方程</li>
</ul>
<p><span class="math display">\[
I(u)=e(u)+\int l(v)K(u,v)dv
\]</span></p>
<ul>
<li><span class="math inline">\(K(u,v)dv\)</span>：Kernel of equation
Light Transport Operator</li>
</ul>
<h2 id="linear-operator-equation">Linear Operator Equation</h2>
<ul>
<li>通过算符的抽象还可极度简化成如下形式</li>
</ul>
<p><span class="math display">\[
L = E + KL
\]</span></p>
<ul>
<li>解渲染方程</li>
</ul>
<p><span class="math display">\[
L=(I-K)^{-1}E
\]</span></p>
<p><span class="math display">\[
L=(I+K+K^2+K^3+K^2+\cdots)E
\]</span></p>
<ul>
<li><span class="math inline">\(E\)</span>：自发光</li>
<li><span class="math inline">\(KE\)</span>：直接光照</li>
<li><span class="math inline">\(KE^2\)</span>：one-bounce indirect</li>
<li>光栅化着色：<span class="math inline">\(E+KE\)</span></li>
<li>全局光照：直接和间接光照的集合</li>
<li>光线跟踪的结果次数增加
<ul>
<li><strong>会收敛到一个亮度</strong></li>
<li>能量守恒</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES101</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
        <tag>GI</tag>
        <tag>Radiometry</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101.闫令琪.06.光线追踪(3).蒙特卡洛路径追踪(Lecture 15-16)</title>
    <url>/2021/03/18/CG/YLQ-GAMES101/06/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/av90798049</li>
</ul>
<h1 id="概率论回顾">概率论回顾</h1>
<ul>
<li>随机变量 <span class="math inline">\(X\)</span></li>
</ul>
<h2 id="离散">离散</h2>
<ul>
<li>概率分布函数 <span class="math inline">\(X \sim p(x)\)</span>
<ul>
<li>Probability Density Function (PDF)</li>
</ul></li>
<li>性质
<ul>
<li><span class="math inline">\(p_i\ge0\)</span></li>
<li><span class="math inline">\(\sum_{i=1}^np_i=1\)</span></li>
</ul></li>
<li>期望 <span class="math inline">\(E(X)\)</span>
<ul>
<li><span class="math inline">\(E[X]=\sum_{i=1}^{n} x_{i}
p_{i}\)</span></li>
</ul></li>
</ul>
<h2 id="连续">连续</h2>
<ul>
<li>概率密度函数 <span class="math inline">\(X \sim p(x)\)</span>
<ul>
<li>Probability Distribution Function (PDF)</li>
</ul></li>
<li>某一个 <span class="math inline">\(x\)</span> 对应的微元对应的概率
<span class="math inline">\(p(x)dx\)</span>
<ul>
<li>长条面积</li>
</ul></li>
<li>性质
<ul>
<li><span class="math inline">\(p(x)\ge0\)</span></li>
<li><span class="math inline">\(\int p(x)dx=1\)</span></li>
</ul></li>
<li>期望
<ul>
<li><span class="math inline">\(E[X]=\int x p(x) d x\)</span></li>
</ul></li>
</ul>
<h2 id="随机变量的函数">随机变量的函数</h2>
<ul>
<li>如果某个随机变量 <span class="math inline">\(Y\)</span> 是随机变量
<span class="math inline">\(X\)</span> 的函数
<ul>
<li><span class="math inline">\(Y=f(X)\)</span></li>
</ul></li>
<li>期望的关系
<ul>
<li><span class="math inline">\(E[Y]=E[f(X)]=\int
f(x)p(x)dx\)</span></li>
</ul></li>
</ul>
<h1 id="蒙特卡洛积分">蒙特卡洛积分</h1>
<ul>
<li>Monte Carlo Integration</li>
<li>用于求定积分
<ul>
<li>数值形式是比较难求的定积分</li>
</ul></li>
<li>黎曼积分：划分为若干段，每段围成的小矩形之和（极限）</li>
</ul>
<h2 id="monte-carlo-积分">Monte Carlo 积分</h2>
<ul>
<li>定积分 <span class="math inline">\(\int_a^bf(x)dx\)</span></li>
<li>随机变量 <span class="math inline">\(X_i\sim p(x)\)</span></li>
<li>蒙特卡洛积分 <span class="math inline">\(F_{N}=\dfrac{1}{N}
\sum_{i=1}^{N} \dfrac{f(X_{i})}{p(X_{i})}\)</span></li>
</ul>
<h2 id="例子均匀分布">例子：均匀分布</h2>
<ul>
<li><span class="math inline">\(X_i\sim p(x)=C\)</span>
<ul>
<li><span class="math inline">\(\int_a^bCdx=C(b-a)=1\)</span></li>
<li><span class="math inline">\(C=\dfrac{1}{b-a}\)</span></li>
</ul></li>
<li><span class="math inline">\(F_N=\dfrac{b-a}{N}
\sum_{i=1}^{N}f(X_{i})\)</span></li>
</ul>
<h2 id="性质">性质</h2>
<ul>
<li>样本越多，越准确
<ul>
<li>The more samples, the less variance.</li>
</ul></li>
<li>对 x 采样，只能对 x 做积分
<ul>
<li>Sample on x, integrate on x.</li>
</ul></li>
</ul>
<h1 id="path-tracing">Path Tracing</h1>
<h2 id="whitted-style-ray-tracing">Whitted-Style Ray Tracing</h2>
<ul>
<li>具体运作
<ul>
<li>Always perform <strong>specular</strong> reflections /
refractions</li>
<li><strong>Stop</strong> bouncing at <strong>diffuse</strong>
surfaces</li>
</ul></li>
</ul>
<h3 id="问题">问题</h3>
<ul>
<li>不能很好的模拟 <strong>Glossy</strong>（金属，类似磨砂的感觉）
材质的物体</li>
<li>能产生高光，但是又有点糊，没有那么光滑</li>
<li>The Utah Teapot（经典模型）</li>
</ul>
<p><img src="/2021/03/18/CG/YLQ-GAMES101/06/1616057889780.png" style="zoom:50%;"></p>
<ul>
<li>漫反射物体之间的反射光无法模拟
<ul>
<li><strong>Color Bleeding</strong> 效果
<ul>
<li>右图中盒子的侧面产生红色 / 绿色的效果</li>
</ul></li>
</ul></li>
<li>The Cornell Box（经典模型）
<ul>
<li>广泛用于测试全局光照</li>
</ul></li>
</ul>
<p><img src="/2021/03/18/CG/YLQ-GAMES101/06/1616058100814.png" style="zoom:50%;"></p>
<h2 id="路径追踪">路径追踪</h2>
<ul>
<li>基于渲染方程</li>
</ul>
<p><span class="math display">\[
L_{o}(p, \omega_{o})=L_{e}(p, \omega_{o})+\int_{\Omega^{+}} L_{i}(p,
\omega_{i}) f_{r}(p, \omega_{i}, \omega_{o})(n \cdot \omega_{i}) d
\omega_{i}
\]</span></p>
<ul>
<li>问题
<ul>
<li>积分：蒙特卡洛方法求解</li>
<li>递归定义</li>
</ul></li>
</ul>
<h2 id="简单的蒙特卡洛方法求积分">简单的蒙特卡洛方法求积分</h2>
<ul>
<li>忽略发光项</li>
</ul>
<p><span class="math display">\[
L_{o}(p, \omega_{o})=\int_{\Omega^{+}} L_{i}(p, \omega_{i}) f_{r}(p,
\omega_{i}, \omega_{o})(n \cdot \omega_{i}) d \omega_{i}
\]</span></p>
<ul>
<li>待求的就是上面的方程</li>
<li>蒙特卡洛积分方程</li>
</ul>
<p><span class="math display">\[
\int_a^bf(x)dx\approx\dfrac{1}{N} \sum_{i=1}^{N}
\dfrac{f(X_{i})}{p(X_{i})},X_k\sim p(x)
\]</span></p>
<p><span class="math display">\[
f(x)= L_{i}(p, \omega_{i}) f_{r}(p, \omega_{i}, \omega_{o})(n \cdot
\omega_{i}) d \omega_{i}
\]</span></p>
<ul>
<li>简单的 PDF
<ul>
<li>半球立体为 <span class="math inline">\(2\pi\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
p(\omega_i)=\dfrac{1}{2\pi}
\]</span></p>
<ul>
<li>积分方程</li>
</ul>
<p><span class="math display">\[
L_{o}(p, \omega_{o})\approx\dfrac{2\pi}{N} \sum_{i=1}^{N} L_{i}(p,
\omega_{i}) f_{r}(p, \omega_{i}, \omega_{o})(n \cdot \omega_{i}) d
\omega_{i}
\]</span></p>
<ul>
<li>根据这个方程，那么就可以得出一个算法
<ul>
<li>递归算法</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shade(p, wo):</span><br><span class="line">    Randomly choose N directions wi~pdf</span><br><span class="line">    Lo = <span class="number">0.0</span></span><br><span class="line">    For each wi:</span><br><span class="line">        Trace a ray r(p, wi)</span><br><span class="line">        <span class="comment"># 碰到光源, 直接光照</span></span><br><span class="line">        If ray r hit the light:</span><br><span class="line">            Lo += (<span class="number">1</span> / N) * L_i * f_r * cosine / pdf(wi)</span><br><span class="line">        <span class="comment"># 碰到物体, 间接光照</span></span><br><span class="line">        Else If ray r hit an <span class="built_in">object</span> at q:</span><br><span class="line">            Lo += (<span class="number">1</span> / N) * shade(q, -wi) * f_r * cosine/ pdf(wi)</span><br><span class="line">    <span class="keyword">return</span> Lo</span><br></pre></td></tr></table></figure>
<h3 id="问题1指数爆炸">问题1：指数爆炸</h3>
<ul>
<li>光线数量：<span class="math inline">\(N^{bounces}\)</span></li>
<li><span class="math inline">\(N=1\)</span>
则不会有问题：近似效果会变差</li>
<li>近似效果很差，noisy</li>
</ul>
<h4 id="解决方案">解决方案</h4>
<ul>
<li><strong>可以为同一个像素，多次发射光线</strong>
<ul>
<li>Trace <strong>more paths</strong> through each
<strong>pixel</strong> and <strong>average</strong> their radiance!</li>
</ul></li>
</ul>
<p><img src="/2021/03/18/CG/YLQ-GAMES101/06/1616059764715.png" style="zoom:50%;"></p>
<ul>
<li>Ray Generation</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ray_generation(camPos, pixel):</span><br><span class="line">    Uniformly choose N sample positions within the pixel</span><br><span class="line">    pixel_radiance = <span class="number">0.0</span></span><br><span class="line">    For each sample <span class="keyword">in</span> the pixel:</span><br><span class="line">        Shoot a ray r(camPos, cam_to_sample)</span><br><span class="line">        If ray r hit the scene at p:</span><br><span class="line">            pixel_radiance += <span class="number">1</span> / N * shade(p, sample_to_cam)</span><br><span class="line">    <span class="keyword">return</span> pixel_radiance</span><br></pre></td></tr></table></figure>
<h3 id="问题2停不下来">问题2：停不下来</h3>
<ul>
<li>互相调用：概率是很小的</li>
<li>事先设置一个递归深度
<ul>
<li>不行，之前的例子</li>
<li>玻璃灯，当设置的 bounces
比较小的时候，由于光线没有从玻璃外壳内出来，看不到里面的灯</li>
<li>能量损失了
<ul>
<li>Cutting #bounces == cutting energy!</li>
</ul></li>
</ul></li>
</ul>
<h4 id="解决方法">解决方法</h4>
<ul>
<li>Russian Roulette（RR）
<ul>
<li>俄罗斯轮盘赌</li>
</ul></li>
<li>一定的概率停止光线追踪
<ul>
<li>概率 <span class="math inline">\(p\)</span>
发出一条光线，将得到的结果除以 <span class="math inline">\(p\)</span>
<ul>
<li><span class="math inline">\(\dfrac{L_o}{p}\)</span></li>
</ul></li>
<li>概率 <span class="math inline">\(1-p\)</span> 不发出光线，得到结果
<span class="math inline">\(0\)</span></li>
<li>巧妙的一点：期望还是 <span class="math inline">\(L_o\)</span>
<ul>
<li><span class="math inline">\(E(X)=p\times\dfrac{L_O}{p}+(1-p)*0=L_O\)</span></li>
</ul></li>
</ul></li>
<li>伪代码如下（<span class="math inline">\(N=1\)</span>）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shade(p, wo):</span><br><span class="line">    Manually specify a probability P_RR</span><br><span class="line">    Randomly select ksi <span class="keyword">in</span> a uniform dist. <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    If (ksi &gt; P_RR):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    Randomly choose ONE direction wi~pdf(w)</span><br><span class="line">    Trace a ray r(p, wi)</span><br><span class="line">    If ray r hit the light:</span><br><span class="line">        <span class="keyword">return</span> L_i * f_r * cosine / pdf(wi) / P_RR</span><br><span class="line">    Else If ray r hit an <span class="built_in">object</span> at q:</span><br><span class="line">        <span class="keyword">return</span> shade(q, -wi) * f_r * cosine / pdf(wi) / P_RR</span><br></pre></td></tr></table></figure>
<ul>
<li>bounces 的期望</li>
</ul>
<p><span class="math display">\[
\sum_i^{\infty}i(p^{i})(1-p)=\dfrac{p}{1-p}
\]</span></p>
<h3 id="问题3ssp-小时效果不好">问题3：SSP 小时效果不好</h3>
<ul>
<li>SSP：Samples Per Pixels</li>
<li>SSP 高的时候，运行很慢</li>
</ul>
<p><img src="/2021/03/18/CG/YLQ-GAMES101/06/1616060900428.png" style="zoom:50%;"></p>
<ul>
<li>光源比较小的时候，发射出较少的光线<strong>很难打到光源</strong></li>
</ul>
<h4 id="解决方案-1">解决方案</h4>
<ul>
<li>修改 PDF</li>
<li>对光源采样</li>
</ul>
<h4 id="sampling-to-the-light">Sampling to the light</h4>
<ul>
<li>对光源均匀采样</li>
<li>面光源面积为 A
<ul>
<li><span class="math inline">\(PDF = \dfrac{1}{A}\)</span></li>
</ul></li>
<li>蒙特卡洛方法满足的条件：对谁积分，对谁采样
<ul>
<li>把渲染方程写成对光源表面的积分</li>
<li>找出 <span class="math inline">\(dA\)</span> 和 <span class="math inline">\(d\omega\)</span> 的关系
<ul>
<li><span class="math inline">\(dw=\dfrac{dA\cos\theta&#39;}{||x&#39;-x||^2}\)</span></li>
<li>向球面做投影</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/03/18/CG/YLQ-GAMES101/06/1616070852888.png" alt="1616070852888" style="zoom:50%;"></p>
<ul>
<li>重写渲染方程</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
L_{o}(p, \omega_{o})&amp;=\int_{\Omega^{+}} L_{i}(p, \omega_{i})
f_{r}(p, \omega_{i}, \omega_{o})(n \cdot \omega_{i}) d \omega_{i}\\
&amp;=\int_{A} L_{i}(p, \omega_{i}) f_{r}(p, \omega_{i}, \omega_{o})(n
\cdot \omega_{i}) \dfrac{dA\cos\theta&#39;}{||x&#39;-x||^2}\\
&amp;=\int_{A} L_{i}(p, \omega_{i}) f_{r}(p, \omega_{i},
\omega_{o})\dfrac{\cos\theta\cos\theta&#39;}{||x&#39;-x||^2}dA\\
\end{aligned}
\]</span></p>
<ul>
<li>我们将光照分为两个部分
<ul>
<li><strong>light source</strong> (direct, no need to have RR)
<ul>
<li>光源对这个点的共享</li>
</ul></li>
<li><strong>other reflectors</strong> (indirect, RR)
<ul>
<li>所有其他非光源对这个点的贡献</li>
</ul></li>
</ul></li>
<li>伪代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shade(p, wo):</span><br><span class="line">    <span class="comment"># Contribution from the light source.</span></span><br><span class="line">    <span class="comment"># 对光源采样</span></span><br><span class="line">    Uniformly sample the light at x’ (pdf_light = <span class="number">1</span> / A)</span><br><span class="line">    L_dir = L_i * f_r * cos θ * cos θ’ / |x’ - p|^<span class="number">2</span> / pdf_light</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Contribution from other reflectors.</span></span><br><span class="line">    <span class="comment"># 对其他物体采样</span></span><br><span class="line">    L_indir = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 俄罗斯轮盘赌测试</span></span><br><span class="line">    Test Russian Roulette <span class="keyword">with</span> probability P_RR</span><br><span class="line">    Uniformly sample the hemisphere toward wi (pdf_hemi = <span class="number">1</span> / 2pi)</span><br><span class="line">    Trace a ray r(p, wi)</span><br><span class="line">    <span class="comment"># 得判断不是光源</span></span><br><span class="line">    If ray r hit a non-emitting <span class="built_in">object</span> at q:</span><br><span class="line">        L_indir = shade(q, -wi) * f_r * cos θ / pdf_hemi / P_RR</span><br><span class="line"></span><br><span class="line">    Return L_dir + L_indir</span><br></pre></td></tr></table></figure>
<ul>
<li>问题：如果光源和待求的点之间有物体
<ul>
<li>采样点和待求的点之间打一条光线，判断是否会相交</li>
</ul></li>
<li><strong>点光源不好处理</strong>
<ul>
<li>做成一个很小的光源</li>
</ul></li>
</ul>
<h2 id="path-tracing-评价">Path Tracing 评价</h2>
<ul>
<li>Path tracing (PT) is indeed difficult
<ul>
<li>Consider it the most challenging in undergrad CS</li>
<li>Why: physics, probability, calculus（微积分学）, coding</li>
<li>Learning PT will help you understand deeper in these</li>
</ul></li>
<li>Path Tracing 能够做到几乎 100% 真实
<ul>
<li><span style="color:red;font-weight:bold">PHOTO-REALISTIC</span></li>
<li>照片级的真实感</li>
<li>例子：http://www.graphics.cornell.edu/online/box/compare.html</li>
</ul></li>
</ul>
<h2 id="关于-ray-tracing-这个概念">关于 Ray Tracing 这个概念</h2>
<ul>
<li>Ray tracing: Previous vs. Modern Concept</li>
<li>以前
<ul>
<li>一般指的就是 Whitted 风格的 Ray-Tracing</li>
</ul></li>
<li>现代
<ul>
<li>所有关于光线传播方法的一个大集合</li>
<li>(Unidirectional &amp; bidirectional) path tracing</li>
<li>Photon mapping
<ul>
<li>光子映射</li>
</ul></li>
<li>Metropolis light transport</li>
<li>VCM / UPBP…</li>
</ul></li>
</ul>
<h2 id="未涵盖的话题">未涵盖的话题</h2>
<ul>
<li>怎么样在半球上均匀的采样</li>
<li>给一个任何函数，怎么对它进行采样</li>
<li>对于蒙特卡洛采样方法，对于一个函数，怎么选择 PDF 使得最优
<ul>
<li>重要性采样理论
<ul>
<li>important sampling</li>
</ul></li>
<li>用随机数怎么样
<ul>
<li>随机数有质量之分</li>
<li>好的随机数：均匀分布在空间内，随机数之间的距离也能控制得很好
<ul>
<li>low discrepancy sequences</li>
</ul></li>
</ul></li>
</ul></li>
<li>能不能把对光源和物体的采样结合起来
<ul>
<li>可以，把不同的采样方法结合起来，使得效果不会比原来的任何一种方法差</li>
<li>MIS 采样理论</li>
<li>multiple imp. sampling</li>
</ul></li>
<li>对于同一个像素的不同
path，简单的做平均行不行，需不需要对靠近中心一点的 path 加一个更大的权
<ul>
<li>pixel reconstruction filter</li>
</ul></li>
<li>最终计算出来的是一个 radiance，怎么转化为颜色
<ul>
<li>gamma correction</li>
<li>color space</li>
<li>HDR（curve）</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES101</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
        <tag>GI</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101.闫令琪.08.高级光线传播与复杂外观建模(Lecture 18)</title>
    <url>/2021/03/22/CG/YLQ-GAMES101/08/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/av90798049</li>
</ul>
<h1 id="高级光线传播">高级光线传播</h1>
<ul>
<li>Advanced Light Transport</li>
<li>Unbiased light transport methods
<ul>
<li>Bidirectional path tracing (BDPT)</li>
<li>Metropolis light transport (MLT)</li>
</ul></li>
<li>Biased light transport methods
<ul>
<li>Photon mapping</li>
<li>Vertex connection and merging (VCM)</li>
</ul></li>
<li>Instant radiosity (VPL / many light methods)</li>
</ul>
<h2 id="有偏无偏估计">有偏无偏估计</h2>
<ul>
<li>无偏估计 unbiased</li>
<li>An <strong>unbiased</strong> Monte Carlo technique does not have any
systematic error
<ul>
<li>不管样本数是多少个，无偏估计的期望总是正确的</li>
<li>The expected value of an unbiased estimator will always be the
correct value, no matter how many samples are used.</li>
</ul></li>
<li>有偏估计 biased
<ul>
<li>一致的 consistent
<ul>
<li>当使用的样本数很多时，期望会收敛到正确的值</li>
<li>the expected value converges to the correct value as infinite
#samples are used.</li>
</ul></li>
</ul></li>
</ul>
<h3 id="渲染中的有偏无偏">渲染中的有偏无偏</h3>
<ul>
<li>An easier understanding bias in rendering
<ul>
<li>Biased == blurry</li>
<li>Consistent == not blurry with infinite #samples</li>
</ul></li>
<li>有偏：模糊
<ul>
<li>一致性：无限的条件下是不模糊的</li>
</ul></li>
</ul>
<h2 id="无偏的">无偏的</h2>
<h3 id="双向路径追踪bdpt">双向路径追踪(BDPT)</h3>
<ul>
<li>Bidirectional Path Tracing (BDPT)</li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616402891446.png" style="zoom:50%;"></p>
<ul>
<li>光源出发发射出半路径，视点出发发射出半路径，BDPT
把这两条路径连接起来
<ul>
<li>思想简单</li>
<li><strong>实现复杂</strong></li>
<li>相对较慢</li>
</ul></li>
<li>有些情况下 BDPT 效果非常好（下图）
<ul>
<li>下图的特点：first-bounce 是 diffuse 的
<ul>
<li>如果用之前的路径追踪方法，不容易控制光线打到光源上</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616402997421.png" style="zoom:60%;"></p>
<h3 id="metropolis-light-transportmlt">Metropolis Light
Transport(MLT)</h3>
<ul>
<li>Metropolis：人名</li>
<li>利用 MCMC 方法实现
<ul>
<li>MCMC：Markov Chain Mente Carlo</li>
<li>根据当前的样本生成下一个样本
<ul>
<li>之前的蒙特卡洛方法不考虑当前样本的影响</li>
</ul></li>
</ul></li>
<li>对于之前的蒙特卡洛采样方法，<strong>当你用于采样的 PDF
和原来的函数一致的时候，效果是最好的（方差最小）</strong></li>
<li>MCMC 方法能够生成一些样本，使得这些样本的分布和原来的函数一致</li>
<li>Jumping from the current sample to the next with some PDF</li>
<li><strong>Very good</strong> at <strong>locally</strong> exploring
difficult light paths</li>
<li>能够在找到蓝色光路的条件下很快找到红色的光路</li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616403640009.png" style="zoom: 67%;"></p>
<ul>
<li>Works great with difficult light paths
<ul>
<li>很适合复杂光路查找的情景</li>
<li>当找到一条光路之后，很快生成其他可能的光路</li>
</ul></li>
<li>两个例子（很难找光路）
<ul>
<li>半开着门</li>
<li>焦散现象 caustic</li>
</ul></li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616403852845.png" style="zoom: 67%;"></p>
<ul>
<li>缺点
<ul>
<li>Difficult to estimate the convergence rate
<ul>
<li>很难估计收敛速度</li>
</ul></li>
<li>Does not guarantee equal convergence rate per pixel
<ul>
<li>所有点的收敛速度不能保证一致</li>
</ul></li>
<li>So, usually produces “dirty” results</li>
<li>Therefore, usually not used to render animations
<ul>
<li>这样这种方法在很难用于渲染动画</li>
<li>相邻两帧可能有些点收敛了，有些没收敛，导致抖动</li>
</ul></li>
</ul></li>
</ul>
<h2 id="有偏的">有偏的</h2>
<h3 id="光子映射">光子映射</h3>
<ul>
<li>photon mapping</li>
<li>Very good at handling Specular-Diffuse-Specular
(<strong>SDS</strong>) paths and <strong>generating caustics</strong>
<ul>
<li>SDS：例如之前在水底的反射</li>
</ul></li>
<li>很适合渲染焦散的场景
<ul>
<li>焦散（caustics）：由于光线的聚焦产生的非常强的图案</li>
<li>只是聚焦，没有发散的意思</li>
</ul></li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616404163843.png"></p>
<h4 id="一种实现方法">一种实现方法</h4>
<ul>
<li>两步的方法（2-stage）</li>
</ul>
<h5 id="stage-1-photon-tracing">(1) Stage 1: photon tracing</h5>
<ul>
<li>Emitting photons from the light source, bouncing them around, then
recording photons on diffuse surfaces
<ul>
<li>从光源辐射出很多的光子，反射，直到光子打到 diffuse 的材质上</li>
<li>整理光子，记录光子的位置</li>
</ul></li>
</ul>
<h5 id="stage-2-photon-collection">(2) Stage 2: photon collection</h5>
<ul>
<li>Shoot sub-paths from the camera, bouncing them around, until they
hit diffuse surfaces</li>
<li>从视点辐射出很多光线，反射，直到打到 diffuse 的材质上</li>
</ul>
<h5 id="计算">(3) 计算</h5>
<ul>
<li><strong>local density estimation</strong>
<ul>
<li>局部密度估计</li>
</ul></li>
<li>ideas：光子分布越集中的地方，应该更亮</li>
<li>对于任何的一个着色点，取其最近的 N
个光子，求出包围他们的球体在表面占的面积
<ul>
<li>求出其密度</li>
</ul></li>
</ul>
<h5 id="评价">评价</h5>
<ul>
<li>N 太小你会看到有噪声（noisy），N
比较大（但是不是无限）会看到图片模糊（blurry）</li>
</ul>
<h5 id="问题的产生">问题的产生</h5>
<ul>
<li>局部密度估计应该是 <span class="math inline">\(\dfrac{dN}{dA}\)</span>，而不是 <span class="math inline">\(\dfrac{\Delta N}{\Delta A}\)</span></li>
<li>当 <span class="math inline">\(\Delta A\)</span>
足够小的时候上面两个值才相等</li>
<li>解决方法：发射出更多的光子，这样还是收集 N 个光子的话，面积就更小
<ul>
<li>发射出的光子足够多，结果就是正确的（一致性 consistent）</li>
</ul></li>
<li>只有当 N 是无限的情况下，才是完全正确的，N
不是无限的时候，多少会有点糊</li>
</ul>
<h4 id="另外的方法">另外的方法</h4>
<ul>
<li>取一个固定大小的范围，统计光子数量，然后计算局部密度</li>
<li>始终是<strong>有偏的</strong>，而且不是<strong>一致</strong>的</li>
</ul>
<h3 id="vertex-connection-and-mergingvcm">Vertex Connection and
Merging(VCM)</h3>
<ul>
<li>把 BDPT 和 photon mapping 结合在一起</li>
<li>ideas
<ul>
<li>Let’s not waste the sub-paths in BDPT if <strong>their end points
cannot be connected</strong> but <strong>can be merged</strong></li>
<li>Use photon mapping to handle the merging of nearby "photons"</li>
</ul></li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616406256091.png" style="zoom:50%;"></p>
<ul>
<li>在 BDPT 基础上，如果有这样的 path
<ul>
<li>端点在同一个面上（不可能通过反射连接起来）</li>
<li>端点离得的足够近</li>
</ul></li>
<li>此时认为从光源发出来的是光子，利用光子映射的方法进行计算（原来认为是一条
sub-path）</li>
</ul>
<h2 id="实时辐射度算法">实时辐射度算法</h2>
<ul>
<li>Instant Radiosity (IR)</li>
<li>也被称为 many-light approaches</li>
<li>思想：已经被照亮的面可以当作光源</li>
<li>算法：
<ul>
<li>Shoot light sub-paths and assume the end point of each sub-path is a
Virtual Point Light (VPL)
<ul>
<li>从光源打出一些光线，光线停在某一个表面上，把光线端点当作虚拟光源</li>
</ul></li>
<li>Render the scene as usual using these VPLs
<ul>
<li>使用虚拟的光源计算光照</li>
</ul></li>
</ul></li>
<li>可以得到间接光照的结果</li>
<li>优点
<ul>
<li>很快</li>
<li>漫反射场景中表现较好</li>
</ul></li>
<li>问题
<ul>
<li>对于 glossy 材质的物体不能很好渲染</li>
<li>当 VPLs 和待渲染的点离得较近的时候，会出现一些奇怪的高亮
<ul>
<li>和平方项有关，距离很近的时候，相当于除了一个很小的数</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616517146224.png" style="zoom: 80%;"></p>
<h2 id="现状">现状</h2>
<ul>
<li>暂时没有一个方法能够解决所有问题</li>
<li>工业界：path tracing 居多，不高端，但是可靠</li>
</ul>
<h1 id="复杂外观建模">复杂外观建模</h1>
<ul>
<li>Advanced Appearance Modeling</li>
<li>Non-surface models 非表面模型
<ul>
<li>Participating media 散射介质</li>
<li>Hair / fur / fiber (BCSDF) 头发/毛发/纤维</li>
<li>Granular material 沙子</li>
</ul></li>
<li>Surface models 表面模型
<ul>
<li>Translucent material (BSSRDF) 半透明</li>
<li>Cloth 布料</li>
<li>Detailed material (non-statistical BRDF) 细节化的模型</li>
</ul></li>
<li>Procedural appearance 程序化生成的模型</li>
</ul>
<h2 id="非表面模型">非表面模型</h2>
<h3 id="散射介质">散射介质</h3>
<ul>
<li>Participating media
<ul>
<li>散射介质 / 参与介质</li>
</ul></li>
<li>Fog （雾），Cloud （云）
<ul>
<li>不是在表面上，定义在空间中</li>
</ul></li>
<li>当光线穿越过散射介质的时候，光线会被 <strong>吸收/散射</strong></li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616555378102.png" style="zoom:80%;"></p>
<ul>
<li>怎么散射？
<ul>
<li>Phase Function（相位函数）
<ul>
<li>类似于 BRDF 规定了怎么反射，PF 规定了怎么散射</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616556350070.png" style="zoom:80%;"></p>
<h4 id="渲染方式">渲染方式</h4>
<ul>
<li>随机选择一个方向去反射</li>
<li>随机选择一个方向直走</li>
<li>对于路径上的所有点（shading point），跟光源相连</li>
<li>不仅需要考虑渲染方程，需要考虑光线和体积之间的作用
<ul>
<li>思想是一样的，产生一些光线的路径</li>
</ul></li>
</ul>
<h3 id="毛发">毛发</h3>
<ul>
<li>光线和曲线的作用</li>
<li>两种高光：有色、无色</li>
</ul>
<h4 id="kajiya-ray-model">Kajiya-Ray Model</h4>
<ul>
<li>类似于之前的 specular + diffuse，光线打到圆柱上
<ul>
<li>散射出一个圆锥</li>
<li>同时又有一部分散射到四面八方</li>
</ul></li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616557193280.png" style="zoom:50%;"></p>
<h4 id="marschner-model">Marschner Model</h4>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616557433440.png" style="zoom: 67%;"></p>
<ul>
<li><strong>广泛应用的模型</strong></li>
<li>R: reflection, T: transmission
<ul>
<li>R：有一部分被直接反射</li>
<li>TT：有一部分被穿透头发，然后再穿透出来</li>
<li>TRT：穿透，反射，穿透</li>
</ul></li>
<li>头发是一个玻璃柱（小段），内部有色素（会吸收能量）</li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616557623819.png" style="zoom:50%;"></p>
<ul>
<li><strong>计算量很大</strong>，头发渲染非常难</li>
</ul>
<h3 id="动物毛发">动物毛发</h3>
<ul>
<li>使用头发的渲染模型渲染的效果不好</li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616557872091.png" style="zoom: 80%;"></p>
<ul>
<li>生物结构
<ul>
<li>动物毛发的髓质比较大，光线更容易发生<strong>散射</strong></li>
</ul></li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616557930395.png" style="zoom:60%;"></p>
<ul>
<li>加入髓质的效果</li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616558220862.png" style="zoom:50%;"></p>
<h4 id="double-cylinder-model">Double Cylinder Model</h4>
<ul>
<li>双层圆柱模型（闫令琪提出）</li>
<li>精确的描述髓质的作用
<ul>
<li>Cortex：absorbs</li>
<li>Medulla：scatters</li>
</ul></li>
<li>效果会更亮
<ul>
<li>s：scatter 散射</li>
</ul></li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616558389562.png" style="zoom:60%;"></p>
<ul>
<li>效果图</li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616559546400.png" style="zoom:67%;"></p>
<h3 id="颗粒材质">颗粒材质</h3>
<ul>
<li>Granular</li>
<li>一粒一粒的材质
<ul>
<li>糖、盐、沙子</li>
</ul></li>
<li><strong>计算量很大</strong></li>
</ul>
<h2 id="表面模型">表面模型</h2>
<h3 id="translucent-material">Translucent Material</h3>
<ul>
<li>semi-transparent：半透明材质，光线经过物体的时候发生<strong>吸收</strong></li>
<li>translucent：光线经过物体的时候发生<strong>吸收和散射</strong></li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616559215018.png" style="zoom:80%;"></p>
<ul>
<li>例子
<ul>
<li>Jade：玉石</li>
<li>Jellyfish：水母</li>
<li>人的耳朵</li>
</ul></li>
<li>次表面散射：subsurface scattering</li>
</ul>
<h4 id="bssrdf">BSSRDF</h4>
<ul>
<li>对 BRDF 概念的延伸</li>
<li><span class="math inline">\(S(x_i,\omega_i,x_o,\omega_o)\)</span>：从点 <span class="math inline">\(x_i\)</span> 处入射，入射方向为 <span class="math inline">\(\omega_i\)</span>，从点 <span class="math inline">\(x_o\)</span> 处出射，出射方向为 <span class="math inline">\(\omega_o\)</span></li>
<li>渲染方程需要修改，需要对整个表面进行积分</li>
</ul>
<p><span class="math display">\[
L\left(x_{o}, \omega_{o}\right)=\int_{A} \int_{H^{2}} S\left(x_{i},
\omega_{i}, x_{o}, \omega_{o}\right) L_{i}\left(x_{i}, \omega_{i}\right)
\cos \theta_{i} \mathrm{d} \omega_{i} \mathrm{d} A
\]</span></p>
<ul>
<li>计算量很大</li>
</ul>
<h5 id="dipole-approximation">Dipole Approximation</h5>
<ul>
<li>Jensen et al. 2001</li>
<li>模仿次表面反射，效果差不多，但是计算量小很多</li>
<li>现实观察
<ul>
<li>光线打到物体上，好像物体底下出现了一个光源，这个光源会照亮其周围的一片</li>
<li>物理上的真实：上方还需要有一个光源</li>
</ul></li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616559823614.png" style="zoom:60%;"></p>
<h5 id="bssrdf-效果">BSSRDF 效果</h5>
<ul>
<li>更接近物理真实，效果更好</li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616560024307.png" style="zoom: 50%;"></p>
<ul>
<li>惊人效果
<ul>
<li>https://cgelves.com/10-most-realistic-human-3d-models-that-will-wow-you/</li>
</ul></li>
</ul>
<h3 id="cloth">Cloth</h3>
<ul>
<li>布料</li>
<li>布料的层级
<ul>
<li>纤维 fibers</li>
<li>股 ply</li>
<li>线 yarn</li>
<li>布料 cloth</li>
</ul></li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616560289100.png" style="zoom:50%;"></p>
<ul>
<li>表面模型和针织的方向、图案有关</li>
<li>根据形状计算 BRDF</li>
<li>有些材质不能解决
<ul>
<li>天鹅绒，不在平面上</li>
</ul></li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616560435020.png" style="zoom:57%;"></p>
<ul>
<li>更准确的做法：空间分布的体积
<ul>
<li>空间体积划分，最终好像就在渲染云一样</li>
<li><strong>计算量很大</strong></li>
</ul></li>
<li>逐纤维渲染
<ul>
<li>计算量很大</li>
</ul></li>
</ul>
<h3 id="detailed-appearance">Detailed Appearance</h3>
<ul>
<li>渲染的结果看着不真实的原因之一：过于完美</li>
<li>真实世界很复杂</li>
<li>手动加入划痕，刷（各向异性）</li>
<li>微表面模型
<ul>
<li>表面法线分布：<span class="math inline">\(D(h)\)</span></li>
<li>简单的正态分布等过于完美
<ul>
<li>法线贴图</li>
</ul></li>
</ul></li>
<li>计算复杂度很高，需要渲染很久
<ul>
<li>原因是表面都是<strong>镜面</strong>，很难让从视点发出的光线打到光源</li>
<li>很难找到一条合理的光路</li>
</ul></li>
<li>解决方式：BRDF over a pixel
<ul>
<li>一个像素出去的光线会覆盖一个区域内的微表面（patch），我们将这一部分区域的分布拿出来，替代原本的光滑的法线，并且用在微表面模型里</li>
<li>p-NDFs</li>
</ul></li>
</ul>
<p><img src="/2021/03/22/CG/YLQ-GAMES101/08/1616565254723.png" style="zoom:60%;"></p>
<ul>
<li>海面的模拟：波光粼粼的效果</li>
</ul>
<h3 id="波动光学">波动光学</h3>
<ul>
<li>Waved Optics</li>
<li>当物体的尺寸和光的波长相近的时候，会发生衍射、干涉等现象的发生（光不再沿直线传播）</li>
<li>例子：
<ul>
<li>小黑屋里面，关掉所光源，只用一个点光源照亮金属片，会发现金属片的表面有各种各样不同颜色的点</li>
</ul></li>
<li>波动光学解出的 BRDF，效果很好（能够模拟出上面的情况）</li>
</ul>
<h2 id="程序化外观">程序化外观</h2>
<ul>
<li>noise function</li>
<li>Compute a noise function on the fly.
<ul>
<li>随用随取（不需要生成）</li>
</ul></li>
<li>木头纹理</li>
<li>Perlin Noise</li>
<li>Houdini：程序化生成材质（需要生成）</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES101</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101.闫令琪.07.材质与外观(Lecture 17)</title>
    <url>/2021/03/21/CG/YLQ-GAMES101/07/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/av90798049</li>
</ul>
<h1 id="材质与外观">材质与外观</h1>
<ul>
<li>Materials and Appearances</li>
</ul>
<h2 id="常见材质">常见材质</h2>
<ul>
<li>光柱、头发、海浪、布、蝴蝶的鳞片、鱼肉</li>
<li>光线传播和材质紧密相关</li>
<li>Weta 的 Manuka渲染器
<ul>
<li>比较成熟的渲染器</li>
<li>支持 40 多种材质</li>
</ul></li>
</ul>
<h2 id="material-brdf">Material == BRDF</h2>
<ul>
<li>材质：反射不同光的方式</li>
</ul>
<h2 id="漫反射材质">漫反射材质</h2>
<ul>
<li>Diffuse / Lambertian Material</li>
</ul>
<p><img src="/2021/03/21/CG/YLQ-GAMES101/07/1616377559351.png" style="zoom:50%;"></p>
<ul>
<li>能量守恒：不发光、不吸收光
<ul>
<li>进出的 irradiance 相同</li>
</ul></li>
<li>及射入射光在每个方向上均匀分布，出射光也在每个方向上均匀分布，那么就有</li>
</ul>
<p><span class="math display">\[
L_o=L_i
\]</span></p>
<ul>
<li>通过 BRDF 得到以下结论</li>
</ul>
<p><span class="math display">\[
\begin{aligned} L_{o}\left(\omega_{o}\right) &amp;=\int_{H^{2}} f_{r}
L_{i}\left(\omega_{i}\right) \cos \theta_{i} \mathrm{d} \omega_{i} \\
&amp;=f_{r} L_{i} \int_{H^{2}} \cos \theta_{i} \mathrm{d} \omega_{i} \\
&amp;=\pi f_{r} L_{i} \end{aligned}
\]</span></p>
<p><span class="math display">\[
f_r=\dfrac{1}{\pi}
\]</span></p>
<ul>
<li>引入一个反射系数（albedo 反射率 ）<span class="math inline">\(\rho\in[0,1]\)</span>，完全不反射 - 完全反射</li>
</ul>
<p><span class="math display">\[
f_r=\dfrac{\rho}{\pi}
\]</span></p>
<h2 id="glossy-材质">Glossy 材质</h2>
<ul>
<li>Glossy material</li>
<li>抛光金属材质
<ul>
<li>有高光，但是高光没那么强</li>
</ul></li>
</ul>
<p><img src="/2021/03/21/CG/YLQ-GAMES101/07/1616377650494.png" style="zoom:50%;"></p>
<ul>
<li>例子</li>
</ul>
<p><img src="/2021/03/21/CG/YLQ-GAMES101/07/1616377852715.png" style="zoom:80%;"></p>
<h2 id="理想反射折射材质">理想反射/折射材质</h2>
<ul>
<li>Ideal reflective / refractive material (BSDF*)
<ul>
<li>BSDF： Bidirectional Scattering Distribution Function
<ul>
<li>双向散射分布函数</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/03/21/CG/YLQ-GAMES101/07/1616377902337.png" style="zoom:50%;"></p>
<h2 id="反射光线的计算">反射光线的计算</h2>
<p><img src="/2021/03/21/CG/YLQ-GAMES101/07/1616393053065.png" style="zoom:50%;"></p>
<ul>
<li><span class="math inline">\(\theta\)</span>
<ul>
<li>这里可以看出半角矢量更加<strong>好算</strong></li>
</ul></li>
</ul>
<p><span class="math display">\[
\vec{\omega_i} + \vec{\omega_o}=2\cos\theta\
\vec{n}=2(\vec{\omega_i}\cdot\vec{n})\vec{n}
\]</span></p>
<ul>
<li><span class="math inline">\(\phi\)</span>
<ul>
<li>局部坐标系，表面俯视</li>
</ul></li>
</ul>
<p><span class="math display">\[
\phi_o=(\phi_i+\pi)\mod2\pi
\]</span></p>
<h2 id="折射">折射</h2>
<ul>
<li>Specular Refraction</li>
<li>几何光学角度</li>
<li>焦散 caustics</li>
</ul>
<p><img src="/2021/03/21/CG/YLQ-GAMES101/07/1616393489347.png"></p>
<h3 id="折射定律">折射定律</h3>
<ul>
<li>Snell' Law</li>
</ul>
<p><img src="/2021/03/21/CG/YLQ-GAMES101/07/1616393583720.png" style="zoom:50%;"></p>
<ul>
<li><span class="math inline">\(\theta\)</span></li>
</ul>
<p><span class="math display">\[
\eta_i\sin\theta_i=\eta_t\sin\theta_t
\]</span></p>
<ul>
<li><span class="math inline">\(\phi\)</span></li>
</ul>
<p><span class="math display">\[
\phi_o=(\phi_i+\pi)\mod2\pi
\]</span></p>
<ul>
<li>一些常见介质的折射率</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">介质 medium</th>
<th style="text-align: center;">折射率 n</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Vacuum（真空）</td>
<td style="text-align: center;">1.0</td>
</tr>
<tr class="even">
<td style="text-align: center;">Air (sea level)</td>
<td style="text-align: center;">1.00029</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Water (20°C)</td>
<td style="text-align: center;">1.333</td>
</tr>
<tr class="even">
<td style="text-align: center;">Glass</td>
<td style="text-align: center;">1.5-1.6</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Diamond</strong></td>
<td style="text-align: center;"><strong>2.42</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>计算折射角的余弦</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\cos\theta_t&amp;=\sqrt{1-\sin^2\theta_t}\\
&amp;=\sqrt{1-(\dfrac{\eta_i\sin\theta_i}{\eta_t})^2}\\
&amp;=\sqrt{1-(\dfrac{\eta_i}{\eta_t})^2(1-\cos\theta_i)^2}\\
\end{aligned}
\]</span></p>
<ul>
<li>可能无解：<strong>全反射</strong>
<ul>
<li><span class="math inline">\(1-(\dfrac{\eta_i}{\eta_t})^2(1-\cos\theta_i)^2&lt;0\)</span></li>
<li><span class="math inline">\({\color{red}\eta_i&gt;\eta_t}\)</span></li>
</ul></li>
<li>Snell's Window / Circle
<ul>
<li>水里向上看只能看到一个锥形的区域</li>
</ul></li>
</ul>
<p><img src="/2021/03/21/CG/YLQ-GAMES101/07/1616394304086.png" style="zoom:50%;"></p>
<ul>
<li>模型中可能发生全反射</li>
<li>对于<strong>球体</strong>，具有对称性，折射进去的光一定能够折射出来</li>
<li>BSDF = BRDF + BTDF
<ul>
<li>散射 = 反射 + 折射</li>
</ul></li>
</ul>
<h2 id="菲涅尔项">菲涅尔项</h2>
<ul>
<li>Fresnel Reflection / Term</li>
<li>不同的视角看过去，反射程度不一样</li>
</ul>
<p><img src="/2021/03/21/CG/YLQ-GAMES101/07/1616394626724.png"></p>
<h3 id="电介质绝缘体">电介质/绝缘体</h3>
<ul>
<li>Dielectric，<span class="math inline">\(\eta=1.5\)</span></li>
<li>S，P 两种极化</li>
<li>垂直的时候反射弱</li>
</ul>
<p><img src="/2021/03/21/CG/YLQ-GAMES101/07/1616394762467.png"></p>
<h3 id="导体">导体</h3>
<ul>
<li>Conductor</li>
<li>垂直的时候也很强
<ul>
<li>古代照镜子用<strong>铜镜</strong></li>
</ul></li>
</ul>
<p><img src="/2021/03/21/CG/YLQ-GAMES101/07/1616394928127.png"></p>
<h3 id="精确计算菲涅尔项">精确计算菲涅尔项</h3>
<ul>
<li>需要考虑极化现象</li>
</ul>
<p><span class="math display">\[
R_s=\left|\dfrac{n_i\cos\theta_i-n_t\cos\theta_t}{n_i\cos\theta_i+n_t\cos\theta_t}\right|^2
\]</span></p>
<p><span class="math display">\[
R_t=\left|\dfrac{n_i\cos\theta_t-n_t\cos\theta_i}{n_i\cos\theta_t+n_t\cos\theta_i}\right|^2
\]</span></p>
<p><span class="math display">\[
R_{eff}=\dfrac{R_s+R_t}{2}
\]</span></p>
<h3 id="估计菲涅尔项">估计菲涅尔项</h3>
<ul>
<li>Schlick’s approximation</li>
<li><span class="math inline">\(\theta:0\to\dfrac{\pi}{2},R(\theta):R_0\to1\)</span></li>
</ul>
<p><span class="math display">\[
R(\theta) =R_{0}+\left(1-R_{0}\right)(1-\cos \theta)^{5}
\]</span></p>
<p><span class="math display">\[
R_{0} =\left(\frac{n_{1}-n_{2}}{n_{1}+n_{2}}\right)^{2}
\]</span></p>
<h2 id="微表面模型">微表面模型</h2>
<ul>
<li>Microfacet Material</li>
<li>假设：离得足够远的时候，看不到物体细节，只能看到他们最终对整个表面的作用</li>
<li>微表面理论</li>
<li>Rough surface
<ul>
<li>Macroscale: flat &amp; rough
<ul>
<li>远处看：<strong>粗糙的平面</strong></li>
</ul></li>
<li>Microscale: bumpy &amp; <strong>specular</strong>
<ul>
<li>近处看：能看出凹凸不平的表面，每一个小的微元都是完全的<strong>镜面</strong>物体</li>
<li>物理中可用于解释漫反射
<ul>
<li>表面中有很多微小的镜子，朝向大小各异，最终形成各个方向均匀反射的结果</li>
</ul></li>
</ul></li>
</ul></li>
<li>Individual elements of surface act like <strong>mirrors</strong>
<ul>
<li>Known as Microfacets</li>
<li>Each microfacet has <strong>its own normal</strong></li>
</ul></li>
</ul>
<h2 id="microfacet-brdf">Microfacet BRDF</h2>
<ul>
<li>微表面中<strong>法线的分布</strong></li>
</ul>
<p><img src="/2021/03/21/CG/YLQ-GAMES101/07/1616396101074.png" style="zoom:50%;"></p>
<ul>
<li>BRDF
<ul>
<li><span class="math inline">\(\mathbf{F}\)</span>：菲涅尔项（Fresnel
term）</li>
<li><span class="math inline">\(\mathbf{G}\)</span>：shadowing-masking
term
<ul>
<li>也称为几何项</li>
<li>微表面的自遮挡</li>
<li>grazing angle：几乎和表面方向平行
<ul>
<li>此时容易发生自遮挡现象</li>
</ul></li>
</ul></li>
<li><span class="math inline">\(\mathbf{D}\)</span>：表面法线的一个分布
<ul>
<li>注意微表面时镜面（mirror）</li>
<li>只有半角矢量和法线一致的微表面才能将光线从入射方向传送到出射方向</li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
f(\mathbf{i}, \mathbf{o})=\frac{\mathbf{F}(\mathbf{i}, \mathbf{h})
\mathbf{G}(\mathbf{i}, \mathbf{o}, \mathbf{h})
\mathbf{D}(\mathbf{h})}{4(\mathbf{n}, \mathbf{i})(\mathbf{n},
\mathbf{o})}
\]</span></p>
<p><img src="/2021/03/21/CG/YLQ-GAMES101/07/1616396858635.png" style="zoom: 80%;"></p>
<ul>
<li>效果十分强大</li>
<li>基于微表面有很多模型，是一类模型的统称</li>
<li>PBR：Physically Based Rendering / Shading</li>
<li>缺点 ：Diffuse比较少，有时需要手动加</li>
</ul>
<h2 id="各向同性各向异性材质">各向同性/各向异性材质</h2>
<ul>
<li>Isotropic / Anisotropic Materials (BRDFs)</li>
<li>各向同性（Isotropic）：微表面的方向性很弱</li>
<li>各向异性（Anisotropic）：微表面具有一定的方向性</li>
</ul>
<p><img src="/2021/03/21/CG/YLQ-GAMES101/07/1616397220727.png" style="zoom: 50%;"></p>
<ul>
<li>各向异性 BRDF
<ul>
<li>入射角和出射角的相对位置不变（同时仰角不变），方位角发生旋转，结果
BRDF 不同</li>
<li>Reflection depends on azimuthal angle
<ul>
<li>BRDF 依赖于方位角</li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
f_{r}\left(\theta_{i}, \phi_{i} ; \theta_{r}, \phi_{r}\right) \neq
f_{r}\left(\theta_{i}, \theta_{r}, \phi_{r}-\phi_{i}\right)
\]</span></p>
<ul>
<li>生活中的各向异性材质
<ul>
<li>brushed metal
<ul>
<li>锅底、门把手</li>
</ul></li>
<li>Nylon</li>
<li>Velvet（天鹅绒）
<ul>
<li>刷往一个方向（自己人为构造各向异性）</li>
</ul></li>
</ul></li>
</ul>
<h2 id="brdf-的性质">BRDF 的性质</h2>
<ul>
<li>非负性（Non-negativity）
<ul>
<li>是一个分布</li>
</ul></li>
<li>线性（Linearity）
<ul>
<li>可加的</li>
</ul></li>
<li>可逆性（Reciprocity principle）
<ul>
<li>光路的可逆性</li>
</ul></li>
<li>能量守恒（Energy conservation）
<ul>
<li>球面积分小于等于 1（可能有吸收）</li>
</ul></li>
<li>各向异性前提下
<ul>
<li>4 维输入变为 3 维的（只和方位角的相对位置有关）</li>
</ul></li>
</ul>
<p><span class="math display">\[
f_{r}\left(\theta_{i}, \phi_{i} ; \theta_{r}, \phi_{r}\right)
=f_{r}\left(\theta_{i}, \theta_{r}, \phi_{r}-\phi_{i}\right)
\]</span></p>
<p><span class="math display">\[
f_{r}\left(\theta_{i}, \phi_{i} ; \theta_{r}, \phi_{r}\right)
=f_{r}\left(\theta_{i}, \theta_{r}, |\phi_{r}-\phi_{i}\right|)
\]</span></p>
<h2 id="测量-brdf">测量 BRDF</h2>
<ul>
<li>动机：
<ul>
<li>菲涅尔项和实际的不太匹配</li>
</ul></li>
<li>测量方法</li>
</ul>
<p><img src="/2021/03/21/CG/YLQ-GAMES101/07/1616398969252.png" style="zoom:50%;"></p>
<ul>
<li>算法</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">foreach outgoing direction wo</span><br><span class="line">    move light to illuminate surface with a thin beam from wo</span><br><span class="line">    for each incoming direction wi</span><br><span class="line">        move sensor to be at direction wi from surface</span><br><span class="line">    measure incident radiance</span><br></pre></td></tr></table></figure>
<ul>
<li>降低复杂度
<ul>
<li>各向同性：4D <span class="math inline">\(\to\)</span> 3D</li>
<li>可逆性：减少一半</li>
</ul></li>
<li>挑战
<ul>
<li>Accurate measurements at grazing angles
<ul>
<li>Important due to Fresnel effects</li>
</ul></li>
<li>Measuring with dense enough sampling to capture high frequency
specularities</li>
<li>Retro-reflection</li>
<li>Spatially-varying reflectance, ...</li>
</ul></li>
</ul>
<h2 id="brdf-的存储">BRDF 的存储</h2>
<h3 id="存储要求">存储要求</h3>
<ul>
<li>Compact representation</li>
<li>Accurate representation of measured data</li>
<li>Efficient evaluation for arbitrary pairs of directions</li>
<li>Good distributions available for importance sampling</li>
</ul>
<h3 id="tabular-representation">Tabular Representation</h3>
<ul>
<li>BRDF 库</li>
<li>最早都是各向同性的</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES101</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101.闫令琪.09.相机与透镜(Lecture 19)</title>
    <url>/2021/03/24/CG/YLQ-GAMES101/09/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/av90798049</li>
</ul>
<h1 id="相机与透镜">相机与透镜</h1>
<ul>
<li>Cameras, Lenses and Light Fields</li>
<li>成像方法
<ul>
<li>Imaging = Synthesis + Capture
<ul>
<li>Synthesis：合成</li>
<li>Capture：捕捉（相机等）</li>
</ul></li>
</ul></li>
<li>Transient Imaging：研究光在极短时间内的传播</li>
<li>Computational Photography：计算摄像学</li>
</ul>
<h2 id="相机">相机</h2>
<ul>
<li>camera</li>
</ul>
<h3 id="相机的内部构造">相机的内部构造</h3>
<ul>
<li>Cross-section of Nikon D3, 14-24mm F2.8 lens</li>
</ul>
<p><img src="/2021/03/24/CG/YLQ-GAMES101/09/20210325205247864.png" style="zoom:60%;"></p>
<ul>
<li>镜头、透镜组、机身、感光元件</li>
</ul>
<h3 id="小孔成像">小孔成像</h3>
<ul>
<li>小孔成像</li>
</ul>
<p><img src="/2021/03/24/CG/YLQ-GAMES101/09/image-20210325210156037.png"></p>
<ul>
<li>基于小孔成像原理的相机
<ul>
<li>pinhole：针孔摄像机</li>
</ul></li>
</ul>
<h3 id="透镜相机">透镜相机</h3>
<ul>
<li>透镜（组）</li>
</ul>
<p><img src="/2021/03/24/CG/YLQ-GAMES101/09/image-20210325210237129.png"></p>
<h3 id="快门">快门</h3>
<ul>
<li>shutter</li>
<li>Shutter Exposes Sensor For Precise Duration</li>
<li>控制光在多少分之一秒内进入相机</li>
</ul>
<p><img src="/2021/03/24/CG/YLQ-GAMES101/09/image-20210325210458008.png" style="zoom:50%;"></p>
<h3 id="传感器">传感器</h3>
<ul>
<li>sensor</li>
<li>Sensor Accumulates Irradiance During Exposure</li>
<li>传感器记录的是 <strong>irradiance</strong></li>
</ul>
<p><img src="/2021/03/24/CG/YLQ-GAMES101/09/image-20210325210703438.png" style="zoom:80%;"></p>
<ul>
<li><strong>不使用小孔/透镜无法成像</strong></li>
</ul>
<p><img src="/2021/03/24/CG/YLQ-GAMES101/09/image-20210325210900934.png" style="zoom:60%;"></p>
<ul>
<li><strong>传感器记录的是 irradiance 而不是 radiance</strong></li>
<li>结果是<strong>模糊</strong>的</li>
<li>但是目前有人在研究一些能够记录 radiance 的传感器
<ul>
<li>暂时认为传感器只能记录 irradiance</li>
</ul></li>
</ul>
<h3 id="针孔摄像机">针孔摄像机</h3>
<ul>
<li>照片是没有深度概念的
<ul>
<li>也就是说整张照片都是锐利的，没有一个地方会是虚化的</li>
<li><strong>不模糊</strong></li>
</ul></li>
<li>光线跟踪用的模型就是针孔摄像机</li>
<li>光线跟踪模拟透镜（组）的效果，可以渲染出带有景深的图片</li>
</ul>
<h3 id="视场">视场</h3>
<ul>
<li>FOV
<ul>
<li>Field of View</li>
</ul></li>
<li>focal length：焦距</li>
<li>针孔摄像机的 FOV 定义如下</li>
</ul>
<p><span class="math display">\[
FOV=2\arctan(\dfrac{h}{2f})
\]</span></p>
<p><img src="/2021/03/24/CG/YLQ-GAMES101/09/image-20210325211605543.png" style="zoom:70%;"></p>
<ul>
<li>其他定义 FOV 的方式（市场）
<ul>
<li>将胶片的大小规定为 35 mm 格式（36 mm x 24 mm），用此时的焦距等效表示
FOV</li>
<li>对角线的长度为 <span class="math inline">\(12\sqrt{13}\)</span></li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">焦距/mm</th>
<th style="text-align: center;">视场（角）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">17</td>
<td style="text-align: center;">104</td>
</tr>
<tr class="even">
<td style="text-align: center;">50</td>
<td style="text-align: center;">47</td>
</tr>
<tr class="odd">
<td style="text-align: center;">200</td>
<td style="text-align: center;">12</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>手机的焦距</strong>：等效成 35 mm 格式的胶片的情况下的焦距
<ul>
<li>FOV 不变，等效计算焦距</li>
</ul></li>
<li>传感器（sensor）和胶片（film），我们暂时混淆使用，有一一对应关系
<ul>
<li>但是在渲染中，sensor 保存的是 irradiance，film
决定存成怎么样的图片格式</li>
</ul></li>
<li>小传感器在保持 FOV 不变：减小焦距
<ul>
<li>手机</li>
<li>成像相对不清晰</li>
</ul></li>
</ul>
<h3 id="曝光">曝光</h3>
<ul>
<li>exposure</li>
<li><span class="math inline">\(H = T \times E\)</span>
<ul>
<li>exposure = time x irradiance</li>
</ul></li>
<li>T：受到快门的控制</li>
<li>E：受到光圈（aperture）、焦距（focal length）等的控制</li>
</ul>
<h4 id="曝光控制">曝光控制</h4>
<h5 id="光圈大小">光圈大小</h5>
<ul>
<li>aperture size</li>
<li>f-stop / f-number
<ul>
<li>我们在这里不区分这两个概念</li>
<li>数越大，光圈越小</li>
</ul></li>
<li>光圈用的大，某些区域会变模糊；光圈用的小，整张图片相对锐利</li>
<li>写法：FN，F/N</li>
<li>N 的含义（非正式理解）：光圈直径的<strong>倒数</strong></li>
</ul>
<h5 id="快门速度">快门速度</h5>
<ul>
<li>shutter speed</li>
<li>通常用一个开放快门的时间来表示</li>
<li>快门时间长：运动模糊
<ul>
<li>motion blur</li>
<li>在快门打开的时间内，物体产生了一段移动，传感器记录了这整段过程，相当于做了平均效果</li>
<li><strong>机械式快门</strong></li>
<li><strong>手抖</strong>：类似的结果</li>
</ul></li>
<li>运动模糊的好处
<ul>
<li>让人感觉运动很快</li>
<li>anti-aliasing，反走样的效果（时间上采样）</li>
</ul></li>
<li>rolling shutter
<ul>
<li>different parts of photo taken at different times</li>
<li>快门打开的速度比物体运动速度慢</li>
<li>例子：<strong>螺旋桨扭曲</strong></li>
</ul></li>
</ul>
<h5 id="iso-增益">ISO 增益</h5>
<ul>
<li>ISO gain</li>
<li>感光度</li>
<li>后期处理：硬件或者软件</li>
<li>Change the amplification (analog and/or digital) between sensor
values and digital image values</li>
<li>ISO 值越大，同时噪声也会被得放大
<ul>
<li>为什么会有噪声：简单的理解，光子数少（photon mapping
算法中的理解）</li>
</ul></li>
<li><strong>线性</strong></li>
</ul>
<h5 id="各种参数的影响">各种参数的影响</h5>
<p><img src="/2021/03/24/CG/YLQ-GAMES101/09/image-20210325232058567.png"></p>
<ul>
<li>f-stop 和 shutter speed 的补偿（只是在曝光度方面上的补偿）
<ul>
<li>f-stop：放大两倍（面积放大 4 倍）</li>
<li>shutter speed：缩小到原来的 <span class="math inline">\(\dfrac{1}{4}\)</span>（时间变长 4 倍）</li>
<li>但是拍出来的效果并不是一模一样
<ul>
<li>大光圈会引起浅景深的问题</li>
<li>长曝光会引发运动模糊</li>
<li>trade off</li>
</ul></li>
</ul></li>
<li>depth of field：景深</li>
</ul>
<h3 id="高速摄影">高速摄影</h3>
<ul>
<li>High-Speed Photograph</li>
<li>每秒钟拍摄更高的帧数，放映的时候按照正常的帧率播放</li>
<li>shutter speed 更快</li>
<li>更大的光圈
<ul>
<li>ISO 会引入噪声</li>
</ul></li>
</ul>
<h3 id="长曝光摄影延时摄影">长曝光摄影/延时摄影</h3>
<ul>
<li>Long-Exposure Photograph</li>
<li>https://www.demilked.com/best-long-exposure-photos/</li>
<li>拉丝效果</li>
</ul>
<h2 id="透镜">透镜</h2>
<ul>
<li>Thin Lens Approximation
<ul>
<li>薄镜头近似</li>
</ul></li>
<li>相机一般使用透镜组</li>
<li>非理想透镜
<ul>
<li>aberration（像差）</li>
</ul></li>
</ul>
<p><img src="/2021/03/24/CG/YLQ-GAMES101/09/image-20210325235217199.png"></p>
<h3 id="理想的薄透镜">理想的薄透镜</h3>
<p><img src="/2021/03/24/CG/YLQ-GAMES101/09/image-20210325235622130.png" style="zoom:70%;"></p>
<ul>
<li>一些假设
<ul>
<li>All parallel rays entering a lens pass through its focal point.
<ul>
<li>平行于光轴的光线过焦点</li>
</ul></li>
<li>All rays through a focal point will be in parallel after passing the
lens.
<ul>
<li>焦点发出的光线平行于光轴射出</li>
</ul></li>
<li>Focal length can be arbitrarily changed.
<ul>
<li>薄透镜的焦距可以任意改变</li>
<li>现实中利用透镜组实现</li>
</ul></li>
</ul></li>
</ul>
<h4 id="其他物理规律">其他物理规律</h4>
<p><img src="/2021/03/24/CG/YLQ-GAMES101/09/image-20210325235913646.png" style="zoom:50%;"></p>
<ul>
<li>经过光心的光线传播方向不变
<ul>
<li>chief ray</li>
</ul></li>
</ul>
<p><img src="/2021/03/24/CG/YLQ-GAMES101/09/image-20210326000524663.png" style="zoom:60%;"></p>
<ul>
<li>物距 <span class="math inline">\(z_o\)</span>，相距 <span class="math inline">\(z_i\)</span></li>
<li>Gaussian Thin Lens Equation</li>
</ul>
<p><span class="math display">\[
\dfrac{1}{f}=\dfrac{1}{z_o}+\dfrac{1}{z_i}
\]</span></p>
<ul>
<li>推导</li>
</ul>
<p><span class="math display">\[
\dfrac{z_o-f}{h_o}=\dfrac{f}{h_i}
\]</span></p>
<p><span class="math display">\[
\dfrac{z_i-f}{h_i}=\dfrac{f}{h_o}
\]</span></p>
<p><span class="math display">\[
\dfrac{h_i}{h_o}=\dfrac{f}{z_o-f}=\dfrac{z_i-f}{f}
\]</span></p>
<p><span class="math display">\[
\dfrac{1}{f}=\dfrac{1}{z_o}+\dfrac{1}{z_i}
\]</span></p>
<ul>
<li>在线演示
<ul>
<li>http://graphics.stanford.edu/courses/cs178-10/applets/gaussian.html</li>
</ul></li>
</ul>
<h3 id="defocus-blur">Defocus Blur</h3>
<ul>
<li>CoC：Circle of Conclusion
<ul>
<li>弥散圆</li>
<li>CoC 指的是弥散圆的大小栈光圈大小的比例</li>
</ul></li>
</ul>
<p><img src="/2021/03/24/CG/YLQ-GAMES101/09/image-20210326002924795.png" style="zoom:67%;"></p>
<ul>
<li>给定像平面（Sensor Plane），可以计算出对焦平面（Focal Plane）
<ul>
<li>利用上面的 Gaussian Thin Lens Equation</li>
<li>如果物体恰好在对焦平面上，像点恰好在像平面上</li>
</ul></li>
<li>对薄透镜来说，如果物体离得比对焦平面远，那么像点会变近
<ul>
<li>此时在 Sensor Plane 上会形成一个弥散圆（COC）</li>
<li>会变模糊</li>
</ul></li>
</ul>
<p><span class="math display">\[
\dfrac{C}{A}=\dfrac{d&#39;}{z_i}=\dfrac{|z_s-z_i|}{z_i}
\]</span></p>
<ul>
<li>CoC 表面看到的东西模糊不模糊，直接和光圈（A）相关
<ul>
<li>A 越大，C 越大</li>
<li>解释了大光圈引起的模糊现象（景深效果）</li>
</ul></li>
</ul>
<h3 id="f-stop">F-Stop</h3>
<ul>
<li>精确定义
<ul>
<li>The f-number of a lens is defined as the focal length divided by the
diameter of the aperture</li>
<li>焦距除以光圈的直径</li>
</ul></li>
<li>f-stop：N</li>
</ul>
<p><span class="math display">\[
C=A\dfrac{|z_s-z_i|}{z_i}=\dfrac{f}{N}\dfrac{|z_s-z_i|}{z_i}
\]</span></p>
<ul>
<li>f-stop 越大，CoC 越小
<ul>
<li>小光圈拍的照片更清楚</li>
</ul></li>
</ul>
<h3 id="光线经过薄透镜">光线经过薄透镜</h3>
<ul>
<li>Ray Tracing Ideal Thin Lenses</li>
</ul>
<p><img src="/2021/03/24/CG/YLQ-GAMES101/09/image-20210326004721312.png" style="zoom:67%;"></p>
<ul>
<li>一种方式
<ul>
<li>确定 sensor 的大小、透镜属性（焦距、光圈大小）</li>
<li>定义感兴趣的平面（焦平面）<span class="math inline">\(z_o\)</span></li>
<li>求出相距 <span class="math inline">\(z_i\)</span></li>
</ul></li>
<li>渲染
<ul>
<li>对 sensor 上的任意一个点 <span class="math inline">\(x&#39;\)</span>
做循环</li>
<li>随机在透镜上选择另外一个点 <span class="math inline">\(x&#39;&#39;\)</span></li>
<li>计算出出射光线的经过点 <span class="math inline">\(x&#39;&#39;&#39;\)</span>：通过 Gaussian Thin Lens
Equation</li>
<li>出射光线 <span class="math inline">\(x&#39;&#39;\to
x&#39;&#39;&#39;\)</span>，和之前的渲染方式一样</li>
</ul></li>
</ul>
<h3 id="景深">景深</h3>
<ul>
<li>Depth of Field</li>
<li>大/小光圈会影响模糊的范围</li>
</ul>
<p><img src="/2021/03/24/CG/YLQ-GAMES101/09/image-20210326005516472.png" style="zoom:60%;"></p>
<ul>
<li>在成像平面附近一段区域内 CoC 足够小，这一段区域就被称为是 Depth of
Focus
<ul>
<li>反求出物体距离的范围，这便是景深 Depth of Field</li>
<li>成像清晰的一段范围</li>
</ul></li>
</ul>
<p><img src="/2021/03/24/CG/YLQ-GAMES101/09/image-20210326005847613.png" style="zoom:60%;"></p>
<ul>
<li><strong>光圈越小，景深越大</strong></li>
<li>在线演示
<ul>
<li>http://graphics.stanford.edu/courses/cs178/applets/dof.html</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES101</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101.闫令琪.10.光场(Lecture 20)</title>
    <url>/2021/03/31/CG/YLQ-GAMES101/10/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/av90798049</li>
</ul>
<h1 id="光场">光场</h1>
<ul>
<li>Light Field / Lumigraph
<ul>
<li>同义词</li>
<li>历史遗留问题，两个组同时各自发现这个概念</li>
</ul></li>
</ul>
<h2 id="我们看到的世界">我们看到的世界</h2>
<p><img src="/2021/03/31/CG/YLQ-GAMES101/10/image-20210331231257993.png" style="zoom:70%;"></p>
<ul>
<li>放上一块幕布，让我们看到的东西和原来一模一样</li>
</ul>
<p><img src="/2021/03/31/CG/YLQ-GAMES101/10/image-20210331231412185.png" style="zoom:70%;"></p>
<ul>
<li>虚拟现实技术的原理</li>
<li>我们只是看到各个方向的光线，看不到光线是多远来的、从什么地方来的</li>
</ul>
<h2 id="全光函数">全光函数</h2>
<ul>
<li>The Plenoptic Function</li>
<li>描述我们往各个方向看看到的光线</li>
</ul>
<p><img src="/2021/03/31/CG/YLQ-GAMES101/10/image-20210331231735426.png" style="zoom:50%;"></p>
<ul>
<li><span class="math inline">\(P(\theta,\phi)\)</span>
<ul>
<li>灰度图</li>
</ul></li>
<li><span class="math inline">\(P(\theta,\phi,\lambda)\)</span>
<ul>
<li>彩色图</li>
</ul></li>
<li><span class="math inline">\(P(\theta,\phi,\lambda,t)\)</span>
<ul>
<li>电影</li>
</ul></li>
<li><span class="math inline">\(P(\theta,\phi,\lambda,t,V_x,V_y,V_z)\)</span>
<ul>
<li>人眼/摄像机的位置可以改变</li>
<li>全息电影</li>
<li>我们能看到的所有东西</li>
<li>7 个维度的函数就可以描述我们看到的整个世界</li>
<li><strong>全光函数</strong></li>
</ul></li>
</ul>
<h2 id="光线">光线</h2>
<ul>
<li>ray</li>
<li><span class="math inline">\(P(\theta,\phi,V_x,V_y,V_z)\)</span>
<ul>
<li>起点和方向</li>
</ul></li>
<li>物体表面的话可以用 4D 表示</li>
</ul>
<h2 id="光场-1">光场</h2>
<ul>
<li>光场：在任何一个位置，往任何一个方向去的光的强度</li>
<li>2D 的位置，2D 的方向</li>
<li>3D 物体的表面是在一个 2D 的空间中的
<ul>
<li>纹理映射的思想</li>
</ul></li>
<li>2D 的方向
<ul>
<li><span class="math inline">\(\theta,\phi\)</span></li>
</ul></li>
<li>有个光场之后，可以得到任意位置对物体的观测
<ul>
<li>对于观测相机，做出视线，求出在物体表面的反射光线，然后从光场中读出即可</li>
</ul></li>
<li>我们不需要知道光场描述的具体的物体，只需要知道在物体表面的任何位置、任何方向的光线强度即可
<ul>
<li>可以当作黑盒</li>
<li>前提：观测点得在物体外面（我们记录的信息是往外的）</li>
</ul></li>
<li>取一个平面，对于平面上任意一个点、任意一个方向，记录光照强度，这样也可以描述光场</li>
<li>另外一种<strong>参数化方式</strong>
<ul>
<li>取两个平行的平面，然后在两个平面上各取一个点，这样也能描述光场</li>
<li>两个点相当于确定了一个方向</li>
<li><span class="math inline">\(u,v,s,t\)</span> 描述</li>
</ul></li>
</ul>
<p><img src="/2021/03/31/CG/YLQ-GAMES101/10/image-20210331234206883.png" style="zoom:70%;"></p>
<ul>
<li><span class="math inline">\(u,v,s,t\)</span> 的两种理解方式
<ul>
<li><span class="math inline">\(u,v\)</span> 不变，取遍 <span class="math inline">\(s,t\)</span>
<ul>
<li>能看到完整的物体图</li>
<li>相当于摄像机看向整个世界</li>
</ul></li>
<li><span class="math inline">\(s,t\)</span> 不变，取遍 <span class="math inline">\(u,v\)</span>
<ul>
<li>能看到同一个点来自各个方向的光照</li>
<li>看的是同一个东西，但是是从各个不同的角度去看</li>
<li>相当于把记录的 irradiance 展开为 radiance</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/03/31/CG/YLQ-GAMES101/10/image-20210331233955685.png" style="zoom: 67%;"></p>
<h3 id="stanford-camera-array">Stanford camera array</h3>
<ul>
<li>利用上面的想法，从不同的 <span class="math inline">\(u,v\)</span>
看向整个世界，让后把记录到的结果整合出来</li>
</ul>
<p><img src="/2021/03/31/CG/YLQ-GAMES101/10/image-20210331234831316.png" style="zoom:70%;"></p>
<ul>
<li><strong>贵</strong></li>
</ul>
<h3 id="苍蝇的眼睛复眼">苍蝇的眼睛（复眼）</h3>
<ul>
<li>就是一个光场</li>
</ul>
<p><img src="/2021/03/31/CG/YLQ-GAMES101/10/image-20210331235248647.png" style="zoom:67%;"></p>
<ul>
<li>lenslet：像素</li>
<li>把光分开，把来自各个方向上的光分到不同的位置上去
<ul>
<li>把实际的感光元件放在背后，前面放置一个透镜，通过透镜将光分开</li>
<li>把 irradiance 分解为 radiance</li>
</ul></li>
</ul>
<h2 id="光场摄像机">光场摄像机</h2>
<ul>
<li>Light Field Camera</li>
<li>上面提到的复眼的原理，透镜代替原来的像素，实际的感光元件放在背后</li>
<li><strong>支持重新聚焦</strong>
<ul>
<li>原理就是光场</li>
</ul></li>
<li>很实用，重要的照片拍糊了，没关系，重新调焦距</li>
</ul>
<h3 id="原理">原理</h3>
<ul>
<li>Each pixel (irradiance) is now stored as a block of pixels
(radiance)</li>
</ul>
<p><img src="/2021/03/31/CG/YLQ-GAMES101/10/image-20210331235947435.png" style="zoom: 33%;"></p>
<ul>
<li><p>怎么获取从光场摄像机的结果中获取一张照片</p>
<ul>
<li>每个小透镜都选择一个相同的方向
<ul>
<li>相当于摄像机朝着这个方向去拍</li>
</ul></li>
<li>方向可以任意选择</li>
<li>相当于可以虚拟的移动相机位置</li>
</ul></li>
<li><p>怎么生成给定对焦平面后的结果照片</p>
<ul>
<li>根据对焦平面计算出每一个光线的方向，在光场上查询出具体的强度</li>
<li>visually changing focal length, picking the refocused ray directions
accordingly</li>
</ul></li>
</ul>
<h3 id="问题">问题</h3>
<ul>
<li>分辨率较低
<ul>
<li>方向分辨率更高，空间分辨率更低</li>
<li>same film used for both spatial and directional information</li>
</ul></li>
<li>价格贵</li>
<li>微透镜的设计很麻烦</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES101</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101.闫令琪.11.颜色与感知(Lecture 20)</title>
    <url>/2021/04/01/CG/YLQ-GAMES101/11/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/av90798049</li>
</ul>
<h1 id="颜色与感知">颜色与感知</h1>
<ul>
<li>color and perception</li>
</ul>
<h2 id="光谱">光谱</h2>
<ul>
<li>spectrum</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/11/image-20210401112342353.png" style="zoom:80%;"></p>
<ul>
<li>可见光光谱：400 - 700nm（近似）</li>
</ul>
<h2 id="谱功率密度">谱功率密度</h2>
<ul>
<li>SPD（Spectral Power Distribution）</li>
<li>在不同的波长强度是多少</li>
<li>单位
<ul>
<li>radiometric units / nanometer (e.g. watts / nm)</li>
<li>Can also be unit-less</li>
</ul></li>
<li>当绝对单位不重要的时候，使用相对强度（相对最大值归一化）</li>
</ul>
<h3 id="一些不同场景的-spd">一些不同场景的 SPD</h3>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/11/image-20210401112939365.png" alt="image-20210401112939365" style="zoom: 80%;"></p>
<h3 id="spd-的性质">SPD 的性质</h3>
<ul>
<li>线性：线性叠加</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/11/image-20210401113113148.png" style="zoom:67%;"></p>
<h2 id="颜色">颜色</h2>
<ul>
<li>Color is a phenomenon of human perception; it is not a universal
property of light</li>
<li>颜色是人眼感知的一个结果，不是光本身的属性</li>
</ul>
<h2 id="人眼结构">人眼结构</h2>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/11/image-20210401113301779.png" style="zoom:40%;"></p>
<ul>
<li>pupil：瞳孔</li>
<li>lens：晶状体</li>
<li>Retinal Photoreceptor Cells：感光细胞
<ul>
<li>Rods：视杆细胞
<ul>
<li>感知光的强度（灰度图）</li>
</ul></li>
<li>Cones：视锥细胞
<ul>
<li>感知光的颜色</li>
<li>分为 3 类（S、M、L）
<ul>
<li><strong>响应曲线</strong>如下</li>
<li>不同人 3 种细胞的分布都不太一样，数量有严重的个体差异</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/11/image-20210401113656644.png" style="zoom:50%;"></p>
<h3 id="人眼感受颜色">人眼感受颜色</h3>
<ul>
<li>光在不同波长上的强度 <span class="math inline">\(s(\lambda)\)</span></li>
</ul>
<p><span class="math display">\[
S=\int r_S(\lambda)s(\lambda)d\lambda
\]</span></p>
<p><span class="math display">\[
M=\int r_M(\lambda)s(\lambda)d\lambda
\]</span></p>
<p><span class="math display">\[
L=\int r_L(\lambda)s(\lambda)d\lambda
\]</span></p>
<ul>
<li>人们看到的是这三个数，大脑处理形成感知的颜色
<ul>
<li>每个人眼中的世界是不一样的，细胞分布不同</li>
</ul></li>
</ul>
<h2 id="同色异谱">同色异谱</h2>
<ul>
<li>Metamerism</li>
<li>光不一样，但是形成的颜色相同</li>
</ul>
<h3 id="metamers">Metamers</h3>
<ul>
<li>Metamers are two different spectra (<span class="math inline">\(\infty\)</span>-dim) that project to the same
(S,M,L) (3-dim) response
<ul>
<li>光谱不同，感知到的颜色相同</li>
</ul></li>
<li>很有用
<ul>
<li>颜色匹配 color matching</li>
<li>我们可以通过调制光谱，得到我们想要的颜色，而这个调制的光谱不需要和原来的一模一样
<ul>
<li>简单，不需要调制整个波段的光谱
<ul>
<li>Don’t have to reproduce the <strong>full spectrum</strong> of a real
world scene</li>
</ul></li>
<li>例子：我们可以见到那的通过 3 基色在显示屏上调至出我们想要的颜色</li>
</ul></li>
</ul></li>
</ul>
<h3 id="颜色匹配">颜色匹配</h3>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/11/image-20210401115855508.png" style="zoom:60%;"></p>
<h2 id="颜色生成-匹配">颜色生成 / 匹配</h2>
<ul>
<li>计算机成像系统：<strong>加色系统</strong>
<ul>
<li>additive color</li>
<li>RGB 都调最大为<strong>白色</strong></li>
</ul></li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/11/image-20210401120016916.png" style="zoom: 33%;"></p>
<ul>
<li>画画：<strong>减色系统</strong></li>
</ul>
<h3 id="加色系统">加色系统</h3>
<ul>
<li>给定 3 基色：<span class="math inline">\(s_R(\lambda),s_G(\lambda),s_B(\lambda)\)</span></li>
<li>通过调整系数获得想要的颜色：<span class="math inline">\(Rs_R(\lambda)+Gs_G(\lambda)+Bs_B(\lambda)\)</span></li>
<li>使用 <span class="math inline">\(R,G,B\)</span> 来描述颜色即可</li>
</ul>
<h3 id="加色系统的匹配">加色系统的匹配</h3>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/11/image-20210401120455905.png" style="zoom:70%;"></p>
<ul>
<li>一边是目标颜色，一边是调制的颜色，通过调整 <span class="math inline">\(R,G,B\)</span> 的值，将调制颜色调制到目标颜色</li>
<li>调不出来？
<ul>
<li>在目标颜色上加上一个颜色，好像就是在调制颜色把右边减去了某种颜色
<ul>
<li>线性</li>
<li>也就是说我们调制颜色的时候，某些系数可以是是<strong>负的</strong></li>
</ul></li>
</ul></li>
</ul>
<h3 id="cie-rgb-匹配实验">CIE RGB 匹配实验</h3>
<ul>
<li>CIE：一个组织</li>
<li><strong>匹配函数</strong>结果
<ul>
<li>如何混合单色光得到任意波长的光（感知颜色上的一致）</li>
</ul></li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/11/image-20210401121101060.png" style="zoom:50%;"></p>
<ul>
<li>给定一个实际的 SPD 分布 <span class="math inline">\(s(\lambda)\)</span>，怎么计算 <span class="math inline">\(R,G,B\)</span>，是的感知上的光是一致的 <span class="math display">\[
R_{CIE\ RGB}=\int \bar{r}(\lambda)s(\lambda)d\lambda
\]</span></li>
</ul>
<p><span class="math display">\[
G_{CIE\ RGB}=\int\bar{g}(\lambda)s(\lambda)d\lambda
\]</span></p>
<p><span class="math display">\[
B_{CIE\ RGB}=\int\bar{b}(\lambda)s(\lambda)d\lambda
\]</span></p>
<h2 id="颜色空间">颜色空间</h2>
<h3 id="srgb">sRGB</h3>
<ul>
<li>standardzed RGB</li>
<li>广泛应用于我们现在的显示设备</li>
<li>制造方式
<ul>
<li>先制造一台标准的显示器，测定它的匹配函数</li>
<li>大家按照这个标准去制造，得到的结果就和标准的一致了</li>
</ul></li>
<li>形成的色域（gamut）是有限的</li>
</ul>
<h3 id="cie-xyz">CIE XYZ</h3>
<ul>
<li>科学上应用更广泛</li>
<li>人造的颜色匹配系统，不是实验测出来的</li>
<li>匹配函数曲线如下</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/11/image-20210401122610739.png" style="zoom:67%;"></p>
<ul>
<li>在设计上，由于绿色的曲线在可见光比较对称，覆盖范围基本全覆盖了，可以用其来表示图像的亮度
<ul>
<li>Y is luminance (brightness regardless of color)</li>
</ul></li>
<li>这种设计的结果
<ul>
<li>红色虽然有两个峰值，但是<strong>没有负数</strong></li>
<li>覆盖到所有的可见光颜色</li>
</ul></li>
</ul>
<h3 id="xyz-可视化">XYZ 可视化</h3>
<ul>
<li><strong>怎么在二维平面上可视化 XYZ</strong></li>
<li>Luminance：Y
<ul>
<li>亮度</li>
</ul></li>
<li>Chromaticity：x，y，z
<ul>
<li>色度</li>
</ul></li>
<li>归一化 <span class="math inline">\(x+y+z=1\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
x&amp;=\dfrac{X}{X+Y+Z}\\
y&amp;=\dfrac{Y}{X+Y+Z}\\
z&amp;=\dfrac{Z}{X+Y+Z}\\
\end{aligned}
\]</span></p>
<ul>
<li>然后显示 <span class="math inline">\((x,y)\)</span> 坐标即可</li>
<li>但是实际上还是有 3 个变量，2 维本质只能显示 2 个变量
<ul>
<li>由于 Y 表示的是亮度，我们固定 Y，通过改变 X、Z 来绘制出上图</li>
</ul></li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/11/image-20210401144514274.png" style="zoom:50%;"></p>
<h3 id="色域">色域</h3>
<ul>
<li><p>Gamut</p></li>
<li><p>所有一个颜色空间可以显示的颜色</p></li>
<li><p>上面这个图就是一个色域</p></li>
<li><p>色域中心：白色（最不纯的颜色）</p></li>
<li><p>边缘：纯色</p></li>
<li><p>不同颜色空间表示的色域不一样</p></li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/11/image-20210401145403255.png" style="zoom:60%;"></p>
<h3 id="hsv">HSV</h3>
<ul>
<li>Hue-Saturation-Value</li>
<li>色调、饱和度、颜色</li>
<li>色调：不同颜色</li>
<li>饱和度：接近单色还是白色</li>
<li>颜色：亮度（黑色到有色）</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/11/image-20210401145932979.png" style="zoom:50%;"></p>
<h4 id="标准定义">标准定义</h4>
<ul>
<li>Hue
<ul>
<li>the “<strong>kind</strong>” of color, regardless of attributes</li>
<li>colorimetric correlate: <strong>dominant wavelength</strong></li>
<li>artist’s correlate: the chosen pigment color</li>
</ul></li>
<li>Saturation
<ul>
<li>the “<strong>colorfulness</strong>”</li>
<li>colorimetric correlate: <strong>purity</strong></li>
<li>artist’s correlate: fraction of paint from the colored tube</li>
</ul></li>
<li>Lightness (or value)
<ul>
<li>the overall <strong>amount</strong> of light</li>
<li>colorimetric correlate: <strong>luminance</strong></li>
<li>artist’s correlate: tints are lighter, shades are darker</li>
</ul></li>
</ul>
<h3 id="cielab-space">CIELAB Space</h3>
<ul>
<li><span class="math inline">\(L\ast a\ast b\ast\)</span></li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/11/image-20210401150304630.png" style="zoom:50%;"></p>
<ul>
<li><span class="math inline">\(L\ast\)</span> is lightness
(brightness)</li>
<li><span class="math inline">\(a\ast\)</span> and <span class="math inline">\(b\ast\)</span> are color-opponent pairs
<ul>
<li><span class="math inline">\(a\ast\)</span> is red-green</li>
<li><span class="math inline">\(b\ast\)</span> is blue-yellow</li>
</ul></li>
<li>互补色</li>
</ul>
<h2 id="互补色理论">互补色理论</h2>
<ul>
<li>红绿互补，蓝黄互补</li>
<li>证据
<ul>
<li>生活中有很多颜色，黄绿色、蓝绿色，但是没有听说过红绿色</li>
<li>视觉暂留，当你盯着一幅画面久了之后，撤去画面你会看到互补色</li>
</ul></li>
<li>视觉暂留一个很好玩的例子
<ul>
<li>两幅相同的图片，第一幅图为上色颜色的互补色，第二幅图为灰度图</li>
<li>看第一张图久了之后，然后换成第二张，人眼会自动上色</li>
</ul></li>
</ul>
<h2 id="视错觉">视错觉</h2>
<ul>
<li>人的感知是相对亮度
<ul>
<li>A，B 是一样亮的</li>
</ul></li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/11/image-20210401151224344.png" style="zoom:50%;"></p>
<h2 id="减色系统">减色系统</h2>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/11/image-20210401151354980.png" style="zoom:50%;"></p>
<ul>
<li>颜色混得越多越黑</li>
</ul>
<h3 id="cmyk">CMYK</h3>
<ul>
<li>CMYK 是一个典型的减色系统
<ul>
<li>Cyan, Magenta, Yellow, and Key</li>
<li>青色、品红色、黄色、黑色</li>
</ul></li>
<li>用于打印，墨水</li>
<li>CMY 可以混合出黑色，为什么一定要带上 K
<ul>
<li>成本问题，黑色墨水便宜</li>
</ul></li>
</ul>
<h2 id="其他问题">其他问题</h2>
<h3 id="颜色空间对比">颜色空间对比</h3>
<ul>
<li>RGB 好用</li>
<li>XYZ 理论性质好，色域大</li>
<li>HSV 好调色</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES101</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101.闫令琪.12.动画与模拟(Lecture 21)</title>
    <url>/2021/04/01/CG/YLQ-GAMES101/12/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/av90798049</li>
</ul>
<h1 id="动画与模拟">动画与模拟</h1>
<ul>
<li>animation</li>
<li>内容
<ul>
<li>History</li>
<li>Keyframe animation</li>
<li>Physical simulation</li>
<li>Kinematics</li>
<li>Rigging</li>
</ul></li>
</ul>
<h2 id="动画">动画</h2>
<ul>
<li>动画的动机：让物体动起来
<ul>
<li>是一种交流的工具</li>
<li>更关注美学特征，物理上差不多对就行</li>
</ul></li>
<li>建模，几何的拓展
<ul>
<li>时间轴上的扩展</li>
</ul></li>
<li>动画的形成：快速播放的图片序列
<ul>
<li>电影：24 fps</li>
<li>视频：30 fps</li>
<li>VR：90 fps
<ul>
<li>不晕的要求</li>
</ul></li>
<li>frames per second</li>
</ul></li>
</ul>
<h2 id="动画的历史">动画的历史</h2>
<h3 id="早期的壁画">早期的壁画</h3>
<ul>
<li>一些图片序列</li>
<li>我们将这些图片截取下来动态的播放，可以看到动态的狩猎图</li>
<li>这说明很早的时候，大家就已经知道动画就是一系列的图片序列而已，只是当时缺少播放设备罢了</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210401154620043.png" style="zoom:50%;"></p>
<h3 id="phenakistoscope">Phenakistoscope</h3>
<ul>
<li>1831</li>
<li>圆盘，边上画上画，但是你只能看到一部分区域</li>
<li>转起来则会有动画的效果</li>
<li>小时候玩的小人书，翻页动画</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210401155000489.png" style="zoom:50%;"></p>
<h3 id="电影">电影</h3>
<ul>
<li>最早用于科学研究
<ul>
<li>例如：捕捉马的运动形态</li>
</ul></li>
</ul>
<h3 id="动画-1">动画</h3>
<ul>
<li>白雪公主和七个小矮人
<ul>
<li>Disney, “Snow White and the Seven Dwarfs” (1937)</li>
<li>第一部手绘的长达 40 分钟的动画（电影长度）
<ul>
<li>First Hand-Drawn Feature-Length (&gt;40 mins) Animation</li>
<li>feature length，时间大于等于 40 分钟，电影的长度</li>
</ul></li>
</ul></li>
<li>Ivan Sutherland, “Sketchpad” (1963) – Light pen, vector display
<ul>
<li>First Digital-Computer-Generated Animation</li>
<li>可以支持用一根激光笔在显示屏上画出、移动简单的几何体</li>
</ul></li>
<li>早期的动画
<ul>
<li>三维网格显示任务的面目表情</li>
<li>Ed Catmull &amp; Frederick Parke, “Computer Animated Faces”
(1972)</li>
</ul></li>
<li>侏罗纪公园
<ul>
<li>Jurassic Park (1993)</li>
<li>里程碑式的作品</li>
<li>真正把电脑生成的恐龙放到了电影里</li>
</ul></li>
<li>玩具总动员
<ul>
<li>Pixar, “Toy Story” (1995)</li>
<li>First CG-Generated Feature-Length Film</li>
<li>第一部完全由电脑生成的电影</li>
<li>当时还是使用<strong>光栅化技术</strong>，没有光线跟踪</li>
</ul></li>
<li>天降美食
<ul>
<li>Sony Pictures Animation, “Cloudy With a Chance of Meatballs”
(2009)</li>
<li>东西掉进水里的模拟还不是很逼真
<ul>
<li>涟漪</li>
</ul></li>
</ul></li>
<li>冰雪奇缘2
<ul>
<li>Walt Disney Animation Studios, “Frozen 2” (2019)</li>
<li>充满大量细节：花瓣、草地、特效</li>
</ul></li>
</ul>
<h2 id="关键帧动画">关键帧动画</h2>
<ul>
<li>keyframe animation</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210401200539173.png" style="zoom:67%;"></p>
<ul>
<li>首先绘制一些重要的位置的场景，这些重要的位置就被称为<strong>关键帧</strong></li>
<li>动画制作
<ul>
<li>Animator (e.g. lead animator) creates keyframes
<ul>
<li>负责人先画出关键帧</li>
</ul></li>
<li>Assistant (person or computer) creates in-between frames
(“tweening”)
<ul>
<li>助手在将中间的过程补全</li>
</ul></li>
</ul></li>
<li>flash
<ul>
<li>简单的图案可以从关键帧自动生成</li>
</ul></li>
</ul>
<h3 id="关键帧插值">关键帧插值</h3>
<ul>
<li>插值是一门学问，做到自然真实是很难的</li>
<li>连续性
<ul>
<li><span class="math inline">\(C1,C2,\cdots\)</span></li>
</ul></li>
</ul>
<h2 id="物理模拟">物理模拟</h2>
<ul>
<li>physical simulation</li>
<li>牛顿定律 <span class="math inline">\(F=ma\)</span>
<ul>
<li>Force = Mass x Acceleration</li>
</ul></li>
<li>简单的匀加速运动</li>
</ul>
<p><span class="math display">\[
x^{t+\Delta t}=x^t+\Delta tv^t+\dfrac{1}{2}(\Delta t)^2a^t
\]</span></p>
<ul>
<li>复杂的布料：如果考虑了所有力，就能很好的模拟出结果</li>
<li>模拟得对的话，则不会出现<strong>穿模</strong>现象</li>
<li>流体的模拟
<ul>
<li>模拟水滴的位置</li>
<li>然后考虑怎么渲染得更真实</li>
</ul></li>
<li>割裂开模拟和真实感渲染这两步</li>
</ul>
<h2 id="质点弹簧系统">质点弹簧系统</h2>
<ul>
<li>Mass Spring System</li>
</ul>
<h3 id="例子">例子</h3>
<h4 id="简单的弹簧绳">简单的弹簧绳</h4>
<ul>
<li>Mass Spring Rope</li>
</ul>
<h4 id="头发">头发</h4>
<ul>
<li>很复杂：摩擦力、重力、外力</li>
</ul>
<h4 id="布料">布料</h4>
<ul>
<li>Mass Spring Mesh</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210401202146335.png" style="zoom:67%;"></p>
<ul>
<li>关于模拟布料的一篇论文</li>
<li>Huamin Wang, Ravi Ramamoorthi, and James F. O'Brien. "Data-Driven
Elastic Models for Cloth: Modeling and Measurement". ACM Transactions on
Graphics, 30(4):71:1–11, July 2011. Proceedings of ACM SIGGRAPH 2011,
Vancouver, BC Canada.</li>
</ul>
<h3 id="质点弹簧系统-1">质点弹簧系统</h3>
<ul>
<li>一系列相互连接的质点和弹簧</li>
</ul>
<h4 id="理想的弹簧">理想的弹簧</h4>
<ul>
<li>没有长度</li>
<li>被拉开多长，就产生多大的力</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210401202528815.png" style="zoom:100%;"></p>
<ul>
<li>弹簧力大小的计算
<ul>
<li>胡克定律 Hooke’s Law</li>
<li>劲度系数 <span class="math inline">\(k_s\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\boldsymbol{f_{a\to b}}=k_s(\mathbf{b}-\mathbf{a})
\]</span></p>
<p><span class="math display">\[
\boldsymbol{f_{b\to a}}=-\boldsymbol{f_{a\to b}}
\]</span></p>
<h4 id="有长度的弹簧">有长度的弹簧</h4>
<p><span class="math display">\[
\boldsymbol{f_{a\to
b}}=k_s(||\mathbf{b}-\mathbf{a}||-l)\dfrac{\mathbf{b}-\mathbf{a}}{||\mathbf{b}-\mathbf{a}||}
\]</span></p>
<ul>
<li>胡克定律
<ul>
<li><span class="math inline">\(\dfrac{\mathbf{b}-\mathbf{a}}{||\mathbf{b}-\mathbf{a}||}\)</span>
表示方向</li>
</ul></li>
<li>问题：由于能量守恒，永远不会停下来
<ul>
<li><strong>加入一个摩擦力</strong></li>
</ul></li>
<li>记号</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\boldsymbol{x}\\
&amp;\dot{\boldsymbol{x}}=\boldsymbol{v}\\
&amp;\ddot{\boldsymbol{x}}=\boldsymbol{a}
\end{aligned}
\]</span></p>
<h4 id="阻尼">阻尼</h4>
<ul>
<li>damping force</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210401204250184.png" style="zoom:80%;"> <span class="math display">\[
\boldsymbol{f}=-k_d\mathbf{\dot{b}}
\]</span></p>
<ul>
<li>问题：会引起所有的运动都停下来（Slows down all motion）
<ul>
<li>表现不了弹簧内部的损耗</li>
</ul></li>
<li>表现问题的例子
<ul>
<li>两个质点和连接它们的弹簧，在光滑的水平面上同步的向右运动，理论上应该不会被停下来，而且弹簧之间应该没有相对运动</li>
<li>但是按照这个模型他们会被停下来</li>
</ul></li>
<li>阻尼应该加在弹簧上，即两个质点的相对运动上（相对速度在弹簧方向上的分量）</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210401205009298.png" style="zoom:80%;"> <span class="math display">\[
\boldsymbol{f_{b}}=-k_d\dfrac{\mathbf{b}-\mathbf{a}}{||\mathbf{b}-\mathbf{a}||}\cdot(\mathbf{\dot{b}}-\mathbf{\dot{a}})\cdot
\dfrac{\mathbf{b}-\mathbf{a}}{||\mathbf{b}-\mathbf{a}||}
\]</span></p>
<ul>
<li>式子含义的解释</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210401205354628.png" style="zoom:60%;"></p>
<ul>
<li>可以解释圆周运动，速度没有衰减的现象</li>
</ul>
<h3 id="组合">组合</h3>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210401211126993.png" style="zoom:50%;"></p>
<h3 id="弹簧模拟布">弹簧模拟布</h3>
<h4 id="问题1切变">问题1：切变</h4>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210401211333098.png" style="zoom:50%;"></p>
<ul>
<li>布有抵抗切变的力，但是这个模型对角线一拉会形变</li>
</ul>
<h4 id="问题2不成平面">问题2：不成平面</h4>
<ul>
<li>如果有一个力让这个结构不成平面，这个结构可能不会恢复
<ul>
<li>例如上面的结构沿着对角线对折</li>
</ul></li>
<li>但是现实的布料是会恢复的</li>
</ul>
<h4 id="策略">策略</h4>
<ul>
<li>加对角线弹簧
<ul>
<li>但是变得不对称了</li>
<li>解决不了问题 2</li>
</ul></li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210401211837682.png" style="zoom:50%;"></p>
<ul>
<li>加两个对角线
<ul>
<li>同样解决不了问题 2（竖直对折）</li>
</ul></li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210401212105160.png" style="zoom:50%;"></p>
<ul>
<li>每一个点和它相隔一个点的点相连
<ul>
<li>skip connection</li>
<li>这样不管如果你把这个结构折成不在一个平面内的结构的话，势必会影响某个弹簧（产生恢复力）</li>
<li>红线的连接相对较弱（劲度系数较小）</li>
</ul></li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210401220905052.png" style="zoom:67%;"></p>
<h3 id="有限元方法模拟布料">有限元方法模拟布料</h3>
<ul>
<li>FEM：Finite Element Method</li>
<li>广泛应用于汽车碰撞的模拟</li>
<li>力的作用会传导</li>
<li>FEM 写起来很复杂</li>
</ul>
<h2 id="粒子系统">粒子系统</h2>
<ul>
<li><strong>Particle System</strong></li>
<li>把模型看成是很多个粒子的集合</li>
<li>每个粒子的动作都被（非）物理上的力定义</li>
<li>在现代图形学和游戏中广泛应用
<ul>
<li>实现比较简单和方便</li>
<li>点越多，复杂度越高，模拟得越精细，执行越慢</li>
</ul></li>
<li>问题
<ul>
<li>可能需要大量的粒子（流体）</li>
<li>可能需要一些其他的加速结构
<ul>
<li>例如要求粒子之间的引力（需要有一个很快得找到周围的粒子的方法）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="简单算法">简单算法</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">For each frame <span class="keyword">in</span> animation</span><br><span class="line">    [If needed] Create new particles</span><br><span class="line">    Calculate forces on each particle</span><br><span class="line">    Update each particle’s position <span class="keyword">and</span> velocity</span><br><span class="line">    [If needed] Remove dead particles</span><br><span class="line">    Render particles</span><br></pre></td></tr></table></figure>
<ul>
<li>建模的部分确定有哪些相互作用力</li>
<li>怎么去解作用力
<ul>
<li>学术界更关心</li>
<li>更难一些</li>
</ul></li>
<li>注意：<strong>模拟和渲染的过程是分开的</strong></li>
</ul>
<h3 id="粒子系统中力的作用">粒子系统中力的作用</h3>
<ul>
<li>Attraction and repulsion forces（引力与斥力）
<ul>
<li>Gravity, electromagnetism, …</li>
<li>Springs, propulsion, …</li>
</ul></li>
<li>Damping forces（阻尼）
<ul>
<li>Friction, air drag, viscosity, …</li>
</ul></li>
<li>Collisions（碰撞）
<ul>
<li>Walls, containers, fixed objects, …</li>
<li>Dynamic objects, character body parts, …</li>
</ul></li>
</ul>
<h3 id="粒子的扩展">粒子的扩展</h3>
<ul>
<li>粒子：大规模范围内有很多小的重复的东西，这些东西可以理解为粒子</li>
</ul>
<h4 id="模拟鸟群">模拟鸟群</h4>
<ul>
<li>http://www.red3d.com/cwr/boids/</li>
<li>引力：和邻居的中心有个引力（任何一只鸟都不想落单，并且试图融入到他们中间去）</li>
<li>斥力：和每只邻居中的鸟都有斥力（任何一只鸟都不希望和其他鸟离的太近）</li>
<li>朝向：邻居的朝向平均值（希望沿着和邻居相同的方向飞）</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210401234930535.png" style="zoom:60%;"></p>
<h4 id="其他例子">其他例子</h4>
<ul>
<li>模拟分子结构
<ul>
<li>Molecular Dynamics</li>
</ul></li>
<li>人群的模拟
<ul>
<li>Crowds + “Rock” Dynamics</li>
</ul></li>
</ul>
<h3 id="其他笔记">其他笔记</h3>
<ul>
<li><a href="/2021/02/03/CG/LS/07/">计算机图形学-李胜</a></li>
</ul>
<h2 id="正运动学">正运动学</h2>
<ul>
<li>Forward Kinematics</li>
<li>做出一种动画，用于描述一个骨骼系统，能够表示和人类似的拓扑结构</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210401235801146.png" style="zoom:50%;"></p>
<ul>
<li>Articulated skeleton（铰接式骨架）
<ul>
<li>Topology (what’s connected to what)
<ul>
<li>拓扑结构，具体怎么连接</li>
</ul></li>
<li>Geometric relations from joints
<ul>
<li>通过关节连接</li>
</ul></li>
<li>Tree structure (in absence of loops)
<ul>
<li>树的结构（无环）</li>
</ul></li>
</ul></li>
<li>关节的类型
<ul>
<li>Pin：允许 1D 的旋转</li>
<li>Ball：允许 2D 的旋转（像球一样旋转、可以转到平面外）</li>
<li>Prismatic joint：允许拉长</li>
</ul></li>
<li>Pin（被钉住一样）</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210401235842580.png" style="zoom:100%;"></p>
<ul>
<li>Prismatic joint（棱柱形关节）</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210402000012688.png"></p>
<h3 id="关节的例子">关节的例子</h3>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210402000209841.png" style="zoom:67%;"></p>
<ul>
<li>Pin 关节连接</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;p_x=l_1\cos(\theta_1)+l_2\cos(\theta_1+\theta_2)\\
&amp;p_y=l_1\sin(\theta_1)+l_2\sin(\theta_1+\theta_2)\\
\end{aligned}
\]</span></p>
<h3 id="评价">评价</h3>
<h4 id="问题">问题</h4>
<ul>
<li>定义太过于物理</li>
<li>不适合与艺术家
<ul>
<li>艺术家喜欢更加直观简单的定义，例如从哪里移动到哪里（而不是几个参数）</li>
</ul></li>
</ul>
<h4 id="好处">好处</h4>
<ul>
<li>方便计算模拟，实现简单</li>
</ul>
<h2 id="逆运动学">逆运动学</h2>
<ul>
<li>告诉你运动的结果，然后计算出参数来模拟这个结果
<ul>
<li>例如给出轨迹，然后计算参数</li>
</ul></li>
</ul>
<h3 id="关节的例子-1">关节的例子</h3>
<ul>
<li>给你 <span class="math inline">\(P\)</span>
点的轨迹，求出中间的过程中的 <span class="math inline">\(\theta_1,\theta_2\)</span>
的值，从而模拟这个运动</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210402001325862.png" style="zoom:67%;"></p>
<ul>
<li>解起来很复杂</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210402001401828.png" style="zoom:30%;"></p>
<h3 id="评价-1">评价</h3>
<h4 id="问题-1">问题</h4>
<ul>
<li>关节多了很难算</li>
<li>解不唯一</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210402001550942.png" style="zoom: 70%;"></p>
<ul>
<li>可能无解
<ul>
<li>解只可能出现实线的圆环上，其他地方无解</li>
</ul></li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210402001723638.png" style="zoom:50%;"></p>
<h4 id="解决策略">解决策略</h4>
<ul>
<li>优化方法求解（梯度下降）</li>
</ul>
<h3 id="逆运动学例子">逆运动学例子</h3>
<ul>
<li>Grochow et al., Style Based Inverse Kinematics</li>
</ul>
<h2 id="rigging">Rigging</h2>
<ul>
<li>指对于形状的控制
<ul>
<li>类似于木偶的控制</li>
</ul></li>
<li>Rigging is a set of higher level controls on a character that allow
more rapid &amp; intuitive modification of pose, deformations,
expression, etc</li>
<li>一定程度上可以说是对于逆运动学的一个应用</li>
<li>Rigging 本身很复杂
<ul>
<li>建模很复杂</li>
</ul></li>
</ul>
<h3 id="blend-shape">Blend Shape</h3>
<ul>
<li>艺术家对同一个人物形象的两个动作已经做好了，不使用骨架，直接堆表面进行插值出中间的形态
<ul>
<li>对于<strong>控制点进行插值</strong></li>
</ul></li>
</ul>
<h3 id="motion-capture">Motion Capture</h3>
<ul>
<li>动作捕捉</li>
<li>真人的控制点</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210402002734021.png" style="zoom:60%;"></p>
<ul>
<li>好处
<ul>
<li>真实感非常强</li>
<li>实际动作不需要艺术家去调，很方便（快）</li>
</ul></li>
<li>缺点
<ul>
<li>动作演员很辛苦</li>
<li>动画人物的动作和现实人做出的动作还是有差异的
<ul>
<li>后期调整</li>
</ul></li>
<li>捕捉不到很好的数据</li>
<li>成本高
<ul>
<li>需要很多个摄像机，才能捕捉到完整的信息</li>
</ul></li>
<li>人物动作自己遮挡到控制点</li>
</ul></li>
</ul>
<h4 id="其他的控制点模型">其他的控制点模型</h4>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210402003138064.png" style="zoom:67%;"></p>
<ul>
<li>光学的方法（不受遮挡的影响）
<ul>
<li>应用相对广泛</li>
<li>需要很多相机高频捕捉</li>
</ul></li>
<li>机械的方法（直接输出数据）</li>
<li>得到的数据
<ul>
<li>每一个控制点的位置随着时间变化的信息</li>
</ul></li>
<li>可以得到非常真实的动画</li>
<li><strong>恐怖谷效应</strong> Uncanny valley
<ul>
<li>过于真实带来的问题</li>
</ul></li>
<li>阿凡达 Avatar
<ul>
<li>使用了面部捕捉</li>
<li>里程碑式的作品</li>
</ul></li>
</ul>
<h2 id="动画产业的-pipeline">动画产业的 pipeline</h2>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/12/image-20210402003601782.png" style="zoom:100%;"></p>
<ul>
<li>VFX：visual effects</li>
<li>开销：美工的开销、渲染的开销
<ul>
<li>动画电影的开销比请演员还高</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES101</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101.闫令琪.13.动画与模拟(2)(Lecture 22)</title>
    <url>/2021/04/01/CG/YLQ-GAMES101/13/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/av90798049</li>
</ul>
<h1 id="动画与模拟">动画与模拟</h1>
<h2 id="单个粒子的模拟">单个粒子的模拟</h2>
<ul>
<li>假设单个粒子在速度场中运动
<ul>
<li>理想，实际很难找到一个速度场</li>
</ul></li>
<li>解常微分方程
<ul>
<li>ODE：Ordinary Differential Equation</li>
</ul></li>
</ul>
<p><span class="math display">\[
\dfrac{dx}{dt}=\dot{x}=v(x,t)
\]</span></p>
<h2 id="欧拉方法">欧拉方法</h2>
<ul>
<li>前向欧拉方法，显式欧拉方法</li>
<li>简单的迭代方法</li>
<li>广泛的使用</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\boldsymbol{x}^{t+\Delta t}=\boldsymbol{x}^{t}+\Delta t
\dot{\boldsymbol{x}}^{t} \\ \dot{\boldsymbol{x}}^{t+\Delta
t}=\dot{\boldsymbol{x}}^{t}+\Delta t \ddot{\boldsymbol{x}}^{t}
\end{aligned}
\]</span></p>
<ul>
<li>始终用上一个时刻的数据计算这一时刻的数据</li>
</ul>
<h3 id="存在的问题">存在的问题</h3>
<h4 id="不准确">不准确</h4>
<ul>
<li>很不准确
<ul>
<li>可以通过减小步长来解决</li>
</ul></li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/13/image-20210402104312620.png" style="zoom: 70%;"></p>
<h4 id="不稳定">不稳定</h4>
<ul>
<li>通常会趋于不稳定
<ul>
<li>例如下面的两个场景
<ul>
<li>场景1：只要有一小段步长，就会脱离螺旋线</li>
<li>场景2：不能汇聚到中心，反而离中心越来越远（正反馈）</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/13/image-20210402104639526.png" style="zoom:70%;"></p>
<h4 id="问题的比较">问题的比较</h4>
<ul>
<li>Errors
<ul>
<li>Errors at each time step accumulate. Accuracy decreases as
simulation proceeds</li>
<li><strong>Accuracy may not be critical in graphics
applications</strong>
<ul>
<li>CG 中，物理上不太准确没啥大关系，效果好就行</li>
</ul></li>
</ul></li>
<li>Instability
<ul>
<li>Errors can compound, causing the simulation to
<strong>diverge</strong> even when the underlying system does not
<ul>
<li>你有一个模拟方法，但是不管你怎么模拟都不会收敛到实际的结果</li>
<li>发散的结果和真实的差的特别大</li>
</ul></li>
<li>Lack of stability is a fundamental problem in simulation, and cannot
be ignored
<ul>
<li>不稳定是个很严重的问题</li>
</ul></li>
</ul></li>
</ul>
<h2 id="对抗不稳定性">对抗不稳定性</h2>
<h3 id="中点法">中点法</h3>
<ul>
<li>Midpoint Method</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/13/image-20210402105237738.png" style="zoom:60%;"></p>
<h4 id="算法">算法</h4>
<ul>
<li>首先使用欧拉方法计算出下一个点的位置 a</li>
<li>取原始点和 a 点连线的中点 b</li>
<li>计算 b 点的方向</li>
<li>用 b 点的方向在原始点上移动一段距离</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
x_{mid}=x(t)+\dfrac{\Delta t}{2}\cdot v(x(t),t)\\
x(t+\Delta t)=x(t)+\Delta t\cdot v(x_{mid},t)
\end{aligned}
\]</span></p>
<h4 id="评价">评价</h4>
<ul>
<li>思想：找一个更具代表性的速度</li>
<li>中点法为什么更优？
<ul>
<li>比欧拉方法多了一个<strong>二次项</strong></li>
</ul></li>
<li>展开上述的公式</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\boldsymbol{x}^{t+\Delta t}&amp;=\boldsymbol{x}^{t}+\Delta
t\left(\boldsymbol{\dot{x}}^{t}+\dfrac{\Delta
t}{2}\cdot\boldsymbol{\ddot{x}}^{t} \right)\\
&amp;=\boldsymbol{x}^{t}+\Delta t
\dot{\boldsymbol{x}}^{t}+\dfrac{(\Delta t)^{2}}{2}
\ddot{\boldsymbol{x}}^{t} \end{aligned}
\]</span></p>
<ul>
<li>是欧拉方法的一个改进</li>
</ul>
<h3 id="自适应步长">自适应步长</h3>
<ul>
<li>Adaptive Step Size</li>
<li>通过估计的方式选择时间步长</li>
<li>很实用的方法</li>
<li>可能会导致使用很小的步长</li>
</ul>
<h4 id="算法-1">算法</h4>
<ul>
<li>定义一个阈值 threshold</li>
<li>重复以下的步骤，直至误差小于阈值
<ul>
<li>Compute <span class="math inline">\(x_T\)</span> an Euler step, size
<span class="math inline">\(T\)</span></li>
<li>Compute <span class="math inline">\(x_{T/2}\)</span> two Euler
steps, size <span class="math inline">\(\dfrac{T}{2}\)</span>
<ul>
<li>把时间分成两段，使用两次欧拉方法</li>
</ul></li>
<li>Compute error <span class="math inline">\(||x_{T}-x_{T/2}||\)</span></li>
<li>If (error &gt; threshold) reduce step size and try again
<ul>
<li>重复减半 <span class="math inline">\(\Delta
T\)</span>，直至错误小于阈值</li>
</ul></li>
</ul></li>
</ul>
<h3 id="隐式欧拉方法">隐式欧拉方法</h3>
<ul>
<li>Implicit methods</li>
<li>后向欧拉方法</li>
<li>使用下一帧的数据来估计这一个时刻的数据
<ul>
<li>解方程组</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\boldsymbol{x}^{t+\Delta t}=\boldsymbol{x}^{t}+\Delta t\
\dot{\boldsymbol{x}}^{t+\Delta t} \\
\dot{\boldsymbol{x}}^{t+\Delta t}=\dot{\boldsymbol{x}}^{t}+\Delta
t\  \ddot{\boldsymbol{x}}^{t+\Delta t}
\end{aligned}
\]</span></p>
<ul>
<li>如果变量描述关系没有这么简单，解方程是一个很难的问题
<ul>
<li>非线性方程组</li>
</ul></li>
<li>一般情况下会利用优化方法来解
<ul>
<li>牛顿法求根公式</li>
</ul></li>
<li>结果稳定性非常好</li>
<li>怎么定义一个算法的稳定性
<ul>
<li>局部每一步的误差：local truncation error (every step)</li>
<li>总的误差：total accumulated error (overall)</li>
</ul></li>
<li>评价的时候看误差的阶</li>
<li>隐式欧拉方法误差的阶是 <span class="math inline">\(1\)</span>
<ul>
<li>局部误差：<span class="math inline">\(O(h^2)\)</span></li>
<li>全局误差：<span class="math inline">\(O(h)\)</span></li>
<li><span class="math inline">\(h\)</span> 表示步长，在这里是 <span class="math inline">\(\Delta t\)</span></li>
</ul></li>
<li>阶越高越好
<ul>
<li>越高的话，我们可以通过减小步长的方法很快的把误差减小下来</li>
</ul></li>
</ul>
<h3 id="龙格库塔方法">龙格库塔方法</h3>
<ul>
<li>Runge-Kutta</li>
<li>一类方法</li>
<li>擅长求解 ODE</li>
<li>一个用的比较多的方法：RK4（4阶）</li>
</ul>
<h4 id="rk4">RK4</h4>
<ul>
<li>初始化
<ul>
<li>初始状态、场</li>
</ul></li>
</ul>
<p><span class="math display">\[
\dfrac{dy}{dt}=f(t,y),y(t_0)=y_)
\]</span></p>
<ul>
<li>更新方式</li>
</ul>
<p><span class="math display">\[
y_{n+1}=y_n+\dfrac{1}{6}h(k_1+2k_2+2k_3+k_4)
\]</span></p>
<p><span class="math display">\[
t_{n+1}=t_n+h
\]</span></p>
<ul>
<li>其中</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
k_1&amp;=f(t_n,y_n)\\
k_2&amp;=f(t_n+\dfrac{h}{2},y_n+h\dfrac{k_1}2)\\
k_3&amp;=f(t_n+\dfrac{h}{2},y_n+h\dfrac{k_2}2)\\
k_4&amp;=f(t_n+h,y_n+hk_3)\\
\end{aligned}
\]</span></p>
<ul>
<li>可以理解为中点法的扩展，精确设计</li>
</ul>
<h3 id="非物理的方法">非物理的方法</h3>
<ul>
<li>Position-Based / Verlet Integration
<ul>
<li>只通过调整位置，使其最后满足某种性质</li>
</ul></li>
<li>在渲染上很好用</li>
<li>不是基于物理的，会不满足物理现象（）能量损失极快</li>
</ul>
<h2 id="刚体的模拟">刚体的模拟</h2>
<ul>
<li>不会形变</li>
<li>类似粒子，但是需要考虑更多的物理量
<ul>
<li>位置、角度、速度、角速度</li>
</ul></li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/13/image-20210402114539986.png" style="zoom:60%;"></p>
<h2 id="流体的模拟">流体的模拟</h2>
<ul>
<li>A Simple <strong>Position-Based</strong> Method</li>
<li>通过模拟整个形成水的体积的小球的位置来模拟整个谁的运动</li>
</ul>
<h3 id="key-idea">key idea</h3>
<ul>
<li>水体是由很多的不可压缩的刚体小球组成的</li>
<li>水是不可压缩的（水的密度是一样的）</li>
<li>从密度的角度出发，如果某个位置的密度发生了改变（和原来不一样），通过改变小球的运动将密度进行修正
<ul>
<li>模拟水的运动</li>
</ul></li>
<li>需要知道密度对所有小球位置（粒子）的梯度
<ul>
<li>很远的小球不影响，梯度为 0</li>
<li>比较近的小球的会影响</li>
</ul></li>
<li>怎么更新（调整小球位置）
<ul>
<li>梯度下降方法</li>
<li>可能出来停不下来的现象
<ul>
<li>可以人为加上运动损失</li>
</ul></li>
</ul></li>
</ul>
<h2 id="两大流派">两大流派</h2>
<ul>
<li>Eulerian vs. Lagrangian</li>
<li>https://www.youtube.com/watch?v=iDIzLkic1pY</li>
</ul>
<p><img src="/2021/04/01/CG/YLQ-GAMES101/13/image-20210402140922051.png" style="zoom:73%;"></p>
<h3 id="拉格朗日方法">拉格朗日方法</h3>
<ul>
<li>质点法</li>
<li>跟踪每一个<strong>质点</strong>的信息</li>
</ul>
<h3 id="欧拉方法-1">欧拉方法</h3>
<ul>
<li>网格法</li>
<li>将场景划分为若干网格</li>
<li>跟踪每个<strong>网格</strong>的信息变化</li>
</ul>
<h3 id="物质点方法">物质点方法</h3>
<ul>
<li>Material Point Method (MPM)</li>
<li>两种方法的混合</li>
</ul>
<h4 id="思路">思路</h4>
<ul>
<li>Lagrangian: consider particles carrying material properties
<ul>
<li>每一个点都带有一些属性</li>
</ul></li>
<li>Eulerian: use a grid to do numerical integration
<ul>
<li>属性的计算是以网格为单位的计算</li>
</ul></li>
<li>Interaction: particles transfer properties to the grid, grid
performs update, then interpolate back to particles
<ul>
<li>网格计算完之后把这些信息写回每个点</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES101</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法.宋国杰.00.说明</title>
    <url>/2021/07/17/DSA/SGJ/00/</url>
    <content><![CDATA[<h1 id="说明">说明</h1>
<ul>
<li>课程名：《数据结构与算法》</li>
<li>课程教师：宋国杰</li>
<li>慕课链接：<a href="https://www.icourse163.org/course/PKU-1002534001">中国大学慕课</a></li>
<li>一些其他材料
<ul>
<li><a href="https://media.openjudge.cn/upload/DSMooc/DSCode_ZhangWangZhao2008_06.rar">课程源代码</a></li>
<li><a href="http://dsalgo.openjudge.cn/">代码练习网站</a></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>0</category>
        <category>DSA</category>
      </categories>
      <tags>
        <tag>DSA</tag>
        <tag>SGJ</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法.宋国杰.01.引言与概论</title>
    <url>/2021/07/17/DSA/SGJ/01/</url>
    <content><![CDATA[<h1 id="引言">引言</h1>
<h2 id="课程目标">课程目标</h2>
<ul>
<li>逻辑结构
<ul>
<li>图 <span class="math inline">\(\supseteq\)</span> 树 <span class="math inline">\(\supseteq\)</span> 线性</li>
</ul></li>
<li>存储结构
<ul>
<li>顺序、链接</li>
<li>索引、散列</li>
</ul></li>
<li>运算
<ul>
<li>增删查改</li>
<li>遍历、排序</li>
</ul></li>
<li>时间复杂度 vs 空间复杂度
<ul>
<li>trade off</li>
</ul></li>
</ul>
<h2 id="解决问题的过程">解决问题的过程</h2>
<ul>
<li>问题（Problem Problem ）
<ul>
<li>从输入到出的一种函数映射</li>
</ul></li>
<li>数据结构（Data Structure）
<ul>
<li>数据的逻辑结构及在计算机中存储表示 ，以及相应操作</li>
</ul></li>
<li>算法（Algorithm）
<ul>
<li>对特定问题求解过程的描述 方法</li>
</ul></li>
<li>程序（Program）
<ul>
<li>算法在计机程序设语言中的实现</li>
</ul></li>
</ul>
<h1 id="概论">概论</h1>
<h2 id="数据结构">数据结构</h2>
<ul>
<li>涉及数据之间的<strong>逻辑关系</strong>、数据在计算机中的<strong>存储表示</strong>和在这种结构上一组能执行的<strong>操作（运算）</strong></li>
<li>三要素
<ul>
<li>逻辑结构、存储（物理）结构、运算</li>
</ul></li>
</ul>
<h3 id="逻辑结构">逻辑结构</h3>
<ul>
<li>Logical Structure</li>
<li>具体问题的<strong>数学抽象</strong>，反映<strong>事物组成</strong>和<strong>逻辑关系</strong></li>
</ul>
<h4 id="逻辑结构的表示">逻辑结构的表示</h4>
<ul>
<li>用<strong>一组数据</strong>（表示为<strong>结点</strong>集合
K），及数据间的<strong>二元关系</strong>（<strong>关系</strong>集合
R）表示：<strong>(K, R)</strong></li>
<li>K 由<strong>有限个</strong>结点组成，代表一组有明确结构的数据集</li>
<li>R 是定义在集合 K 上的一组关系，每个关系 r <span class="math inline">\(\in\)</span> R 都是 <strong>K<span class="math inline">\(\times\)</span>K
上的二元关系</strong>，描述结点间的逻辑关系</li>
</ul>
<h4 id="结点的类型">结点的类型</h4>
<ul>
<li>基本数据类型
<ul>
<li>整数类型 (integer)、实数类型 (real) 、字符类型 (char)、指针类型
(pointer)</li>
</ul></li>
<li>复合数据类型
<ul>
<li>由基本数据类型组合而成的结构
<ul>
<li>数组 、结构类型等</li>
</ul></li>
<li>复合数据类型本身，又可参与定义更为复杂的结点类型</li>
</ul></li>
</ul>
<h4 id="结构关系的类型">结构(关系)的类型</h4>
<ul>
<li>用 R 的性质来刻划数据结构的特点，并进行分类
<ul>
<li>集合结构（set structure）</li>
<li>线性结构（linear structure）</li>
<li>树型结构（tree structure）</li>
<li>图结构（graph structure）</li>
</ul></li>
</ul>
<h5 id="线性结构">线性结构</h5>
<ul>
<li>又被称为<strong>前驱关系</strong></li>
<li>关系 r 是<strong>有向的</strong></li>
<li>满足<strong>全序性</strong>、<strong>单索性</strong>
<ul>
<li>全序性：全部结点两两<strong>皆可比较前后</strong></li>
<li>单索性：每个结点都存在<strong>唯一</strong>一个<strong>直接前驱和直接后继结点</strong></li>
</ul></li>
</ul>
<h5 id="树形结构">树形结构</h5>
<ul>
<li>又被称为<strong>层次结构</strong></li>
<li>每个结点可有多于一个 “直接后继”，但只有唯一的 “直接前驱”</li>
<li>最高层结点称为根（root）结点，无父结点</li>
</ul>
<h5 id="图形结构">图形结构</h5>
<ul>
<li>又被称为<strong>网络结构</strong></li>
<li>图结构对关系 r 没有施加任何约束
<ul>
<li>每个结点的直接前驱和直接后继数目没有要求</li>
</ul></li>
</ul>
<h4 id="逻辑结构设计方法">逻辑结构设计方法</h4>
<ul>
<li><strong>自顶向下</strong>的设计逻辑
<ul>
<li>先明确数据结点，及其主要关系 r</li>
<li>在分析关系 r 时，也要分析其数据结点的数据类型</li>
<li>如果数据结点的逻辑结构比较复杂，那么把它作为下一个层次，再分析下一层次的逻辑结构</li>
<li>递归分析，直至满足需求</li>
</ul></li>
</ul>
<h3 id="存储结构">存储结构</h3>
<ul>
<li>亦称<strong>物理结构</strong>，是逻辑结构在计算机中的<strong>物理存储表示</strong></li>
<li>计算机主存储器
<ul>
<li><strong>空间相邻</strong>
<ul>
<li>存储空间是一种具有非负整数地址编码的、空间相邻的单元集合，其基本存储单元是<strong>字节</strong></li>
</ul></li>
<li><strong>随机访问</strong>
<ul>
<li>计算机指令具有<strong>按地址随机访问</strong>存储空间内任意单元的能力，访问不同地址所需时间相同</li>
</ul></li>
</ul></li>
<li>存储结构建立一种<strong>逻辑结构到物理结构的映射</strong>
<ul>
<li><strong>逻辑结点映射</strong>：对于每一个结点 j <span class="math inline">\(\in\)</span> K 都对应一个唯一的存储区域 c <span class="math inline">\(\in\)</span> M</li>
<li><strong>逻辑关系映射</strong>：每一关系元组 <span class="math inline">\((j_1,j_2)\in r\)</span>（其中 <span class="math inline">\(j_1,j_2\in K\)</span> 是结点），亦即 <span class="math inline">\(j_1,j_2\)</span>
的逻辑关系映射为存储单元的地址顺序关系（或指针地址指向关系）</li>
</ul></li>
<li>四种基本存储映射方法
<ul>
<li>顺序、链接、索引、散列</li>
</ul></li>
</ul>
<h4 id="顺序方法">顺序方法</h4>
<ul>
<li>顺序存储
<ul>
<li>结点按<strong>地址相邻关系</strong>顺序存储，结点间逻辑关系用存储单元的<strong>自然顺序</strong>关系来表达</li>
<li>数组是顺序存储法的具体实例</li>
</ul></li>
<li><strong>顺序存储是紧凑存储结构</strong>
<ul>
<li>紧凑：存储空间除存储有用数据外，<strong>不存储其他附加信息</strong></li>
<li>存储密度：存储结构所存储 “有用数据”
和该结构（包括附加信息）整个存储空间大小之比</li>
</ul></li>
<li>一维数组</li>
<li>二维数组：支持整数编码访问
<ul>
<li>行优先存储</li>
<li><span class="math inline">\(M[i][j]=M[0][0]+i\times
\mathrm{sizeof}(M[0])\times \mathrm{sizeof}(M[0][0])\)</span></li>
</ul></li>
</ul>
<h4 id="链接方法">链接方法</h4>
<ul>
<li>利用存储结构中<strong>指针指向</strong>来表示两个结点间逻辑关系</li>
<li>可以表达任意的逻辑关系 r</li>
<li>将数据结点分为两部分：数据字段、指针字段
<ul>
<li>数据字段：存放结点本身的数据</li>
<li>指针字段：存放指针，链接到某个<strong>后继结点</strong>，指向存储单元的开始地址</li>
<li>多个相关结点的依次链接就会形成<strong>链表</strong></li>
</ul></li>
<li>优点：<strong>增删容易</strong>
<ul>
<li>顺序方法对于经常增、删结点情形，往往遇到困难</li>
<li>链接方法结合动态存储可以解决这些复杂的问题</li>
</ul></li>
<li>缺点：<strong>定位困难</strong>
<ul>
<li>访问结点必须知道该结点的指针</li>
<li>否则需要沿着链接指针逐个搜索，花费时间较大</li>
</ul></li>
</ul>
<h4 id="索引方法">索引方法</h4>
<p><img src="/2021/07/17/DSA/SGJ/01/image-20210717131720697.png" style="zoom: 67%;"></p>
<ul>
<li>是顺序存储法的一种推广</li>
<li>索引方法是要建造一个由整数域 Z 映射到存储地址域 D 的函数 Y: Z <span class="math inline">\(\to\)</span> D，把结点的整数索引值 z <span class="math inline">\(\in\)</span> Z 映射到结点的存储地址d <span class="math inline">\(\in\)</span> D
<ul>
<li>Y 称为索引函数</li>
</ul></li>
</ul>
<h4 id="散列方法">散列方法</h4>
<ul>
<li>散列是索引方法的扩展</li>
<li>散列函数：将关键码 s 映射到非负整数 z
<ul>
<li>h: s <span class="math inline">\(\to\)</span> z</li>
</ul></li>
<li>对任意的 s <span class="math inline">\(\in\)</span> S，散列函数
h(s)=z，z <span class="math inline">\(\in\)</span> Z</li>
</ul>
<h3 id="抽象数据类型-adt">抽象数据类型 (ADT)</h3>
<ul>
<li>抽象问题得到解决，同类具体问题都可得到解决</li>
<li>ADT 是对多种可能的结构和实现的抽象</li>
<li>模块化思想的发展，提供了抽象数据类型的实现手段，简称 ADT (Abstract
Data Type)
<ul>
<li>可以看作是定义了一组操作的一个抽象模型</li>
</ul></li>
<li>一个抽象数据类型要包括哪些操作，这一点由设计者根据需要确定</li>
<li>用数学方法定义<strong>对象集合</strong>和<strong>运算集合</strong>，仅通过运算的性质刻画数据对象，而<strong>独立于计算机中可能的表示方法</strong></li>
<li>目的：<strong>隐藏运算实现的细节和内部数据结构</strong></li>
<li>三元组：&lt;数据对象，数据关系，数据操作&gt;</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ADT 抽象数据类型名 &#123;</span><br><span class="line">    数据对象D: &lt;数据对象的定义&gt;;</span><br><span class="line">    数据关系S: &lt;数据关系的定义&gt;;</span><br><span class="line">    数据操作P: &lt;基本操作的定义&gt;;</span><br><span class="line">&#125; ADT 抽象数据类型名</span><br></pre></td></tr></table></figure>
<h2 id="算法">算法</h2>
<ul>
<li>数据结构 + 算法 = 程序设计</li>
<li>程序设计的实质：为计算机处理问题编制一组 “指令”</li>
<li>需要解决两个问题：算法和数据结构
<ul>
<li>数据结构 = 问题的数学模型</li>
<li>算法 = 处理问题的策略</li>
</ul></li>
</ul>
<h3 id="算法的性质">算法的性质</h3>
<ul>
<li>通用性
<ul>
<li>对<strong>参数化输入</strong>进行问题求解
，保证计算<strong>结果的正确性</strong></li>
</ul></li>
<li>有效性
<ul>
<li>有限条指令序列能完成算法所要实现的功能</li>
</ul></li>
<li>确定性
<ul>
<li>算法描述中的<strong>下一步应执行的骤必须明确</strong></li>
</ul></li>
<li>有穷性
<ul>
<li>算法的执行必须在<strong>有限步</strong>内结束</li>
<li>换句话说 ，算法不能有死循环</li>
</ul></li>
</ul>
<h3 id="算法分类">算法分类</h3>
<ul>
<li>穷举法
<ul>
<li>万能，低效</li>
</ul></li>
<li>回溯法、搜索 (DFS, BFS)</li>
<li>贪心法
<ul>
<li>最优子结构 —— 最优解</li>
<li>否则 ，只是快速得到次优解</li>
</ul></li>
<li>递归分治 (二分检索 、快速排序 、分治排序 )
<ul>
<li>子结构不重复</li>
<li>分、治、合</li>
</ul></li>
<li>动态规划
<ul>
<li>自底向上，利用中间结果，迅速构造</li>
<li>最优子结构、重复子结构、无后效性</li>
<li>搜索中分支定界的特例</li>
<li>空间换时间</li>
</ul></li>
</ul>
<h3 id="算法分析">算法分析</h3>
<ul>
<li>算法分析是对一个算法需要多少<strong>计算时间</strong>和<strong>存储空间</strong>的定量分析</li>
<li>判断所提出的算法是否符合现实情况</li>
<li>时间和空间复杂性：trade off</li>
</ul>
<h4 id="算法复杂性度量">算法复杂性度量</h4>
<ul>
<li>不能用绝对时间单位
<ul>
<li>环境不同</li>
<li>语言不同</li>
<li>可扩展性不同：在不同输入规模上表现不同</li>
</ul></li>
<li>绝对运行时间的比较也是需要的</li>
<li>重要的不是具体的时间，而是<strong>算法复杂性</strong>与<strong>输入数据规模(N)</strong>之间的关系</li>
<li>用 “<strong>输入规模(N)</strong>” 所需
“<strong>基本操作(B)</strong>”
的量级来描述时间复杂性，与操作的具体数值无关</li>
</ul>
<h3 id="算法的渐进分析">算法的渐进分析</h3>
<ul>
<li>大 <span class="math inline">\(O\)</span> 表示法
<ul>
<li>如果存在正数 <span class="math inline">\(c\)</span> 和 <span class="math inline">\(n_0\)</span>，使得对任意的 <span class="math inline">\(n&gt;n_0\)</span>，都有 <span class="math inline">\(f(n)\le cg(n)\)</span></li>
<li>则称 <span class="math inline">\(f(n)\)</span> 在集合 <span class="math inline">\(O(g(n))\)</span> 中，或简称 <span class="math inline">\(f(n)\)</span> 是 <span class="math inline">\(O(g(n))\)</span> 的</li>
</ul></li>
<li><span class="math inline">\(\Omega\)</span> 表示法
<ul>
<li>如果存在正数 <span class="math inline">\(c\)</span> 和 <span class="math inline">\(n_0\)</span>，使得对任意的 <span class="math inline">\(n&gt;n_0\)</span>，都有 <span class="math inline">\(f(n)\ge cg(n)\)</span></li>
<li>则称 <span class="math inline">\(f(n)\)</span> 在集合 <span class="math inline">\(\Omega(g(n))\)</span> 中，或简称 <span class="math inline">\(f(n)\)</span> 是 <span class="math inline">\(\Omega(g(n))\)</span> 的</li>
</ul></li>
<li><span class="math inline">\(\Theta\)</span> 表示法
<ul>
<li>如果一个函数既在集合 <span class="math inline">\(O(g(n))\)</span>
中又在集合 <span class="math inline">\(\Omega(g(n))\)</span>
中，则称其为 <span class="math inline">\(\Theta(g(n))\)</span> 的</li>
<li>即存在正数 <span class="math inline">\(c_1,c_2\)</span> 和 <span class="math inline">\(n_0\)</span>，使得对任意的 <span class="math inline">\(n&gt;n_0\)</span>，都有 <span class="math inline">\(c_1g(n)\le f(n)\le c_2g(n)\)</span></li>
</ul></li>
</ul>
<h4 id="示例">示例</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">4</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = i<span class="number">-3</span>, sum = a[i<span class="number">-4</span>]; j &lt;= i; j++) &#123;</span><br><span class="line">        sum += a[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>外层循环进行 n-4 次</li>
<li>对每个 i 而言，内层循环只执行 4 次
<ul>
<li>每次的操作次数和 i 的大小无关：11 次赋值操作</li>
</ul></li>
<li>整个代码总共进行1 + 11*(n-4) = O(n)次</li>
<li>看似双重循环，其实线性时间</li>
</ul>
<h4 id="最坏最好平均情况">最坏、最好、平均情况</h4>
<ul>
<li>算法分析受条件分支的影响
<ul>
<li>算法的增长率估计往往由于算法中的条件分支而遇到困难</li>
<li>分支走向又受输入数据取值的影响，因此很多算法都无法得出独立于输入数据的渐进估计</li>
</ul></li>
<li>估计方法
<ul>
<li>最坏情况估计</li>
<li>最好情况估计</li>
<li>平均情况估计</li>
</ul></li>
</ul>
<h5 id="平均情况">平均情况</h5>
<ul>
<li>简单情况下，需要考虑每种输入情况的概率</li>
</ul>
<p><span class="math display">\[
\mathrm{C_{avg}=\sum_{i}p(input_i)\times \mathrm{steps}(input_i)}
\]</span></p>
<ul>
<li>对于时间开销，一般不关注算法的最好估计，最坏估计是唯一的选择
<ul>
<li>特别是处理应急事件，计算机系统必须在规定的响应时间内做完紧急事件处理</li>
</ul></li>
<li>对于多数算法而言，<strong>最坏情况和平均情况估计</strong>，它们的时间开销的公式虽然不同，但是往往只是<strong>常数因子大小</strong>的区别，或者常数项的大小区别。因此<strong>不会影响渐进分析的增长率函数估计</strong></li>
</ul>
<h4 id="时间和空间的折衷">时间和空间的折衷</h4>
<ul>
<li>空间开销也可以实行类似的渐进分析方法
<ul>
<li>指除<strong>数据本身之外</strong>的存储开销</li>
</ul></li>
<li>静态存储结构
<ul>
<li>空间开销估计往往容易</li>
</ul></li>
<li>动态存储结构
<ul>
<li>算法运行过程中会有数量级地增大或缩小</li>
<li>这种情况的空间开销的分析和估计是十分必要的</li>
</ul></li>
<li>时空折衷（Trade-off between Time and Space）
<ul>
<li>空间换时间：为改善算法的时间开销，可通过增大空间开销而设计出时间开销小的算法</li>
<li>时间换空间：为缩小算法的空间开销，通过增大时间开销来换取存储空间的节省</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>DSA</category>
      </categories>
      <tags>
        <tag>DSA</tag>
        <tag>SGJ</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法.基本算法</title>
    <url>/2021/07/19/DSA/SGJ/dsa-code/</url>
    <content><![CDATA[<h1 id="数据结构与算法算法汇总">数据结构与算法算法汇总</h1>
<h2 id="最小生成树">1. 最小生成树</h2>
<ul>
<li><a href="http://dsa.openjudge.cn/graph/0714/">兔子与星空</a>
<ul>
<li>板子题</li>
<li><a href="/utils/show_code/index.html?dsa-code/1.1.Kruscal.cpp">Kruscal
代码</a></li>
</ul></li>
</ul>
<h2 id="拓扑排序">2. 拓扑排序</h2>
<ul>
<li><a href="http://dsa.openjudge.cn/graph/0719/">拓扑排序</a>
<ul>
<li>板子题</li>
<li><a href="/utils/show_code/index.html?dsa-code/2.1.cpp">代码</a></li>
</ul></li>
</ul>
<h2 id="树与森林">3. 树与森林</h2>
<ul>
<li><a href="http://bailian.openjudge.cn/practice/4082/">树的镜面映射</a>
<ul>
<li>森林（左子右兄表示方法）</li>
<li><a href="/utils/show_code/index.html?dsa-code/3.1.cpp">代码</a></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>DSA</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>DSA</tag>
        <tag>最小生成树</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>OSTEP 阅读笔记(说明)</title>
    <url>/2021/03/26/OS/OSTEP/00/</url>
    <content><![CDATA[<h2 id="说明">说明</h2>
<ul>
<li>书名
<ul>
<li>Operating Systems: Three Easy Pieces</li>
<li>操作系统导论</li>
</ul></li>
<li>官网
<ul>
<li>https://pages.cs.wisc.edu/~remzi/OSTEP/?source=techstories.org</li>
</ul></li>
<li>英文版 pdf 和 作业
<ul>
<li>https://pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>0</category>
        <category>OS.OSTEP</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>OSTEP 阅读笔记(Ch02.操作系统介绍)</title>
    <url>/2021/03/26/OS/OSTEP/02/</url>
    <content><![CDATA[<h1 id="第二章-操作系统介绍">第二章 操作系统介绍</h1>
<h2 id="基本概念">基本概念</h2>
<ul>
<li>操作系统中最重要的 3 个概念
<ul>
<li>虚拟化（virtualization）</li>
<li>并发（concurrency）</li>
<li>持久性（persistence）</li>
</ul></li>
<li>运行程序：执行指令</li>
<li>操作系统的出现，是为了让系统更加易于使用、能够高效地运行</li>
<li>操作系统利用虚拟化技术（virtualization），将物理资源抽象为更通用、强大的虚拟形式
<ul>
<li>虚拟化技术允许多个程序同时运行，并让他们似乎有着自己独立的物理设备</li>
<li>但是实际的物理设备是有限的，</li>
</ul></li>
<li>方便应用程序调用一些物理设备（还有保护的原因），操作系统为用户提供了很多<strong>系统调用</strong>，用于运行程序、访问内存和设备等</li>
<li>Virtualizing the CPU
<ul>
<li>可以多个程序一起运行（顺序由操作系统调度）</li>
</ul></li>
<li>Virtualizing Memory
<ul>
<li>让每个程序认为自己有独立的地址空间（虚存空间）</li>
<li>代码输出的地址是虚拟地址</li>
</ul></li>
<li>Concurrency
<ul>
<li>多线程是一种并发</li>
<li>非原子操作可能会引发错误</li>
<li>操作系统需要处理并发问题</li>
</ul></li>
<li>Persistence
<ul>
<li>由于断电或者系统崩溃等问题，需要持久存储数据</li>
<li>文件系统：操作系统中操理磁盘的软件</li>
<li>操作系统中没有虚拟磁盘，程序共享文件
<ul>
<li>硬件驱动程序很复杂，硬件相关（Windows中加入了硬件抽象层 HAL）</li>
</ul></li>
<li>处理系统崩溃
<ul>
<li>日志</li>
</ul></li>
<li>性能优化
<ul>
<li>写时复制</li>
</ul></li>
</ul></li>
</ul>
<h2 id="设计目标">设计目标</h2>
<ul>
<li>处理上述问题</li>
<li>抽象（层）</li>
<li>高性能</li>
<li>保护与隔离</li>
<li>能源效率</li>
<li>安全</li>
</ul>
<h2 id="历史">历史</h2>
<ul>
<li>早期
<ul>
<li>只是一些库</li>
</ul></li>
<li>限制应用程序功能
<ul>
<li>系统调用、权限分级</li>
</ul></li>
<li>multiprogramming
<ul>
<li>调度程序</li>
<li>内存保护</li>
</ul></li>
<li>PC：低成本、速度快、大众化</li>
</ul>
]]></content>
      <categories>
        <category>OS.OSTEP</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>OSTEP 阅读笔记(Ch04.进程)</title>
    <url>/2021/03/26/OS/OSTEP/04/</url>
    <content><![CDATA[<h1 id="第-4-章-抽象进程">第 4 章 抽象：进程</h1>
<ul>
<li>进程的非正式定义：<strong>进程就是运行中的程序</strong></li>
<li>操作系统通过虚拟化（virtualizing）CPU 来提供有许多 CPU 的假象
<ul>
<li>让一个进程只运行一个<strong>时间片</strong>，然后切换到其他进程</li>
<li><strong>性能损失</strong></li>
</ul></li>
<li>时分共享（time sharing），空分共享（space sharing）</li>
<li>低级的机制（mechanism）+ 高级的策略（policy）
<ul>
<li>低级方法或协议，实现了所需的功能</li>
<li>调度策略（scheduling policy）</li>
</ul></li>
</ul>
<h2 id="抽象进程">4.1 抽象：进程</h2>
<ul>
<li>进程的机器状态（machine state）：程序在运行时可以读取或更新的内容
<ul>
<li>内存</li>
<li>寄存器
<ul>
<li>通用寄存器</li>
<li>PC（Program Counter）程序计数器、栈指针（stack
pointer）、帧指针（frame pointer）等</li>
</ul></li>
<li>打开文件列表</li>
</ul></li>
<li>一种好的设计方式：<strong>分离策略和机制</strong></li>
</ul>
<h2 id="进程-api">4.2 进程 API</h2>
<ul>
<li>进程 API 所应包括的功能
<ul>
<li>创建（create）</li>
<li>销毁（destroy）
<ul>
<li>停止失控进程</li>
</ul></li>
<li>等待（wait）</li>
<li>其他控制（miscellaneous ccontrol）
<ul>
<li>暂停进程</li>
</ul></li>
<li>状态（status）</li>
</ul></li>
</ul>
<h2 id="进程创建更多细节">4.3 进程创建：更多细节</h2>
<h3 id="程序如何转化为进程">程序如何转化为进程</h3>
<ul>
<li>将代码和所有静态数据（例如初始化变量）从磁盘加载（load）到内存中
<ul>
<li>早期：尽快加载</li>
<li>现在：lazy</li>
</ul></li>
<li>必须为运行时栈（run-time stack）分配内存
<ul>
<li>C：用栈存放局部变量、函数参数和返回地址</li>
<li>操作系统也可能会用参数初始化栈，main() 函数的参数列表（2）</li>
</ul></li>
<li>可能为程序的堆（heap）分配一些内存
<ul>
<li>C：malloc() / free()</li>
</ul></li>
<li>执行一些其他初始化任务
<ul>
<li>I/O 相关
<ul>
<li>Unix 默认情况下每个进程都有3 个打开的文件描述符（file
descriptor），用于标准输入、输出和错误</li>
</ul></li>
</ul></li>
<li>启动程序</li>
</ul>
<h2 id="进程状态">4.4 进程状态</h2>
<ul>
<li>3 状态
<ul>
<li>运行（running）</li>
<li>就绪（ready）</li>
<li>阻塞（blocked）</li>
</ul></li>
</ul>
<p><img src="/2021/03/26/OS/OSTEP/04/image-20210326105918960.png" style="zoom: 67%;"></p>
<ul>
<li>可能还会有其他状态
<ul>
<li>初始（initial）：表示进程在创建时处于的状态</li>
<li>最终（final）：已退出但尚未清理的状态</li>
</ul></li>
</ul>
<h2 id="数据结构">4.5 数据结构</h2>
<ul>
<li>进程列表（process list）</li>
<li>保存机器状态
<ul>
<li>寄存器、内存（栈、堆）、打开文件列表</li>
</ul></li>
<li>保存进程信息
<ul>
<li>进程状态</li>
<li>进程号、父进程等等</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>OS.OSTEP</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>OSTEP 阅读笔记(Ch05.进程API)</title>
    <url>/2021/03/26/OS/OSTEP/05/</url>
    <content><![CDATA[<h1 id="第-5-章-插叙进程-api">第 5 章 插叙：进程 API</h1>
<ul>
<li>UNIX 系统中的进程 API</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fork();</span><br><span class="line">exec();</span><br><span class="line">wait();</span><br></pre></td></tr></table></figure>
<h2 id="fork">5.1 fork()</h2>
<ul>
<li>调用一次，返回两次
<ul>
<li>父进程返回子进程的 pid</li>
<li>子进程返回 0</li>
</ul></li>
<li>父进程和子进程的运行顺序是不确定的</li>
<li>由于CPU 调度程序非常复杂，所以我们不能假设哪个进程会先运行</li>
</ul>
<h2 id="wait">5.2 wait()</h2>
<ul>
<li>等待子进程运行结束后再运行
<ul>
<li>具体等待哪个子进程、几个子进程由调用参数决定</li>
</ul></li>
</ul>
<h2 id="exec">5.3 exec()</h2>
<ul>
<li>让子进程运行不一样的程序</li>
<li>调用一次，从不返回</li>
<li>没有创建新进程，而是直接将当前运行的程序替换为不同的运行程序</li>
<li>从可执行程序中加载代码和静态数据，并用它覆写自己的代码段（以及静态数据），重新初始化堆、栈及其他内存空间</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *myargs[<span class="number">3</span>];</span><br><span class="line">myargs[<span class="number">0</span>] = strdup(<span class="string">&quot;wc&quot;</span>);   <span class="comment">// program: &quot;wc&quot; (word count)</span></span><br><span class="line">myargs[<span class="number">1</span>] = strdup(<span class="string">&quot;p3.c&quot;</span>); <span class="comment">// argument: file to count</span></span><br><span class="line">myargs[<span class="number">2</span>] = <span class="literal">NULL</span>;           <span class="comment">// marks end of array</span></span><br><span class="line">execvp(myargs[<span class="number">0</span>], myargs);  <span class="comment">// runs word count</span></span><br></pre></td></tr></table></figure>
<h2 id="为什么这样设计-api">5.4 为什么这样设计 API</h2>
<ul>
<li>UNIX shell
<ul>
<li>给了shell 在 fork 之后 exec 之前运行代码的机会</li>
<li>这样可以改变运行时环境，实现有趣的功能</li>
</ul></li>
<li>重定向文件输出</li>
</ul>
<h2 id="其他-api">5.5 其他 API</h2>
<ul>
<li>kill()</li>
<li>信号（signal）、</li>
<li><strong>查看 man 手册获取更多知识</strong></li>
</ul>
<h2 id="作业">作业</h2>
<h4 id="section">(1)</h4>
<h4 id="section-1">(2)</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="comment">// 当关闭了标准输出之后, open 找到的第一个可用的文件描述符就是 1</span></span><br><span class="line">    <span class="comment">// 此时 printf 输出到 open 打开的文件里</span></span><br><span class="line">    close(STDOUT_FILENO);</span><br><span class="line">    open(<span class="string">&quot;2.txt&quot;</span>, O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork Error!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cccccc&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pppppp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子进程和父进程都能共访问 open()
返回的文件描述符，因为父子进程虽然i有自己的文件描述符列表，但是共享打开文件</li>
<li>父子进程同时写文件的时候不能保证谁先写入，我的 wsl 中结果为</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">ppppppcccccc</span><br></pre></td></tr></table></figure>
<h4 id="section-2">(3)</h4>
<h4 id="section-3">(4)</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv, <span class="type">char</span>** env)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork Error!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        <span class="type">char</span> *myargs[<span class="number">2</span>];</span><br><span class="line">        myargs[<span class="number">0</span>] = strdup(<span class="string">&quot;/bin/ls&quot;</span>);</span><br><span class="line">        myargs[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// execl(myargs[0], myargs[0], NULL);</span></span><br><span class="line">        <span class="comment">// execle(myargs[0], myargs[0], NULL, env);</span></span><br><span class="line">        <span class="comment">// execlp(&quot;ls&quot;, myargs[0], NULL);</span></span><br><span class="line">        execv(myargs[<span class="number">0</span>], myargs);</span><br><span class="line">        <span class="comment">// execve(myargs[0], myargs, env);</span></span><br><span class="line">        <span class="comment">// execvp(&quot;ls&quot;, myargs);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果确实可以执行 ls 命令，输出当前目录下的文件按</li>
<li>我的输出如下</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">2.c  2.out  2.txt  4.c  4.out</span><br></pre></td></tr></table></figure>
<ul>
<li>同样的基本调用，不同的封装方式为了满足不同的应用场景需要</li>
<li>区别如下
<ul>
<li>l：用参数列表的方式传递新程序的参数，最后一个参数需要显示的指定为
NULL</li>
<li>v：用数组的方式传递新程序的参数，数组最后一个值需要显示的指定为
NULL</li>
<li>e：设置新的环境变量，作为一个数组在最后一个参数传入</li>
<li>p：运行的可执行文件只需要传递文件名即可，否则需要传递全路径</li>
</ul></li>
</ul>
<h4 id="section-4">(5)</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv, <span class="type">char</span>** env)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork Error!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m child!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait&#x27;return pid: %d\n&quot;</span>, wait(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child&#x27;s pid: %d\n&quot;</span>, pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m father!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出如下</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">I&#x27;m child!</span><br><span class="line">wait&#x27;return pid: 323</span><br><span class="line">child&#x27;s pid: 323</span><br><span class="line">I&#x27;m father!</span><br></pre></td></tr></table></figure>
<ul>
<li><code>wait(NULL)</code> 返回等待的子进程的 pid</li>
<li>子进程使用 <code>wait(NULL)</code> 会返回 -1</li>
<li>使用 <code>man wait</code> 可以查看具体的含义
<ul>
<li><code>wait(NULL)</code> 操作当一个子进程结束的就会返回其 pid，等效于
<code>waitpid(-1, &amp;wstatus, 0)</code></li>
</ul></li>
</ul>
<h4 id="section-5">(6)</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv, <span class="type">char</span>** env)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork Error!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m child!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait&#x27;return pid: %d\n&quot;</span>, waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child&#x27;s pid: %d\n&quot;</span>, pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m father!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>wait(NULL)</code> 等价于
<code>waitpid(-1, NULL, 0)</code></li>
</ul>
<h4 id="section-6">(7)</h4>
<h4 id="section-7">(8)</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv, <span class="type">char</span>** env)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(pipe_fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Pipe Error!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork Error!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        dup2(pipe_fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m child!\n&quot;</span>);</span><br><span class="line">        close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent</span></span><br><span class="line">        <span class="type">char</span>* msg = <span class="literal">NULL</span>; <span class="comment">// 系统帮助 malloc, 要求 len 设置为 0</span></span><br><span class="line">        <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">        dup2(pipe_fd[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">        close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">        getline(&amp;msg, &amp;len, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m father!\nmessage from child: %s\n&quot;</span>, msg);</span><br><span class="line">        close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">free</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出如下</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">I&#x27;m father!</span><br><span class="line">message from child: I&#x27;m child!</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OS.OSTEP</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES202.闫令琪.01.课程介绍</title>
    <url>/2021/03/27/CG/YLQ-GAMES202/01/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1YK4y1T7yY</li>
<li>Introduction and Overview</li>
</ul>
<h1 id="高质量实时渲染">高质量实时渲染</h1>
<ul>
<li>Real-Time High Quality Rendering
<ul>
<li><strong>Real-Time</strong></li>
<li><strong>High Quality</strong></li>
<li><strong>Rendering</strong></li>
</ul></li>
</ul>
<h2 id="高质量实时渲染概念">高质量实时渲染概念</h2>
<h3 id="real-time">Real-Time</h3>
<ul>
<li>一般：30 FPS
<ul>
<li>frames per second</li>
</ul></li>
<li>虚拟现实 / 增强现实
<ul>
<li>Virtual / Augmented Reality</li>
<li>VR / AR</li>
<li><strong>90</strong> FPS</li>
</ul></li>
<li><strong>Interactivity</strong>：可以接受的交互速度
<ul>
<li>互动性</li>
<li>Each frame generated on the fly</li>
</ul></li>
</ul>
<h3 id="high-quality">High Quality</h3>
<ul>
<li>真实感
<ul>
<li>高额的计算代价</li>
<li>trade off：高质量，实时</li>
</ul></li>
<li>要求
<ul>
<li>渲染结果是正确的</li>
<li>近似正确的
<ul>
<li>可以接受</li>
</ul></li>
</ul></li>
</ul>
<h3 id="rendering">Rendering</h3>
<ul>
<li>渲染</li>
</ul>
<h2 id="话题">话题</h2>
<ul>
<li>实时阴影/环境光照
<ul>
<li>Shadows (and env)</li>
</ul></li>
<li>实时全局光照
<ul>
<li>Global Illum. (Scene/image space, precomputed)</li>
</ul></li>
<li>实时高质量着色
<ul>
<li>Physically based Shading</li>
</ul></li>
<li>实时光线追踪
<ul>
<li>Real-time ray tracing</li>
</ul></li>
<li>参与介质渲染
<ul>
<li>Participating Media Rendering</li>
</ul></li>
<li>非真实感渲染
<ul>
<li>Non-Photorealistic Rendering</li>
<li>艺术效果</li>
</ul></li>
<li>反走样与超采样
<ul>
<li>Antialiasing and supersampling</li>
<li>TAA：时间上的反走样</li>
<li>DLSS：深度学习方法超采样</li>
<li>TAAU</li>
</ul></li>
<li>游戏引擎
<ul>
<li>工程性的东西
<ul>
<li>原理在学术界比较简单</li>
<li>但是实现这样一个系统非常难</li>
</ul></li>
<li>实时渲染很大程度上是由游戏需求推动的</li>
</ul></li>
</ul>
<h2 id="不会涉及的内容">不会涉及的内容</h2>
<ul>
<li>建模与引擎使用</li>
<li>离线渲染</li>
<li>neural rendering
<ul>
<li>神经网络</li>
<li>做不到 high quality</li>
<li>做不到 real-time</li>
</ul></li>
<li>scene / shader 优化</li>
<li>shader 逆向工程</li>
<li>高性能计算</li>
</ul>
<h2 id="科学与技术">科学与技术</h2>
<ul>
<li>science != technology</li>
<li>Real-time rendering = fast &amp; approximate offline rendering +
systematic engineering
<ul>
<li>实时渲染 = 离线渲染的近似 + 系统的工程</li>
</ul></li>
<li>实时渲染的技术：工业界远高于学术界
<ul>
<li>例如游戏公司可能最早发现游戏渲染中存在的问题</li>
</ul></li>
</ul>
<h2 id="computer-graphics-is-awesome">Computer Graphics is AWESOME!</h2>
<h2 id="实时渲染的动机">实时渲染的动机</h2>
<ul>
<li>photorealistic images
<ul>
<li>照片级真实感</li>
</ul></li>
<li>离线渲染很慢</li>
<li>实时渲染做一些近似，得到可以接受的结果
<ul>
<li>With proper approximations, we can generate plausible results but
runs much faster</li>
</ul></li>
</ul>
<h2 id="实时渲染的发展史">实时渲染的发展史</h2>
<ul>
<li>Interactive 3D graphics <strong>pipeline</strong> as in
<strong>OpenGL</strong>
<ul>
<li>Earliest SGI machines (Clark 82) to today</li>
<li>Most of focus on <strong>more geometry</strong>, <strong>texture
mapping</strong></li>
<li>Some tweaks for realism (<strong>shadow mapping</strong>,
<strong>accum. buffer</strong>)</li>
</ul></li>
<li>20 years ago
<ul>
<li>Interactive 3D geometry with <strong>simple texture
mapping</strong>, <strong>fake shadows</strong> (OpenGL, DirectX)</li>
</ul></li>
<li>20 -&gt; 10 years ago
<ul>
<li>A <strong>giant leap</strong> since the emergence of
<strong>programmable shaders</strong> (2000)
<ul>
<li>可编程渲染管线被研究出来之后，得到了飞速的发展</li>
</ul></li>
<li><strong>Complex environment lighting</strong>, <strong>real
materials</strong> (velvet, satin, paints), <strong>soft
shadows</strong></li>
<li>游戏渲染中还存在的一些问题
<ul>
<li>dark：整个场景不够明亮</li>
<li>oily：油，高光部分不真实</li>
</ul></li>
</ul></li>
<li>Today
<ul>
<li>"Stunning graphics"</li>
<li>Extended to Virtual Reality (VR) and even <strong>movies</strong>
<ul>
<li>用实时渲染的技术去做原来要用离线渲染制作的电影</li>
</ul></li>
<li>可以看一些游戏引擎的宣传片</li>
</ul></li>
</ul>
<h2 id="重要技术">重要技术</h2>
<ul>
<li>Programmable graphics hardware (shaders) (20 years ago)
<ul>
<li>可编程渲染管线</li>
</ul></li>
</ul>
<p><img src="/2021/03/27/CG/YLQ-GAMES202/01/image-20210327134650411.png" style="zoom:50%;"></p>
<ul>
<li>Precomputation-based methods (15 years ago)
<ul>
<li>预先计算，复杂的计算在渲染之前</li>
<li>存储上的代价</li>
</ul></li>
<li>Interactive Ray Tracing (8-10 years ago: CUDA + OptiX)
<ul>
<li>交互级的光线追踪</li>
<li>Hardware development allows ray tracing on GPUs at low sampling
rates
<ul>
<li>(~1 samples per pixel (SPP))</li>
</ul></li>
<li>Followed by post processing to denoise</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES202</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES202.闫令琪.00.说明</title>
    <url>/2021/03/27/CG/YLQ-GAMES202/00/</url>
    <content><![CDATA[<ul>
<li>GAMES202：Real-Time High Quality Rendering
<ul>
<li>高质量实时渲染</li>
</ul></li>
<li><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games202.html">课程主页</a></li>
<li>授课老师：闫令琪</li>
<li>视频地址：<a href="https://www.bilibili.com/video/BV1YK4y1T7yY">B站</a></li>
<li>内容
<ul>
<li>实时阴影/环境光照
<ul>
<li>Shadows (and env)</li>
</ul></li>
<li>实时全局光照
<ul>
<li>Global Illum. (Scene/image space, precomputed)</li>
</ul></li>
<li>实时高质量着色
<ul>
<li>Physically based Shading</li>
</ul></li>
<li>实时光线追踪
<ul>
<li>Real-time ray tracing</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>0</category>
        <category>CG</category>
        <category>CG.GAMES202</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES202.闫令琪.02.基础知识</title>
    <url>/2021/03/27/CG/YLQ-GAMES202/02/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1YK4y1T7yY</li>
<li>Recap of CG Basics</li>
</ul>
<h1 id="基础知识回顾">基础知识回顾</h1>
<h2 id="硬件渲染管线">硬件渲染管线</h2>
<ul>
<li>Basic GPU hardware pipeline</li>
</ul>
<h3 id="管线">管线</h3>
<ul>
<li>vertex processing</li>
<li>triangle processing</li>
<li>rasterization</li>
<li>fragment processing</li>
<li>framebuffer operation</li>
</ul>
<h3 id="关键步骤">关键步骤</h3>
<ul>
<li>Model, View, Projection transforms</li>
<li>Sampling triangle coverage</li>
<li>Z-Buffer Visibility Tests</li>
<li>Shading
<ul>
<li>Blinn-Phong</li>
</ul></li>
<li>Texture mapping &amp; interpolation
<ul>
<li>重心坐标系</li>
</ul></li>
</ul>
<h3 id="其他问题">其他问题</h3>
<ul>
<li>纹理坐标的 <span class="math inline">\((u,v)\)</span>
是怎么参数化出来的？
<ul>
<li>立方体贴图的思维</li>
<li>通用的要求
<ul>
<li>纹理扭曲小</li>
<li>纹理映射到物体之后，每个部分的拉伸尽量相近</li>
</ul></li>
<li><strong>参数化问题</strong>
<ul>
<li>困难的几何问题</li>
</ul></li>
</ul></li>
</ul>
<h2 id="opengl">OpenGL</h2>
<ul>
<li>Is a set of APIs that call the GPU pipeline from CPU
<ul>
<li>一系列让 CPU 调用 GPU 的 API</li>
</ul></li>
<li>跨平台</li>
<li>其他的 API
<ul>
<li>DirectX
<ul>
<li>Windows</li>
</ul></li>
<li>Vulkan</li>
</ul></li>
<li>OpenGL 的问题
<ul>
<li>碎片化，版本更迭平缓，不同版本有不同的特性</li>
<li>C 风格，很难使用</li>
<li>早先不能 Debug</li>
</ul></li>
</ul>
<h3 id="opengl-的流程">OpenGL 的流程</h3>
<h4 id="一个类比画油画">一个类比（画油画）</h4>
<ul>
<li><strong>A. Place objects/models</strong>
<ul>
<li>放置物体 <span class="math inline">\(\leftrightarrow\)</span>
模型位置，模型属性，模型变换的指定</li>
</ul></li>
<li><strong>B. Set position of an easel</strong>
<ul>
<li>放置画架 <span class="math inline">\(\leftrightarrow\)</span>
确定相机（视图变换），使用具体的哪一个 framebuffer</li>
</ul></li>
<li><strong>C. Attach a canvas to the easel</strong>
<ul>
<li>固定一个画布 <span class="math inline">\(\leftrightarrow\)</span>
在一个 framebuffer 里面可以生成好几张纹理图</li>
<li>multiple rendering target：支持渲染多张纹理</li>
<li><strong>双缓冲技术</strong>：先将图片渲染好，没问题之后再将其显示在屏幕上
<ul>
<li>早期直接渲染到屏幕上会出现撕裂的问题（上一帧渲染到一半，下一帧就开始渲染了）</li>
<li>垂直同步打开：不会有撕裂的问题</li>
<li><strong>垂直同步</strong>
<ul>
<li>打开后能防止游戏画面高速移动时画面撕裂的现象</li>
<li>打开后如果你的游戏画面 FPS
数能达到或超过你显示器的刷新率，这时你的游戏画面 FPS
数被限制为你显示器的刷新率</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>D. Paint to the canvas</strong>
<ul>
<li>在画布上画画 <span class="math inline">\(\leftrightarrow\)</span>
shading（vertex/fragment shader），rasterization</li>
<li>vertex/fragment shader：<strong>并行</strong></li>
</ul></li>
<li><strong>E. (Attach other canvases to the easel and continue
painting)</strong>
<ul>
<li>换一张画布继续画 <span class="math inline">\(\leftrightarrow\)</span> 换一个 framebuffer
继续绘制</li>
</ul></li>
<li><strong>F. (Use previous paintings for reference)</strong>
<ul>
<li><span class="math inline">\(\leftrightarrow\)</span> Multiple
passes，使用之前渲染得到的结果（纹理）</li>
</ul></li>
</ul>
<h4 id="opengl-做的事">OpenGL 做的事</h4>
<ul>
<li>in each pass
<ul>
<li>Specify objects, camera, MVP, etc.</li>
<li>Specify framebuffer and input/output textures</li>
<li>Specify vertex / fragment shaders</li>
<li>(When you have everything specified on the GPU) Render!</li>
</ul></li>
</ul>
<h2 id="opengl-shading-language-glsl">OpenGL Shading Language
(GLSL)</h2>
<ul>
<li>描述着色器怎么运作的</li>
<li>比较像 C 语言</li>
<li>有很长的历史
<ul>
<li>早期：GPU 上写汇编语言</li>
<li>SGI 时期：Stanford Real-Time Shading Language</li>
<li>Still long ago：Cg from NVIDIA</li>
<li><strong>HLSL</strong> in <strong>DirectX</strong>
(<strong>vertex</strong> + <strong>pixel</strong>)</li>
<li><strong>GLSL</strong> in <strong>OpenGL</strong>
(<strong>vertex</strong> + <strong>fragment</strong>)</li>
</ul></li>
<li>最终还是编译成汇编语言的</li>
</ul>
<h3 id="使用-shader">使用 shader</h3>
<ul>
<li>Create shader (Vertex and Fragment)</li>
<li><strong>Compile</strong> shader</li>
<li>Attach shader to <strong>program</strong></li>
<li><strong>Link</strong> program</li>
<li><strong>Use program</strong></li>
</ul>
<h3 id="一些关键字">一些关键字</h3>
<ul>
<li>attribute：顶点属性</li>
<li>uniform：全局变量（CPU直接送过去）</li>
<li>varying：变量
<ul>
<li>vertex shader 中为插值前的顶点值</li>
<li>fragment shader 中为插值后的片元值</li>
</ul></li>
<li>sample2D：采样器（纹理）</li>
<li>highp：表示高精度</li>
</ul>
<h3 id="debugging-shaders">Debugging Shaders</h3>
<ul>
<li>早期：NVIDIA Nsight with Visual Studio
<ul>
<li>Needed multiple GPUs for debugging GLSL
<ul>
<li>GLSL：多 GPU 才行</li>
</ul></li>
<li>Had to run in software simulation mode in HLSL
<ul>
<li>HLSL：软件模拟</li>
</ul></li>
</ul></li>
<li>现在
<ul>
<li>Nsight Graphics (cross platform, NVIDIA GPUs only)
<ul>
<li>和 visual studio 分开的，跨平台</li>
</ul></li>
<li>RenderDoc (cross platform, no limitations on GPUs)
<ul>
<li>软件，对 GPU 类型没有要求</li>
</ul></li>
</ul></li>
</ul>
<h4 id="经验">经验</h4>
<ul>
<li>RGB 调试法
<ul>
<li>想要输出一个值，可以把它作为颜色在屏幕中显示出来</li>
<li>利用软件提取出颜色即可</li>
</ul></li>
</ul>
<h2 id="渲染方程">渲染方程</h2>
<ul>
<li>The Rendering Equation</li>
</ul>
<p><span class="math display">\[
L_o(p,\omega_o)=
L_e(p,\omega_o)
+\int_{H^2}f_r(p,\omega_i\to\omega_o)L_i(p,\omega_i)V(p,\omega_i)\cos\theta_id\omega_i
\]</span></p>
<ul>
<li>outging radiance = emission + <span class="math inline">\(\sum\)</span> BRDF x incident radiance x
visibility
<ul>
<li>是否把 <span class="math inline">\(\cos\theta_i\)</span> 这一项合入
BRDF
<ul>
<li>BRDF</li>
<li>cosine-weighted BRDF</li>
</ul></li>
</ul></li>
<li>实时渲染的理解：显式考虑 visibility</li>
<li>环境光照：Environment Lighting
<ul>
<li>cube map</li>
<li>circle map</li>
</ul></li>
<li>全局光照 = 直接光照 + 间接光照
<ul>
<li>直接光照：direct illumination</li>
<li>间接光照：indirect illumination
<ul>
<li>one-bounce</li>
<li>two-bounce</li>
<li><span class="math inline">\(\cdots\)</span></li>
</ul></li>
</ul></li>
<li>实时渲染的理论基础
<ul>
<li>one-bounce 之后效果就好了很多，之后的添加只是在细节上更好</li>
<li>实时渲染主要就是模拟 one-bounce 的间接光照</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES202</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES202.闫令琪.03.实时阴影(1)</title>
    <url>/2021/04/02/CG/YLQ-GAMES202/03/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1YK4y1T7yY</li>
</ul>
<h1 id="real-time-shadows">Real-Time Shadows</h1>
<ul>
<li>实时阴影</li>
</ul>
<h2 id="shadow-mapping">Shadow Mapping</h2>
<ul>
<li>SM</li>
<li>经典的两趟算法
<ul>
<li>2-pass</li>
</ul></li>
</ul>
<h3 id="算法步骤">算法步骤</h3>
<ul>
<li>第一遍渲染，转换到以光源为视点的观察坐标系，记录下深度图</li>
<li>第二遍正常渲染，对每个点，转换到以光源为视点的观察坐标系中判断可见性
<ul>
<li>判断可见性的时候深度一致即可，可以使用原来的线性距离或者投影之后的 z
值</li>
</ul></li>
</ul>
<h3 id="评价">评价</h3>
<ul>
<li>图像空间的算法</li>
</ul>
<h4 id="优点">优点</h4>
<ul>
<li>绘制阴影的时候，不需要知道场景的几何信息</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>artifacts
<ul>
<li>self occlusion 自遮挡</li>
<li>aliasing 走样</li>
</ul></li>
</ul>
<h3 id="自遮挡问题">自遮挡问题</h3>
<ul>
<li>self occlusion</li>
</ul>
<p><img src="/2021/04/02/CG/YLQ-GAMES202/03/image-20210407160110616.png" style="zoom: 33%;"></p>
<ul>
<li>地板上的平面出现了自遮挡现象</li>
<li>由于数值精度造成的（分辨率）
<ul>
<li>shadow map 精度有限，投射出去就是图中的红色小片</li>
<li>例如蓝色的视线应该是能看到红色的部分的，但是由于精度问题，shadow map
中记录的是橙色的值，导致我们判断红色部分不可见，从而产生自遮挡现象</li>
</ul></li>
</ul>
<p><img src="/2021/04/02/CG/YLQ-GAMES202/03/image-20210407160246926.png" style="zoom:67%;"></p>
<ul>
<li>如果光线和物体表面垂直，此时没有这个问题
<ul>
<li>光线和法线重合</li>
</ul></li>
<li>如果光线和物体表面成一个很小的角度时，自遮挡问题很严重
<ul>
<li>光线和法线夹角很大</li>
<li>grazing angle</li>
</ul></li>
</ul>
<h4 id="解决方案">解决方案</h4>
<ul>
<li>增加一个 bias</li>
<li>中间的黄色那段我们不算
<ul>
<li>也就是说我们对计算得到的深度减去一个 bias</li>
</ul></li>
</ul>
<p><img src="/2021/04/02/CG/YLQ-GAMES202/03/image-20210407161249651.png" style="zoom:50%;"></p>
<ul>
<li>一些技巧：动态的 bias
<ul>
<li>当光线和物体表面法线夹角比较大时，bias 也需要比较大</li>
<li>当光线和物体表面法线夹角比较小时，bias 比较小即可</li>
</ul></li>
</ul>
<h4 id="引入-bias-带来的问题">引入 bias 带来的问题</h4>
<ul>
<li>detached shadow
<ul>
<li>不接触的阴影</li>
</ul></li>
<li>鞋子部分的阴影消失了</li>
</ul>
<p><img src="/2021/04/02/CG/YLQ-GAMES202/03/image-20210407161700013.png" style="zoom: 33%;"></p>
<ul>
<li>工业界 100% 解决这个问题的方法现在还没有
<ul>
<li>解决方法还是通过找一个合适的 bias，让自遮挡和detached shadow
都不出现</li>
<li>最简单的方式</li>
</ul></li>
<li>学术界的方法（工业界用的人少）
<ul>
<li>second-depth shadow mapping</li>
</ul></li>
</ul>
<h4 id="second-depth-shadow-mapping">second-depth shadow mapping</h4>
<ul>
<li>不使用 bias</li>
<li>记录最小深度的同时，还记录第二小的深度</li>
<li>实际比较的时候使用这两个深度的平均值
<ul>
<li>能够解决之前的问题</li>
</ul></li>
</ul>
<p><img src="/2021/04/02/CG/YLQ-GAMES202/03/image-20210407163438738.png" style="zoom:50%;"></p>
<ul>
<li>这个方法的问题
<ul>
<li>每个物体都得是一个几何实体
<ul>
<li>不能是一张平面，如果是一张纸的话，得描述成一个很扁的长方体</li>
</ul></li>
<li>实现这个算法很困难，复杂度没有变化，但是无法并行</li>
</ul></li>
<li>一些 trick
<ul>
<li>如果是<strong>最外层</strong>的地板，在做第一趟渲染深度图的时候不渲染地板</li>
</ul></li>
<li>实时渲染不相信复杂度，只相信实时运行的速度
<ul>
<li>RTR does not trust in COMPLEXITY</li>
<li>常数也很重要</li>
</ul></li>
</ul>
<h3 id="走样问题">走样问题</h3>
<ul>
<li>阴影分辨率的问题</li>
<li>高端的做法
<ul>
<li>给不同位置不同的分辨率</li>
</ul></li>
<li>软影</li>
</ul>
<h2 id="sm-的数学原理">SM 的数学原理</h2>
<h3 id="常用不等式">常用不等式</h3>
<ul>
<li>Schwarz Inequality
<ul>
<li>施瓦茨不等式</li>
</ul></li>
</ul>
<p><span class="math display">\[
\left[\int_a^bf(x)g(x)dx\right]^2\le\int_a^bf^2(x)dx\cdot
\int_a^bg^2(x)dx
\]</span></p>
<ul>
<li>Minkowski Inequality
<ul>
<li>明可夫斯基不等式</li>
</ul></li>
</ul>
<p><span class="math display">\[
\left[\int_a^b\left[f(x)+g(x)\right]^2dx\right]^{\frac{1}{2}}\le\left[\int_a^bf^2(x)dx\right]^{\frac{1}{2}}\cdot
\left[\int_a^bg^2(x)dx\right]^{\frac{1}{2}}
\]</span></p>
<ul>
<li>实时渲染中我们关心<strong>约等</strong>，而不是<strong>不等</strong>
<ul>
<li>在近似条件下<strong>约等</strong></li>
</ul></li>
</ul>
<h3 id="rtr-中的一个常用近似">RTR 中的一个常用近似</h3>
<p><span class="math display">\[
{\color{red}\int_\Omega f(x)g(x)dx\approx \dfrac{\int_\Omega
f(x)dx}{\int_\Omega dx}\cdot {\int_\Omega g(x)dx}}
\]</span></p>
<ul>
<li>分母的部分表示归一化常数
<ul>
<li>例如 <span class="math inline">\(f(x)=2\)</span></li>
</ul></li>
<li>什么时候近似正确呢？（满足一个条件即可）
<ul>
<li>small support
<ul>
<li><span class="math inline">\(g(x)\)</span> 的积分域很小的时候</li>
</ul></li>
<li>smooth integrand
<ul>
<li><span class="math inline">\(g(x)\)</span> 在积分域内变化不大</li>
<li>图形学学术界中的 smooth：min、max 差别不大</li>
</ul></li>
</ul></li>
</ul>
<h4 id="应用于渲染方程">应用于渲染方程</h4>
<ul>
<li>忽略自发光</li>
</ul>
<p><span class="math display">\[
L_o(p,\omega_o)=
\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)V(p,\omega_i)\cos\theta_id\omega_i
\]</span></p>
<ul>
<li>利用上面的近似</li>
</ul>
<p><span class="math display">\[
L_o(p,\omega_o)\approx
\dfrac{\int_{\Omega^+}V(p,\omega_i)d\omega_i}{\int_{\Omega^+}d\omega_i}\cdot\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)\cos\theta_id\omega_i
\]</span></p>
<ul>
<li>这样子的近似把可见性从 shading 部分抽离出来了
<ul>
<li>我们做 shadow mapping 方法的原理</li>
</ul></li>
</ul>
<h4 id="shadow-mapping-的原理">shadow mapping 的原理</h4>
<ul>
<li>什么时候是准确的？</li>
<li>small support
<ul>
<li>积分范围只有一个点 <span class="math inline">\(\to\)</span>
点光源、方向光源</li>
<li>做硬阴影的数学基础</li>
</ul></li>
<li>smooth integrand
<ul>
<li>diffuse bsdf / constant radiance area lighting</li>
<li>diffuse BSDF + 面光源</li>
<li>解释 shadow mapping 算法不适合的场景
<ul>
<li>环境光照（可以理解为超级大的面光源）+ glossy BRDF</li>
</ul></li>
</ul></li>
</ul>
<h2 id="pcss">PCSS</h2>
<ul>
<li>Percentage Closer Soft Shadows</li>
<li>生成软阴影的一种算法</li>
</ul>
<h3 id="软阴影">软阴影</h3>
<p><img src="/2021/04/02/CG/YLQ-GAMES202/03/image-20210407171749439.png"></p>
<ul>
<li>生活中的现象：太阳
<ul>
<li>半影</li>
</ul></li>
</ul>
<p><img src="/2021/04/02/CG/YLQ-GAMES202/03/image-20210407172053852.png" style="zoom:67%;"></p>
<h3 id="pcf">PCF</h3>
<ul>
<li>Percentage Closer Filtering</li>
<li>这个技术是用于于抗锯齿的，而不是用于生成软阴影的（PCSS
是用于生成软阴影的）</li>
<li>Filtering the results of shadow comparisons
<ul>
<li>先采样，后做平均（filter）</li>
</ul></li>
<li>为什么不能先对 SM 做 filter，后采样？
<ul>
<li>Texture filtering just averages color components, i.e. you’ll get
blurred shadow map first</li>
<li>Averaging depth values, then comparing, you still get a binary
visibility</li>
<li>这样的操作最后得到的结果还是非 0 即 1 的，没有意义</li>
</ul></li>
<li>原来判断一个点的可见性是直接做一次判断
<ul>
<li>shading point 和在深度图中对应位置记录的深度值作比较</li>
</ul></li>
<li>PCF 的想法是对其周围的几个点都做阴影判断，最后把得到的结果平均起来
<ul>
<li>shading point 和在深度图中对应位置周围的几个点的深度作比较</li>
<li>最后得到的可见性是一个 0 - 1 之间的值</li>
<li><strong>可以加权</strong></li>
</ul></li>
</ul>
<p><img src="/2021/04/02/CG/YLQ-GAMES202/03/image-20210407173321583.png" style="zoom:50%;"></p>
<ul>
<li>PCF 的结果</li>
</ul>
<p><img src="/2021/04/02/CG/YLQ-GAMES202/03/image-20210407173924706.png"></p>
<ul>
<li>时间开销：变成原来的 k 倍（k 为核的大小）</li>
<li>filter size
<ul>
<li>small：sharper</li>
<li>large：softer</li>
<li>决定分辨率，核越大，量化越细</li>
</ul></li>
<li>核的大小应该怎么确定？</li>
<li>核的大小决定了阴影的软硬程度，根据阴影的软硬需求动态调整核的大小</li>
</ul>
<h3 id="pcss-1">PCSS</h3>
<ul>
<li>PCF 的思想，动态调整核的大小</li>
<li>什么地方需要硬阴影，什么地方需要硬阴影？</li>
<li><strong>遮挡物和阴影的距离</strong>
<ul>
<li>距离越大，阴影越软</li>
<li>距离越小，阴影越硬</li>
</ul></li>
</ul>
<p><img src="/2021/04/02/CG/YLQ-GAMES202/03/image-20210407175007126.png" style="zoom:50%;"></p>
<ul>
<li>根据上面的启发，定义一个距离函数，通过这个距离函数计算核的大小
<ul>
<li>Filter size &lt;-&gt; blocker distance</li>
<li>More accurately, <strong>relative</strong> <strong>average</strong>
projected blocker depth!</li>
</ul></li>
</ul>
<p><img src="/2021/04/02/CG/YLQ-GAMES202/03/image-20210407175256445.png" style="zoom: 40%;"></p>
<ul>
<li>根据相似三角形
<ul>
<li>penumbra：半影</li>
</ul></li>
</ul>
<p><span class="math display">\[
w_{penumbra}=\dfrac{d_{Receiver}-d_{Blocker}}{d_{Blocker}}\cdot
w_{Light}
\]</span></p>
<ul>
<li>这个式子也符合我们生活中的观察
<ul>
<li>Blocker 离 Receiver 越近，那么阴影越硬（<span class="math inline">\(w_{penumbra}\)</span> 越小）</li>
</ul></li>
<li><span class="math inline">\(d_{Blocker}\)</span>：average blocker
depth
<ul>
<li>blocker 可能并不是一个点，有一定的范围，计算他们的平均值</li>
<li>看 SM 中对应位置有多少个点能挡住 shading point，求他们的平均值</li>
</ul></li>
<li>面光源本身是没法生成一个 SM
的，我们模拟面光源的软阴影，用一个点光源代替它生成一个 SM</li>
</ul>
<h4 id="pcss-流程">PCSS 流程</h4>
<ul>
<li>Step 1: Blocker search
<ul>
<li>getting the average blocker depth in a <strong>certain
region</strong></li>
<li>将这些点在 SM 中的深度值和我们计算出来的深度值作比较
<ul>
<li>感觉这个时候还是当作点光源操作</li>
</ul></li>
<li>考虑的是平均的 blocker 的深度，如果不是 blocker 则不管这个像素</li>
</ul></li>
<li>Step 2: Penumbra estimation
<ul>
<li>use the average blocker depth to determine <strong>filter
size</strong></li>
</ul></li>
<li>Step 3: Percentage Closer Filtering</li>
</ul>
<h4 id="问题">问题</h4>
<ul>
<li>怎么决定第一步搜索 blocker 的范围</li>
<li>可以设置为一个常数，例如 5x5</li>
<li>可以通过启发式计算出搜索范围</li>
</ul>
<p><img src="/2021/04/02/CG/YLQ-GAMES202/03/image-20210407181810295.png" style="zoom:40%;"></p>
<ul>
<li>比较慢，时间开销大</li>
</ul>
<h2 id="其他">其他</h2>
<ul>
<li>多光源，如果利用 SM，需要对每个光源计算一个 SM</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES202</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES202.闫令琪.04.实时阴影(2)</title>
    <url>/2021/04/10/CG/YLQ-GAMES202/04/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1YK4y1T7yY</li>
</ul>
<h1 id="实时阴影">实时阴影</h1>
<h2 id="pcfpcss">PCF/PCSS</h2>
<h3 id="背后的数学">背后的数学</h3>
<h4 id="pcf">PCF</h4>
<ul>
<li>filter/convolution</li>
<li>卷积</li>
</ul>
<p><span class="math display">\[
[w\ast f](p)=\sum_{q\in \mathcal{N}(p)}w(p,q)f(q)
\]</span></p>
<h4 id="pcss">PCSS</h4>
<p><span class="math display">\[
V(x)=\sum_{q\in \mathcal{N}(p)}w(p,q)\cdot\chi^+[D_{SM}(q)-D_{scene}(x)]
\]</span></p>
<ul>
<li><span class="math inline">\(\chi^+(x)\)</span>
<ul>
<li><span class="math inline">\(1,x\ge0\)</span></li>
<li><span class="math inline">\(0,x&lt;0\)</span></li>
</ul></li>
<li>PCF 并不是对 SM 进行模糊</li>
</ul>
<p><span class="math display">\[
V(x)\ne\chi^+\{[w\ast D_{SM}](x)-D_{scene}(x)\}
\]</span></p>
<ul>
<li>PCF 也不是在图像空间（结果图）上做 filter
<ul>
<li>二值的结果图（也就是经典 SM 做出来的阴影效果）</li>
</ul></li>
</ul>
<p><span class="math display">\[
V(x)\ne \sum_{y\in\mathcal{N}(x)}w(x,y)V(y)
\]</span></p>
<h3 id="pcss-的步骤">PCSS 的步骤</h3>
<ul>
<li>Step 1: Blocker search
<ul>
<li>在某个区域内计算平均遮挡深度</li>
</ul></li>
<li>Step 2: Penumbra estimation
<ul>
<li>通过计算出来的平均遮挡深度来计算半影（penumbra）的大小</li>
</ul></li>
<li>Step 3: Percentage Closer Filtering
<ul>
<li>根据 Step 2 计算出来的大小进行 PCF</li>
</ul></li>
</ul>
<h4 id="限速步">限速步</h4>
<ul>
<li>Step 1，Step 3
<ul>
<li>采样会比较慢</li>
<li>Softer -&gt; larger filtering region -&gt; slower</li>
</ul></li>
<li>两种方式
<ul>
<li>对区域内的每一个像素采样</li>
<li>对区域内的像素进行随机采样
<ul>
<li>稀疏采样会引起噪声</li>
<li>处理噪声的方法：图像空间降噪，时间维度降噪
<ul>
<li>低通滤波回式低频噪声通过，帧间闪烁现象变成 boiling
artifact（沸腾的现象）</li>
</ul></li>
<li>flicker：如果每一帧取得随机数不一样，会引起帧间闪烁的问题</li>
</ul></li>
</ul></li>
<li>针对很慢的方法，提出了 Variance Shadow Mapping</li>
</ul>
<h2 id="vssm-vsm">VSSM / VSM</h2>
<ul>
<li>Variance Soft Shadow Mapping</li>
<li>针对性地解决 PCSS 在第一步、第三步慢的问题</li>
</ul>
<h3 id="pcf-步骤step-3">PCF 步骤(Step 3)</h3>
<ul>
<li>假设均值滤波
<ul>
<li>等价于想要知道在指定范围内有百分之多少的 texel 是在 shading point
之前</li>
<li>等价于在指定范围内找出有多少的 texel 深度值比 shading point
要小</li>
<li>等价于想知道当前像素在指定范围内，深度排到第几（百分之几）</li>
</ul></li>
<li>如果知道指定区域的分布，那么就容易得到结果</li>
<li>如果不需要那么准确，知道直方图也能得到结果</li>
<li>假定是正态分布，也能得到结果（相对更加不准）</li>
<li>怎么定义一个正态分布：均值、方差</li>
</ul>
<h4 id="key-idea">key idea</h4>
<ul>
<li>快速求出某个区域内的<strong>均值</strong>和<strong>方差</strong></li>
<li>mean + variance</li>
</ul>
<h5 id="均值">均值</h5>
<ul>
<li>MipMap：不准确，只能求正方形</li>
<li>Summed Area Tables（SAT）</li>
</ul>
<h5 id="方差">方差</h5>
<p><span class="math display">\[
Var(X)=E(X^2)-E^2(X)
\]</span></p>
<ul>
<li>计算两个均值即可
<ul>
<li>存两张图</li>
</ul></li>
<li>怎么在 OpenGL 中实现
<ul>
<li>4 通道，一个通道存 <span class="math inline">\(SM\
(depth)\)</span>，一个通道保存 <span class="math inline">\(SM^2\
(depth^2)\)</span></li>
</ul></li>
</ul>
<h5 id="计算百分之几">计算百分之几</h5>
<ul>
<li>CDF：求出阴影面积</li>
</ul>
<p><img src="/2021/04/10/CG/YLQ-GAMES202/04/image-20210411002207326.png" style="zoom:70%;"></p>
<ul>
<li>具体实现求积分：<strong>打表</strong></li>
<li>误差函数：error function</li>
<li>c++ 中有函数 <code>erf()</code>
<ul>
<li>有数值解，没有解析解</li>
</ul></li>
</ul>
<h5 id="切比雪夫不等式估计">切比雪夫不等式估计</h5>
<ul>
<li>Chebychev’s inequality</li>
</ul>
<p><span class="math display">\[
P(x&gt;t)\le\dfrac{\sigma^2}{\sigma^2+(t-\mu)^2}
\]</span></p>
<ul>
<li>背后假设是单峰的分布
<ul>
<li>具体得去看证明过程</li>
</ul></li>
</ul>
<p><img src="/2021/04/10/CG/YLQ-GAMES202/04/image-20210411002838515.png" style="zoom:50%;"></p>
<ul>
<li>我们在渲染中直接作为约等号（约等式）</li>
<li>对于 <span class="math inline">\(t\ge\mu\)</span> 效果还是不错的
<ul>
<li>否则估计不准确</li>
</ul></li>
</ul>
<h4 id="评价">评价</h4>
<ul>
<li>VSSM 在查询的时候是 O(1)
的（很快），但是在生成的时候需要有些开销</li>
<li>生成 Mipmap 是硬件支持的，生成非常快</li>
<li>生成 SAT 相对较慢</li>
<li>现在解决了 PCSS 中的<strong>第三步</strong>的问题</li>
</ul>
<h3 id="第一步的问题step-1">第一步的问题(Step 1)</h3>
<ul>
<li>blocker search</li>
<li>求出<strong>遮挡物</strong>的平均深度，而不是<strong>区域</strong>内的平均深度
<ul>
<li>区域内的平均深度是知道的</li>
</ul></li>
</ul>
<h4 id="定义基础量">定义基础量</h4>
<ul>
<li>区域内的平均深度：<span class="math inline">\(z_{avg}\)</span></li>
<li>blocker 的平均深度<span class="math inline">\((z&lt;t)\)</span>：<span class="math inline">\(avg.z_{ooc}\)</span>
<ul>
<li>待求的量</li>
</ul></li>
<li>non-blocker 的平均深度<span class="math inline">\((z&gt;t)\)</span>：<span class="math inline">\(avg.z_{unooc}\)</span></li>
</ul>
<h4 id="key-idea-1">key idea</h4>
<ul>
<li>满足如下的关系</li>
</ul>
<p><span class="math display">\[
\dfrac{N_1}{N}z_{unooc}+\dfrac{N_2}{N}z_{ooc}=z_{avg}
\]</span></p>
<ul>
<li><span class="math inline">\(\dfrac{N_1}{N}\)</span>
可以通过切比雪夫不等式估计</li>
<li><span class="math inline">\(\dfrac{N_2}{N}=1-\dfrac{N_1}{N}\)</span></li>
<li>假设 <span class="math inline">\(z_{unooc}=t\)</span>
<ul>
<li>非遮挡物的深度和当前的深度相似</li>
<li><strong>基于绝大多数阴影的接收者是一个平面</strong>
<ul>
<li>这种假设还是有问题的
<ul>
<li>接受平面是曲面</li>
<li>接受平面和光线平行</li>
</ul></li>
</ul></li>
</ul></li>
<li><span class="math inline">\(z_{avg}\)</span>
可以通过范围查询得到</li>
</ul>
<h3 id="vssm-效果">VSSM 效果</h3>
<ul>
<li>https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch08.html</li>
</ul>
<p><img src="/2021/04/10/CG/YLQ-GAMES202/04/image-20210411004730398.png"></p>
<h3 id="现状">现状</h3>
<ul>
<li>人们会更多使用 PCSS 来做阴影</li>
<li>人们对于噪声的容忍度很高
<ul>
<li>图像空间降噪做得很好</li>
<li>尤其是结合时间维度之后</li>
</ul></li>
</ul>
<h3 id="mipmap-sat">MipMap / SAT</h3>
<ul>
<li>快速范围查询</li>
</ul>
<h4 id="mipmap">MipMap</h4>
<ul>
<li>fast、approx、square</li>
<li>涉及到插值
<ul>
<li>层内插值（线性插值）</li>
<li>层间插值（三线性插值）</li>
<li>插值会引发不准确</li>
</ul></li>
<li>正方形查询都会不准，对于矩形无法解决
<ul>
<li>各向异性过滤可以查询矩形</li>
</ul></li>
<li>在软阴影范围比较小的情况下还是表现不错的</li>
</ul>
<h4 id="sat">SAT</h4>
<ul>
<li>summed area table</li>
<li>范围内元素平均和范围内元素综合是等价的（知道范围大小）</li>
</ul>
<h5 id="一维数组">一维数组</h5>
<ul>
<li><strong>前缀和</strong></li>
<li>任意范围内的和可以通过两个前缀和相减得到</li>
<li>前缀和可以通过动态规划方法很快得到 <span class="math inline">\(O(n)\)</span></li>
</ul>
<p><img src="/2021/04/10/CG/YLQ-GAMES202/04/image-20210411005854571.png" style="zoom:67%;"></p>
<h5 id="二维数组">二维数组</h5>
<ul>
<li>忽略下图中的坐标系箭头，应该是左上角为原点才能和范围匹配</li>
</ul>
<p><img src="/2021/04/10/CG/YLQ-GAMES202/04/image-20210411010824972.png" style="zoom:50%;"></p>
<ul>
<li>动态规划，<span class="math inline">\(dp[i][j]\)</span> 记录范围
<span class="math inline">\((0,0),(i,j)\)</span> 矩形内的面积</li>
</ul>
<p><span class="math display">\[
S \left((a,b),(c,d)\right)=dp[c][d]-dp[c][b]-dp[a][d]+dp[a][b]
\]</span></p>
<ul>
<li>建表
<ul>
<li>每行做一遍，每列做一遍</li>
<li>复杂度 <span class="math inline">\(O(mn)\)</span>
<ul>
<li>并行 <span class="math inline">\(O(m+n)\)</span></li>
</ul></li>
</ul></li>
<li>数值精度溢出问题：有可能（double 损失精度）</li>
</ul>
<h2 id="msm">MSM</h2>
<ul>
<li>Moment Shadow Mapping</li>
</ul>
<h3 id="vssm-的问题">VSSM 的问题</h3>
<h4 id="单峰假设不准">单峰假设不准</h4>
<ul>
<li>正态分布的假设可能不成立</li>
<li>带来的问题：计算出来的百分比不准确</li>
</ul>
<p><img src="/2021/04/10/CG/YLQ-GAMES202/04/image-20210411011808699.png" style="zoom: 67%;"></p>
<ul>
<li>问题
<ul>
<li>偏黑：问题不大，结果可以忍受</li>
<li>偏亮：问题很大（LIGHT LEAKING）</li>
</ul></li>
<li>下图表示偏亮</li>
</ul>
<p><img src="/2021/04/10/CG/YLQ-GAMES202/04/image-20210411012025564.png" style="zoom:50%;"></p>
<ul>
<li>下图表示偏亮带来的问题
<ul>
<li>镂空车车底问题</li>
<li>https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch08.html</li>
</ul></li>
</ul>
<p><img src="/2021/04/10/CG/YLQ-GAMES202/04/image-20210411012147457.png"></p>
<h4 id="接受面不是平面">接受面不是平面</h4>
<ul>
<li>接收面不是平面导致假设出问题</li>
</ul>
<h4 id="切比雪夫不等式问题">切比雪夫不等式问题</h4>
<ul>
<li><span class="math inline">\(t\ge\mu\)</span></li>
</ul>
<h3 id="msm-解决的问题">MSM 解决的问题</h3>
<ul>
<li><strong>更精准的模拟分布</strong></li>
<li>高阶矩（moment）描述分布
<ul>
<li>VSSM 只使用了 <span class="math inline">\(X,X^2\)</span></li>
</ul></li>
<li>保留更多阶的矩，描述的分布更准确
<ul>
<li>只给结论，过程复杂</li>
<li>简单来说就是某种展开，保留更多的项，结果更加准确</li>
</ul></li>
<li>first <span class="math inline">\(m\)</span> orders of moments can
represent a function with <span class="math inline">\(\dfrac{m}{2}\)</span> steps</li>
</ul>
<p><img src="/2021/04/10/CG/YLQ-GAMES202/04/image-20210411012724712.png" style="zoom:50%;"></p>
<ul>
<li>通常而言，4 阶矩效果就很好了
<ul>
<li>越多，存储开销越大</li>
<li>存储上工业界常用的方法：packing/unpacking
<ul>
<li>多个通道表示一个数</li>
<li>一个数表示多个通道</li>
<li>这样做的结果是不能<strong>直接</strong>插值的</li>
</ul></li>
</ul></li>
<li>怎么通过这些高阶矩计算出需要的值
<ul>
<li>论文：[Peters et al., Moment Shadow Mapping]</li>
</ul></li>
</ul>
<h3 id="效果">效果</h3>
<ul>
<li>解决了 light leaking 问题</li>
</ul>
<p><img src="/2021/04/10/CG/YLQ-GAMES202/04/image-20210411013329525.png" style="zoom:50%;"></p>
<h2 id="dfss">DFSS</h2>
<ul>
<li>Distance field soft shadows</li>
<li>生成软阴影</li>
</ul>
<h3 id="signed-distance-function">(Signed) Distance Function</h3>
<ul>
<li>（有向）距离场</li>
<li>At any point, giving the minimum distance (could be signed distance)
to the closest location on an object</li>
<li>对于任意一个点，定义到到物体表面的最近距离
<ul>
<li>可以带符号</li>
<li>负号表示在物体内部</li>
</ul></li>
<li>SDF：Signed Distance Function</li>
<li>GAMES101 中的例子：blend 一个边界
<ul>
<li>第一行是线性插值</li>
<li>第二行是使用 SDF 进行插值</li>
</ul></li>
</ul>
<p><img src="/2021/04/10/CG/YLQ-GAMES202/04/image-20210411142439398.png" style="zoom:50%;"></p>
<ul>
<li>SDF 能在几何上产生非常好的过渡</li>
<li>SDF 理论基础
<ul>
<li>最优传输理论（optimal transport）</li>
<li>顾险峰</li>
</ul></li>
</ul>
<h3 id="距离场的使用">距离场的使用</h3>
<h4 id="ray-marching">ray marching</h4>
<ul>
<li>https://docs.unrealengine.com/en-US/BuildingWorlds/LightingAndShadows/MeshDistanceFields/index.html</li>
<li>用于光线和物体求交</li>
</ul>
<p><img src="/2021/04/10/CG/YLQ-GAMES202/04/image-20210411143347944.png"></p>
<ul>
<li>SDF 提供了一个<strong>安全距离</strong>
<ul>
<li>对于一个点 x，SDF(x) 表示在一个半径为 SDF(x) 的距离之内没有物体</li>
<li>也就是说光线前进 SDF(x) 这么长的路程，一定不会打到物体上</li>
</ul></li>
<li>也就是说，光线每次前进 SDF 中记录的距离，优化求交过程</li>
<li>SDF 的计算比较麻烦，存储开销很大</li>
<li>运动物体（刚体）是可以使用 SDF 的
<ul>
<li>如果对每个模型计算了 SDF，求解整个场景的 SDF 只需要求每个模型 SDF
的<strong>最小值</strong>即可</li>
<li>刚体运动的 SDF 比较好计算</li>
</ul></li>
<li>形变物体的 SDF 需要重新计算
<ul>
<li>比较麻烦</li>
</ul></li>
</ul>
<h4 id="生成软阴影">生成软阴影</h4>
<ul>
<li>任意一点的 SDF
告诉了我们一个<strong>安全距离</strong>，等价于<strong>安全角度</strong></li>
</ul>
<p><img src="/2021/04/10/CG/YLQ-GAMES202/04/image-20210411144319279.png" style="zoom: 80%;"></p>
<ul>
<li>安全角度越小，意味着能够看到的东西越少
<ul>
<li>less visibility</li>
</ul></li>
<li>在 ray marching 的过程中，每一步都计算安全角度
<ul>
<li>最终的安全角度就是<strong>过程中最小的安全角度</strong></li>
</ul></li>
</ul>
<p><img src="/2021/04/10/CG/YLQ-GAMES202/04/image-20210411144659961.png" style="zoom:50%;"></p>
<ul>
<li>怎么计算安全距离</li>
</ul>
<p><span class="math display">\[
\arcsin\left\{\dfrac{SDF(p)}{||p-o||}\right\}
\]</span></p>
<ul>
<li>更快的计算
<ul>
<li>一个近似，直接使用 <span class="math inline">\(\sin\)</span>
的结果也可以估计出阴影的大小</li>
<li><span class="math inline">\(k\)</span> 的作用：控制 0,1
之间的过渡带范围，也就是阴影的软硬程度
<ul>
<li>larger k <span class="math inline">\(\leftrightarrow\)</span>
earlier cutoff of penumbra <span class="math inline">\(\leftrightarrow\)</span> harder shadow</li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
\min\left\{\dfrac{k\cdot SDF(p)}{||p-o||},1.0\right\}
\]</span></p>
<ul>
<li>安全角度的大小决定阴影的软硬程度</li>
<li>效果</li>
</ul>
<p><img src="/2021/04/10/CG/YLQ-GAMES202/04/image-20210411145602479.png" style="zoom:60%;"></p>
<ul>
<li>一个教程：https://zhuanlan.zhihu.com/p/94265891</li>
</ul>
<h3 id="距离场的可视化">距离场的可视化</h3>
<ul>
<li>很像是物体的描边</li>
<li>https://docs.unrealengine.com/en-US/BuildingWorlds/LightingAndShadows/MeshDistanceFields/index.html</li>
</ul>
<p><img src="/2021/04/10/CG/YLQ-GAMES202/04/image-20210411145813626.png" style="zoom:50%;"></p>
<h3 id="距离场做软阴影的评价">距离场做软阴影的评价</h3>
<ul>
<li>好处
<ul>
<li>快：在 ray marching 的同时计算出软阴影
<ul>
<li>生成 SDF 的过程相对耗时</li>
</ul></li>
<li>高质量</li>
</ul></li>
<li>问题
<ul>
<li>需要预先计算 SDF</li>
<li>需要较大的存储（3D）
<ul>
<li>优化存储：八叉树、kd 树等</li>
</ul></li>
<li>artifacts</li>
</ul></li>
</ul>
<h3 id="其他">其他</h3>
<ul>
<li>https://github.com/protectwise/troika/tree/master/packages/troika-three-text
<ul>
<li>利用距离场实现无限分辨率的字母</li>
</ul></li>
<li>SDF 生成的物体表面非常不好贴纹理，参数化表面很复杂</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES202</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES202.闫令琪.05.实时环境光照(1)</title>
    <url>/2021/04/11/CG/YLQ-GAMES202/05/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1YK4y1T7yY</li>
</ul>
<h1 id="实时环境光照">实时环境光照</h1>
<ul>
<li>Real-Time Environment Mapping</li>
</ul>
<h2 id="shading-from-environment-lighting">Shading from Environment
Lighting</h2>
<ul>
<li>环境光照下任意点的 shading（不考虑阴影）</li>
<li>环境光照
<ul>
<li>一张贴图</li>
<li>记录了各个方向上来自于无限远的光照</li>
</ul></li>
<li>典型的保存方式：cube map，spherical map</li>
<li>怎么使用环境光照来渲染一个物体
<ul>
<li>IBL：Image-Based Lighting</li>
</ul></li>
<li>不考虑可见性（阴影），渲染方程如下</li>
</ul>
<p><span class="math display">\[
L_o(p,\omega_o)=
\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)\cos\theta_id\omega_i
\]</span></p>
<ul>
<li>蒙特卡洛积分可以求解上面的渲染方程
<ul>
<li>通常而言，基于 sampling 的方法在实时渲染不太适用（比较慢）</li>
<li>但是现在技术进步允许 sampling 的方法应用了</li>
</ul></li>
<li>接下来的方法就是使用<strong>预计算</strong>代替采样</li>
</ul>
<h2 id="the-split-sum-approximation">The Split Sum Approximation</h2>
<h3 id="近似方案">近似方案</h3>
<ul>
<li>基于如下的观察
<ul>
<li>glossy 材质：small support</li>
<li>diffuse 材质：smooth</li>
</ul></li>
</ul>
<p><img src="/2021/04/11/CG/YLQ-GAMES202/05/image-20210411153013150.png" style="zoom:50%;"></p>
<ul>
<li>使用之前的近似方案
<ul>
<li>一点点小的区别，我们只需要对 BRDF 覆盖的范围 <span class="math inline">\(\Omega_G\)</span> 进行积分即可</li>
</ul></li>
</ul>
<p><span class="math display">\[
\int_\Omega f(x)g(x)dx\approx \dfrac{\int_{\Omega_G}
f(x)dx}{\int_{\Omega_G} dx}\cdot {\int_\Omega g(x)dx}
\]</span></p>
<p><span class="math display">\[
L_o(p,\omega_o)=
{\color{red}\dfrac{\int_{\Omega_{G_{f_r}}}
L_i(p,\omega_i)d\omega_i}{\int_{\Omega_{G_{f_r}}} d\omega_i}}
{\color{blue}\int_{\Omega^+}f_r(p,\omega_i,\omega_o)\cos\theta_id\omega_i}
\]</span></p>
<ul>
<li>分为两个部分之后，分别计算</li>
</ul>
<h3 id="st-stage">1st Stage</h3>
<ul>
<li><strong>第一部分的积分</strong></li>
<li>红色区域就是对光源的入射方向（上面的 r ）进行了一个滤波</li>
<li>prefilter，在 rendering 之前预先处理
<ul>
<li>类似于 MIPMAP 的思想</li>
<li>预先生成多张使用不同滤波核 filter 的环境贴图</li>
<li>之后在 shading 的时候进行一个查询，双线性插值</li>
<li>如果查询的值不是一个预先设置的滤波核的大小，三线性插值</li>
</ul></li>
</ul>
<p><img src="/2021/04/11/CG/YLQ-GAMES202/05/image-20210411153933349.png" style="zoom: 67%;"></p>
<ul>
<li>如果是球面环境贴图，需要保证整个 filter 是在球面上发生的</li>
<li>求积分 vs prefilter</li>
</ul>
<p><img src="/2021/04/11/CG/YLQ-GAMES202/05/image-20210411154256861.png" style="zoom:50%;"></p>
<h3 id="nd-stage">2nd Stage</h3>
<h4 id="参数维度5">参数维度：5</h4>
<ul>
<li><strong>第二部分的积分</strong></li>
<li>蓝色部分的积分</li>
<li>预先计算 precompute</li>
<li>假定是 microfacet 的 BRDF
<ul>
<li>只需要知道菲涅尔项、微表面的法线分布（roughness）
<ul>
<li>Precompute its value for all possible combinations of variables
roughness, color (Fresnel term), etc.</li>
</ul></li>
<li>还是很难求积分</li>
<li>而且保存结果需要很大的内存（至少5D 的表）</li>
<li>roughness（一个数）、菲涅尔项（rgb 3 通道、入射角）</li>
</ul></li>
</ul>
<h4 id="参数维度3">参数维度：3</h4>
<ul>
<li>微表面模型的BRDF
<ul>
<li>只考虑菲涅尔项和微表面的法线分布就行</li>
<li>菲涅尔项：决定颜色</li>
<li>微表面的法向分布：材质（glossy、diffuse）</li>
</ul></li>
</ul>
<p><span class="math display">\[
f(\mathbf{i}, \mathbf{o})=\frac{\mathbf{F}(\mathbf{i}, \mathbf{h})
\mathbf{G}(\mathbf{i}, \mathbf{o}, \mathbf{h})
\mathbf{D}(\mathbf{h})}{4(\mathbf{n}, \mathbf{i})(\mathbf{n},
\mathbf{o})}
\]</span></p>
<ul>
<li>菲涅尔项可以用一个函数近似
<ul>
<li>Schlick’s approximation</li>
<li>认为不同的材质是两个参数的函数：入射光夹角、基础反射率（基础颜色）</li>
</ul></li>
</ul>
<p><span class="math display">\[
R(\theta) =R_{0}+\left(1-R_{0}\right)(1-\cos \theta)^{5}
\]</span></p>
<p><span class="math display">\[
R_{0} =\left(\frac{n_{1}-n_{2}}{n_{1}+n_{2}}\right)^{2}
\]</span></p>
<p><img src="/2021/04/11/CG/YLQ-GAMES202/05/image-20210411161156645.png" style="zoom: 67%;"></p>
<ul>
<li>可以定义一个法线分布
<ul>
<li>Beckmann distribution</li>
<li><span class="math inline">\(\alpha\)</span> 定义
roughness，分布的胖瘦</li>
<li><span class="math inline">\(\theta_h\)</span>
表示法线和半角矢量的夹角
<ul>
<li>半角矢量和入射方向是可以互相转换的</li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
D(h)=\dfrac{e^{-\dfrac{\tan^2\theta_h}{\alpha^2}}}{\pi\alpha^2\cos^4\theta_h}
\]</span></p>
<p><img src="/2021/04/11/CG/YLQ-GAMES202/05/image-20210411160934144.png" style="zoom:50%;"></p>
<ul>
<li>所以说现在预计算只需要保存 3D 的图（参数维度是 3D ）
<ul>
<li>认为 <span class="math inline">\(R_0\)</span> 是灰度</li>
</ul></li>
</ul>
<h4 id="参数维度2">参数维度：2</h4>
<ul>
<li>怎么继续降维</li>
<li>显式把上面的菲涅尔项写进去，试图把 <span class="math inline">\(R_0\)</span> 分离开来
<ul>
<li>分母的 <span class="math inline">\(F\)</span> 会被消掉</li>
<li><span class="math inline">\(f_r=FD\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\int_{\Omega^+}f_r(p,\omega_i,\omega_o)\cos\theta_id\omega_i
\]</span></p>
<p><span class="math display">\[
\approx\ R_0\int_{\Omega^+}\dfrac{f_r}{F}(1-(1-\cos
\theta)^{5})\cos\theta_id\omega_i+\int_{\Omega^+}\dfrac{f_r}{F}(1-\cos
\theta)^{5}\cos\theta_id\omega_i\\
\]</span></p>
<ul>
<li>积分的维度变成了 2D</li>
<li>直接打表 2D</li>
</ul>
<p><img src="/2021/04/11/CG/YLQ-GAMES202/05/image-20210411164507382.png"></p>
<ul>
<li>在实现的时候甚至可以使用一张纹理的两个通道</li>
</ul>
<h3 id="评价">评价</h3>
<ul>
<li>避免了采样</li>
<li>很快，效果很好</li>
</ul>
<p><img src="/2021/04/11/CG/YLQ-GAMES202/05/image-20210411164800702.png" style="zoom:50%;"></p>
<h3 id="实时渲染应用">实时渲染应用</h3>
<ul>
<li>使用求和代替积分（说的同一件事）</li>
</ul>
<p><img src="/2021/04/11/CG/YLQ-GAMES202/05/image-20210411164928683.png" style="zoom: 60%;"></p>
]]></content>
      <categories>
        <category>CG.GAMES202</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES202.闫令琪.06.实时环境光照(2)</title>
    <url>/2021/04/14/CG/YLQ-GAMES202/06/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1YK4y1T7yY</li>
</ul>
<h1 id="实时环境光照">实时环境光照</h1>
<ul>
<li>Precomputed Radiance Transfer</li>
</ul>
<h2 id="shadow-from-environment-lighting">Shadow From Environment
Lighting</h2>
<ul>
<li>怎么从环境光照中得到阴影</li>
<li>对于实时渲染而言，非常难</li>
</ul>
<h3 id="对环境光照的不同角度理解">对环境光照的不同角度理解</h3>
<h4 id="多光源">多光源</h4>
<ul>
<li>可以把环境光理解为四面八方来的光照，理解为每个方向的都有光源</li>
<li>环境光照被描述为一个 <code>many-light problem</code>
<ul>
<li>如果使用 SM 的话，每个光源需要一个 SM</li>
<li>代价很高</li>
</ul></li>
</ul>
<h4 id="采样">采样</h4>
<ul>
<li>可以通过采样估计，但是不知道 visibility
项（基于光栅化成像方法），采样很盲目</li>
<li>之前的不等式（约等式）拆分不容易（visibility
不能剥离开来），因为有环境光项的存在
<ul>
<li>support 是整个半球</li>
<li>变化不一定 smooth</li>
</ul></li>
</ul>
<h3 id="工业界的解决方案">工业界的解决方案</h3>
<ul>
<li>只处理最亮的几个光源</li>
<li>环境光遮蔽（AO）
<ul>
<li>只能处理 constant environment lighting 情况下的光照
<ul>
<li>全白、全灰等</li>
</ul></li>
<li>否则估计不准</li>
</ul></li>
</ul>
<h3 id="相关研究">相关研究</h3>
<ul>
<li>Imperfect shadow maps
<ul>
<li>相对好懂</li>
</ul></li>
<li>Light cuts
<ul>
<li>反射物当作光源、光源归类</li>
</ul></li>
<li>RTRT (might be the ultimate solution)
<ul>
<li>Real-Time Ray Tracing</li>
</ul></li>
<li>Precomputed radiance transfer
<ul>
<li>能够得到非常准确得到环境光的阴影</li>
</ul></li>
</ul>
<h3 id="工业界">工业界</h3>
<ul>
<li>游戏引擎使用的方法和我们学的差不多，但是在实现上可能融合了很多种方法</li>
<li>工业界怎么实现的又快又好才是重点</li>
</ul>
<h2 id="频域与滤波">频域与滤波</h2>
<h3 id="傅里叶变换">傅里叶变换</h3>
<ul>
<li>傅里叶变换 Foutier Transform</li>
<li>任意函数都可以展开为 sin/cos 函数的线性组合
<ul>
<li><strong>基函数</strong></li>
</ul></li>
<li>频率高，变化快</li>
<li>图像主要是低频区域</li>
<li>高频区域是细节</li>
<li>滤波器：去除某些频率的内容，保留感兴趣的频率</li>
<li>时域卷积 <span class="math inline">\(\leftrightarrow\)</span>
频域相乘</li>
<li>模糊
<ul>
<li>时域卷积</li>
<li>频域低通滤波（乘一个低通滤波器）</li>
</ul></li>
</ul>
<h3 id="滤波的理解">滤波的理解</h3>
<ul>
<li>乘积的积分可以理解为一种滤波
<ul>
<li>Any product integral can be considered as filtering</li>
</ul></li>
</ul>
<p><span class="math display">\[
\int_{\Omega}f(x)g(x)dx
\]</span></p>
<ul>
<li>低频：smooth
<ul>
<li>Low frequency == smooth function / slow changes / etc</li>
</ul></li>
<li>上面积分得到的结果的频率是积分项中频率较低的一项
<ul>
<li>由较低的一项决定</li>
<li>The frequency of the integral is the lowest of any individual’s</li>
<li><strong>从频域上的相乘理解</strong></li>
</ul></li>
</ul>
<h3 id="基函数">基函数</h3>
<ul>
<li>Basis Functions</li>
<li>一组线性无关的函数，任意函数都可以由这组函数线性表出
<ul>
<li>A set of functions that can be used to represent other functions in
general</li>
</ul></li>
<li>基函数正交</li>
<li>傅里叶变换中的 <span class="math inline">\(\sin/\cos/\cdots\)</span></li>
<li>泰勒展开中的多项式 <span class="math inline">\(x/x^2/\cdots\)</span></li>
</ul>
<h2 id="球面谐波函数">球面谐波函数</h2>
<ul>
<li>Spherical Harmonics</li>
<li>A set of 2D basis functions defined on the sphere</li>
<li>一系列的的二维函数，定义在球面上
<ul>
<li>方向函数 <span class="math inline">\((\theta,\phi)\)</span></li>
</ul></li>
<li>球面谐波函数的可视化
<ul>
<li>每一行的频率是一样的，第 <span class="math inline">\(l\)</span> 阶的
SH</li>
<li><span class="math inline">\(m=2l+1\)</span></li>
<li>前 <span class="math inline">\(n\)</span> 阶一共有 <span class="math inline">\(n^2\)</span> 个基函数</li>
</ul></li>
</ul>
<p><img src="/2021/04/14/CG/YLQ-GAMES202/06/image-20210414115518543.png" style="zoom:67%;"></p>
<ul>
<li>上图中
<ul>
<li>颜色表示值（白/黑）</li>
<li>值的变换快慢是频率</li>
</ul></li>
<li>为什么不使用 2D 的傅里叶变换
<ul>
<li>不适合球面，可能最终会在球面上产生一条缝</li>
<li>SH 定义在球面上，因此在球面上的变换更加 smooth</li>
</ul></li>
<li>每一个基函数可以被勒让德多项式定义
<ul>
<li>Each SH basis function <span class="math inline">\(B(\omega_i)\)</span> is associated with a
(Legendre) polynomial</li>
</ul></li>
<li><strong>投影操作</strong>
<ul>
<li>给定任意一个的定义在球面上的函数 <span class="math inline">\(f(w)\)</span>，其展开为 SH 表示的系数为</li>
</ul></li>
</ul>
<p><span class="math display">\[
c_i=\int_{\Omega}f(\omega)B_i(\omega_i)\mathrm{d}(\omega)
\]</span></p>
<ul>
<li>恢复函数的的时候，可以直接保留前几项（例如前 4 阶）
<ul>
<li>类似于傅里叶变换中保留前几项，就可以恢复出一个相对可以接受的结果</li>
</ul></li>
</ul>
<h2 id="环境光照下-diffuse-物体的-shading">环境光照下 diffuse 物体的
shading</h2>
<ul>
<li>不考虑 shadow</li>
<li>上一节课：Prefiltering + single query = no filtering + multiple
queries</li>
<li>我们的想法是通过i分析 diffuse 的 BDRF
，发现这是个低频成分，于是我们不需要保留光照太多的高频信息，于是我们可以指考虑光照在球面谐波函数中的前几项即可</li>
</ul>
<h3 id="分析-brdf">分析 BRDF</h3>
<ul>
<li><strong>diffuse</strong> 物体的 BRDF
表现的效果就是一个低通滤波器（球面上）
<ul>
<li><strong>相关</strong>，卷积</li>
</ul></li>
</ul>
<p><span class="math display">\[
E_{lm}=A_lL_{lm}
\]</span></p>
<ul>
<li><span class="math inline">\(A_l\)</span> 为系数（<span class="math inline">\(l\)</span> 为偶数）</li>
</ul>
<p><span class="math display">\[
A_l=2\pi\dfrac{(-1)^{\frac{l}{2}-1}}{(l+2)(l-1)}\left[\dfrac{l!}{2^l(\frac{l}{2}!)^2}\right]
\]</span></p>
<ul>
<li>使用前 3 阶的 SH 就能够很好的恢复
<ul>
<li>因为 diffuse 的 BRDF
十分低频，最终得到的结果肯定也是低频项占据主导</li>
</ul></li>
</ul>
<p><img src="/2021/04/14/CG/YLQ-GAMES202/06/image-20210414122309086.png" style="zoom:50%;"></p>
<h3 id="估计光照">估计光照</h3>
<ul>
<li>因为 diffuse 的 BRDF 十分低频，最终能够得到的结果也会是一个低频信号
<ul>
<li>我们要计算的积分最终结果是 BRDF 和光照的卷积</li>
</ul></li>
<li>没必要保留光照太多的高频信息</li>
</ul>
<h3 id="实验">实验</h3>
<ul>
<li>ground truth</li>
</ul>
<p><img src="/2021/04/14/CG/YLQ-GAMES202/06/image-20210414124153911.png"></p>
<ul>
<li>使用前 1/2/3 阶的 SH 进行恢复光照，然后最终 shading 的结果</li>
<li>RMS ERROR：25%，8%，1%</li>
</ul>
<p><img src="/2021/04/14/CG/YLQ-GAMES202/06/1.png"></p>
<h3 id="sh评价">SH评价</h3>
<ul>
<li>很适合描述低频的 BRDF、低频的光照</li>
</ul>
<h3 id="diego">Diego</h3>
<ul>
<li>两行代码获得博士学位</li>
<li>引入球谐函数，引领了一个时代</li>
</ul>
<p><img src="/2021/04/14/CG/YLQ-GAMES202/06/image-20210414140316760.png" style="zoom: 50%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">surface float1 <span class="title">irradmat</span> <span class="params">(matrix4 M, float3 v)</span> </span>&#123;</span><br><span class="line">    float4 n = &#123;v , <span class="number">1</span>&#125; ;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dot</span>(n , M*n) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sh-的性质">SH 的性质</h3>
<ul>
<li>orthonormal
<ul>
<li>正交</li>
</ul></li>
<li>simple projection/reconstruction
<ul>
<li>投影/重建好算</li>
</ul></li>
<li>simple rotation
<ul>
<li>旋转球面上的任意函数，等价于旋转基函数</li>
<li>旋转基函数，新的基函数可以被同阶的其他基函数线性表出</li>
<li>因此旋转函数，相当于修改基函数的系数</li>
</ul></li>
<li>simple convolution</li>
<li>few basis functions: low freqs
<ul>
<li>使用较小阶的基函数就能够得到不错的效果（低频）</li>
</ul></li>
</ul>
<p><img src="/2021/04/14/CG/YLQ-GAMES202/06/image-20210414144553229.png"></p>
<h2 id="prt">PRT</h2>
<ul>
<li>Precomputed Radiance Transfer</li>
<li>渲染方程</li>
</ul>
<p><img src="/2021/04/14/CG/YLQ-GAMES202/06/image-20210414141140164.png" style="zoom:50%;"></p>
<ul>
<li>右下角中的红点对应的 3 张图</li>
<li>复杂度很高，对于每一个点，需要取遍 6 张贴图中的所有点
<ul>
<li><span class="math inline">\(6\ast64\ast64\)</span></li>
</ul></li>
</ul>
<h3 id="prt-论文">PRT 论文</h3>
<ul>
<li>Precomputed Radiance Transfer for Real-Time Rendering in Dynamic,
Low-Frequency Lighting Environments [Sloan 02]</li>
<li>SIGGRAPH 2002</li>
<li>利用球谐函数的性质进行预计算</li>
<li>用另一种角度看待渲染方程</li>
<li><strong>我们假设场景是不变的，改变的只是光照</strong>
<ul>
<li>光照的位置、光照的颜色</li>
</ul></li>
</ul>
<p><img src="/2021/04/14/CG/YLQ-GAMES202/06/image-20210414142001805.png" style="zoom:67%;"></p>
<ul>
<li>把 Lighting 表示为基函数</li>
<li>场景是不变的，因此在预计算的时候把 light transport
先计算出来，然后用基函数表示</li>
</ul>
<h3 id="prt-diffuse-物体">PRT Diffuse 物体</h3>
<ul>
<li>将 diffuse 常数项从渲染方程中提取出来</li>
</ul>
<p><span class="math display">\[
L(\boldsymbol{o})=\rho\int_{\Omega}L(\boldsymbol{i})V(\boldsymbol{i})\max(0,\boldsymbol{n}\cdot
\boldsymbol{i})\mathrm{d}\boldsymbol{i}
\]</span></p>
<ul>
<li>光照使用 SH 表示</li>
</ul>
<p><span class="math display">\[
L(\boldsymbol{i})\approx\sum l_iB_i(\boldsymbol{i})
\]</span></p>
<ul>
<li>渲染方程变为</li>
</ul>
<p><span class="math display">\[
L(\boldsymbol{o})=\rho\sum
l_i{\color{red}\int_{\Omega}B_i(\boldsymbol{i})V(\boldsymbol{i})\max(0,\boldsymbol{n}\cdot
\boldsymbol{i})\mathrm{d}\boldsymbol{i}}
\]</span></p>
<ul>
<li>红色部分与光照无关，可以预计算，记作 <span class="math inline">\(T_i\)</span>，渲染方程变为
<ul>
<li>预计算的话不考虑时间</li>
<li>Reduce rendering computation to <strong>dot product</strong></li>
</ul></li>
</ul>
<p><span class="math display">\[
L(\boldsymbol{o})=\rho\sum l_iT_i
\]</span></p>
<ul>
<li><strong>场景是不能动的</strong>，因为动了，visibility
项就变了，预计算失效</li>
<li>能不能解决光源移动的问题？
<ul>
<li>可以，SH 的性质，如果光源做了一个旋转操作，很快就能够得到新的
SH</li>
</ul></li>
</ul>
<h3 id="prt-另外一种预计算的方式">PRT 另外一种预计算的方式</h3>
<ul>
<li>渲染方程</li>
</ul>
<p><span class="math display">\[
L_o(p,\omega_o)=
\int_{\Omega^+}{\color{red}L_i(p,\omega_i)}{\color{blue}f_r(p,\omega_i,\omega_o)\cos\theta_i
V(p,\omega_i)}d\omega_i=\int_{\Omega^+}{\color{red}L(\omega_i)}{\color{blue}T(\omega_i)}d\omega_i
\]</span></p>
<ul>
<li>把 <strong>lighting</strong> 和 <strong>light transport</strong>
都用基函数表示出来</li>
</ul>
<p><span class="math display">\[
L(\omega_i)\approx\sum_{p}c_pB_p(\omega_i)
\]</span></p>
<p><span class="math display">\[
T(\omega_i)\approx\sum_{q}t_qB_q(\omega_i)
\]</span></p>
<ul>
<li>重新表示渲染方程</li>
</ul>
<p><span class="math display">\[
L_o(p,\omega_o)=\sum_{p}\sum_{q}c_pt_q\int_{\Omega^+}B_p(\omega_i)B_q(\omega_i)d\omega_i
\]</span></p>
<ul>
<li>似乎看起来是 <span class="math inline">\(O(n^2)\)</span>
的，但是由于 SH 的正交性，只有 <span class="math inline">\(p=q\)</span>
的情况下才不为 0</li>
</ul>
<h3 id="prt-glossy-物体">PRT Glossy 物体</h3>
<ul>
<li>diffuse 物体，BRDF 为常数</li>
<li>glossy 物体，4D 的 BRDF
<ul>
<li>和 diffuse 的区别，上面 light transport（蓝色项）还与方向矢量 <span class="math inline">\(o\)</span> 有关（与视点有关）</li>
</ul></li>
<li>因此就算是使用了基函数，结果还是和 <span class="math inline">\(o\)</span> 相关</li>
</ul>
<p><span class="math display">\[
L(o)\approx\sum_{i} l_iT_i(o)
\]</span></p>
<ul>
<li>能否将 <span class="math inline">\(T_i(o)\)</span>
也用基函数表示</li>
</ul>
<p><span class="math display">\[
T_i(o)\approx\sum_{j} t_{ij}B_j(o)
\]</span></p>
<p><span class="math display">\[
L(o)\approx\sum_{i}\sum_{j} l_it_{ij}B_j(o)
\]</span></p>
<ul>
<li>这样看来，我们需要把 light transport
作为一个矩阵来看待（而不是之前的向量）</li>
</ul>
<p><img src="/2021/04/14/CG/YLQ-GAMES202/06/image-20210424213131713.png" style="zoom: 50%;"></p>
<ul>
<li>存储开销变大了，计算开销也变大了</li>
<li>SH 阶数
<ul>
<li>diffuse 使用 3 阶 SH 就够了</li>
<li>glossy 需要一些高频成分，4 阶或者 5 阶</li>
</ul></li>
<li>非常高频，接近镜面的物体，PRT 无法解决
<ul>
<li>需要很高阶，而且效果不好</li>
<li>可以直接采样</li>
</ul></li>
</ul>
<h3 id="interreflection-and-caustics">Interreflection and caustics</h3>
<ul>
<li>光路 transport paths
<ul>
<li><span class="math inline">\(LE\)</span>（直接看到光源）
<ul>
<li>light - eye</li>
</ul></li>
<li><span class="math inline">\(LGE\)</span>（直接反射）
<ul>
<li>light - glossy - eye</li>
</ul></li>
<li><span class="math inline">\(L(D|G)\ast E\)</span></li>
<li><span class="math inline">\(LS\ast(D|G)\ast E\)</span>
<ul>
<li>caustics</li>
</ul></li>
</ul></li>
<li>PRT 在做完预计算之后，实际渲染的过程复杂度和 transport
的复杂度是无关的</li>
<li>也就是说 PRT 可以模拟任意复杂的 transport</li>
</ul>
<h3 id="怎么进行预计算">怎么进行预计算</h3>
<ul>
<li><strong>基函数看作是光照</strong></li>
<li>对于 diffuse 物体</li>
</ul>
<p><span class="math display">\[
T_i=\int_{\Omega}B_i(\boldsymbol{i})V(\boldsymbol{i})\max(0,\boldsymbol{n}\cdot
\boldsymbol{i})\mathrm{d}\boldsymbol{i}
\]</span></p>
<ul>
<li>形式上还是和 rendering equation，因此可以把基函数看作是某种光照</li>
<li>因此，预计算的过程可以看作是一个离线渲染的过程，具体方法可以用之前提到的其他算法</li>
</ul>
<p><img src="/2021/04/14/CG/YLQ-GAMES202/06/image-20210424215319352.png" style="zoom:60%;"></p>
<h3 id="prt-的问题">PRT 的问题</h3>
<ul>
<li>不太适用于高频的光照（需要用很多的高阶的基函数）</li>
<li>要求场景是固定的</li>
<li>材质也需要是固定的</li>
<li>存储开销</li>
</ul>
<h3 id="prt-的改进">PRT 的改进</h3>
<ul>
<li>More basis functions
<ul>
<li>其他的基函数</li>
</ul></li>
<li>dot product =&gt; triple products
<ul>
<li>预计算更多的部分，例如 BRDF、visibility 等</li>
</ul></li>
<li>Static scene =&gt; dynamic scene</li>
<li>Fix material =&gt; dynamic material</li>
<li>Other effects: translucent, hair, ...</li>
<li>Precomputation =&gt; analytic computation
<ul>
<li>解析解，例如 split sum</li>
</ul></li>
</ul>
<h2 id="其他的一些基函数">其他的一些基函数</h2>
<ul>
<li>Spherical Harmonics (SH)</li>
<li>Wavelet</li>
<li>Zonal Harmonics</li>
<li>Spherical Gaussian (SG)</li>
<li>Piecewise Constant</li>
</ul>
<h3 id="小波">小波</h3>
<ul>
<li>Wavelet
<ul>
<li>有很多种</li>
</ul></li>
<li>2D Haar Wavelet</li>
</ul>
<p><img src="/2021/04/14/CG/YLQ-GAMES202/06/image-20210424220500394.png"></p>
<ul>
<li>小波定义在图像块上的，不同的小波定义域也不相同
<ul>
<li>灰色部分就是没有定义的地方</li>
</ul></li>
<li>小波变换之后，很多基函数对应的系数为 0
<ul>
<li>保留最大的多少个不为 0 的项即可</li>
<li>非线性估计</li>
</ul></li>
<li><strong>对全频率的表示</strong></li>
<li>由于小波是定义在平面上的，因此我们使用 cube map 去表示环境光照
<ul>
<li>对每个面进行小波变换</li>
<li>将系数最大的几个项存在右上、右下、左下部分，对剩余的部分继续进行小波变换</li>
</ul></li>
</ul>
<p><img src="/2021/04/14/CG/YLQ-GAMES202/06/wavelet.png"></p>
<ul>
<li>JPEG 文件使用了 DCT（离散余弦变换）去进行图像压缩
<ul>
<li>和小波变换比较像</li>
</ul></li>
</ul>
<h3 id="小波-vs-球谐">小波 vs 球谐</h3>
<p><img src="/2021/04/14/CG/YLQ-GAMES202/06/image-20210424221956291.png" style="zoom:50%;"></p>
<ul>
<li>小波变换
<ul>
<li>保留了一些高频信息，产生很多高频阴影</li>
<li><strong>不支持快速旋转光照</strong></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES202</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES202.闫令琪.07.实时全局光照(3D空间)</title>
    <url>/2021/04/24/CG/YLQ-GAMES202/07/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1YK4y1T7yY</li>
</ul>
<h1 id="d空间实时全局光照">3D空间实时全局光照</h1>
<ul>
<li>Global Illumination (GI) is important but complex
<ul>
<li><strong>GI</strong>：Global Illumination</li>
</ul></li>
</ul>
<p><img src="/2021/04/24/CG/YLQ-GAMES202/07/image-20210424222703305.png" style="zoom:40%;"></p>
<h2 id="one-bounce">one-bounce</h2>
<ul>
<li>实时渲染中，我们主要解决的全局光照之的主要是
<strong>one-bounce</strong> 的间接光照</li>
<li>one-bounce</li>
</ul>
<p><img src="/2021/04/24/CG/YLQ-GAMES202/07/image-20210424222841739.png" style="zoom:70%;"></p>
<ul>
<li>一切被光源直接照亮的物体，都可以作为<strong>次级光源</strong>去照亮其他物体
<ul>
<li>原始的光源：primary light source</li>
</ul></li>
</ul>
<h2 id="分类">分类</h2>
<ul>
<li>3D 空间的方法
<ul>
<li>RSM</li>
<li>VXGI</li>
</ul></li>
<li>图像空间
<ul>
<li>SSAO</li>
<li>SSDO</li>
<li>SSR</li>
</ul></li>
</ul>
<h2 id="rsm">RSM</h2>
<ul>
<li>Reflective Shadow Mapping</li>
</ul>
<h3 id="问题">问题</h3>
<ul>
<li>那些部分可以被作为次级光源
<ul>
<li>Shadow Mapping</li>
</ul></li>
<li>每个次级光源对 shading point 的贡献是多少
<ul>
<li>把每一小区域都当做是面光源</li>
<li>采样方法</li>
</ul></li>
</ul>
<h3 id="次级光源">次级光源</h3>
<ul>
<li>使用 shadow map 解决</li>
<li>对于 SM 而言，认为每一个像素对应一个小片</li>
<li>同样的理解，我们可以把这些小片对应的区域都作为次级光源</li>
<li>计算量很大：<strong>采样</strong></li>
<li>产生了一个问题，我们在计算次级光源 shading 的时候，我们是在 light
的位置去观察的，我们不知道这些次级光源之后用于渲染其他物体的时候的入射方向是什么（次级光源的出射方向不知道）</li>
<li>怎么让结果不依赖于出射方向呢？
<ul>
<li><strong>经典假设</strong>：所有反射物（次级光源）都是 diffuse
的</li>
</ul></li>
</ul>
<h3 id="怎么用次级光源去照亮">怎么用次级光源去照亮</h3>
<p><img src="/2021/04/24/CG/YLQ-GAMES202/07/image-20210424224344549.png" style="zoom: 50%;"></p>
<ul>
<li>对（次级）光源采样</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
L_o(p,\omega_o)
&amp;=\int_{\Omega_{patch}}L_i(p,\omega_i)V(p,\omega_i)f_r(p,\omega_i,\omega_o)\cos\theta_i
d\omega_i\\
&amp;=\int_{A_{patch}} L_{i}(q\to p) V(q\to p)f_{r}(p, q\to p,
\omega_{o})\dfrac{\cos\theta_p\cos\theta_q}{||p-q||^2}dA\\
\end{aligned}
\]</span></p>
<ul>
<li>如果 patch 的数量比较少，可以直接求和</li>
<li>对于次级光源，diffuse
<ul>
<li>BRDF：<span class="math inline">\(f_r&#39;=\dfrac{\rho}{\pi}\)</span>
<ul>
<li>注意不是上面渲染方程里的，而是针对次级光源 p 处的，上面的是 q
处的</li>
</ul></li>
<li><span class="math inline">\(L_i=f_r&#39;\dfrac{\Phi}{dA}\)</span>
<ul>
<li><span class="math inline">\(\Phi\)</span>：入射的 flux</li>
<li>BRDF 的定义</li>
<li>带入渲染方程，发现不需要知道 patch 对应的大小（消掉了）</li>
<li>只需要知道 <span class="math inline">\(\Phi\)</span> 即可</li>
</ul></li>
</ul></li>
<li>可见性检测，V 很难做
<ul>
<li><strong>不好算就不算了</strong></li>
</ul></li>
<li>论文中的系数
<ul>
<li>4 次方</li>
<li><span style="color:red;font-weight:bold">和我们推导的是一致的</span></li>
<li>分子中 <span class="math inline">\(x-x_p\)</span>
没有归一化，归一化之后是一样的</li>
</ul></li>
</ul>
<p><img src="/2021/04/24/CG/YLQ-GAMES202/07/image-20210424233936824.png" style="zoom:50%;"></p>
<h3 id="一些细节">一些细节</h3>
<ul>
<li>不是所有的次级光源都会对 shading point 有贡献
<ul>
<li>可见性（很难）</li>
<li>距离</li>
<li>朝向
<ul>
<li>例如桌子上的点不会照亮 x 点</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/04/24/CG/YLQ-GAMES202/07/image-20210424234651564.png" style="zoom:50%;"></p>
<ul>
<li>只需要找离 shading point 比较近的点采样
<ul>
<li>平方衰减</li>
</ul></li>
<li>论文大胆的假设，在 SM 中离得比较近，表示在世界坐标系中离得比较近
<ul>
<li>加速采样</li>
</ul></li>
<li>具体采样方法
<ul>
<li>近的点贡献大，多采样一点</li>
<li>远的点少采样一点，但是把面积做大一点</li>
<li>400 个 sample 效果就不错</li>
</ul></li>
</ul>
<p><img src="/2021/04/24/CG/YLQ-GAMES202/07/image-20210424234745199.png" style="zoom:50%;"></p>
<ul>
<li>存储开销
<ul>
<li>shadow map（depth）</li>
<li>flux</li>
<li>世界坐标系法向</li>
<li>世界坐标系位置</li>
</ul></li>
<li><strong>RSM 对手电筒的模拟效果非常好</strong></li>
</ul>
<h3 id="评价">评价</h3>
<ul>
<li>pros
<ul>
<li>很容易实现：基于 shadow map 算法</li>
</ul></li>
<li>cons
<ul>
<li>直接光源个数有多少个，就需要做多少个 SM（SM 原生问题）</li>
<li>次级光源照亮物体时没考虑可见性</li>
<li>很多假设：计算在次级光源处的 shading 的时候做了 diffuse 的假设</li>
<li>深度图之间的距离代替世界坐标系的距离</li>
<li>采样率和效率之间的 trade off</li>
</ul></li>
</ul>
<h3 id="其他想法">其他想法</h3>
<ul>
<li>RSM 中的次级光源和离线渲染中的 VPL 非常接近
<ul>
<li>virtual point light</li>
</ul></li>
<li>认为 RSM 还是属于 3D 的方法，而不是图像空间的方法
<ul>
<li>因为准确记录了信息，而且第二个 pass 的时候还是在 3D
空间中计算的</li>
</ul></li>
</ul>
<h2 id="lpv">LPV</h2>
<ul>
<li>Light Propagation Volumes (LPV)</li>
<li>最早在 CryEngine3 中被提出
<ul>
<li>Crisis 游戏</li>
</ul></li>
<li>关键问题
<ul>
<li>对于每一个 shading point 能够很快的获得来自各个方向的 radiance</li>
</ul></li>
<li>LPV 的关键想法：radiance 直线传播，传播过程中是不变的</li>
<li>把场景划分为 3D 的网格
<ul>
<li>Voxel 体素</li>
</ul></li>
</ul>
<p><img src="/2021/04/24/CG/YLQ-GAMES202/07/image-20210429151639562.png" style="zoom:50%;"></p>
<ul>
<li>问题抽象（上图是一个 2D 的例子）
<ul>
<li>蓝色：直接光源</li>
<li>红色：被光源直接照亮的物体</li>
<li>黄色：询问来自各个方向的 radiance</li>
</ul></li>
</ul>
<h3 id="算法步骤">算法步骤</h3>
<ul>
<li>Generation of radiance point set scene representation
<ul>
<li>确定哪一些点会发出间接光照（次级光源）</li>
</ul></li>
<li>Injection of point cloud of virtual light sources into radiance
volume
<ul>
<li>把次级光源放到场景的网格中</li>
</ul></li>
<li>Volumetric radiance propagation
<ul>
<li>将 radiance 在网格中进行传播</li>
</ul></li>
<li>Scene lighting with final light propagation volume
<ul>
<li>直接利用这些 radiance 进行光照计算</li>
</ul></li>
</ul>
<h4 id="step-1-generation">Step 1: Generation</h4>
<ul>
<li>找到次级光源
<ul>
<li>可以简单地通过 RSM 找到</li>
</ul></li>
<li>不一定需要使用所有的次级光源，可以对其进行一些采样</li>
</ul>
<h4 id="step-2-injection">Step 2: Injection</h4>
<ul>
<li>首先将场景划分为 3D 的网格</li>
<li>对于每一个网格，我们找到网格内的次级光源
<ul>
<li>对于每个方向的 radiance 进行求和</li>
<li>使用 SH 进行压缩（2阶就够了）
<ul>
<li>使用 SH 压缩，于是只能得到一些相对低阶的项，因此对于 diffuse
场景支持较好</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/04/24/CG/YLQ-GAMES202/07/image-20210429153000429.png" style="zoom:50%;"></p>
<h4 id="step3-propagation">Step3: Propagation</h4>
<ul>
<li>对于每一个网格，考虑它周围的 6 个邻接的网格传播过来的 radiance
<ul>
<li>求和，然后使用 SH 进行压缩</li>
<li>实际操作可能是对每个点向周围 6 个面的传播</li>
</ul></li>
<li>最终迭代至不动点
<ul>
<li>一般迭代四五次就能够稳定下来</li>
</ul></li>
<li><strong>在传播的过程中，我们不考虑可见性</strong></li>
</ul>
<p><img src="/2021/04/24/CG/YLQ-GAMES202/07/image-20210429153128762.png" style="zoom:50%;"></p>
<h4 id="step-4-rendering">Step 4: Rendering</h4>
<ul>
<li>对于任意的 shading
point，我们找到它位于哪一个具体的网格中，通过记录的不同方向的 radiance
进行计算</li>
</ul>
<h3 id="问题-1">问题</h3>
<ul>
<li>如下图，我们将一个网格内的点的 radiance 都认为是一样的，但是实际上 p
点不会照亮对应网格中的蓝色点
<ul>
<li>造成 light leaking 的问题</li>
</ul></li>
</ul>
<p><img src="/2021/04/24/CG/YLQ-GAMES202/07/image-20210429153458743.png" style="zoom:50%;"></p>
<ul>
<li>LPV 和 对比图</li>
</ul>
<p><img src="/2021/04/24/CG/YLQ-GAMES202/07/image-20210429153707871.png"></p>
<ul>
<li>根本原因：网格的精度问题，如果存在某个场景中的几何粒度比网格要小，这样就可能会导致上面的现象</li>
<li>增大精度
<ul>
<li>存储开销变大</li>
<li>propagation 不容易稳定，计算开销变大</li>
</ul></li>
<li>工业界的实现会使用不同精度层次的网格
<ul>
<li>学术界叫法：multi-scale</li>
<li>工业界叫法：cascaded</li>
</ul></li>
<li>对于每一个光源，都需要用一次 RSM 算法
<ul>
<li>注入之后的传播只需要一次</li>
</ul></li>
<li>LPV 是实时计算的，而不是预计算</li>
</ul>
<h2 id="vxgi">VXGI</h2>
<ul>
<li>Voxel Global Illumination (VXGI)</li>
<li>two-pass 的算法</li>
</ul>
<h3 id="和-rsm-的区别">和 RSM 的区别</h3>
<ul>
<li>RSM 的光源是每个像素表示的微小表面</li>
<li>VXGI 将整个场景离散成很多个格子
<ul>
<li>例如八叉树的方式组织整个场景</li>
</ul></li>
</ul>
<p><img src="/2021/04/24/CG/YLQ-GAMES202/07/image-20210429154900906.png" style="zoom: 50%;"></p>
<ul>
<li>渲染的时候从相机出发，对每个像素发出 eye ray，对于场景中碰到的点进行
cone tracing
<ul>
<li>glossy 物体的反射叶是一个锥形的区域</li>
</ul></li>
</ul>
<h3 id="具体步骤">具体步骤</h3>
<p><img src="/2021/04/24/CG/YLQ-GAMES202/07/image-20210429155540446.png"></p>
<h4 id="pass-1-from-the-light">pass 1: from the light</h4>
<ul>
<li>首先我们需要对整个场景体素化，建立一个层次结构
<ul>
<li>需要在层次结构中更新</li>
<li>更多的情况，高层结构是将低层结构收集起来（合并）</li>
</ul></li>
<li>在每1个体素中记录法线的分布、光源入射方向的分布</li>
</ul>
<h4 id="pass-2-from-the-camera">pass 2: from the camera</h4>
<h5 id="glossy-物体">glossy 物体</h5>
<ul>
<li>对于 glossy 的物体，反射叶就是一个锥形</li>
<li>一种最简单的方法，从 shading point
连出一个圆锥，逐体素是否和圆锥相交，如果相交，则计算整个体素对于 shading
point 的贡献值
<ul>
<li>加速：圆锥的大小在传播过程中是越来越大的，因此我们可以通过距离估计出范围大小，然后在八叉树的对应层次结构中对应的一块即可</li>
</ul></li>
</ul>
<p><img src="/2021/04/24/CG/YLQ-GAMES202/07/image-20210429155927647.png" style="zoom:50%;"></p>
<p><img src="/2021/04/24/CG/YLQ-GAMES202/07/image-20210429160538316.png" style="zoom:50%;"></p>
<h5 id="diffuse-物体">diffuse 物体</h5>
<ul>
<li>可以使用若干圆锥近似
<ul>
<li>圆锥之间有缝，但是这对于 diffuse 物体是可以接受的</li>
</ul></li>
</ul>
<p><img src="/2021/04/24/CG/YLQ-GAMES202/07/image-20210429160555277.png" style="zoom:50%;"></p>
<h2 id="评价-1">评价</h2>
<ul>
<li>在当时的情况下，算是比较好的一种方法
<ul>
<li>很像我们在离线渲染中做的 photon mapping 的操作</li>
</ul></li>
<li>存在一些他自己的问题
<ul>
<li>由于开销较大，应用比较少</li>
<li>场景的体素化是很麻烦的，可能需要预计算
<ul>
<li>对于动态场景而言更是如此，每一帧可能都得重建</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES202</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES202.闫令琪.08.实时全局光照(屏幕空间)(SSAO/SSDO)</title>
    <url>/2021/04/29/CG/YLQ-GAMES202/08/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1YK4y1T7yY</li>
</ul>
<h1 id="屏幕空间全局光照">屏幕空间全局光照</h1>
<h2 id="屏幕空间">屏幕空间</h2>
<ul>
<li>所有拿到的信息都是在屏幕上的</li>
<li>之后使用的信息只能是直接光照形成的结果</li>
<li>相当于是对得到的二维图像进行一个后处理</li>
</ul>
<h2 id="ssao">SSAO</h2>
<ul>
<li>Screen Space Ambient Occlusion</li>
<li>屏幕空间环境光遮蔽</li>
<li>AO 的结果：contact shadow
<ul>
<li>物体接触的地方会有阴影</li>
</ul></li>
<li>SSAO：对于全局光照的一个近似
<ul>
<li>屏幕空间内的信息进行计算</li>
</ul></li>
</ul>
<h3 id="关键假设">关键假设</h3>
<ul>
<li>我们不知道入射光的方向</li>
<li>我们可以假设，对于所有的 shading
point，所有的入射方向，光照都是一个常数
<ul>
<li>环境光</li>
</ul></li>
<li>但是不同地方接受到的环境光的强度应该是不一样的，通过某种方式对于环境光的强度进行估计</li>
</ul>
<p><img src="/2021/04/29/CG/YLQ-GAMES202/08/image-20210429164516719.png" style="zoom:50%;"></p>
<ul>
<li>同时我们假设所有的物体都是 diffuse 的</li>
</ul>
<p><img src="/2021/04/29/CG/YLQ-GAMES202/08/image-20210429164733058.png" style="zoom:50%;"></p>
<h3 id="理论基础环境光">理论基础(环境光)</h3>
<ul>
<li>渲染方程</li>
</ul>
<p><span class="math display">\[
L_o(p,\omega_o)=
\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)
V(p,\omega_i)\cos\theta_i\,\mathrm{d}\omega_i
\]</span></p>
<ul>
<li>利用之前的经典不等式
<ul>
<li><span class="math inline">\(g(x)\)</span>：smooth / small
support</li>
</ul></li>
</ul>
<p><span class="math display">\[
\int_\Omega f(x)g(x)\,\mathrm{d}x\approx \dfrac{\int_\Omega
f(x)\,\mathrm{d}x}{\int_\Omega \,\mathrm{d}x}\cdot {\int_\Omega
g(x)\,\mathrm{d}x}
\]</span></p>
<ul>
<li>近似结果
<ul>
<li><strong>多了一项 <span class="math inline">\(\cos\theta_i\)</span>，后面会解释</strong></li>
<li>可以把 <span class="math inline">\(\cos\theta_i\,\mathrm{d}\omega_i\)</span>
整个看成是一项 <span class="math inline">\(\mathrm{d}x_{\perp}\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
L_o(p,\omega_o)\approx
{\color{blue}\dfrac{\int_{\Omega^+}V(p,\omega_i)\cos\theta_i\,\mathrm{d}\omega_i}{\int_{\Omega^+}\cos\theta_i\,\mathrm{d}\omega_i}}
\cdot
{\color{red}\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)\cos\theta_i\,\mathrm{d}\omega_i}
\]</span></p>
<ul>
<li><span style="color:blue">蓝色</span>部分
<ul>
<li>平均可见性</li>
</ul></li>
</ul>
<p><span class="math display">\[
{\color{blue}k_A}=\dfrac{\int_{\Omega^+}V(p,\omega_i)\cos\theta_i\,\mathrm{d}\omega_i}{\pi}
\]</span></p>
<ul>
<li><span style="color:red">红色</span>部分
<ul>
<li>diffuse，BRDF 是常数</li>
<li>光照为 constant，L 为常数</li>
<li>都可以随便指定</li>
</ul></li>
</ul>
<p><span class="math display">\[
L_{i}^{indir}(p)\cdot\dfrac{\rho}{\pi}\cdot\pi=L_{i}^{indir}(p)\cdot\rho
\]</span></p>
<ul>
<li>AO 可以理解为
<ul>
<li>平均的 visibility x 你给定的一个数</li>
</ul></li>
</ul>
<h4 id="一种理解">一种理解</h4>
<p><span class="math display">\[
\int_\Omega f(x)g(x)\,\mathrm{d}x\approx \dfrac{\int_\Omega
f(x)\,\mathrm{d}x}{\int_\Omega \,\mathrm{d}x}\cdot {\int_\Omega
g(x)\,\mathrm{d}x}=\overline{f(x)}\int_\Omega g(x)\,\mathrm{d}x
\]</span></p>
<ul>
<li>我们可以认为，是在求一个 <span class="math inline">\(f(x)\)</span>
在 <span class="math inline">\(g(x)\)</span> 的定义域 <span class="math inline">\(\Omega\)</span> 上求一个平均值</li>
</ul>
<h4 id="准确的条件">准确的条件</h4>
<ul>
<li><span class="math inline">\(g(x)\)</span>：smooth / small
support</li>
<li>所以 AO 的拆分是准确的
<ul>
<li><span class="math inline">\(G\)</span> 是常数</li>
</ul></li>
</ul>
<h4 id="另一种理解">另一种理解</h4>
<ul>
<li><strong>拆分后为什么多了一项 <span class="math inline">\(\cos\theta_i\)</span></strong></li>
</ul>
<p><img src="/2021/04/29/CG/YLQ-GAMES202/08/image-20210429193728599.png" style="zoom:50%;"></p>
<ul>
<li><span class="math inline">\(\mathrm{d}x_{\perp}=\cos\theta_i\,\mathrm{d}\omega_i\)</span>
刚好是立体角投影到平面上的结果</li>
<li>所以我们可以把 <span class="math inline">\(\cos\theta_i\,\mathrm{d}\omega_i\)</span>
整个看成是一项 <span class="math inline">\(\mathrm{d}x_{\perp}\)</span></li>
</ul>
<h3 id="ssao-的简单理解">SSAO 的简单理解</h3>
<ul>
<li>光照为常数，BRDF 为常数</li>
<li>可以从积分项中拿出来</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
L_o(p,\omega_o)&amp;=
\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)
V(p,\omega_i)\cos\theta_i\,\mathrm{d}\omega_i\\
&amp;=\dfrac{\rho}{\pi}\cdot
L_i(p)\cdot\int_{\Omega^+}V(p,\omega_i)\cos\theta_i\,\mathrm{d}\omega_i
\end{aligned}
\]</span></p>
<h3 id="怎么求解可见性屏幕空间">怎么求解可见性(屏幕空间)</h3>
<ul>
<li>对于某一个 shading
point，我们对其法相半球进行采样，求平均可见性</li>
<li>发出 trace 光线，光线距离R，进行可见性判断</li>
</ul>
<p><img src="/2021/04/29/CG/YLQ-GAMES202/08/image-20210429195523419.png" style="zoom:50%;"></p>
<ul>
<li>选取一个指定的半径 R
<ul>
<li>R 不能太大，否则最终都会被挡住（想象一个封闭的屋子）</li>
<li>R 不能太小，否则会忽略一些来自于更远的反射光</li>
<li>trade off</li>
</ul></li>
</ul>
<h3 id="实际求解可见性的方法">实际求解可见性的方法</h3>
<ul>
<li>利用 z-buffer</li>
<li>直接去 trace 光线很难做</li>
</ul>
<p><img src="/2021/04/29/CG/YLQ-GAMES202/08/image-20210429195932778.png" style="zoom:67%;"></p>
<ul>
<li>对于任何一个 shading point，我们对其周围半径 R
内的球体内进行采样</li>
<li>利用深度图（正常光栅化渲染管线渲染都会生成一张深度图）</li>
<li>对每一个采样点，我们将其和深度图中记录的深度作比较
<ul>
<li>采样点经过投影变换得到的深度值如果比深度图中记录的要大，说明被挡住了</li>
</ul></li>
<li>但是这样子是有可能出错的，毕竟记录的是一个 2D 的信息
<ul>
<li>中间那幅图的红色虚线右边的点</li>
<li>它在物体外部，但是根据 SM 的出来的值是在物体内部</li>
<li>SM 中无法记录复杂的几何信息</li>
<li>这样子的小错误在工业界是可以容忍的</li>
</ul></li>
<li>早期使用的是整个球体的采样，而不是法向半球采样，实际上我们使用法相半球采样才是正确的
<ul>
<li>因为早期渲染管线，在最后无法保留法线的值，于是只能用整个球体的采样</li>
<li>早期的解决方案
<ul>
<li><strong>只有在红点个数（被遮挡的点个数）过半的情况下，才开始考虑
AO</strong></li>
</ul></li>
</ul></li>
<li>现在我们直接使用法向半球采样</li>
</ul>
<h3 id="ssao-的问题">SSAO 的问题</h3>
<p><img src="/2021/04/29/CG/YLQ-GAMES202/08/image-20210429201816674.png" style="zoom:57%;"></p>
<ul>
<li>可能会出现一些虚假的 AO（false occlusion）</li>
<li>如右图中，石凳和地面应该没有接触，因此不应该有 AO
的效果，但是我们在之前简单的考虑遮挡，就会产生这样的现象</li>
<li>工业界的解决方案，使用一个半径 R，大于半径 R，我们认为不遮挡</li>
<li>采样点越多，AO 的效果越好
<ul>
<li>怎么在采样点少的情况下获得噪声比较小的结果</li>
<li>先做 AO，然后做一个高斯模糊（去噪）</li>
</ul></li>
</ul>
<h2 id="hbao">HBAO</h2>
<ul>
<li>Horizon based ambient occlusion</li>
<li>SSAO 的改进
<ul>
<li>在<strong>法向半球</strong>内采样</li>
<li>考虑半径 <strong>R</strong></li>
</ul></li>
</ul>
<h2 id="ssdo">SSDO</h2>
<ul>
<li>对 SSAO 的提高</li>
<li>对于间接光照，我们没必要假设所有方向来的光是一样的</li>
<li>我们在一定程度上是能够知道间接光照的
<ul>
<li>从屏幕空间中来</li>
</ul></li>
</ul>
<p><img src="/2021/04/29/CG/YLQ-GAMES202/08/image-20210505102400590.png"></p>
<ul>
<li>SSAO 只能产生变亮变暗的效果，但是不能模拟颜色的变化</li>
<li>做法和 path tracing 很像
<ul>
<li>从 shading point 随机打出射线</li>
<li>如果射线击中了某个物体，产生间接光照</li>
<li>如果涉嫌没有击中物体，直接光照</li>
</ul></li>
</ul>
<h3 id="ao-与-do">AO 与 DO</h3>
<ul>
<li>AO 与 DO 的假设是完全相反的
<ul>
<li>AO 假设间接光照来自于非常远的地方</li>
<li>DO 假设间接光照来自于周围相近的地方</li>
</ul></li>
<li>红色圈内的射线
<ul>
<li>AO 认为有间接光照（没有被物体挡住）</li>
<li>DO 认为没有间接光照（没有击中次级光源/物体）</li>
</ul></li>
<li>黄色圈内的射线
<ul>
<li>AO 认为没有间接光照（被物体挡住了）</li>
<li>DO 认为有间接光照（接种了次级光源/物体）</li>
</ul></li>
</ul>
<p><img src="/2021/04/29/CG/YLQ-GAMES202/08/image-20210505102850841.png" style="zoom:50%;"></p>
<h3 id="ssdo-的实现">SSDO 的实现</h3>
<ul>
<li>如果没有击中物体，没有间接光照（可能是环境光或者是直接光照）</li>
</ul>
<p><span class="math display">\[
L_o^{dir}(p,\omega_o)=
\int_{\Omega^+\;V=1}L_i^{dir}(p,\omega_i)f_r(p,\omega_i,\omega_o)
\cos\theta_i\,\mathrm{d}\omega_i
\]</span></p>
<ul>
<li>击中其他物体，则需要计算间接光照</li>
</ul>
<p><span class="math display">\[
L_o^{indir}(p,\omega_o)=
\int_{\Omega^+\;V=0}L_i^{indir}(p,\omega_i)f_r(p,\omega_i,\omega_o)
\cos\theta_i\,\mathrm{d}\omega_i
\]</span></p>
<h3 id="判断一个点是否可见">判断一个点是否可见</h3>
<p><img src="/2021/04/29/CG/YLQ-GAMES202/08/image-20210505103954288.png" style="zoom:50%;"></p>
<ul>
<li>和 HBAO 一样</li>
<li>判断某个点是否可见，和 HBAO 同样的判断
<ul>
<li>深度与深度图中的记录相比较</li>
<li>限制半径 R</li>
</ul></li>
<li>上图中
<ul>
<li>C 点没有被挡住，因此可以计算环境光照（我们不太关心这一点）</li>
<li>A、B、D 点被挡住了，因此我们需要计算这 3 个点对 shading point 的贡献
<ul>
<li>深度图中的点都是记录了 flux 等信息的（defered shading 的思想）</li>
</ul></li>
</ul></li>
<li>我们判断一个点是否对 P
点可见，使用其深度和深度图中记录值相比较，这是有问题的，例如下图中
<ul>
<li>A 点对 P 点可见，但是我们判断为不可见</li>
<li>B 点对视点可见，但是 PB 这个方向会被其他物体挡住</li>
</ul></li>
</ul>
<p><img src="/2021/04/29/CG/YLQ-GAMES202/08/image-20210505103954299.png" style="zoom:50%;"></p>
<h3 id="ssdo-评价">SSDO 评价</h3>
<h4 id="pros">Pros</h4>
<ul>
<li>质量不错</li>
<li>轻量级计算</li>
</ul>
<h4 id="cons">Cons</h4>
<ul>
<li>可见性（考虑得比较少）</li>
<li>Screen space 丢失了信息
<ul>
<li>例如下图，我们将物体旋转之后，由于视点看不到背面，结果导致地上的反光没了</li>
</ul></li>
</ul>
<p><img src="/2021/04/29/CG/YLQ-GAMES202/08/image-20210505105216389.png"></p>
<ul>
<li>SSDO 只能做到近处的贡献（只考虑了小范围内的贡献）</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES202</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES202.闫令琪.09.实时全局光照(屏幕空间)(SSR)</title>
    <url>/2021/05/05/CG/YLQ-GAMES202/09/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1YK4y1T7yY</li>
</ul>
<h1 id="屏幕空间全局光照">屏幕空间全局光照</h1>
<h2 id="ssr">SSR</h2>
<ul>
<li>Screen Space Reflection
<ul>
<li>Screen Space RayTracing</li>
</ul></li>
<li>屏幕空间上做光线追踪
<ul>
<li>不需要 3D 信息、三角形加速结构等</li>
</ul></li>
<li>Ritschel et al., <a href="https://www.ea.com/frostbite/news/stochastic-screen-space-reflections">Stochastic
Screen-Space Reflections</a>, SIGGRAPH 2015 course
<ul>
<li>作者PPT，<a href="http://advances.realtimerendering.com/s2015/Stochastic%20Screen-Space%20Reflections.pptx">原始网站</a></li>
</ul></li>
</ul>
<h3 id="现实游戏中的反射">现实、游戏中的反射</h3>
<ul>
<li>反射本质上就是全局光照</li>
</ul>
<p><img src="/2021/05/05/CG/YLQ-GAMES202/09/image-20210505112034773.png" style="zoom: 33%;"></p>
<ul>
<li>不评价好坏，工厂地板的反射可能本身就没这么亮</li>
<li>技术是不错的</li>
</ul>
<p><img src="/2021/05/05/CG/YLQ-GAMES202/09/image-20210505112138650.png" style="zoom:33%;"></p>
<h3 id="发现">发现</h3>
<ul>
<li><strong>绝大多</strong>是反射的东西都是在图上有了的东西
<ul>
<li>因此可以直接使用 Screen Space 的东西</li>
<li>白色框选部分反射的是红色框选部分</li>
</ul></li>
</ul>
<p><img src="/2021/05/05/CG/YLQ-GAMES202/09/image-20210505112333707.png" style="zoom:70%;"></p>
<h3 id="一个例子">一个例子</h3>
<ul>
<li>我们想做的是类似<strong>镜面反射</strong>的效果</li>
</ul>
<p><img src="/2021/05/05/CG/YLQ-GAMES202/09/image-20210505163251248.png" style="zoom:50%;"></p>
<ul>
<li>我们渲染好了整个场景，现在试图在地面上加入反射</li>
<li>对于每一个 fragment
<ul>
<li>我们对其求出<strong>反射光线</strong></li>
<li>我们让反射光线和场景求交</li>
</ul></li>
<li><strong>SSR 可以做镜面反射，也可以做 glossy 材质的反射</strong></li>
<li>glossy 材质：采样</li>
<li>SSR 可以做地面不是平面的场景</li>
<li><strong>SSR 可以做任意的光线追踪</strong></li>
</ul>
<h3 id="ssr-思路">SSR 思路</h3>
<ul>
<li>两个问题
<ul>
<li>反射光在哪里</li>
<li>怎么做 shading</li>
</ul></li>
</ul>
<p><img src="/2021/05/05/CG/YLQ-GAMES202/09/image-20210505163631903.png" style="zoom:30%;"></p>
<h3 id="计算发射光位置">计算发射光位置</h3>
<h4 id="linear-raymarch">Linear Raymarch</h4>
<ul>
<li>步进</li>
</ul>
<p><img src="/2021/05/05/CG/YLQ-GAMES202/09/image-20210505164249050.png" style="zoom:70%;"></p>
<ul>
<li>从 shading point
出发，沿着场景一步一步前进，利用深度图判断当前点是否和场景相交</li>
<li>找到相交的点，就把这个点作为次级光源</li>
<li>步长需要给定，怎么定义步长？
<ul>
<li>步长太大，可能找到的点离真实的点很远</li>
<li>步长太小，计算量太大</li>
</ul></li>
</ul>
<h4 id="hierarchical-ray-trace">Hierarchical ray trace</h4>
<ul>
<li>动态决定步长的大小</li>
<li>例如下图中，反射点一开始可以直接走好几格都不会和壳（获得的图片相当于是场景的一个壳）</li>
<li>如果我们能够很快的获得可以走多少格都不会和壳相交，这样效率就会大大提高</li>
</ul>
<p><img src="/2021/05/05/CG/YLQ-GAMES202/09/image-20210505164743420.png" style="zoom:50%;"></p>
<ul>
<li>层次结构，对对深度图做一个 mipmap，但是我们对于上一层的
mipmap，对应区域取的是下一层的<strong>最小值</strong>，而不是平均值
<ul>
<li>min-pooling</li>
</ul></li>
</ul>
<p><img src="/2021/05/05/CG/YLQ-GAMES202/09/image-20210505165208112.png" style="zoom:50%;"></p>
<ul>
<li>取最小值，可以保证我们如果在上层的 mipmap 中不相交，在下层的 mipmap
中也一定不相交
<ul>
<li><strong>保守估计</strong></li>
</ul></li>
</ul>
<p><img src="/2021/05/05/CG/YLQ-GAMES202/09/image-20210505165449662.png" style="zoom:70%;"></p>
<ul>
<li>这样的层次结构就可以允许我们的步进值是好几个格子</li>
<li>从层次机构的根部开始判断
<ul>
<li>如果和上层的 mipmap 不相交，则直接跨过这个区域</li>
<li>如果相交，则进入下一层的 mipmap
<ul>
<li>有两个子结点，但是我们知道应该进入哪一个子结点</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mip = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(level &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    step through current cell;</span><br><span class="line">    <span class="keyword">if</span>(above Z plane) ++level;</span><br><span class="line">    <span class="keyword">if</span>(below Z plane) --level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mipmap 存在问题，做不了起点不在 <span class="math inline">\(2^k\)</span> 上的最小值
<ul>
<li>例如上面的例子，[2, 3] 格子之间的最小值就求不了</li>
</ul></li>
</ul>
<h3 id="ssr-的问题">SSR 的问题</h3>
<ul>
<li>问题源自于屏幕空间</li>
<li>我们不知到我们没有看到的场景是什么，我们只了解一层壳</li>
<li><strong>下图中手掌心没了</strong></li>
</ul>
<p><img src="/2021/05/05/CG/YLQ-GAMES202/09/image-20210505173006720.png" style="zoom: 33%;"></p>
<ul>
<li><strong>下图中地面反射只有一部分窗帘</strong>
<ul>
<li>我们可以根据反射光走的距离进行一个衰减，这样子的话我们可以把边缘虚化，效果会好一点</li>
</ul></li>
</ul>
<p><img src="/2021/05/05/CG/YLQ-GAMES202/09/image-20210505173319014.png" style="zoom: 33%;"></p>
<ul>
<li>虚化后的结果</li>
</ul>
<p><img src="/2021/05/05/CG/YLQ-GAMES202/09/image-20210505173724688.png" style="zoom:33%;"></p>
<h3 id="shading">Shading</h3>
<ul>
<li>SSR 本质上就是把 path tracing
中光线和场景求交的问题转化成了光线和场景的壳求交的问题</li>
<li>所以之前 path tracing 的方法都可以直接使用</li>
</ul>
<p><span class="math display">\[
L_o(p,\omega_o)=
\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)\cos\theta_i\,\mathrm{d}\omega_i\\
\]</span></p>
<ul>
<li>diffuse/glossy：蒙特卡洛采样方法</li>
<li>specular：直接计算即可</li>
<li>我们有一个假设：<strong>反射物（次级光源）是 diffuse 的</strong>
<ul>
<li>和 RSM 一样，不然无法求出 <span class="math inline">\(L_i(p,\omega_i)\)</span></li>
<li><span class="math inline">\(L_i(p,\omega_i)=L_o(q,q\to
p)\)</span></li>
</ul></li>
<li>是否需要距离衰减？
<ul>
<li><strong>不需要</strong></li>
<li>还是对 BRDF 的立体角进行采样，而没有转化为光源的面积</li>
<li>只有对光源采样才会有平方衰减的问题</li>
</ul></li>
<li>次级光源和 shading point 的可见性问题？
<ul>
<li>处理得很好，上面的 hierarchical ray tracing 求出的是第一个交点</li>
<li>只有对光源采样才会出现可见性问题</li>
</ul></li>
</ul>
<h3 id="ssr-可以模拟的结果">SSR 可以模拟的结果</h3>
<ul>
<li><strong>以下现象只要你正确对 BRDF
采样计算，就能自然得到结果</strong></li>
<li>Sharp and blur reflections
<ul>
<li>不同材质的反射结果</li>
</ul></li>
<li>contact hardening
<ul>
<li>shading point 与次级光源离得越近，我们看到的反射越清晰</li>
<li>同样的反射叶，距离越远，圆锥的面积越大，结果就会模糊一些</li>
</ul></li>
<li>specular elongation
<ul>
<li>雨天坐车看到红绿灯，地面看过去，发现红绿灯被垂直上下拉长了</li>
<li>认为地面是各向同性的，法线分布在一个标准的圆上，给定一个观察的方向，BRDF
lobe 应该是一个长条的椭圆</li>
</ul></li>
</ul>
<p><img src="/2021/05/05/CG/YLQ-GAMES202/09/image-20210505194523700.png"></p>
<ul>
<li>per-pixel roughness and normal
<ul>
<li>我们本身没有对这些条件做出假设，因此是可以的</li>
</ul></li>
</ul>
<h3 id="improvements">Improvements</h3>
<ul>
<li>BRDF important sampling</li>
<li>glossy 物体
<ul>
<li>因为反射光线是在一个 lobe 内部，没必要对四面八方均匀采样</li>
<li>只需要选择一个 PDF，让它和这个 lobe 形状一致</li>
</ul></li>
</ul>
<p><img src="/2021/05/05/CG/YLQ-GAMES202/09/image-20210505195534812.png" style="zoom:60%;"></p>
<ul>
<li>复用一些可行的光路，形成新的光路</li>
</ul>
<p><img src="/2021/05/05/CG/YLQ-GAMES202/09/image-20210505195447596.png" style="zoom:60%;"></p>
<ul>
<li>预先模糊
<ul>
<li>Prefiltered samples</li>
<li>Weighed by each BRDF</li>
<li>对于 lobe 多次采样，等价于预先模糊再在镜面反射的方向上采样一次
<ul>
<li>问题，屏幕空间上不同的点深度是不一样的</li>
<li>怎么做 filter 是个问题</li>
</ul></li>
</ul></li>
</ul>
<h3 id="ssr-评价">SSR 评价</h3>
<h4 id="pros">Pros</h4>
<ul>
<li>Fast performance for glossy and specular reflections</li>
<li>Good quality</li>
<li>No spikes and occlusion issues</li>
</ul>
<h4 id="cons">Cons</h4>
<ul>
<li>Not as efficient in the diffuse case
<ul>
<li>需要打出大量光线</li>
</ul></li>
<li>Missing information outside the screen</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES202</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES202.闫令琪.10.基于物理的材质(微表面模型)</title>
    <url>/2021/05/12/CG/YLQ-GAMES202/10/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1YK4y1T7yY</li>
</ul>
<h1 id="基于物理的材质">基于物理的材质</h1>
<h2 id="pbr-vs-pbr-material">PBR vs PBR Material</h2>
<ul>
<li>PBR：Physically-Based Rendering（基于物理的渲染）
<ul>
<li>所有在渲染中涉及到的东西都必须是物理的</li>
<li>材质、光照、相机、光线传播等
<ul>
<li>material、light、camera、light transport</li>
<li>透镜、透镜组</li>
</ul></li>
<li><strong>PBR
不仅限于材质，但是实时渲染领域通常就是指材质</strong></li>
</ul></li>
<li>实时渲染材质的落后于离线渲染
<ul>
<li>丰富程度
<ul>
<li>实时渲染用的材质一般都是研究的比较透彻的，能够比较快的渲染</li>
</ul></li>
<li>准确度（质量）
<ul>
<li>为了速度，牺牲质量</li>
<li><strong>头发</strong> 的渲染</li>
<li>实时渲染是在保证速度的前提下提高质量</li>
</ul></li>
<li>”PB“ 在实时渲染中并没有那么物理
<ul>
<li>做了大量的简化</li>
</ul></li>
</ul></li>
</ul>
<h2 id="实时渲染中的-pbr">实时渲染中的 PBR</h2>
<ul>
<li>主要有两类：surface、volume</li>
<li>在表面上定义的、在体积上定义的</li>
</ul>
<h3 id="surface">surface</h3>
<ul>
<li>在物体表面上定义的</li>
<li>microfacet models
<ul>
<li>实际于物理的描述</li>
<li>但有时候不正确的使用，则不是 PBR</li>
</ul></li>
<li>disney principled BRDFS：基于 Disney 的原则设计的 BRDF
<ul>
<li>发明的时候希望被用于离线渲染，但同时也能被用在实时渲染之中</li>
<li>轻量级的计算，实现简单</li>
<li>能够表示材质种类很多，效果也非常不错</li>
<li>不是 PBR 的</li>
<li>artist friendly：为了艺术家使用方便而设计的</li>
<li>总体而言描述的还是挺好的，但是在细节上还是不完美</li>
<li>一张效果图：左（照片）、右（渲染图）
<ul>
<li>渲染器：Hyperion</li>
<li>最早的 Disney 工作室所在的街的名字</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512132930074.png" style="zoom: 67%;"></p>
<h3 id="volume">volume</h3>
<ul>
<li>在体积上定义的
<ul>
<li>更加困难</li>
</ul></li>
<li>mostly focused on fast and approximate single scattering and
multiple scattering</li>
<li><strong>cloud</strong>, <strong>hair</strong>,
<strong>skin</strong>, etc
<ul>
<li>烟雾、云、皮肤、头发</li>
</ul></li>
</ul>
<h3 id="实时渲染">实时渲染</h3>
<ul>
<li>实时渲染中材质并没有很多其他的新理论</li>
<li>但是会有很多实现上的 hacks
<ul>
<li>为了降低开销</li>
</ul></li>
<li>速度是前提
<ul>
<li>speed、performance</li>
</ul></li>
</ul>
<h2 id="microfacet-brdf">Microfacet BRDF</h2>
<ul>
<li>微表面模型</li>
<li><a href="/2021/03/21/CG/YLQ-GAMES101/07/">GAMES101
中有所介绍</a></li>
<li>微表面的 BRDF：<strong>微观</strong>
<ul>
<li>微表面的法线各不相同</li>
<li>这些法线的不同分布造成最终渲染结果的不同</li>
</ul></li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512134827072.png" style="zoom: 50%;"></p>
<ul>
<li>F 项：菲涅尔项，从一个角度看过去有多少能量会被反射</li>
<li>G 项：shadowing masking</li>
<li>D 项：微表面的法线分布
<ul>
<li><strong>半程向量</strong>和<strong>微表面的法线</strong>一致的情况下，才能把光线从入射方向反射到出射方向去</li>
</ul></li>
</ul>
<h3 id="菲涅尔项">菲涅尔项</h3>
<ul>
<li>The Fresnel Term</li>
<li>反射的能量和入射角的方向有关</li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512140332729.png" style="zoom: 67%;"></p>
<ul>
<li>绝缘体（Dieletric）、导体（Conduct）的性质不太一样
<ul>
<li><a href="/2021/03/21/CG/YLQ-GAMES101/07/">GAMES101</a></li>
</ul></li>
<li>Schlick's approximation</li>
</ul>
<p><span class="math display">\[
R(\theta) =R_{0}+\left(1-R_{0}\right)(1-\cos \theta)^{5}
\]</span></p>
<p><span class="math display">\[
R_{0} =\left(\frac{n_{1}-n_{2}}{n_{1}+n_{2}}\right)^{2}
\]</span></p>
<h3 id="ndf">NDF</h3>
<ul>
<li>Normal Distribution Function</li>
<li>微表面的法线分布函数</li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512141142682.png" style="zoom:67%;"></p>
<ul>
<li>分布比较集中：glossy -&gt; specular</li>
<li>分布比较散乱：diffuse</li>
<li>怎么让微表面在不同材质之间变化
<ul>
<li>高度场上下做一个拉伸（scale）</li>
<li>上下做一个拉伸之后
<ul>
<li>可以让法线的分布不再集中，从 glossy 转变为 diffuse</li>
<li>相当于把所有面变得倾斜过来了</li>
<li>微表面之间形成的沟壑变得越来越深，形成粗糙的表面</li>
</ul></li>
</ul></li>
<li>NDF：微表面的<strong>法线分布函数</strong>
<ul>
<li>二维</li>
</ul></li>
<li>有很多描述 NDF 的模型
<ul>
<li>Beckmann, GGX, etc</li>
<li>Detailed models [Yan 2014, 2016, 2018, …]
<ul>
<li>实时渲染中用的比较少，代价太大</li>
</ul></li>
</ul></li>
<li>怎么把一个 2D 的分布函数可视化在一个平面上？
<ul>
<li>法线，半球面的分布（不能向下）</li>
<li>从上往下拍扁即可，projected solid angle</li>
</ul></li>
</ul>
<h4 id="beckmann-ndf">Beckmann NDF</h4>
<p><span class="math display">\[
D(h)=\dfrac{e^{-\dfrac{\tan^2\theta_h}{\alpha^2}}}{\pi\alpha^2\cos^4\theta_h}
\]</span></p>
<ul>
<li>和高斯函数很像</li>
<li>高斯函数
<ul>
<li>高斯函数是对正态函数的一个更通用的抽象</li>
<li>表示一类中间高，往两边衰减的函数分布</li>
</ul></li>
<li><span class="math inline">\(\alpha\)</span>：一个参数，描述粗糙程度（正态函数中的方差
<span class="math inline">\(\sigma\)</span> ）
<ul>
<li><span class="math inline">\(\alpha\)</span> 越小，越趋向于镜面
specular</li>
</ul></li>
<li><span class="math inline">\(\theta_h\)</span>：法线（镜面：垂直表面）和半程向量所成的夹角</li>
<li><strong>各向同性的</strong>，不涉及 <span class="math inline">\(\phi\)</span>
<ul>
<li>复杂的 Beckmann NDF 是可以描述各向异性的材质的</li>
</ul></li>
<li>为什么分子中是 <span class="math inline">\(\tan^2\theta_h\)</span>
而不是 <span class="math inline">\(\theta^2_h\)</span> ？
<ul>
<li>Beckmann NDF 是定义在坡度空间上的（<strong>slope
space</strong>）</li>
<li>高斯函数本身的定义域是无限大的，定义在 <span class="math inline">\(\tan\theta_h\)</span> 上可以满足当 <span class="math inline">\(\theta_h\)</span> 取遍 <span class="math inline">\([0,\dfrac{\pi}{2}]\)</span>，满足这个无限大的条件</li>
<li>保证了<strong>不会有微表面的法线是朝下的</strong></li>
</ul></li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512145652158.png" style="zoom:50%;"></p>
<ul>
<li>分母项
<ul>
<li>归一化项</li>
<li>让 NDF 在 projected solid angle 上积分为 1</li>
</ul></li>
</ul>
<h4 id="ggx-ndf">GGX NDF</h4>
<ul>
<li>GGX (or Trowbridge-Reitz) [Walter et al. 2007]</li>
<li>TR 模型</li>
<li>特点：长尾的（long tail）</li>
<li>GGX 会很快衰减没但是衰减到一定程度之后，速度会变慢，导致长尾
<ul>
<li>grazing angle 还不会是 0</li>
</ul></li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512151311797.png" style="zoom:67%;"></p>
<ul>
<li>GGX 能够看到周围的光晕现象
<ul>
<li>GGX 的效果更加自然</li>
</ul></li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512151536925.png" style="zoom:50%;"></p>
<h4 id="extending-ggx">Extending GGX</h4>
<ul>
<li>Extending GGX [by <strong>Brent Burley</strong> from WDAS]</li>
<li>Walt Disney Animation Studios</li>
<li>迪士尼动画工作室</li>
<li><strong>GTR</strong> (Generalized Trowbridge-Reitz)</li>
<li>Even longer tails</li>
<li>定义了一个参数 <span class="math inline">\(\gamma\)</span>，当 <span class="math inline">\(\gamma=2\)</span> 的时候，就是 GGX
<ul>
<li>当 <span class="math inline">\(\gamma\)</span>
取的比较大的时候，会接近于 Backmann 的效果（有趣）</li>
</ul></li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512152230598.png" style="zoom:50%;"></p>
<h3 id="shadowing-masking">Shadowing-Masking</h3>
<ul>
<li>几何项 G</li>
<li>微表面之间的互相遮挡问题
<ul>
<li>尤其是在 grazing angle 的时候</li>
</ul></li>
<li>入射光、反射光都可能被遮挡</li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512152705978.png" style="zoom:70%;"></p>
<ul>
<li>Shadowing：light（左）</li>
<li>Masking：eye（右）</li>
<li>体现由于遮挡导致的变暗的现象</li>
<li><span id="G_item_character">基本性质</span>
<ul>
<li>靠近 grazing angle 的时候，接近于 0</li>
<li>接近法线的时候，接近于 1</li>
</ul></li>
</ul>
<h4 id="g-term-的重要性">G term 的重要性</h4>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512153103820.png" style="zoom:50%;"> <span class="math display">\[
f(\mathbf{i}, \mathbf{o})=\frac{\mathbf{F}(\mathbf{i}, \mathbf{h})
\mathbf{G}(\mathbf{i}, \mathbf{o}, \mathbf{h})
\mathbf{D}(\mathbf{h})}{4(\mathbf{n}, \mathbf{i})(\mathbf{n},
\mathbf{o})}
\]</span></p>
<ul>
<li>如果不考虑 G 项
<ul>
<li>在边缘的地方，分母 <span class="math inline">\(n\cdot i\)</span>
接近于 0</li>
<li>导致结果巨大，渲染的结果就是边缘有白色的亮圈</li>
<li>这是不符合物理规律的</li>
</ul></li>
</ul>
<h4 id="the-smith-shadowing-masking-term">The Smith shadowing-masking
term</h4>
<ul>
<li>一个常用的 shadowing-masking 项</li>
<li>理论非常复杂</li>
<li>在具体的发现分布之下推导出一个 G 项</li>
<li>把 shadowing 和 masking 拆开考虑
<ul>
<li>但实际上是有关的</li>
<li><span class="math inline">\(m\)</span> 是半程向量</li>
</ul></li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512153704997.png" style="zoom: 33%;"></p>
<ul>
<li>一个例子</li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512153741268.png" style="zoom: 50%;"></p>
<ul>
<li><a href="#G_item_character">G 项的特征</a></li>
</ul>
<h3 id="multiple-bounces">Multiple Bounces</h3>
<ul>
<li>微表面模型还存在一个其他问题：<strong>能量损失</strong></li>
<li><a href="https://fpsunflower.github.io/ckulla/data/s2017_pbs_imageworks_slides_v2.pdf">该部分链接</a></li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512154111914.png"></p>
<ul>
<li>roughness 变化</li>
<li>存在的问题，从左到右结果越来越暗了
<ul>
<li>高光到哑光，亮度应该是差不多的</li>
</ul></li>
</ul>
<h4 id="白炉测试">白炉测试</h4>
<ul>
<li>The White Furnace Test</li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512154553425.png"></p>
<ul>
<li>一个实验，空的背景，环境光照各处都是一样的，先保证在 roughness
比较低的情况下，反射出来的颜色和背景一样</li>
<li>随着 roughness 增大，颜色越来越暗，出现能量损失现象</li>
</ul>
<h4 id="为什么会有能量损失">为什么会有能量损失</h4>
<ul>
<li>roughness 越大
<ul>
<li>沟壑越多，光线越容易被挡住</li>
<li>多次弹射的光线占比的可能性越大</li>
<li>如果我们在使用微表面模型的时候只考虑单次
bounce，损失的能量就越多</li>
</ul></li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512155104802.png"></p>
<h4 id="解决能量损失的问题">解决能量损失的问题</h4>
<ul>
<li>基本思想，把损失的能量补回来
<ul>
<li>Heitz et al. 2016</li>
<li>准确计算多次 bounce</li>
<li>很慢</li>
</ul></li>
<li>基本思想
<ul>
<li>如果一束光被遮挡了，说明这一束光发生了下一次的反射</li>
</ul></li>
</ul>
<h4 id="the-kulla-conty-approximation">The Kulla-Conty
Approximation</h4>
<ul>
<li>一个近似方法</li>
<li>经验性的方式补全丢失的能量</li>
<li>怎么求出丢失的能量？</li>
<li>先算出出射的总能量（这里求解的 BRDF
就是上面考虑了各种项的结果，因此计算出来的结果应该是有损失的）
<ul>
<li>对所有的入射方向的入射光做一个积分</li>
<li>我们假设所有方向的入射光 radiance 都是 1，<span class="math inline">\(L_i=1\)</span></li>
<li>这里的 <span class="math inline">\(\cos\theta\)</span> 项哪去了？
<ul>
<li><span class="math inline">\(\mathrm{d}\omega=\sin\theta\;\mathrm{d}\theta\;\mathrm{d}\phi\)</span></li>
<li><span class="math inline">\(\cos\theta\;\mathrm{d}\omega=\sin\theta\;\mathrm{d}\sin\theta\;\mathrm{d}\phi\)</span></li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
E(\mu_o)=\int_{0}^{2\pi}\int_{0}^{1}f(\mu_o,\mu_i,\phi)\mu_i\;\mathrm{d}\mu_i\;\mathrm{d}\phi
\]</span></p>
<p><span class="math display">\[
\mu=\sin\theta
\]</span></p>
<ul>
<li>那么损失的能量就是 <span class="math inline">\(1-E(\mu_o)\)</span>
<ul>
<li>损失的能量和观察方向是相关的</li>
</ul></li>
<li>关键思想就是把上面的能量补上</li>
</ul>
<h5 id="一种设计">一种设计</h5>
<ul>
<li>补上另外一种 BDRF，使得最终积分的结果为 <span class="math inline">\(1-E(\mu_o)\)</span></li>
<li>考虑对称性，我们还有另外一项
<ul>
<li><span class="math inline">\(c(1-E(\mu_o))(1-E(\mu_i))\)</span></li>
<li><span class="math inline">\(c\)</span> 为归一化项</li>
</ul></li>
<li><strong>我们可以设计其他的积分函数</strong>，使得积分结果为 <span class="math inline">\(1-E(\mu_o)\)</span> 即可</li>
<li>这种设计比较自然</li>
</ul>
<p><span class="math display">\[
c=f_{ms}(\mu_o,\mu_i)=\dfrac{(1-E(\mu_o))(1-E(\mu_i))}{\pi(1-E_{avg})}
\]</span></p>
<p><span class="math display">\[
E_{avg}=\dfrac{\int_0^1E(\mu)\mu\;\mathrm{d}\mu}{\int_0^1\mu\;\mathrm{d}\mu}=2\int_0^1E(\mu)\mu\;\mathrm{d}\mu
\]</span></p>
<ul>
<li>验证</li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512161642746.png" style="zoom:50%;"></p>
<ul>
<li>新的问题，怎么计算我们的 <span class="math inline">\(E_{avg}\)</span></li>
<li>对于复杂积分的求解
<ul>
<li>预计算 、打表</li>
<li>precompute、tabulate</li>
</ul></li>
<li>参数
<ul>
<li><span class="math inline">\(\mu_o\)</span></li>
<li>具体 BDRF 的参数
<ul>
<li>简单的 NDF 可以用 roughness</li>
</ul></li>
</ul></li>
<li>打表</li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512162106796.png" style="zoom:50%;"></p>
<ul>
<li>结果</li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512154111914.png"></p>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512162437672.png"></p>
<h5 id="如果-brdf-有颜色">如果 BRDF 有颜色</h5>
<ul>
<li>Color == absorption == energy loss (as it should)</li>
<li>有颜色，表明有吸收，也就是存在能量损失（这些能量的损失是应该损失的，被吸收）</li>
<li>那么就导致原始的积分结果不是 1</li>
<li>我们先考虑没有颜色吸收，按照上面的思路计算出结果，然后再考虑由于颜色吸收导致的能量损失</li>
</ul>
<h6 id="the-average-fresnel">the average Fresnel</h6>
<ul>
<li>计算一个平均的 Fresnel 项，对不同的入射角进行积分</li>
<li>为什么这么做呢？因为颜色的吸收只会出现在 Fresnel 项中</li>
</ul>
<p><span class="math display">\[
F_{avg}=\dfrac{\int_0^1F(\mu)\mu\;\mathrm{d}\mu}{\int_0^1\mu\;\mathrm{d}\mu}=2\int_0^1F(\mu)\mu\;\mathrm{d}\mu
\]</span></p>
<ul>
<li><span class="math inline">\(E_{avg}\)</span>
项是不会参与大后续的多次 bounce 中的
<ul>
<li>参与到后续 bounce 中的是 <span class="math inline">\(1-E(\mu_o)\)</span></li>
</ul></li>
</ul>
<h6 id="把最终能够看到的能量分类">把最终能够看到的能量分类</h6>
<ul>
<li>直接能看到的能量：<span class="math inline">\(F_{avg}E_{avg}\)</span></li>
<li>1 次反射之后看到的能量：<span class="math inline">\(F_{avg}(1-E_{avg})F_{avg}E_{avg}\)</span></li>
<li>...</li>
<li><span class="math inline">\(k\)</span> 次反射之后看到的能量：<span class="math inline">\(F_{avg}^k(1-E_{avg})^kF_{avg}E_{avg}\)</span></li>
<li>对上面的能量求和</li>
</ul>
<p><span class="math display">\[
\dfrac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}
\]</span></p>
<ul>
<li>我们将这个系数直接乘到直接计算出来的没有考虑吸收的结果之上即可
<ul>
<li><strong>乘到增加的 BRDF 之上（而不是原来的）</strong></li>
</ul></li>
<li>RGB 3 通道是分开计算的</li>
</ul>
<h6 id="结果">结果</h6>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512170106198.png"></p>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512170118253.png"></p>
<h4 id="不正确的-hack">不正确的 Hack</h4>
<ul>
<li>微表面模型比较暗，我们再直接加上一个 diffuse lobe 的结果</li>
</ul>
<p><img src="/2021/05/12/CG/YLQ-GAMES202/10/image-20210512170357957.png"></p>
<ul>
<li>问题
<ul>
<li>物理上完全错误</li>
<li>不能保证能量守恒
<ul>
<li>如果加上一个 diffuse lobe 但是能够保证能量守恒，那是正确的</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES202</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES202.闫令琪.11.基于物理的材质与非真实感渲染</title>
    <url>/2021/05/22/CG/YLQ-GAMES202/11/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1YK4y1T7yY</li>
</ul>
<h1 id="基于物理的材质">基于物理的材质</h1>
<ul>
<li>Shading Microfacet Models using Linearly Transformed Cosines
(LTC)</li>
<li>使用 LTC 方法对微表面模型进行着色</li>
<li>LTC 方法可以用于简单反射叶（lobe）模型的着色
<ul>
<li>lobe：固定入射方向的反射叶，2D sliced BRDF</li>
</ul></li>
</ul>
<h2 id="ltc">LTC</h2>
<ul>
<li>Linearly Transformed Cosines</li>
<li>线性变换的余弦</li>
<li>主要针对的是 GGX 法线分布的模型（其他的模型也 OK）</li>
<li>不考虑 shadow</li>
<li>解决的是微表面模型下，<strong>多边形光源</strong>的 shading
<ul>
<li>the split sum 做的是环境光下的 shading，和 LTC 不一样</li>
</ul></li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522153653136.png" style="zoom:50%;"></p>
<ul>
<li>如果没有 LTC 方法的话，如何做多边形光源下的 shading
<ul>
<li>需要做采样</li>
<li>在多边形的光源上取很多采样点</li>
<li>然后将这些采样点和 shading point 连线，求出 shading</li>
</ul></li>
<li><strong>LTC 不需要采样</strong></li>
</ul>
<h3 id="ltc-的关键想法">LTC 的关键想法</h3>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522161357852.png" style="zoom: 67%;"></p>
<ul>
<li>lobe 可以通过某种线性变换，变换成一个余弦函数</li>
<li>多边形的光源也可以有类似的变换
<ul>
<li>例如上面的四边形，对四个顶点进行变换</li>
<li>然后用变换后的结果进行 shading</li>
</ul></li>
<li>原来做渲染方程的积分不好做，但是经过上面的变换之后是<strong>有解析解</strong>的
<ul>
<li>将任意的 lobe 在任意的多边形光源下的积分问题转变为固定的 cosine
下对任意的多边形光源下进行积分的问题</li>
<li>假设多边形内部是均匀的，任意的点对 shading point 的 radiance
都是相同的</li>
</ul></li>
</ul>
<h3 id="具体的操作">具体的操作</h3>
<ul>
<li>我们观察到 2D 的 BRDF lobe 可以变幻成一个余弦
<ul>
<li><span class="math inline">\(\mathrm{BRDF\;lobe}{\buildrel{M^{-1}}\over\longrightarrow}\mathrm{Cosine}\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522162225689.png" style="zoom:67%;"></p>
<ul>
<li>我们需要对所有的方向进行一个变换
<ul>
<li><span class="math inline">\(\omega_i{\buildrel{M^{-1}}\over\longrightarrow}\omega_i&#39;\)</span></li>
</ul></li>
<li>积分域发生变化
<ul>
<li><span class="math inline">\(P{\buildrel{M^{-1}}\over\longrightarrow}P&#39;\)</span></li>
</ul></li>
<li>结果如下</li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522162343163.png" style="zoom:67%;"></p>
<h3 id="ltc-的推导">LTC 的推导</h3>
<ul>
<li>我们所做的事情就是变换积分变量</li>
<li>我们在这里假设，多边形光源的 radiance 是相同（uniform）的（<span class="math inline">\(L_i\)</span> 相同）
<ul>
<li>论文中可以通过其他的方法去掉这个假设</li>
</ul></li>
<li>新的方向经过 <span class="math inline">\(M\)</span>
变换，可以变成原来的方向
<ul>
<li>注意我们上面用的符号是 <span class="math inline">\(M^{-1}\)</span></li>
<li><span class="math inline">\(w_i=\dfrac{M\omega_i&#39;}{\Vert
M\omega_i&#39;\Vert}\)</span></li>
<li>归一化的原因是，单元球上的点我们的变换操作可能不在单位球上（长度发生变化）</li>
</ul></li>
<li>渲染方程的变化
<ul>
<li><span class="math inline">\(F\)</span> 变换到 Cosine 上
<ul>
<li>具体怎么变换，在 Paper 中作了很多预计算</li>
<li>通过优化方法计算</li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
L(\omega_o)&amp;=L_i\cdot\int_PF(\omega_i)\;\mathrm{d}\omega_i\\
&amp;=L_i\cdot\int_{P&#39;}\cos(\omega_i&#39;)\;\mathrm{d}\dfrac{M\omega_i&#39;}{\Vert
M\omega_i&#39;\Vert}\\
&amp;=L_i\cdot\int_{P&#39;}\cos(\omega_i&#39;)J\;\mathrm{d}\omega_i&#39;\\
\end{aligned}
\]</span></p>
<h3 id="ltc-渲染结果">LTC 渲染结果</h3>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522164229335.png"></p>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522164237490.png" style="zoom: 67%;"></p>
<h3 id="ltc-总结">LTC 总结</h3>
<ul>
<li>shadow 的问题
<ul>
<li>可以先做 LTC，再通过其他方法计算 shadow</li>
</ul></li>
<li>如果多边形光源不是 uniform 的，比如光源带纹理
<ul>
<li>这样 LTC 就不准确，但是也是一个好的近似</li>
</ul></li>
<li>各向异性的表面能不能变换到 Cosine
<ul>
<li>是可以的，入射方向确定之后，出射方向就是一个 lobe</li>
</ul></li>
</ul>
<h2 id="disneys-principled-brdf">Disney’s Principled BRDF</h2>
<ul>
<li>Disney 原则的 BRDF</li>
</ul>
<h3 id="动机-motivation">动机 Motivation</h3>
<ul>
<li>微表面模型对于真实的材质表示的不是很好
<ul>
<li>例如 diffuse 项缺失
<ul>
<li>虽然我们可以通过某些方法可以补上，但是还是存在一些其他问题</li>
</ul></li>
<li>微表面模型 fit 不了我们一些实测的材质
<ul>
<li>例子：刷了清漆的桌子
<ul>
<li>高光+diffuse</li>
<li>高光：清漆上的反射</li>
<li>diffuse：进入清漆之后打到木板上的反射</li>
<li>微表面模型模拟不了</li>
</ul></li>
<li>多层材质</li>
</ul></li>
<li>微表面模型表示不了所有的东西</li>
</ul></li>
<li>微表面模型不好用，对于艺术家们来说不友好
<ul>
<li>例如金属的折射率是一个复数：<span class="math inline">\(n-ik\)</span>，可能不好理解，不好调</li>
</ul></li>
</ul>
<h3 id="设计目标">设计目标</h3>
<ul>
<li>Art directable，使用起来比较友好</li>
<li>物理上并不是很准确，只是在一定程度上保证正确</li>
<li>在实时渲染中，PBR 做了很多近似，因此还是认为这种方法是 PBR 的</li>
</ul>
<h3 id="一些设计原则">一些设计原则</h3>
<ul>
<li>Intuitive rather than physical parameters should be used.
<ul>
<li>使用的参数需要更直观一点，而不是生硬的物理参数</li>
</ul></li>
<li>There should be as few parameters as possible.
<ul>
<li>参数越少越好（调起来方便）</li>
</ul></li>
<li>Parameters should be zero to one over their plausible range.
<ul>
<li>参数设置为 0-1 的拖动条</li>
</ul></li>
<li>Parameters should be allowed to be pushed beyond their plausible
range where it makes sense.
<ul>
<li>有时候允许结果超出原始的范围（营造特殊的效果）</li>
</ul></li>
<li>All combinations of parameters should be as robust and plausible as
possible.
<ul>
<li>所有组合应该都是可以的（不会导致程序崩溃）</li>
</ul></li>
</ul>
<h3 id="一个例子">一个例子</h3>
<ul>
<li>某些参数及其效果
<ul>
<li>表示能力很强大</li>
<li>参数可能有冗余</li>
</ul></li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522171008715.png"></p>
<ul>
<li>subsurface：次表面散射
<ul>
<li>用来描述光线穿过透明/半透明表面时发生散射的照明现象，是指光从表面进入物体经过内部散射，然后又通过物体表面的其他顶点出射的光线传递过程</li>
<li>效果：比 diffuse 还要平的效果（求被按扁了的效果）</li>
</ul></li>
<li>metallic：金属性</li>
<li>specular：镜面反射的强度</li>
<li>specular
Tint：镜面反射的颜色更偏向于白色（0）还是物体本身的颜色</li>
<li>roughness：粗糙程度</li>
<li>anisotropic：各向异性程度</li>
<li>sheen：天鹅绒的效果
<ul>
<li>沿着法线长了很多绒毛，在 grazing angle 看过去会有一种雾化的效果</li>
</ul></li>
<li>sheen Tint：sheen 的颜色是偏白还是物体本身的颜色</li>
<li>clearcoat：木板上刷一层清漆的效果</li>
<li>clearcoat Gloss：清漆的光滑程度（粗糙程度反一下）</li>
</ul>
<h3 id="pros-and-cons">Pros and Cons</h3>
<ul>
<li>容易理解和使用</li>
<li>表示能力很强大</li>
<li>实现是开源的，很多实现是对基于物理材质的近似</li>
<li>不是基于物理的
<ul>
<li>牺牲了物理上的准确性</li>
<li>学术界和工业界的不同</li>
</ul></li>
<li>参数空间很大
<ul>
<li>表示能力很强</li>
<li>可能有冗余</li>
<li>难以学习和训练</li>
</ul></li>
<li>模型本身是拟合能量守恒的</li>
</ul>
<h1 id="npr">NPR</h1>
<ul>
<li>非真实感渲染</li>
<li>Non-Photorealistic Rendering (NPR)</li>
<li>实时渲染中
<ul>
<li>NPR == fast and reliable stylization</li>
<li>这也是神经网络不能够应用于 NPR
中的原因，可能不满足其中的某个因素</li>
</ul></li>
</ul>
<h2 id="photorealistic-rendering">Photorealistic Rendering</h2>
<ul>
<li>照片级真实感渲染</li>
<li>正确的阴影、光照、几何、材质</li>
<li>目标是渲染出更加真实的图片，达到照片级的效果</li>
<li>左右，一半是渲染，一半是真实
<ul>
<li>原作者记不清了，没有参考答案</li>
</ul></li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522174304452.png" style="zoom:50%;"></p>
<h2 id="npr-目标">NPR 目标</h2>
<ul>
<li>目标是营造一种艺术效果</li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522174600616.png" style="zoom:60%;"></p>
<h2 id="npr-的思路">NPR 的思路</h2>
<ul>
<li>从真实感渲染出发，将某些部分简化，将某些重要的部分加强
<ul>
<li>Starts from photorealistic rendering</li>
<li>Exploits abstraction</li>
<li>Strengthens important parts</li>
</ul></li>
</ul>
<h2 id="npr-的应用">NPR 的应用</h2>
<ul>
<li>art、visualization、instruction、education、entertainment</li>
<li>艺术、可视化、说明书、教育（小孩子绘画）、娱乐</li>
<li>说明书中非真实的图片可能更能够说明问题</li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522174952337.png"></p>
<ul>
<li>游戏应用
<ul>
<li>[Atelier Ryza 2: Lost Legends &amp; the Secret Fairy]</li>
</ul></li>
<li>动漫
<ul>
<li>[Attack on Titan, Season 4]</li>
<li>虽然是 NPR，同时保留了很多真实感渲染的部分</li>
</ul></li>
</ul>
<h2 id="哪些地方需要做风格化">哪些地方需要做风格化</h2>
<ul>
<li>[Xenoblade Chronicles 2]
<ul>
<li>焰、光</li>
</ul></li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522175250659.png" style="zoom:50%;"></p>
<ul>
<li>Borderlands 3</li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522175412405.png" style="zoom: 70%;"></p>
<ul>
<li>描边：Bold contours（outlines）</li>
<li>色块：Blocks of colors</li>
<li>素描的效果：Strokes on surfaces</li>
</ul>
<h3 id="outline-rendering">Outline Rendering</h3>
<h4 id="什么是边">什么是边</h4>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522175622716.png" style="zoom:50%;"></p>
<ul>
<li>outlines 不仅仅是 contours
<ul>
<li>[B]oundary / border edge：边界</li>
<li>[C]rease：折痕</li>
<li>[M]aterial edge：材质的连接</li>
<li>[S]ilhouette edge：轮廓
<ul>
<li>在物体的外面一圈的轮廓上（2D 最外边的轮廓）</li>
<li>得是多个面共享的边界</li>
<li>S 是 C 的子集</li>
</ul></li>
</ul></li>
</ul>
<h4 id="描边的思路">描边的思路</h4>
<ul>
<li>shading 方法来做</li>
<li>修改几何</li>
<li>后期图像处理</li>
</ul>
<h4 id="shading-方法描边">Shading 方法描边</h4>
<ul>
<li>只能做 silhouette 的边</li>
<li>对于封闭的物体，什么样的边是 silhouette 边呢？
<ul>
<li><strong>观察的方向和法线几乎垂直的边</strong></li>
<li>grazing angle</li>
</ul></li>
<li>渲染的时候可以为夹角设置一个阈值 threshold
<ul>
<li>域值越小，被认为是边缘的点越多，最终形成的边缘越粗</li>
</ul></li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522202842564.png" style="zoom: 33%;"></p>
<ul>
<li>step：硬边界</li>
<li>smooth step：过渡的效果</li>
</ul>
<h5 id="问题">问题</h5>
<ul>
<li>不同位置的边的粗细不一致
<ul>
<li>法线变换比较平滑的地方，边比较粗</li>
</ul></li>
</ul>
<h4 id="geometry-方法描边">Geometry 方法描边</h4>
<ul>
<li>Backface fattening</li>
<li>把所有的背向面扩大一圈渲染成黑的，正向面正常渲染</li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522203233929.png" style="zoom:50%;"></p>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522203244568.png" style="zoom:50%;"></p>
<h4 id="image-方法描边">Image 方法描边</h4>
<ul>
<li>后期图像处理</li>
<li>Edge detection（边缘检测）
<ul>
<li>Sobel detector</li>
</ul></li>
<li>锐化操作：边界增强，找到边界，加回到原来的图上</li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522203533535.png" style="zoom:50%;"></p>
<ul>
<li>可以通过其他辅助图像找到边界
<ul>
<li>法线、深度图</li>
</ul></li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522203740986.png" style="zoom: 33%;"></p>
<h3 id="color-blocks">Color blocks</h3>
<ul>
<li>色块效果</li>
<li>下图：glossy、diffuse、color block</li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522203921025.png" style="zoom:50%;"></p>
<ul>
<li>实现方法
<ul>
<li>Hard shading：thresholding on shading
<ul>
<li>正常计算 shading，对计算出来的结果进行一个阈值化</li>
</ul></li>
<li>Posterization：thresholding on final image color
<ul>
<li>在最终的图片上进行阈值化</li>
</ul></li>
</ul></li>
<li>阈值化可以是多值化，也可以是二值化
<ul>
<li>Quantization（量化）</li>
</ul></li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522204142321.png" style="zoom:80%;"></p>
<ul>
<li>在不同的部分（specular、diffuse）上使用不同的阈值化方法</li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522204304560.png" style="zoom:67%;"></p>
<h3 id="strokes-surface-stylization">Strokes Surface Stylization</h3>
<ul>
<li>素描的效果</li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522212218788.png" style="zoom:50%;"></p>
<ul>
<li>什么是素描的效果？
<ul>
<li>打格子</li>
<li>密度：使用<strong>格子的密度</strong>表示<strong>明暗效果</strong></li>
<li>连续性：使用纹理代替点的计算，保证笔触的连续性</li>
</ul></li>
<li>设计几种不同密度的纹理
<ul>
<li>我们希望在远处，不会变得越来越暗，导致全黑</li>
<li>我们自己做一个 Mipmap，缩小之后不改变密度（相当于截取一部分）</li>
</ul></li>
<li>Tonal art maps (TAMs)
<ul>
<li>Strokes of different densities</li>
<li>Each density has a MIPMAP</li>
</ul></li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522212429396.png" style="zoom:50%;"></p>
<ul>
<li>一些其他方法</li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522212758582.png" style="zoom:67%;"></p>
<h2 id="npr-总结">NPR 总结</h2>
<ul>
<li>NPR is art driven</li>
<li>怎么把艺术家的需求转化为具体的渲染实现才是有趣/有挑战的</li>
<li>多和艺术家交流</li>
<li>NPR 很多时候是 if...else...
<ul>
<li>每个场景</li>
<li>每个部分</li>
</ul></li>
<li>NPR 做的好与不好，很大程度上取决于原来的 photorealistic rendering
做的好坏
<ul>
<li>Photorealistic models are super important in NPR</li>
<li>艺术是真实的抽象</li>
<li>NPR 与 PR 不能被分开来看待</li>
</ul></li>
<li>例如：布料（cloth）</li>
</ul>
<p><img src="/2021/05/22/CG/YLQ-GAMES202/11/image-20210522213943708.png" style="zoom:70%;"></p>
]]></content>
      <categories>
        <category>CG.GAMES202</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES202.闫令琪.12.实时光线追踪</title>
    <url>/2021/05/31/CG/YLQ-GAMES202/12/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1YK4y1T7yY</li>
</ul>
<h1 id="real-time-ray-tracing">Real-Time Ray Tracing</h1>
<ul>
<li>一些复杂的材质在这门课上不讲了</li>
<li>Volumetric / scattering materials
<ul>
<li>人脸
<ul>
<li>《最终幻想七 重制版》 [Final Fantasy VII Remake]</li>
</ul></li>
<li>毛发
<ul>
<li>《黑神话：悟空》 [Black Myth: Wukong]</li>
</ul></li>
</ul></li>
<li>背景知识比较多
<ul>
<li>RTE：散射介质中光线的传播</li>
<li>BSSRDF：次表面散射
<ul>
<li>出射点和入射点可以不同的 BRDF</li>
</ul></li>
<li>毛发内部的一次、多次散射</li>
</ul></li>
<li>离线渲染课程
<ul>
<li>更复杂的光线传播方法
<ul>
<li>delta tracking：在散射介质中做光线的步进</li>
</ul></li>
<li>复杂的材质
<ul>
<li>dual scattering：毛发渲染的一种方法</li>
<li>layered materials：分层的材质</li>
</ul></li>
</ul></li>
<li>UE5 发布
<ul>
<li>一些技术的可能实现</li>
<li>Nanite</li>
<li>Lumen</li>
</ul></li>
</ul>
<h2 id="rtx">RTX</h2>
<ul>
<li>实时光线追踪</li>
<li>早期的观点
<ul>
<li>"Ray tracing is the futureand ever will be."</li>
</ul></li>
<li>2018 RTX 系列硬件的推出使得实时光线追踪成为可能
<ul>
<li>图灵架构</li>
<li>NVIDIA announced GeForce RTX series (Turing architecture)</li>
</ul></li>
<li>RTRT 的应用场景
<ul>
<li>设计：汽车渲染</li>
<li>影视动画</li>
<li>...</li>
</ul></li>
</ul>
<p><img src="/2021/05/31/CG/YLQ-GAMES202/12/image-20210531212121853.png" alt="image-20210531212121853" style="zoom: 40%;"></p>
<ul>
<li>RTX 做了什么
<ul>
<li>做了很多 demo 展示效果：Impressive demos of RTRT
<ul>
<li>主要是高亮的场景（glossy）
<ul>
<li>一方面 glossy 材质方便求反射光线</li>
<li>另一方面 diffuse 材质你看不出来与传统方法的区别</li>
</ul></li>
</ul></li>
<li>Advanced ray traced effects：能够实现很多之前比较难做的效果
<ul>
<li>Shadows</li>
<li>Reflections &amp; Specular</li>
<li>Ambient Occlusion</li>
<li>Global Illumination</li>
</ul></li>
<li>RTX 是一种架构，允许我们 trace 光线</li>
<li>RTX 是一种硬件上的突破，计算的很快
<ul>
<li>tensor core：加速神经网络</li>
<li>rt core：针对 ray tracing 做的优化</li>
<li>10 Giga rays per second
<ul>
<li>帧数、其他计算的考虑，最终的效果留给 RTRT 的时间能够达到 1spp
<ul>
<li>1 sample per pixel (2080Ti)</li>
</ul></li>
</ul></li>
</ul></li>
<li>RTX 支持降噪
<ul>
<li>1SPP 噪声严重</li>
</ul></li>
</ul></li>
</ul>
<h3 id="spp">SPP</h3>
<ul>
<li>1 SPP path tracing：为了实现全局光照效果，至少 4 条光线
<ul>
<li>1 rasterization (primary) +</li>
<li>1 ray (primary visibility) +</li>
<li>1 ray (secondary bounce) +</li>
<li>1 ray (secondary visibility)</li>
</ul></li>
<li>primary hitpoint：第一次打中的点</li>
<li>shadow ray：判断这个点对光源是否可见</li>
<li>one bounce
<ul>
<li>secondary hitpoint</li>
<li>shadow ray</li>
</ul></li>
</ul>
<p><img src="/2021/05/31/CG/YLQ-GAMES202/12/image-20210531213131561.png" style="zoom:50%;"></p>
<ul>
<li>一种优化
<ul>
<li>没必要对所有的像素进行一次 ray tracing</li>
<li>先进行光栅化，可以更快</li>
</ul></li>
<li>这样 1SPP 需要考虑的光线少了 1 条（找到 primary hitpoint
的光线光栅化做了）</li>
<li>1 SPP 效果很差，噪声很严重</li>
</ul>
<p><img src="/2021/05/31/CG/YLQ-GAMES202/12/image-20210531214157842.png"></p>
<h3 id="rtx-的-denoising">RTX 的 denoising</h3>
<ul>
<li>State of the Art* Denoising Solution</li>
</ul>
<p><img src="/2021/05/31/CG/YLQ-GAMES202/12/image-20210531214248561.png" style="zoom:50%;"></p>
<ul>
<li>1SPP 变成这样的效果
<ul>
<li>震惊但是这是真的</li>
</ul></li>
</ul>
<h2 id="降噪-denosing">降噪 Denosing</h2>
<h3 id="目标">目标</h3>
<ul>
<li>目标
<ul>
<li>输入为 1SPP 的渲染结果</li>
<li>没有模糊、没有 artifacts、保持所有的细节
<ul>
<li>overblur（高斯滤波的结果）</li>
</ul></li>
<li>速度要快，降噪只是实时渲染的一小部分
<ul>
<li>每一帧降噪所花费的是时间小于 2ms</li>
</ul></li>
</ul></li>
<li>不可能，传统的方法都不行
<ul>
<li>Sheared filtering series (SF, AAF, FSF, MAAF, …)</li>
<li>Other offline filtering methods (IPP, BM3D, APR, …)</li>
<li>Deep learning series (CNN, Autoencoder, …)
<ul>
<li>现在来看，速度太慢了</li>
<li>跑一个神经网络花费时间在 100 ms 左右</li>
</ul></li>
</ul></li>
<li>Optix：Nvidia 的光追 API</li>
</ul>
<h3 id="工业界的解法">工业界的解法</h3>
<ul>
<li><strong>Temporal</strong>：时间上的滤波</li>
<li>关键想法：
<ul>
<li>递归的思维</li>
<li>需要滤波当前帧，我们认为<strong>前一帧是已经滤波好了的</strong></li>
<li>假设场景的运动是连续的
<ul>
<li>利用上一帧的 shading 结果</li>
</ul></li>
<li><strong>motion vector</strong>：用于找到对应的 shading point
在上一帧的位置</li>
<li>结果相当于增加了 SPP（由于递归，SPP的增加是很多的）</li>
</ul></li>
<li>motion vector</li>
</ul>
<p><img src="/2021/05/31/CG/YLQ-GAMES202/12/image-20210531223422938.png" style="zoom:67%;"></p>
<ul>
<li>空间上的降噪
<ul>
<li>下一节课</li>
</ul></li>
</ul>
<h3 id="g-buffer">G-Buffer</h3>
<ul>
<li>Geometry Buffer
<ul>
<li>光栅化得到的</li>
</ul></li>
</ul>
<p><img src="/2021/05/31/CG/YLQ-GAMES202/12/image-20210531223725649.png"></p>
<ul>
<li>需要什么，保存什么
<ul>
<li>可以保存深度、法向、世界坐标系位置等各种信息</li>
<li>保存的是屏幕空间的信息</li>
</ul></li>
<li>生成 G-Buffer 通常认为是轻量级的</li>
<li>使用 G-Buffer 是很快的</li>
</ul>
<h3 id="back-projection">Back Projection</h3>
<ul>
<li>找对应点</li>
<li>当前帧 <span class="math inline">\(i\)</span> 中的像素点 <span class="math inline">\(x\)</span>，找到这个像素中的内容在上一帧 <span class="math inline">\(i-1\)</span> 中的位置 <span class="math inline">\(x&#39;\)</span>
<ul>
<li><span class="math inline">\(x,x&#39;\)</span>
在世界坐标系中具有相同的世界坐标系坐标</li>
</ul></li>
</ul>
<p><img src="/2021/05/31/CG/YLQ-GAMES202/12/image-20210531224126028.png" style="zoom:67%;"></p>
<ul>
<li>求出世界坐标系位置 <span class="math inline">\(s\)</span>
<ul>
<li>如果有 G-Buffer 中，直接取出 <span class="math inline">\(s\)</span>
即可</li>
<li>如果没有 G-Buffer，计算得到 <span class="math inline">\(s =
M^{-1}V^{-1}P^{-1}E^{-1}x\)</span>
<ul>
<li><span class="math inline">\(E\)</span> 视口变换，带 <span class="math inline">\(&#39;\)</span> 表示上一帧结果</li>
<li>需要用到深度信息，屏幕空间是 2D 的，变换是 3D 的</li>
</ul></li>
</ul></li>
<li>计算上一帧世界坐标系坐标 <span class="math inline">\(s&#39;\)</span>
的位置（已经得到了世界坐标 <span class="math inline">\(s\)</span>）
<ul>
<li>我们是知道物体怎么运动的，计算即可，我们拥有整个场景的运动信息</li>
<li><span class="math inline">\(s&#39;{\buildrel{T}\over\longrightarrow}
s,s{\buildrel{T^{-1}}\over\longrightarrow} s&#39;\)</span></li>
</ul></li>
<li>计算在上一帧中的位置 <span class="math inline">\(x&#39;\)</span>
<ul>
<li><span class="math inline">\(x&#39;=E&#39;P&#39;V&#39;M&#39;s&#39;\)</span></li>
</ul></li>
<li>光流：找像素和像素在不同时间上的一个对应 optical flow
<ul>
<li>算 motion vector 本质上也是一种 optical flow</li>
<li>motion vector 是完全物理正确的</li>
<li>光流是根据内容推理，但是深度学习能够做的很好</li>
</ul></li>
</ul>
<h3 id="blending">blending</h3>
<ul>
<li>怎么结合得到的两张图</li>
<li>符号定义（象形hhh）
<ul>
<li><span class="math inline">\(\sim\)</span> ：unfiltered</li>
<li><span class="math inline">\(-\)</span>：filtered</li>
</ul></li>
<li>步骤
<ul>
<li>当前帧自己先做一次降噪（空间）
<ul>
<li><span class="math inline">\(\bar{C}^{(i)}=Filter[\tilde{C}^{(i)}]\)</span></li>
<li>1SPP 情况下只依赖当前帧的结果，降噪效果是不可能很好的</li>
</ul></li>
<li>Temporal（时间）
<ul>
<li><span class="math inline">\(\bar{C}^{(i)}=\alpha\bar{C}^{(i)}+(1-\alpha)\bar{C}^{i-1}\)</span></li>
<li>对应像素而不是同一个像素</li>
<li>通常 <span class="math inline">\(\alpha\in[0.1,0.2]\)</span></li>
<li>说明用的内容主要是上一帧的内容，大胆的设想</li>
</ul></li>
</ul></li>
</ul>
<h3 id="效果">效果</h3>
<ul>
<li>1spp Ray Traced Global Illumination</li>
</ul>
<p><img src="/2021/05/31/CG/YLQ-GAMES202/12/image-20210531234208290.png"></p>
<ul>
<li>1spp Ray Traced Global Illumination + Denoising</li>
</ul>
<p><img src="/2021/05/31/CG/YLQ-GAMES202/12/image-20210531234218006.png"></p>
<ul>
<li>Ground Truth</li>
</ul>
<p><img src="/2021/05/31/CG/YLQ-GAMES202/12/image-20210531234300669.png"></p>
<ul>
<li>滤波绝对不可能让一张有噪声的图变亮或者变暗，保持能量守恒
<ul>
<li>带噪声的图，很多噪点的能量可能是很高的，但是会被显示器给截断</li>
<li>原始的 exr 图片，在 HDR 显示器上显示的结果，denoising
前后亮度应该相差不大</li>
</ul></li>
<li>一些问题
<ul>
<li>缺失了一些信息，例如左上角圆台体中间条带的 contact shadow</li>
<li>一些细节由于降噪变得模糊</li>
</ul></li>
<li>1SPP 的效果!!!!!!</li>
</ul>
<h3 id="问题">问题</h3>
<ul>
<li>场景的第一帧怎么渲染？切换了场景？突变的光源（蹦迪）？
<ul>
<li>burn-in period：场景突变需要一段时间累计信息</li>
<li>这是上面的方法是做不到的</li>
</ul></li>
<li>向后走场景做不了
<ul>
<li>walking backwards in a hallway</li>
<li>很多点上一帧还不在渲染结果内</li>
<li>屏幕空间的问题</li>
</ul></li>
<li>disocclusion：在新的一帧中从遮挡状态转变为不被遮挡的状态
<ul>
<li>这一帧的点在上一帧中被遮挡</li>
<li>于是在上一帧中找到的对应点并不是真正的对应点，而是<strong>挡住对应点的点</strong></li>
<li>屏幕空间的问题</li>
</ul></li>
<li>detached/lagging shadows
<ul>
<li>阴影的拖尾问题（shading 的问题）</li>
<li>如下场景，场景、像机都不移动，于是任何一个像素 motion vector 为
0</li>
<li>此时移动光源，造成阴影拖尾的现象</li>
</ul></li>
</ul>
<p><img src="/2021/05/31/CG/YLQ-GAMES202/12/image-20210601000529916.png"></p>
<ul>
<li>glossy 反射的问题
<ul>
<li>反射的拖尾（shading 的问题）</li>
<li>如下场景中，相机、地板、光源保持不动，于是地板的 motin vector 为
0</li>
<li>移动椅子，我们发现，地板上的反射效果得过一会才能跟上物体的运动</li>
<li>快速移动有延迟，滞后问题</li>
</ul></li>
</ul>
<p><img src="/2021/05/31/CG/YLQ-GAMES202/12/image-20210601000906122.png"></p>
<h3 id="问题解决">问题解决</h3>
<h4 id="问题-3">问题 3</h4>
<ul>
<li>不能用，但是强行使用
<ul>
<li>Lagging：拖尾效果，鬼影</li>
</ul></li>
</ul>
<p><img src="/2021/05/31/CG/YLQ-GAMES202/12/image-20210531235727923.png" style="zoom:60%;"></p>
<ul>
<li>巧妙的使用</li>
<li>Clamping
<ul>
<li>把上一帧的值先拉近到这一帧的结果</li>
</ul></li>
<li>Detection
<ul>
<li>如果检测到不对应，则不使用上一帧的信息</li>
<li>例如给物体标 ID，如果上一帧的 ID 不一致，则调整 <span class="math inline">\(\alpha\)</span> 的值（使用更少的上一帧信息）</li>
</ul></li>
<li>这样的问题：引入了噪声（降噪效果变差）</li>
</ul>
<p><img src="/2021/05/31/CG/YLQ-GAMES202/12/image-20210601000246930.png" style="zoom:60%;"></p>
<h2 id="taa">TAA</h2>
<ul>
<li>The temporal accumulation is inspired by Temporal Anti-Aliasing
(TAA)</li>
<li>类似的想法</li>
<li>论文
<ul>
<li>Temporally Reliable Motion Vectors for Real-time Ray Tracing</li>
<li>[Eurographics]</li>
<li>实用，能够解决一些问题，更多挖掘可用信息</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES202</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES202.闫令琪.13.实时光线追踪(2)</title>
    <url>/2021/06/10/CG/YLQ-GAMES202/13/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1YK4y1T7yY</li>
</ul>
<h1 id="实时光线追踪">实时光线追踪</h1>
<ul>
<li>空间滤波
<ul>
<li>联合双边滤波</li>
<li>大 filter 的实现</li>
<li>outlier removal（离群值去除）</li>
</ul></li>
<li>RTRT 中的技术
<ul>
<li>SVGF：Spatiotemporal Variance-Guided Filtering</li>
<li>RAE：Recurrent AutoEncoder</li>
</ul></li>
</ul>
<h2 id="空间滤波">空间滤波</h2>
<h3 id="实现目标">实现目标</h3>
<ul>
<li>实现的效果：降噪
<ul>
<li>下图是椒盐噪声利用中值滤波实现的效果</li>
</ul></li>
</ul>
<p><img src="/2021/06/10/CG/YLQ-GAMES202/13/image-20210610164704899.png" style="zoom:80%;"></p>
<ul>
<li>这里我们想做的是低通滤波（low-pass）
<ul>
<li>去除高频噪声
<ul>
<li>高频中也有信号，同时会造成高频信号的丢失</li>
<li>还存在一些低频的噪声</li>
</ul></li>
<li>我们在空间域上进行</li>
</ul></li>
</ul>
<h3 id="输入">输入</h3>
<ul>
<li>一张带有噪声的图片 <span class="math inline">\(\tilde{C}\)</span></li>
<li>以可滤波核 <span class="math inline">\(K\)</span>
<ul>
<li>可以每个像素有不一样的滤波核</li>
</ul></li>
</ul>
<h3 id="高斯滤波">高斯滤波</h3>
<ul>
<li>高斯滤波核
<ul>
<li>周围值得贡献通过离中心点得距离决定</li>
<li>由高斯函数决定</li>
</ul></li>
</ul>
<p><img src="/2021/06/10/CG/YLQ-GAMES202/13/image-20210610165435406.png"></p>
<ul>
<li>简单的伪代码实现
<ul>
<li>注意高斯核 <span class="math inline">\(K\)</span>
的归一化（所有权值和为 1）
<ul>
<li>伪代码中的 sum_of_weights</li>
<li>同样的我们之前学到的积分拆解，分母中有一个空积分，这也是为了归一化</li>
</ul></li>
<li>高斯核本身是无限大的，但是我们可以只考虑比较大贡献的值，例如 <span class="math inline">\(3\sigma\)</span> 截断</li>
<li>在有些算法实现的时候，会先判断一下 sum_of_weights 是否为
0（高斯这里不可能为 0，就不判断了）</li>
<li>颜色可以是多通道的，此时 sum_of_weights、sum_of_weighted_values
都是多通道的</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">For each pixel i:</span><br><span class="line">    sum_of_weights = sum_of_weighted_values = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># include i</span></span><br><span class="line">    For each pixel j around i:</span><br><span class="line">        Calculate the weight w_ij = G(|i - j|, sigma)</span><br><span class="line">        sum_of_weighted_values += w_ij * C^&#123;<span class="built_in">input</span>&#125;[j]</span><br><span class="line">        sum_of_weights += w_ij</span><br><span class="line">        C^&#123;output&#125;[I] = sum_of_weighted_values / sum_of_weights</span><br></pre></td></tr></table></figure>
<h3 id="双边滤波">双边滤波</h3>
<ul>
<li>Bilateral Filtering</li>
<li>高斯滤波的问题
<ul>
<li>图像一些高频细节也同时缺失了，例如边界也被模糊了</li>
<li>但是我们想要保留边界的信息</li>
</ul></li>
<li><a href="https://www.mathworks.com/help/images/ref/imgaussfilt.html">下图</a>是一个例子</li>
</ul>
<p><img src="/2021/06/10/CG/YLQ-GAMES202/13/image-20210610170430348.png" style="zoom: 67%;"></p>
<ul>
<li>双边滤波的目的就是在去噪的同时能够保持边界</li>
<li>基于我们生活中的观察
<ul>
<li>边界：颜色变化非常剧烈</li>
</ul></li>
<li>idea：如何保持边界
<ul>
<li>循环的时候我们看 j 点和 i 点的颜色是不是相差特别大
<ul>
<li>如果相差不是特别大，我们使用原来高斯滤波的方式进行</li>
<li>如果相差特别大，我们就减小贡献值（减小权值）</li>
</ul></li>
</ul></li>
<li><a href="https://www.mathworks.com/help/images/ref/imgaussfilt.html">一种实现</a>如下
<ul>
<li>两个点 <span class="math inline">\((i,j),(k,l)\)</span></li>
<li>值差别过大的时候，那么贡献就会减小</li>
</ul></li>
</ul>
<p><span class="math display">\[
w(i,j,k,l)=\exp\left(-\dfrac{(i-k)^2+(j-l)^2}{2\sigma_d^2}-\dfrac{\Vert
I(i,j)-I(k,l)\Vert^2}{2\sigma_r^2}\right)
\]</span></p>
<ul>
<li>效果如下
<ul>
<li>能够很好的保留边界信息</li>
<li>山内部的高频信息被抹掉了，但是边界信息保留了</li>
</ul></li>
</ul>
<p><img src="/2021/06/10/CG/YLQ-GAMES202/13/image-20210610173346721.png"></p>
<ul>
<li>问题
<ul>
<li>噪声很明显的图会出问题</li>
<li><strong>分不清噪声和边界</strong></li>
</ul></li>
</ul>
<h3 id="联合双边滤波">联合双边滤波</h3>
<ul>
<li>Cross/Joint Bilateral Filtering</li>
<li>观察
<ul>
<li>高斯滤波：position distance</li>
<li>双边滤波：position distance + color distance</li>
</ul></li>
<li>于是我们可以用更多的标准，让结果更加接近我们想要的值</li>
<li>这就是联合双边滤波</li>
<li><strong>联合双边滤波对蒙特卡洛路径追踪算法得到图片的降噪效果很好</strong>
<ul>
<li><strong>Especially good at denoising path traced rendering
results!</strong></li>
</ul></li>
<li>使用哪些信息呢？
<ul>
<li><strong>G-Buffer</strong>
<ul>
<li>世界坐标</li>
<li>法向</li>
<li>albedo</li>
<li>object ID（每种物体标一个数字）：motion vector 中使用过</li>
</ul></li>
<li><strong>G-Buffer 本身是完全没有噪声的</strong>
<ul>
<li>和多次反射无关</li>
</ul></li>
</ul></li>
<li>和之前的滤波一样，不需要考虑归一化
<ul>
<li>在实现的时候对滤波核进行归一化即可，函数不需要归一化</li>
</ul></li>
<li>也可以使用其他函数，不一定是高斯函数，只要随着距离有衰减就可以</li>
<li>高斯函数、指数函数、余弦函数</li>
</ul>
<p><img src="/2021/06/10/CG/YLQ-GAMES202/13/image-20210610205556276.png" style="zoom: 50%;"></p>
<ul>
<li>高斯也不需要是严格的高斯，系数什么的都可以变</li>
</ul>
<h4 id="联合双边滤波例子">联合双边滤波例子</h4>
<ul>
<li>我们渲染得到了如下图片，同时得到了 G-Buffer 如下
<ul>
<li>Depth</li>
<li>Normal</li>
<li>Color</li>
</ul></li>
</ul>
<p><img src="/2021/06/10/CG/YLQ-GAMES202/13/image-20210610205758226.png" style="zoom:67%;"></p>
<ul>
<li>如果我们需要保留边界，则可以使用如下信息作为标准（metric）</li>
<li>A-B：position + depth</li>
<li>B-C：position + normal</li>
<li>D-E：position + color
<ul>
<li>有噪声的情况下可能会有些问题，color 可能是噪声</li>
</ul></li>
<li>具体哪一个标准占的权重大小由 <span class="math inline">\(\sigma\)</span> 调节
<ul>
<li>比如上面双边滤波中的 <span class="math inline">\(\sigma_d,\sigma_r\)</span></li>
</ul></li>
</ul>
<h2 id="实现大的滤波核">实现大的滤波核</h2>
<ul>
<li>Implementing Large Filters</li>
<li>我们在滤波的时候，<strong>如果滤波核特别大，计算开销就很大</strong></li>
</ul>
<h3 id="大滤波核的解决思路">大滤波核的解决思路</h3>
<ul>
<li>FFT（快速傅里叶变化）在 GPU
上的优化做的并不好，因此还是基于空间域上的实现</li>
</ul>
<h4 id="拆分separate-passes">(1) 拆分：Separate Passes</h4>
<ul>
<li>例如对一个高斯滤波，我们可以先水平方向做一次，然后在竖直方向做一次</li>
</ul>
<p><img src="/2021/06/10/CG/YLQ-GAMES202/13/image-20210610212405100.png" style="zoom: 67%;"></p>
<ul>
<li>对每一个像素，对周围点的查询次数由 <span class="math inline">\(N^2\)</span> 变成了 <span class="math inline">\(2N\)</span>
<ul>
<li><span class="math inline">\(N\)</span> 为滤波核的大小</li>
</ul></li>
</ul>
<h5 id="高斯函数拆分的数学原理">高斯函数拆分的数学原理</h5>
<ul>
<li>高斯滤波为什么能这么拆？数学原理如下</li>
<li>高斯函数有好的定义</li>
</ul>
<p><span class="math display">\[
G_{2D}(x,y)=\exp\left(-\dfrac{x^2+y^2}{2\sigma^2}\right)
\]</span></p>
<p><span class="math display">\[
G_{1D}(x)=\exp\left(-\dfrac{x^2}{2\sigma^2}\right)
\]</span></p>
<p><span class="math display">\[
G_{1D}(y)=\exp\left(-\dfrac{y^2}{2\sigma^2}\right)
\]</span></p>
<p><span class="math display">\[
G_{2D}(x,y)=G_{1D}(x)\cdot G_{1D}(y)
\]</span></p>
<ul>
<li>滤波就是卷积（filtering == convolution）</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
R(x_0,y_0)&amp;=\iint{F(x_0,y_0)G_{2D}(x_0-x,y_0-y)}\;\mathrm{d}x\mathrm{d}y\\
&amp;=\iint{F(x_0,y_0)G_{1D}(x_0-x)G_{1D}(y_0-y)}\;\mathrm{d}x\mathrm{d}y\\
&amp;=\int\Big(F(x_0,y_0)G_{1D}(x_0-x)\;\mathrm{d}x\Big)G_{1D}(y_0-y)\mathrm{d}y
\end{aligned}
\]</span></p>
<ul>
<li>双边高斯滤波就不能这么拆分，因为不具备定义上 2D 拆分为 1D 的性质
<ul>
<li>但是在实际工业实现上，都是这么强行拆分的</li>
</ul></li>
</ul>
<h4 id="逐步增大滤波核progressively-growing-sizes">(2)
逐步增大滤波核：Progressively Growing Sizes</h4>
<ul>
<li>一个例子：a-trous wavelet</li>
<li>每一趟都是 <span class="math inline">\(5\times5\)</span>
的大小，但是每一趟像素间的间隔是不一样的</li>
<li>第 <span class="math inline">\(i\)</span> 趟考虑的点间隔 <span class="math inline">\(2^{i}\)</span>
<ul>
<li>第 <span class="math inline">\(1\)</span> 趟（<span class="math inline">\(i=0\)</span>）</li>
<li>考虑的点示例如下</li>
</ul></li>
</ul>
<p><img src="/2021/06/10/CG/YLQ-GAMES202/13/image-20210610214554336.png" style="zoom:50%;"></p>
<ul>
<li>因此我们对于原始 <span class="math inline">\(64\times64\)</span>
的滤波，对于<strong>每一个像素点</strong>访问周围点的次数从 <span class="math inline">\(64\times64\)</span> 降到了 <span class="math inline">\(5^2\times5\)</span>
<ul>
<li>第 <span class="math inline">\(5(i=4)\)</span> 层的时候，间隔为
<span class="math inline">\(2^4=16\)</span>，一共 <span class="math inline">\(5\)</span> 个点，<span class="math inline">\(4\)</span> 个间隔，结果占据范围为 <span class="math inline">\(64\)</span></li>
<li><span class="math inline">\(4096\Rightarrow125\)</span></li>
</ul></li>
</ul>
<h5 id="原理">原理</h5>
<ul>
<li>为什么要一开始不直接使用大的 filter？
<ul>
<li>使用更大的 filter == 消除更低的频率</li>
</ul></li>
<li>跳过一些采样点为什么是可行的？
<ul>
<li>更低的频率间隔更大</li>
<li>空间采样，频域上频谱的搬移
<ul>
<li>如果采样频率太低（间隔太大），会导致走样</li>
<li>采样定理</li>
</ul></li>
<li>因为频率变低了，因此可以跳过一些采样点</li>
</ul></li>
</ul>
<p><img src="/2021/06/10/CG/YLQ-GAMES202/13/image-20210610232427566.png" style="zoom:60%;"></p>
<ul>
<li>根据上图
<ul>
<li>第一个 pass，把<span style="font-weight:bold;color:#2E74BB">蓝色部分</span>的高频信息去掉了</li>
<li>第二个 pass 间隔较大，可以去掉<span style="font-weight:bold;color:#F59A24">黄色部分</span>的高频信息
<ul>
<li>同时不会有走样现象，因为高频信息已经被去掉了</li>
<li>可以通过计算得到，频谱搬移的时候恰好不会有混叠</li>
</ul></li>
</ul></li>
<li>在实际中是有问题的，高频信息并不是完全被去掉（非理想滤波器）
<ul>
<li>能看到一些格子状的 artifact</li>
</ul></li>
</ul>
<h2 id="outlier-removal">Outlier Removal</h2>
<ul>
<li>Outlier Removal (and temporal clamping)</li>
<li>离群值去除</li>
<li>我们在渲染的过程中可能会出现一些特别亮的点，如<a href="https://clarissewiki.com/4.0/fireflies-filtering.html">下图</a></li>
</ul>
<p><img src="/2021/06/10/CG/YLQ-GAMES202/13/image-20210610234504044.png" style="zoom:67%;"></p>
<ul>
<li>这些点在滤波中很难处理，这个点很亮（值很大），在滤波之后会被扩散为一个光晕（比较大的亮斑）
<ul>
<li>the filtered results are still noisy, even
<strong>blocky</strong></li>
<li><strong>blocky artifact</strong></li>
</ul></li>
<li>这些特别亮的点就被称为是 outlier
<ul>
<li>图形学中常被称为是 firefly（火萤）</li>
</ul></li>
<li>outlier removal 会导致<strong>能量不守恒</strong>
<ul>
<li>RTRT 为了提高效率，这么做是可以接受的</li>
</ul></li>
</ul>
<h3 id="过程">过程</h3>
<ul>
<li>在做滤波之前先处理掉（不处理掉会影响滤波）</li>
<li>outlier 检测
<ul>
<li>对于每个像素，查看周围的一个小邻域（<span class="math inline">\(7\times7\)</span>）</li>
<li>计算邻域内的均值、方差（也可以用中位数）
<ul>
<li>简单计算</li>
<li>用一些数据结构</li>
</ul></li>
<li>如果一个点的值在均值加减若干个标准差范围内，如果超出这个范围，我们认为他们就是
outlier
<ul>
<li><span class="math inline">\([\mu-k\sigma,\mu+k\sigma]\)</span></li>
<li>工业界 <span class="math inline">\(k=1\sim3\)</span> 都有</li>
</ul></li>
</ul></li>
<li>outlier removal
<ul>
<li>将 outlier 截断（clamp）</li>
<li>工业界 clamp 的实现比较复杂，可能不是一个简单的区间</li>
</ul></li>
</ul>
<h3 id="taa-中的-outlier-removal">TAA 中的 outlier removal</h3>
<ul>
<li><span class="math inline">\(\bar{C}^{(i)}=\alpha\bar{C}^{(i)}+(1-\alpha)\bar{C}^{i-1}\)</span></li>
<li>我们对上一帧得到的 noise free 的结果进行截断
<ul>
<li>如果上一帧的结果和这一帧相差太大，我们做一个截断的操作</li>
<li>这样的操作是一个 noise 和 lagging 的 tradeoff
<ul>
<li>引入了更多噪声</li>
</ul></li>
<li>相当于调整 <span class="math inline">\(\alpha\)</span></li>
</ul></li>
<li><span class="math inline">\(\bar{C}^{(i)}=\alpha\bar{C}^{(i)}+(1-\alpha)\cdot\mathrm{clamp}(\bar{C}^{i-1},\mu-k\sigma,k+k\sigma)\)</span></li>
</ul>
<h2 id="svgf">SVGF</h2>
<ul>
<li>Nvidia 2017 年的论文
<ul>
<li><a href="https://research.nvidia.com/sites/default/files/pubs/2017-07_Spatiotemporal-Variance-Guided-Filtering%3A//svgf_preprint.pdf">Spatiotemporal
Variance-Guided Filtering: Real-Time Reconstruction for Path-Traced
Global Illumination</a></li>
</ul></li>
<li><strong>Spatiotemporal</strong> Variance-Guided Filtering
<ul>
<li>和之前的基本的时空上的降噪方法类似</li>
<li>有一些额外的方差分析和 tricks
<ul>
<li>每一个像素会记录一个 variance（方差）</li>
</ul></li>
</ul></li>
<li>1spp / 滤波结果 / ground truth
<ul>
<li>ground truth 可以通过 path tracing 用一个较高的 spp
得到的基本收敛的结果</li>
</ul></li>
</ul>
<p><img src="/2021/06/10/CG/YLQ-GAMES202/13/image-20210613145752902.png" style="zoom: 50%;"></p>
<h3 id="个标准">3 个标准</h3>
<h4 id="depth">depth</h4>
<ul>
<li>深度</li>
<li><span class="math inline">\(q\)</span> 对 <span class="math inline">\(p\)</span> 的贡献</li>
</ul>
<p><span class="math display">\[
w_z=\exp\Big(-\dfrac{|z(p)-z(q)|}{\sigma_z|\nabla
z_p\cdot(p-q)|+\epsilon}\Big)
\]</span></p>
<ul>
<li>不是高斯，分子是一次方（有衰减即可）</li>
<li>分母的 <span class="math inline">\(\epsilon=10^{-6}\)</span>
防止除零的发生（<span class="math inline">\(p=q\)</span>）</li>
<li><span class="math inline">\(\nabla z\)</span> is the gradient of
clip-space depth with respect to <strong>screenspace
coordinates</strong></li>
</ul>
<p><img src="/2021/06/10/CG/YLQ-GAMES202/13/image-20210614103832074.png" style="zoom:67%;"></p>
<ul>
<li>图上的 A、B 两点在同一个平面上，直观上感觉应该 A 对 B 的贡献不小
<ul>
<li>但是由于这个平面是侧向我们的，深度上有差异，简单的使用深度值的话，计算得到的贡献偏小</li>
<li>我们使用<strong>深度在法线上差异</strong>作为一个标准（切平面上的深度差异）</li>
<li>分母计算出来的结果就是按照 <span class="math inline">\(p\)</span>
点的变化率，深度应该变化的值
<ul>
<li>如果共平面，值和分子相同，计算得到的结果使得贡献值变大</li>
</ul></li>
</ul></li>
</ul>
<h4 id="normal">normal</h4>
<ul>
<li>法线</li>
</ul>
<p><span class="math display">\[
w_n=\max\Big(0,n(p)\cdot n(q)\Big)^{\sigma_n}
\]</span></p>
<ul>
<li>指数控制衰减的快慢（之前的 Blinn-Phong 模型的镜面叶）</li>
</ul>
<p><img src="/2021/06/10/CG/YLQ-GAMES202/13/image-20210614110024367.png" style="zoom:67%;"></p>
<ul>
<li>如果场景应用了法线贴图，我们使用的是没有法线贴图之前的法线（marco
normals）
<ul>
<li>法线贴图干扰很大</li>
</ul></li>
</ul>
<h4 id="luminance">luminance</h4>
<ul>
<li>luminance（灰度的颜色值）</li>
<li>如果两个点的灰度值相差过大，则贡献值要减小
<ul>
<li>例如：A 不应该贡献到 B，B 不应该贡献到 C</li>
</ul></li>
<li>但是由于噪声的存在，会让我们的判断有些干扰</li>
<li>我们通过方差来判断噪声
<ul>
<li>如果方差较大（噪声严重），则不应该过多的相信这两个点之间的差异</li>
</ul></li>
</ul>
<p><img src="/2021/06/10/CG/YLQ-GAMES202/13/image-20210614110631154.png" style="zoom: 67%;"></p>
<ul>
<li>表达式如下</li>
</ul>
<p><span class="math display">\[
w_l=\exp\Big(-\dfrac{|l_i(p)-l_i(q)|}{\sigma_l\sqrt{g_{3\times3}\Big(\mathrm{Var}\big(l_i(p)\big)\Big)}+\epsilon}\Big)
\]</span></p>
<ul>
<li>方差具体计算
<ul>
<li>spatial：我们对当前帧待判断像素点周围 <span class="math inline">\(7\times7\)</span>
区域方差值（实际上的标准差）</li>
<li>temporal：通过 motion vector
找到上一帧中的对应点，求一个方差的平均（带权）</li>
<li>spatial：在使用的时候，我们在周围取一个 <span class="math inline">\(3\times3\)</span> 区域内求一个平均值</li>
</ul></li>
</ul>
<h3 id="评价">评价</h3>
<ul>
<li>方差项会导致在做 over blur 和 noise 之间的 trade off
的时候，会倾向于 over blur</li>
<li>改进：ASVGF
<ul>
<li>更加精准的判断 temporal上的连续情况</li>
<li>overblur 的不要这么厉害（相对噪声会严重些）</li>
</ul></li>
<li>motion vector 同样会导致拖尾的结果</li>
</ul>
<h2 id="rae">RAE</h2>
<ul>
<li>Nvidia 2017 年的论文
<ul>
<li><a href="https://research.nvidia.com/publication/interactive-reconstruction-monte-carlo-image-sequences-using-recurrent-denoising">Interactive
Reconstruction of Monte Carlo Image Sequences using a Recurrent
denoising AutoEncoder</a></li>
</ul></li>
<li>后处理的神经网络
<ul>
<li>目标：noisy <span class="math inline">\(\to\)</span> clean</li>
<li>使用到一些 G-Buffer 的内容</li>
</ul></li>
<li>关键结构
<ul>
<li>Recurrent block 的结构能够保存上一帧的信息</li>
<li>AutoEncoder（U-net）结构（漏斗形）</li>
</ul></li>
</ul>
<h3 id="网络结构">网络结构</h3>
<p><img src="/2021/06/10/CG/YLQ-GAMES202/13/image-20210614112743145.png"></p>
<ul>
<li>输入为 G-Buffer</li>
<li>AutoEncoder
<ul>
<li>对称的</li>
<li>skip connection：faster and better training</li>
</ul></li>
<li>Recurrent Block
<ul>
<li>实际跑的时候，保留前几帧的信息</li>
</ul></li>
</ul>
<p><img src="/2021/06/10/CG/YLQ-GAMES202/13/image-20210614140956345.png" style="zoom: 67%;"></p>
<ul>
<li>训练的时候也需要用一些连续帧（不能只有单张渲染结果）</li>
<li>没有使用 motion vector
<ul>
<li>具体使用是什么内容，是神经网络学习出来的结果</li>
</ul></li>
<li>当时：50ms 一帧</li>
</ul>
<h3 id="问题">问题</h3>
<ul>
<li>overblur</li>
<li>残影</li>
<li>RAE 场景偏暗（亮了 artifacts 会增多）</li>
</ul>
<h3 id="svgf-vs-rae">SVGF vs RAE</h3>
<ul>
<li>帧间抖动，一些低频噪声，看起来像沸腾的水，boiling artifacts</li>
</ul>
<table>
<colgroup>
<col style="width: 32%">
<col style="width: 9%">
<col style="width: 8%">
<col style="width: 11%">
<col style="width: 13%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">Quality</th>
<th style="text-align: center;">Artifact</th>
<th style="text-align: center;">Performance</th>
<th style="text-align: center;">Explanability</th>
<th style="text-align: center;">Where did the paper go</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">SVGF</td>
<td style="text-align: center;"><strong>Clean</strong></td>
<td style="text-align: center;">Ghosting</td>
<td style="text-align: center;"><strong>Fast</strong></td>
<td style="text-align: center;"><strong>Yes</strong></td>
<td style="text-align: center;">HPG</td>
</tr>
<tr class="even">
<td style="text-align: center;">RAE <br>(when first invented)</td>
<td style="text-align: center;">Overblur</td>
<td style="text-align: center;">Ghosting</td>
<td style="text-align: center;">Slow</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;"><strong>SIGGRAPH</strong></td>
</tr>
</tbody>
</table>
<h3 id="好处">好处</h3>
<ul>
<li>RAE 在不同输入情况下， performance
是固定的（网络固定、计算耗时固定）</li>
<li>Nvidia 把 RAE 中的 Recurrent Block 去掉了，放到了 Optix 的光追降噪中
<ul>
<li>对于稍微高一点的 spp 降噪效果非常好</li>
<li>针对单张图片（去掉了 Recurrent Block）</li>
</ul></li>
<li>在 tensor core 提出之后，RAE 效果变好了</li>
</ul>
]]></content>
      <categories>
        <category>CG.GAMES202</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES202.闫令琪.14.工业界算法实现</title>
    <url>/2021/06/13/CG/YLQ-GAMES202/14/</url>
    <content><![CDATA[<ul>
<li>https://www.bilibili.com/video/BV1YK4y1T7yY</li>
</ul>
<p><img src="/2021/06/13/CG/YLQ-GAMES202/14/image-20210613145024654.png" style="zoom:50%;"></p>
<h1 id="工业界算法实现">工业界算法实现</h1>
<ul>
<li>A Glimpse of Industrial Solutions (from the scientific
perspective)</li>
</ul>
<h2 id="aa">AA</h2>
<ul>
<li>Anti-Aliasing：反走样</li>
</ul>
<h3 id="taa">TAA</h3>
<ul>
<li>Temporal Anti-Aliasing</li>
<li>TAA 算法的成功，才有了 temporal 思想在 RTRT 中的应用</li>
<li>走样的来源：对于每个像素的采样数不够（采样定理）</li>
<li>解决思路：使用更多的样本</li>
<li>temporal
AA：使用更多的样本，但是是使用更多上一帧（以及之前帧）的样本
<ul>
<li>思路和 RTRT 中是一样的</li>
</ul></li>
</ul>
<h4 id="静止场景">静止场景</h4>
<p><img src="/2021/06/13/CG/YLQ-GAMES202/14/image-20210614143611181.png" style="zoom:50%;"></p>
<ul>
<li>怎么复用上一帧的样本？</li>
<li>一种想法，每一帧采不同的区域
<ul>
<li>连续 4 帧，分别采样 左上、右上、右下、左下（移动的 sampling
pattern）</li>
<li>复用上一帧，递归形成复用之前所有的样本的 sampling</li>
</ul></li>
</ul>
<p><img src="/2021/06/13/CG/YLQ-GAMES202/14/rec.png"></p>
<ul>
<li>为什么不随机生成呢？
<ul>
<li>相对均匀分布</li>
<li>如果随机会引入一些额外的高频信息，效果可能不太好</li>
</ul></li>
</ul>
<h4 id="运动场景">运动场景</h4>
<ul>
<li>motion vector</li>
<li>temporal 信息不可用的时候，也是使用 clamping 的方法
<ul>
<li>基本上和 RTRT 中的思路一致</li>
</ul></li>
</ul>
<h3 id="msaa-和-ssaa">MSAA 和 SSAA</h3>
<ul>
<li>SSAA：Supersampling
<ul>
<li>渲染的时候，使用更高的分辨率，在渲染结束后，降采样到要求的分辨率</li>
<li>正确的，效果非常好，但是开销非常大</li>
</ul></li>
<li>MSAA：Multisampling AA
<ul>
<li>一个 primitive 只会进行一次 shading</li>
<li>下图中，SSAA 需要做 4 次 shading，MSAA 只需要做两次</li>
</ul></li>
</ul>
<p><img src="/2021/06/13/CG/YLQ-GAMES202/14/image-20210614145047754.png" style="zoom:50%;"></p>
<ul>
<li>MSAA 支持空间上的复用
<ul>
<li>(1)(2) 中间的两个采样点可以被视为对 (1) 的贡献，也能被当作对 (2)
的贡献</li>
<li>复用了中间两个点</li>
</ul></li>
</ul>
<p><img src="/2021/06/13/CG/YLQ-GAMES202/14/image-20210614145220883.png" style="zoom: 80%;"></p>
<ul>
<li>https://www.sapphirenation.net/anti-aliasing-comparison-performance-quality</li>
</ul>
<h3 id="图像上的-aa">图像上的 AA</h3>
<ul>
<li>先渲染得到带锯齿的结果图，然后在图像上进行反走样处理</li>
<li>最流行的方法：SMAA（Enhanced subpixelmorphological AA）</li>
<li>发展历史：FXAA <span class="math inline">\(\to\)</span>
MLAA（Morphological AA）<span class="math inline">\(\to\)</span>
SMAA</li>
</ul>
<h4 id="smaa">SMAA</h4>
<ul>
<li>http://www.iryoku.com/smaa/</li>
<li>先检测出来边界，然后根据找出来的边界，根据占比上色
<ul>
<li>矢量化的过程</li>
</ul></li>
</ul>
<p><img src="/2021/06/13/CG/YLQ-GAMES202/14/image-20210614145953181.png" style="zoom: 67%;"></p>
<ul>
<li>效果非常快</li>
<li>不能对 G-Buffer 做反走样，反走样了则失去了原来的意义</li>
</ul>
<h2 id="temporal-super-resolution">Temporal Super Resolution</h2>
<ul>
<li>超分辨率：Super Resolution（Super Sampling）
<ul>
<li>字面理解：提高分辨率</li>
</ul></li>
</ul>
<h3 id="dlss">DLSS</h3>
<ul>
<li>Nvidia</li>
<li>DLSS
1.0：硬猜，通过神经网络学习到一些结果，将模糊的边缘换成不模糊的边缘
<ul>
<li>完全数据驱动</li>
</ul></li>
<li>DLSS 2.0：使用更多 Temporal 的信息
<ul>
<li>分辨率提高，变模糊，等价于是采样不足，试从上一帧中获取信息</li>
</ul></li>
<li>核心思想就是利用 TAA
<ul>
<li>Temporally reuse samples to increase resolution</li>
</ul></li>
<li>DLSS 面临的另外一个问题，如果时间的信息不可用，不能使用 clamping
的方法
<ul>
<li>对 temporal 的信息利用更加严格</li>
<li>我们实际上需要的是一个增大了分辨率的结果，我们需要知道一些更细致分辨率的值，如果我们不能够在时间上获取到这些信息，盲目的使用周围的值去猜，这样会导致模糊的结果
<ul>
<li>也就是说新的值和原来的值本质上是不同的，更细致的分辨率有更多细节</li>
</ul></li>
<li>因此我们需要找一个比 clamp 更好的方案（当 temporal failure
的时候）</li>
</ul></li>
</ul>
<p><img src="/2021/06/13/CG/YLQ-GAMES202/14/image-20210614151204493.png" style="zoom:50%;"></p>
<ul>
<li>当前帧和上一帧的采样信号 <span class="math inline">\(\to\)</span>
得到一个当前帧增加了采样点的值
<ul>
<li>DLSS
的网络没有输出具体的颜色值，而是告诉我们应该怎么去使用上一帧的信息</li>
</ul></li>
</ul>
<p><img src="/2021/06/13/CG/YLQ-GAMES202/14/image-20210614151247397.png" style="zoom:50%;"></p>
<h4 id="效果对比">效果对比</h4>
<ul>
<li>540p Bicubic Upsampled to 1080p</li>
</ul>
<p><img src="/2021/06/13/CG/YLQ-GAMES202/14/image-20210614151725046.png"></p>
<ul>
<li>540p to 1080p DLSS2.0</li>
</ul>
<p><img src="/2021/06/13/CG/YLQ-GAMES202/14/image-20210614151801326.png"></p>
<ul>
<li>1080p with TAA</li>
</ul>
<p><img src="/2021/06/13/CG/YLQ-GAMES202/14/image-20210614151819215.png"></p>
<ul>
<li>DLSS 2.0 的效果可能更加锐利，因为 Temporal
的复用可能提高的分辨率不止 2x</li>
</ul>
<h4 id="其他">其他</h4>
<ul>
<li>DLSS 网络跑得快，具体怎么实现不清楚
<ul>
<li>Network inference performance optimization (classified)</li>
</ul></li>
<li>AMD 也有 DLSS
<ul>
<li>AMD：FidelityFX Super Resolution</li>
<li>同样性能的 <strong>CPU</strong>，AMD 的价格大概在 Nvidia
的一半价格</li>
</ul></li>
<li>Facebook：Neural Supersampling for Real-time Rendering [Xiao et al.]
<ul>
<li>效果不太好，实现上更像 DLSS 1.0，工业界不好用</li>
</ul></li>
</ul>
<h2 id="避免没有意义的-shading">避免没有意义的 shading</h2>
<h3 id="deferred-shading">Deferred Shading</h3>
<ul>
<li>延迟渲染</li>
<li>让 shading 变得更加高效，速度更快</li>
<li>传统的光栅化渲染管线
<ul>
<li>Triangles -&gt; fragments -&gt; depth test -&gt; shade -&gt;
pixel</li>
</ul></li>
<li>延迟渲染的想法
<ul>
<li>在传统的光栅化渲染管线下，只有对视点可见的点的 shading
才是真正有效的，其他点的渲染本质上都是是无用功</li>
</ul></li>
<li>最坏的情况
<ul>
<li>对于每一个
fragment，都是<strong>从远到近</strong>渲染的，这样做了很多无用功</li>
<li>这样每一个点都得做 shading</li>
<li>复杂度：O(#fragment <span class="math inline">\(\times\)</span>
#light)</li>
</ul></li>
<li>延迟渲染的基本想法
<ul>
<li>大部分的 fragment 在最终的 image 中是不可见的</li>
<li>我们只需要渲染在最终的 image 中可见的 fragment</li>
</ul></li>
</ul>
<h4 id="思路">思路</h4>
<ul>
<li>光栅化两次</li>
<li>第一次光栅化
<ul>
<li>只生成 depth-buffer</li>
<li>不做 shading</li>
</ul></li>
<li>第二次光栅化
<ul>
<li>给通过深度测试的 fragment 进行 shading</li>
<li>因为对于每一个像素，能够通过深度测试的 fragment 只会有 1 个</li>
</ul></li>
<li>延迟渲染的基本想法
<ul>
<li>一次光栅化的开销比对大量不必要点的 shading 计算开销要小</li>
<li>assume rasterizing the scene is way faster than shading all unseen
fragments (<strong>usually true</strong>)</li>
</ul></li>
<li>复杂度：O(#vis. fragment <span class="math inline">\(\times\)</span>
#light)</li>
<li>问题
<ul>
<li>我们做不了 AA（G-Buffer 不能做 AA）</li>
<li>但是可以通过 TAA 或者图像空间上的 AA，AA 的问题能够被很好的解决</li>
</ul></li>
<li>因此延迟渲染成为工业界的标配</li>
</ul>
<h3 id="tiled-shading">Tiled Shading</h3>
<ul>
<li><strong>优化光源</strong></li>
<li>把屏幕切分为若干个 tile（大概每个 <span class="math inline">\(32\times32\)</span>），每个小块单独做 shading</li>
<li>这样子的方法可以<strong>减少每一个小块需要考虑的光源数目</strong></li>
<li>如下是 frustum 的俯视图</li>
</ul>
<p><img src="/2021/06/13/CG/YLQ-GAMES202/14/image-20210614164138654.png" style="zoom:50%;"></p>
<ul>
<li>对于每一个小条，不是所有光源都会影响到它
<ul>
<li>光源的平方衰减
<ul>
<li>上面的圆圈表示每一个光源的覆盖范围（球投影成圆）</li>
</ul></li>
<li>上面的数字表示影响到这个光源的光源个数</li>
</ul></li>
<li>复杂度：O(#vis. frag. <span class="math inline">\(\times\)</span>
avg #light per tile)</li>
</ul>
<h3 id="clustered-shading">Clustered shading</h3>
<p><img src="/2021/06/13/CG/YLQ-GAMES202/14/image-20210614164138654.png" style="zoom:50%;"></p>
<ul>
<li>想法和 tiled shading 类似</li>
<li>深度上也切片</li>
<li>一个格子可能包含多个像素，前面可能不会把后面整个各自都遮挡住</li>
</ul>
<h2 id="level-of-detail">Level of Detail</h2>
<ul>
<li>LoD
<ul>
<li>例如 mipmap 就是一个 level of detail</li>
</ul></li>
<li>在具体使用的时候，选择正确的层级去使用，这样能够节省计算的效率</li>
<li>RTR 工业界中把这种在对不同层级细节的使用称为
<strong>cascaded</strong></li>
<li>shadow map 可以用来做 LoD</li>
</ul>
<h3 id="cascaded-shadow-map">Cascaded Shadow Map</h3>
<ul>
<li>[Dimitrov et al., Cascaded Shadow Maps]</li>
<li>离视点近的物体使用高分辨率的 SM，离视点远的物体使用低分辨率的 SM
<ul>
<li>下图中，三角形为 frustum，红色使用高分辨率 SM，蓝色使用低分辨率
SM</li>
</ul></li>
</ul>
<p><img src="/2021/06/13/CG/YLQ-GAMES202/14/image-20210614182849481.png" style="zoom:50%;"></p>
<ul>
<li>实际应用中我们很难生成一张变分辨率的
SM，因此实际应用会生成多张不同分辨率的 SM</li>
<li>针对不同距离，我们使用不同分辨率的 SM</li>
<li>范围会有一些重叠
<ul>
<li>保证切换 SM 时能够平滑过渡</li>
<li>重叠区域使用两个 SM 混合的效果</li>
</ul></li>
</ul>
<h3 id="cascaded-lpv">Cascaded LPV</h3>
<ul>
<li>[Anton Kaplanyan, Light Propagation Volumes in CryEngine 3]</li>
<li>近处比较小，远处比较大</li>
</ul>
<p><img src="/2021/06/13/CG/YLQ-GAMES202/14/image-20210614183357657.png" style="zoom:67%;"></p>
<h3 id="geometric-lod">Geometric LoD</h3>
<ul>
<li>高模（三角形多的模型）、低模（三角形少的模型）</li>
<li>预先生成一系列的不同三角形数的模型</li>
<li>可以对一个物体的不同部分使用不同精细程度的模型细节</li>
<li>UE5 的 Nanite 就是利用这些原理实现</li>
<li>对于引擎来说，技术实现是难点</li>
</ul>
<h3 id="cascaded-的问题">Cascaded 的问题</h3>
<ul>
<li>在不同层级之间切换的时候可能会有问题（popping artifactss）
<ul>
<li>通常的方法可以在边界的地方使用 blending 的方法</li>
<li>Popping artifacts
<ul>
<li>TAA 处理（复用上一帧的信息）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="引擎实现的难点">引擎实现的难点</h3>
<ul>
<li>一个物体的不同部分使用不同层级的
LoD，怎么保证相接的地方是没有缝的？</li>
<li>如何动态加载和调度不同层级的资源？
<ul>
<li>GPU 容量有限</li>
</ul></li>
<li>Representing geometry using triangles or geometry textures?
<ul>
<li>怎么表示几何形体？三角形？几何纹理？</li>
</ul></li>
<li>引擎实现的加速
<ul>
<li>clipping 裁剪</li>
<li>culling 剔除（背面剔除）</li>
</ul></li>
</ul>
<h2 id="全局光照的解决方法">全局光照的解决方法</h2>
<ul>
<li>SSR 屏幕空间光线跟踪</li>
<li>没有一种简单的 GI 方法能够解决所有的场景
<ul>
<li>RTRT可以，但是现在还是太慢了</li>
</ul></li>
<li>工业界经常把多种方法混合起来使用</li>
<li>一个 GI 的解决方案
<ul>
<li>SSR 得到近似的 GI</li>
<li>对于 SSR 失败的地方，是用其他方式补充
<ul>
<li>hardware (RTRT) or software ray tracing</li>
</ul></li>
</ul></li>
<li>软件光追
<ul>
<li><span style="color:red">HQ SDF for individual objects that are
close-by</span>
<ul>
<li>高质量的有向距离场</li>
</ul></li>
<li><span style="color:red">LQ SDF for the entire scene</span></li>
<li><span style="color:red">RSM if there are strong directional / point
lights</span>
<ul>
<li>手电筒</li>
</ul></li>
<li>Dynamic Diffuse GI(<strong>DDGI</strong>)
<ul>
<li>Probes that stores irradiance in a 3D grid</li>
<li>利用这些探针去照亮整个场景</li>
</ul></li>
</ul></li>
<li>硬件光追
<ul>
<li><span style="color:red">Doesn’t have to use the original geometry,
but low-poly proxies</span>
<ul>
<li>使用简化的模型</li>
</ul></li>
<li>Probes（RTXGI）</li>
</ul></li>
<li>以上<span style="color:red">红色部分</span>是 UE5 的 Lumen 实现</li>
</ul>
<h2 id="课程没有涉及的部分">课程没有涉及的部分</h2>
<ul>
<li>Texturing an SDF</li>
<li>Transparent material and order-independent transparency</li>
<li>Particle rendering</li>
<li>Post processing (depth of field, motion blur, etc.)</li>
<li>Random seed and blue noise
<ul>
<li>蓝噪声：</li>
</ul></li>
<li>Foveated rendering
<ul>
<li>注视点投入更多渲染的算力</li>
</ul></li>
<li>Probe based global illumination</li>
<li>ReSTIR, Neural Radiance Caching, etc.</li>
<li>Many-light theory and light cuts</li>
<li>Participating media, SSSSS
<ul>
<li>参与介质</li>
<li>次表面散射</li>
</ul></li>
<li>Hair appearance</li>
<li>......</li>
</ul>
<p><img src="/2021/06/13/CG/YLQ-GAMES202/14/image-20210614192555110.png" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>CG.GAMES202</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>YLQ</tag>
      </tags>
  </entry>
  <entry>
    <title>mitsuba 开发指南(01)</title>
    <url>/2021/11/25/CG/mitsuba/doc1/</url>
    <content><![CDATA[<h1 id="mitsuba-开发指南.01">mitsuba 开发指南.01</h1>
<ul>
<li>参考 document 版本</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Mitsuba Documentation</span><br><span class="line">Version 0.5.0</span><br><span class="line">Wenzel Jakob</span><br><span class="line">February 25, 2014</span><br></pre></td></tr></table></figure>
<h2 id="一些个问题">一些个问题</h2>
<ul>
<li>在写代码的时候一直在报错，找不到 <code>Float</code>
的定义，为了不报错，我在如下文件中加了定
<ul>
<li><code>include/mitsuba/core/platform.h</code></li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_PRECISION <span class="comment">// 这一行是我添加的, 编译的时候需要去掉</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(DOUBLE_PRECISION)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Float;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(SINGLE_PRECISION)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> Float;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> No precision flag was defined!</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>这个指定是在编译指令中指定的
<ul>
<li><code>config.py</code></li>
<li>一个服务器上可行的<a href="/utils/show_code/index.html?mitsuba/config.py">配置</a></li>
</ul></li>
<li>更好的解决方式是在 vscode 中预定义宏
<ul>
<li><a href="/2022/03/01/software/vscode/01/">solution</a></li>
</ul></li>
</ul>
<h2 id="code-structure">9. Code Structure</h2>
<ul>
<li>分为 4 个部分
<ul>
<li>libcore：图片 IO、数据结构、程序调度、插件管理</li>
<li>librender：场景（光源、材质、参与介质、shapes）</li>
<li>libhw：硬件加速、显示、OpenGL、交互 GUI</li>
<li>libidir：为了实现 BDPT 准备的一些库</li>
</ul></li>
</ul>
<h2 id="coding-style">10. Coding Style</h2>
<ul>
<li>4 空格缩进</li>
<li>左括号同行</li>
<li>命名格式：camel-case
<ul>
<li>类名首字母大写</li>
<li>成员函数首字母小写</li>
<li>成员变量加上前缀：<code>m_</code></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; m_value = value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>枚举变量加上前缀 <code>E</code></li>
<li>尽量能加 <code>const</code> 就加上 <code>const</code></li>
<li>简单函数使用 <code>inline</code></li>
<li>头文件加注释</li>
<li>使用 Boost 库</li>
<li><strong>所有的 class 都会被分配在堆上</strong>，struct
可能在堆上也可能在栈上
<ul>
<li>使用方式如下</li>
<li><code>ref&lt;&gt;</code></li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (..) &#123;</span><br><span class="line">    ref&lt;MyClass&gt; instance = <span class="keyword">new</span> <span class="built_in">MyClass</span>();</span><br><span class="line">    instance-&gt;<span class="built_in">doSomething</span>()</span><br><span class="line">&#125; <span class="comment">// reference expires, instance will be deallocated</span></span><br></pre></td></tr></table></figure>
<ul>
<li>实现插件的时候，继承自泛化的接口</li>
</ul>
<h2 id="实现一个用户插件plugin">11. 实现一个用户插件(plugin)</h2>
<ul>
<li>两种方式
<ul>
<li>sampling-based integrators
<ul>
<li>基于光线追踪，发出一条光线，估计它的 incident radiance</li>
<li>实现 <code>SamplingIntegrator</code> 接口即可
<ul>
<li>这样我们并行层、网络层自然实现（不需要我们自己写）</li>
</ul></li>
<li>也可以实现其他接口
<ul>
<li>an irradiance cache</li>
<li>an adaptive integrator</li>
</ul></li>
</ul></li>
<li>generic ones
<ul>
<li>不能归为上一类的，需要一些特殊的操作，例如 VPL</li>
</ul></li>
</ul></li>
</ul>
<h3 id="实现一个深度查看器的教程">(1) 实现一个深度查看器的教程</h3>
<h4 id="文件夹">文件夹</h4>
<ul>
<li><code>src/integrators/</code> 文件夹下新建文件夹
<code>depthmap</code>，接下来的操作全在 <code>depthmap</code>
文件夹中操作</li>
</ul>
<h4 id="depthviewer.cpp">depthViewer.cpp</h4>
<ul>
<li>新建 <code>depthViewer.cpp</code> 文件</li>
<li>具体内容看 <code>cpp</code> 代码
<ul>
<li><a href="/utils/show_code/index.html?mitsuba/learn/DepthViewer/DepthViewer.cpp">Code</a></li>
</ul></li>
<li>实际调用序列化函数的时候按照如下方法
<ul>
<li>我们想要的是对整个对象进行序列化，不仅简单的递归调用，可能存在如下问题
<ul>
<li>某个成员被引用多次（浪费空间）</li>
<li>互相引用（陷入无限递归）</li>
</ul></li>
<li>当我们需要对堆上的物体进行序列化和反序列化的时候，进行如下调用</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">ref&lt;SomeClass&gt; myObject = ...;</span><br><span class="line">manager-&gt;<span class="built_in">serialize</span>(stream, myObject.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">ref&lt;SomeClass&gt; myObject =</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;SomeClass *&gt;(manager-&gt;<span class="built_in">getInstance</span>(stream));</span><br></pre></td></tr></table></figure>
<h4 id="导出插件">导出插件</h4>
<ul>
<li><code>integrators</code> 文件夹下有一个 <code>SConscript</code>
文件，加上如下一行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plugins += env.SharedLibrary(<span class="string">&#x27;DepthViewer&#x27;</span>, [<span class="string">&#x27;depthViewer/depthViewer.cpp&#x27;</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>在根目录编译</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">linux</span></span><br><span class="line">scons -j$(nproc)</span><br></pre></td></tr></table></figure>
<ul>
<li>生成的文件在 <code>dist</code> 文件夹下</li>
<li>场景文件配置如下
<ul>
<li><code>test.xml</code>
<ul>
<li>应该得到一张<strong>全绿色的照片</strong></li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">scene</span> <span class="attr">version</span>=<span class="string">&quot;0.6.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integrator</span> <span class="attr">type</span>=<span class="string">&quot;DepthViewer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;spectrum name=&quot;color&quot; value=&quot;1.0&quot;/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">integrator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scene</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>渲染</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">./mitsuba -o test1 test.xml</span><br></pre></td></tr></table></figure>
<ul>
<li>生成了一张 <code>test.exr</code>，转化为 <code>test.png</code>
查看</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./mtsutil tonemap -f png -t test1.exr</span><br></pre></td></tr></table></figure>
<h4 id="其他场景">其他场景</h4>
<p><img src="/2021/11/25/CG/mitsuba/doc1/glass_dmap.png" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>mitsuba</category>
      </categories>
      <tags>
        <tag>mitsuba</tag>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>mitsuba.不同渲染方法在不同场景上的对比</title>
    <url>/2021/04/26/CG/mitsuba/methodsCompare/</url>
    <content><![CDATA[<h1 id="不同渲染方法在不同场景上的对比">不同渲染方法在不同场景上的对比</h1>
<h1 id="mitsuba-0.6">mitsuba 0.6</h1>
<h2 id="说明">说明</h2>
<h3 id="使用环境">使用环境</h3>
<ul>
<li>Ubuntu</li>
<li>mitsuba 0.6</li>
</ul>
<h3 id="场景文件">场景文件</h3>
<ul>
<li>https://github.com/bacTlink/mitsuba-CPPM-scenes</li>
</ul>
<h3 id="一些问题">一些问题</h3>
<ul>
<li>没有 sudo 权限运行时指定动态库加载位置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=~/mitsuba-VCM/dist/</span><br></pre></td></tr></table></figure>
<ul>
<li>上传文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -i rsa -P portNum -r localDir xx@xx.xx.xx.xx:serverDir</span><br></pre></td></tr></table></figure>
<h2 id="结果对比">结果对比</h2>
<ul>
<li>mitsuba 是通过修改 integrator 来修改具体的配置的</li>
</ul>
<h3 id="artware-场景">artware 场景</h3>
<h4 id="path">path</h4>
<ul>
<li>路径追踪</li>
<li>Path tracer</li>
<li>mitsuba 的参数</li>
</ul>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 9%">
<col style="width: 74%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">参数</th>
<th style="text-align: center;">类型</th>
<th style="text-align: center;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">maxDepth</td>
<td style="text-align: center;">integer</td>
<td style="text-align: center;">最大路径长度</td>
</tr>
<tr class="even">
<td style="text-align: center;">rrDepth</td>
<td style="text-align: center;">integer</td>
<td style="text-align: center;">大于设定值之后，采用俄罗斯轮盘赌的方式以一定概率停止（5）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">strictNormals</td>
<td style="text-align: center;">boolean</td>
<td style="text-align: center;">严格法线（false）</td>
</tr>
<tr class="even">
<td style="text-align: center;">hideEmitters</td>
<td style="text-align: center;">boolean</td>
<td style="text-align: center;">隐藏直接光源（false）</td>
</tr>
</tbody>
</table>
<ul>
<li>严格法线：法线插值带来的问题，可能出现这样子的情况
<ul>
<li>根据插值法线，光线是从物体外面击中物体，但是根据实际的几何法线，光线是从物体里面击中的
<ul>
<li>漏光效果</li>
</ul></li>
<li>设置为 true 会将这些光线去除</li>
<li>They can lead to paradoxical situations where a light ray impinges
on an object from a direction that is classified as “outside” according
to the shading normal, and “inside” according to the true geometric
normal.</li>
</ul></li>
<li>配置文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">integrator</span> <span class="attr">type</span>=<span class="string">&quot;path&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integer</span> <span class="attr">name</span>=<span class="string">&quot;maxDepth&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">integrator</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>运行渲染器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/mitsuba-VCM/dist/mitsuba -o artware_PATH_maxdepth=5 artware_SPPM.xml</span><br></pre></td></tr></table></figure>
<ul>
<li>将导出的 exr 格式的图片转化为 png 格式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/mitsuba-VCM/dist/mtsutil tonemap -f png -t artware_PATH_maxdepth=5.exr</span><br></pre></td></tr></table></figure>
<ul>
<li>运行时间很短，效果如下，整个场景很暗，直接找到的有效路径很少</li>
</ul>
<p><img src="/2021/04/26/CG/mitsuba/methodsCompare/artware_PATH_maxdepth=5.png" alt="artware_BDPT_maxdepth=5" style="zoom: 50%;"></p>
<ul>
<li>将最大深度修改为 <code>33</code>（和 SPPM 一致），效果如下
<ul>
<li>虽然场景亮了一些，效果还是不太好，还是找不到有效的路径</li>
</ul></li>
</ul>
<p><img src="/2021/04/26/CG/mitsuba/methodsCompare/artware_PATH_maxdepth=33.png" alt="artware_BDPT_maxdepth=5" style="zoom: 50%;"></p>
<h4 id="bdpt">bdpt</h4>
<ul>
<li>双向路径追踪</li>
<li>Bidirectional path tracer</li>
<li>mitsuba 的参数</li>
</ul>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 9%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">参数</th>
<th style="text-align: center;">类型</th>
<th style="text-align: center;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">maxDepth</td>
<td style="text-align: center;">integer</td>
<td style="text-align: center;">最大路径长度</td>
</tr>
<tr class="even">
<td style="text-align: center;">rrDepth</td>
<td style="text-align: center;">integer</td>
<td style="text-align: center;">大于设定值之后，采用俄罗斯轮盘赌的方式以一定概率停止（5）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">lightImage</td>
<td style="text-align: center;">boolean</td>
<td style="text-align: center;">每条从 camera 除法的 subpath
是否直接对光源采样（true）</td>
</tr>
<tr class="even">
<td style="text-align: center;">sampleDirect</td>
<td style="text-align: center;">boolean</td>
<td style="text-align: center;">是否采用直接采样策略（true）</td>
</tr>
</tbody>
</table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">integrator</span> <span class="attr">type</span>=<span class="string">&quot;bdpt&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integer</span> <span class="attr">name</span>=<span class="string">&quot;maxDepth&quot;</span> <span class="attr">value</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">integrator</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/mitsuba-VCM/dist/mitsuba -o artware_BDPT_maxdepth=33 artware_use.xml</span><br><span class="line">~/mitsuba-VCM/dist/mtsutil tonemap -f png -t artware_BDPT_maxdepth=33.exr</span><br></pre></td></tr></table></figure>
<ul>
<li>效果如下，和 path tracing
相比而言，能够获得更好的效果，简单体现在整体亮度更亮</li>
<li>而且能够较好的模拟焦散的现象，对于手电筒的发光也能较好的模拟</li>
</ul>
<p><img src="/2021/04/26/CG/mitsuba/methodsCompare/artware_BDPT_maxdepth=33.png" style="zoom: 50%;"></p>
<ul>
<li>修改一些参数我们看看结果</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">integrator</span> <span class="attr">type</span>=<span class="string">&quot;bdpt&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integer</span> <span class="attr">name</span>=<span class="string">&quot;maxDepth&quot;</span> <span class="attr">value</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">boolean</span> <span class="attr">name</span>=<span class="string">&quot;lightImage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">integrator</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/mitsuba-VCM/dist/mitsuba -o artware_BDPT_maxdepth=33_lightImage_false artware_use.xml</span><br><span class="line">~/mitsuba-VCM/dist/mtsutil tonemap -f png -t artware_BDPT_maxdepth=33_lightImage_false.exr</span><br></pre></td></tr></table></figure>
<ul>
<li>结果如下，我们去除了路径对光源的直接采样，最终的结果没有这么亮，相当于能够采样到光源的路径变少了
<ul>
<li>但是为什么焦散现象也变少了，这个应该是 SDS 路径</li>
</ul></li>
</ul>
<p><img src="/2021/04/26/CG/mitsuba/methodsCompare/artware_BDPT_maxdepth=33_lightImage_false.png" style="zoom: 50%;"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">integrator</span> <span class="attr">type</span>=<span class="string">&quot;bdpt&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integer</span> <span class="attr">name</span>=<span class="string">&quot;maxDepth&quot;</span> <span class="attr">value</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">boolean</span> <span class="attr">name</span>=<span class="string">&quot;sampleDirect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">integrator</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/mitsuba-VCM/dist/mitsuba -o artware_BDPT_maxdepth=33_sampleDirect_false artware_use.xml</span><br><span class="line">~/mitsuba-VCM/dist/mtsutil tonemap -f png -t artware_BDPT_maxdepth=33_sampleDirect_false.exr</span><br></pre></td></tr></table></figure>
<ul>
<li>感觉没多大区别</li>
</ul>
<p><img src="/2021/04/26/CG/mitsuba/methodsCompare/artware_BDPT_maxdepth=33_sampleDirect_false.png" style="zoom:50%;"></p>
<h4 id="photonmapper">photonmapper</h4>
<ul>
<li>photon mapping</li>
<li>简单使用默认参数设置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">integrator</span> <span class="attr">type</span>=<span class="string">&quot;photonmapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integer</span> <span class="attr">name</span>=<span class="string">&quot;maxDepth&quot;</span> <span class="attr">value</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">integrator</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/mitsuba-VCM/dist/mitsuba -o artware_pm_maxdepth=33 artware_use.xml</span><br><span class="line">~/mitsuba-VCM/dist/mtsutil tonemap -f png -t artware_pm_maxdepth=33.exr</span><br></pre></td></tr></table></figure>
<ul>
<li>结果如下，PM 算法
<ul>
<li>PM 作为一种无偏的算法，最大的问题就是会产生一种糊的感觉</li>
<li>但是由于加入了对于焦散的优化查找，最终也能模拟焦散的结果</li>
</ul></li>
</ul>
<p><img src="/2021/04/26/CG/mitsuba/methodsCompare/artware_pm_maxdepth=33.png" style="zoom:50%;"></p>
<ul>
<li>传统的 PM 算法是模拟不了 焦散的现象的，参数如下</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">integrator</span> <span class="attr">type</span>=<span class="string">&quot;photonmapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integer</span> <span class="attr">name</span>=<span class="string">&quot;maxDepth&quot;</span> <span class="attr">value</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">float</span> <span class="attr">name</span>=<span class="string">&quot;causticLookupRadius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">integrator</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/mitsuba-VCM/dist/mitsuba -o artware_pm_maxdepth=33_no_caustic artware_use.xml</span><br><span class="line">~/mitsuba-VCM/dist/mtsutil tonemap -f png -t artware_pm_maxdepth=33_no_caustic.exr</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/26/CG/mitsuba/methodsCompare/artware_pm_maxdepth=33_no_caustic.png" style="zoom:50%;"></p>
<h4 id="ppm">ppm</h4>
<ul>
<li>Progressive photon mapping integrator</li>
<li>渐进式光子映射</li>
<li>多次累计，一起估计</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">integrator</span> <span class="attr">type</span>=<span class="string">&quot;ppm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integer</span> <span class="attr">name</span>=<span class="string">&quot;maxDepth&quot;</span> <span class="attr">value</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integer</span> <span class="attr">name</span>=<span class="string">&quot;maxPasses&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">integrator</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/mitsuba-VCM/dist/mitsuba -o artware_PMM_maxPasses=100 artware_use.xml</span><br><span class="line">~/mitsuba-VCM/dist/mtsutil tonemap -f png -t artware_PMM_maxPasses=100.exr</span><br></pre></td></tr></table></figure>
<ul>
<li>运行速度比 SPPM 慢很多，初始的建立以及每个 pass 都比较慢</li>
<li>效果如下
<ul>
<li>比 PM 的效果更好，而且不会导致内存爆炸的问题，运行速度比 PM 慢</li>
<li>噪点比较多，收敛的问题</li>
</ul></li>
</ul>
<p><img src="/2021/04/26/CG/mitsuba/methodsCompare/artware_PMM_maxPasses=100.png" style="zoom: 50%;"></p>
<h4 id="sppm">sppm</h4>
<ul>
<li>Stochastic progressive photon mapping integrator</li>
<li>随机渐进式光子映射</li>
<li>分批生成，分批估计</li>
<li>服务器上给的参数直接尝试运行时间太久了，我们把 pass 修改为 100</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">integrator</span> <span class="attr">type</span>=<span class="string">&quot;sppm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integer</span> <span class="attr">name</span>=<span class="string">&quot;maxDepth&quot;</span> <span class="attr">value</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">boolean</span> <span class="attr">name</span>=<span class="string">&quot;strictNormals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integer</span> <span class="attr">name</span>=<span class="string">&quot;kNN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integer</span> <span class="attr">name</span>=<span class="string">&quot;maxPasses&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integer</span> <span class="attr">name</span>=<span class="string">&quot;stepSnapshot&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integer</span> <span class="attr">name</span>=<span class="string">&quot;photonCount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;655360&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">float</span> <span class="attr">name</span>=<span class="string">&quot;k&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">float</span> <span class="attr">name</span>=<span class="string">&quot;beta&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1.2&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">integrator</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/mitsuba-VCM/dist/mitsuba -o artware_SPMM_maxPasses=100 artware_use.xml</span><br><span class="line">~/mitsuba-VCM/dist/mtsutil tonemap -f png -t artware_SPMM_maxPasses=100.exr</span><br></pre></td></tr></table></figure>
<ul>
<li>运行时间相对较长，效果如下
<ul>
<li>SPPM 算法达到收敛需要比较长的时间，我们只是使用了 100
pass，因此图上还是出现了一些模糊的现象（有偏导致的）</li>
</ul></li>
</ul>
<p><img src="/2021/04/26/CG/mitsuba/methodsCompare/artware_SPMM_maxPasses=100.png" style="zoom: 50%;"></p>
<ul>
<li>增大 maxPasses = 1000，效果如下
<ul>
<li>我们可以看到整体而言，模糊程度比 100 小了好多，这是因为 PM 是一致的
<ul>
<li>当采样数足够多的时候，<span class="math inline">\(\Delta S\)</span>
足够小，此时是正确的</li>
</ul></li>
<li>但是出现了一些白色的亮点，这是由于高贡献路径采样概率小导致的，需要更多的采样数直至收敛才能解决</li>
</ul></li>
</ul>
<p><img src="/2021/04/26/CG/mitsuba/methodsCompare/artware_SPMM_maxPasses=1000.png" style="zoom: 50%;"></p>
<h4 id="mlt">mlt</h4>
<ul>
<li>Path SpaceMetropolis Light Transport</li>
<li>利用 MCMC 算法能够比较快的从一条有效路径找到其他有效路径</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">integrator</span> <span class="attr">type</span>=<span class="string">&quot;mlt&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integer</span> <span class="attr">name</span>=<span class="string">&quot;maxDepth&quot;</span> <span class="attr">value</span>=<span class="string">&quot;33&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">boolean</span> <span class="attr">name</span>=<span class="string">&quot;twoStage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">integrator</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/mitsuba-VCM/dist/mitsuba -o artware_MLT_not_2stage artware_use.xml</span><br><span class="line">~/mitsuba-VCM/dist/mtsutil tonemap -f png -t artware_MLT_not_2stage.exr</span><br></pre></td></tr></table></figure>
<ul>
<li>运行很快</li>
<li>能够采样到一些概率较低的路径，但是整体而言效果并不是很好，可能需要其他算法的初始路径作为根据</li>
</ul>
<p><img src="/2021/04/26/CG/mitsuba/methodsCompare/artware_MLT_not_2stage.png" style="zoom: 50%;"></p>
<ul>
<li>2stage：第一遍得到一张低分辨率的图（用于估计分布），第二遍开始真正的渲染</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">integrator</span> <span class="attr">type</span>=<span class="string">&quot;mlt&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integer</span> <span class="attr">name</span>=<span class="string">&quot;maxDepth&quot;</span> <span class="attr">value</span>=<span class="string">&quot;33&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">boolean</span> <span class="attr">name</span>=<span class="string">&quot;twoStage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">integrator</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/mitsuba-VCM/dist/mitsuba -o artware_MLT_2stage artware_use.xml</span><br><span class="line">~/mitsuba-VCM/dist/mtsutil tonemap -f png -t artware_MLT_2stage.exr</span><br></pre></td></tr></table></figure>
<ul>
<li>效果如下，感觉不是太懂为什么是这样的，似乎光源都没了</li>
</ul>
<p><img src="/2021/04/26/CG/mitsuba/methodsCompare/artware_MLT_2stage.png" style="zoom: 50%;"></p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/115244695">ssh/scp</a></li>
<li><a href="http://mitsuba-renderer.org/docs.html">mitsuba 0.5
官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>mitsuba</category>
      </categories>
      <tags>
        <tag>mitsuba</tag>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>mitsuba 0.6 在 Win10 上的环境配置</title>
    <url>/2021/04/26/CG/mitsuba/mitsuba-0-6-installation/</url>
    <content><![CDATA[<h1 id="mitsuba0.6-配置">mitsuba0.6 配置</h1>
<h2 id="环境">环境</h2>
<ul>
<li>Win10</li>
<li>VS2017</li>
<li>mitsuba 0.6</li>
</ul>
<h2 id="下载源代码">下载源代码</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --recursive https://github.com/mitsuba-renderer/mitsuba.git</span><br></pre></td></tr></table></figure>
<h2 id="说明">说明</h2>
<ul>
<li>使用 <code>mitsuba-msvc2017.sln</code>
<ul>
<li>也没问题，需要在环境变量中把 python 的路径修改为下面配置的
2.7，同时把 scons 加入环境变量</li>
<li>重启 <code>mitsuba-msvc2017.sln</code> 即可</li>
</ul></li>
<li><strong>最终使用了命令行编译</strong>，但是使用了 MSVC 的工具
<ul>
<li>需要配置一些 <code>msvc</code> 的环境变量，如果你没有配置的话</li>
</ul></li>
</ul>
<h2 id="required-build-dependency">required build dependency</h2>
<ul>
<li>需要下载一些依赖库
<ul>
<li><a href="https://github.com/mitsuba-renderer/dependencies_win64">下载链接</a></li>
</ul></li>
<li>解压到 <code>mitsuba</code> 文件夹下，重命名为
<code>dependencies</code></li>
</ul>
<h2 id="configuration">configuration</h2>
<ul>
<li>把 build 文件夹下的 <code>config-win64-msvc2017.py</code> 复制到
mitsuba 根目录下，重命名为 <code>config.py</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">copy build\config-win64-msvc2017.py .\config.py</span><br></pre></td></tr></table></figure>
<h2 id="安装一个-python2.7-的环境">安装一个 python2.7 的环境</h2>
<ul>
<li><code>config.py</code> 中使用的是 2.7 的语法
<ul>
<li><code>print</code> 语法</li>
</ul></li>
<li>利用 anaconda 创建一个 2.7 的环境</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n py27 python=2.7</span><br></pre></td></tr></table></figure>
<h2 id="安装-scons">安装 scons</h2>
<ul>
<li>利用提供的 scons 2.5.1
<ul>
<li>https://github.com/mitsuba-renderer/dependencies_win64</li>
</ul></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">activate py27</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
<h2 id="unicodedecodeerror">UnicodeDecodeError</h2>
<ul>
<li>UnicodeDecodeError: 'ascii' codec can't decode byte 0xc9 in position
9: ordinal not in range(128):</li>
<li><code>scons</code> 在编译时候会检查所有的环境变量（不仅仅是
path），如果环境变量中含有非 ascii 码的字符就会报错退出</li>
<li>暂时的解决方案是把环境变量中的中文部分做一个修改（或者临时备份，到时候再改回去）</li>
</ul>
<h2 id="运行编译程序">运行编译程序</h2>
<ul>
<li>在 mitsuba 根目录下运行如下命令即可顺利编译
<ul>
<li>需要配置好 MSVC 的环境变量</li>
</ul></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">activate py27</span><br><span class="line">scons -j20</span><br></pre></td></tr></table></figure>
<ul>
<li>或者配置好 py27/scons 的环境变量使用
<code>mitsuba-msvc2017.sln</code> 编译</li>
</ul>
<h2 id="qt">Qt</h2>
<ul>
<li>到此为止应该能够运行 <code>mitsuba.exe</code> 了，但是还是不能运行
<code>misgui.exe</code>
<ul>
<li>dist 目录下</li>
</ul></li>
<li>可以从 <code>dependencies\include\QtCore</code> 中看到 Qt 的版本是
<code>5.9.1</code> ，去官网下载对应版本</li>
<li>https://download.qt.io/archive/qt/5.9/5.9.1/</li>
<li>安装的时候除了默认选项之外，我把所有的 <code>VS2017</code>
相关的都加上了</li>
<li>安装完之后把安装目录下的 <code>platforms/qwindows.dll</code> 复制到
<code>dist/platforms/qwindows.dll</code>
<ul>
<li>可以在安装目录下搜索 <code>qwindows.dll</code></li>
</ul></li>
<li>由于版本问题，需要用 <code>Qt</code> 安装目录下的同名文件覆盖
<code>mtsgui.exe</code> 同目录下的如下文件</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Qt5Core.dll</span><br><span class="line">Qt5Gui.dll</span><br><span class="line">Qt5Network.dll</span><br><span class="line">Qt5OpenGL.dll</span><br><span class="line">Qt5Widgets.dll</span><br><span class="line">Qt5Xml.dll</span><br><span class="line">Qt5XmlPatterns.dll</span><br></pre></td></tr></table></figure>
<h2 id="大功告成">大功告成</h2>
<h2 id="安装过程中踩的坑">安装过程中踩的坑</h2>
<h3 id="安装-scons不能这么安装-版本太高">(1) 安装 scons(不能这么安装,
版本太高)</h3>
<ul>
<li><span style="color:red;font-weight:bold">不能这么安装,
版本太高</span>
<ul>
<li>4.1</li>
</ul></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m pip install scons</span><br></pre></td></tr></table></figure>
<ul>
<li>注意需要把 <code>python</code> 安装的 <code>Scripts</code>
添加到环境变量 <code>PATH</code> 中</li>
<li>例如</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">d:\installed application\python\scripts\</span><br></pre></td></tr></table></figure>
<h3 id="scons-2.5.1-只支持-python2.x">(2) scons 2.5.1 只支持
python2.x</h3>
<ul>
<li>修改 python 为 3.x 失败</li>
</ul>
<h4 id="之前的修改方式">之前的修改方式</h4>
<ul>
<li>利用正则表达式修改为 <code>py3</code> 语法
<ul>
<li>notepad++</li>
<li>注意原来的 L175 是多行的，需要手动改一下</li>
</ul></li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">print([^\n\r]*)</span><br><span class="line">-&gt;</span><br><span class="line">print\(\1\)</span><br></pre></td></tr></table></figure>
<h3 id="一个问题">(3) 一个问题</h3>
<ul>
<li>如果通过 <code>mitsuba-msvc2017.sln</code>
安装的话，需要临时修改环境变量
<ul>
<li>scons 安装在了环境 py27 下</li>
<li>于是 VS2017 调用的应该也是这个环境，而不是我们之前的环境</li>
<li>暂时的解决方案是把环境变量暂时设置为 py27 的环境</li>
</ul></li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">d:\installed application\python\scripts\</span><br><span class="line">D:\installed application\python</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">D:\installed-application\Anaconda3\envs\py27\Scripts</span><br><span class="line">D:\installed-application\Anaconda3\envs\py27</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>https://github.com/mitsuba-renderer/mitsuba/issues/</li>
<li>https://github.com/mitsuba-renderer/mitsuba/issues/52#issuecomment-356929115</li>
<li>https://github.com/mitsuba-renderer/mitsuba/issues/143</li>
</ul>
]]></content>
      <categories>
        <category>installation</category>
        <category>mitsuba</category>
      </categories>
      <tags>
        <tag>installation</tag>
        <tag>mitsuba</tag>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-riscv-源代码阅读.说明</title>
    <url>/2021/03/26/OS/xv6-source-code/00/</url>
    <content><![CDATA[<h2 id="说明">说明</h2>
<ul>
<li><p>xv6-riscv-源代码阅读</p></li>
<li><p><a href="https://github.com/mit-pdos/xv6-riscv">源代码</a></p></li>
<li><p><a href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">参考文档</a></p></li>
<li><p>包括 5 个部分</p>
<ul>
<li>中断与异常</li>
<li>进程线程</li>
<li>同步机制</li>
<li>虚存管理</li>
<li>文件系统</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>0</category>
        <category>OS.xv6-source-code</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-riscv-源代码阅读.中断与异常</title>
    <url>/2021/03/28/OS/xv6-source-code/01-Exception/</url>
    <content><![CDATA[<h1 id="xv6-源代码阅读中断与异常">XV6 源代码阅读——中断与异常</h1>
<h2 id="说明">说明</h2>
<ul>
<li>阅读的代码是 <code>xv6-riscv</code> 版本的</li>
<li>涉及到的文件如下
<ul>
<li><code>kernel</code>
<ul>
<li><code>kernelvsc.S</code>、<code>proc.c</code>、<code>start.c</code>、<code>syscall.c</code>、<code>trampoline.S</code>、<code>trap.c</code>、<code>riscv.h</code>、<code>entry.S</code></li>
</ul></li>
<li><code>user</code>
<ul>
<li><code>sh.c</code>、<code>initcode.S</code></li>
</ul></li>
</ul></li>
</ul>
<h2 id="问题回答">问题回答</h2>
<h3 id="问题-1">(1) 问题 1</h3>
<h4 id="问题">问题</h4>
<ul>
<li>什么是用户态和内核态？两者有何区别？什么是中断和系统调用？两者有何区别？计算机在运行时，是如何确定当前处于用户态还是内核态的？</li>
</ul>
<h4 id="回答">回答</h4>
<ul>
<li>在 RISC-V 中，有 3 种权限不同的模式（Machine mode、Supervisor
mode、User mode）
<ul>
<li>machine mode 拥有所有的特权，一般在启动时候用于配置电脑的环境</li>
<li>supervisor mode
的权限相对低些，可以执行特权指令，例如是否使能中断等</li>
<li>user mode 的权限级别最低，完成一些特殊功能的时候需要通过系统调用进入
supervisor mode</li>
</ul></li>
<li>内核态可以运行在 machine mode 和 supervisor mode
下，用户态只能运行在 user mode</li>
<li>中断与系统调用
<ul>
<li>中断分为外中断和内中断，外中断包括 I/O
中断、时钟中断等，内中断包括异常、系统调用和中止</li>
<li>系统调用指的是处于用户态下的程序需要完成一些只有内核态才能完成的功能时，通过系统调用的方式进入内核态，从而实现功能的行为
<ul>
<li>主动调用，返回到下一条指令</li>
<li>一种中断，需要利用中断的机制来实现</li>
</ul></li>
</ul></li>
<li>在 RISC-V 中，通过寄存器 sstatus 中保存的 SPP 位来判断是处于内核态
(1) 还是用户态 (0)</li>
</ul>
<h3 id="问题-2">(2) 问题 2</h3>
<h4 id="问题-3">问题</h4>
<ul>
<li>什么是中断描述符，中断描述符表？在XV6
里是用什么数据结构表示的？</li>
</ul>
<h4 id="回答-1">回答</h4>
<ul>
<li>RISC-V 中直接在 stvec
寄存器中设定中断处理程序的基地址，然后根据引起中断的不同原因分别进行操作，stvec
可以有两种取值 uservec / kernelvec</li>
<li>如果是一种系统调用的话，在 uservec 中通过 syscall
进行具体功能的调用，参数通过 a
类寄存器传递，具体的系统调用号保存在寄存器 a7 里面，然后在进行 syscall
的时候，直接在数组通过系统调用号索引出具体的系统调用函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># user/initcode.S</span><br><span class="line">start:</span><br><span class="line">  la a0, init</span><br><span class="line">  la a1, argv</span><br><span class="line">  li a7, SYS_exec</span><br><span class="line">  ecall # ecall 陷入内核, 然后执行 uservec(在第三部分提具体的机制)</span><br></pre></td></tr></table></figure>
<h3 id="一次中断的过程">(3) 一次中断的过程</h3>
<ul>
<li>我们使用 trap 来泛指中断
<ul>
<li>系统调用（system call）：用户态程序通过调用 <code>ecall</code>
进入内核态实现功能</li>
<li>异常（exception）：用户态或者内核态程序的操作非法（除零、地址无效等）</li>
<li>设备中断（device interrupt）：例如硬件读写等</li>
</ul></li>
<li>Xv6 trap 的处理过程主要有 4 步
<ul>
<li>RISC-V CPU 硬件做一些相关工作</li>
<li>为内核执行 C 代码准备一个向量组</li>
<li>C trap 处理程序</li>
<li>最后通过 system call 或者 device-driver 进行处理</li>
</ul></li>
<li>硬件在中断中做的事情如下
<ul>
<li>判断 trap 类型，如果是设备中断而且寄存器 sstatus 中的 SIE 位为 0
，那么结束（下列都不执行）</li>
<li>将寄存器 sstatus 中的 SIE 位设置为 0（关掉设备中断）</li>
<li>将 pc 拷贝到寄存器 sepc 中</li>
<li>保存当前模式（user/supervisor）到 sstatus 的 SPP 位中</li>
<li>将 scause 寄存器设置为引起 trap 的原因</li>
<li>设置模式为 supervisor mode</li>
<li>将寄存器 stvec 的内容拷贝到 pc 中
<ul>
<li>stvec 寄存器保存 trap 处理程序的地址</li>
</ul></li>
<li>开始按照新的 pc 执行代码</li>
</ul></li>
<li>硬件在中断中的行为
<ul>
<li>没有切换页表、没有切换栈、没有保存其他寄存器</li>
<li>这样的话相对高效，不是所有程序都需要切换页表的，而且不同程序保存寄存器的方式也不一样，硬件只做必要的事情</li>
</ul></li>
<li>Xv6 在实现 trap 的时候将其分为如下 3 类，分别对应不同的处理程序
<ul>
<li>traps from kernel space</li>
<li>traps from user space</li>
<li>timer interrupts</li>
</ul></li>
<li>我们接下来探讨这 3 类 trap 的不同实现</li>
</ul>
<h4 id="traps-from-kernel-mode">Traps from kernel mode</h4>
<ul>
<li>在内核模式下，trap 只有两类：exceptions 、device interrupt</li>
<li>当一个 trap
发生的时候，首先硬件开始工作，配置好上面提到的环境信息</li>
<li>此时 stvec 指向了 kernelvec 的起始地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kernel/kernelvec.S</span><br><span class="line">.globl kerneltrap</span><br><span class="line">.globl kernelvec</span><br><span class="line">.align 4</span><br><span class="line">kernelvec:</span><br><span class="line">        # 在栈上开辟一块空间用于保存寄存器</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line">        sd ra, 0(sp)</span><br><span class="line">        # ... 保存所有寄存器</span><br><span class="line">        sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        # 调用 C 处理程序</span><br><span class="line">        call kerneltrap</span><br><span class="line"></span><br><span class="line">        # 恢复寄存器到之前的状态</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        # ... 恢复所有的寄存器(除了 tp)</span><br><span class="line">        ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        # 恢复栈指针</span><br><span class="line">        addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">        # 返回到之前的运行状态</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>
<ul>
<li>kernelvec 首先在栈上开辟一块空间，将所有的寄存器都保存下来
<ul>
<li>因为本身就是在内核栈中，直接保存在栈上就行了</li>
</ul></li>
<li>调用 trap 的处理程序 kerneltrap</li>
<li>返回后恢复所有寄存器到原来的状态
<ul>
<li>不需要恢复 tp（thread pointer）</li>
</ul></li>
<li>kerneltrap 的代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"><span class="type">void</span>  <span class="title function_">kerneltrap</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  uint64 sstatus = r_sstatus();</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the yield() may have caused some traps to occur,</span></span><br><span class="line">  <span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span></span><br><span class="line">  w_sepc(sepc);</span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>kerneltrap 首先保存寄存器 sstatus、sepc
<ul>
<li>因为可能在 yield() 的时候出发新的
trap，因此需要保存这些寄存器的值</li>
</ul></li>
<li>权限判断，触发 kerneltrap 的必须是内核态</li>
<li>判断现在的 sstatus 寄存器的 SIE 位是否为 1（是否打开设备中断）
<ul>
<li>如果打开了说明之前有可能出错，正常情况下应该是关闭的</li>
<li>出错原因？</li>
</ul></li>
<li>判断 trap 的原因【通过 devintr() 函数判断】
<ul>
<li>如果是 exceptions ，那么肯定是内核出现错误了</li>
<li>如果是 device interrupt 的话，那么一定是时钟中断，调用 yield()
让出执行权</li>
</ul></li>
<li>最后恢复寄存器 sstatus、sepc 的值</li>
</ul>
<h5 id="一个问题">一个问题</h5>
<ul>
<li>如果 yield() 的时候触发了 trap 怎么进入 kerneltrap 呢？在 user mode
下，stvec 指向的是 usertrap？
<ul>
<li>在调用 usertrap 的时候设置 stvec 为 kerneltrap 即可</li>
<li>由于 RISC-V 硬件在进入 trap 的时候会关闭中断，因此就算有一小段时间
stvec 的值不正确也没事</li>
<li>具体 yield() 的机制还没学习 // TODO</li>
</ul></li>
</ul>
<h4 id="traps-from-user-space">Traps from user space</h4>
<ul>
<li>除了上面提到的两种 trap 之外，用户态下的 trap 还有通过 syscall
触发的系统调用</li>
<li>大体的运作逻辑是这样
<ul>
<li>uservec、usertrap、 usertrapret、userret</li>
</ul></li>
<li>这一部分相对复杂的原因硬件在进入 trap
的时候是没有切换页表的，因此我们在查找具体的页表内容的时候需要通过当前进程中保存的页表地址取计算得到</li>
<li>首先系统进入 trap 之后，硬件会做上面提到的工作
<ul>
<li>但是此时，stvec 指向的地址是 uservec</li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># trampoline.S</span><br><span class="line">uservec:</span><br><span class="line">    # 交换 a0 和 sscratch 寄存器的值</span><br><span class="line">        # so that a0 is TRAPFRAME</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        # 将寄存器保存到当前进程的 trapframe 中</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        # ... 保存寄存去</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">        # 同时也保存 a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0)</span><br><span class="line"></span><br><span class="line">        # 从 user mode 的 traptable 中恢复一些内核的信息</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line">        ld t0, 16(a0)</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # a0 is no longer valid, since the kernel page</span><br><span class="line">        # table does not specially map p-&gt;tf.</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>
<ul>
<li>在进行系统调用之前，p-&gt;trapframe 的起始地址会被保存在 sscratch
寄存器中</li>
<li>因此在运行 usertrap 的时候可以利用 sscatch 寄存器中保存的值找到 user
mode 下的页表地址</li>
<li>usertrap 首先将所有的寄存器保存在 p-&gt;trapframe 中</li>
<li>然后将内核页表的地址修改为和用户的页表地址一致</li>
<li>跳转到 usertrap 执行</li>
<li>usertrap 代码如下（基本思路和之前差不多）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 stvec 为 kernelvec</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存PC, 否则可能会有其他的 usertrap 修改它</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统调用返回下一条命令</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做完寄存器的操作之后打开设备中断</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall(); <span class="comment">// 系统调用</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>usertrap 的流程如下
<ul>
<li>判断权限（要求是用户态）</li>
<li>重新修改 stvec 为 kernelvec
<ul>
<li>当前所处的状态是内核态</li>
<li>之前提到的 yield 问题</li>
</ul></li>
<li>保存一些状态值，避免新的 usertrap 会修改它
<ul>
<li>PC 等</li>
</ul></li>
<li>判断具体引起 trap 的原因
<ul>
<li>如果是 syscall
<ul>
<li>判断进程是否存活</li>
<li>修改 PC = PC + 4（系统调用返回下一条命令）</li>
<li>打开设备中断</li>
<li>syscall 进行系统调用</li>
</ul></li>
<li>如果是 exception
<ul>
<li>杀死进程并报错</li>
</ul></li>
<li>如果是 device interrupt
<ul>
<li>yield</li>
</ul></li>
</ul></li>
<li>最后调用 usertrapret 返回
<ul>
<li>这一部分主要恢复之前保存的状态</li>
</ul></li>
</ul></li>
</ul>
<h4 id="time-interrupt">Time interrupt</h4>
<ul>
<li>具体的机制和上面谈到的一样</li>
<li>time interrupt 的启动
<ul>
<li>在操作系统启动的时候，开启 time interrupt</li>
</ul></li>
</ul>
<h3 id="思考">思考</h3>
<ul>
<li>很多的设计都是一些 trade-off
<ul>
<li>例如在 RISC-V
中，只让硬件做简单的工作，而不用进行一些复杂的操作（页表切换、栈切换等）</li>
<li>这样的设计让不需要做复杂操作的程序运行得更快了（例如
kernelvec）</li>
<li>但是同时需要做上述操作的程序处理起来就更加复杂，而且不是硬件直接做的话，速度上也会有所下降（例如
uservec）</li>
</ul></li>
<li>很多设计的思想其实是相通的，例如这里的 kernelvec
调用的时候需要自己保存一些状态，避免在此时再次引发 trap
的时候修改这些状态量。这和编译器上面递归函数调用的时候需要保存参数等是一致的。</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf</li>
<li>https://github.com/mit-pdos/xv6-riscv</li>
</ul>
]]></content>
      <categories>
        <category>OS.xv6-source-code</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-riscv-源代码阅读.进程线程</title>
    <url>/2021/04/04/OS/xv6-source-code/02-Process-Thread/</url>
    <content><![CDATA[<h1 id="xv6-源代码阅读进程线程">XV6 源代码阅读——进程线程</h1>
<h2 id="说明">说明</h2>
<ul>
<li>阅读的代码是 <code>xv6-riscv</code> 版本的</li>
<li>涉及到的文件如下
<ul>
<li><code>kernel</code>
<ul>
<li><code>entry.S</code>、<code>start.c</code>、<code>main.c</code>、<code>kalloc.c</code>、<code>vm.c</code>、<code>proc.c</code>、<code>swtch.S</code>、<code>proc.h</code>、<code>printf.c</code>、<code>trap.c</code></li>
</ul></li>
<li><code>user</code>
<ul>
<li><code>initcode.S</code></li>
</ul></li>
</ul></li>
</ul>
<h2 id="思考题">思考题</h2>
<ol type="1">
<li>什么是进程，什么是线程？操作系统的资源分配单位和调度单位分别是什么？XV6
中的进程和线程分别是什么，都实现了吗？</li>
<li>进程管理的数据结构是什么？Linux、XV6
中分别叫什么名字？其中包含了哪些内容？操作系统是如何进行管理进程管理数据结构的？它们是如何初始化的？</li>
<li>进程有哪些状态？请画出 XV6 的进程状态转化图。在Linux、XV6
中，进程的状态分别包括哪些？你认为操作系统的设计者为什么会有这样的设计思路？</li>
<li>如何启动多进程（创建子进程）？如何调度多进程？调度算法有哪些？操作系统为何要限制一个CPU
最大支持的进程数？XV6
中的最大进程数是多少？如何执行进程的切换？什么是进程上下文？多进程和多CPU
有什么关系？</li>
<li>内核态进程是什么？用户态进程是什么？它们有什么区别？</li>
<li>进程在内存中是如何布局的，进程的堆和栈有什么区别？</li>
</ol>
<h2 id="阅读报告">阅读报告</h2>
<h3 id="xv6-的启动流程">1. xv6 的启动流程</h3>
<ul>
<li>这一部分讲述 xv6 在启动过程中的配置以及 xv6 中第一个 shell
进程的创建过程</li>
</ul>
<h4 id="kernelentry.s">kernel/entry.S</h4>
<ul>
<li>当 xv6 的系统启动的时候，首先会启动一个引导加载程序（存在 ROM
里面），之后装载内核程序进内存
<ul>
<li>注意由于只有一个内核栈，内核栈部分的地址空间可以是固定，因此 xv6
启动的时候并没有开启硬件支持的 paging
策略，也就是说，对于内核栈而言，它的物理地址和虚拟地址是一样的</li>
<li>引导加载程序把内核代码加载到物理地址为 0x8000000 的地方（0x0 -
0x80000000 之间有 I/O 设备）</li>
</ul></li>
<li>在机器模式下，CPU 从 _entry 处开始执行操作系统的代码
<ul>
<li>首先需要给内核开辟一个内核栈，从而可以执行 C 代码</li>
<li>每一个 CPU 都应该有自己的内核栈（xv6 最多支持 8 个
CPU），开始每个内核栈的大小为 4096 byte，地址空间向下增长</li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kernel/entry.S</span><br><span class="line">_entry:</span><br><span class="line">    # 设置一个内核栈</span><br><span class="line">    # stack0 在 start.c 中声明, 每个内核栈的大小为 4096 byte</span><br><span class="line">    # 以下的代码表示将 sp 指向某个 CPU 对应的内核栈的起始地址</span><br><span class="line">    # 也就是说, 进行如下设置: sp = stack0 + (hartid + 1) * 4096</span><br><span class="line">    la sp, stack0           # sp = stack0</span><br><span class="line">    li a0, 1024*4           # a0 = 4096</span><br><span class="line">    csrr a1, mhartid        # 从寄存器 mhartid 中读取出当前对应的 CPU 号</span><br><span class="line">                            # a1 = hartid</span><br><span class="line">    addi a1, a1, 1          # 地址空间向下增长, 因此将起始地址设置为最大</span><br><span class="line">    mul a0, a0, a1          # a0 = 4096 * (hartid + 1)</span><br><span class="line">    add sp, sp, a0          # sp = stack0 + (hartid + 1) * 4096</span><br><span class="line"></span><br><span class="line">    # 跳转到 kernel/start.c 执行内核代码</span><br><span class="line">    call start</span><br></pre></td></tr></table></figure>
<h4 id="kernelstart.c">kernel/start.c</h4>
<ul>
<li>start() 函数调用</li>
<li>首先进行一些在机器模式下才能进行的机器配置，然后进入 supervisor
模式</li>
<li>机器配置
<ul>
<li>通过调用 mret 进入supervisor mode
<ul>
<li>设置寄存器 mstatus 中的 MPP 位为 supervisor mode</li>
<li>设置返回地址为 main（kernel/main.c）</li>
</ul></li>
<li>将所有的中断异常处理都转交给 supervisor mode</li>
<li>开启时钟中断</li>
<li>把当前 CPU 的 ID 保存在 tp 寄存器当中(（thread pointer）</li>
</ul></li>
<li>最后通过调用如下命令进入 supervisor mode</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm volatile(&quot;mret&quot;)</span><br></pre></td></tr></table></figure>
<ul>
<li>mstatus 寄存器的布局如下</li>
</ul>
<figure>
<img src="/2021/04/04/OS/xv6-source-code/02-Process-Thread/image-20210404123719406.png" alt="image-20210404123719406">
<figcaption aria-hidden="true">image-20210404123719406</figcaption>
</figure>
<h4 id="kernelmain.c">kernel/main.c</h4>
<ul>
<li>main() 函数中首先进行很多属性的配置，然后通过 usetinit()
创建第一个进程</li>
<li>对任意一个 CPU，我们需要配置它一些系统属性</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/main.c</span></span><br><span class="line"><span class="comment">// 1. 打开硬件支持的 paging 策略</span></span><br><span class="line"><span class="comment">// 但是对于内核而言, 使用的策略是虚拟地址直接映射到相同的物理地址</span></span><br><span class="line"><span class="comment">// 通过 w_satp(MAKE_SATP(kernel_pagetable))</span></span><br><span class="line">kvminithart();</span><br><span class="line"><span class="comment">// 2. 装载中断处理函数指针, 内核态的中断处理程序设置为 kernelvec</span></span><br><span class="line">trapinithart();</span><br><span class="line"><span class="comment">// 3. 打开对外部中断的响应</span></span><br><span class="line">plicinithart();</span><br></pre></td></tr></table></figure>
<ul>
<li>对于 0 号 CPU，因为这是第一个启动的
CPU，我们需要进行一些特殊的初始化配置
<ul>
<li>当然也包括上面的配置</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">consoleinit();        <span class="comment">// 配置控制台属性(锁, uart寄存器配置)</span></span><br><span class="line">printfinit();         <span class="comment">// 配置 printf 属性(锁)</span></span><br><span class="line">kinit();              <span class="comment">// 物理页分配策略的初始化(锁, 开辟空间)</span></span><br><span class="line">kvminit();            <span class="comment">// 新建一个内核的物理页表, 调用 kalloc() 生成一个页表(4096 byte)</span></span><br><span class="line">                      <span class="comment">// 通过调用 kvmmake() 设置一些固定的函数入口</span></span><br><span class="line">                      <span class="comment">// 对内核而言, 使用虚拟地址直接映射到物理地址的内核页表映射策略</span></span><br><span class="line">kvminithart();        <span class="comment">// 1</span></span><br><span class="line">procinit();           <span class="comment">// 初始化进程表(最多支持 64 个进程)</span></span><br><span class="line">trapinit();           <span class="comment">// 初始化中断异常处理程序的一些配置(锁)</span></span><br><span class="line">trapinithart();       <span class="comment">// 2</span></span><br><span class="line">plicinit();           <span class="comment">// 设置响应外部中断的处理程序</span></span><br><span class="line">plicinithart();       <span class="comment">// 3</span></span><br><span class="line">binit();              <span class="comment">// buffer cache, 新建 cache, 双向链表形式组织, 锁</span></span><br><span class="line">iinit();              <span class="comment">// inode cache, 文件列表 cache, 锁</span></span><br><span class="line">fileinit();           <span class="comment">// file table, 文件表(锁)</span></span><br><span class="line">virtio_disk_init();   <span class="comment">// emulated hard disk</span></span><br><span class="line">userinit();           <span class="comment">// 新建第一个用户进程</span></span><br><span class="line">__sync_synchronize();</span><br><span class="line">started = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="kernelproc.c">kernel/proc.c</h4>
<ul>
<li>userinit() 函数执行的逻辑如下
<ul>
<li>调用 allocproc() 从进程表中找到一个状态为 UNUSED 的进程
<ul>
<li>找到之后，进行一些初始化配置
<ul>
<li>找不到返回 0，说明已经达到系统内置的最大进程数量</li>
</ul></li>
<li>计算 pid</li>
<li>state 设置为 USED</li>
<li>调用 kalloc() 分配一个 trapframe
<ul>
<li>trapframe 的作用是在用户态进入内核态的时候保存其所有的寄存器</li>
<li>如果没有分配到 trapframe，那么调用 freeproc() 退出
<ul>
<li>freeproc()：属性值修改为空闲、清空内存区域</li>
</ul></li>
</ul></li>
<li>调用 proc_pagetable() 分配一个用户态的页表
<ul>
<li>同时进行页表项的配置等</li>
<li>如果没有分配到页表，那么调用 freeproc() 退出</li>
</ul></li>
<li>设置 context 寄存器 ra、sp（进程切换）
<ul>
<li>ra：用户态应该执行的代码地址</li>
<li>sp：栈指针</li>
</ul></li>
</ul></li>
<li>把初始化代码放入进程的页表中
<ul>
<li>一段机器代码，是一个系统调用 exec("/init")，会执行代码
user/initcode.S，开始运行 shell</li>
<li>只是加载，没有运行</li>
</ul></li>
<li>设置 trapframe 中的寄存器 epc、sp（异常中断返回用户态）
<ul>
<li>epc：用户态的 PC</li>
<li>sp：用户态得到栈指针</li>
</ul></li>
<li>设置进程名称为 <code>initcode</code>，进程工作目录为
<code>/</code></li>
<li>设置进程状态为 RUNNABLE</li>
</ul></li>
<li>最后返回 kernel/main.c 中执行进程调度程序 scheduler()
<ul>
<li>调度之后才开始运行上面加载的机器代码</li>
</ul></li>
<li>之后如果想创建进程的化，都需要通过 shell 调用 exec() 实现</li>
</ul>
<h3 id="进程与线程">2. 进程与线程</h3>
<h4 id="进程">进程</h4>
<ul>
<li>为了满足并发的需求，利用进程模型通过某些机制可以实现多个程序看上去同时运行的状态</li>
<li>进程是程序的一次执行过程，是正在运行程序的抽象，包括程序、数据、控制块集合等</li>
</ul>
<h4 id="线程">线程</h4>
<ul>
<li>线程的引入是为了解决进程占用空间多、切换开销大的问题，对一个进程实体划分为多个线程</li>
<li>线程是进程中的一个运行实体</li>
</ul>
<h4 id="基本单位">基本单位</h4>
<ul>
<li>在线程出现之前，资源分配单位和调度单位都是进程</li>
<li>在线程出现之后，资源分配单位是进程，调度单位是线程</li>
</ul>
<h4 id="xv6">xv6</h4>
<ul>
<li>xv6 只实现了进程，没有实现线程</li>
</ul>
<h3 id="进程管理的数据结构">3. 进程管理的数据结构</h3>
<h4 id="xv6-1">xv6</h4>
<ul>
<li>对于 xv6 而言，进程管理的数据结构是 proc</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span> <span class="comment">// 当前进程的锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下内容如果需要修改的话, 必须持有当前进程的锁 lock</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// 当前进程所处的状态</span></span><br><span class="line">    <span class="type">void</span> *chan;                  <span class="comment">// 非 0 表示当前进程处于 sleep 状态(睡眠地址)</span></span><br><span class="line">    <span class="type">int</span> killed;                  <span class="comment">// 非 0 则表示当前进程被 killed</span></span><br><span class="line">    <span class="type">int</span> xstate;                  <span class="comment">// 退出状态, 可以被父进程的 wait() 检查</span></span><br><span class="line">    <span class="type">int</span> pid;                     <span class="comment">// 进程 ID 号, pid</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要修改父进程指针的话, 需要持有整个进程树的锁</span></span><br><span class="line">    <span class="comment">// kernel/proc.c: pid_lock</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// 父进程指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些变量对于一个进程来说是私有的, 修改的时候不需要加锁</span></span><br><span class="line">    uint64 kstack;               <span class="comment">// 内核栈的虚拟地址</span></span><br><span class="line">    uint64 sz;                   <span class="comment">// 进程所占的内存大小</span></span><br><span class="line">    <span class="type">pagetable_t</span> pagetable;       <span class="comment">// 用户页表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// 当进程在用户态和内核态之间切换时</span></span><br><span class="line">                                 <span class="comment">// 用于保存/恢复进程的状态</span></span><br><span class="line">                                 <span class="comment">// 用于保存寄存器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// 切换进程所需要保存的进程状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// 打开文件列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// 当前工作目录</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// 进程名称</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>进程管理，通过一些变量和函数来管理</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="type">int</span> nextpid = <span class="number">1</span>;            <span class="comment">// 用于进程号的编码</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span>    <span class="comment">// 最多支持 64 个进程</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">pid_lock</span>;</span>   <span class="comment">// 当修改一些整个进程树相关的内容的时候, 需要加的锁</span></span><br><span class="line">                            <span class="comment">// 例如新建一个进程的时候, 需要从 nextpid 中生成一个新的 pid</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">wait_lock</span>;</span>  <span class="comment">// 辅助于 wait() 使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="comment">// 创建一个新的进程并且初始化这个进程, 具体内容在上面已经提到过了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 释放进程的内容空间</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="linux">Linux</h4>
<ul>
<li>Linux 中的进程数据结构更加复杂，表示为
task_struct，其中包含更多的控制信息</li>
<li>在组织上，Linux 将所有的进程组织成一个双向链表，而不是 xv6
中的数组，这样子在进程少的时候内存利用率更高，同时也提供了支持更多进程的可能。</li>
</ul>
<h3 id="进程状态">4. 进程状态</h3>
<h4 id="xv6-2">xv6</h4>
<ul>
<li>xv6 中一共有 6 种状态</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前进程没有被使用, 属于空闲进程</span></span><br><span class="line">    <span class="comment">// (1) 系统启动的时候, 所有的进程的状态都被初始化 UNUSED</span></span><br><span class="line">    <span class="comment">//     当 shell 或者其他方式想要新建一个进程的时候, 会查询是否存在状态为 UNUSED 的进程</span></span><br><span class="line">    <span class="comment">//     如果有, 就会将这个进程拿出来使用, 将他的状态修改为 USED</span></span><br><span class="line">    <span class="comment">// (2) 一个 ZOMBIE 进程被回收之后(wait()), 状态会被修改为 UNUSED</span></span><br><span class="line">    UNUSED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前进程已经被占用, 但是还没有被调度</span></span><br><span class="line">    <span class="comment">// (1) 在 allocproc() 的过程中, 如果发生其他的问题(例如无法分配 trapframe)</span></span><br><span class="line">    <span class="comment">//     此时 USED 状态会被修改回 UNUSED(同时释放内存)</span></span><br><span class="line">    USED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处于睡眠状态</span></span><br><span class="line">    <span class="comment">// 调用 sleep() 的时候会从 RUNNING 状态进入 SLEEPING</span></span><br><span class="line">    SLEEPING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示当前继承处于可以被调度运行的状态</span></span><br><span class="line">    <span class="comment">// (1) wakeup() 可以将一个进程从 SLEEPING 转向 RUNNABLE</span></span><br><span class="line">    <span class="comment">// (2) kill() 会将 SLEEPING 进程状态修改为 RUNNABLE</span></span><br><span class="line">    <span class="comment">// (3) yield() 会让出当前进程的执行权, 让 CPU 重新调度</span></span><br><span class="line">    <span class="comment">//     状态: RUNNING -&gt; RUNNABLE</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1) userinit() 会将 USED 状态修改为 RUNNING</span></span><br><span class="line">    <span class="comment">//     这个调用仅在初始化第一个进程的时候出现</span></span><br><span class="line">    <span class="comment">// (2) 在调用 fork() 的时候, 刚刚被 allocproc() 申请的进程在经过错误检查之后,</span></span><br><span class="line">    <span class="comment">//     USED 状态会被修改为 RUNNABLE</span></span><br><span class="line">    <span class="comment">// (3) scheduler() 调度程序可以把 RUNNABLE 状态的程序修改为 RUNNING</span></span><br><span class="line">    RUNNING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处于进程退出但是还没有被回收的状态(资源已经被回收, 但是还没有被父进程发现)</span></span><br><span class="line">    <span class="comment">// (1) exit() 的调用会让进程 从高 RUNNING 转变为 ZOMBIE</span></span><br><span class="line">    ZOMBIE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>状态转化图如下</li>
</ul>
<pre class="mermaid">graph LR;
A[UNUSED];
B[USED];
C[SLEEPING];
D[RUNNABLE];
E[RUNNING];
F[ZOMBIE];
A --->|"allocproc()"| B
B --->|"freeproc()"| A
C --->|"wakeup()/kill()"| D
E --->|"sleep()"| C
B --->|"userinit()/fork()"| D
D --->|"scheduler()"| E
E --->|"yield()"| D
E --->|"exit()"| F
F --->|"wait()"| A</pre>
<ul>
<li>设计思路我们会在下一部分中讨论</li>
</ul>
<h4 id="linux-1">Linux</h4>
<ul>
<li>Linux 的状态如下，如果不算 xv6 的 UNUSED 状态的话，Linux
的状态更多，可以支持更多的操作</li>
<li>在调度算法上可以支持更复杂而又有效的方法</li>
</ul>
<p><img src="/2021/04/04/OS/xv6-source-code/02-Process-Thread/image-20210404165659973.png" style="zoom:67%;"></p>
<h3 id="进程调度">5. 进程调度</h3>
<h4 id="进程调度策略">进程调度策略</h4>
<ul>
<li>xv6 的进程调度策略非常简单</li>
<li>对整个进程数组循环，遇见可以调度的进程（状态为 RUNNABLE），就让其上
CPU 运行（状态修改为 RUNNING）</li>
<li>由于系统有定时的时钟中断信号，因此这样看起来更像是 RR
轮转调度（但是也并不一致）</li>
</ul>
<h4 id="sleep-and-wakeup">sleep and wakeup</h4>
<ul>
<li>函数原型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span> &#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sleep() 会将当前进程状态设置为 SLEEPING，同时设置等待地址为
chan，然后调用 sched() 重新进行进程调度</li>
<li>wakeup() 会把状态为 SLEEPIN 而且等待地址为 chan
的进程唤醒（状态设置为 RUNNABLE）</li>
</ul>
<h4 id="wait-exit-and-kill">wait, exit, and kill</h4>
<ul>
<li>这里的逻辑设计很好地反映了为什么要设置这么多个状态</li>
<li>函数原型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(uint64 addr)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait() 从进程数组中查找是否有它的子进程正处于 ZOMBIE
状态，如果有则将其回收（状态修改为 UNUSED，将数据结构 proc 的内容归
0，内存区域填入垃圾）</li>
<li>kill() 只是不会讲进程直接杀死，而是将这个进程的 killed 设置为 1
，同时修改其状态
<ul>
<li>如果是 SLEEPING 状态的话，将其状态设置为 RUNNABLE</li>
<li>其余不做处理，因为它们总会到达 RUNNING 的状态</li>
<li>当一个进程转变为被重新调度的时候，必然会经过 usertrap()
返回用户态，再返回之前检查它的 killed 是否非 0，如果非 0，则调用
exit(-1) 退出</li>
</ul></li>
<li>exit() 会回收进程的资源，同时将进程的状态设置为 ZOMBIE
<ul>
<li>同时如果该进程还有子进程的话，会把所有的子进程转交给 init 进程</li>
</ul></li>
<li>以上的设计就很好的解决了问题（资源回收、父子进程间的联系）</li>
</ul>
<h3 id="进程上下文切换">6. 进程上下文切换</h3>
<ul>
<li>内核更像是一个多线程的模型，有两个并发的线程
<ul>
<li>一个是我们的调度程序，始终运行在内核态</li>
<li>另外一个就是常规的可以运行在用户态、以及经过异常中断进入到内核态的程序</li>
</ul></li>
<li>调度程序和另一个程序通过 swtch() 实现轮流执行</li>
<li>swtch(&amp;a, &amp;b) 将当前的上下文存入 a，然后从 b
中读出新的上下文，这样的效果就相当于是上下文切换，还是在一个进程里，但是执行的代码区域已经不一样了</li>
<li>通过 swtch 可以实现线程的切换
<ul>
<li>通过调用 swtch(&amp;c-&gt;context, &amp;p-&gt;context)
将现在的上下文保存到 c-&gt;context 中，然后从 p-&gt;context
读出新的上下文，实现了线程的切换</li>
<li>如果想要切换回原来的线程，只需要从 c-&gt;context
中读入原来的上下文，把当前上下文保存到 p-&gt;context 即可</li>
</ul></li>
</ul>
<h4 id="例子xv6-启动的时候">例子：xv6 启动的时候</h4>
<ul>
<li>启动的时候在调用 allocproc() 的时候，进行了如下的设置</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br></pre></td></tr></table></figure>
<ul>
<li>当代码执行到 scheduler() 的时候，调用 swtch(&amp;c-&gt;context,
&amp;p-&gt;context) ，会将上下文切换到
forkret()，也就是从内核态返回到用户态的代码区域，进行用户态代码的执行，也就是执行一开始保存的
exec("./init") 代码</li>
<li>而当用户态程序自己调用 yield() 或者由于时钟信号调用了 yield()
之后，通过调用 swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context)
可以实现重新进入 scheduler() 程序，重新进行进程的调度</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf</li>
<li>https://github.com/mit-pdos/xv6-riscv</li>
<li>https://zhuanlan.zhihu.com/p/164394603</li>
<li>课程 PPT
<ul>
<li>3-2021-春季-进程线程模型-发布版.pdf</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>OS.xv6-source-code</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-riscv-源代码阅读.同步机制(锁)</title>
    <url>/2021/04/17/OS/xv6-source-code/03-Lock/</url>
    <content><![CDATA[<h1 id="xv6-源代码阅读同步机制锁">XV6 源代码阅读——同步机制(锁)</h1>
<h2 id="说明">说明</h2>
<ul>
<li>阅读的代码是 <code>xv6-riscv</code> 版本的</li>
<li>涉及到的文件如下
<ul>
<li><code>kernel</code>
<ul>
<li><code>kalloc.c</code>、<code>spinlock.h</code>、<code>spinlock.c</code>、<code>sleeplock.h</code>、<code>sleeplock.c</code></li>
</ul></li>
</ul></li>
</ul>
<h2 id="问题">问题</h2>
<ul>
<li>什么是临界区？什么是同步和互斥？什么是竞争状态？临界区操作时中断是否应该开启？中断会有什么影响？XV6
的锁是如何实现的，有什么操作？xchg 是什么指令，该指令有何特性？</li>
</ul>
<ol start="2" type="1">
<li>基于 XV6 的
spinlock，请给出实现信号量、读写锁、信号机制的设计方案（三选二，请写出相应的伪代码）</li>
</ol>
<h2 id="阅读报告">阅读报告</h2>
<h3 id="race">race</h3>
<h4 id="race-发生条件">(1) race 发生条件</h4>
<ul>
<li>同一块内存区域被并发的访问</li>
<li>至少有一个操作是写操作</li>
</ul>
<h4 id="xv6-中的例子">(2) xv6 中的例子</h4>
<ul>
<li>kalloc/kfree</li>
<li>不同 CPU 同时对链表进行操作
<ul>
<li>xv6 中的实现是头部的 push/pop</li>
<li>需要使用锁保护起来，否咋会引发 race</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r = kmem.freelist;</span><br><span class="line">    <span class="keyword">if</span>(r)</span><br><span class="line">        kmem.freelist = r-&gt;next;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Locks Protect Invariants</strong></li>
<li>我们指的使用锁保护数据，我们实际上指的是用锁保护了一组这些数据上的不变量</li>
<li>这些不变量可能在某些短暂的时间段是会变的，但是很快就会被恢复
<ul>
<li>例如上面的 L6-7，在 push 一个元素的时候，有一段时间 kmem.freelist
并没有指向链表的开头，但是快我们在插入之后便将其重新指向了链表的开头</li>
</ul></li>
<li>race
的发生就是在这些不变量发生改变的时候，有另外的程序使用了这个不变量</li>
<li>锁的作用
<ul>
<li>可以理解为我们将一组在临界区上操作序列化了，需要一次一个的执行，从而将不变量很好的保护起来了</li>
<li>也可以理解为我们使用锁将对临界区的操作原子化了</li>
</ul></li>
<li>加锁和解锁之间的区域应该尽量小，否则会影响并行性</li>
</ul>
<h3 id="xv6-中的锁">xv6 中的锁</h3>
<ul>
<li>xv6 中有两种锁：spinlocks、sleep-locks</li>
</ul>
<h3 id="spinlock">spinlock</h3>
<ul>
<li>spinlock 的数据结构如下
<ul>
<li>是一种互斥锁</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mutual exclusion lock.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">    uint locked;       <span class="comment">// 1 表示该锁被持有, 0 表示该锁没有被持有</span></span><br><span class="line">    <span class="comment">// For debugging:</span></span><br><span class="line">    <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>   <span class="comment">// The cpu holding the lock.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="acquirelk">acquire(lk)</h4>
<ul>
<li>我们需要如下的语句（L3-4）原子化，否则可能出现多个 CPU
持有这个锁的情况</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lk-&gt;locked == <span class="number">0</span>) &#123;</span><br><span class="line">            lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="amoswap">amoswap</h5>
<p>RISCV 中提供了这样的指令（是一个原子操作）</p>
<ul>
<li>这个指令将地址 a 处的值（旧值）读取出来，然后把寄存器 r
里的值（新值）写入地址 a 处，然后再把旧值写入寄存器 r 中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">amoswap r, a</span><br></pre></td></tr></table></figure>
<ul>
<li>于是 <code>acquire()</code> 的实现如下
<ul>
<li><code>__sync_lock_test_and_set</code> 底层实现就是利用了
<code>amoswap</code></li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span> &#123;</span><br><span class="line">    push_off(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">    <span class="keyword">if</span>(holding(lk))</span><br><span class="line">        panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">    <span class="comment">//   a5 = 1</span></span><br><span class="line">    <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">    <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">    <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 空循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">    <span class="comment">// past this point, to ensure that the critical section&#x27;s memory</span></span><br><span class="line">    <span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line">    <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">    lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="releaselk">release(lk)</h4>
<ul>
<li>release 的实现类似，只是把锁释放
<ul>
<li><code>__sync_lock_release</code> 底层实现就是利用了
<code>amoswap</code></li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">        panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line">    lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Tell the C compiler and the CPU to not move loads or stores</span></span><br><span class="line">    <span class="comment">// past this point, to ensure that all the stores in the critical</span></span><br><span class="line">    <span class="comment">// section are visible to other CPUs before the lock is released,</span></span><br><span class="line">    <span class="comment">// and that loads in the critical section occur strictly before</span></span><br><span class="line">    <span class="comment">// the lock is released.</span></span><br><span class="line">    <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span></span><br><span class="line">    <span class="comment">// This code doesn&#x27;t use a C assignment, since the C standard</span></span><br><span class="line">    <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">    <span class="comment">// multiple store instructions.</span></span><br><span class="line">    <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">    <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">    <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">    __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line">    pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="xv6-中对-spinlock-的使用">xv6 中对 spinlock 的使用</h3>
<ul>
<li>之前提到的 <code>kernel/kalloc.c</code> 中的 <code>kalloc()</code>
和 <code>free()</code></li>
<li>使用锁的难点
<ul>
<li>哪里该使用锁？</li>
<li>该使用多少个锁？</li>
</ul></li>
<li>当一个 CPU 操作一个变量，同时另一个 CPU 可以写它时，需要使用
lock</li>
<li>如果一个不变量涉及到多个内存位置的时候，需要加锁</li>
<li>为了效率而言，能不加锁的地方尽量不加锁
<ul>
<li>锁减少了并行性</li>
</ul></li>
<li>single kernel lock（一个大内核锁）
<ul>
<li>并行性很差</li>
<li>有些系统调用可能会出问题
<ul>
<li>system calls such as pipe reads or wait would pose a problem</li>
</ul></li>
</ul></li>
<li>如果内核的工作很复杂，更好的设计是设计更多、更细粒度的锁，从而保持较好的并行性</li>
<li>一个粗粒度设计的例子：xv6 中的 kalloc/free
<ul>
<li>只有一个锁</li>
<li>如果有多个 CPU 想要调用 kalloc 申请内存，那么结果将会变得很慢</li>
<li>大家都在 spinlock 上做着无意义的空循环</li>
</ul></li>
<li>一个细粒度设计的例子：xv6 中的文件
<ul>
<li>每一个文件都有一个锁</li>
</ul></li>
<li>xv6 中的锁</li>
</ul>
<p><img src="/2021/04/17/OS/xv6-source-code/03-Lock/image-20210417171819325.png" alt="image-20210417171819325" style="zoom:65%;"></p>
<h3 id="xv6-中关于死锁的讨论">xv6 中关于死锁的讨论</h3>
<ul>
<li>如果通过内核的代码路径必须同时持有多个锁，很重要的一点是，所有代码路径需要以相同的顺序获取这些锁
<ul>
<li>否则可能引发死锁</li>
<li>一个例子
<ul>
<li>A 申请锁的顺序 <code>L1,L2</code>，B 申请锁的顺序
<code>L2,L1</code></li>
<li>死锁：<code>A(L1),B(L2),A(L2),B(L1)</code></li>
</ul></li>
</ul></li>
<li>因此在函数的调用路径上需要好好设计</li>
<li>有的时候可能出现获取锁的顺序和调用顺序不一致的情况，这些都要好好考虑进去</li>
<li>锁的设计越细粒度，死锁的可能性越大</li>
</ul>
<h3 id="锁和中断处理程序">锁和中断处理程序</h3>
<ul>
<li>一个例子就是 sys_sleep() 需要读取 ticks，而 clockintr() 会修改 ticks
<ul>
<li>想像这样一个场景，sys_sleep() 获得了 ticks
的锁，此时程序收到了时钟中断的信号，需要将
ticks++。此时便引发了死锁。</li>
</ul></li>
<li>一般的设计方法是，如果某一个锁会被中断处理程序获取，那么 CPU
在持有这个锁的时候不能开启中断</li>
<li><strong>xv6 的设计更加保守，当 CPU 申请一个锁的时候，我们就关当前
CPU 的中断</strong>
<ul>
<li>在释放锁的时候，打开中断</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">push_off();</span><br><span class="line">pop_off();</span><br></pre></td></tr></table></figure>
<h3 id="指令与内存模型">指令与内存模型</h3>
<ul>
<li>instructions and memory model
<ul>
<li>A memory consistency model (which we often just call a “memory
model”)</li>
</ul></li>
<li>编译器或者 CPU 在运行程序的时候可能试图去优化代码而 “乱序执行”</li>
<li>但是需要遵守一些规则，这个规则被称为内存模型
<ul>
<li>运行结果不能变</li>
</ul></li>
</ul>
<h3 id="sleep-lock">sleep lock</h3>
<ul>
<li>有的时候可能需要获取一个锁很久（tens of milliseconds）
<ul>
<li>例如往磁盘上写文件</li>
</ul></li>
<li>如果利用 spinlock 的话很浪费 CPU，需要等很久（空循环）</li>
<li>进程在持有 spinlock 的时候不能 yield
<ul>
<li>但是也不能设计成能够 yield，可能引发死锁</li>
</ul></li>
<li>专门设计一种 sleeplock，允许在等待的时候 yield
<ul>
<li>允许中断，sleeplock 不能够被用于中断处理程序</li>
<li>允许 yield，因此在 spinlock 保护的临界区内不能使用 sleeplock</li>
</ul></li>
<li>sleeplock 的数据结构如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Long-term locks for processes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> &#123;</span></span><br><span class="line">    uint locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lk</span>;</span> <span class="comment">// spinlock protecting this sleep lock</span></span><br><span class="line">    <span class="comment">// For debugging:</span></span><br><span class="line">    <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">    <span class="type">int</span> pid;           <span class="comment">// Process holding lock</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>acquiresleep() / releasesleep()</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span> &#123;</span><br><span class="line">    acquire(&amp;lk-&gt;lk);</span><br><span class="line">    <span class="keyword">while</span> (lk-&gt;locked) &#123;</span><br><span class="line">        sleep(lk, &amp;lk-&gt;lk);</span><br><span class="line">    &#125;</span><br><span class="line">    lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">    lk-&gt;pid = myproc()-&gt;pid;</span><br><span class="line">    release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">releasesleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span> &#123;</span><br><span class="line">    acquire(&amp;lk-&gt;lk);</span><br><span class="line">    lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">    lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">    wakeup(lk);</span><br><span class="line">    release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题-1">问题 1</h3>
<ul>
<li>临界资源：系统中某些资源只允许一个进程访问或使用，这些资源成为临界资源</li>
<li>临界区：指需要被互斥访问的区域，可能是对临界资源的操作</li>
<li>同步与互斥
<ul>
<li>互斥：指某一资源在某一个时刻只允许一个进程对其进行访问，但不限制顺序</li>
<li>同步：通过某些机制实现进程对资源的有序访问</li>
<li>互斥是一种特殊的同步</li>
</ul></li>
<li>竞争状态：两个进程同时对某个资源进行修改，导致最终的结果是不正确的
<ul>
<li>具体见 <a href="#race">race</a> 部分</li>
</ul></li>
<li>临界区的操作中断应该关闭，否则可能引起死锁
<ul>
<li>具体分析见<a href="#锁和中断处理程序">锁和中断处理程序</a>部分</li>
</ul></li>
<li>xv6 的锁的实现：上面的 <a href="#spinlock">spinlock</a>、<a href="sleeplock">sleeplock</a> 部分</li>
<li>RISCV 中的类似指令<code>amoswap</code>，是一个原子操作，分析见 <a href="#amoswap">amoswap</a> 部分</li>
</ul>
<h3 id="问题-2">问题 2</h3>
<h4 id="信号量">信号量</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">plock</span>;</span> <span class="comment">// 保证 P/V 操作是原子的</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">vlock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">queue</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只会被调用一次</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_init</span><span class="params">(<span class="keyword">struct</span> semaphore* se, <span class="type">unsigned</span> <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    se-&gt;count = val;</span><br><span class="line">    initlock(&amp;(se-&gt;plock), <span class="string">&quot;semaphore_plock&quot;</span>);</span><br><span class="line">    initlock(&amp;(se-&gt;vlock), <span class="string">&quot;semaphore_vlock&quot;</span>);</span><br><span class="line">    initlock(&amp;(se-&gt;<span class="built_in">queue</span>), <span class="string">&quot;semaphore_queue&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> samephore* se)</span> &#123;</span><br><span class="line">    acquire(se-&gt;plock);</span><br><span class="line">    --se-&gt;count;</span><br><span class="line">    <span class="keyword">if</span>(se-&gt;count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        acquire(se-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    release(se-&gt;plock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> samephore* se)</span> &#123;</span><br><span class="line">    acquire(se-&gt;vlock);</span><br><span class="line">    ++se-&gt;count;</span><br><span class="line">    <span class="keyword">if</span>(se-&gt;count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        release(se-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    release(se-&gt;vlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读写锁">读写锁</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_lock</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> rdcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">rlock</span>;</span> <span class="comment">// 保证操作是原子的</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">wlock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">rulock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">wulock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">queue</span>;</span> <span class="comment">// 读写队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_lock</span><span class="params">(<span class="keyword">struct</span> rw_lock* se)</span> &#123;</span><br><span class="line">    se-&gt;rdcnt = <span class="number">0</span>;</span><br><span class="line">    initlock(&amp;(se-&gt;rlock), <span class="string">&quot;rlock&quot;</span>);</span><br><span class="line">    initlock(&amp;(se-&gt;wlock), <span class="string">&quot;wlock&quot;</span>);</span><br><span class="line">    initlock(&amp;(se-&gt;ulock), <span class="string">&quot;ulock&quot;</span>);</span><br><span class="line">    initlock(&amp;(se-&gt;<span class="built_in">queue</span>), <span class="string">&quot;queue&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rd_lock</span><span class="params">(<span class="keyword">struct</span> rw_lock* se)</span> &#123;</span><br><span class="line">    acquire(se-&gt;rlock);</span><br><span class="line">    se-&gt;rdcnt ++;</span><br><span class="line">    <span class="keyword">if</span>(se-&gt;rdcnt == <span class="number">1</span>) &#123;</span><br><span class="line">        acquire(se-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    release(se-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rd_unlock</span><span class="params">(<span class="keyword">struct</span> rw_lock* se)</span> &#123;</span><br><span class="line">    acquire(se-&gt;ulock);</span><br><span class="line">    se-&gt;rdcnt--;</span><br><span class="line">    <span class="keyword">if</span>(se-&gt;dcnt == <span class="number">0</span>) &#123;</span><br><span class="line">        release(se-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    release(se-&gt;ulock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wr_lock</span><span class="params">(<span class="keyword">struct</span> rw_lock* se)</span> &#123;</span><br><span class="line">    acquire(se-&gt;wlock);</span><br><span class="line">    acquire(se-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    release(se-&gt;wlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wr_unlock</span><span class="params">(<span class="keyword">struct</span> rw_lock* se)</span> &#123;</span><br><span class="line">    acquire(se-&gt;wulock);</span><br><span class="line">    release(se-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    release(se-&gt;wulock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf</li>
<li>https://github.com/mit-pdos/xv6-riscv</li>
</ul>
]]></content>
      <categories>
        <category>OS.xv6-source-code</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-riscv-源代码阅读.虚存管理</title>
    <url>/2021/05/09/OS/xv6-source-code/04-VM/</url>
    <content><![CDATA[<h1 id="xv6-源代码阅读虚存管理">XV6 源代码阅读——虚存管理</h1>
<h2 id="说明">说明</h2>
<ul>
<li>阅读的代码是 <code>xv6-riscv</code> 版本的</li>
<li>涉及到的文件如下
<ul>
<li><code>kernel</code>
<ul>
<li><code>kalloc.c</code>、<code>vm.c</code></li>
</ul></li>
</ul></li>
</ul>
<h2 id="问题-1">问题 1</h2>
<blockquote>
<p>XV6 初始化之后到执行 main.c
时，内存布局是怎样的（其中已有哪些内容）？</p>
</blockquote>
<h3 id="xv6-的启动流程main.c-之前">xv6 的启动流程（main.c 之前）</h3>
<ul>
<li>xv6
的启动过程在之前的进程线程源代码阅读中已经说过了，这里只展示和内存分布相关的部分</li>
<li>kernel/kernel.ld
<ul>
<li>当 xv6 的系统启动的时候，首先会启动一个引导加载程序（存在 ROM
里面），之后装载内核程序进内存</li>
<li>引导加载程序把内核代码加载到物理地址为 0x8000000 的地方（0x0 -
0x80000000 之间有 I/O 设备）</li>
<li>设置 ENTRY 为_entry，开始执行 kernel/entry.S 的代码</li>
</ul></li>
<li>kernel/entry.S
<ul>
<li>注意由于只有一个内核栈，内核栈部分的地址空间可以是固定，因此 xv6
启动的时候并没有开启硬件支持的 paging
策略，也就是说，对于内核栈而言，它的物理地址和虚拟地址是一样的</li>
<li>在机器模式下，CPU 从 _entry 处开始执行操作系统的代码</li>
<li>首先需要给内核开辟一个栈，从而可以执行 C 代码</li>
<li>每一个 CPU 都应该有自己的栈（xv6 最多支持 8 个
CPU），开始每个内核栈的大小为 4096 byte，地址空间向下增长</li>
<li>最后设置调用 kernel/start.c 中的 start 函数</li>
</ul></li>
<li>kernel/start.c
<ul>
<li>主要是配置一些寄存器和机器状态等</li>
<li>例如打开时钟中断、设置中断等</li>
<li>跳转到 kernel/main.c</li>
</ul></li>
</ul>
<h3 id="回答问题">回答问题</h3>
<ul>
<li>xv6 的<span id="vmd">内存分布</span>如下</li>
</ul>
<p><img src="/2021/05/09/OS/xv6-source-code/04-VM/image-20210509145509177.png" style="zoom:67%;"></p>
<ul>
<li>根据上面的描述，在执行到 main.c 之前，在内存中 Kernel text 、Kernel
data、UART0、PLIC、CLINT、VIRTIO
是已经存在了的，通过引导程序加载进了内存</li>
</ul>
<h2 id="问题-2">问题 2</h2>
<blockquote>
<p>XV6
的动态内存管理是如何完成的？有一个kmem（链表），用于管理可分配的物理内存页</p>
<p>（vend=0x00400000，也就是可分配的内存页最大为4Mb）</p>
</blockquote>
<ul>
<li>xv6 的动态内存管理指的是怎么去管理物理内存</li>
<li>xv6 将 Kernel data 以上，PHYSTOP
以下的区域用于作为物理内存的分配，将其划分为页的形式，然后保存在数据结构
<code>kmem</code> 中，<code>kmem</code>
中保存着一个链表，这个链表保存着所有空闲的物理内存</li>
<li>xv6 的物理内存分配与回收都是按页进行的</li>
<li>当需要申请一块物理内存的时候，我们调用 <code>kalloc()</code> 从
<code>kmem</code>
中申请一页（链表头部申请一页），当需要时放一块内存的时候，我们调用
<code>kfree()</code> 将内存还给
<code>kmem</code>（插入到链表的开头）</li>
</ul>
<h2 id="问题-3">问题 3</h2>
<blockquote>
<p>XV6 的虚拟内存是如何初始化的？画出 XV6
的虚拟内存布局图，请说出每一部分对应的内容是什么</p>
<p>见 memlayout.h 和 vm.c 的 kmap 上的注释</p>
</blockquote>
<ul>
<li>虚拟内存的初始化是在 <code>main.c</code> 中实现的</li>
<li><a href="#vmd">内存分布图如上</a></li>
</ul>
<h3 id="main.c-的操作">main.c 的操作</h3>
<h4 id="kinit">kinit()</h4>
<ul>
<li>调用 <code>kinit()</code> 对物理页进行一个组织
<ul>
<li>将 Kernel data 以上，PHYSTOP 以下的区域用于作为物理内存的分配</li>
<li>因为 xv6
分配物理页是按页分配的，需要将这个区域两端取整，然后按页划分，保存在结构体
<code>kmem</code> 的 <code>freelist</code> 中</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>
<h4 id="kvminit">kvminit()</h4>
<ul>
<li>调用 <code>kvminit()</code> 对内核的页表进行初始化，调用
<code>kvmmake()</code> 实现</li>
<li>直接映射（物理地址和虚拟地址相同）生成如下的页表（为了使用统一的页表映射策略）
<ul>
<li>UART0：Universal Asynchronous Receiver/Transmitter</li>
<li>VIRTIO0：virtio disk</li>
<li>PLIC：Platform-Level Interrupt Controller</li>
<li>Kernel text（内核代码段）</li>
<li>Kernel data（内核数据段）</li>
</ul></li>
<li>对 <code>TRAMPOLINE</code> 进行虚拟映射</li>
<li>映射内核栈，为每一个进程分配一个页的内核栈，在两个内核栈之间分配一个
guard page，用于检测栈溢出</li>
<li>接下来就是初始一些数据结构 <code>proc</code> 等</li>
<li>以上的建立起虚拟地址和物理地址的映射是通过函数
<code>mappages()</code> 实现的，实现的大致逻辑如下
<ul>
<li>首先通过 <code>walk()</code>
在已经存在的页表项中检索，如果找到一个有效的页表项，则报错
<code>remap</code></li>
<li>如果找不到（正常的情况下应该是找不到），此时建立起映射即可，也就是在页表项（第
3 级页表）设置 PPN 的值和物理页的基地址相同，同时设置权限位</li>
</ul></li>
</ul>
<h2 id="问题-4">问题 4</h2>
<blockquote>
<p>关于XV6
的内存页式管理。发生中断时，用哪个页表？一个内页是多大？页目录有多少项？页表有多少项？最大支持多大的内存？画出从虚拟地址到物理地址的转换图。在XV6
中，是如何将虚拟地址与物理地址映射的（调用了哪些函数实现了哪些功能）？</p>
</blockquote>
<h3 id="级页表">3 级页表</h3>
<ul>
<li>xv6 的页式管理，xv6 通过 3 级页表实现，具体实现如下图</li>
</ul>
<p><img src="/2021/05/09/OS/xv6-source-code/04-VM/image-20210509193047497.png" style="zoom:80%;"></p>
<ul>
<li>虚拟地址中首先保存着 4 个偏移量 L2、L1、L0、Offset</li>
<li>通过 satp 寄存器读取到第一级页表的基地址，通过 L2 找到 PPN1</li>
<li>PPN1 中记录的第二级页表的基地址，通过 L1 找到 PPN2</li>
<li>PPN2 记录着第三级页表的基地址，通过 L2 找到 PPN</li>
<li>PPN 和 页内偏移量 Offset 组合形成最终的物理地址</li>
<li>具体是通过函数 <code>walkaddr()</code>
实现的，其中三级页表的翻译是通过 <code>walk()</code> 实现的</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 判断是否合法并返回物理页的基地址 */</span></span><br><span class="line">uint64 <span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa;</span><br><span class="line">    <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 找到最后一级页表(第3级页表)对应的 PTE */</span></span><br><span class="line"><span class="type">pte_t</span> * <span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">        panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">        <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">            pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">            *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中断">中断</h3>
<ul>
<li>发生中断时，将 CPU 上进程的第一级页表的及地址存入 stap
寄存器，同时清空 TLB</li>
<li>也就是说，将当前页表替换为触发中断的进程的页表，紧接着之后的查找都是在新的页表上执行，具体的翻译步骤就是通过上面的
3 级页表翻译</li>
<li>其中每一级页表都有 512 个页表项，支持内存大小可达 <span class="math inline">\(2^{39}\)</span></li>
<li>清空 TLB 的操作是由如下命令执行的</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">sfence_vma</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// the zero, zero means flush all TLB entries.</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sfence.vma zero, zero&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2>
<h3 id="虚拟地址空间设计">虚拟地址空间设计</h3>
<ul>
<li>xv6-riscv 的设计和其他的设计不太一样，xv6
的设计中内核态拥有自己的一个页表，这就是说对于 xv6
来说，用户态和内核态的虚拟地址空间都可以达到 0 -
MAXVA，这样的设计的好处似乎还挺多
<ul>
<li>首先我们可以看到，可以分配的空间变大了</li>
<li>在内核态分配空间的时候不需要考虑和用户态是否有交集了
<ul>
<li>当然直接将内核态和用户态分离开也能马上实现没有交集的效果</li>
</ul></li>
<li>当然也存在一些问题，比在在陷入内核、退出内核的时候都需要对 TLB
进行一个清空的操作，这样增大了 TLB miss 的概率，导致效率有所下降</li>
</ul></li>
<li>用户空间的虚拟地址范围如下</li>
</ul>
<p><img src="/2021/05/09/OS/xv6-source-code/04-VM/image-20210509222041197.png" style="zoom:60%;"></p>
<h3 id="内核态的-cpu-栈与内核栈">内核态的 CPU 栈与内核栈</h3>
<ul>
<li>一开始系统启动的时候为每一个 CPU 都分配了一个栈，这个栈是为了每个
CPU 的前期初始化操作以及调度程序准备的</li>
<li>我们可以认为在内核态下，其实是存在两个线程的，一个线程是调度线程，一个线程是由用户态的
trap 进入的</li>
<li>因此这两个线程也是需要有自己的栈的</li>
<li>所以这样的设计是没有问题的，而且在一定程度上讲确实得这么设计</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf</li>
<li>https://github.com/mit-pdos/xv6-riscv</li>
</ul>
]]></content>
      <categories>
        <category>OS.xv6-source-code</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-riscv-源代码阅读.文件系统</title>
    <url>/2021/06/07/OS/xv6-source-code/05-FileSystem/</url>
    <content><![CDATA[<h1 id="xv6-源代码阅读文件系统">XV6 源代码阅读——文件系统</h1>
<h2 id="说明">说明</h2>
<ul>
<li>阅读的代码是 <code>xv6-riscv</code> 版本的</li>
<li>涉及到的文件如下
<ul>
<li><code>kernel</code>
<ul>
<li><code>buf.h</code>、<code>bio.c</code>、<code>param.h</code>、<code>log.c</code>、<code>fs.h</code>、<code>file.h</code>、<code>file.c</code>、<code>fs.c</code>、<code>stat.h</code>、<code>fcntl.h</code>、<code>sysfile.c</code>、<code>ide.c</code></li>
</ul></li>
</ul></li>
</ul>
<h2 id="阅读笔记">阅读笔记</h2>
<ul>
<li>这一部分为阅读 <code>book-riscv-rec1</code> 的笔记</li>
</ul>
<h3 id="文件系统的目标">文件系统的目标</h3>
<ul>
<li>文件系统需要解决的几个问题
<ul>
<li>需要有一个保存在磁盘上的数据结构，保存文件的结构信息、文件本身、空闲的磁盘区域</li>
<li>需要支持故障重启（crash recovery）</li>
<li>多进程的并发访问</li>
<li>磁盘访问是慢速的，需要维护一个 cache，保存经常访问的块</li>
</ul></li>
</ul>
<h3 id="七层结构">七层结构</h3>
<ul>
<li>xv6 的文件系统是七层结构</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Layers of the xv6 file system</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">File Discriptor</td>
</tr>
<tr class="even">
<td style="text-align: center;">Pathname</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Directory</td>
</tr>
<tr class="even">
<td style="text-align: center;">Inode</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Logging</td>
</tr>
<tr class="even">
<td style="text-align: center;">Buffer cache</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Disk</td>
</tr>
</tbody>
</table>
<ul>
<li>disk 层从一个虚拟硬盘（vitro hard drive）上读取 block</li>
<li>buffer cache 层缓存 block
<ul>
<li>保证同一个 block 只能被一个内核进程同时访问</li>
</ul></li>
<li>logging 层记录一些日志信息，用于出错恢复</li>
<li>inode 层是一个独立的文件，唯一的 i-number 和一些存储数据的块</li>
<li>directory 层把文件夹封装称为一些特殊的 inode
<ul>
<li>内容为一些列目录项，包括文件名和 i-number</li>
</ul></li>
<li>pathname 层提供一个层次化的树结构，处理了递归包含的情况</li>
<li>file descriptor 层把 pipes, devices, files
等都抽象为文件，使用统一的文件系统的接口</li>
</ul>
<h3 id="物理存放结构">物理存放结构</h3>
<p><img src="/2021/06/07/OS/xv6-source-code/05-FileSystem/image-20210604192843755.png" style="zoom: 80%;"></p>
<ul>
<li>第 0 块保留，用于存储引导扇区</li>
<li>第 1
块为超级块（superblock），保存着文件系统的元数据、一些用于构建初始操作系统的代码（称为
<code>mkfs</code>）
<ul>
<li>元数据
<ul>
<li>文件系统的大小（多少块）</li>
<li>数据有多少块</li>
<li>inode 有多少个</li>
<li>log 占多少块</li>
</ul></li>
</ul></li>
<li>从第 2 块开始，保存 log 信息
<ul>
<li>大小为 <code>LOGSIZE+1=(MAXOPBLOCKS*3)+1=31</code></li>
</ul></li>
<li>接下来是 inode（每个块有多个 inode）</li>
<li>接着是 bitmap blocks，用来保存那些块是被使用或空闲的</li>
<li>最后是数据块（要么是文件夹或文件，要么在 bitmap 中标记为空闲）</li>
</ul>
<h3 id="buffer-cache-层">Buffer cache 层</h3>
<ul>
<li>两个目标
<ul>
<li>同步磁盘块，保证每个磁盘块在内存中最多只有一个拷贝，保证每一个磁盘块的拷贝只能被一个内核线程使用</li>
<li>缓存 popular blocks，减少访问磁盘导致的开销</li>
</ul></li>
<li>对上提供的接口如下
<ul>
<li>bread()：获取一个磁盘块的拷贝到内存中</li>
<li>bwrite()：将缓存写入磁盘的对应块中</li>
<li>brelse()：释放缓存块（<strong>用完必须得释放</strong>）</li>
</ul></li>
<li>通过给每一个 buffer 分配一个 sleeplock
的方式实现一个磁盘块的拷贝只能被一个内核线程使用
<ul>
<li>bread() 返回一个带锁的 buffer</li>
<li>brelse() 释放锁</li>
</ul></li>
<li>当需要的磁盘块没有读入内存的时候，通过 LRU 的方式回收一个
buffer，并从磁盘中将对应块读入内存
<ul>
<li>通过 <code>virtio_disk_rw(b, 0)</code> 实现</li>
</ul></li>
</ul>
<h3 id="buffer-cache-层代码实现">Buffer cache 层（代码实现）</h3>
<ul>
<li><code>kernel/bio.c</code></li>
<li>一共有 30 个 buffer
<ul>
<li><code>NBUF=(MAXOPBLOCKS*3)=30</code></li>
</ul></li>
<li>通过 <code>binit()</code> 将，所有的 buffer 保存为一个静态的数组
<ul>
<li>组织成一个双向循环链表（为了实现 LRU 的替换算法）</li>
<li>为了方便组织，这个双向链表带一个空的虚拟头结点</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/bio.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>
<ul>
<li>每一个 buffer 的数据结构如下
<ul>
<li>valid 字段表示这个 buffer 是否对应磁盘上的某一个块（1
表示有对应）</li>
<li>disk 字段表示是否将 buffer 中的信息写回了磁盘上（1
表示修改了未写回）</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/buf.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">    <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">    uint dev;</span><br><span class="line">    uint blockno;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">    uint refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">    uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>bread() 函数调用 bget() 获取一个 buffer
<ul>
<li>如果返回一个 <code>valid=1</code> 的 buffer，说明待读取的 buffer
已经在内存中了</li>
<li>如果返回一个 <code>valid=0</code> 的 buffer，说明待读取的 buffer
尚未进入内存，通过调用 <code>virtio_disk_rw(b, 0)</code>
从磁盘中将其读入内存（buffer 中）</li>
</ul></li>
<li>bget() 的逻辑如下
<ul>
<li>首先扫描整个链表，看需要读取的内容是否被缓存，若缓存了，直接返回</li>
<li>若未缓存，从链表开始扫描，找到一个空闲的 buffer（refcnt=0） 返回
<ul>
<li>注意此时需要把 valid 项置为 0，表明需要从磁盘中读取具体的内容</li>
</ul></li>
<li>如果还没找到，则报错 <code>panic()</code></li>
<li>注意返回的 buffer 是带锁的</li>
</ul></li>
<li>bget() 的整个过程都是持有锁 <code>bcache.lock</code>
的，因此保证了每一个磁盘块在 buffer 中最多只会有一个拷贝</li>
<li>如果修改了 buffer 中的内容，需要调用 bwrite()
将内容写回磁盘，内部调用 <code>virtio_disk_rw(b, 1)</code> 实现</li>
<li>最终需要调用 brelse() 进行释放缓存块，将 refcnt 减 1，同时得释放
buffer 上的锁
<ul>
<li>如果 refcnt 为 0，将这个 buffer 插入到链表头的后面
<ul>
<li>这就保证了 LRU
的实现，在逆向查找，找到的第一个空闲块一定是最老的</li>
</ul></li>
</ul></li>
</ul>
<h3 id="logging-层">logging 层</h3>
<ul>
<li>这一部分的设计主要是为了处理故障恢复的问题</li>
<li>例如在一个操作执行到一半的时候发生了故障，此时可能出现磁盘内容不一致的情况</li>
<li>当需要向磁盘写入内容的时候，xv6
先向磁盘上写一个日志记录，当把所有的写操作都计入日志之后，写一个 commit
表示日志记录完整，此时再进行系统调用将内容写入磁盘，当内容都写完之后，在磁盘上消去这个日志信息</li>
<li>系统崩溃重启之后的流程如下
<ul>
<li>检查日志记录，如果有完整的操作，那么就执行，如果操作不完整，则直接忽略</li>
</ul></li>
<li>日志记录保证了这个操作是原子的（全或无）</li>
</ul>
<h3 id="log-的设计">log 的设计</h3>
<ul>
<li>log 在磁盘中的位置是确定的，在 superblock 中能够找到</li>
<li>由一个头块（header block）和一些更新的块（logged blocks）组成</li>
<li>header block
<ul>
<li>一个扇区编号的数组
<ul>
<li>对应扇区磁盘内容写入<strong>下标+1</strong>所在的 log
块中，具体见下面的<a href="#code01">代码</a></li>
</ul></li>
<li>日志块的个数</li>
</ul></li>
<li>header block 占据一个块的大小，具体在 initlog() 有检查</li>
<li>计数要么为
0（没有需要处理的记录），要么非零（表示存在一个事务，即一组待处理的写操作）</li>
<li>一个事务可能包含一组系统调用，为了避免一个有关文件系统的系统调用被拆分为多个事务，因此
commit 只在没有有关文件系统的系统调用出现时进行</li>
<li>在日志处理中，log
块的空间是固定的，因此如果需要写的内容太多的话会出问题
<ul>
<li>两个系统调用 write、unlink 写的内容可能会过大
<ul>
<li>xv6
的实现可以把一个很多块的写操作拆分为若干个较少块的写操作，解决上述问题</li>
</ul></li>
<li>如果一个有关文件系统的系统调用写的内容超过了 log
区域中剩余块的大小，此时这个系统调用不会被执行</li>
</ul></li>
</ul>
<h3 id="logging-层代码实现">logging 层（代码实现）</h3>
<ul>
<li><code>kernel/log.c</code></li>
<li>一个典型的在系统调用中使用 log 机制的方式如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">begin_op();</span><br><span class="line">...</span><br><span class="line">bp = bread(...);</span><br><span class="line">bp-&gt;data[...] = ...;</span><br><span class="line">log_write(bp);</span><br><span class="line">...</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure>
<h4 id="begin_op">begin_op()</h4>
<ul>
<li>等待，直到 log 系统没有 committing 而且有充足的 log blocks
<ul>
<li>xv6 认为每个系统调用只会使用 MAXOPBLOCKS（10） 个 block</li>
</ul></li>
<li>满足条件后，系统调用数 +1 并返回
<ul>
<li>log.outstanding 记录使用 log 系统的系统调用数</li>
</ul></li>
</ul>
<h4 id="log_write">log_write()</h4>
<ul>
<li>把 buffer 的磁盘块号保存到 log 中，同时做一个优化（absorbtion）
<ul>
<li>找到一个同一磁盘块的拷贝时，用新的修改覆盖它即可（直接说使用原来留下的
slot）
<ul>
<li>因为反正前一个修改会被覆盖</li>
</ul></li>
</ul></li>
<li>同时把 buffer 的 refcnt +1（避免被替换出去）</li>
</ul>
<h4 id="end_op">end_op()</h4>
<ul>
<li>首先将计数 log.outstanding -1（系统调用数 -1）</li>
<li>如果此时计数变成 0，则调用 commit() 进行 commit</li>
</ul>
<h5 id="commit">commit()</h5>
<ul>
<li>commit() 分为 4 个步骤</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/log.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">commit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write_log();     <span class="comment">// Write modified blocks from cache to log</span></span><br><span class="line">        write_head();    <span class="comment">// Write header to disk -- the real commit</span></span><br><span class="line">        install_trans(<span class="number">0</span>); <span class="comment">// Now install writes to home locations</span></span><br><span class="line">        <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">        write_head();    <span class="comment">// Erase the transaction from the log</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>write_log()：把具体的内容写入 log 对应的磁盘块里
<ul>
<li>通过调用 bread() 读取磁盘块、memmove() 内存复制、bwrite()
写入磁盘完成
<ul>
<li>需要写入的磁盘区域 <span class="math inline">\(\to\)</span> 对应的
log 块</li>
</ul></li>
<li><span id="code01">代码如下</span>，注意这里的 log
数组中记录的磁盘块写入对应<strong>下标+1</strong>的 log
块中，因为第一块留给了 log 的 head</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/log.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_log</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> tail;</span><br><span class="line">    <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">to</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// log block</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">from</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// cache block</span></span><br><span class="line">        memmove(to-&gt;data, from-&gt;data, BSIZE);</span><br><span class="line">        bwrite(to);  <span class="comment">// write the log</span></span><br><span class="line">        brelse(from);</span><br><span class="line">        brelse(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>write_head()：把 log 块的头信息写入磁盘
<ul>
<li>log 块区域的第一块是 log 的 header 块</li>
<li>这一个区域完成之后就实现了 commit()
的功能，就来来执行真正的写操作</li>
</ul></li>
<li>install_trans()：执行原来要求的写操作
<ul>
<li>通过调用 bread() 读取磁盘块、memmove() 内存复制、bwrite()
写入磁盘完成
<ul>
<li>对应的 log 块 <span class="math inline">\(\to\)</span>
需要写入的磁盘区域</li>
</ul></li>
</ul></li>
<li>write_head()：将磁盘块中的头信息清空（将计数归零）</li>
</ul>
<h4 id="recover_from_log">recover_from_log()</h4>
<ul>
<li>这一部分是用于故障恢复的</li>
<li>很简单的实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/log.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">recover_from_log</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    read_head();</span><br><span class="line">    install_trans(<span class="number">1</span>); <span class="comment">// if committed, copy from log to disk</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">    write_head(); <span class="comment">// clear the log</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这部分代码会在系统启动的时候调用
<ul>
<li>fsinit() <span class="math inline">\(\to\)</span> initlog() <span class="math inline">\(\to\)</span> recover_from_log()</li>
</ul></li>
<li>注意这里的 install_trans() 的参数 1
<ul>
<li>因为如果不是恢复，log_write()
的操作为了不让墓表块释放，因此会将引用计数+1，此时在 install_trans()
中需要 -1，但是在恢复的时候没有进行这个操作，所以不需要 -1</li>
</ul></li>
</ul>
<h4 id="一个例子">一个例子</h4>
<ul>
<li>file.c 的 filewrite() 表示一个例子
<ul>
<li>注意这里为了避免文件一次写的太大，把文件拆分为多个写操作</li>
</ul></li>
</ul>
<h3 id="块分配器bitmap">块分配器（bitmap）</h3>
<ul>
<li>通过 bitmap 记录一个磁盘块是否空闲（0 表示空闲）
<ul>
<li>在系统启动的时候，<code>mkfs</code> 代码会将 boot
sector、superblock、log blocks、inode blocks、bitmap 对应在 bitmap
中的值设置为 1</li>
</ul></li>
<li>代码：<code>kernel/fs.c</code></li>
<li>balloc() 函数从磁盘中找一个空闲的磁盘块并返回（bitmap 中标记为
0）</li>
<li>bfree() 函数释放一个指定的磁盘块</li>
<li>读取 bitmap 的块</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bp = bread(dev, BBLOCK(b, sb));</span><br></pre></td></tr></table></figure>
<ul>
<li>bitmap 只能被一个进程同时访问
<ul>
<li>因为在最后需要调用
brelse()/bread()，这已经隐式加上了锁，所以不需要对 bitmap 显式加锁</li>
</ul></li>
</ul>
<h3 id="inode-层">Inode 层</h3>
<ul>
<li>两种含义
<ul>
<li>磁盘上的数据结构（on-disk），包含文件的大小和一个数据存放位置的列表</li>
<li>内存中的数据结构（in-memory），包括磁盘上数据结构的一个拷贝以及一些内核需要用到的内容</li>
</ul></li>
</ul>
<h4 id="on-disk">on-disk</h4>
<ul>
<li>磁盘上的 inode 被放置在 inode blocks 中，大小都是相同的，给定一个
n（i-number）就能找到第 n 个 inode 的位置</li>
<li>数据结构如下
<ul>
<li>type：file、directory、special files（devices）、0（表示空闲）</li>
<li>nlink：引用数（用于判断数据块是否该被释放）</li>
<li>size：文件所占据的字节数</li>
<li>addrs：文件所在数据块的地址</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.h</span></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">    <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">    <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">    <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">    uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">    uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="in-memory">in-memory</h4>
<ul>
<li>数据结构如下，除了上面的 dinode 之外还有一些其他的字段
<ul>
<li>ref 记录引用数（用于判断这个数据结构是否该被释放）
<ul>
<li>iget()、iput() 增加和减少引用数</li>
<li>引用来源：文件描述符、当前工作目录、暂时的内核代码（exec 等）</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/file.h</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    uint dev;           <span class="comment">// Device number</span></span><br><span class="line">    uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">    <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">    <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">    <span class="type">short</span> major;</span><br><span class="line">    <span class="type">short</span> minor;</span><br><span class="line">    <span class="type">short</span> nlink;</span><br><span class="line">    uint size;</span><br><span class="line">    uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>有 4 种锁的机制
<ul>
<li>icache.lock 保证一个 inode 只会在缓存中出现一次，保证引用计数 ref
的正确
<ul>
<li>好像是 itable.lock</li>
</ul></li>
<li>每一个 inode 都有一个 sleeplock，用于保证其内部字段的独占访问</li>
<li>ref 不为 0 的时候这个 entry 不会被回收</li>
<li>nlink 字段表示这个文件的引用数（他不为 0，xv6 就不会释放
entry）</li>
</ul></li>
<li>iget() 返回一个 inode
<ul>
<li>如果是新使用的，valid = 0，之后使用的时候会从磁盘读入（ilock()
实现读入）</li>
</ul></li>
<li>ilock() 是加锁的，iget() 不加锁</li>
<li>inode cache 是 write-through（直写的），调用 iupdate()
直接反应到磁盘上</li>
</ul>
<h3 id="inode-层代码实现">Inode 层（代码实现）</h3>
<ul>
<li>分配一个新的 inode 结点（新建文件等）的流程如下</li>
<li>调用 ialloc()
<ul>
<li>从标号为 1的 inode 的开始查找，找到一个空闲的 inode 之后，调用
iget() 返回
<ul>
<li>标号为 0 是预留的？</li>
<li>根节点也是从 1 开始的（<code>#define ROOTINO 1</code>）</li>
</ul></li>
</ul></li>
<li>iget()
<ul>
<li>先看看有没有缓存，若有缓存，则引用数 ref +1，直接返回</li>
<li>如果没有找到，则将第一个空闲的 inode 返回</li>
</ul></li>
<li>ilock()
<ul>
<li>想要对 inode 进行读写操作的时候，需要先对 inode 获取锁（调用
ilock）</li>
<li>同时 ilock 会检查这个内容有没有从磁盘冲读进内存，如果没有则读入</li>
</ul></li>
<li>iunlock()
<ul>
<li>释放锁</li>
</ul></li>
<li>iput()
<ul>
<li>引用数 ref -1</li>
<li>如果减完之后计数为 0，同时 valid=1，nlink=0 的话，释放数据块</li>
</ul></li>
<li>可能会出现这样一种情况，nlink=0，ref 不为 0，此时 inode 没有被释放
<ul>
<li>当 ref 被减为 0 的瞬间，系统崩溃了</li>
<li>重启的时候我们知道 nlink=0
的文件是没有用的，但是我们在磁盘上这块空间并未被释放</li>
<li>xv6 没有针对这个问题进行补救，因此可能出现磁盘空间耗尽的情况</li>
</ul></li>
</ul>
<h3 id="inode-的内容">Inode 的内容</h3>
<ul>
<li>结构如下
<ul>
<li>前 12 块是直接索引，后面 256 块是间接索引</li>
<li>文件最大大小为 268kB</li>
</ul></li>
</ul>
<p><img src="/2021/06/07/OS/xv6-source-code/05-FileSystem/image-20210606150134024.png" style="zoom:80%;"></p>
<ul>
<li>bmap() 返回第 n 个数据块的地址
<ul>
<li>按照上面的索引方式找出即可</li>
<li>越界 panic，如果没有则分配一个</li>
</ul></li>
<li>itruc() 释放数据块
<ul>
<li>遍历所有索引，如果不为 0，就释放，最后把间接索引块也释放了</li>
</ul></li>
<li>stati() 将 inode 的元数据拷贝返回一个数据结构 <code>stat</code></li>
</ul>
<h3 id="directory-层代码实现">Directory 层（代码实现）</h3>
<ul>
<li>和文件相似，只不过
type=T_DIR，内容为一组目录项，每一个目录项的结构如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    ushort inum;</span><br><span class="line">    <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>name 最长为 <code>DIRSIZ=14</code> 个字符</li>
<li>dirlookup()
<ul>
<li>在一个目录中查找指定 name 的文件，返回 inode 指针</li>
</ul></li>
<li>dirlink()
<ul>
<li>按照给定的 name，新建一个新的文件夹
<ul>
<li>遍历 entry，找到一个空闲的返回</li>
<li>如果已经存在，则报错</li>
</ul></li>
</ul></li>
</ul>
<h3 id="pathname-层代码实现">Pathname 层（代码实现）</h3>
<ul>
<li>通过一系列的 dirlookup() 实现</li>
<li>namei() 返回待查找文件的 inode</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.c</span></span><br><span class="line"><span class="keyword">struct</span> inode* <span class="title function_">namei</span><span class="params">(<span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>nameiparent() 返回待查找文件的父节点的 inode，同时返回文件名到 name
中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.c</span></span><br><span class="line"><span class="keyword">struct</span> inode* <span class="title function_">nameiparent</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面两个函数最终调用 namex() 实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode* <span class="title function_">namex</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> nameiparent, <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>namex() 逻辑如下
<ul>
<li>首先判断是相对路径还是绝对路径，返回查找的起始 inode
<ul>
<li><code>/</code> 从根目录开始的绝对路径</li>
<li>其他为相对路径</li>
</ul></li>
<li>接着就是一个递归查询，直到找到最终的结果，返回 inode</li>
</ul></li>
</ul>
<h3 id="file-descriptor-层">File descriptor 层</h3>
<ul>
<li>Unix 把很多东西都抽象为文件，</li>
<li>xv6 给每一个进程维护了一个文件描述符表</li>
<li>所有的打开文件保存在一个全局的文件表（file table
<code>ftable</code>）里</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/file.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file</span>[<span class="title">NFILE</span>];</span> <span class="comment">// NFILE = 100</span></span><br><span class="line">&#125; ftable;</span><br></pre></td></tr></table></figure>
<ul>
<li>filealloc()
<ul>
<li>从 ftable 中找一个引用为 0 （空闲）的文件返回</li>
</ul></li>
<li>filedup()
<ul>
<li>引用计数 +1，返回</li>
</ul></li>
<li>fileclose()
<ul>
<li>引用计数 -1，如果为 0，同设置 type 为 FD_NONE</li>
</ul></li>
<li>filestat()
<ul>
<li>调用 stati() 获取文件元数据</li>
</ul></li>
<li>fileread()
<ul>
<li>调用 readi() 读取文件数据</li>
</ul></li>
<li>filewrite()
<ul>
<li>封装了 writei()</li>
</ul></li>
</ul>
<h3 id="系统调用代码实现">系统调用（代码实现）</h3>
<h4 id="sys_link">sys_link()</h4>
<ul>
<li>过程见注释</li>
<li>效果是将 new 指向 old</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line"><span class="comment">// Create the path new as a link to the same inode as old.</span></span><br><span class="line">uint64 <span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[DIRSIZ], new[MAXPATH], old[MAXPATH];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dp</span>, *<span class="title">ip</span>;</span></span><br><span class="line">    <span class="comment">// 读取两个系统调用的参数</span></span><br><span class="line">    <span class="keyword">if</span>(argstr(<span class="number">0</span>, old, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, new, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// begin_op();</span></span><br><span class="line">    begin_op();</span><br><span class="line">    <span class="comment">// 判断 old 文件存在</span></span><br><span class="line">    <span class="keyword">if</span>((ip = namei(old)) == <span class="number">0</span>)&#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="comment">// 不能是文件夹</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_DIR)&#123;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 引用+1</span></span><br><span class="line">    ip-&gt;nlink++;</span><br><span class="line">    iupdate(ip);</span><br><span class="line">    iunlock(ip);</span><br><span class="line">    <span class="comment">// new 的父节点得存在</span></span><br><span class="line">    <span class="keyword">if</span>((dp = nameiparent(new, name)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    ilock(dp);</span><br><span class="line">    <span class="comment">// 得在同一设备上</span></span><br><span class="line">    <span class="comment">// link 得成功</span></span><br><span class="line">    <span class="keyword">if</span>(dp-&gt;dev != ip-&gt;dev || dirlink(dp, name, ip-&gt;inum) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        iunlockput(dp);</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="comment">// end_op();</span></span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    ilock(ip);</span><br><span class="line">    ip-&gt;nlink--;</span><br><span class="line">    iupdate(ip);</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题-1">问题 1</h2>
<blockquote>
<p>了解UNIX 文件系统的主要组成部分：超级块（superblock），i
节点（inode），数据块（data block），目录块（directory
block），间接块（indirection block）。分别解释它们的作用。。</p>
</blockquote>
<ul>
<li>超级块：指的是 Unix
文件系统存储的源信息，包括具体的物理内存分布情况，每一块区域占据的大小等</li>
<li>i 节点：保存文件系统的树形结构</li>
<li>数据块：保存文件的具体数据</li>
<li>Unix 文件系统的文件夹保存目录项，前 12
个目录项为直接索引，保存的是文件的起始块的地址，接着是一级索引块、二级索引块、三级索引块。
<ul>
<li>目录块指的是文件夹保存的块，保存在 i 节点区</li>
<li>间接块指的是索引块，保存在文件和目录区</li>
</ul></li>
</ul>
<h2 id="问题-2">问题 2</h2>
<blockquote>
<p>阅读文件 ide.c。这是一个简单的 ide
硬盘驱动程序，对其内容作大致了解。</p>
</blockquote>
<ul>
<li>xv6-riscv 中没有这个文件</li>
<li><code>mkfs.c</code> 中是文件系统启动时运行的，保存在引导块中的代码
<ul>
<li>主要是设置超级块中的元数据</li>
</ul></li>
<li>xv6-riscv 中由 7
层结构组成，每一层实现一些具体的功能，然后为上层结构提供一些接口
<ul>
<li>具体的内容在上面不同层的设计中已经提到了</li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Layers of the xv6 file system</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">File Discriptor</td>
</tr>
<tr class="even">
<td style="text-align: center;">Pathname</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Directory</td>
</tr>
<tr class="even">
<td style="text-align: center;">Inode</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Logging</td>
</tr>
<tr class="even">
<td style="text-align: center;">Buffer cache</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Disk</td>
</tr>
</tbody>
</table>
<h2 id="问题-3">问题 3</h2>
<blockquote>
<p>阅读文件buf.h、bio.c。了解XV6 文件系统中buffer cache
层的内容和实现。描述 buffer 双链表数据结构及其初始化过程，了解 buffer
的状态，了解对 buffer 的各种操作。</p>
</blockquote>
<ul>
<li>xv6-riscv 的 buffer 一共 30
个，组织成一个双向链表的结构（虚拟头节点，虚拟头节点的 prev
指针指向最后一个节点）</li>
<li>初始化部分就是把 buffer 数组组织成一个双向链表，buffer 字段初始化为
0</li>
<li>更加细节的答案部分见上面的阅读笔记部分，以下是上面部分的超链接（点击可以跳转到上面）
<ul>
<li><a href="#Buffer%20cache%20层">逻辑部分</a></li>
<li><a href="#Buffer%20cache%20层（代码实现）">代码实现部分</a></li>
</ul></li>
</ul>
<h2 id="问题-4">问题 4</h2>
<blockquote>
<p>阅读文件 log.c，了解XV6 文件系统中的 logging 和 transaction
机制。</p>
</blockquote>
<ul>
<li>简单的来说，xv6-riscv 在磁盘中预留了一大块区域用于 log
机制，这是用于故障恢复的</li>
<li>主要过程如下
<ul>
<li>对于磁盘块的写操作，我们不直接写磁盘，像将其写入 log
块中，写完之后将 log 的 header 信息写入磁盘</li>
<li>这个时候所有数据已经写入 log 磁盘了，此时可以进行真正的写操作</li>
<li>我们将这些块从 log
区域读取出来，接着将其写入原来要写入的磁盘块中</li>
</ul></li>
<li>以上的操作保证了对于磁盘块的写是全或无的，不会出现不一致性</li>
<li>更加细节的答案部分见上面的阅读笔记部分，以下是上面部分的超链接（点击可以跳转到上面）
<ul>
<li><a href="#logging%20层">逻辑部分</a></li>
<li><a href="#logging%20层（代码实现）">代码实现部分</a></li>
</ul></li>
</ul>
<h2 id="问题-5">问题 5</h2>
<blockquote>
<p>阅读文件 fs.h、fs.c，了解 XV6 文件系统的磁盘布局</p>
</blockquote>
<ul>
<li>磁盘布局如下</li>
</ul>
<p><img src="/2021/06/07/OS/xv6-source-code/05-FileSystem/image-20210604192843755.png" style="zoom: 80%;"></p>
<ul>
<li>boot loader 占据一块</li>
<li>superblock 占据一块</li>
<li>log 占据 31 块（1 个头和 30 个log 块）</li>
<li>更加细节的答案部分见上面的阅读笔记部分，以下是上面部分的超链接（点击可以跳转到上面）
<ul>
<li><a href="#物理存放结构">物理存放结构</a></li>
</ul></li>
<li>大小（<code>make qemu</code> 输出）</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">nmeta 70 (</span><br><span class="line">    boot,</span><br><span class="line">    super,</span><br><span class="line">    log blocks 30</span><br><span class="line">    inode blocks 13,</span><br><span class="line">    bitmap blocks 25</span><br><span class="line">)</span><br><span class="line">blocks 199930</span><br><span class="line">total 200000</span><br></pre></td></tr></table></figure>
<h2 id="问题-6">问题 6</h2>
<blockquote>
<p>阅读文件 file.h、file.c，了解 XV6 的 “文件” 有哪些，以及文件、i
节点、设备相关的数据结构。了解 XV6 有哪些文件的基本操作？XV6
最多支持多少个文件？每个进程最多能打开多少个文件？</p>
</blockquote>
<ul>
<li>xv6-riscv 中的文件类型如下
<ul>
<li>pipe、普通文件（文件、文件夹）、device</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/file.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br></pre></td></tr></table></figure>
<ul>
<li>文件的数据结构如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/file.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">    <span class="type">int</span> ref;           <span class="comment">// reference count</span></span><br><span class="line">    <span class="type">char</span> readable;</span><br><span class="line">    <span class="type">char</span> writable;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">    uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line">    <span class="type">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>inode 的数据结构有两个
<ul>
<li>一个是保存在磁盘上的 inode，保存的是元数据</li>
<li>另一个是保存在内存中的数据结构，包含上面的部分，同时添加了一些内核为了管理文件需要维护的字段</li>
<li><a href="#Inode%20层">具体内容</a></li>
</ul></li>
<li>pipe 的数据结构如下
<ul>
<li>内容很直白，两个 fd，两个数字记录读写的字节数，一个缓冲区</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/pipe.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">char</span> data[PIPESIZE];</span><br><span class="line">    uint nread;     <span class="comment">// number of bytes read</span></span><br><span class="line">    uint nwrite;    <span class="comment">// number of bytes written</span></span><br><span class="line">    <span class="type">int</span> readopen;   <span class="comment">// read fd is still open</span></span><br><span class="line">    <span class="type">int</span> writeopen;  <span class="comment">// write fd is still open</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>文件的基本操作
<ul>
<li>filealloc()：分配一个新的文件 entry（打开或者新建文件使用）</li>
<li>filedup()：复制文件</li>
<li>fileclose()：关闭文件</li>
<li>filestat()：获取文件的元数据信息</li>
</ul></li>
<li>xv6-riscv 最多支持同时打开 100 个文件（NFILE）</li>
<li>每一个进程最多支持打开 16 个文件（NOFILE）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/param.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOFILE       16  <span class="comment">// open files per process</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFILE       100  <span class="comment">// open files per system</span></span></span><br></pre></td></tr></table></figure>
<h2 id="问题-7">问题 7</h2>
<blockquote>
<p>阅读文件
sysfile.c，了解与文件系统相关的系统调用，简述各个系统调用的作用</p>
</blockquote>
<ul>
<li>一个具体实现的例子<a href="#系统调用（代码实现）">如上</a>（sys_link()）</li>
<li>一些与文件系统相关的系统调用的含义
<ul>
<li>sys_pipe()：打开一个管道，并将结果保存到 proc 数据结构的 ofile
中</li>
<li>sys_chdir()：切换当前目录</li>
<li>sys_mknod()：创建字符设备文件和块设备文件</li>
<li>sys_mkdir()：新建文件夹</li>
<li>sys_open()：打开文件</li>
<li>sys_unlink()：删除这个文件引用</li>
<li>sys_link()：将 new 指向 old，指向同一个文件</li>
<li>sys_fstat()：获取文件元数据信息</li>
<li>sys_close()：关闭文件</li>
<li>sys_write()：王文件中写数据</li>
<li>sys_read()：从文件中读取数据</li>
<li>sys_dup()：复制文件</li>
</ul></li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf</li>
<li>https://github.com/mit-pdos/xv6-riscv</li>
</ul>
]]></content>
      <categories>
        <category>OS.xv6-source-code</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习.陈向群.说明</title>
    <url>/2021/06/20/OS/CXQ/00/</url>
    <content><![CDATA[<h1 id="操作系统复习">操作系统复习</h1>
<h2 id="说明">说明</h2>
<ul>
<li>课程名称：操作系统</li>
<li>授课老师：陈向群</li>
<li>课程链接：<a href="http://www.chinesemooc.org/mooc/4747">华文慕课</a></li>
</ul>
]]></content>
      <categories>
        <category>0</category>
        <category>OS.CXQ</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习.陈向群（06-07）（存储管理）</title>
    <url>/2021/06/20/OS/CXQ/Review-2/</url>
    <content><![CDATA[<h1 id="操作系统复习06-07">操作系统复习（06-07）</h1>
<h2 id="chapter-06存储管理概述">Chapter 06：存储管理概述</h2>
<h3 id="关键词">关键词</h3>
<ul>
<li>地址重定位、逻辑地址、物理地址、存储保护、存储共享、单一连续区、固定分区、覆盖技术、可变分区、页式、段式、虚拟内存、虚拟存储空间、虚拟地址、物理地址、页表/页表项、快表
TLB、驻留集、工作集、页面置换算法、清除策略、交换技术、段页式、Page
Fault、加载控制、页缓冲技术、地址转换、地址变换、地址翻译、地址映射</li>
</ul>
<h3 id="思考题">思考题</h3>
<ul>
<li>怎样理解 “进程地址空间是对内存的抽象” 这句话？</li>
<li>结合课件 21 页的图、 22
页上的图说明采用的是哪一种内存分配算法？</li>
<li>课件 32
页上提到紧缩时要考虑的问题包括系统开销和移动时机两方面，请具体说明为什么要考虑这两个问题？</li>
<li>采用交换技术后，被换出内存后再换入内存的进程是否必须回到原处？如果不是，通过什么方式(技术或机制)可以做到</li>
<li>请给出一种管理磁盘交换区的方案。</li>
<li>课件 50
页上提出了两种解决进程空间增长的解决方案，请比较它们。你倾向哪一种解决方案，为什么？</li>
</ul>
<h3 id="内容">内容</h3>
<ul>
<li>连续性 — 离散性</li>
<li>驻留性 — 交换性</li>
<li>一次性 — 多次性</li>
<li>地址重定位：将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址的过程
<ul>
<li>静态地址重定位：加载到内存时</li>
<li>动态地址重定位：逐条指令执行时
<ul>
<li>MMU</li>
</ul></li>
</ul></li>
</ul>
<h4 id="物理内存管理方案">物理内存管理方案</h4>
<ul>
<li>空闲物理内存管理
<ul>
<li>位图、空闲区表（已分配区表）、空闲块链表</li>
</ul></li>
<li>内存分配算法
<ul>
<li>首次适配（first fit）</li>
<li>下次适配（next fit）
<ul>
<li>从上次找到的空闲区处接着查找，其他和首次适配相同</li>
</ul></li>
<li>最佳适配（best fit）</li>
<li>最差适配（worst ft）</li>
</ul></li>
<li>回收问题
<ul>
<li>合并空闲块</li>
<li>上相邻、下相邻、上下都相邻、上下都不相邻</li>
</ul></li>
</ul>
<h5 id="伙伴系统">伙伴系统</h5>
<ul>
<li>Linux 底层内存管理采用</li>
<li>例子
<ul>
<li>整块分配</li>
<li>只有伙伴才合并</li>
<li>最佳适配</li>
</ul></li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-2/image-20210621102110784.png" style="zoom:67%;"></p>
<h4 id="基本内存管理方案">基本内存管理方案</h4>
<ul>
<li>单一用户连续区</li>
<li>固定分区</li>
<li>可变分区
<ul>
<li>碎片
<ul>
<li>紧缩技术（memory
compaction）：在内存移动程序，将所有小的空闲区合并为较大的空闲区</li>
</ul></li>
</ul></li>
<li>页式
<ul>
<li>内存块（物理页面、页框、页帧、page frame）</li>
<li>页表、页表项</li>
<li>逻辑地址：页号、页内偏移</li>
<li><strong>内碎片</strong></li>
</ul></li>
<li>段式
<ul>
<li>段内连续，段间可以不连续</li>
<li><strong>用户程序地址空间</strong>：按程序自身的<strong>逻辑关系</strong>划分为若干个程序段，每个程序段都有一个段名</li>
<li><strong>内存空间</strong>被<strong>动态</strong>的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定</li>
<li>逻辑地址：段号、段内地址</li>
</ul></li>
<li>段页式
<ul>
<li>用户程序划分：按段式划分（对用户来讲，按段的逻辑关系进行划分；对系统讲，按页划分每一段）</li>
<li><strong>每一段有一个页表</strong></li>
</ul></li>
</ul>
<h4 id="内存-扩充">内存 “扩充”</h4>
<ul>
<li>覆盖技术（Overlaying）：早期操作系统
<ul>
<li>程序执行过程中，<strong>程序的不同部分在内存中相互替代</strong>
<ul>
<li>按照其自身的逻辑结构将那些不会同时执行的程序段共享同一块内存区域</li>
<li>要求程序各模块之间有明确的调用结构</li>
</ul></li>
<li>程序员声明覆盖结构，操作系统完成自动覆盖</li>
</ul></li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-2/image-20210621105758541.png" style="zoom: 50%;"></p>
<ul>
<li>交换技术（Swapping）
<ul>
<li>交换区：一般系统会指定一块<strong>特殊的磁盘区域</strong>作为交换空间（swap
space），包含<strong>连续的磁道</strong>，操作系统可以使用底层的磁盘读写操作对其<strong>高效访问</strong></li>
</ul></li>
</ul>
<h2 id="chapter-07虚拟存储管理">Chapter 07：虚拟存储管理</h2>
<h3 id="关键词-1">关键词</h3>
<ul>
<li>虚拟存储管理、硬件机制（地址转换）、页表/页表项、页错误处理、各种软件策略（读取策略、放置策略、置换策略、驻留集策略、清除策略、装载控制策略）</li>
</ul>
<h3 id="思考题-1">思考题</h3>
<ul>
<li>进程地址空间是对内存的抽象，请解读一下课件第 3 页上的图</li>
<li>虚拟内存、虚拟地址空间、虔拟地址、虔拟存储技术四个术语的解释</li>
<li>怎样理解操作系统中的资源转换技术？举例说明</li>
<li>结合课件 23-24 页的内容和图，梳理一下 CPU
取到虚拟地址并把转换为物理地址的过程</li>
<li>课件 30 页的图表示的是什么流程？请总结一下该流程的每一个步骤</li>
<li>OPT 置换算法的作用是什么？在什么条件下可以实现它？</li>
<li>请比较老化算法（Aging）与 LRU 算法</li>
<li>课件 36
页上给出了设计页面置换算法时的典型思路:基于过去的行为来预测将来的行为。请列举日常生活中运用这一思路的例子</li>
<li>课件第 48 页的置换算法是一种简单的使用特殊硬件实现 LRU
的方法，请解释理由</li>
<li>实现工作集模型需要考虑哪些因素？开放性探讨一下：是否可以采用机器学习等方法实现工作集模型？有没有使用场录？利弊各是什么？</li>
<li>TLB 什么时候刷新？怎么刷新？</li>
</ul>
<h3 id="内容-1">内容</h3>
<ul>
<li>主要是虚拟页式存储管理</li>
<li>概念区分
<ul>
<li><strong>虚拟内存</strong>：物理内存和磁盘</li>
<li><strong>虚拟地址空间</strong>：分配给进程的虚拟内存</li>
<li><strong>虚拟地址</strong>：虚拟内存中某一位置的地址</li>
<li><strong>虚拟存储技术</strong>：当进程运行时，先将其一部分装入内存，另一部分暂时保存在磁盘；当要执行的指令或访问的数据不在内存时，由操作系统自动完成将它们从磁盘调入内存的工作</li>
</ul></li>
<li>lazy allocation</li>
<li>交换技术</li>
<li>请求调页（demand paging）、预先调页（prepaging）</li>
<li>MMU</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-2/image-20210621114558663.png" style="zoom:50%;"></p>
<ul>
<li>页表表项设计
<ul>
<li>页框号</li>
<li>有效位（valid、present）</li>
<li>访问位（referenced、accessed）</li>
<li>修改位（dirty、modified）</li>
<li>保护位：读 / 写 / 执行（protection）</li>
</ul></li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-2/image-20210621115053925.png" style="zoom: 45%;"></p>
<ul>
<li><strong>多级页表</strong></li>
<li>二级页表
<ul>
<li>页目录</li>
</ul></li>
<li>四级页表示例</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-2/image-20210509193047497.png" alt="image-20210621120928868" style="zoom: 67%;"></p>
<ul>
<li>反转页表（节省内存）
<ul>
<li>从物理地址空间出发，系统建立一张页表</li>
<li>页表项记录进程i的某虚拟地址(虚页号) 与页框号的映射关系</li>
<li>虚拟地址翻译：哈希表（拉链法解决冲突问题）</li>
</ul></li>
<li>地址转换
<ul>
<li>虚拟页面不在内存、页面非法、或者被保护 <span class="math inline">\(\Rightarrow\)</span> Page Fault</li>
</ul></li>
<li>快表 TLB
<ul>
<li>相联存储器</li>
<li>保存正在运行进程的页表的子集（部分表项）</li>
</ul></li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-2/image-20210621125731348.png" style="zoom:80%;"></p>
<ul>
<li>TLB 和 高速缓存</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-2/image-20210621125923726.png" style="zoom:80%;"></p>
<ul>
<li>缺页异常：一种 page fault</li>
<li>驻留集管理
<ul>
<li>固定分配策略、可变分配策略（通过缺页率评估）</li>
</ul></li>
</ul>
<h4 id="页面置换算法">页面置换算法</h4>
<ul>
<li>置换策略
<ul>
<li>局部置换策略：缺页进程的驻留集</li>
<li>全局置换策略：内存中所有未锁定的页框</li>
</ul></li>
<li>置换策略
<ul>
<li>目标：<strong>置换最近最不可能访问的页</strong></li>
<li>局部性原理：基于过去预测未来</li>
</ul></li>
<li>页框锁定
<ul>
<li>操作系统核心代码、关键数据结构、<strong>I/O 缓冲区</strong></li>
</ul></li>
</ul>
<h5 id="页面置换算法-replacement">页面置换算法 replacement</h5>
<h6 id="理想最佳最优置换算法opt">理想（最佳、最优）置换算法（OPT）</h6>
<h6 id="先进先出页面置换算法fifo">先进先出页面置换算法（FIFO）</h6>
<ul>
<li>页面链表实现</li>
</ul>
<h6 id="第二次机会置换算法scr">第二次机会置换算法（SCR）</h6>
<ul>
<li>按照先进先出算法选择某一页面，检查其访问位 R
<ul>
<li>如果为 0，则置换该页</li>
<li>如果为 1，则给第二次机会，并将访问位置
0，把该页面放到链表的尾端（新放入一样）</li>
</ul></li>
</ul>
<h6 id="时钟算法clock">时钟算法（Clock）</h6>
<ul>
<li>循环链表</li>
<li>不移动页面位置</li>
</ul>
<h6 id="最近未使用算法nru">最近未使用算法（NRU）</h6>
<ul>
<li>选择在最近一段时间内未使用过的一页并置换</li>
<li>算法
<ul>
<li>访问位（R）、修改位（M）</li>
<li>分类
<ul>
<li>第 0 类：无访问，无修改</li>
<li>第 1 类：无访问，有修改</li>
<li>第 2 类：有访问，无修改</li>
<li>第 3 类：有访问，有修改</li>
</ul></li>
<li>随机从编号最小的非空类中选择一页置换</li>
</ul></li>
<li>实现
<ul>
<li><ol type="1">
<li>从指针的当前位置开始，扫描页框缓冲区，选择遇到的第一个页框（r=0；m=0）用于置换（本扫描过程中，对访问位不做任何修改）</li>
</ol></li>
<li><ol start="2" type="1">
<li>如果第 1
步失败，则重新扫描，选择第一个（r=0；m=1）的页框（本次扫描过程中，对每个跳过的页框，将其访问位设置成
0）</li>
</ol></li>
<li><ol start="3" type="1">
<li>如果第 2
步失败，指针将回到它的最初位置，并且集合中所有页框的访问位均为 0。重复第
1 步，并且，如果有必要，重复第 2 步</li>
</ol></li>
</ul></li>
<li>实现的区别就是修改了访问位
<ul>
<li>如果只跑一次这个算法结果是一样的</li>
</ul></li>
<li><strong>NRU 不带时间戳</strong></li>
</ul>
<h6 id="最近少使用算法-lru">最近少使用算法 (LRU)</h6>
<ul>
<li>LRU 性能接近 OPT</li>
<li>实现：时间戳、维护一个访问页的栈
<ul>
<li>开销大</li>
</ul></li>
<li>一种硬件实现
<ul>
<li>访问：行置为 1，列置为 0</li>
<li>置换：把和最小的行替换掉</li>
</ul></li>
<li>一个例子：页面访问顺序 0, 1, 2, 3, 2, 1, 0, 3, 2, 3</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-2/image-20210621134821834.png" style="zoom:40%;"></p>
<h6 id="最不经常使用算法nfu">最不经常使用算法（NFU）</h6>
<ul>
<li>选择访问次数最少的页面置换</li>
<li>实现：
<ul>
<li>软件计数器，一页一个，初值为 0</li>
<li>每次时钟中断时，计数器加 R</li>
<li>发生缺页中断时，选择计数器值最小的一页置换</li>
</ul></li>
</ul>
<h6 id="老化算法aging">老化算法（Aging）</h6>
<ul>
<li>改进（模拟LRU）：计数器在加 R 前先右移一位，R
位加到计数器的最左端</li>
<li>感觉和 LRU
相似，但是计数器的位数是有限的，会把较早的访问情况冲掉</li>
</ul>
<h6 id="页面置换例子">页面置换例子</h6>
<ul>
<li>注意 FIFO
访问已经缓存的页的时候不移动链表（相当于不修改时间戳）</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-2/image-20210621135801334.png" style="zoom:150%;"></p>
<ul>
<li>LRU</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-2/image-20210621135939814.png" style="zoom:150%;"></p>
<ul>
<li>OPT</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-2/image-20210621135958374.png" style="zoom:150%;"></p>
<h5 id="belady-现象">Belady 现象</h5>
<ul>
<li>FIFO：当分配给进程的物理页面数增加时，缺页次数反而增加</li>
</ul>
<h5 id="影响缺页次数的因素">影响缺页次数的因素</h5>
<ul>
<li>因素
<ul>
<li>页面置换算法</li>
<li>页面本身的大小
<ul>
<li>最佳页面大小：<span class="math inline">\(\sqrt{2se}\)</span></li>
</ul></li>
<li>程序的编制方法</li>
<li>分配给进程的物理页面数</li>
</ul></li>
<li>颠簸（Thrashing，抖动）
<ul>
<li>虚存中，页面在内存与磁盘之间频繁调度，使得调度页面所需的时间比进程实际运行的时间还多，这样导致系统效率急剧下降，这种现象称为颠簸或抖动</li>
</ul></li>
</ul>
<h5 id="工作集模型">工作集模型</h5>
<ul>
<li>活跃页面</li>
<li>工作集 <span class="math inline">\(W(t,\Delta)\)</span>
<ul>
<li>该进程在过去的 <span class="math inline">\(\Delta\)</span>
个虚拟时间单位中使用的虚拟页面集合</li>
</ul></li>
<li>驻留集：当前时刻，进程实际驻留在内存当中的页框集合</li>
<li>思路：找出一个不在工作集中的页面并置换它
<ul>
<li>判定：每个页表项中有一个字段记录该页面最后一次被访问的时间</li>
</ul></li>
<li>算法实现
<ul>
<li>扫描所有页表项，执行操作</li>
<li><ol type="1">
<li>如果一个页面的 R 位是
1，则将该页面的最后一次访问时间设为当前时间，将 R 位清零</li>
</ol></li>
<li><ol start="2" type="1">
<li>如果一个页面的 R 位是 0，则检查该页面的访问时间是否在 “当前时间 - T”
之前</li>
</ol>
<ol start="2" type="1">
<li>[1] 如果是，则该页面为被置换的页面；</li>
<li>[2]
如果不是，记录当前所有被扫描过页面的最后访问时间里面的最小值。扫描下一个页面并重复
(1)、(2)</li>
</ol></li>
</ul></li>
</ul>
<ol start="2" type="1">
<li>类似的思想：监视缺页率增减驻留集大小</li>
</ol>
<h5 id="清除策略">清除策略</h5>
<ul>
<li>保存一定数目的页框供给比使用所有内存并在需要时搜索一个页框有更好的性能</li>
<li>一个置换出去但是还未被覆盖的页面，当他再次被访问的时候，直接将其移出空闲缓冲池即可</li>
<li>分页守护进程：检查内存状态，保证有大量空闲页框</li>
<li>双指针时钟：前指针由分页守护进程控制</li>
<li><strong>页缓冲技术</strong>
<ul>
<li>空闲页链表</li>
<li>修改页链表：簇的方式写回（减少 I/O）</li>
</ul></li>
</ul>
<h5 id="加载控制">加载控制</h5>
<ul>
<li>系统并发度：驻留在内存中的进程数目</li>
<li><strong>通过调节并发进程数进行系统负载控制</strong>
<ul>
<li>交换到磁盘</li>
</ul></li>
</ul>
<h4 id="内存映射文件">内存映射文件</h4>
<ul>
<li>mmap()</li>
<li>lazy 读入</li>
<li>共享库文件中的共享对象</li>
<li>私有的写时拷贝对象</li>
</ul>
<h4 id="策略与机制分离">策略与机制分离</h4>
<ul>
<li>Mach</li>
<li>存储管理系统被分为三个部分
<ul>
<li>底层MMU处理程序（与机器相关）</li>
<li>作为内核一部分的缺页中断处理程序（与机器无关）</li>
<li>运行在<strong>用户空间</strong>中的外部页面调度程序（策略）</li>
</ul></li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-2/image-20210621144545558.png" style="zoom:50%;"></p>
<h2 id="chapter-07-2windows-虚拟内存管理技术">Chapter 07-2：Windows
虚拟内存管理技术</h2>
<h3 id="思考题-2">思考题</h3>
<ul>
<li>进程虚拟地址空间的大小由谁决定？</li>
<li>进程虚拟地址空间的布局由谁确定？</li>
<li>创建一个进程，加载相应的可执行文件并且执行的过程是怎样的？</li>
<li>当捕获到缺页错误时，操作系统如何知道程序当前所需要的页在可执行文件中的哪一个位置？</li>
<li>总结 Windows 自映射机制的实现原理</li>
<li>总结 Windows 的物理内存管理</li>
</ul>
<h3 id="内容-2">内容</h3>
<h4 id="intel-x86-虚拟内存机制">Intel x86 虚拟内存机制</h4>
<p><img src="/2021/06/20/OS/CXQ/Review-2/image-20210621145153555.png" style="zoom:50%;"></p>
<h4 id="windows-虚拟内存管理">Windows 虚拟内存管理</h4>
<h5 id="内存管理器的组成部分">内存管理器的组成部分</h5>
<ul>
<li>工作集管理器（MmWorkingSetManager）</li>
<li>进程/栈交换器（KeSwapProcessOrStack）</li>
<li>修改页面写出器（MiModifiedPageWriter）</li>
<li>映射页面写出器（MiMappedPageWriter）</li>
<li>零页线程（MmZeroPageThread）</li>
</ul>
<h5 id="缺页异常处理">缺页异常处理</h5>
<ul>
<li><p>CPU 翻译的时候发现页表项无效 <span class="math inline">\(\Rightarrow\)</span> 缺页中断</p></li>
<li><p>发生缺页中断时， CPU 自动将引发异常时访问的虚拟地址存入寄存器
<strong>CR2</strong></p></li>
<li><p>走中断异常处理流程</p></li>
<li><p>根据操作系统提供的异常处理程序开始处理</p></li>
<li><p>页目录与自映射机制</p>
<ul>
<li>专用寄存器（x86 中为
<strong>CR3</strong>）用于保存页目录的物理地址</li>
</ul></li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-2/image-20210621152121351.png" style="zoom:67%;"></p>
<h5 id="工作集">工作集</h5>
<ul>
<li>基于工作集模型的页面置换算法</li>
</ul>
<h5 id="用户空间内存分配方式">用户空间内存分配方式</h5>
<ul>
<li>以页为单位的虚拟内存分配方式
<ul>
<li>两阶段：<strong>保留</strong>、<strong>提交</strong></li>
<li>如何判断保留/提交
<ul>
<li>页表可以判断提交，但是无法判断保留</li>
<li>VAD 虚拟地址描述符，平衡二叉树</li>
</ul></li>
</ul></li>
<li>内存映射文件</li>
<li>内存堆方法
<ul>
<li>适用于大量的小型内存申请</li>
</ul></li>
</ul>
<h5 id="物理内存管理">物理内存管理</h5>
<ul>
<li>页框的状态
<ul>
<li>活动（Active）/ 有效（Valid ）：在工作集中</li>
<li>过渡（Transition）：读入页框 / 从页框写出</li>
<li>空闲（Free）</li>
<li>零初始化（zeroed）：空闲且被零初始化</li>
<li>坏（Bad ）：硬件坏了</li>
<li>后备（standby）：页框内容未修改，invalid、transition，但是内容还在</li>
<li>修改（Modified）：页框内容修改过，invalid、transition，但是内容还在</li>
</ul></li>
<li>页表与页框号数据库</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-2/image-20210621154155412.png" style="zoom:67%;"></p>
<ul>
<li>了解每一条线是为什么
<ul>
<li>进程的工作集出来：页框不够用得回收（看是否被修改）、<strong>进程结束</strong></li>
</ul></li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-2/image-20210621154246683.png" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>OS.CXQ</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习.陈向群（文件系统）</title>
    <url>/2021/06/21/OS/CXQ/Review-3/</url>
    <content><![CDATA[<h1 id="操作系统复习">操作系统复习</h1>
<h2 id="文件系统">文件系统</h2>
<h3 id="关键词">关键词</h3>
<ul>
<li>文件系统、文件、文件分类、文件控制块
FCB、文件目录、目录文件、文件系统布局
、文件逻辑结构、文件物理结构、文件描述符 / 文件句柄、FAT /
UNIX、文件基本操作、内存结构、文件共享、磁盘空间管理</li>
</ul>
<h3 id="思考题">思考题</h3>
<ul>
<li>怎样理解 “文件是对磁盘的抽象”？</li>
<li>文件系统提供了哪些 “接口”</li>
<li>怎样实现 “文件的按名存取” ？</li>
<li>文件系统的 “最后一公里”是什么？</li>
<li>怎样设计 “文件的属性”？</li>
<li>怎样理解 “文件的逻辑结构和物理结构” ？</li>
<li>文件目录、目录文件和目录项之间的关联？目录项和文件控制块(FCB)的区别和相同点？</li>
<li>实现文件系统需要考虑磁盘与内存中的内容布局，UNIX、FAT 和
NTFS几个文件系统都是怎样设计的？</li>
<li>怎样理解 “目录文件的组织方式：顺序、散列、B+树” ？</li>
<li>“文件目录检索”
的步骤有哪两步？每一步达到什么目的？如何加快这一步骤？</li>
<li>文件系统在内存中需要数据结构，为什么？</li>
<li>FAT16文件系统的局限性是什么？</li>
<li>怎样实现系统调用rename (给文件重命名) ？</li>
<li>怎样实现系统调用copy (复制文件) ？</li>
<li>为什么提供 “硬链接” 和 “软链接” ？</li>
</ul>
<h3 id="内容">内容</h3>
<h4 id="文件系统基本概念">文件系统基本概念</h4>
<ul>
<li>文件是什么
<ul>
<li>文件是对磁盘的抽象</li>
<li>所谓文件是指一组带标识（标识即为文件名）的、在逻辑上有完整意义的<strong>信息项的序列</strong></li>
<li><strong>信息项</strong></li>
<li>文件内容的意义：<strong>由文件建立者和使用者解释</strong></li>
</ul></li>
<li>文件系统</li>
<li>文件的分类：普通文件、目录文件、特殊文件(设备文件)、管道文件、套接字、符号链接文件</li>
<li>文件的逻辑结构
<ul>
<li>字节序列（流式文件）、记录序列（记录式文件）、树</li>
<li>堆、顺序、索引、散列、索引顺序</li>
</ul></li>
<li>文件存取方式
<ul>
<li>顺序访问、随机存取</li>
</ul></li>
<li>存储介质</li>
<li>磁盘：扇区 <span class="math inline">\(\to\)</span> 物理块</li>
<li>磁盘结构</li>
</ul>
<p><img src="/2021/06/21/OS/CXQ/Review-3/image-20210621161552239.png" style="zoom:67%;"></p>
<ul>
<li>磁盘访问
<ul>
<li><strong>寻道</strong>（时间）：磁头移动定位到指定磁道</li>
<li><strong>旋转延迟</strong>（时间）：等待指定扇区从磁头下旋转经过</li>
<li><strong>数据传输</strong>（时间）：数据在磁盘与内存之间的实际传输</li>
</ul></li>
<li>文件属性
<ul>
<li>文件控制块 FCB</li>
<li>常用属性</li>
</ul></li>
<li>文件操作
<ul>
<li>create、delete、open、...</li>
</ul></li>
</ul>
<p><span style="color:red;font-weight:bold">TODO</span></p>
]]></content>
      <categories>
        <category>OS.CXQ</category>
        <category>TODO</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习.陈向群（00-02）（概述、中断异常）</title>
    <url>/2021/06/20/OS/CXQ/Review/</url>
    <content><![CDATA[<h1 id="操作系统复习00-02">操作系统复习（00-02）</h1>
<h2 id="chapter-00课程简介">Chapter 00：课程简介</h2>
<h3 id="内容">内容</h3>
<ul>
<li>执行一个可执行文件的时候，操作系统做了什么？</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hello world&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>两种观点
<ul>
<li>用户程序：OS 功能调用、返回</li>
<li>进程调度：调度、返回</li>
</ul></li>
<li>操作系统的主要工作
<ul>
<li>执行程序、个性（硬件相关）、共性、其他问题（性能、安全、健壮性等）</li>
</ul></li>
</ul>
<h2 id="chapter-01操作系统概述">Chapter 01：操作系统概述</h2>
<h3 id="关键词">关键词</h3>
<ul>
<li>操作系统定义、并发性、共享性、虚拟性、随机性、SPOOLing、多道程序设计、OS/360、MULTICS、典型操作系统</li>
</ul>
<h3 id="思考题">思考题</h3>
<ul>
<li>一个应用程序的执行流程是怎样的？ 涉及到哪些功能模块？</li>
<li>请问 Windows 操作系统中的设备驱动程序具体提
供了什么功能？有具体的例子吗？为什么说它不直接与硬件打交道？
可不可以理解为设备驱动程序是建立在 HAL
之上的更高层的抽象，所以是通过HAL与硬件打交道 ？</li>
<li>课件上 “UNIX操作系统”
<ul>
<li>文件子系统与块设备之间的 Buffer Cache 的作用是什么？</li>
<li>简要小结一下 Buffer Cache 的工作原理</li>
</ul></li>
<li>UNIX 的名字来历的猜测</li>
<li>SPOOLing 技术过时了吗？</li>
<li>传统的分时系统在今天有什么意义？</li>
</ul>
<h3 id="内容-1">内容</h3>
<ul>
<li><p>Windows 架构、Unix 架构、Linux 架构、Android 架构</p></li>
<li><p>层次：应用程序、系统功能调用、操作系统、计算机硬件</p></li>
<li><p>操作系统是什么？</p>
<ul>
<li><p>系统软件</p>
<p>软硬件资源管理（<strong>有效</strong>、<strong>合理</strong>）</p></li>
<li><p>程序执行控制，对外提供服务</p></li>
<li><p>用户<strong>方便</strong>使用</p></li>
<li><p>机器的<strong>扩展</strong></p></li>
</ul></li>
<li><p>设计与实现目标：抽象、模块化、性能、应用之间、隔离性、可靠性、节能、安全性、移动性</p></li>
<li><p>什么是操作系统（不同角度）？</p>
<ul>
<li>作为软件来看的观点</li>
<li>资源管理的观点</li>
<li>进程的观点</li>
<li>虚机器观点（<strong>分层结构</strong>）</li>
</ul></li>
<li><p>操作系统的特征：<strong>并发</strong>、<strong>共享</strong>、<strong>虚拟</strong>、<strong>随机</strong></p></li>
<li><p>操作系统发展史</p>
<ul>
<li>第1阶段 （1948 -1970 ）：硬件昂贵，人工便宜
<ul>
<li>SPOOLing（假脱机）</li>
</ul></li>
<li>第2阶段 （1970 -1985 ）：硬件便宜，人工昂贵
<ul>
<li>第一个分时操作系统 CTSS</li>
</ul></li>
<li>第3阶段 （1981 -）：硬件非常便宜，人工昂贵</li>
<li>第4阶段 （1981 -）：分布式</li>
<li>第5阶段 （1995 -）：移动计算时代</li>
<li>第6阶段 （2006 -）：云计算时代</li>
<li>第7阶段 （200？ -）：泛在计算 / 普适计算 / 物联网</li>
</ul></li>
<li><p>操作系统分类</p>
<ul>
<li>批处理操作系统（多道）</li>
<li>分时系统</li>
<li>实时操作系统
<ul>
<li>硬实时系统、软实时系统</li>
</ul></li>
<li>个人计算机操作系统</li>
<li>网络操作系统</li>
<li>分布式操作系统</li>
<li>嵌入式操作系统</li>
</ul></li>
<li><p>操作系统的另一种分类（Tanenbaum）</p>
<ul>
<li>大型机操作系统</li>
<li>服务器操作系统</li>
<li>多处理机操作系统</li>
<li>个人计算机操作系统</li>
<li>实时操作系统</li>
<li>嵌入式操作系统</li>
<li>智能卡操作系统</li>
</ul></li>
</ul>
<h2 id="chapter-02运行环境和运行机制">Chapter
02：运行环境和运行机制</h2>
<h3 id="关键词-1">关键词</h3>
<ul>
<li>CPU 状态 (模式
)、特权指令、非特权指令、内核态/用户态、管态/目态、R0/R3、中断与异常、中断向量表、中断描述符、系统调用、机制与策略</li>
</ul>
<h3 id="思考题-1">思考题</h3>
<ul>
<li>怎样理解 ”操作系统是由中断/异常/事件驱动的” 这句话？</li>
<li>中断/异常的来源有什么不同？ 处理方式是一样的吗？</li>
<li>中断/异常机制中，哪些是硬件(体系结构)负责的？
哪些是软件(操作系统)负责的？</li>
<li>从中断响应(硬件)到中断处理程序(软件)执行结束，计算机系统经过了哪些流程？</li>
<li>操作系统初始化与中断/异常有哪些关联？</li>
<li>怎样理解应用程序是如何与操作系统交互的？</li>
<li>什么是软件异常？ 它是如何工作的？</li>
<li>X86 在 Peniuml1300 之后提供了 sysantcr/sysexit
指令，为什么？与int0x80/iret有什么不同？</li>
<li>关于基于 x86 体系结构的 Linux 的系统调用实现:
<ul>
<li>系统调用入口程序 system_ call()
与中断描述符表是什么关系？与系统调用表是什么关系？</li>
<li>系统调用处理结束后，处理器转去执行哪个模块？</li>
</ul></li>
<li>系统调用与 C 函数调用的区别？</li>
</ul>
<h3 id="内容-2">内容</h3>
<h4 id="cpu">CPU</h4>
<ul>
<li>CPU 与内存</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review/image-20210620130725590.png" style="zoom: 50%;"></p>
<ul>
<li>两类寄存器
<ul>
<li>用户可见寄存器
<ul>
<li>数据寄存器、地址寄存器、条件码寄存器</li>
</ul></li>
<li>控制和状态寄存器
<ul>
<li>程序计数器（PC）、指令寄存器（IR）、程序状态字（PSW）</li>
</ul></li>
</ul></li>
<li>内核态与用户态</li>
<li>特权指令与非特权指令</li>
<li>x86 系列处理器
<ul>
<li>R0 <span class="math inline">\(\to\)</span> R3：特权高 <span class="math inline">\(\to\)</span> 低</li>
</ul></li>
<li>CPU 状态之间的切换
<ul>
<li>进入内核态：中断/异常/陷入机制</li>
<li>返回用户态：设置程序状态字 PSW</li>
</ul></li>
</ul>
<h4 id="中断机制">中断机制</h4>
<ul>
<li>中断与异常的引入原因
<ul>
<li>中断的引入：为了支持 CPU 和设备之间的并行操作</li>
<li>异常的引入：表示 CPU 执行指令时本身出现的问题</li>
</ul></li>
<li>中断与异常</li>
</ul>
<table>
<colgroup>
<col style="width: 24%">
<col style="width: 36%">
<col style="width: 12%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">类别</th>
<th style="text-align: center;">原因</th>
<th style="text-align: center;">异步/同步</th>
<th style="text-align: center;">返回行为</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">中断<br>Interrupt</td>
<td style="text-align: center;">来自 I/O 设备、其他硬件部件</td>
<td style="text-align: center;">异步</td>
<td style="text-align: center;">总是返回到下一条指令</td>
</tr>
<tr class="even">
<td style="text-align: center;">陷入<br>Trap</td>
<td style="text-align: center;">有意识安排的</td>
<td style="text-align: center;">同步</td>
<td style="text-align: center;">返回到下一条指令</td>
</tr>
<tr class="odd">
<td style="text-align: center;">故障<br>Fault</td>
<td style="text-align: center;">可恢复的错误</td>
<td style="text-align: center;">同步</td>
<td style="text-align: center;">返回到当前指令</td>
</tr>
<tr class="even">
<td style="text-align: center;">终止<br>Abort</td>
<td style="text-align: center;">不可恢复的错误</td>
<td style="text-align: center;">同步</td>
<td style="text-align: center;">不会返回</td>
</tr>
</tbody>
</table>
<ul>
<li>中断/异常机制工作原理
<ul>
<li><strong>软硬件配合</strong></li>
</ul></li>
<li>中断响应（中断硬件部件完成）
<ul>
<li>在每条指令执行周期的<strong>最后时刻</strong>扫描中断寄存器，查看是否有中断信号</li>
<li>若有中断，中断硬件将该中断触发器内容按规定编码送入 PSW
的相应位，称为中断码，通过交换<strong>中断向量</strong>引出中断处理程序</li>
</ul></li>
<li>中断向量与中断向量表</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review/image-20210620133337993.png" style="zoom:67%;"></p>
<ul>
<li>中断处理程序</li>
<li><strong>中断/异常机制中软硬件分工</strong>
<ul>
<li>以设备 IO 中断为例</li>
</ul></li>
</ul>
<h5 id="ia32-体系结构对中断的支持">IA32 体系结构对中断的支持</h5>
<ul>
<li>中断控制器</li>
<li>实模式（正常情况）：中断向量表</li>
<li>保护模式（刚启动）：中断描述符表</li>
<li>门描述符</li>
<li>IDTR 寄存器、GDTR 寄存器</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review/image-20210620135745915.png" style="zoom: 67%;"></p>
<ul>
<li>整个流程</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review/image-20210620140055338.png" style="zoom:67%;"></p>
<h4 id="存储系统">存储系统</h4>
<ul>
<li>容量、速度、成本</li>
<li>寄存器、高速缓存、主存、磁盘</li>
<li>局部性原理</li>
</ul>
<h4 id="io-访问技术">I/O 访问技术</h4>
<ul>
<li>程序控制方式
<ul>
<li>I/O 处理单元</li>
<li>CPU 定期<strong>轮询</strong> I/O 单元的状态，直到处理完毕</li>
</ul></li>
<li>中断驱动方式
<ul>
<li>每个数据需要传输时中断 CPU</li>
<li>I/O 操作与指令并行</li>
</ul></li>
<li>直接存储器存取（DMA）方式
<ul>
<li>一批数据需要传输时中断 CPU</li>
<li>DMA 控制</li>
</ul></li>
</ul>
<h4 id="时钟">时钟</h4>
<ul>
<li>绝对时钟、相对时钟</li>
<li>硬件时钟、软件时钟</li>
</ul>
<h5 id="x86-体系结构的定时硬件">x86 体系结构的定时硬件</h5>
<ul>
<li>4 种定时硬件
<ul>
<li>实时时钟（RTC）</li>
<li>时间戳计数器（TSC）</li>
<li>可编程间隔定时器（PIT）</li>
<li>SMP系统中的本地APIC定时器</li>
</ul></li>
</ul>
<h4 id="系统调用">系统调用</h4>
<ul>
<li>系统调用、库函数、API、内核函数</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review/image-20210620144410952.png" style="zoom:67%;"></p>
<ul>
<li>系统调用机制的设计
<ul>
<li>利用中断/异常机制</li>
</ul></li>
<li>如何实现参数传递
<ul>
<li>陷入指令自带参数</li>
<li><strong>通用寄存器</strong></li>
<li>专用堆栈区</li>
</ul></li>
</ul>
<h4 id="内核的进入与退出">内核的进入与退出</h4>
<p><img src="/2021/06/20/OS/CXQ/Review/image-20210620150546175.png" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>OS.CXQ</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习.陈向群（03-05）（进程线程）</title>
    <url>/2021/06/20/OS/CXQ/Review-1/</url>
    <content><![CDATA[<h1 id="操作系统复习03-05">操作系统复习（03-05）</h1>
<h2 id="chapter-03进程线程模型">Chapter 03：进程线程模型</h2>
<h3 id="关键词">关键词</h3>
<ul>
<li>进程、进程状态及状态转换、进程控制、进程控制块、进程地址空间、进程上下文、线程、线程属性、Web
服务器、用户级线程、Pthreads、核心级线程 、原语、可再入程序</li>
</ul>
<h3 id="思考题">思考题</h3>
<ul>
<li>怎样理解 “进程是对 CPU 的抽象” 这句话？</li>
<li>一个程序要经过哪些准备工作才能运行(程序怎样变成进程) ？</li>
<li>进程有哪些状态？状态之间转换的条件以及对应的操作？</li>
<li>一个进程在生命周期内都由哪些要素组成？</li>
<li>从静态和动态两个角度，怎样观察进程？</li>
<li>进程与程序是一样的吗？你能用日常生活中的例子解释什么是进程、什么是程序吗？</li>
<li>什么是可再入程序？为什么进程执行的程序要具备可再入特性？</li>
<li>哪些应用场景需要多线程支持？</li>
<li>线程的基本概念是什么？与进程是什么关系？</li>
<li>线程有哪些属性？为什么线程要有自己的栈？</li>
<li>线程实现机制有哪几种？</li>
<li>典型的操作系统都是怎样支持线程的？</li>
<li>Linux 是怎样支持线程的？ Linux内核是否区分进程和线程？</li>
</ul>
<h3 id="内容">内容</h3>
<h4 id="基本概念">基本概念</h4>
<ul>
<li>多道程序设计</li>
<li>并发环境与并发程序
<ul>
<li>如下都可以认为是并发</li>
</ul></li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-1/image-20210620152710803.png" style="zoom:67%;"></p>
<ul>
<li>进程
<ul>
<li>进程是具有独立功能的程序关于某个数据集合上的<strong>一次运行活动</strong>，是系统进行资源分配和调度的独立单位</li>
</ul></li>
</ul>
<h4 id="进程模型">进程模型</h4>
<ul>
<li>三状态
<ul>
<li>运行态（Running）、就绪态（Ready）、等待态（Waiting/Blocked）</li>
</ul></li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-1/image-20210620153101230.png" style="zoom:50%;"></p>
<ul>
<li>5 状态
<ul>
<li>创建（New）、终止（Terminated）、挂起（Suspended）
<ul>
<li>挂起：把一个进程从内存转到<strong>磁盘</strong></li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-1/image-20210620153216549.png" style="zoom:50%;"></p>
<ul>
<li>7 状态</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-1/image-20210620153624993.png" style="zoom: 50%;"></p>
<ul>
<li>Linux 进程模型</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-1/image-20210620153824357.png" style="zoom: 67%;"></p>
<ul>
<li>数据结构 PCB
<ul>
<li>PCB 是系统感知进程存在的唯一标志</li>
</ul></li>
<li>PCB 内容
<ul>
<li>进程描述信息、进程控制信息、所拥有的资源和使用情况、CPU
现场信息</li>
</ul></li>
<li>进程地址空间</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-1/image-20210620155652222.png" style="zoom:50%;"></p>
<ul>
<li>上下文切换</li>
<li>进程表
<ul>
<li>每类进程维护一个或者多个队列</li>
</ul></li>
</ul>
<h4 id="进程控制">进程控制</h4>
<ul>
<li>原语
<ul>
<li>原子操作</li>
</ul></li>
<li>进程的创建</li>
<li>进程的撤销</li>
<li>进程阻塞与进程唤醒</li>
<li>UNIX 系统设计的进程控制操作
<ul>
<li>fork、exec、wait、exit</li>
</ul></li>
<li>copy-on-write 技术</li>
<li>进程的分类
<ul>
<li>系统进程、用户进程</li>
<li>前台进程、后台进程</li>
<li>CPU 密集型进程、I/O 密集型进程</li>
</ul></li>
<li>进程的层次结构
<ul>
<li>UNIX进程家族树：init 为根</li>
<li>Windows：地位相同</li>
</ul></li>
</ul>
<h4 id="线程模型">线程模型</h4>
<ul>
<li>为什么在进程中再派生线程？
<ul>
<li>应用的需要
<ul>
<li>web 服务器</li>
</ul></li>
<li>开销的考虑
<ul>
<li>创建、撤销、通信、切换</li>
</ul></li>
<li>性能的考虑
<ul>
<li>并行</li>
<li>多处理器</li>
</ul></li>
</ul></li>
<li>Web 服务器的 3 种实现方式</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">模型</th>
<th style="text-align: center;">特性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">多线程</td>
<td style="text-align: center;">并行性、阻塞系统调用</td>
</tr>
<tr class="even">
<td style="text-align: center;">单线程进程</td>
<td style="text-align: center;">无并行性、阻塞系统调用</td>
</tr>
<tr class="odd">
<td style="text-align: center;">有限状态机</td>
<td style="text-align: center;">并行性、非阻塞系统调用、中断</td>
</tr>
</tbody>
</table>
<ul>
<li>线程：进程中一个运行实体，是 CPU 的调度单位
<ul>
<li>轻量级进程</li>
</ul></li>
<li>单线程进程模型、多线程进程模型</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-1/image-20210620162653610.png" style="zoom: 67%;"></p>
<ul>
<li>线程的实现
<ul>
<li>用户级线程：Linux
<ul>
<li>大多数系统调用是阻塞的，因此，由于内核阻塞进程，故进程中所有线程也被阻塞
<ul>
<li>修改系统调用为非阻塞的</li>
<li>重新实现对应系统调用的I/O库函数</li>
</ul></li>
</ul></li>
<li>核心级线程：Windows</li>
<li>混合：Solaris
<ul>
<li>用户空间创建、核心态调度</li>
<li>多个用户级线程多路复用多个内核级线程</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-1/image-20210620163606724.png" style="zoom:50%;"></p>
<ul>
<li>Solaris
<ul>
<li>Solaris 的多线程模型中包括四种实体
<ul>
<li>进程，内核线程，用户线程、轻量级进程（LWP）</li>
<li>LWP 把用户线程和内核线程绑定到一起</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-1/image-20210620163756995.png" style="zoom: 60%;"></p>
<ul>
<li>可再入程序（可重入）
<ul>
<li>可被多个进程同时调用的程序，具有下列性质
<ul>
<li>它是纯代码的，即在执行过程中自身不改变</li>
<li>调用它的进程应该提供数据区</li>
</ul></li>
</ul></li>
</ul>
<h2 id="chapter-04进程线程调度">Chapter 04：进程线程调度</h2>
<h3 id="关键词-1">关键词</h3>
<ul>
<li>调度层次、调度时机、进程切换、调度算法设计原则、抢占与非抢占、时间片、饥饿、调度算法、优先级反转、吞吐量、周转时间、响应时间、Linux调度算法、Windows
线程调度</li>
</ul>
<h3 id="思考题-1">思考题</h3>
<ul>
<li>所谓调度仅仅是指的CPU(处理器)调度吗？</li>
<li>怎样描述进程的优先级？</li>
<li>就绪队列有哪些组织方式？</li>
<li>有哪些引发调度的原因？</li>
<li>衡量调度算法的指标有哪些？怎样选取？</li>
<li>怎样区分抢占式和非抢占式调度思想？</li>
<li>操作系统内核怎么实现抢占式调度策略的？</li>
<li>时间片轮转算法是抢占式调度算法吗？</li>
<li>操作系统的调度机制很好地体现了机制和策略分离
的原则，请举例说明这一点</li>
<li>请同学们上网查一查,
1997年，美国发射的探测器‘探路者号”在火星上究竟发生了什么？请回答：
<ul>
<li>这个故事涉及到进程调度的哪个知识点？</li>
<li>故事中涉及到的是哪一个操作系统？</li>
<li>运行过程中“ 探路者号” 遇到了什么问题？</li>
<li>这个问题产生的原因是什么？</li>
<li>工程师们是怎么解决这个问题的？</li>
<li>这件事给我们什么启示？</li>
</ul></li>
</ul>
<h3 id="内容-1">内容</h3>
<ul>
<li>调度的 3 个层次
<ul>
<li>长程调度：作业调度或宏观调度</li>
<li>中程调度：进程在内外存之间的交换</li>
<li>短程调度：微观调度（毫秒级）</li>
</ul></li>
<li>处理器调度
<ul>
<li>系统空闲进程、idle 进程</li>
<li>调度程序</li>
</ul></li>
<li>三个问题：<strong>调度算法、调度时机、调度过程</strong></li>
<li><strong>调度时机</strong>：事件发生
<ul>
<li>内核对中断/异常/系统调用处理后返回到用户态前最后时刻</li>
</ul></li>
<li><strong>调度过程</strong>：进程切换
<ul>
<li>全局页目录</li>
<li>内核栈、硬件上下文</li>
<li>保存旧的，恢复新的</li>
</ul></li>
<li>上下文切换开销
<ul>
<li>直接开销</li>
<li>间接开销：高速缓存 Cache、Buffer Cache、TLB</li>
</ul></li>
</ul>
<h4 id="调度算法">调度算法</h4>
<ul>
<li>目标
<ul>
<li>交互式进程（interactive process）：响应时间、均衡性</li>
<li>批处理进程（batch process）：吞吐量、周转时间、CPU利用率</li>
<li>实时进程（real-time process）：最后期限、可预测性</li>
</ul></li>
<li>评价指标
<ul>
<li>公平性 Fairness</li>
<li>吞吐量 Throughput</li>
<li>周转时间 TT (Turnaround Time)：提出请求到完成</li>
<li>响应时间 RT (Response Time)</li>
<li>CPU 利用率 (CPU Utilization)</li>
<li>等待时间 (Waiting time)</li>
</ul></li>
</ul>
<h5 id="调度算法要点">调度算法要点</h5>
<ul>
<li>进程优先级</li>
<li>进程就绪队列组织
<ul>
<li>按优先级排队、多级队列</li>
</ul></li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-1/image-20210620171014692.png" style="zoom: 67%;"></p>
<ul>
<li>抢占与非抢占</li>
<li>I/O 密集型与 CPU 密集型进程</li>
<li>时间片
<ul>
<li>长短、长短是否一致、是否可变</li>
</ul></li>
</ul>
<h5 id="批处理系统中采用的调度算法">批处理系统中采用的调度算法</h5>
<ul>
<li>先来先服务（FCFS-First Come First Serve）</li>
<li>最短作业优先（SJF-Shortest Job First）</li>
<li>最短剩余时间优先（SRTN-Shortest Remaining Time Next）
<ul>
<li>SJF 的抢占版本</li>
</ul></li>
<li>最高响应比优先（HRRN-Highest Response Ratio Next）
<ul>
<li>响应比 R = 作业周转时间 / 作业处理时间 = 1 +（作业等待时间 /
作业处理时间）</li>
<li>抢占版本、不可抢占版本</li>
</ul></li>
</ul>
<h5 id="交互式系统中采用的调度算法">交互式系统中采用的调度算法</h5>
<ul>
<li>轮转调度（RR-Round Robin）
<ul>
<li>对于相同大小的进程不利（平均周转时间）</li>
</ul></li>
<li>优先级调度（HPF-Highest Priority First）
<ul>
<li>通常而言
<ul>
<li><strong>系统进程优先级</strong> 高于 用户进程</li>
<li><strong>前台进程优先级</strong> 高于 后台进程操作</li>
<li>系统更偏好 I/O 型进程</li>
</ul></li>
<li>优先级反转问题（抢占才会出现）
<ul>
<li>设置优先级上限（优先级天花板协议 priority ceiling protocol）</li>
<li>优先级继承
<ul>
<li><strong>阻挡了谁就继承谁</strong></li>
</ul></li>
<li>使用中断禁止</li>
</ul></li>
</ul></li>
<li>多级队列（Multiple queues）与多级反馈队列（Multiple feedback
queue）</li>
<li>最短进程优先（Shortest Process Next）</li>
</ul>
<h5 id="windows-调度算法">Windows 调度算法</h5>
<ul>
<li>动态优先级、抢占式</li>
<li>具体算法</li>
<li>线程优先级提升与时间配额调整</li>
</ul>
<h5 id="linux-调度算法">Linux 调度算法</h5>
<p><img src="/2021/06/20/OS/CXQ/Review-1/image-20210620192211811.png" style="zoom:67%;"></p>
<h5 id="多处理器调度">多处理器调度</h5>
<ul>
<li>负载均衡、迁移开销（直接、间接）</li>
<li>静态进程分配、动态进程分配</li>
</ul>
<h2 id="chapter-05进程线程同步模型">Chapter 05：进程线程同步模型</h2>
<h3 id="关键词-2">关键词</h3>
<ul>
<li>临界区、进程互斥、进程同步、信号量、PV
操作、管程、生产者消费者问题、读者写者问题、
条件变量、wait/signal、锁、Pthreads、Hoare 管程</li>
</ul>
<h3 id="思考题-2">思考题</h3>
<ul>
<li>课件第 17 页，如果把判断标志然后谖置标志实现为 lock()，则lock()
应该满足 什么性质？</li>
<li>当有进程在临界区时，有两种处理方式: (1) 一直占用 CPU 等待进入临界区;
(2) 阻塞等待。试问前者的效率一定比后者的效率低吗？</li>
<li>课件 25-26 页， “睡眠”
与“唤醒”操作都是原语操作，为什么用它们解决生产者消费者问题时依然可能出错？在什么场景下会出错？简单思考一下如何解决？</li>
<li>课件32页上给出的 PV 操作的定义与参考书《现代操作系统》或 ICS
课上的定义不同，但效果是否一样？请解释一下</li>
<li>请简单总结一下JAVA语言对管程的支持
<ul>
<li>如何解决互斥问题？</li>
<li>如何解决同步问题？</li>
</ul></li>
<li>课件第 80 页上锁的实现代码是否正确？为什么？第 81
页的解决方案是不是对的？第 82 页的呢？请解释一下 83 页的方案</li>
<li>阅读一下课件第 91
页上的例子，总结一下在用消息传递实现生产者消费者问题时，send 和 receive
的作用</li>
<li>请举一个简单的例子，说明 Linux 的共享内存机制的应用</li>
</ul>
<h3 id="内容-2">内容</h3>
<ul>
<li>进程：并发、共享、不确定性</li>
<li>顺序环境：程序执行的顺序性</li>
<li>并发环境</li>
<li>进程前趋图</li>
<li>竞争条件（race）</li>
<li>进程互斥
<ul>
<li>临界资源（critical resource）</li>
<li>临界区（critical section/region）</li>
</ul></li>
<li>临界区使用规则
<ul>
<li>有空让进、无空等待、有限等待</li>
<li>多中择一、让权等待</li>
</ul></li>
<li>进程的同步
<ul>
<li>某种时序关系</li>
</ul></li>
<li>实现进程互斥的方案
<ul>
<li>软件解法：Dekker、Peterson</li>
<li>硬件解法：中断屏蔽方法、测试并加锁（TSL）</li>
</ul></li>
<li>生产者消费者问题（有界缓冲区）</li>
</ul>
<h4 id="信号量及-pv-操作">信号量及 PV 操作</h4>
<ul>
<li>PV 操作是原语操作</li>
<li>信号量
<ul>
<li>初始化（非负数），P 操作、V 操作</li>
</ul></li>
<li>生产者消费者问题（有界缓冲区）</li>
<li>读者写者问题
<ul>
<li>读者优先</li>
</ul></li>
</ul>
<h4 id="管程">管程</h4>
<ul>
<li>由关于<strong>共享资源的数据结构</strong>及<strong>在其上操作的一组过程</strong>组成</li>
<li>进程<strong>只能</strong>通过<strong>调用管程中的过程</strong>来<strong>间接访问</strong>管程中的数据结构</li>
<li>两个问题：同步、互斥</li>
</ul>
<h5 id="hoare-管程">Hoare 管程</h5>
<ul>
<li>管程中的两个进程，P 唤醒 Q：P 等待，Q 运行</li>
</ul>
<p><img src="/2021/06/20/OS/CXQ/Review-1/image-20210620204847938.png" style="zoom:67%;"></p>
<ul>
<li>条件变量：在管程内部说明和使用的一种特殊类型的变量
<ul>
<li>var c:condition;</li>
<li>对于条件变量，可以执行 wait 和 signal 操作</li>
</ul></li>
<li>wait(c)
<ul>
<li>如果紧急等待队列非空，则唤醒第一个等待者，否则释放管程的互斥权</li>
<li>执行此操作的进程进入c 链尾部</li>
</ul></li>
<li>signal(c)
<ul>
<li>如果 c 链为空，则相当于空操作，执行此操作的进程继续执行</li>
<li>否则唤醒第一个等待者，执行此操作的进程进入紧急等待队列的尾部</li>
</ul></li>
</ul>
<h5 id="mesa-管程">Mesa 管程</h5>
<ul>
<li>signal <span class="math inline">\(\to\)</span> notify
<ul>
<li>notify：当一个正在管程中的进程执行 notify(x) 时，它使得 x
条件队列得到通知，发信号的进程继续执行</li>
</ul></li>
<li>notify
的结果：位于条件队列头的进程在将来合适的时候且当处理器可用时恢复执行
<ul>
<li>得用 while 再次判断条件</li>
</ul></li>
<li>超时则改为就绪（优化），但是还是得判断条件
<ul>
<li>避免 notify 的程序炸掉导致无法被唤醒</li>
</ul></li>
<li>broadcast 原语：全唤醒成就绪</li>
</ul>
]]></content>
      <categories>
        <category>OS.CXQ</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-labs-2020.说明</title>
    <url>/2021/03/26/OS/xv6-labs/00/</url>
    <content><![CDATA[<h2 id="说明">说明</h2>
<ul>
<li>mit 操作系统课程 lab
<ul>
<li><a href="https://pdos.csail.mit.edu/6.828/2020/">官网</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2020/labs/">labs
目录</a></li>
</ul></li>
<li><a href="https://github.com/banbao990/xv6-labs-2020">代码</a></li>
<li>已经完成部分如下
<ol>
<li style="list-style: none">
<input type="checkbox" checked> lab0-utils
</li>
<li style="list-style: none">
<input type="checkbox" checked> lab1-syscall
</li>
<li style="list-style: none">
<input type="checkbox" checked> lab2-pagetable
</li>
<li style="list-style: none">
<input type="checkbox" checked> lab3-traps
</li>
<li style="list-style: none">
<input type="checkbox" checked> lab4-lazy-allocation
</li>
<li style="list-style: none">
<input type="checkbox" checked> lab5-copyonwrite
</li>
<li style="list-style: none">
<input type="checkbox" checked> lab6-multi-threading
</li>
<li style="list-style: none">
<input type="checkbox" checked> lab7-lock
</li>
<li style="list-style: none">
<input type="checkbox" checked> lab8-file-system
</li>
<li style="list-style: none">
<input type="checkbox" checked> lab9-mmap
</li>
<li style="list-style: none">
<input type="checkbox"> lab10-net
</li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>0</category>
        <category>OS.xv6-labs</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-labs-2020.lab1.syscall</title>
    <url>/2021/04/10/OS/xv6-labs/lab1-syscall/</url>
    <content><![CDATA[<h1 id="lab1-syscall">lab1 syscall</h1>
<h2 id="作业链接">作业链接</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2020/labs/syscall.html</li>
</ul>
<h2 id="xv6-riscv-的系统调用">xv6-RISCV 的系统调用</h2>
<ul>
<li>首先用户态程序通过系统调用 <code>ecall</code>
进入内核态，硬件做好一些简单的环境配置，然后进入
<code>trampoline.S/uservec()</code> 程序段，接着通过
<code>syscall()</code>
函数选择具体的系统调用，接着是硬件实现或者软件实现（我们这里做的功能）具体功能。</li>
</ul>
<h2 id="实验-1-添加-trace-系统调用">实验 1: 添加 trace 系统调用</h2>
<ul>
<li>添加一个系统调用 <code>trace</code></li>
</ul>
<h3 id="配置">1. 配置</h3>
<ul>
<li>在 <code>Makefile</code> 中把 <code>$U/_trace</code> 添加到
<code>UPROGS</code> 里</li>
</ul>
<h3 id="用户态准备工作">2. 用户态准备工作</h3>
<h4 id="useruser.h">2.1 user/user.h</h4>
<ul>
<li>在 <code>user/user.h</code> 中添加函数原型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="userusys.pl">2.2 user/usys.pl</h4>
<ul>
<li>在 <code>user/usys.pl</code> 中添加入口</li>
</ul>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>usys.pl</code> 的作用是生成 <code>usys.S</code> 汇编代码</li>
<li>生成用户态的系统调用汇编代码
<ul>
<li>如下是生成的 trace 系统调用汇编代码</li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global trace</span><br><span class="line">trace:</span><br><span class="line"> li a7, SYS_trace</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>
<h4 id="kernelsyscall.h">2.3 kernel/syscall.h</h4>
<ul>
<li>在 <code>kernel/syscall.h</code> 中添加系统调用号</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br></pre></td></tr></table></figure>
<h3 id="内核代码准备工作">3. 内核代码准备工作</h3>
<h4 id="kernelsyscall.c">3.1 kernel/syscall.c</h4>
<ul>
<li>添加 <code>sys_trace()</code> 的定义和入口</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    <span class="comment">// 省略原来的入口地址</span></span><br><span class="line">    [SYS_trace]   sys_trace,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="kernelsysproc.c">3.2 kernel/sysproc.c</h4>
<ul>
<li>添加 <code>sys_trace()</code> 的具体实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里没有做具体的实现</span></span><br><span class="line">    <span class="comment">// 只是测试</span></span><br><span class="line">    <span class="comment">// 具体实现见后面</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;syscall: trace(pid: %d)\n&quot;</span>, p-&gt;pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>做到这个时候，<code>trace</code> 系统调用已经可以执行了</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ trace 32 grep hello README</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">syscall: trace(pid: 3)</span><br></pre></td></tr></table></figure>
<h3 id="内核代码功能实现">4. 内核代码功能实现</h3>
<h4 id="实现方式">4.1 实现方式</h4>
<ul>
<li>在调用 <code>trace</code> 的时候，在进程的 <code>proc</code>
结构中保存一个新的变量
<code>trace_mask</code>，从而在该进程进行系统调用的产生系统调用的输出</li>
</ul>
<h4 id="kernelproc.h">4.2 kernel/proc.h</h4>
<ul>
<li>在 <code>proc</code> 数据结构中加入新的变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加在最后面, 感觉不需要加锁</span></span><br><span class="line"><span class="type">int</span> trace_mask;</span><br></pre></td></tr></table></figure>
<h4 id="kernelsysproc.c-1">4.3 kernel/sysproc.c</h4>
<ul>
<li>记录 trace 的需要记录的系统调用掩码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="comment">// 简单在 proc 结构中记录一个参数掩码</span></span><br><span class="line">    <span class="type">int</span> trace_mask;</span><br><span class="line">    <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;trace_mask) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    p-&gt;trace_mask = trace_mask;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="kernelsyscall.c-1">4.4 kernel/syscall.c</h4>
<ul>
<li>加入一个字符数组，通过系统调用号来找到名字</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span>* syscall_names[] = &#123;</span><br><span class="line">    [SYS_fork]    <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    [SYS_trace]   <span class="string">&quot;trace&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 syscall 函数中做是否需要输出的判断</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">        p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">        <span class="comment">// 返回的时候输出 trace_mask 对应的系统调用</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; num) &amp; p-&gt;trace_mask) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,</span><br><span class="line">               p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="kernelproc.c">4.5 kernel/proc.c</h4>
<ul>
<li>fork() 后，trace 同时要跟踪子进程</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 复制 trace_mask</span></span><br><span class="line">    np-&gt;trace_mask = p-&gt;trace_mask;</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>freeproc() 函数中要把 p-&gt;trace_mask 置为 0</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;trace_mask = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="一些问题">5. 一些问题</h3>
<ul>
<li>怎么保证了初始化的结果为全 0
<ul>
<li>怎么保证 trace_mask 初始化的时候为 0</li>
</ul></li>
</ul>
<h2 id="实验-2-添加-sysinfo-系统调用">实验 2: 添加 sysinfo 系统调用</h2>
<ul>
<li>添加一个系统调用 <code>sysinfo</code></li>
</ul>
<h3 id="配置-1">1. 配置</h3>
<ul>
<li>在 <code>Makefile</code> 中把 <code>$U/_sysinfotest</code> 添加到
<code>UPROGS</code> 里</li>
</ul>
<h3 id="用户态准备工作-1">2. 用户态准备工作</h3>
<h4 id="useruser.h-1">2.1 user/user.h</h4>
<ul>
<li>在 <code>user/user.h</code> 中添加函数原型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="userusys.pl-1">2.2 user/usys.pl</h4>
<ul>
<li>在 <code>user/usys.pl</code> 中添加入口</li>
</ul>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">entry(<span class="string">&quot;sysinfo&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="kernelsyscall.h-1">2.3 kernel/syscall.h</h4>
<ul>
<li>在 <code>kernel/syscall.h</code> 中添加系统调用号</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  23</span></span><br></pre></td></tr></table></figure>
<h3 id="内核代码准备工作-1">3. 内核代码准备工作</h3>
<h4 id="kernelsyscall.c-2">3.1 kernel/syscall.c</h4>
<ul>
<li>添加 <code>sys_sysinfo()</code> 的定义和入口</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    <span class="comment">// 省略原来的入口地址</span></span><br><span class="line">    [SYS_sysinfo]   sys_sysinfo,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="kernelsysproc.c-2">3.2 kernel/sysproc.c</h4>
<ul>
<li>添加 <code>sys_sysinfo()</code> 的具体实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 具体实现见后面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内核代码功能实现-1">4. 内核代码功能实现</h3>
<h4 id="kernelsysproc.c-3">4.1 kernel/sysproc.c</h4>
<ul>
<li>主要逻辑就是下列代码注释中所讲的</li>
<li>通过调用 <code>kernel/kalloc.c</code> 中的函数 get_freemen()
得到空闲的内存大小</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysinfo.h&quot;</span></span></span><br><span class="line">uint64 <span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 需要写入 struct sysinfo 的地址</span></span><br><span class="line">    uint64 addr;</span><br><span class="line">    <span class="comment">// 获取指针</span></span><br><span class="line">    <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">    info.freemem = get_freemen();</span><br><span class="line">    info.nproc = get_nproc();</span><br><span class="line">    <span class="comment">// 复制内存内容</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="comment">// file.c</span></span><br><span class="line">    <span class="comment">// 将页表 p-&gt;pagetable 中起始地址为 &amp;info 长度为 sizeof(info) 的内存</span></span><br><span class="line">    <span class="comment">// 复制到地址 addr</span></span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span>*)(&amp;info), <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="kerneldefs.h">4.2 kernel/defs.h</h4>
<ul>
<li>加入新添加的函数定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64          <span class="title function_">get_freemen</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">uint64          <span class="title function_">get_nproc</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="kernelkalloc.c">4.2 kernel/kalloc.c</h4>
<ul>
<li>实现函数 get_freemen()，获取当前空闲内存的字节数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">get_freemen</span><span class="params">()</span> &#123;</span><br><span class="line">    uint64 num = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">    r = kmem.freelist;</span><br><span class="line">    <span class="comment">// 遍历列表, 获得空闲的 page 数目</span></span><br><span class="line">    <span class="keyword">while</span>(r)&#123;</span><br><span class="line">        ++num;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num * PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>struct kmem 记录当前进程的空闲内存信息</li>
<li>struct run 是一个链表，记录空闲的内存</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>
<h4 id="kernelproc.c-1">4.3 kernel/proc.c</h4>
<ul>
<li>实现函数 get_nproc()，获取当前状态为 <code>UNUSED</code>
的进程数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">get_nproc</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    uint num = <span class="number">0</span>;</span><br><span class="line">    uint i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; NPROC; ++i) &#123;</span><br><span class="line">        <span class="comment">// 需要加锁, 详情见 proc.h</span></span><br><span class="line">        acquire(&amp;(proc[i].lock));</span><br><span class="line">        <span class="keyword">if</span>(proc[i].state != UNUSED) &#123;</span><br><span class="line">            ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        release(&amp;(proc[i].lock));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验结果">实验结果</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make qemu-gdb</span><br><span class="line">trace 32 grep: OK (11.5s)</span><br><span class="line">== Test trace all grep ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">trace all grep: OK (1.7s)</span><br><span class="line">== Test trace nothing ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">trace nothing: OK (1.8s)</span><br><span class="line">== Test trace children ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">trace children: OK (21.7s)</span><br><span class="line">== Test sysinfotest ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">sysinfotest: OK (5.1s)</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 35/35</span><br></pre></td></tr></table></figure>
<h2 id="遇到的困难以及收获">遇到的困难以及收获</h2>
<ul>
<li>做完这个 lab 之后对系统调用的认识更加深入了</li>
<li>困难主要是在于第一次写
lab，刚开始读源代码还是有点吃力，但是读完了收获还是很大的</li>
</ul>
<h2 id="对课程或-lab-的意见和建议">对课程或 lab 的意见和建议</h2>
<ul>
<li>mit 的 lab 想到写的很清晰，循循善诱，让我们一步一步深入 xv6
的内核设计</li>
<li>希望中文版也能跟上，毕竟我们也是自己开课的</li>
</ul>
<h2 id="参考文献">参考文献</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf</li>
</ul>
]]></content>
      <categories>
        <category>OS.xv6-labs</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-labs-2020.lab0.utils</title>
    <url>/2021/03/29/OS/xv6-labs/lab0-environment-utils/</url>
    <content><![CDATA[<h1 id="lab0-环境配置及系统调用">lab0 环境配置及系统调用</h1>
<ul>
<li>环境配置：https://pdos.csail.mit.edu/6.828/2020/tools.html</li>
</ul>
<h2 id="实验环境">实验环境</h2>
<p>实验环境基于 WSL(windows linux subsystem)</p>
<ul>
<li>WSL 1.0</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 20.04.2 LTS</span><br><span class="line">Release:        20.04</span><br><span class="line">Codename:       focal</span><br></pre></td></tr></table></figure>
<h2 id="换源">换源</h2>
<ul>
<li>打开文件 "/etc/apt/sources.list"
<ul>
<li>可以备份一下原始的文件</li>
</ul></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.back</span><br><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<ul>
<li>修改文件为清华源
<ul>
<li>https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</li>
<li>根据版本选择即可</li>
</ul></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<h2 id="配置-vscode-作为编辑器">配置 VSCode 作为编辑器</h2>
<ul>
<li>安装好直接 <strong>code .</strong> 即可</li>
<li>权限问题</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/mnt/c/Users/User/.vscode/extensions/ms-vscode-remote.remote-wsl-0.54.6/scripts/wslServer.sh: Permission denied</span><br></pre></td></tr></table></figure>
<ul>
<li>修改文件 <strong>/etc/wsl.conf</strong></li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/wsl.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[automount]</span><br><span class="line">enable = false</span><br></pre></td></tr></table></figure>
<ul>
<li>修改访问权限</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/c/Users/XXX/.vscode/extensions/ms-vscode-remote.remote-wsl-0.54.6/scripts/</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x *</span><br></pre></td></tr></table></figure>
<h2 id="安装工具">安装工具</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove qemu-system-misc</span><br><span class="line">sudo apt-get install qemu-system-misc=1:4.2-3ubuntu6</span><br></pre></td></tr></table></figure>
<ul>
<li>评分需要安装 python</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2>
<ul>
<li>例如写好了 <code>sleep.c</code> 之后需要修改 makefile 文件</li>
<li>Add your <code>sleep</code> program to <code>UPROGS</code> in
Makefile</li>
</ul>
<h1 id="lab0">Lab0</h1>
<h2 id="准备工作">准备工作</h2>
<h3 id="预备知识">预备知识</h3>
<ul>
<li>pipe
<ul>
<li>管道通信</li>
<li>https://blog.csdn.net/skyroben/article/details/71513385</li>
</ul></li>
<li>linux 标准流
<ul>
<li>标准输入流：0</li>
<li>标准输出流：1</li>
<li>标准错误流：2</li>
</ul></li>
<li>命令行中括号的含义
<ul>
<li><code>[]</code>：可写可不写</li>
<li><code>&#123;&#125;</code>：那就必须要在 <code>&#123;&#125;</code>
内给出的选择里选一个</li>
<li><code>&lt;&gt;</code>：表示必选</li>
</ul></li>
</ul>
<h3 id="一些准备">一些准备</h3>
<ul>
<li>修改 makefile</li>
<li>添加程序</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    $U/_sleep\</span><br><span class="line">    $U/_pingpong\</span><br><span class="line">    $U/_primes\</span><br><span class="line">    $U/_find\</span><br><span class="line">    $U/_xargs\</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>在 user 文件夹下新建文件</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">sleep.c</span><br><span class="line">pingpong.c</span><br><span class="line">primes.c</span><br><span class="line">find.c</span><br><span class="line">xargs.c</span><br></pre></td></tr></table></figure>
<h3 id="函数封装">函数封装</h3>
<ul>
<li>在 user/user.h 中添加封装函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line"><span class="comment">// wrapped system call(printf.c)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pipe</span><span class="params">(<span class="type">int</span>*)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>在某个文件中添加实现</li>
<li>这里我们为了不修改 makefile，直接在 user/printf.c 中实现了</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/printf.c</span></span><br><span class="line"><span class="comment">// 放在这感觉不太合适, 但是这样不需要修改 makefile</span></span><br><span class="line"><span class="comment">// wrapped system call</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fork</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        unix_error(<span class="string">&quot;Fork Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pipe</span><span class="params">(<span class="type">int</span>* fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;Failed to creater a pipe!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sleep">sleep</h2>
<ul>
<li>通过系统调用 sleep 实现即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/sleep.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 输出到标准错误流</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Invalid args! Usage: sleep &lt;number&gt;!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sleepTime = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    sleep(sleepTime);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="pingpong">pingpong</h2>
<ul>
<li>实现进程间通信</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/pingpong.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 变量定义</span></span><br><span class="line">    <span class="comment">// parent to child, child to parent</span></span><br><span class="line">    <span class="comment">// 使用一个管道会引发锁的问题</span></span><br><span class="line">    <span class="type">int</span> fdP2C[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> fdC2P[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> msg[ARRAY_SIZE];</span><br><span class="line">    <span class="type">int</span> readNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start</span></span><br><span class="line">    readNumber = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个管道</span></span><br><span class="line">    <span class="comment">// 返回两个文件描述符 fd[0] 读, fd[1] 写</span></span><br><span class="line">    <span class="comment">// fd[1] 的输出是 fd[0] 的输入</span></span><br><span class="line">    Pipe(fdP2C);</span><br><span class="line">    Pipe(fdC2P);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建父子进程</span></span><br><span class="line">    id = Fork();</span><br><span class="line">    <span class="keyword">if</span>(id != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// father</span></span><br><span class="line">        close(fdP2C[<span class="number">0</span>]);</span><br><span class="line">        close(fdC2P[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// write</span></span><br><span class="line">        write(fdP2C[<span class="number">1</span>], <span class="string">&quot;ping&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// read</span></span><br><span class="line">        readNumber = read(fdC2P[<span class="number">0</span>], msg, ARRAY_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(readNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received %s\n&quot;</span>, getpid(), msg);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fdP2C[<span class="number">1</span>]);</span><br><span class="line">        close(fdC2P[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        close(fdP2C[<span class="number">1</span>]);</span><br><span class="line">        close(fdC2P[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// read</span></span><br><span class="line">        readNumber = read(fdP2C[<span class="number">0</span>], msg, ARRAY_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(readNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received %s\n&quot;</span>, getpid(), msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// write</span></span><br><span class="line">        write(fdC2P[<span class="number">1</span>], <span class="string">&quot;pong&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        close(fdP2C[<span class="number">0</span>]);</span><br><span class="line">        close(fdC2P[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// sleep(10);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思考">思考</h3>
<ul>
<li>题目的设计很巧妙，如果是子进程先传消息的话可能出现如下的问题</li>
<li>pingpong 输出如下
<ul>
<li>这个错误是子进程先写导致的</li>
<li>父进程结束了，但是子进程还在</li>
</ul></li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$ pingpong</span><br><span class="line">3: received ping</span><br><span class="line">4: $r eceived pong</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只需要等到父进程结束，shell 就可以输出
<ul>
<li>linux 代码测试</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fork()!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Father!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="primes">primes</h2>
<ul>
<li>https://swtch.com/~rsc/thread/</li>
<li>保证这样一个性质：每一个进程接收到的一个数字序列的第一个数字一定是质数</li>
<li>主要想法如下
<ul>
<li>第一个进程把数字 2-32 通过管道输出给下一个进程</li>
<li>之后每一个进程记录第一个数（记作 a），输出 a（a
是质数），将序列中的其他数字除以 a
<ul>
<li>如果能够被 a 整除，说明是合数，丢弃</li>
<li>如果能够不被 a 整除，说明可能是质数，传递给下一个进程</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recurve</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> hasForked = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> firstNumber, num;</span><br><span class="line">    <span class="type">int</span> p1[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 输出第一个数</span></span><br><span class="line">        <span class="keyword">if</span>(first == <span class="number">1</span>) &#123;</span><br><span class="line">            firstNumber = num;</span><br><span class="line">            first = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逐个检查之后的数, 若不能被记录的数整除, 传至下一进程</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(num % firstNumber != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(hasForked == <span class="number">0</span>) &#123;</span><br><span class="line">                    Pipe(p1);</span><br><span class="line">                    <span class="keyword">if</span>(Fork() != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// father</span></span><br><span class="line">                        close(p1[<span class="number">0</span>]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// child</span></span><br><span class="line">                        close(fd);</span><br><span class="line">                        close(p1[<span class="number">1</span>]);</span><br><span class="line">                        recurve(p1[<span class="number">0</span>]);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 退出, 因为之后的代码都是父进程的</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    hasForked = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 写入管道</span></span><br><span class="line">                write(p1[<span class="number">1</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hasForked == <span class="number">1</span>) &#123;</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心问题就是每次只 write/read 一个 int</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 忽略错误处理</span></span><br><span class="line">    <span class="comment">// 第一个进程输出 2-32 到管道里</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> p1[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    Pipe(p1);</span><br><span class="line">    <span class="keyword">if</span> (Fork() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// father</span></span><br><span class="line">        close(p1[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt; <span class="number">35</span>; ++i) &#123;</span><br><span class="line">            write(p1[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 等待直到子进程全被回收</span></span><br><span class="line">        <span class="keyword">while</span>(wait(&amp;status) != <span class="number">-1</span>) &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        recurve(p1[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="xargs">xargs</h2>
<ul>
<li>实现功能 xargs</li>
<li>具体功能见注释</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/xargs.c</span></span><br><span class="line"><span class="meta">#include &quot;kernel/types.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;kernel/stat.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;user/user.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;kernel/param.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFFER_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ARG_LENGTH 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// xargs: 将前一个命令的输出作为后面的输入的附加参数, 按照 &quot; &quot;(空格)分开</span></span><br><span class="line"><span class="comment">// 例如: 当前文件目录下有文件 a.txt, b.txt</span></span><br><span class="line"><span class="comment">// ls | xargs rm</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// rm a.txt b.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// echo -e : 字符转义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高级语法(未实现)</span></span><br><span class="line"><span class="comment">// TODO</span></span><br><span class="line"><span class="comment">// -n num 后面加次数, 表示命令在执行的时候一次用的参数的个数, 默认是用所有的</span></span><br><span class="line"><span class="comment">// (1)</span></span><br><span class="line"><span class="comment">// echo -e &quot;1\n2&quot; | xargs -n 1 echo line</span></span><br><span class="line"><span class="comment">// line 1</span></span><br><span class="line"><span class="comment">// line 2</span></span><br><span class="line"><span class="comment">// (2)</span></span><br><span class="line"><span class="comment">// echo -e &quot;1\n2&quot; | xargs echo line</span></span><br><span class="line"><span class="comment">// line 1 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单行读取, 每一行执行一次命令</span></span><br><span class="line"><span class="comment">// 将每一行按照空格分开, 作为参数传入</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="built_in">int</span> argc, <span class="built_in">char</span> **argv</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line">    <span class="built_in">int</span> status;</span><br><span class="line">    <span class="built_in">char</span> pass[MAXARG][MAX_ARG_LENGTH];</span><br><span class="line">    <span class="built_in">int</span> n;</span><br><span class="line">    <span class="built_in">char</span> buffer[MAX_BUFFER_SIZE + <span class="number">1</span>]; <span class="comment">// 多留一位</span></span><br><span class="line">    <span class="built_in">char</span> *start, *now, *last;</span><br><span class="line">    <span class="built_in">int</span> pos; <span class="comment">// 当前应该写入的参数位置</span></span><br><span class="line">    <span class="built_in">char</span> *passHelp[MAXARG]; <span class="comment">// 用于辅助传参</span></span><br><span class="line"></span><br><span class="line">    pos = argc - <span class="number">1</span>;</span><br><span class="line">    memset(pass, <span class="number">0</span>, <span class="keyword">sizeof</span>(pass));</span><br><span class="line">    memset(passHelp, <span class="number">0</span>, <span class="keyword">sizeof</span>(passHelp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制参数</span></span><br><span class="line">    <span class="comment">// xargs 这个参数不需要</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        strcpy(pass[i<span class="number">-1</span>], argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从标准输入流读取输出</span></span><br><span class="line">    <span class="keyword">while</span>((n = read(<span class="number">0</span>, buffer, MAX_BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        buffer[n] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//因为多保留了一位</span></span><br><span class="line">        last = buffer + n;</span><br><span class="line">        <span class="comment">// 将读取到的字符按照空格/回车分开</span></span><br><span class="line">        start = buffer;</span><br><span class="line">        <span class="keyword">for</span>(now = buffer; now &lt; last; ++now) &#123;</span><br><span class="line">            <span class="keyword">if</span>(*now == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                *now = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(pos == MAXARG) &#123;</span><br><span class="line">                    unix_error(<span class="string">&quot;To Many Args!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                strcpy(pass[pos++], start);</span><br><span class="line">                start = now + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(*now == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                *now = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(pos == MAXARG) &#123;</span><br><span class="line">                    unix_error(<span class="string">&quot;To Many Args!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                strcpy(pass[pos++], start);</span><br><span class="line">                start = now + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 每行执行一次</span></span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; pos; ++i) &#123;</span><br><span class="line">                    passHelp[i] = pass[i];</span><br><span class="line">                &#125;</span><br><span class="line">                passHelp[pos] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">                    exec(passHelp[<span class="number">0</span>], passHelp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    wait(&amp;status);</span><br><span class="line">                &#125;</span><br><span class="line">                pos = argc - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个参数</span></span><br><span class="line">        <span class="keyword">if</span>(pos == MAXARG) &#123;</span><br><span class="line">            unix_error(<span class="string">&quot;To Many Args!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        strcpy(pass[pos++], start);</span><br><span class="line">        <span class="comment">// 要求下一次复制的时候, 保留最后一个参数</span></span><br><span class="line">        <span class="comment">// 处理一个字符串被分割为两段</span></span><br><span class="line">        <span class="comment">// 事实上无法区分是两个还是一个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为我们不实现高级功能, 不需要使用 fork</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; pos; ++i) &#123;</span><br><span class="line">        passHelp[i] = pass[i];</span><br><span class="line">    &#125;</span><br><span class="line">    passHelp[pos] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        exec(passHelp[<span class="number">0</span>], passHelp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  echo 3 4 5 | xargs echo 1 2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OS.xv6-labs</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-labs-2020.lab2.pagetable</title>
    <url>/2021/05/13/OS/xv6-labs/lab2-pagetable/</url>
    <content><![CDATA[<h1 id="lab2-pagetable">lab2 pagetable</h1>
<h2 id="作业链接">1.作业链接</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html</li>
</ul>
<h2 id="实习内容">2. 实习内容</h2>
<h3 id="vmprint">2.1 vmprint()</h3>
<ul>
<li>实现一个函数
<code>vmprint(pagetable_t)</code>，实现输出页表的功能</li>
<li>输出格式如下
<ul>
<li>第一行为输入的参数</li>
<li>接着输出 <code>valid</code> 的 <code>PTE</code> 以及指向的
<code>pa</code>（物理地址）</li>
</ul></li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">page table 0x0000000087f6e000</span><br><span class="line">..0: pte 0x0000000021fda801 pa 0x0000000087f6a000</span><br><span class="line">.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000</span><br><span class="line">.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000</span><br><span class="line">.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000</span><br><span class="line">.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000</span><br><span class="line">..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000</span><br><span class="line">.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000</span><br><span class="line">.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000</span><br><span class="line">.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br></pre></td></tr></table></figure>
<h4 id="一些提示">(1) 一些提示</h4>
<ul>
<li>可以在 <code>kernel/vm.c</code> 中实现 <code>vmprint()</code></li>
<li>使用在文件 <code>kernel/riscv.h.</code> 结尾定义的宏</li>
<li>参考 <code>freewalk()</code> 的实现</li>
<li>在 <code>kernel/defs.h</code> 中声明 <code>vmprint()</code></li>
<li>使用 <code>%p</code> 输出地址</li>
</ul>
<h4 id="准备工作">(2) 准备工作</h4>
<ul>
<li>声明函数原型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"><span class="comment">// vm.c</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span>)</span>;</span><br><span class="line"><span class="comment">// 为了方便实现, 定义的辅助函数</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">vmprint_help</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>插入测试代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// kernel/exec.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pid==<span class="number">1</span>) vmprint(p-&gt;pagetable); <span class="comment">// Code Added</span></span><br><span class="line">    <span class="keyword">return</span> argc;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现">(3) 实现</h4>
<ul>
<li>在 <code>vm.c</code> 中实现代码</li>
<li>实现上比较简单，只需要逐级输出即可</li>
<li>模仿 <code>freewalk()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span>* pgtbl_level[] = &#123;</span><br><span class="line">    <span class="string">&quot;..&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.. ..&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.. .. ..&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">    vmprint_help(pagetable, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint_help</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">        <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">        <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">            <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">            uint64 child = PTE2PA(pte);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s%d: pte %p pa %p\n&quot;</span>, pgtbl_level[level], i, pte, child);</span><br><span class="line">            <span class="keyword">if</span>(level != <span class="number">2</span>) &#123;</span><br><span class="line">                vmprint_help((<span class="type">pagetable_t</span>)child, level + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="回答问题">(4) 回答问题</h4>
<blockquote>
<p>Explain the output of vmprint in terms of Fig 3-4 from the text.</p>
<p>What does page 0 contain?</p>
<p>What is in page 2?</p>
<p>When running in user mode, could the process read/write the memory
mapped by page 1?</p>
</blockquote>
<ul>
<li>xv6 的 3 级页表如下所示</li>
</ul>
<p><img src="/2021/05/13/OS/xv6-labs/lab2-pagetable/image-20210512193655832.png" style="zoom:67%;"></p>
<ul>
<li>page 0 中保存的是第 2 级页表的起始地址，以及权限位</li>
<li>page 2 中保存的是实际物理地址的页号，以及权限位</li>
<li>用户态下访问不到这里 page
1映射的地址空间，因为用户态和内核态使用的不是同一个页表，翻译得到的物理地址不同</li>
</ul>
<h3 id="a-kernel-page-table-per-process">2.2 a kernel page table per
process</h3>
<ul>
<li>xv6 实现的时候
<ul>
<li>所有的进程共享一个内核的
pagetable，是虚拟地址直接映射物理地址实现的</li>
<li>为每一个进程维护了一个 pagetable，利虚存技术实现的，虚拟地址从 0
开始</li>
<li>这样的话，进入内核之后用户态的页表就失效了，于是如果我们在内核态下想要直接访问用户态传过来的指针，必须要先进行额外的翻译操作，而不是直接去页表中翻译</li>
</ul></li>
<li>这一部分实验要求每一个进程都拥有一个自己的内核页表，这个内核页表需要和当前存在的全局内核页表一致</li>
</ul>
<h4 id="一些提示-1">(1) 一些提示</h4>
<ul>
<li>在数据结构 <code>struct proc</code>
中增加一个字段，为每一个进程保存它的内核页表</li>
<li>在调用 <code>allocproc()</code> 的时候，为每个进程分配一个内核页表
<ul>
<li>具体的实现参照 <code>kvminit()</code></li>
</ul></li>
<li>确保每个进程的内核栈都在其内核页表中有映射
<ul>
<li>之前是都保存在内核页表中，在 <code>procinit()</code> 中实现的</li>
<li>每一个进程应该只需要保存他自己的内核栈的映射即可</li>
</ul></li>
<li>当进程调度的时候，需要切换页表
<ul>
<li>参考 <code>kvminithart()</code> 的实现</li>
<li>先调用 <code>w_satp()</code>，设置第 1 级页表的基地址</li>
<li>再调用 <code>sfence_vma()</code> 清空 TLB（失效了）</li>
</ul></li>
<li>当没有其他进程运行的时候，<code>scheduler()</code> 需要使用
<code>kernel_pagetable</code></li>
<li><code>freeproc()</code> 进程释放的时候需要同时释放页表</li>
<li>当你释放页表的时候，不能够把最后对应的物理内存也释放了，因为他们是共享的
<ul>
<li>因为他们都共享原来内核的代码之类的，这些不能释放</li>
<li>内核栈也不用释放，一次分配，多次使用</li>
</ul></li>
<li>之前实现的 <code>vmprint()</code> 用于 <code>DEBUG</code></li>
<li>用于 <code>DEBUG</code>，缺页异常导致的结果
<ul>
<li>A missing page table mapping will likely cause the kernel to
encounter a page fault. It will print an error that includes
<code>sepc=0x00000000XXXXXXXX</code>. You can find out where the fault
occurred by searching for <code>XXXXXXXX</code> in
<code>kernel/kernel.asm</code>.</li>
</ul></li>
</ul>
<h4 id="实现-1">(2) 实现</h4>
<ul>
<li><code>struct proc</code> 增加一个保存内核页表的字段</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pagetable_t</span> pagetable_k;     <span class="comment">// Kernel page table</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>allocproc()</code> 分配页表</li>
<li>在对页表进行映射的时候，我们需要对当前进程的内核页表进行映射</li>
<li>通过修改 <code>kvmmap()</code> 为 <code>kvmmap_k()</code> 实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> etext[];  <span class="comment">// 在进行页表映射的时候需要用到</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 分配内核页表</span></span><br><span class="line">    p-&gt;pagetable_k = proc_pagetable_k(p);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pagetable_k == <span class="number">0</span>)&#123;</span><br><span class="line">        freeproc(p);</span><br><span class="line">        release(&amp;p-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">    <span class="type">pagetable_t</span> pagetable;</span><br><span class="line">    pagetable = uvmcreate();</span><br><span class="line">    <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    kvmmap_k(pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">    kvmmap_k(pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">    kvmmap_k(pagetable, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">    kvmmap_k(pagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">    kvmmap_k(pagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">    kvmmap_k(pagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">    kvmmap_k(pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">    <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvmmap_k</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap_k&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>映射内核栈</li>
<li>只需要为每个进程映射自己的内核栈，同时在 <code>procinit()</code>
不需要分配栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 分配内核页表</span></span><br><span class="line">    <span class="type">char</span> *pa = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(pa == <span class="number">0</span>)&#123;</span><br><span class="line">        freeproc(p);</span><br><span class="line">        release(&amp;p-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    uint64 va = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">    kvmmap_k(p-&gt;pagetable_k, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">    p-&gt;kstack = va;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">    initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">        initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line">        p-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    kvminithart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调度的时候切换内核页表</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    w_satp(MAKE_SATP(p-&gt;pagetable_k));</span><br><span class="line">    sfence_vma();</span><br><span class="line">    swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">    kvminithart();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>freeproc()</code> 的时候
<ul>
<li>首先释放栈的映射</li>
<li>释放页表，但是不能释放第 3 级页表指向的物理页</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 还得释放栈的映射(在释放整个页表之前)</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;kstack != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// dofree = 1</span></span><br><span class="line">        uvmunmap(p-&gt;pagetable_k, p-&gt;kstack, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// uint64 pa = walkaddr(p-&gt;pagetable_k, p-&gt;kstack);</span></span><br><span class="line">        <span class="comment">// kfree((void*)pa);</span></span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pagetable_k)</span><br><span class="line">        proc_freepagetable_k(p-&gt;pagetable_k);</span><br><span class="line">    p-&gt;pagetable_k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除映射, 但是不释放内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_freepagetable_k</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">    uvmunmap(pagetable, UART0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, VIRTIO0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, CLINT, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, PLIC, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, KERNBASE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, (uint64)etext, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    freewalk_k(pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freewalk_k</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">    <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">        <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">        <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">            uint64 child = PTE2PA(pte);</span><br><span class="line">            freewalk_k((<span class="type">pagetable_t</span>)child);</span><br><span class="line">            pagetable[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是允许的</span></span><br><span class="line">        <span class="comment">// &#125; else if(pte &amp; PTE_V)&#123;</span></span><br><span class="line">        <span class="comment">//   panic(&quot;freewalk: leaf&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将上面的函数加入 <code>kernel/defs.h</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">pagetable_t</span>     <span class="title function_">proc_pagetable_k</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">proc_freepagetable_k</span><span class="params">(<span class="type">pagetable_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">kvmmap_k</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">freewalk_k</span><span class="params">(<span class="type">pagetable_t</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行完之后报错</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">panic: virtio_disk_intr status</span><br></pre></td></tr></table></figure>
<ul>
<li>这是由于在 <code>kvmpa()</code> 中调用 <code>walk()</code>
的时候没有使用进程对应的内核页表导致的</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line">uint64 <span class="title function_">kvmpa</span><span class="params">(uint64 va)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pte = walk(kernel_pagetable, va, <span class="number">0</span>);</span><br><span class="line">    pte = walk(myproc()-&gt;pagetable_k, va, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一些细节">(3) 一些细节</h4>
<ul>
<li>以上的解法会导致一些其他问题，例如资源申请，发现不够了，此时应该
<code>kill</code> 掉这个进程，而不是 <code>panic</code></li>
<li>例如 <code>kvmmap_k()</code> 的设计，我们将 <code>panic</code>
修改为检查返回值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kvmmap_k</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, va, sz, pa, perm) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// panic(&quot;kvmmap_k&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">static</span> uint64 addr_kernel[] = &#123;</span><br><span class="line">    UART0,</span><br><span class="line">    VIRTIO0,</span><br><span class="line">    CLINT,</span><br><span class="line">    PLIC,</span><br><span class="line">    KERNBASE,</span><br><span class="line">    (uint64)etext,</span><br><span class="line">    TRAMPOLINE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_proc_freepagetable_k</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num; ++i) &#123;</span><br><span class="line">        uvmunmap(pagetable, addr_kernel[i], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">proc_pagetable_k</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">    <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// An empty page table.</span></span><br><span class="line">    pagetable = uvmcreate();</span><br><span class="line">    <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模仿 kvminit()</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    ret = kvmmap_k(pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) <span class="keyword">goto</span> bad;</span><br><span class="line">    ++num;</span><br><span class="line">    ret = kvmmap_k(pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) <span class="keyword">goto</span> bad;</span><br><span class="line">    ++num;</span><br><span class="line">    ret = kvmmap_k(pagetable, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) <span class="keyword">goto</span> bad;</span><br><span class="line">    ++num;</span><br><span class="line">    ret = kvmmap_k(pagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) <span class="keyword">goto</span> bad;</span><br><span class="line">    ++num;</span><br><span class="line">    ret = kvmmap_k(pagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) <span class="keyword">goto</span> bad;</span><br><span class="line">    ++num;</span><br><span class="line">    ret = kvmmap_k(pagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) <span class="keyword">goto</span> bad;</span><br><span class="line">    ++num;</span><br><span class="line">    ret = kvmmap_k(pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) <span class="keyword">goto</span> bad;</span><br><span class="line">    ++num;</span><br><span class="line">    <span class="keyword">return</span> pagetable;</span><br><span class="line"></span><br><span class="line">    bad:</span><br><span class="line">    check_proc_freepagetable_k(pagetable, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(kvmmap_k(p-&gt;pagetable_k, va, (uint64)pa, PGSIZE, PTE_R | PTE_W) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pa);</span><br><span class="line">        freeproc(p);</span><br><span class="line">        release(&amp;p-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;kstack = va;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="simplify-copyincopyinstr">2.3 Simplify copyin/copyinstr</h3>
<ul>
<li><code>copyin()</code>
函数在读取用户空间的虚拟地址的时候，需要先使用用户空间的页表，将其翻译成物理地址</li>
<li>我们在这里需要实现将每个进程用户空间保存的页表映射存到内核页表中，从而可以直接翻译访问</li>
</ul>
<h4 id="一些提示-2">(1) 一些提示</h4>
<ul>
<li>这个机制依赖于用户空间和内核空间的虚拟地址的范围没有交集
<ul>
<li>于是我们需要让用户空间的地址增长小于最小的内核虚拟地址</li>
<li>xv6 启动正常工作之后的最低地址 PLIC（0C000000）</li>
<li>需要让用户空间的地址增长小于 PLIC</li>
<li>为什么不是 CLINT 呢？CLINT 都是在 M-Mode 中映射的</li>
</ul></li>
<li>先实现 <code>copyin()</code>，在 <code>copyin()</code> 中调用
<code>copyin_new()</code>，之后再去实现
<code>copyinstr_new()</code></li>
<li>每次对用户页表进行修改的时候，同时修改内核页表
<ul>
<li><code>fork()</code>, <code>exec()</code>, <code>sbrk()</code></li>
</ul></li>
<li>不要忽略第一个用户进程，<code>usertint()</code>
中也需要将用户页表的映射加入到内核页表中</li>
<li>权限设置：A page with <code>PTE_U</code> set cannot be accessed in
kernel mode.</li>
</ul>
<h4 id="实现-2">(2) 实现</h4>
<h5 id="clint">[1] CLINT</h5>
<ul>
<li>去掉内核页表对于 <code>CLINT</code> 的映射，注释掉即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">static</span> uint64 addr_kernel[] = &#123;</span><br><span class="line">    UART0,</span><br><span class="line">    VIRTIO0,</span><br><span class="line">    <span class="comment">// CLINT,</span></span><br><span class="line">    PLIC,</span><br><span class="line">    KERNBASE,</span><br><span class="line">    (uint64)etext,</span><br><span class="line">    TRAMPOLINE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">proc_pagetable_k</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// ret = kvmmap_k(pagetable, CLINT, CLINT, 0x10000, PTE_R | PTE_W);</span></span><br><span class="line">    <span class="comment">// if(ret != 0) goto bad;</span></span><br><span class="line">    <span class="comment">// ++num;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用户虚拟地址的增长不能超过 <code>PLIC</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sz + n &gt;= PLIC) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="内核页表">[2] 内核页表</h5>
<ul>
<li>在修改用户页表的同时修改内核页表，设置权限</li>
<li>注意在释放内核页表的时候，都不能释放物理页</li>
<li>找到 <code>uvmalloc()</code> 函数修改页表的地方</li>
<li>构造一个复制函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernek/defs.h</span></span><br><span class="line"><span class="comment">// vm.c</span></span><br><span class="line">uint64          <span class="title function_">uvmalloc_k</span> <span class="params">(<span class="type">pagetable_t</span> pgold, <span class="type">pagetable_t</span> pgnew, uint64 oldsz, uint64 newsz)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line">uint64 <span class="title function_">uvmalloc_k</span> <span class="params">(<span class="type">pagetable_t</span> pgnew, <span class="type">pagetable_t</span> pgold, uint64 oldsz, uint64 newsz)</span> &#123;</span><br><span class="line">    uint64 a;</span><br><span class="line">    <span class="type">pte_t</span> *pte_old, *pte_new;</span><br><span class="line">    <span class="keyword">if</span>(newsz &lt; oldsz) <span class="keyword">return</span> oldsz;</span><br><span class="line">    oldsz = PGROUNDUP(oldsz);</span><br><span class="line">    <span class="keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line">        <span class="comment">// 不分配</span></span><br><span class="line">        pte_old = walk(pgold, a, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(pte_old == <span class="number">0</span>) panic(<span class="string">&quot;uvmalloc_k: pte should exist!&quot;</span>);</span><br><span class="line">        <span class="comment">// 分配</span></span><br><span class="line">        pte_new = walk(pgnew, a, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(pte_new == <span class="number">0</span>) panic(<span class="string">&quot;uvmalloc_k: kalloc error!&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置映射</span></span><br><span class="line">        *pte_new = (*pte_old) &amp; (~PTE_U);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="userinit">userinit()</h6>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">    p-&gt;sz = PGSIZE;</span><br><span class="line">    uvmalloc_k(p-&gt;pagetable_k, p-&gt;pagetable, <span class="number">0</span>, p-&gt;sz); <span class="comment">// Code Added</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="fork">fork()</h6>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 没有检查返回值</span></span><br><span class="line">    uvmalloc_k(np-&gt;pagetable_k, np-&gt;pagetable, <span class="number">0</span>, p-&gt;sz); <span class="comment">// Code Added</span></span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="exec">exec()</h6>
<ul>
<li>注意这里需要将原来内核页表中的映射关系解除（内核映射不需要）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/exec.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Load program into memory.</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 虚拟地址的大小</span></span><br><span class="line">        <span class="keyword">if</span>(sz1 &gt;= PLIC)</span><br><span class="line">            <span class="keyword">goto</span> bad;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 释放原来的页表(不需要释放内核原来的)</span></span><br><span class="line">    uvmunmap(p-&gt;pagetable_k, <span class="number">0</span>, PGROUNDUP(oldsz)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 全部都分配好了再复制</span></span><br><span class="line">    <span class="comment">// 没有检查返回值</span></span><br><span class="line">    uvmalloc_k(p-&gt;pagetable_k, p-&gt;pagetable, <span class="number">0</span>, sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pid==<span class="number">1</span>) vmprint(p-&gt;pagetable);</span><br><span class="line">    <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="sys_sbrk">sys_sbrk()</h6>
<ul>
<li>可能会解除映射关系，定义函数 <code>uvmdealloc_k()</code>
进行处理（不释放具体的物理页）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="comment">// 不释放物理内存</span></span><br><span class="line">uint64 <span class="title function_">uvmdealloc_k</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(newsz &gt;= oldsz)</span><br><span class="line">        <span class="keyword">return</span> oldsz;</span><br><span class="line">    <span class="keyword">if</span>(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz))&#123;</span><br><span class="line">        <span class="type">int</span> npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;</span><br><span class="line">        uvmunmap(pagetable, PGROUNDUP(newsz), npages, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 没有检查返回值</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        uvmalloc_k(p-&gt;pagetable_k, p-&gt;pagetable, addr, addr + n);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 不释放物理内存</span></span><br><span class="line">        uvmdealloc_k(p-&gt;pagetable_k, addr + n, addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试函数">[3] 测试函数</h5>
<ul>
<li>最后修改测试函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> copyin_new(pagetable, dst, srcva, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> copyinstr_new(pagetable, dst, srcva, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一些细节-1">(3) 一些细节</h4>
<ul>
<li>同样是 <code>panic</code>
的问题，在设计上我们不应该让用户的操作造成操作系统的崩溃，因此
<code>uvmalloc_k()</code> 中的 <code>panic</code> 应该处理掉</li>
<li>其中 <code>panic("uvmalloc_k: pte should exist!");</code>
是合理的，因为用于页表的映射是存在</li>
<li><code>panic("uvmalloc_k: kalloc error!");</code>
这个需要操作系统处理，而不是报错崩溃</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">uvmalloc_k</span> <span class="params">(<span class="type">pagetable_t</span> pgnew, <span class="type">pagetable_t</span> pgold, uint64 oldsz, uint64 newsz)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pte_new = walk(pgnew, a, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte_new == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// panic(&quot;uvmalloc_k: kalloc error!&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>各处检查返回值即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/exec.c</span></span><br><span class="line"><span class="comment">// 进程还在, 不需要释放内核页表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(uvmalloc_k(p-&gt;pagetable_k, p-&gt;pagetable, <span class="number">0</span>, sz) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="comment">// 内核态, 只会调用一次, 第一个进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(uvmalloc_k(p-&gt;pagetable_k, p-&gt;pagetable, <span class="number">0</span>, p-&gt;sz) == <span class="number">-1</span>)</span><br><span class="line">        panic(<span class="string">&quot;usertinit error!&quot;</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 没有检查返回值</span></span><br><span class="line">    <span class="keyword">if</span>(uvmalloc_k(np-&gt;pagetable_k, np-&gt;pagetable, <span class="number">0</span>, p-&gt;sz) == <span class="number">-1</span>) &#123;</span><br><span class="line">        freeproc(np);</span><br><span class="line">        release(&amp;np-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 没有检查返回值</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(uvmalloc_k(p-&gt;pagetable_k, p-&gt;pagetable, addr, addr + n) == <span class="number">-1</span>) &#123;</span><br><span class="line">            growproc(-n);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="回答问题-1">(4) 回答问题</h4>
<ul>
<li><code>copyin()</code> 中的 3 个测试</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(srcva &gt;= p-&gt;sz || srcva+len &gt;= p-&gt;sz || srcva+len &lt; srcva)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>前两个判断保证复制的整块内存区域是已经分配的，第三个判断保证 len
不为负</li>
<li>第三个判断是必要的，如果没有这个判断，<code>memmove()</code>
的第三个参数类型为
<code>uint</code>，会导致把大量的用户页表的内容带入内核，可能对造成内核代码修改崩溃</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">memmove</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, uint n)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="实验结果">3. 实验结果</h2>
<ul>
<li>在修改完 2.3 的 (3) 之后，有一次结果超时，后来都能通过测试</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">== Test pte printout ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">pte printout: OK (13.3s)</span><br><span class="line">== Test answers-pgtbl.txt == answers-pgtbl.txt: OK</span><br><span class="line">== Test count copyin ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">count copyin: OK (2.4s)</span><br><span class="line">    (Old xv6.out.count failure <span class="built_in">log</span> removed)</span><br><span class="line">== Test usertests ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(279.6s)</span><br><span class="line">== Test   usertests: copyin ==</span><br><span class="line">  usertests: copyin: OK</span><br><span class="line">== Test   usertests: copyinstr1 ==</span><br><span class="line">  usertests: copyinstr1: OK</span><br><span class="line">== Test   usertests: copyinstr2 ==</span><br><span class="line">  usertests: copyinstr2: OK</span><br><span class="line">== Test   usertests: copyinstr3 ==</span><br><span class="line">  usertests: copyinstr3: OK</span><br><span class="line">== Test   usertests: sbrkmuch ==</span><br><span class="line">  usertests: sbrkmuch: OK</span><br><span class="line">== Test   usertests: all tests ==</span><br><span class="line">  usertests: all tests: OK</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 66/66</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/13/OS/xv6-labs/lab2-pagetable/image-20210513193659174.png" style="zoom:80%;"></p>
<h2 id="遇到的困难以及收获">4. 遇到的困难以及收获</h2>
<ul>
<li>整体思路上不算是很难，而且提示给的很充足</li>
<li>但是由于测试需要跑的时间较长，整个 lab 也花了较多时间</li>
<li>做完这个 lab
之后对于操作系统内部的页表组织有了更深刻的理解，同时对比不同的组织方式，理解了它们之间的优劣
<ul>
<li>每个进程拥有一个页表，整个内核态拥有一个页表</li>
<li>每个进程拥有一个内核页表和用户页表</li>
</ul></li>
<li>感觉系统性的东西，能够把想法正确实现就是很棒了</li>
</ul>
<h2 id="对课程或-lab-的意见和建议">5. 对课程或 lab 的意见和建议</h2>
<ul>
<li>暂时没有意见</li>
</ul>
<h2 id="参考文献">6. 参考文献</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev1.pdf</li>
<li>https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html</li>
</ul>
]]></content>
      <categories>
        <category>OS.xv6-labs</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-labs-2020.lab3.traps</title>
    <url>/2021/05/06/OS/xv6-labs/lab3-traps/</url>
    <content><![CDATA[<h1 id="lab3-traps">lab3 traps</h1>
<h2 id="作业链接">1. 作业链接</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2020/labs/traps.html</li>
</ul>
<h2 id="实习内容">2. 实习内容</h2>
<h3 id="risc-v-汇编代码">RISC-V 汇编代码</h3>
<p>（1）函数传参使用哪些寄存器？printf() 函数调用中 13
放在那个寄存器里？</p>
<ul>
<li>函数传递参数使用寄存器：a0-a7</li>
<li>放置在 a2 寄存器里（第 3 个参数）</li>
</ul>
<p>（2）哪一部分的代码体现了对 f(), g() 的调用？</p>
<ul>
<li>f()：编译器优化的太厉害了，直接把 f(8)+1 算出来了，结果是 12</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># f(int)</span><br><span class="line"># Line 46</span><br><span class="line">26: 45b1                li  a1,12</span><br></pre></td></tr></table></figure>
<ul>
<li>g()：编译器直接把 g() 函数优化成 inline 形式的，在调用 g()
的地方，直接使用 a0 = a0 + 3 代替</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># g(int)</span><br><span class="line"># Line 32</span><br><span class="line">14: 250d                addiw   a0,a0,3</span><br></pre></td></tr></table></figure>
<p>（3）printf() 函数的地址</p>
<ul>
<li>0000000000000630</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Line 1092</span><br><span class="line">0000000000000630 &lt;printf&gt;:</span><br></pre></td></tr></table></figure>
<p>（4）在调用 printf() 之后，ra 寄存器中保存的值是多少？</p>
<ul>
<li>0x38
<ul>
<li>1536 = 0x600</li>
<li>0x630 - 0x600 + 0x8 = 0x38</li>
</ul></li>
</ul>
<p>（5）下列代码输出是什么？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>
<ul>
<li>输出为：<code>HE110 World</code>
<ul>
<li>57616 = 0xe110</li>
<li>RISC-V 是小端的，因此 i 在内存中的分布为 72 6c 64
00（低地址到高地址）,对应的字符串为 <code>rld</code></li>
</ul></li>
<li>如果 RISC-V 是大端的，为了保证输出输出不变，需要把 i 的值修改为
0x726c6400，不需要修改 57616</li>
</ul>
<p>（6）下列代码的输出是什么？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d y=%d&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>输出结果为：<code>x=3 y=5221</code>
<ul>
<li>其中 5221
为一个不确定的数字，寄存器传参的时候少传了一个参数，所以这个值我们是未知的</li>
</ul></li>
</ul>
<h3 id="backtrace">Backtrace</h3>
<ul>
<li>要求
<ul>
<li>The compiler puts in each stack frame a frame pointer that holds the
address of the caller's frame pointer. Your <code>backtrace</code>
should use these frame pointers to walk up the stack and print the saved
return address in each stack frame.</li>
</ul></li>
<li>在 sys_sleep() 中调用 backtrace()</li>
</ul>
<h4 id="kerneldefs.h">kernel/defs.h</h4>
<ul>
<li>添加函数原型，从而能够让 sleep() 调用 backtrace()</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="kernelriscv.h">kernel/riscv.h</h4>
<ul>
<li>在这里添加读取寄存器 s0 的指令</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_fp</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="kernelsysproc.c">kernel/sysproc.c</h4>
<ul>
<li>在 sys_sleep() 函数中添加对 backtrace() 的调用</li>
<li>我直接加在开头了</li>
</ul>
<h4 id="kernelprintf.c">kernel/printf.c</h4>
<ul>
<li>添加函数实现</li>
<li>注意栈帧结构
<ul>
<li>return address: a fixed offset (-8) from the frame pointer of a
stackframe</li>
<li>the saved frame pointer: fixed offset (-16) from the frame
pointer</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// backtrace</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">backtrace</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前的帧指针 frame pointer</span></span><br><span class="line">    uint64 fp = r_fp();</span><br><span class="line">    uint64 down = PGROUNDDOWN(fp);</span><br><span class="line">    uint64 up = PGROUNDUP(fp);</span><br><span class="line">    <span class="comment">// 栈向下增长, 因此循环的时候 fp 应该是越来越大</span></span><br><span class="line">    <span class="keyword">while</span>(fp &lt; up &amp;&amp; fp &gt; down) &#123;</span><br><span class="line">        printptr(*(uint64 *)(fp - <span class="number">8</span>));</span><br><span class="line">        consputc(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        fp = *(uint64 *)(fp - <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="backtrace-用途">backtrace 用途</h4>
<ul>
<li>Once your backtrace is working, call it from <code>panic</code> in
<code>kernel/printf.c</code> so that you see the kernel's backtrace when
it panics.</li>
</ul>
<h3 id="alarm">Alarm</h3>
<h4 id="问题描述">问题描述</h4>
<ul>
<li>In this exercise you'll add a feature to xv6 that periodically
alerts a process as it uses CPU time. This might be useful for
compute-bound processes that want to limit how much CPU time they chew
up, or for processes that want to compute but also want to take some
periodic action. More generally, you'll be implementing a primitive form
of user-level interrupt/fault handlers; you could use something similar
to handle page faults in the application, for example. Your solution is
correct if it passes alarmtest and usertests.</li>
<li>添加两个系统调用</li>
</ul>
<h4 id="准备工作">准备工作</h4>
<h5 id="makefile">Makefile</h5>
<ul>
<li>把 <code>$U/_alarmtest</code> 添加到 <code>UPROGS</code> 里</li>
</ul>
<h5 id="useruser.h">user/user.h</h5>
<ul>
<li>添加函数原型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> ticks, <span class="type">void</span> (*handler)())</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<h5 id="useruser.pl">user/user.pl</h5>
<ul>
<li>添加入口，辅助生成汇编代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entry(&quot;sigalarm&quot;);</span><br><span class="line">entry(&quot;sigreturn&quot;);</span><br></pre></td></tr></table></figure>
<h5 id="kernelsyscall.h">kernel/syscall.h</h5>
<ul>
<li>添加系统调用号</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigalarm  22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigreturn  23</span></span><br></pre></td></tr></table></figure>
<h5 id="kernelsyscall.c">kernel/syscall.c</h5>
<ul>
<li>添加新系统调用的定义和入口</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    [SYS_sigalarm]   sys_sigalarm,</span><br><span class="line">    [SYS_sigreturn]   sys_sigreturn,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="kernelsysproc.c-1">kernel/sysproc.c</h5>
<ul>
<li>添加具体的实现（测试）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>做到这里，程序能够编译成功了，但是具体功能还没有实现</li>
</ul>
<h4 id="test0-invoke-handler">test0: invoke handler</h4>
<ul>
<li>实现逻辑
<ul>
<li>在调用 sysalarm 的时候，在进程的数据结构中保存参数
<ul>
<li>handler、多久调用一次 handler、现在已经运行了多少个 ticks（初始化为
0）</li>
</ul></li>
<li>在收到时钟中断信号的时候，判断是否需要调用 handler，如果需要，设置
PC 为 handler</li>
</ul></li>
<li>这个是先破坏了栈帧，因此是有问题的
<ul>
<li>test1/test2 部分解决这个问题</li>
</ul></li>
</ul>
<h5 id="kernelproc.h">kernel/proc.h</h5>
<ul>
<li>添加一些中间变量辅助实现 sys_alarm() 功能</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 添加几个变量辅助实现 sysalarm()</span></span><br><span class="line">    <span class="type">int</span> ticks_for_alarm;    <span class="comment">// 多久时间调用一次 handler</span></span><br><span class="line">    <span class="type">void</span>(*)(alarm_handler); <span class="comment">// handler</span></span><br><span class="line">    <span class="type">int</span> ticks_used;         <span class="comment">// 已经使用了多少 ticks(对 ticks_for_alarm 取模)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="kernelproc.c">kernel/proc.c</h5>
<ul>
<li>对于上面那些变量的初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 最后的部分添加如下修改</span></span><br><span class="line"></span><br><span class="line">    p-&gt;ticks_for_alarm = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 理论上修改上边一个变量就够了, 但是为了安全, 全都修改了</span></span><br><span class="line">    p-&gt;alarm_handler = <span class="number">0</span>;</span><br><span class="line">    p-&gt;ticks_used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全起见也改了, 但是不该不影响结果</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    p-&gt;ticks_for_alarm = <span class="number">0</span>;</span><br><span class="line">    p-&gt;alarm_handler = <span class="number">0</span>;</span><br><span class="line">    p-&gt;ticks_used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="kernelsysproc.c-2">kernel/sysproc.c</h5>
<ul>
<li>设置 proc.h 中的变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    uint64 handler;</span><br><span class="line">    <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(argaddr(<span class="number">1</span>, &amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    p-&gt;alarm_handler = (<span class="type">void</span>(*)()) handler;</span><br><span class="line">    p-&gt;ticks_for_alarm = n;</span><br><span class="line">    p-&gt;ticks_used = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="kernelusertrap.c错误实现">kernel/usertrap.c（错误实现）</h5>
<ul>
<li>每次接受到时钟中断的时候，计数器 ticks 自增</li>
<li>在从内核态返回用户态的时候判断 ticks 记录是否超标，如果是，则调用
handler 进行处理</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ticks_for_alarm) &#123;</span><br><span class="line">            ++p-&gt;ticks_used;</span><br><span class="line">        &#125;</span><br><span class="line">        yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 原来是 w_sepc(p-&gt;trapframe-&gt;epc);</span></span><br><span class="line">    <span class="comment">// 现在加上一个判断, 将其设置为 handler 的地址</span></span><br><span class="line">    <span class="comment">// 这显然是错误的, 栈帧被破坏了, 但是 test0 是 OK 的</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ticks_for_alarm &amp;&amp; p-&gt;ticks_used == p-&gt;ticks_for_alarm) &#123;</span><br><span class="line">        p-&gt;ticks_used = <span class="number">0</span>;</span><br><span class="line">        w_sepc((uint64)p-&gt;alarm_handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>另外一种简便的实现方式
<ul>
<li>直接修改 epc</li>
<li>但是也是破坏了栈帧</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ticks_for_alarm) &#123;</span><br><span class="line">            ++p-&gt;ticks_used;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;ticks_used == p-&gt;ticks_for_alarm) &#123;</span><br><span class="line">                p-&gt;ticks_used = <span class="number">0</span>;</span><br><span class="line">                p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarm_handler;</span><br><span class="line">            &#125;</span><br><span class="line">            yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="test1-resume-interrupted-code">test1: resume interrupted
code</h4>
<ul>
<li>这一部分的实现除了 usertrap.c，其他部分都是基于 test0
进行修改的</li>
</ul>
<h5 id="kernelusertrap.c正确实现">kernel/usertrap.c（正确实现）</h5>
<ul>
<li>需要保存寄存器状态，通过 sysalarm 和 sigreturn 的配合实现</li>
<li>要求每个 hander 的最后都需要调用 sigreturn 回到内核态</li>
<li>test0 的实现回到用户态之前需要保存当时的寄存器状态，当 sigreturn
回到了内核态是恢复寄存器状态，返回用户态正常执行</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ticks_for_alarm) &#123;</span><br><span class="line">            ++p-&gt;ticks_used;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;ticks_used == p-&gt;ticks_for_alarm) &#123;</span><br><span class="line">                p-&gt;ticks_used = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 保存所有的寄存器状态</span></span><br><span class="line">                memmove(&amp;(p-&gt;trapframe2), p-&gt;trapframe, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">                p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarm_handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="kernelproc.h-1">kernel/proc.h</h5>
<ul>
<li>需要在 proc 数据结构中保存寄存器</li>
<li>这里为了方便直接使用 trapframe
的数据结构，实际上有些值是不需要保存恢复的
<ul>
<li>kernel
的相关值不用恢复：kernel_satp、kernel_sp、kernel_trap、kernel_hartid</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 保存 sysalarm 的寄存器状态, kernel 的 4 个不需要, 但是为了方便都写了</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">trapframe2</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="kernelsysproc.c-3">kernel/sysproc.c</h5>
<ul>
<li>当调用 sys_sigreturn 的时候恢复寄存器状态</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="comment">// 恢复寄存器状态(4 个 kernel 的不需要)</span></span><br><span class="line">    <span class="comment">// 如果是 sigalarm(0, 0) 的话不需要恢复现场</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ticks_for_alarm) &#123;</span><br><span class="line">        memmove(</span><br><span class="line">            ((uint64 *)p-&gt;trapframe) + <span class="number">5</span>,</span><br><span class="line">            ((uint64 *)&amp;(p-&gt;trapframe2)) + <span class="number">5</span>,</span><br><span class="line">            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe) - <span class="number">5</span>*<span class="keyword">sizeof</span>(uint64)</span><br><span class="line">        );</span><br><span class="line">        p-&gt;trapframe-&gt;epc = p-&gt;trapframe2.epc;</span><br><span class="line">        p-&gt;is_alarm = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>到这里为止，已经能够通过 test2，在不破坏栈帧的情况下实现 sysalarm
的效果</li>
</ul>
<h4 id="test2-prevent-re-entrant-calls">test2(): prevent re-entrant
calls</h4>
<ul>
<li>这一部分的实现基于 test1 进行修改的</li>
</ul>
<h5 id="实现逻辑">实现逻辑</h5>
<ul>
<li>不允许重复调用，当一个 sysalarm 已经存在的时候，没有调用 sigreturn
之前不允许调用新的 sigalarm</li>
<li>这一部分的实现很简单，在 proc 数据结构中添加一个标记变量
<ul>
<li>调用 sigalarm 的时候设置为 1
<ul>
<li>如果调用 sigalarm 的时候已经为 1，则该调用不生效</li>
</ul></li>
<li>调用 sigreturn 的时候设置为 0</li>
</ul></li>
</ul>
<h5 id="kernelproc.h-2">kernel/proc.h</h5>
<ul>
<li>添加一个标记变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> is_alarm; <span class="comment">// 是否调用 sigalarm</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="kernelproc.c-1">kernel/proc.c</h5>
<ul>
<li>标记变量的初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    p-&gt;is_alarm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全起见也改了, 但是不该不影响结果</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    p-&gt;is_alarm = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="kernelsysproc.c错误实现">kernel/sysproc.c（错误实现）</h5>
<ul>
<li>添加标记变量的判断</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;is_alarm) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(handler)&#123;</span><br><span class="line">        <span class="comment">// 注意如果调用的是 sigalarm(0, 0) 的话是不需要调用 sigreturn 的</span></span><br><span class="line">        p-&gt;is_alarm = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    p-&gt;is_alarm = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这样子实现是错误的，只能阻止新的 sigalarm
的调用，但是不能够实现已经设置的 handler 在 sigreturn
之前的再次调用</li>
<li>输出结果</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">test2 start</span><br><span class="line">.....alarm!</span><br><span class="line">alarm!</span><br><span class="line">test2 failed: alarm handler called more than once</span><br></pre></td></tr></table></figure>
<h5 id="kernelsysproc.c正确实现">kernel/sysproc.c（正确实现）</h5>
<ul>
<li>此时 is_alarm 的含义变成了是否调用 handler</li>
<li>如果有 handler 调用，禁止新的 sigalarm 调用</li>
<li>恢复当然还是在调用 sigreturn 的时候恢复</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 如果已经调用了一个 handler, 而且没有返回的话</span></span><br><span class="line">    <span class="comment">// 我们禁止这个新的调用(我们的设计不支持递归调用)</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;is_alarm) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 恢复寄存器状态(4 个 kernel 的不需要)</span></span><br><span class="line">    <span class="comment">// 只有保存了寄存器才需要恢复现场</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;is_alarm) &#123;</span><br><span class="line">        memmove(</span><br><span class="line">            ((uint64 *)p-&gt;trapframe) + <span class="number">5</span>,</span><br><span class="line">            ((uint64 *)&amp;(p-&gt;trapframe2)) + <span class="number">5</span>,</span><br><span class="line">            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe) - <span class="number">5</span>*<span class="keyword">sizeof</span>(uint64)</span><br><span class="line">        );</span><br><span class="line">        p-&gt;trapframe-&gt;epc = p-&gt;trapframe2.epc;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;is_alarm = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="kerneltrap.c">kernel/trap.c</h5>
<ul>
<li>正确实现应该是在保存寄存器的时候进行判断
<ul>
<li>因为我们只有一块区域，不能够实现递归调用</li>
<li>也能解决上面的问题</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 保存所有的寄存器状态</span></span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;is_alarm)) &#123;</span><br><span class="line">        p-&gt;is_alarm = <span class="number">1</span>;</span><br><span class="line">        memmove(&amp;(p-&gt;trapframe2), p-&gt;trapframe, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">        p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarm_handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验结果">3. 实验结果</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">== Test answers-traps.txt == answers-traps.txt: OK</span><br><span class="line">== Test backtrace <span class="built_in">test</span> ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">backtrace <span class="built_in">test</span>: OK (14.9s)</span><br><span class="line">== Test running alarmtest ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(7.0s)</span><br><span class="line">== Test   alarmtest: test0 ==</span><br><span class="line">  alarmtest: test0: OK</span><br><span class="line">== Test   alarmtest: test1 ==</span><br><span class="line">  alarmtest: test1: OK</span><br><span class="line">== Test   alarmtest: test2 ==</span><br><span class="line">  alarmtest: test2: OK</span><br><span class="line">== Test usertests ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">usertests: OK (231.3s)</span><br><span class="line">    (Old xv6.out.usertests failure <span class="built_in">log</span> removed)</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 85/85</span><br></pre></td></tr></table></figure>
<h2 id="遇到的困难以及收获">4. 遇到的困难以及收获</h2>
<ul>
<li>做完整个 lab 感觉操作系统的设计很巧妙，这里的的 sysalarm
的实际就感觉很有趣，通过两次系统调用解决了一次系统调用很难解决的问题。</li>
<li>具体的解决方法在上面都已经提到了，主要是怎么设置
PC，以及栈帧的保存与恢复问题。</li>
</ul>
<h3 id="一个小问题">一个小问题</h3>
<ul>
<li>在这个 lab 的实现中，在 <code>sigreturn()</code>
未返回时，有两种实现方案
<ul>
<li>不允许 <code>sigalarm()</code> 重新设置 <code>handler</code></li>
<li>允许 <code>sigalarm()</code> 重新设置
<code>handler</code>，但是不允许其有修改保存的寄存器（我们只有一块区域，不支持递归）</li>
</ul></li>
<li>这两种方法都可行，测试都能过</li>
<li>但似乎又都有各自的问题
<ul>
<li>第一种方法不能允许 <code>sigalarm(0, 0)</code>
的调用，这样的调用能够取消 <code>handler()</code></li>
<li>第二种方法会让最终的 <code>handler()</code> 不太可控，可能在
<code>sigreturn()</code> 未返回的时候设置了奇怪的
<code>handler()</code></li>
</ul></li>
<li>我是按照方法 1 实现的</li>
</ul>
<h3 id="sys_alarm-保存的寄存器">sys_alarm 保存的寄存器</h3>
<ul>
<li>epc（需要）</li>
<li>callee-saved（需要）（sig_return 之前可能没有 pop 栈）</li>
<li>caller-saved（不需要）</li>
<li>kernel_sp（不需要）</li>
<li>kernel_hartid（不能）</li>
<li>kernel_stap（不需要）</li>
</ul>
<h2 id="对课程或-lab-的意见和建议">5. 对课程或 lab 的意见和建议</h2>
<ul>
<li>一个建议是最后的 usertests.c
的运行时间太长了，感觉没有必要用那么多的测试，之前已按因为一行代码写反了一直超时，浪费了太多时间。</li>
</ul>
<h2 id="参考文献">6. 参考文献</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2020/reference.html</li>
<li>https://github.com/riscv/riscv-isa-manual/releases/download/draft-20200727-8088ba4/riscv-spec.pdf</li>
<li>https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf</li>
</ul>
]]></content>
      <categories>
        <category>OS.xv6-labs</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-labs-2020.lab4.lazy page allocation</title>
    <url>/2021/05/08/OS/xv6-labs/lab4-lazy-allocation/</url>
    <content><![CDATA[<h1 id="lab4-lazy-page-allocation">lab4: lazy page allocation</h1>
<h2 id="作业链接">1.作业链接</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2020/labs/cow.html</li>
</ul>
<h2 id="实习内容">2. 实习内容</h2>
<h3 id="准备工作">准备工作</h3>
<p>子进程 + 阅读给定文档的 Chapter 03/04</p>
<h3 id="p1-eliminate-allocation-from-sbrk">P1: Eliminate allocation from
sbrk()</h3>
<ul>
<li>修改系统调用 <code>sbrk()</code>，让其只增加进程的大小
<code>myproc()-&gt;sz</code>，返回未增长前的的地址，不分配新的内存空间</li>
<li>直接修改文件 <code>kernel/sysproc.c</code> 中的函数
<code>sys_sbrk()</code> 即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c:sys_sbrk()</span></span><br><span class="line">uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 注意地址要写成 uint64, 原来的代码里面写的是 int</span></span><br><span class="line">    <span class="comment">// 导致最后会有 panic(&quot;walk&quot;)</span></span><br><span class="line">    <span class="comment">// 截断导致最终 p-&gt;sz 变成负数(f开头)</span></span><br><span class="line">    uint64 addr;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    addr = myproc()-&gt;sz;</span><br><span class="line">    <span class="comment">// if(growproc(n) &lt; 0)</span></span><br><span class="line">    <span class="comment">//  return -1;</span></span><br><span class="line">    myproc()-&gt;sz = addr + n;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这样的修改势必会导致在读取地址的时候导致 page
fault，因为没有分配内存，虚拟映射失败</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> hi</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">usertrap(): unexpected scause 0x000000000000000f pid=3</span><br><span class="line">            sepc=0x00000000000012ac stval=0x0000000000004008</span><br><span class="line">panic: uvmunmap: not mapped</span><br></pre></td></tr></table></figure>
<h3 id="p2-lazy-allocation">P2: Lazy allocation</h3>
<ul>
<li>响应上面的 page fault，从而能够让程序良好运行</li>
<li>需要在 <code>usertrap()</code> 调用 <code>printf()</code>
之前加入一些代码进行 page fault 的判断</li>
<li>可能需要修改一些其它地方的代码</li>
</ul>
<h4 id="一些提示">(1) 一些提示</h4>
<ul>
<li>可以通过 <code>r_scause()</code> 为 13 或者 15
来判断当前是否触发的是 <code>pagefault</code></li>
<li><code>r_stval()</code> 返回导致异常的虚拟地址</li>
<li>仿照 <code>vm.c</code> 中的 <code>uvmalloc()</code> 代码进行分配内存
<ul>
<li>原来 <code>sbrk()</code> 通过调用 <code>growproc()</code> 间接调用到
<code>uvmalloc()</code></li>
<li>需要调用 <code>kalloc()</code> 以及 <code>mappages()</code></li>
</ul></li>
<li>使用 <code>PGROUNDDOWN(va)</code>
可以获取到当前虚拟页的最小地址</li>
<li><code>uvmunmap()</code> 会调用
<code>panic()</code>，如果是因为没有映射造成的话，我们应该不让他调用</li>
<li><code>kernel/kernel.asm</code>
中保存着汇编代码，如果发生错误可以查看这部分代码</li>
<li>如果报错 <code>incomplete type proc</code>
<ul>
<li>include "spinlock.h" then "proc.h".</li>
</ul></li>
</ul>
<h4 id="修改-usertrap">(2) 修改 usertrap()</h4>
<ul>
<li>判断异常是否为 pagefault</li>
<li>如果是则正确分配一页物理页</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c:usertrap()</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0xf</span> || scause == <span class="number">0xd</span>) &#123;</span><br><span class="line">    <span class="comment">// Page Fault Code Start</span></span><br><span class="line">    uint64 scause = r_scause();</span><br><span class="line">    <span class="comment">// 判断是否为 pagefault</span></span><br><span class="line">    <span class="comment">// 获取虚拟页位置</span></span><br><span class="line">    uint64 vm_addr = r_stval();</span><br><span class="line">    vm_addr = PGROUNDDOWN(vm_addr);</span><br><span class="line">    <span class="type">pagetable_t</span> pagetable = myproc()-&gt;pagetable;</span><br><span class="line">    <span class="type">char</span> *mem;</span><br><span class="line">    <span class="comment">// 为虚拟页分配一页物理页</span></span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="comment">// 当分配不到物理页时的处理</span></span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>) &#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刷零</span></span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, vm_addr, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">        kfree(mem);</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Page Fault Code End</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<ul>
<li>同时我们要把由于 pagefault 导致的 <code>panic()</code> 取消
<ul>
<li>注释掉如下代码</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c:uvmunmap()</span></span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: not mapped&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>由于我们现在只是实现了 lazy
的分配，还需要解决这样一个问题，如果申请了一块内存，但是尚未分配映射，此时我们不需要进行
<code>kfree()</code> 操作</li>
<li>整段代码修改如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c:uvmunmap()</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="comment">// 分配了而且映射了的内存才需要释放</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// panic(&quot;uvmunmap: walk&quot;);</span></span><br><span class="line">    <span class="comment">// if((*pte &amp; PTE_V) == 0)</span></span><br><span class="line">    <span class="comment">// panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">        panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="comment">// 分配了而且映射了的内存才需要释放</span></span><br><span class="line">    <span class="keyword">if</span>(do_free &amp;&amp; (*pte &amp; PTE_V) != <span class="number">0</span>)&#123;</span><br><span class="line">        uint64 pa = PTE2PA(*pte);</span><br><span class="line">        kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<ul>
<li>此时运行 <code>echo hi</code>，能够正确的输出 <code>hi</code></li>
</ul>
<h3 id="p3-lazytests-and-usertests">P3: Lazytests and Usertests</h3>
<ul>
<li>处理一些细节问题</li>
<li>实现 <code>sbrk()</code> 中参数为负的情况</li>
<li>如果请求的虚拟地址，比当前进程通过 <code>sbrk()</code>
申请的最高地址要高的话，<code>kill</code> 掉</li>
<li>内核态访问的的内存已申请，但是尚未分配映射
<ul>
<li>You can fix it by add code in <code>walkaddr()</code> in
<code>kernel/vm.c:104</code>, as any r/w syscall will invoke
<code>walkaddr</code> to get physical address.</li>
</ul></li>
<li>能够处理 <code>fork()</code> 中父子进程的内存复制</li>
<li><code>kalloc()</code> 失败的时候，<code>kill</code> 掉当前进程
<ul>
<li>已经实现</li>
</ul></li>
<li>解决栈溢出的问题，栈的大小只有一页，不能访问栈之外的空间</li>
</ul>
<h4 id="sbrk-参数为负">(1) sbrk() 参数为负</h4>
<ul>
<li>直接调用 <code>uvmunmap()</code> 释放即可</li>
<li>简单实现，我们可以直接调用 <code>growproc()</code> 实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c:sys_sbrk()</span></span><br><span class="line">uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    uint64 addr;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    addr = myproc()-&gt;sz;</span><br><span class="line">    <span class="comment">// if(growproc(n) &lt; 0)</span></span><br><span class="line">    <span class="comment">//  return -1;</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        myproc()-&gt;sz = addr + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="访问到未申请的空间">(2) 访问到未申请的空间</h4>
<ul>
<li>判断访问的虚拟地址是否已经申请</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c:usertrap()</span></span><br><span class="line"><span class="keyword">if</span>(vm_addr &gt;= p-&gt;sz) &#123;</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="栈溢出">(3) 栈溢出</h4>
<ul>
<li>因为栈的大小只有一页，我们可以通过
<code>myproc()-&gt;trapframe-&gt;sp</code> 获取到当前栈所在的页</li>
<li>然后使用 <code>PGROUNDDOWN</code> 以及 <code>PGROUNDUP</code>
获取到边界</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c:usertrap()</span></span><br><span class="line"><span class="comment">// 用户栈溢出</span></span><br><span class="line">uint64 ustack = p-&gt;trapframe-&gt;sp;</span><br><span class="line"><span class="keyword">if</span>(vm_addr &lt; PGROUNDDOWN(ustack)) &#123;</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fork-问题">(4) fork 问题</h4>
<ul>
<li>调用 fork
的时候，如果父进程存在一些申请了但是尚未分配映射的内存，子进程就不需要
copy 了</li>
<li>在进行 <code>uvmcopy()</code> 的时候进行修改，如果 pte
不存在，则不复制，而不是报错</li>
<li>修改如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// panic(&quot;uvmcopy: pte should exist&quot;);</span></span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// panic(&quot;uvmcopy: page not present&quot;);</span></span><br></pre></td></tr></table></figure>
<h4 id="内核态的内存操作">(5) 内核态的内存操作</h4>
<ul>
<li>如果内核态需要操作一个申请了但是尚未分配映射的空间时，需要进行处理</li>
<li>例如 <code>write()</code> 的内存尚未分配映射</li>
<li>在 <code>walkaddr()</code> 中加入判断
<ul>
<li>如果出现找不到页的情况，马上分配</li>
<li>具体的分配页的判断和 <code>usertrap()</code>
中的一样，于是我们将其封装为一个函数</li>
</ul></li>
</ul>
<h4 id="最终的修改情况">(6) 最终的修改情况</h4>
<ul>
<li><code>kernel/defs.h</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vm.c</span></span><br><span class="line">uint64          <span class="title function_">alloc_page</span><span class="params">(<span class="keyword">struct</span> proc*, uint64)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>kernel/vm.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加一个 lazy allocation 的函数</span></span><br><span class="line">uint64 <span class="title function_">alloc_page</span><span class="params">(<span class="keyword">struct</span> proc* p, uint64 vm_addr)</span>&#123;</span><br><span class="line">    <span class="comment">// 访问的虚拟地址没有申请</span></span><br><span class="line">    <span class="comment">// 虚拟地址越界</span></span><br><span class="line">    <span class="keyword">if</span>(vm_addr &gt;= p-&gt;sz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用户栈溢出</span></span><br><span class="line">    uint64 ustack = p-&gt;trapframe-&gt;sp;</span><br><span class="line">    <span class="keyword">if</span>(vm_addr &lt; (uint64)PGROUNDDOWN(ustack)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vm_addr = PGROUNDDOWN(vm_addr);</span><br><span class="line">    <span class="type">pagetable_t</span> pagetable = p-&gt;pagetable;</span><br><span class="line">    <span class="type">char</span> *mem;</span><br><span class="line">    <span class="comment">// 为虚拟页分配一页物理页</span></span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="comment">// 当分配不到物理页时的处理</span></span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刷零</span></span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, vm_addr, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">        kfree(mem);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (uint64)mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// uvmcopy()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// panic(&quot;uvmcopy: pte should exist&quot;);</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// panic(&quot;uvmcopy: page not present&quot;);</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// uvmunmap()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// panic(&quot;uvmunmap: walk&quot;);</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配了而且映射了的内存才需要释放</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// walkaddr()</span></span><br><span class="line">uint64 <span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">    <span class="comment">// if(pte == 0)</span></span><br><span class="line">    <span class="comment">//   return 0;</span></span><br><span class="line">    <span class="comment">// if((*pte &amp; PTE_V) == 0)</span></span><br><span class="line">    <span class="comment">//   return 0;</span></span><br><span class="line">    <span class="comment">// if((*pte &amp; PTE_U) == 0)</span></span><br><span class="line">    <span class="comment">//   return 0;</span></span><br><span class="line">    <span class="title function_">if</span><span class="params">(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span>)</span> &#123;</span><br><span class="line">        pa = alloc_page(myproc(), va);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pa = PTE2PA(*pte);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>kernel/sysproc.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    uint64 addr;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    p = myproc();</span><br><span class="line">    addr = p-&gt;sz;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;sz = addr + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>kernel/trap.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span> || r_scause() == <span class="number">13</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = alloc_page(p, r_stval());</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验结果">3. 实验结果</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make qemu-gdb</span><br><span class="line">(26.0s)</span><br><span class="line">== Test   lazy: map ==</span><br><span class="line">  lazy: map: OK</span><br><span class="line">== Test   lazy: unmap ==</span><br><span class="line">  lazy: unmap: OK</span><br><span class="line">== Test usertests ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">Timeout! (300.9s)</span><br><span class="line">== Test   usertests: pgbug ==</span><br><span class="line">  usertests: pgbug: OK</span><br><span class="line">== Test   usertests: sbrkbugs ==</span><br><span class="line">  usertests: sbrkbugs: OK</span><br><span class="line">== Test   usertests: argptest ==</span><br><span class="line">  usertests: argptest: OK</span><br><span class="line">== Test   usertests: sbrkmuch ==</span><br><span class="line">  usertests: sbrkmuch: OK</span><br><span class="line">== Test   usertests: sbrkfail ==</span><br><span class="line">  usertests: sbrkfail: OK</span><br><span class="line">== Test   usertests: sbrkarg ==</span><br><span class="line">  usertests: sbrkarg: OK</span><br><span class="line">== Test   usertests: stacktest ==</span><br><span class="line">  usertests: stacktest: OK</span><br><span class="line">== Test   usertests: execout ==</span><br><span class="line">  usertests: execout: OK</span><br><span class="line">== Test   usertests: copyin ==</span><br><span class="line">  usertests: copyin: OK</span><br><span class="line">== Test   usertests: copyout ==</span><br><span class="line">  usertests: copyout: OK</span><br><span class="line">== Test   usertests: copyinstr1 ==</span><br><span class="line">  usertests: copyinstr1: OK</span><br><span class="line">== Test   usertests: copyinstr2 ==</span><br><span class="line">  usertests: copyinstr2: OK</span><br><span class="line">== Test   usertests: copyinstr3 ==</span><br><span class="line">  usertests: copyinstr3: OK</span><br><span class="line">== Test   usertests: rwsbrk ==</span><br><span class="line">  usertests: rwsbrk: OK</span><br><span class="line">== Test   usertests: truncate1 ==</span><br><span class="line">  usertests: truncate1: OK</span><br><span class="line">== Test   usertests: truncate2 ==</span><br><span class="line">  usertests: truncate2: OK</span><br><span class="line">== Test   usertests: truncate3 ==</span><br><span class="line">  usertests: truncate3: OK</span><br><span class="line">== Test   usertests: reparent2 ==</span><br><span class="line">  usertests: reparent2: OK</span><br><span class="line">== Test   usertests: badarg ==</span><br><span class="line">  usertests: badarg: OK</span><br><span class="line">== Test   usertests: reparent ==</span><br><span class="line">  usertests: reparent: OK</span><br><span class="line">== Test   usertests: twochildren ==</span><br><span class="line">  usertests: twochildren: OK</span><br><span class="line">== Test   usertests: forkfork ==</span><br><span class="line">  usertests: forkfork: OK</span><br><span class="line">== Test   usertests: forkforkfork ==</span><br><span class="line">  usertests: forkforkfork: OK</span><br><span class="line">== Test   usertests: createdelete ==</span><br><span class="line">  usertests: createdelete: OK</span><br><span class="line">== Test   usertests: linkunlink ==</span><br><span class="line">  usertests: linkunlink: OK</span><br><span class="line">== Test   usertests: linktest ==</span><br><span class="line">  usertests: linktest: OK</span><br><span class="line">== Test   usertests: unlinkread ==</span><br><span class="line">  usertests: unlinkread: OK</span><br><span class="line">== Test   usertests: concreate ==</span><br><span class="line">  usertests: concreate: OK</span><br><span class="line">== Test   usertests: subdir ==</span><br><span class="line">  usertests: subdir: OK</span><br><span class="line">== Test   usertests: fourfiles ==</span><br><span class="line">  usertests: fourfiles: OK</span><br><span class="line">== Test   usertests: sharedfd ==</span><br><span class="line">  usertests: sharedfd: OK</span><br><span class="line">== Test   usertests: exectest ==</span><br><span class="line">  usertests: exectest: OK</span><br><span class="line">== Test   usertests: bigargtest ==</span><br><span class="line">  usertests: bigargtest: OK</span><br><span class="line">== Test   usertests: bigwrite ==</span><br><span class="line">  usertests: bigwrite: OK</span><br><span class="line">== Test   usertests: bsstest ==</span><br><span class="line">  usertests: bsstest: OK</span><br><span class="line">== Test   usertests: sbrkbasic ==</span><br><span class="line">  usertests: sbrkbasic: OK</span><br><span class="line">== Test   usertests: kernmem ==</span><br><span class="line">  usertests: kernmem: OK</span><br><span class="line">== Test   usertests: validatetest ==</span><br><span class="line">  usertests: validatetest: OK</span><br><span class="line">== Test   usertests: opentest ==</span><br><span class="line">  usertests: opentest: OK</span><br><span class="line">== Test   usertests: writetest ==</span><br><span class="line">  usertests: writetest: OK</span><br><span class="line">== Test   usertests: writebig ==</span><br><span class="line">  usertests: writebig: OK</span><br><span class="line">== Test   usertests: createtest ==</span><br><span class="line">  usertests: createtest: OK</span><br><span class="line">== Test   usertests: openiput ==</span><br><span class="line">  usertests: openiput: OK</span><br><span class="line">== Test   usertests: exitiput ==</span><br><span class="line">  usertests: exitiput: OK</span><br><span class="line">== Test   usertests: iput ==</span><br><span class="line">  usertests: iput: OK</span><br><span class="line">== Test   usertests: mem ==</span><br><span class="line">  usertests: mem: OK</span><br><span class="line">== Test   usertests: pipe1 ==</span><br><span class="line">  usertests: pipe1: OK</span><br><span class="line">== Test   usertests: preempt ==</span><br><span class="line">  usertests: preempt: OK</span><br><span class="line">== Test   usertests: exitwait ==</span><br><span class="line">  usertests: exitwait: OK</span><br><span class="line">== Test   usertests: rmdot ==</span><br><span class="line">  usertests: rmdot: OK</span><br><span class="line">== Test   usertests: fourteen ==</span><br><span class="line">  usertests: fourteen: OK</span><br><span class="line">== Test   usertests: bigfile ==</span><br><span class="line">  usertests: bigfile: OK</span><br><span class="line">== Test   usertests: dirfile ==</span><br><span class="line">  usertests: dirfile: OK</span><br><span class="line">== Test   usertests: iref ==</span><br><span class="line">  usertests: iref: OK</span><br><span class="line">== Test   usertests: forktest ==</span><br><span class="line">  usertests: forktest: OK</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 119/119</span><br></pre></td></tr></table></figure>
<h2 id="遇到的困难以及收获">4. 遇到的困难以及收获</h2>
<ul>
<li>在 <code>sys_sbrk()</code> 函数中的部分 <code>addr</code> 被声明成了
<code>int</code>，但是实际上应该是 <code>uint64</code>，这个 bug
改了好久，一直都在报错
<code>panic("walk")</code>，看来对原始的代码也不能都相信，还得是自己重新修改下</li>
<li>有些问题的设计还是挺巧妙的，例如在内核态下遇到了 pagefault
的处理，这个在之前都没有仔细思考过</li>
<li>在学习完这一部分的 lab
之后，对整个多级页表的立即更加深入了，对操作系统在底层内存空间实现也有了更好的理解</li>
</ul>
<h2 id="对课程或-lab-的意见和建议">5. 对课程或 lab 的意见和建议</h2>
<ul>
<li>希望中文版本能把 hint 也翻译过来（当然不是必要的）</li>
</ul>
<h2 id="参考文献">6. 参考文献</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf</li>
</ul>
]]></content>
      <categories>
        <category>OS.xv6-labs</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-labs-2020.lab6.Multi threading</title>
    <url>/2021/05/02/OS/xv6-labs/lab6-multi-threading/</url>
    <content><![CDATA[<h1 id="lab6-multi-threading">lab6 Multi-threading</h1>
<h2 id="作业链接">1.作业链接</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2020/labs/thread.html</li>
</ul>
<h2 id="实习内容">2. 实习内容</h2>
<h3 id="uthread-switching-between-threads">Uthread: switching between
threads</h3>
<ul>
<li>实现用户态的线程调度</li>
<li>这一部分主要是是实现在线程切换的时候的寄存器的保存与恢复</li>
<li>具体要做的是修改如下代码，实现上述功能
<ul>
<li><code>user/uthread.c</code> 中的 <code>thread_create()</code>
、<code>thread_schedule()</code></li>
<li><code>user/uthread_switch.S</code> 中的
<code>thread_switch</code></li>
</ul></li>
<li>具体功能
<ul>
<li>当 <code>thread_schedule()</code>
调度到一个线程，而且这个线程是第一次被调度时，这个线程应该转向
<code>thread_create()</code>，而且需要在它自己的栈上执行</li>
<li><code>thread_swtich()</code> 实现寄存器的保存与恢复
<ul>
<li>可以保存在 <code>struct thread</code> 中</li>
<li>在 <code>thread_schedule()</code> 中调用
<code>thread_switch()</code></li>
</ul></li>
</ul></li>
<li>注意这里的线程调度实现：<code>user/uthread</code>
<ul>
<li>事先准备好线程的所有线程的上下文，然后再进行调度，因此
<code>thread_schedule()</code>
只需要设置好具体执行上下文的内容，而不需要修改寄存器的值</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    a_started = b_started = c_started = <span class="number">0</span>;</span><br><span class="line">    a_n = b_n = c_n = <span class="number">0</span>;</span><br><span class="line">    thread_init();</span><br><span class="line">    <span class="comment">// 先准备好线程, 最后再开始调度</span></span><br><span class="line">    thread_create(thread_a);</span><br><span class="line">    thread_create(thread_b);</span><br><span class="line">    thread_create(thread_c);</span><br><span class="line">    thread_schedule();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="useruthread.c">(1) user/uthread.c</h4>
<ul>
<li>这一部分的实现可以参考
<code>kernel/swtch.S</code>、<code>kernel/proc.h</code></li>
</ul>
<h5 id="struct-thread">struct thread</h5>
<ul>
<li>修改数据结构 <code>struct thread</code></li>
<li>开辟一块区域，用于切换线程的时候的寄存器保存
<ul>
<li>只需要保存 <code>callee-save</code> 寄存器，因为
<code>caller-saved</code>
寄存器在调用函数之前就被保存在栈上了，而每一个线程的栈是独立的，不会修改其他线程的栈，到时候执行权回到该线程的时候，可以直接通过栈恢复
<code>caller-saved</code> 寄存器</li>
</ul></li>
<li>RISC-V 中的寄存器如下</li>
</ul>
<p><img src="/2021/05/02/OS/xv6-labs/lab6-multi-threading/image-20210410115522565.png" style="zoom: 67%;"></p>
<ul>
<li>数据结构修改如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要保存的寄存器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_frame</span> &#123;</span></span><br><span class="line">    <span class="comment">// 通过记录这些寄存器实现切换</span></span><br><span class="line">    <span class="comment">// uint64 tp; 好像不会用到这个寄存器</span></span><br><span class="line">    uint64 ra;</span><br><span class="line">    uint64 sp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// callee-saved</span></span><br><span class="line">    uint64 s0;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 需要保存的寄存器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_frame</span> <span class="title">tf</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义函数 <code>thread_switch(&amp;old, &amp;new)</code> 的作用如下
<ul>
<li>将当前的寄存器状态保存到 <code>old</code> 地址中</li>
<li>使用 <code>new</code> 地址中的寄存器代替当前的寄存器状态</li>
</ul></li>
</ul>
<h5 id="thread_schedule">thread_schedule()</h5>
<ul>
<li>添加切换线程的函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">thread_schedule</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (current_thread != next_thread) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 注意之前修改了变量指向</span></span><br><span class="line">        thread_switch((uint64)&amp;t-&gt;tf, (uint64)&amp;current_thread-&gt;tf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="thread_create">thread_create()</h5>
<ul>
<li>在新建一个线程的时候需要从数组中找一个状态为 <code>FREE</code>
的线程，将其用于调用
<ul>
<li>这里没有做新建线程时已经没有状态为 <code>FREE</code>
的情况的判断</li>
</ul></li>
<li>做完之后将返回值设置为他自己的栈结构</li>
<li>修改上面 <code>strcut threadframe</code> 中的变量
<code>ra</code>、<code>sp</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    t-&gt;tf.ra = (uint64)func;</span><br><span class="line">    <span class="comment">// 指向栈底(上往下增长)</span></span><br><span class="line">    t-&gt;tf.sp = (uint64)&amp;t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="userthread_switch.s">(2) user/thread_switch.S</h4>
<ul>
<li>根据 <code>thread_switch(&amp;old, &amp;new)</code>
的含义确定如何操作寄存器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line"># 将当前的寄存器状态保存到 a0 地址中</span><br><span class="line"># 使用 a1 地址中的寄存器代替当前的寄存器状态</span><br><span class="line">.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line">    sd ra, 0(a0)</span><br><span class="line">    sd sp, 8(a0)</span><br><span class="line">    sd s0, 16(a0)</span><br><span class="line">    /* ... */</span><br><span class="line">    sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">    ld ra, 0(a1)</span><br><span class="line">    ld sp, 8(a1)</span><br><span class="line">    ld s0, 16(a1)</span><br><span class="line">    /* ... */</span><br><span class="line">    ld s11, 104(a1)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<h3 id="using-threads">Using threads</h3>
<ul>
<li>使用 pthreads 库进行多线程编程</li>
<li>在真正的 Linux 机器上跑代码</li>
</ul>
<h4 id="问题">(1) 问题</h4>
<ul>
<li>Why are there missing keys with 2 threads, but not with 1 thread?
Identify a sequence of events with 2 threads that can lead to a key
being missing.</li>
<li>当线程1在插入一个键值对的时候，此时另外一个线程同时读取了未插入的状态开始执行，此时两个线程的插入实际上是只是插入了一个元素
<ul>
<li>具体分析看如下代码</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时线程1运行到这里,同时线程2开始执行 put() 函数</span></span><br><span class="line">    <span class="comment">// 然后在线程1执行到 insert() 之前运行到了这里</span></span><br><span class="line">    <span class="comment">// 那么线程2和线程1插入的位置是同一个, 也就是说最终只插入了一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(e)&#123;</span><br><span class="line">        e-&gt;value = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="notxv6ph.c">(2) notxv6/ph.c</h4>
<ul>
<li>使用 lock 解决，要求总时间（各线程耗时之和）不能超过原来的 1.25
倍</li>
<li>只有 <code>put()</code> 函数需要加锁</li>
<li>看完提示就 OK 了</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock;            <span class="comment">// declare a lock</span></span><br><span class="line">pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>); <span class="comment">// initialize the lock</span></span><br><span class="line">pthread_mutex_lock(&amp;lock);       <span class="comment">// acquire lock</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);     <span class="comment">// release lock</span></span><br></pre></td></tr></table></figure>
<h5 id="解法-1">解法 1</h5>
<ul>
<li>只加一个锁</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pthread_mutex_lock(&amp;lock);       <span class="comment">// acquire lock</span></span><br><span class="line">    <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(e)&#123;</span><br><span class="line">        e-&gt;value = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// the new is new.</span></span><br><span class="line">        insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;lock);     <span class="comment">// release lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>过不了测试</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">ph_safe: OK (37.1s)</span><br><span class="line">ph_fast: FAIL (76.1s)</span><br></pre></td></tr></table></figure>
<h5 id="解法2">解法2</h5>
<ul>
<li>为每一个 bucket 加一个锁</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;lock[i]);       <span class="comment">// acquire lock</span></span><br><span class="line">    <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(e)&#123;</span><br><span class="line">        e-&gt;value = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;lock[i]);     <span class="comment">// release lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">ph_safe: OK (29.2s)</span><br><span class="line">ph_fast: OK (62.3s)</span><br></pre></td></tr></table></figure>
<h3 id="barrier">Barrier</h3>
<ul>
<li>要求
<ul>
<li>实现一个
barrier（应用程序中的一个点），所有参与线程必须在该点等待，直到所有其他参与线程也都到达该点</li>
<li>Linux 条件变量实现</li>
</ul></li>
<li>需要在真正的 Linux 机器上跑代码</li>
<li>看提示
<ul>
<li><code>pthread_cond_wait</code> releases the <code>mutex</code> when
called, and re-acquires the <code>mutex</code> before returning.</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);  <span class="comment">// go to sleep on cond, releasing lock mutex, acquiring upon wake up</span></span><br><span class="line">pthread_cond_broadcast(&amp;cond);     <span class="comment">// wake up every thread sleeping on cond</span></span><br></pre></td></tr></table></figure>
<ul>
<li>实现 <code>notxv6/barrier.c</code> 中的 <code>barrier()</code>
函数即可</li>
<li>同时需要实现支持多次 barrier，每一轮将记录变量 round + 1</li>
</ul>
<h4 id="notxv6barrier.c">(1) notxv6/barrier.c</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">barrier</span><span class="params">()</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">    ++bstate.nthread;</span><br><span class="line">    <span class="keyword">if</span>(bstate.nthread != nthread) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">        <span class="comment">// 注意调用这个函数的时候会释放锁, 凡是返回到这个函数的时候会重新等待获得锁</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++bstate.round;</span><br><span class="line">        bstate.nthread = <span class="number">0</span>;</span><br><span class="line">        pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所以得释放</span></span><br><span class="line">    pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验结果">3. 实验结果</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make qemu-gdb</span><br><span class="line">uthread: OK (13.4s)</span><br><span class="line">== Test answers-thread.txt == answers-thread.txt: OK</span><br><span class="line">== Test ph_safe == make[1]: Entering directory <span class="string">&#x27;/home/banbao990/xv6-labs-2020&#x27;</span></span><br><span class="line">make[1]: <span class="string">&#x27;ph&#x27;</span> is up to <span class="built_in">date</span>.</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/banbao990/xv6-labs-2020&#x27;</span></span><br><span class="line">ph_safe: OK (27.3s)</span><br><span class="line">== Test ph_fast == make[1]: Entering directory <span class="string">&#x27;/home/banbao990/xv6-labs-2020&#x27;</span></span><br><span class="line">make[1]: <span class="string">&#x27;ph&#x27;</span> is up to <span class="built_in">date</span>.</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/banbao990/xv6-labs-2020&#x27;</span></span><br><span class="line">ph_fast: OK (63.8s)</span><br><span class="line">== Test barrier == make[1]: Entering directory <span class="string">&#x27;/home/banbao990/xv6-labs-2020&#x27;</span></span><br><span class="line">make[1]: <span class="string">&#x27;barrier&#x27;</span> is up to <span class="built_in">date</span>.</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/banbao990/xv6-labs-2020&#x27;</span></span><br><span class="line">barrier: OK (12.8s)</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 60/60</span><br></pre></td></tr></table></figure>
<h2 id="遇到的困难以及收获">4. 遇到的困难以及收获</h2>
<ul>
<li>这个 lab 相对比较简单</li>
<li>第一部分就是简单的仿造内核的 <code>swtch.S</code> 以及
<code>proc.h</code> 编写代码即可</li>
<li>后面两个部分就是使用 pthread 库进行多线程代码的编写</li>
<li>锁加的位置对整体的性能可能会有较大影响，需要仔细考虑</li>
</ul>
<h2 id="对课程或-lab-的意见和建议">5. 对课程或 lab 的意见和建议</h2>
<ul>
<li>暂时没有建议</li>
</ul>
<h2 id="参考文献">6. 参考文献</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf</li>
</ul>
]]></content>
      <categories>
        <category>OS.xv6-labs</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-labs-2020.lab5.Copy on Write</title>
    <url>/2021/05/10/OS/xv6-labs/lab5-copyonwrite/</url>
    <content><![CDATA[<h1 id="lab5-copy-on-write">lab5 Copy-on-Write</h1>
<h2 id="作业链接">1.作业链接</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2020/labs/cow.html</li>
</ul>
<h2 id="实习内容">2. 实习内容</h2>
<h3 id="说明">2.1 说明</h3>
<ul>
<li>当调用 <code>fork()</code>
的时候，父进程会把其所有的内存都复制给子进程，但是实际上子进程可能都不会去使用这些内存中的内容（例如调用
<code>exec()</code> 自己设置内容）</li>
<li>利用写时复制的技术减少无用内存空间的复制</li>
<li>写时复制（copy-on-write）技术的要求
<ul>
<li>延迟分配</li>
<li>在必要的时候才进行物理内存的复制
<ul>
<li>例如父进程写，但是子进程使用的是写之前的内容，不能共享了</li>
</ul></li>
</ul></li>
<li>COW 技术说明
<ul>
<li>当父进程调用 <code>fork()</code> 的时候，我们只是为子进程创建
pagetable，PTE 指向父进程的物理页，同时标记这段父子进程共享的内存区域为
<code>not writable</code></li>
<li>当某个进程试图去写这块区域的时候，触发
pagefault，此时开一块新的物理内存区域，把之前的内容复制过去，同时标记为
<code>writeable</code></li>
<li>对于原来的部分，如果变成独享，则可以标记为
<code>writeable</code></li>
<li>共享的区域 free 的时候，只有在最后一个进程 free 的时候才真正
free</li>
</ul></li>
</ul>
<h3 id="一些提示">2.2 一些提示</h3>
<ul>
<li>修改 <code>vm.c:uvmcopy()</code> 实现复制的时候，只是将子进程的 PTE
指向父进程的物理页，同时把父子进程的共享的 PTE 都设置为
<code>not writable</code>（清空 PTE_W 位）
<ul>
<li>注意 <code>uvmcopy()</code> 只被 <code>fork()</code> 调用</li>
</ul></li>
<li>修改 <code>trap.c:usertrap()</code> 识别出 COW 页上的
pagefault，然后调用 kalloc() 分配新的物理页，将旧的物理页复制过来，装载
PTE，设置为 <code>writable</code>（PTE_W 位设置为 1）</li>
<li>保证在 free 的时候，只有最后一个 PTE 引用 free 的时候才释放物理页
<ul>
<li>可以为每一个物理页设置一个 <code>reference count</code></li>
<li><code>kalloc()</code> 分配的时候设置为 1</li>
<li><code>fork()</code> 的时候将计数器 +1
<ul>
<li><code>uvmcopy()</code></li>
</ul></li>
<li><code>kfree()</code> 的时候将计数器 -1，若减到 0 则释放</li>
<li>计数器的实现可以用一个全局数组去记录
<ul>
<li>初始化为全1，因为有一个 <code>kfree()</code> 的调用</li>
<li>通过物理地址整除 4096 （页大小）去访问</li>
</ul></li>
</ul></li>
<li>修改 <code>copyout()</code> 去处理内核态可能发生的 cow 导致的
pagefault
<ul>
<li>处理的机制相同</li>
</ul></li>
<li>可以使用 PTE 中的保留位 RSW (reserved for software) 去记录 PTE
指向的页是不是 COW 页</li>
<li><code>kernel/riscv.h</code> 中有一些预定义的宏</li>
<li>如果 COW 触发 pagefault 时内存耗尽，应该把该进程 kill 掉</li>
</ul>
<h3 id="实习">2.3 实习</h3>
<h4 id="如何维护引用计数">(1) 如何维护引用计数</h4>
<ul>
<li>在 xv6 中，我们将 end 到 PHYSTOP
之间的区域用于动态的物理页分配，我们可以在这段区域的开头保留一段区域，将这段区域用于保存引用计数</li>
<li>如果直接保存在栈上的话，感觉太大了，可能会导致栈溢出</li>
<li>我们没有必要计算得很精确，可以直接把数组大小 CNT_INDEXS
设置为如下值</li>
</ul>
<p><span class="math display">\[
\dfrac{PHYSTOP-end}{PAGE\_SIZE}
\]</span></p>
<ul>
<li>对于每个元素的大小，因为 xv6 最多只允许 64 个进程，因此我们使用一个
char 去记录就够了</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">    <span class="type">char</span> *ref_cnt; <span class="comment">// 用于记录 reference count 的一个数组</span></span><br><span class="line">    uint64 ref_start; <span class="comment">// 开始分配的物理内存的起始地址(用于计算偏移量)</span></span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="comment">// 数组元素为 char(最多 64 进程)</span></span><br><span class="line">    <span class="comment">// sizeof(char) = 1, 不需要乘</span></span><br><span class="line">    <span class="comment">// 计算大小(偏大)</span></span><br><span class="line">    uint64 size = ((uint64) pa_end - (uint64) pa_start) &gt;&gt; PGSHIFT;</span><br><span class="line">    <span class="comment">// 初始化为全 1</span></span><br><span class="line">    <span class="comment">// memset 逐字节设置</span></span><br><span class="line">    <span class="built_in">memset</span>(pa_start, <span class="number">1</span>, size);</span><br><span class="line">    <span class="comment">// 开始分配物理内存的位置</span></span><br><span class="line">    p = (<span class="type">char</span> *)pa_start + size;</span><br><span class="line">    p = (<span class="type">char</span> *)PGROUNDUP((uint64)p);</span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    <span class="comment">// 数组起始位置设置为 pa_start</span></span><br><span class="line">    kmem.ref_cnt = (<span class="type">char</span> *)pa_start;</span><br><span class="line">    kmem.ref_start = (uint64)p;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE) &#123;</span><br><span class="line">        kfree(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将 <code>kmem.ref_cnt</code> 全部初始化为 1，因为调用
<code>kfree()</code> 的时候，我们会将引用计数 -1
<ul>
<li>这样刚好可以把所有的物理页的引用计数初始化为 0</li>
<li>但是起始并没有什么关系，我们每次分配的时候会将引用计数记为 0</li>
</ul></li>
<li>针对引用计数，我们增加一些辅助的函数
<ul>
<li>具体的函数和解释见代码</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line">uint64          <span class="title function_">get_ref_cnt_index</span><span class="params">(uint64)</span>;</span><br><span class="line"><span class="type">char</span>            <span class="title function_">ref_increment</span><span class="params">(uint64, <span class="type">char</span>)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="comment">/* 带锁 */</span></span><br><span class="line"><span class="comment">// 对引用计数进行 += inc 的操作</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">ref_increment</span><span class="params">(uint64 pa, <span class="type">char</span> inc)</span> &#123;</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="type">char</span> ans = (kmem.ref_cnt[get_ref_cnt_index(pa)] += inc);</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不带锁 */</span></span><br><span class="line"><span class="comment">// 获取引用计数</span></span><br><span class="line">uint64 <span class="title function_">get_ref_cnt_index</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">  uint64 ans = (pa - kmem.ref_start) &gt;&gt; PGSHIFT;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="kallockfree">(2) kalloc/kfree</h4>
<ul>
<li>在 <code>kalloc()</code> 分配页得时候，将引用计数置为 1</li>
<li>在 <code>kfree()</code> 释放页得时候，修改并判断引用计数是否为 0
<ul>
<li>如果为 0 则放回空的链表</li>
<li>如果不为 0 则直接返回</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(r) &#123;</span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">        <span class="comment">// 注意 get_ref_cnt_index() 函数是不加锁的, 因此需要在外面加锁</span></span><br><span class="line">        kmem.ref_cnt[get_ref_cnt_index((uint64)r)] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">char</span> num = ref_increment((uint64)pa, (<span class="type">char</span>)<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 引用计数不为 0</span></span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修改-uvmcopy">(3) 修改 uvmcopy()</h4>
<ul>
<li>复制的时候，将子进程的 PTE
指向父进程的物理地址即可，不需要重新分配</li>
<li>判断 PTE 指向的物理页是否可写
<ul>
<li>如果可写，同时修改 PTE 为 <code>not writable</code>，并设置 PTE 的
PTE_COW 位（RSW 的低位，第 8 位）</li>
<li>如果不可写，则不需要设置 PTE_COW / PTE_W 位</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/riscv.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 8) <span class="comment">// COW</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span> &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa, i;</span><br><span class="line">    uint64 flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">        <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">        pa = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 之前的 PTE_W, PTE_COW</span></span><br><span class="line">        uint64 pte_w_cow_before = *pte &amp; (PTE_W|PTE_COW);</span><br><span class="line">        <span class="comment">// 对于可以进行写操作的 PTE, 我们才使用 COW 策略</span></span><br><span class="line">        <span class="comment">// 如果这个页不可写, 我们直接不复制即可</span></span><br><span class="line">        <span class="keyword">if</span>(*pte &amp; PTE_W) &#123;</span><br><span class="line">            *pte ^= PTE_W; <span class="comment">// *pte &amp;= ~PTE</span></span><br><span class="line">            *pte |= PTE_COW;</span><br><span class="line">        &#125;</span><br><span class="line">        flags = PTE_FLAGS(*pte);</span><br><span class="line">        <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// kfree(mem);</span></span><br><span class="line">            <span class="comment">// 恢复原来的 flags</span></span><br><span class="line">            *pte &amp;= ~(PTE_COW | PTE_W);</span><br><span class="line">            *pte |= pte_w_cow_before;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 引用计数 +1</span></span><br><span class="line">        ref_increment(pa, (<span class="type">char</span>)<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="识别-pagefault">(4) 识别 pagefault</h4>
<ul>
<li>类似于 lazy allocation，我们需要在 <code>usertrap()</code> 中识别
COW 导致的 pagefault</li>
<li>为了方便，我们封装成一个函数 <code>cow_handler()</code>
<ul>
<li>判断是否是由于 COW 导致的 pagefault</li>
<li>处理引用计数</li>
<li>重新分配物理内存</li>
<li>在重新分配内存的时候，我们需要进行的操作是直接修改返回的 PTE
<ul>
<li>因为这 3 级页表的映射关系还是存在的，我们只需要将第 3 级页表中存储的
PTE 直接修改为 <code>PPN|flags</code></li>
<li>其中 PPN 是新分配的物理地址</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"><span class="comment">// vm.c</span></span><br><span class="line">uint64          <span class="title function_">cow_handler</span><span class="params">(<span class="type">pagetable_t</span>, uint64)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/traps.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">0xf</span> || r_scause() == <span class="number">0xd</span>) &#123;</span><br><span class="line">        <span class="comment">// page fault</span></span><br><span class="line">        <span class="comment">// 获取虚拟页位置</span></span><br><span class="line">        uint64 va = r_stval();</span><br><span class="line">        <span class="keyword">if</span>(cow_handler(p-&gt;pagetable, va) == <span class="number">0</span>) &#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="comment">/* va 需要对齐 */</span></span><br><span class="line">uint64 <span class="title function_">cow_handler</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 不是 COW 页</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_COW) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有内存了</span></span><br><span class="line">    <span class="type">char</span> *mem;</span><br><span class="line">    <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">    uint64 flags = PTE_FLAGS(*pte);</span><br><span class="line">    kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    flags = (flags &amp; ~PTE_COW) | PTE_W;</span><br><span class="line">    *pte = PA2PTE((uint64)mem) | flags;</span><br><span class="line">    <span class="keyword">return</span> (uint64)mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="识别内核态的-cow-导致的-pagefault">(5) 识别内核态的 cow 导致的
pagefault</h4>
<ul>
<li>这会发生在函数 <code>copyout()</code>
中，于是我们采用相同的策略，这里需要先判断是否是</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span> &#123;</span><br><span class="line">    uint64 n, va0, pa0;</span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        va0 = PGROUNDDOWN(dstva);</span><br><span class="line">        <span class="keyword">if</span> (va0 &gt;= MAXVA)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 先判断是不是 COW 页</span></span><br><span class="line">        <span class="type">pte_t</span>* pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 不是 COW 页</span></span><br><span class="line">        <span class="keyword">if</span>((*pte &amp; PTE_COW) == <span class="number">0</span>) &#123;</span><br><span class="line">            pa0 = walkaddr(pagetable, va0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pa0 = cow_handler(pagetable, va0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验结果">3. 实验结果</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make qemu-gdb</span><br><span class="line">(24.2s)</span><br><span class="line">== Test   simple ==</span><br><span class="line">  simple: OK</span><br><span class="line">== Test   three ==</span><br><span class="line">  three: OK</span><br><span class="line">== Test   file ==</span><br><span class="line">  file: OK</span><br><span class="line">== Test usertests ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(211.7s)</span><br><span class="line">== Test   usertests: copyin ==</span><br><span class="line">  usertests: copyin: OK</span><br><span class="line">== Test   usertests: copyout ==</span><br><span class="line">  usertests: copyout: OK</span><br><span class="line">== Test   usertests: all tests ==</span><br><span class="line">  usertests: all tests: OK</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 110/110</span><br></pre></td></tr></table></figure>
<h2 id="遇到的困难以及收获">4. 遇到的困难以及收获</h2>
<ul>
<li>这个 lab
想起来难度并不是很大，思路在网页中也写得很清楚，但是很多细节还是很花费时间的</li>
<li>做完 lab 之后对于 cow 整体的实现也有了更加深入的理解</li>
<li>同时对一些细节的处理也让我收获颇丰，例如这里关于 PTE
的处理，直接修改 PTE 的内容而不是重新映射，这样的设计确实很巧妙</li>
<li>同时通过 lazy allocation 和 cow 这两个
lab，也让我们意识到了，在设计的过程中要同时考虑用户态的内核态的异常
<ul>
<li>例如 pagefault
<ul>
<li>用户态的 pagefault 可以在 <code>usertrap()</code>
中考虑（产生后利用异常机制处理）</li>
<li>内核态的 pagefault 需要在 <code>copyout()</code>
中考虑（产生的地方）</li>
</ul></li>
</ul></li>
</ul>
<h2 id="对课程或-lab-的意见和建议">5. 对课程或 lab 的意见和建议</h2>
<ul>
<li>暂时没有意见</li>
</ul>
<h2 id="参考文献">6. 参考文献</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf</li>
<li>https://pdos.csail.mit.edu/6.828/2020/labs/cow.html</li>
</ul>
]]></content>
      <categories>
        <category>OS.xv6-labs</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-labs-2020.lab8.file system</title>
    <url>/2021/06/09/OS/xv6-labs/lab8-file-system/</url>
    <content><![CDATA[<h1 id="lab8-file-system">lab8 file system</h1>
<h2 id="作业链接">1. 作业链接</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2020/labs/fs.html</li>
</ul>
<h2 id="实习内容">2. 实习内容</h2>
<h3 id="large-files">2.1 Large files</h3>
<h4 id="目标与描述">(1) 目标与描述</h4>
<ul>
<li>xv6 的一个文件有 13 个数据项，前 12 个数据项直接索引到数据块，第 13
个数据项通过一级索引索引到数据块（先找到索引表，通过索引表找到数据块地址）
<ul>
<li>一个数据项大小为 <span class="math inline">\(4\)</span>
字节，一个块的大小为 <span class="math inline">\(1024\)</span>
字节，因此一个块中最多可以放 <span class="math inline">\(\dfrac{1024}{4}=256\)</span> 个数据项</li>
<li>因此支持的的文件最大为 <span class="math inline">\(12+256=268\)</span> 块</li>
</ul></li>
<li>我们的目标是让 xv6 支持更大的文件，我们增加一个二级索引
<ul>
<li>前 11 个数据项直接索引，第 12 个数据项一级索引，第 13
个数据项二级索引</li>
<li>这样支持的最大文件为 <span class="math inline">\(11+256+256\times256=65803\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/06/09/OS/xv6-labs/lab8-file-system/001.png" style="zoom:67%;"></p>
<ul>
<li>注意文件系统的每次修改代码都需要 <code>make clean</code>，否则
<code>fs.img</code> 中文件系统会出问题
<ul>
<li>或者删除文件 <code>fs.img</code></li>
</ul></li>
</ul>
<h4 id="提示">(2) 提示</h4>
<ul>
<li><code>fs.c</code> 中的<code>bmap()</code> 函数建立起对数据块的索引
<ul>
<li>读操作如果没找到数据块，则报错返回</li>
<li>写操作如果没找到，则需要分配一块</li>
</ul></li>
<li>bmap() 中的参数 <code>bn</code> 是逻辑序号（文件内从 0
开始标的序号）</li>
</ul>
<h4 id="实现">(3) 实现</h4>
<h5 id="修改宏">[1] 修改宏</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX_NUM_1 (BSIZE/sizeof(uint))      <span class="comment">// 一级索引表数据个数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX_NUM_2 (INDEX_NUM_1*INDEX_NUM_1) <span class="comment">// 二级索引表数据个数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX_ENTRY_1 NDIRECT                 <span class="comment">// 一级索引表位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX_ENTRY_2 (NDIRECT+1)             <span class="comment">// 二级索引表位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (INDEX_NUM_1 + INDEX_NUM_2) <span class="comment">// 不能删除!!!!有其他地方引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT) <span class="comment">// 最大文件个数</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意所有的原来相关引用必须正确
<ul>
<li>NINDIRECT
<ul>
<li>mkfs/mkfs.c：iappend() 正确</li>
</ul></li>
<li>NDIRECT</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/file.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uint addrs[NDIRECT+<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uint addrs[NDIRECT+<span class="number">2</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="二级索引表">[2] 二级索引表</h5>
<ul>
<li>以下的代码修改都是 <code>kernel/fs.c</code></li>
<li>可以 <code>ctrl-f</code>
找找需要修改的地方（<code>addr</code>）</li>
<li>修改 bmap()，建立起新的映射关系
<ul>
<li>判断如果是二级索引的话，需要先读入二级索引表，再读入一级索引表，最后读入数据块地址</li>
<li>最后需要释放二级索引表</li>
</ul></li>
<li>注意修改了内容就需要调用 log_write() 写到磁盘（write through）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> uint <span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span> &#123;</span><br><span class="line">    uint addr, *a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前 11 块直接索引</span></span><br><span class="line">    <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">        <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">            ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line">    bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一级索引</span></span><br><span class="line">    <span class="keyword">if</span>(bn &lt; INDEX_NUM_1)&#123;</span><br><span class="line">        <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">        <span class="keyword">if</span>((addr = ip-&gt;addrs[INDEX_ENTRY_1]) == <span class="number">0</span>)</span><br><span class="line">            ip-&gt;addrs[INDEX_ENTRY_1] = addr = balloc(ip-&gt;dev);</span><br><span class="line">        bp = bread(ip-&gt;dev, addr);</span><br><span class="line">        a = (uint*)bp-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">            a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">            log_write(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(bp);</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line">    bn -= INDEX_NUM_1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二级索引</span></span><br><span class="line">    <span class="keyword">if</span>(bn &lt; INDEX_NUM_2) &#123;</span><br><span class="line">        uint addr2, *a2, index;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">bp2</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载二级索引, 如果必要的话则为其分配空间</span></span><br><span class="line">        <span class="keyword">if</span>((addr2 = ip-&gt;addrs[INDEX_ENTRY_2]) == <span class="number">0</span>)</span><br><span class="line">            ip-&gt;addrs[INDEX_ENTRY_2] = addr2 = balloc(ip-&gt;dev);</span><br><span class="line"></span><br><span class="line">        bp2 = bread(ip-&gt;dev, addr2);</span><br><span class="line">        a2 = (uint*)bp2-&gt;data;</span><br><span class="line">        <span class="comment">// 计算出第几个索引项</span></span><br><span class="line">        index = bn / INDEX_NUM_1;</span><br><span class="line">        bn %= INDEX_NUM_1;</span><br><span class="line">        <span class="comment">// 加载一级索引</span></span><br><span class="line">        <span class="keyword">if</span>((addr = a2[index]) == <span class="number">0</span>) &#123;</span><br><span class="line">            a2[index] = addr = balloc(ip-&gt;dev);</span><br><span class="line">            log_write(bp2);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(bp2);</span><br><span class="line"></span><br><span class="line">        bp = bread(ip-&gt;dev, addr);</span><br><span class="line">        a = (uint*)bp-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">            a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">            log_write(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(bp);</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>itrunc() 丢弃 inode 的时候需要回收所有的数据块</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">    uint *a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接映射的数据块</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">            bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">            ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一级索引</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[INDEX_ENTRY_1])&#123;</span><br><span class="line">        bp = bread(ip-&gt;dev, ip-&gt;addrs[INDEX_ENTRY_1]);</span><br><span class="line">        a = (uint*)bp-&gt;data;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; INDEX_NUM_1; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j])</span><br><span class="line">                bfree(ip-&gt;dev, a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(bp);</span><br><span class="line">        bfree(ip-&gt;dev, ip-&gt;addrs[INDEX_ENTRY_1]);</span><br><span class="line">        ip-&gt;addrs[INDEX_ENTRY_1] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二级索引</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[INDEX_ENTRY_2]) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">bp2</span>;</span></span><br><span class="line">        uint* a2;</span><br><span class="line">        bp2 = bread(ip-&gt;dev, ip-&gt;addrs[INDEX_ENTRY_2]);</span><br><span class="line">        a2 = (uint*)bp2-&gt;data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐个查看一级索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; INDEX_NUM_1; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a2[k]) &#123;</span><br><span class="line">                bp = bread(ip-&gt;dev, a2[k]);</span><br><span class="line">                a = (uint*)bp-&gt;data;</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; INDEX_NUM_1; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[j])</span><br><span class="line">                        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                brelse(bp);</span><br><span class="line">                bfree(ip-&gt;dev, a2[k]);</span><br><span class="line">                <span class="comment">// a2[k] = 0; 有 bfree()</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收二级索引表</span></span><br><span class="line">        brelse(bp2);</span><br><span class="line">        bfree(ip-&gt;dev, ip-&gt;addrs[INDEX_ENTRY_2]);</span><br><span class="line">        ip-&gt;addrs[INDEX_ENTRY_2] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">    iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="symbolic-links">2.2 Symbolic links</h3>
<h4 id="目标与描述-1">(1) 目标与描述</h4>
<ul>
<li>实现软链接</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">symlink</span><span class="params">(<span class="type">char</span> *target, <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>软链接可以跨盘，硬链接不能跨盘</li>
</ul>
<h4 id="提示-1">(2) 提示</h4>
<ul>
<li>一部分提示（准备工作）放在实现中</li>
<li><code>symlink(target, path)</code> 的 target 不存在也能成功
<ul>
<li>你需要有一个地方保存 target 位置，可以保存在 inode 的数据块中</li>
<li>需要有返回值，0 成功，-1 失败（和 link/unlink 一致）</li>
</ul></li>
<li>修改系统调用 open() 实现对软链接文件的处理
<ul>
<li>如果文件不存在，则 open 失败</li>
<li>如果文件打开的 flag 中有
<code>O_NOFOLLOW</code>，则<strong>不需要</strong>打开软链接对应的文件</li>
</ul></li>
<li>如果软链接文件对应的文件还是软链接文件，需要递归打开，直至找到一个不是软链接的文件
<ul>
<li>如果成环，则需要报错（简单使用一个递归深度阈值判断即可，10）</li>
</ul></li>
<li>其他系统调用（例如链接和取消链接）不需要打开到软链接最终链接的文件，只需要打开软链接文件本身即可</li>
<li>不需要处理软链接指向文件夹的情况
<ul>
<li>不允许指向文件夹</li>
</ul></li>
</ul>
<h4 id="实现-1">(3) 实现</h4>
<h5 id="添加一个新的系统调用-symlink">[1] 添加一个新的系统调用
symlink</h5>
<ul>
<li><code>Makefile</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(LAB)</span>,fs)</span><br><span class="line">UPROGS += \</span><br><span class="line">    $U/_bigfile\</span><br><span class="line">    $U/_symlinktest</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>user/usys.pl</code></li>
</ul>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">entry(<span class="string">&quot;symlink&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>user/user.h</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span>*)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>kernel/sysfile.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_symlink</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>kernel/syscall.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    [SYS_symlink] sys_symlink,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>kernel/syscall.h</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_symlink 22</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>kernel/stat.h</code> 中添加文件类型，表示软链接（symbolic
link）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_SYMLINK 4</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>kernel/fcntl.h</code> 添加新的 flag，用于 open
系统调用，注意文件打开的 flag 是是使用 or 进行组合的，因此不能和已有的
flag 重合</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> O_NOFOLLOW 0x004</span></span><br></pre></td></tr></table></figure>
<h5 id="sys_symlink-具体实现">[2] sys_symlink() 具体实现</h5>
<ul>
<li>注意一些小问题即可
<ul>
<li>symlink 的 path 是可以存在的，测试数据中那个有这样的内容
<ul>
<li>这个人感觉很不合理</li>
<li>没有做一些其他的处理，例如释放原来的文件数据块（感觉应该是要做，但是在这个lab中没有实现）</li>
</ul></li>
<li>namei() 返回 ip 不为 0 的情况下，ip 是不带锁，但是引用计数+1
<ul>
<li>因此需要注意 iput() 的调用</li>
</ul></li>
<li>将 target 保存在 data 段的开始</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仿照 sys_link 实现即可</span></span><br><span class="line"><span class="comment">// 效果是将 old 指向 new</span></span><br><span class="line">uint64 <span class="title function_">sys_symlink</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[DIRSIZ], target[MAXPATH], path[MAXPATH];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dp</span>, *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    begin_op();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// target 可以不存在</span></span><br><span class="line">    <span class="comment">// if((ip = namei(path)) == 0)&#123;</span></span><br><span class="line">    <span class="comment">//   end_op();</span></span><br><span class="line">    <span class="comment">//   return -1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// target 的引用计数增加</span></span><br><span class="line">    <span class="keyword">if</span>((ip = namei(target)) != <span class="number">0</span>) &#123;</span><br><span class="line">        ilock(ip);</span><br><span class="line">        <span class="comment">// 不能是文件夹</span></span><br><span class="line">        <span class="comment">// 测试数据中没有文件夹的数据</span></span><br><span class="line">        <span class="keyword">if</span>(ip-&gt;type == T_DIR) &#123;</span><br><span class="line">            iunlockput(ip);</span><br><span class="line">            end_op();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ip-&gt;nlink++;</span><br><span class="line">        iupdate(ip);</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// link 的实现是 new 文件不存在, 因此直接使用 dirlink 即可</span></span><br><span class="line">    <span class="comment">// 在测试数据中, symlink 的 path 文件可以存在, 因此方法不太一样</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先检查 path 节点是否存在, 不存在则新建一个</span></span><br><span class="line">    <span class="keyword">if</span>((dp = namei(path)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// path 的父节点得存在</span></span><br><span class="line">        <span class="keyword">if</span>((dp = nameiparent(path, name)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            iput(dp);</span><br><span class="line">            <span class="comment">// 新建一个 path 节点</span></span><br><span class="line">            <span class="comment">// 返回的 dp 带锁且引用计数 +1</span></span><br><span class="line">            <span class="keyword">if</span>((dp = create(path, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad;</span><br><span class="line">            &#125;</span><br><span class="line">            iunlock(dp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ilock(dp);</span><br><span class="line">    <span class="comment">// 把 target 写入 dp 的 data 字段中</span></span><br><span class="line">    writei(dp, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, MAXPATH);</span><br><span class="line">    <span class="comment">// 设置 dp 类型</span></span><br><span class="line">    <span class="comment">// dp-&gt;type = T_SYMLINK;(已经设置了)</span></span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    <span class="comment">// iput(ip); 之前调用 iunlockput() 了</span></span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bad:</span><br><span class="line">    ilock(ip);</span><br><span class="line">    ip-&gt;nlink--;</span><br><span class="line">    iupdate(ip);</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="sys_open-的实现">[3] sys_open() 的实现</h5>
<ul>
<li>在打开文件的时候进行一个判断，如果是软链接同时没有
<code>O_NOFOLLOW</code> flag 的话，就打开软链接对应的文件即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if((ip = namei(path)) == 0)&#123;</span></span><br><span class="line">    <span class="comment">//   end_op();</span></span><br><span class="line">    <span class="comment">//   return -1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">if</span>((ip = namei_check_symlink(path , <span class="number">0</span>, omode)) == <span class="number">0</span>) &#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>namei_check_symlink() 如下
<ul>
<li>显式的递归深度检测</li>
<li>注意细节 iput()，因为切换到下一个文件，因此将引用计数-1</li>
<li>读取 target 的时候，注意是在 data 段的开头</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回如果不为 0, 计数 +1</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode* <span class="title function_">namei_check_symlink</span><span class="params">(<span class="type">char</span> *path, uint depth, <span class="type">int</span> omode)</span> &#123;</span><br><span class="line">    <span class="comment">// 利用一个显式的递归深度检测环</span></span><br><span class="line">    <span class="keyword">if</span>(depth &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">    <span class="comment">// 文件不存在(symlink 允许 target 不存在)</span></span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="comment">// 如果带有 O_NOFOLLOW flag, 则只需要打开软链接文件本身</span></span><br><span class="line">    <span class="keyword">if</span>(!(omode &amp; O_NOFOLLOW) &amp;&amp; ip-&gt;type == T_SYMLINK) &#123;</span><br><span class="line">        <span class="type">char</span> next[MAXPATH];</span><br><span class="line">        <span class="comment">// 保存在 data 的开始</span></span><br><span class="line">        <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)next, <span class="number">0</span>, MAXPATH) == <span class="number">0</span>) &#123;</span><br><span class="line">            iunlock(ip);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iunlock(ip);</span><br><span class="line">        iput(ip); <span class="comment">// 接着下一个文件了, 因此当前文件的引用计数-1</span></span><br><span class="line">        <span class="keyword">return</span> namei_check_symlink(next, depth + <span class="number">1</span> ,omode);</span><br><span class="line">    &#125;</span><br><span class="line">    iunlock(ip);</span><br><span class="line">    <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验结果">3. 实验结果</h2>
<ul>
<li>bigfile 和 usertests 不能在规定时间内完成任务（电脑性能问题）</li>
<li>修改了 timeout</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@test(<span class="params"><span class="number">40</span>, <span class="string">&quot;running bigfile&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_bigfile</span>():</span><br><span class="line">    r.run_qemu(shell_script([</span><br><span class="line">        <span class="string">&#x27;bigfile&#x27;</span></span><br><span class="line">    ]), timeout=<span class="number">500</span>) <span class="comment"># 原来是 360, 最终耗时 381</span></span><br><span class="line">    r.<span class="keyword">match</span>(<span class="string">&#x27;^wrote 65803 blocks$&#x27;</span>)</span><br><span class="line">    r.<span class="keyword">match</span>(<span class="string">&#x27;^bigfile done; ok$&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@test(<span class="params"><span class="number">19</span>, <span class="string">&quot;usertests&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_usertests</span>():</span><br><span class="line">    r.run_qemu(shell_script([</span><br><span class="line">        <span class="string">&#x27;usertests&#x27;</span></span><br><span class="line">    ]), timeout=<span class="number">1000</span>) <span class="comment"># 原来是 360, 最终耗时 566.5</span></span><br><span class="line">    r.<span class="keyword">match</span>(<span class="string">&#x27;^ALL TESTS PASSED$&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make qemu-gdb</span><br><span class="line">running bigfile: OK (381.0s)</span><br><span class="line">    (Old xv6.out.bigfile failure <span class="built_in">log</span> removed)</span><br><span class="line">== Test running symlinktest ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(3.0s)</span><br><span class="line">== Test   symlinktest: symlinks ==</span><br><span class="line">  symlinktest: symlinks: OK</span><br><span class="line">== Test   symlinktest: concurrent symlinks ==</span><br><span class="line">  symlinktest: concurrent symlinks: OK</span><br><span class="line">== Test usertests ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">  usertests: OK (566.5s)</span><br><span class="line">    (Old xv6.out.usertests failure <span class="built_in">log</span> removed)</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 100/100</span><br></pre></td></tr></table></figure>
<h2 id="遇到的困难以及收获">4. 遇到的困难以及收获</h2>
<ul>
<li>第一部分修改宏的时候，没有把所有引用宏的地方都对应上，因此报了奇怪的错误</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">panic : virtio_disk_intr status</span><br></pre></td></tr></table></figure>
<ul>
<li>以后得注意，在修改已有代码段的时候，需要注意所有引用在修改后还是正确的</li>
<li>文件系统的设计确实很巧妙，函数之间的相互调用需要符合一定的规范
<ul>
<li>例如引用计数以及锁的设计，感觉都得好好思考才能做出答案</li>
</ul></li>
<li>感觉 symlink 的 path 可以存在这个设定确实不太合理</li>
</ul>
<h2 id="对课程或-lab-的意见和建议">5. 对课程或 lab 的意见和建议</h2>
<ul>
<li>建议提供一些关于 lab 的 debug 功能的指导</li>
</ul>
<h2 id="参考文献">6. 参考文献</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev1.pdf</li>
</ul>
]]></content>
      <categories>
        <category>OS.xv6-labs</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-labs-2020.lab7.lock</title>
    <url>/2021/06/03/OS/xv6-labs/lab7-lock/</url>
    <content><![CDATA[<h1 id="lab7-lock">lab7 lock</h1>
<h2 id="作业链接">1. 作业链接</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2020/labs/lock.html</li>
</ul>
<h2 id="实习内容">2. 实习内容</h2>
<h3 id="memory-allocator">2.1 Memory allocator</h3>
<h4 id="实验目标">(1) 实验目标</h4>
<ul>
<li>在内存管理上，由于只有一个 <code>freelist</code>，在多 CPU
的情况下，如果多个 CPU 同时申请内存，则可能出现剧烈的 <code>race</code>
现象</li>
<li>一个解决的方案就是为每一个 CPU 维护一个 <code>kmem</code>
的锁，从而减少 <code>race</code></li>
<li>在这一部分，就是实现这样的策略</li>
</ul>
<h4 id="提示">(2) 提示</h4>
<ul>
<li><code>kernel/param.h</code> 中定义了常数 <code>NCPU</code> （CPU
个数）</li>
<li>在 <code>freerange</code> 中将所有的可分配物理内存分配给每个
CPU</li>
<li><code>cpuid()</code> 返回当前 CPU 的
id，但是这只有在关闭中断的时候才是安全的
<ul>
<li>因此需要在调用前后关开中断（<code>push_off()</code>、<code>pop_off()</code>）</li>
</ul></li>
<li>可以简单地将锁命名为 <code>kmem</code>，或者使用
<code>snprintf()</code> 函数进行命名（这个没什么用，DEBUG）</li>
</ul>
<h4 id="实现">(3) 实现</h4>
<h5 id="锁的声明与初始化">[1] 锁的声明与初始化</h5>
<ul>
<li>找到原来的定义修改为数组即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem[NCPU];</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化的时候初始化整个数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kinit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 为了方便, 我们直接把名字命名为 `kmem`</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; NCPU; ++i)</span><br><span class="line">        initlock(&amp;kmem[i].lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">    freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="初始化可分配的物理内存">[2] 初始化可分配的物理内存</h5>
<ul>
<li>在 <code>freerange()</code> 中实现</li>
<li>依次给每个 CPU 分配物理内存即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// kfree(p);</span></span><br><span class="line">        <span class="comment">// 模仿 kfree 实现</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">1</span>, PGSIZE);</span><br><span class="line">        r = (<span class="keyword">struct</span> run*)p;</span><br><span class="line">        acquire(&amp;kmem[id].lock);</span><br><span class="line">        r-&gt;next = kmem[id].freelist;</span><br><span class="line">        kmem[id].freelist = r;</span><br><span class="line">        release(&amp;kmem[id].lock);</span><br><span class="line">        ++id;</span><br><span class="line">        <span class="keyword">if</span>(id == NCPU) &#123;</span><br><span class="line">            id = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="kalloc-kfree">[3] kalloc / kfree</h5>
<ul>
<li>在分配物理内存的时候，需要在当前 CPU 的 freelist 中分配</li>
<li>当不够的时候，可以取其他 CPU 的 freelist 中的物理内存</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">    push_off();</span><br><span class="line">    <span class="type">int</span> id = cpuid();</span><br><span class="line">    pop_off();</span><br><span class="line">    <span class="comment">// 尝试分配内存</span></span><br><span class="line">    acquire(&amp;kmem[id].lock);</span><br><span class="line">    r = kmem[id].freelist;</span><br><span class="line">    <span class="keyword">if</span>(r)</span><br><span class="line">        kmem[id].freelist = r-&gt;next;</span><br><span class="line">    release(&amp;kmem[id].lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从其他 CPU 那里获取</span></span><br><span class="line">    <span class="keyword">if</span>(!r) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; NCPU; ++i) &#123;</span><br><span class="line">            acquire(&amp;kmem[i].lock);</span><br><span class="line">            r = kmem[i].freelist;</span><br><span class="line">            <span class="keyword">if</span>(r)</span><br><span class="line">                kmem[i].freelist = r-&gt;next;</span><br><span class="line">            release(&amp;kmem[i].lock);</span><br><span class="line">            <span class="keyword">if</span>(r)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(r)</span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在释放物理内存的时候，将其释放到当前 CPU 的 freelist 中去</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    push_off();</span><br><span class="line">    <span class="type">int</span> id = cpuid();</span><br><span class="line">    pop_off();</span><br><span class="line"></span><br><span class="line">    acquire(&amp;kmem[id].lock);</span><br><span class="line">    r-&gt;next = kmem[id].freelist;</span><br><span class="line">    kmem[id].freelist = r;</span><br><span class="line">    release(&amp;kmem[id].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="buffer-cache">2.2 Buffer cache</h3>
<ul>
<li>由于 buffer
只有一个锁，因此存在大量的冲突，修改锁实现更少的冲突</li>
</ul>
<h4 id="提示-1">(1) 提示</h4>
<ul>
<li>修改 <code>bget</code> 和 <code>brelse</code>，以便
<code>bcache</code>
中不同块的并发查找和释放不太可能在锁上发生冲突（例如，不必都等待
<code>bcache.lock</code>）
<ul>
<li>每个块最多缓存一个副本</li>
</ul></li>
<li>新加的锁命名为 <code>bcache</code></li>
<li>建议使用哈希表在查找每个块号，然后每个哈希表项
<ul>
<li>可以使用固定大小的哈希表（例如一个质数：13）</li>
</ul></li>
<li>允许存在以下的冲突（conflict）
<ul>
<li>两个进程并发的使用相同块号的块（<code>bcachetest</code>
<code>test0</code> 不测试这个）</li>
<li>两个进程同时 miss，需要找一个新的块（<code>bcachetest</code>
<code>test0</code> 不测试这个）</li>
<li>通过调整块和锁不可避免的冲突（例如两个块的哈希值相同，但是可以通过调整哈希表的大小减小冲突）</li>
</ul></li>
<li>在哈希表中找 buffer 但是没找到，需要重新分配一个 buffer
的入口的时候得是原子操作</li>
<li>移除 buffer 链表（<code>bcache.head</code>
等），使用带最后一次使用时间戳的 buffer 代替（使用
<code>kernel/trap.c</code> 中的 <code>ticks</code> ）
<ul>
<li>这样修改以后，<code>brelse</code> 就不需要申请 <code>bcache</code>
的锁了，而且 <code>bget</code> 能够通过时间戳选出 LRU 的 buffer</li>
</ul></li>
<li><code>bget</code> 可以中可以是序列化驱逐（满了）</li>
<li>注意避免死锁，当驱逐的时候你需要同时持有 <code>bcache</code>
和哈希表中某一项的锁</li>
<li>当替换块的时候，如果没有映射到同一个哈希表项中，需要移动
<code>struct buf</code> 结构
<ul>
<li>注意死锁（哈希值相同时）</li>
</ul></li>
</ul>
<h4 id="实现-1">(2) 实现</h4>
<ul>
<li>只需要把链表修改为哈希桶即可
<ul>
<li>对于每一个哈希桶内部，我们使用带虚拟头结点的单向链表实现</li>
</ul></li>
<li>只需要修改文件 <code>kernel/bio.c</code> 和
<code>kernel/buf.h</code></li>
</ul>
<h5 id="修改链表为开链哈希桶">[1] 修改链表为开链哈希桶</h5>
<ul>
<li>一些宏定义
<ul>
<li>哈希桶个数为 13</li>
<li><code>buf</code> 的个数就按照原来给的，30 个</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUCKET_NUM 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_NUM NBUF</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改 <code>struct buf</code>，我们不需要 <code>prev</code>
指针了，通过 <code>timestamp</code> 时间戳去实现 LRU 算法</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">    <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">    uint dev;</span><br><span class="line">    uint blockno;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">    uint refcnt;</span><br><span class="line">    <span class="comment">// struct buf *prev; // 删除字段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">    uchar data[BSIZE];</span><br><span class="line">    uint timestamp;      <span class="comment">// 添加字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改数据结构 <code>bcache</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/bio.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line">    <span class="comment">// 修改为哈希桶(开链法)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">buckets</span>[<span class="title">BUCKET_NUM</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">bucketslock</span>[<span class="title">BUCKET_NUM</span>];</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化中修改初始化方式
<ul>
<li>初始化锁</li>
<li>初始化 buffer，主要是将 <code>buf</code> 均匀分配到哈希桶中
<ul>
<li>每个哈希桶中内容为带虚拟头结点的单向链表</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化锁</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; BUCKET_NUM; ++i) &#123;</span><br><span class="line">        initlock(&amp;bcache.lock[i], <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    initlock(&amp;bcache.lock_global, <span class="string">&quot;bcache_global&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化初始引用(初始化虚拟头结点)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; BUCKET_NUM; ++i) &#123;</span><br><span class="line">        bcache.buckets[i].next = &amp;bcache.buckets[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 buffer</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; BUF_NUM; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> id = hash(i);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">now</span> =</span> &amp;bcache.buf[i];</span><br><span class="line">        now-&gt;blockno = id;</span><br><span class="line">        now-&gt;refcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// now-&gt;timestamp = ticks;</span></span><br><span class="line">        initsleeplock(&amp;now-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">        <span class="comment">// 插入</span></span><br><span class="line">        now-&gt;next = bcache.buckets[id].next;</span><br><span class="line">        bcache.buckets[id].next = now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="修改-bget-函数">[2] 修改 bget 函数</h5>
<ul>
<li>按照原来链表的寻找方式，我们在每个哈希桶的链表中查找
<ul>
<li>如果已经缓存的话，直接返回即可</li>
<li>如果没有缓存的话，先在对应的哈希桶中找看看有没有空 buffer
<ul>
<li>对应的哈希桶内 LRU 查找</li>
</ul></li>
<li>如果没有的话再到其他哈希桶中找空的 buffer
<ul>
<li>其他的所有哈希桶 LRU 查找</li>
</ul></li>
</ul></li>
<li>这样子的实现并不是标准的 LRU</li>
<li>具体实现如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf* <span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id = hash(blockno);</span><br><span class="line">    acquire(&amp;bcache.lock[id]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 查找这个块是否被缓存, 如果被缓存直接返回即可</span></span><br><span class="line">    <span class="keyword">for</span>(b = bcache.buckets[id].next; b != &amp;bcache.buckets[id]; b = b-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">            b-&gt;refcnt++;</span><br><span class="line">            release(&amp;bcache.lock[id]);</span><br><span class="line">            acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 先在自己的桶里寻找</span></span><br><span class="line">    uint timestamp_min = <span class="number">0x8fffffff</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">res</span> =</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(b = bcache.buckets[id].next; b != &amp;bcache.buckets[id]; b = b-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span> &amp;&amp; b-&gt;timestamp &lt; timestamp_min) &#123;</span><br><span class="line">            timestamp_min = b-&gt;timestamp;</span><br><span class="line">            res = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res) &#123;</span><br><span class="line">        res-&gt;dev = dev;</span><br><span class="line">        res-&gt;blockno = blockno;</span><br><span class="line">        res-&gt;valid = <span class="number">0</span>;</span><br><span class="line">        res-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">        release(&amp;bcache.lock[id]);</span><br><span class="line">        acquiresleep(&amp;res-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 没有被缓存, 需要进行驱逐(其他桶中找)</span></span><br><span class="line">    <span class="comment">// 注意这里需要加全局锁</span></span><br><span class="line">    <span class="comment">// 不然可能出现两个进程同时找到同一个空块的情况</span></span><br><span class="line">    acquire(&amp;bcache.lock_global);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1) 找到最早的时间戳</span></span><br><span class="line">    <span class="comment">// 可以直接对 buf 循环</span></span><br><span class="line">    timestamp_min = <span class="number">0x8fffffff</span>;</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; BUF_NUM; ++i) &#123;</span><br><span class="line">        b = &amp;bcache.buf[i];</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span> &amp;&amp; b-&gt;timestamp &lt; timestamp_min) &#123;</span><br><span class="line">            timestamp_min = b-&gt;timestamp;</span><br><span class="line">            res = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没找到直接 panic</span></span><br><span class="line">    <span class="keyword">if</span>(!res) &#123;</span><br><span class="line">        release(&amp;bcache.lock[id]);</span><br><span class="line">        release(&amp;bcache.lock_global);</span><br><span class="line">        panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id_new = hash(res-&gt;blockno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要移动块到目标哈希桶中</span></span><br><span class="line">    <span class="comment">// 从原桶中删除</span></span><br><span class="line">    acquire(&amp;bcache.lock[id_new]);</span><br><span class="line">    <span class="keyword">for</span>(b = &amp;bcache.buckets[id_new]; b-&gt;next != &amp;bcache.buckets[id_new]; b = b-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;next == res) &#123;</span><br><span class="line">            b-&gt;next = res-&gt;next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入新桶</span></span><br><span class="line">    res-&gt;next = bcache.buckets[id].next;</span><br><span class="line">    bcache.buckets[id].next = res;</span><br><span class="line">    res-&gt;dev = dev;</span><br><span class="line">    res-&gt;blockno = blockno;</span><br><span class="line">    res-&gt;valid = <span class="number">0</span>;</span><br><span class="line">    res-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">    release(&amp;bcache.lock[id_new]); <span class="comment">// 具体释放位置应该在哪里?</span></span><br><span class="line">    release(&amp;bcache.lock[id]);</span><br><span class="line">    release(&amp;bcache.lock_global);</span><br><span class="line">    acquiresleep(&amp;res-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验结果">3. 实验结果</h2>
<ul>
<li>在我的电脑上第一个测试 <code>kalloctest</code> ，给的时间是
200s，但是我的电脑跑起来要 210s 左右，修改了一下时间限制才能过</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># grade-lab-lock</span></span><br><span class="line"><span class="comment"># line 12: timeout=300</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">== Test running kalloctest ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(211.1s)</span><br><span class="line">== Test   kalloctest: test1 ==</span><br><span class="line">  kalloctest: test1: OK</span><br><span class="line">== Test   kalloctest: test2 ==</span><br><span class="line">  kalloctest: test2: OK</span><br><span class="line">== Test kalloctest: sbrkmuch ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">kalloctest: sbrkmuch: OK (19.2s)</span><br><span class="line">== Test running bcachetest ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(14.5s)</span><br><span class="line">== Test   bcachetest: test0 ==</span><br><span class="line">  bcachetest: test0: OK</span><br><span class="line">== Test   bcachetest: test1 ==</span><br><span class="line">  bcachetest: test1: OK</span><br><span class="line">== Test usertests ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">usertests: OK (222.9s)</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 70/70</span><br></pre></td></tr></table></figure>
<h2 id="遇到的困难以及收获">4. 遇到的困难以及收获</h2>
<ul>
<li>一开始利用双向链表、单向链表实现，不知道为什么都会报错
<code>panic</code>，现在也没找到问题，后来改用带虚拟头结点的单向链表之后通过了，感觉很奇怪，有时间再回来看看具体的问题</li>
<li>做完 lab 之后了解到了一种在高并发场景下常用的优化手段
<ul>
<li>将锁进行细分，从而能够减小冲突，最终实现性能的提升</li>
</ul></li>
<li>感觉在实际的操作系统设计的过程中，锁的控制确实是一个很精细的过程，一不小心就会写成死锁，而且这些问题一般都很难发现</li>
<li>设计过程中很多时候应该使用保守的设计，比如在这个例子中，我们在找不到缓存，同时在哈希桶中找不到空闲
buffer
的时候，加上全局锁，此时虽然降低了性能，但是最终能够保证结果的正确</li>
</ul>
<h2 id="对课程或-lab-的意见和建议">5. 对课程或 lab 的意见和建议</h2>
<ul>
<li>建议提供一些关于 lab 的 debug 功能的指导</li>
</ul>
<h2 id="参考文献">6. 参考文献</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev1.pdf</li>
</ul>
]]></content>
      <categories>
        <category>OS.xv6-labs</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-labs-2020.lab9.mmap</title>
    <url>/2021/06/10/OS/xv6-labs/lab9-mmap/</url>
    <content><![CDATA[<h1 id="lab9-mmap">lab9 mmap</h1>
<h2 id="作业链接">1. 作业链接</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2020/labs/mmap.html</li>
</ul>
<h2 id="实习内容">2. 实习内容</h2>
<ul>
<li>实现系统调用 mmap，munmap</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>linux 下通过让一下命令查看对 mmap、munmap 的解释</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man 2 mmap</span><br></pre></td></tr></table></figure>
<ul>
<li>mmap()
<ul>
<li>addr：起始地址
<ul>
<li>如果为 NULL，则内核会选择一个页对齐的地址</li>
<li>如果不为 NULL，只是一个 hint，如果不可行则会选择其他地址</li>
</ul></li>
<li>length：申请的空间长度（字节）</li>
<li>prot：一些保护位
<ul>
<li>PROT_EXEC Pages may be executed.</li>
<li>PROT_READ Pages may be read.</li>
<li>PROT_WRITE Pages may be written.</li>
<li>PROT_NONE Pages may not be accessed.</li>
</ul></li>
<li>flag：设置的 flag，表示对这块区域的操作对其它进程的影响
<ul>
<li>MAP_SHARED、MAP_SHARED、MAP_ANONYMOUS 等</li>
</ul></li>
<li>fd：建立映射的文件</li>
<li>offset：被映射对象内容的起点</li>
<li>返回值为起始地址，(void*)-1 表示失败</li>
</ul></li>
<li>munmap()
<ul>
<li>addr：起始地址</li>
<li>length：空间长度（字节）</li>
</ul></li>
</ul>
<h3 id="说明">2.1 说明</h3>
<ul>
<li>我们在这个实验中只需要实现简单功能即可</li>
<li>mmap
<ul>
<li>addr 可以认为始终为 0
<ul>
<li>表示起始地址由内核决定</li>
</ul></li>
<li>返回值为起始地址，或者 <code>0xffffffffffffffff</code> 表示失败</li>
<li>length 表示需要映射内容的长度
<ul>
<li>可能和文件不等长</li>
</ul></li>
<li>prot 表示这块区域是否可读、可写、可执行
<ul>
<li>我们可以假设只能是 <code>PROT_READ</code> 、<code>PROT_WRITE</code>
、二者都有</li>
<li>flags 只能是
<code>MAP_SHARED</code>（修改需要写回文件）、<code>MAP_PRIVATE</code>（不需要写回文件）</li>
</ul></li>
<li>fd 为文件描述符</li>
<li>offset 为 0</li>
</ul></li>
<li>我们允许 MAP_SHARED 的映射区域不对应相同的物理页</li>
<li>munmap
<ul>
<li>解除映射</li>
<li>如果 flag 为 MAP_SHARED，则需要写回文件</li>
<li>解除的区域可以是映射区域的一个子集，但是我们可以假设接触区域只能是如下情况
<ul>
<li>整个区域</li>
<li>start 和映射区域相同</li>
<li>end 和映射区域相同</li>
</ul></li>
</ul></li>
</ul>
<h3 id="提示">2.2 提示</h3>
<ul>
<li>准备工作放在实现里面</li>
<li>mmap 本身不分配物理页，通过 page fault 分配物理页
<ul>
<li>usertrap 就行了，mmap 只会被用户态调用分配</li>
<li>保证快速映射一块大区域，允许映射比实际物理内存更大的范围</li>
</ul></li>
<li>每个进程保存一个数据结构 VMA（virtual memory area），记录被 mmap
映射的区域
<ul>
<li>简单的可以直接开一个定长的数组，16 就足够了</li>
<li>VMA 需要保存如下内容
<ul>
<li>address, length, permissions, file 等</li>
</ul></li>
</ul></li>
<li>mmap 的实现
<ul>
<li>首先在进程的空闲内存区与中找到一块区域分配空间</li>
<li>在 VMA 中找到一个空闲区域用于保存记录</li>
<li>VMA 中需要有一个 <code>struct file*</code> 指针，需要把 file
的引用计数+1（避免释放）
<ul>
<li>可以看 <code>filedup</code> 的实现</li>
</ul></li>
<li><span id="Q1">注意权限的检查</span>，有 read-only 的测试样例
<ul>
<li>如果把只读区域映射为可写的而且是 MAP_SHARED 则直接报错</li>
<li>MAP_PRIVATE 不会写</li>
</ul></li>
</ul></li>
<li>此时由于 lazy 的结果会导致 page fault</li>
<li>实现 page fault 时读取文件，分配物理页
<ul>
<li>捕捉 page fault</li>
<li>通过 readi 读取文件中与访问地址相近的 4096 bytes，并建立映射关系
<ul>
<li>readi 的时候需要给 inode 加锁</li>
</ul></li>
<li>正确设置权限位</li>
</ul></li>
<li>此时能够正确到达第一个 munmap 测试</li>
<li>实现 munmap
<ul>
<li>遍历 VMA，找到对应的 VMA，释放对应的空间即可</li>
<li>如果是 MAP_SHARED 的话，需要将修改的内容写回文件
<ul>
<li>参考 filewrite 实现</li>
</ul></li>
<li>如果是释放了整个映射区域的话，需要将文件的引用计数-1</li>
</ul></li>
<li>理论上，我们应该只写回真正被修改的页，也就是说 dirty 位设置为 1 的页
<ul>
<li>但是这里没有检查，因此我们不做要求</li>
</ul></li>
<li>exit() 退出的时候，释放所有的 VMA 中没有解除映射的块</li>
<li>fork() 的时候，子进程拥有和父进程一样的 VMA，允许在子进程遇到 page
fault 的时候分配一个不和父进程一样的物理页
<ul>
<li>更好的方式是和父进程共用一个物理页，但是这里不要求</li>
</ul></li>
</ul>
<h3 id="实现">2.3 实现</h3>
<h4 id="添加系统调用">(1) 添加系统调用</h4>
<ul>
<li><code>Makefile</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    $U/_mmaptest\</span><br></pre></td></tr></table></figure>
<ul>
<li>添加系统调用</li>
<li><code>user/usys.pl</code></li>
</ul>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">entry(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;munmap&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>user/user.h</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>*, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>kernel/sysfile.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_mmap</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64 <span class="title function_">sys_munmap</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>kernel/syscall.h</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mmap   22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_munmap 23</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>kernel/syscall.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_munmap</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    [SYS_mmap]   sys_mmap,</span><br><span class="line">    [SYS_munmap]   sys_munmap,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="vma">(2) VMA</h4>
<ul>
<li>添加数据结构 VMA</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> &#123;</span></span><br><span class="line">    uint64 start;  <span class="comment">// 起始地址</span></span><br><span class="line">    uint64 end;    <span class="comment">// 结束地址</span></span><br><span class="line">    uint64 length; <span class="comment">// 区域的长度</span></span><br><span class="line">    <span class="type">int</span> prot;      <span class="comment">// 权限</span></span><br><span class="line">    <span class="type">int</span> flags;     <span class="comment">// MAP_SHARED,MAP_PRIVATE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// 对应的文件</span></span><br><span class="line">    <span class="type">int</span> offset;    <span class="comment">// 可能释放了一个部分, 此时 offset 可能不是 0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>在 proc 中添加 VMA</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVMA 16</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> <span class="title">vma</span>[<span class="title">MAXVMA</span>];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mmap">(3) mmap</h4>
<ul>
<li>按照提示的说明实现 mmap()</li>
<li>找到一个空闲区域，写入 VMA，修改当前进程的 sz</li>
<li>注意上面提到的一个<a href="#Q1">权限问题</a></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line">uint64 <span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// uint64 addr; // 都为 0</span></span><br><span class="line">    <span class="type">int</span> length, prot, flags, fd;</span><br><span class="line">    <span class="comment">// int offset; // 都为 0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">if</span>(argint(<span class="number">1</span>, &amp;length) &lt; <span class="number">0</span> || argint(<span class="number">2</span>, &amp;prot) &lt; <span class="number">0</span></span><br><span class="line">       || argint(<span class="number">3</span>, &amp;flags) &lt; <span class="number">0</span> || argfd(<span class="number">4</span>, &amp;fd, &amp;f) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果把只读区域映射为可写的而且是 MAP_SHARED 则直接报错</span></span><br><span class="line">    <span class="comment">// MAP_PRIVATE 不会写</span></span><br><span class="line">    <span class="comment">// 有 read-only 测试</span></span><br><span class="line">    <span class="keyword">if</span>(!f-&gt;writable &amp;&amp; (prot &amp; PROT_WRITE) &amp;&amp; (flags &amp; MAP_SHARED))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到空闲区域, 找到空闲 VMA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXVMA; ++i) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span>* <span class="title">v</span> =</span> &amp;(p-&gt;vma[i]);</span><br><span class="line">        <span class="keyword">if</span>(v-&gt;length == <span class="number">0</span>) &#123;</span><br><span class="line">            v-&gt;length = length;</span><br><span class="line">            v-&gt;start = p-&gt;sz;</span><br><span class="line">            v-&gt;prot = prot;</span><br><span class="line">            v-&gt;flags = flags;</span><br><span class="line">            v-&gt;offset = <span class="number">0</span>;</span><br><span class="line">            v-&gt;file = filedup(f); <span class="comment">// 引用计数+1</span></span><br><span class="line">            <span class="comment">// 地址必须是页对齐的</span></span><br><span class="line">            length = PGROUNDUP(length);</span><br><span class="line">            p-&gt;sz += length;</span><br><span class="line">            v-&gt;end = p-&gt;sz;</span><br><span class="line">            <span class="keyword">return</span> v-&gt;start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>由于这里并没有分配内存，因此会触发 usertrap()</li>
</ul>
<h4 id="usertrap">(4) usertrap</h4>
<ul>
<li>在 usertrap 中处理 page fault
<ul>
<li>和 lab4-lazy 比较像</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c:usertrap</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">0xd</span> || r_scause() == <span class="number">0xf</span>) &#123;</span><br><span class="line">    <span class="comment">// 因为包含关系的问题, 我们直接把函数放到 sysfile.c 里面</span></span><br><span class="line">    <span class="comment">// printf(&quot;%p\n%p\n&quot;, r_stval(), PGROUNDDOWN(r_stval()));</span></span><br><span class="line">    <span class="keyword">if</span>(!map_mmap(p, r_stval())) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<ul>
<li>因为头文件的包含问题，我们把 map_mmap() 的实现放在了
kernel/sysfile.c 里面</li>
<li>kernel/defs.h 里添加函数声明</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"><span class="comment">// sysfile.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">map_mmap</span><span class="params">(<span class="keyword">struct</span> proc*, uint64)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>kernel/sysfile.c 中添加实现
<ul>
<li>遍历 VMA，找到对应的文件</li>
<li>申请空间</li>
<li>建立映射</li>
<li>从文件中读入内存</li>
</ul></li>
<li>一些个问题
<ul>
<li>申请空间是按页申请的，因此起始地址必须时页对齐的，申请长度必须是页的整数倍</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line"><span class="comment">// 1 成功, 0 失败</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">map_mmap</span><span class="params">(<span class="keyword">struct</span> proc *p, uint64 addr)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历 vma 找到具体的文件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXVMA; ++i) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span>* <span class="title">v</span> =</span> &amp;(p-&gt;vma[i]);</span><br><span class="line">        <span class="comment">// 左闭右开</span></span><br><span class="line">        <span class="keyword">if</span>(v-&gt;length != <span class="number">0</span> &amp;&amp; addr &lt; v-&gt;end &amp;&amp; addr &gt;= v-&gt;start) &#123;</span><br><span class="line">            uint64 start = PGROUNDDOWN(addr);</span><br><span class="line">            <span class="comment">// uint64 end = PGROUNDUP(addr);</span></span><br><span class="line">            <span class="comment">// 可能释放了一部分, 但是后面部分没有建立映射(offset)</span></span><br><span class="line">            uint64 offset = start - v-&gt;start + v-&gt;offset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 申请一块空间</span></span><br><span class="line">            <span class="type">char</span>* mem = kalloc();</span><br><span class="line">            <span class="keyword">if</span>(!mem) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// PROT_NONE       0x0   PTE_V (1L &lt;&lt; 0)</span></span><br><span class="line">            <span class="comment">// PROT_READ       0x1   PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line">            <span class="comment">// PROT_WRITE      0x2   PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line">            <span class="comment">// PROT_EXEC       0x4   PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line">            <span class="comment">//                       PTE_U (1L &lt;&lt; 4)</span></span><br><span class="line">            <span class="comment">// 建立映射关系</span></span><br><span class="line">            <span class="keyword">if</span>(mappages(p-&gt;pagetable, start, PGSIZE,</span><br><span class="line">                        (uint64)mem, (v-&gt;prot&lt;&lt;<span class="number">1</span>)|PTE_U) != <span class="number">0</span></span><br><span class="line">              )&#123;</span><br><span class="line">                kfree(mem);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取文件</span></span><br><span class="line">            ilock(v-&gt;file-&gt;ip);</span><br><span class="line">            <span class="comment">// 1 表示虚拟地址</span></span><br><span class="line">            readi(v-&gt;file-&gt;ip, <span class="number">1</span>, start, offset, PGSIZE);</span><br><span class="line">            iunlock(v-&gt;file-&gt;ip);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="munmap">(5) munmap</h4>
<ul>
<li>遍历 VMA，找到对应的映射</li>
<li>判断是否是从 start 开始释放，如果是，接着判断是否需要释放整个文件
<ul>
<li>注意如果要释放只做标记，之后再释放，否则会出问题（不能提前释放文件）</li>
</ul></li>
<li>如果是 MAP_SHARED，则在释放之前需要进行写操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line">uint64 <span class="title function_">sys_munmap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;length) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXVMA; ++i) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span>* <span class="title">v</span> =</span> &amp;(p-&gt;vma[i]);</span><br><span class="line">    <span class="comment">// 左闭右开</span></span><br><span class="line">    <span class="keyword">if</span>(v-&gt;length != <span class="number">0</span> &amp;&amp; addr &lt; v-&gt;end &amp;&amp; addr &gt;= v-&gt;start) &#123;</span><br><span class="line">      <span class="type">int</span> should_close = <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> offset = v-&gt;offset;</span><br><span class="line">      addr = PGROUNDDOWN(addr);</span><br><span class="line">      length = PGROUNDUP(length);</span><br><span class="line">      <span class="comment">// 是否从 start 开始</span></span><br><span class="line">      <span class="keyword">if</span>(addr == v-&gt;start) &#123;</span><br><span class="line">        <span class="comment">// 是否释放整个文件</span></span><br><span class="line">        <span class="keyword">if</span>(length == v-&gt;length) &#123;</span><br><span class="line">          v-&gt;length = <span class="number">0</span>;</span><br><span class="line">          <span class="comment">// 不能在这个时候释放, 得在写回之后</span></span><br><span class="line">          should_close = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          v-&gt;start += length;</span><br><span class="line">          v-&gt;length -= length;</span><br><span class="line">          v-&gt;offset += length;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 根据要求这个时候只能是释放到结尾</span></span><br><span class="line">        v-&gt;length -= length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 处理 MAP_SHARED</span></span><br><span class="line">      <span class="keyword">if</span>(v-&gt;flags &amp; MAP_SHARED) &#123;</span><br><span class="line">        <span class="comment">// 一种简单的实现就是直接把整个文件写回去</span></span><br><span class="line">        <span class="comment">// !!!!(不行, 可能现在的映射已经不是整个文件)</span></span><br><span class="line">        filewrite_offset(v-&gt;file, addr, length, offset);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 解除映射</span></span><br><span class="line">      <span class="comment">// 这里还有些问题, 可能并没有映射</span></span><br><span class="line">      <span class="comment">// if(walkaddr(p-&gt;pagetable, addr) != 0)</span></span><br><span class="line">      uvmunmap(p-&gt;pagetable, addr, length/PGSIZE, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span>(should_close)</span><br><span class="line">        fileclose(v-&gt;file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>和 filewrite() 一样的实现，只是增加一个文件的 offset
<ul>
<li>我们只实现了 FINODE 的写操作</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line"><span class="comment">// Write to file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address.</span></span><br><span class="line"><span class="comment">// 支持 offset</span></span><br><span class="line"><span class="comment">// 我们只进行 FINODE 的写操作</span></span><br><span class="line"><span class="comment">// n 表示写的字节数</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">    <span class="title function_">filewrite_offset</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;writable == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;type != FD_INODE) &#123;</span><br><span class="line">        panic(<span class="string">&quot;filewrite: only FINODE implemented!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = ((MAXOPBLOCKS<span class="number">-1</span><span class="number">-1</span><span class="number">-2</span>) / <span class="number">2</span>) * BSIZE;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">        <span class="type">int</span> n1 = n - i;</span><br><span class="line">        <span class="keyword">if</span>(n1 &gt; max)</span><br><span class="line">            n1 = max;</span><br><span class="line"></span><br><span class="line">        begin_op();</span><br><span class="line">        ilock(f-&gt;ip);</span><br><span class="line">        <span class="keyword">if</span> ((r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, offset, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">            offset += r;</span><br><span class="line">        iunlock(f-&gt;ip);</span><br><span class="line">        end_op();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r != n1) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i += r;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = (i == n ? n : <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其他细节">(6) 其他细节</h4>
<ul>
<li>在 exit() 退出的时候，需要释放映射的文件区域
<ul>
<li>注意文件计数需要+1</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc/c:exit()</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXVMA; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">v</span> =</span> &amp;(p-&gt;vma[i]);</span><br><span class="line">    <span class="keyword">if</span>(v-&gt;length != <span class="number">0</span>)&#123;</span><br><span class="line">        uvmunmap(p-&gt;pagetable, v-&gt;start, v-&gt;length/PGSIZE, <span class="number">1</span>);</span><br><span class="line">        v-&gt;length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在 fork 的时候，将父进程的映射内容拷贝到子进程
<ul>
<li>注意文件计数需要+1</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc/c:fork()</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// VMA</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXVMA; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;vma[i].length) &#123;</span><br><span class="line">        memmove(&amp;(np-&gt;vma[i]), &amp;(p-&gt;vma[i]), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> VMA));</span><br><span class="line">        filedup(p-&gt;vma[i].file);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        np-&gt;vma[i].length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<ul>
<li>因为 lazy 分配的原因，我们需要做一些特殊处理</li>
<li>uvmunmap()
<ul>
<li>如果没有建立映射，则不需要释放</li>
<li>如果建立了映射，但是没有读入内存，则不需要调用 kfree()</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c:uvmunmap()</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//   panic(&quot;uvmunmap: walk&quot;);</span></span><br><span class="line">    <span class="comment">// if((*pte &amp; PTE_V) == 0)</span></span><br><span class="line">    <span class="comment">//   panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">        panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free &amp;&amp; (*pte &amp; PTE_V) != <span class="number">0</span>)&#123;</span><br><span class="line">        uint64 pa = PTE2PA(*pte);</span><br><span class="line">        kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>uvmcopy()
<ul>
<li>如果尚未分配物理页，这是允许的</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c:uvmcopy()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后的代码</span></span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<h2 id="实验结果">3. 实验结果</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">== Test running mmaptest ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(23.1s)</span><br><span class="line">== Test   mmaptest: mmap f ==</span><br><span class="line">  mmaptest: mmap f: OK</span><br><span class="line">== Test   mmaptest: mmap private ==</span><br><span class="line">  mmaptest: mmap private: OK</span><br><span class="line">== Test   mmaptest: mmap read-only ==</span><br><span class="line">  mmaptest: mmap read-only: OK</span><br><span class="line">== Test   mmaptest: mmap <span class="built_in">read</span>/write ==</span><br><span class="line">  mmaptest: mmap <span class="built_in">read</span>/write: OK</span><br><span class="line">== Test   mmaptest: mmap dirty ==</span><br><span class="line">  mmaptest: mmap dirty: OK</span><br><span class="line">== Test   mmaptest: not-mapped unmap ==</span><br><span class="line">  mmaptest: not-mapped unmap: OK</span><br><span class="line">== Test   mmaptest: two files ==</span><br><span class="line">  mmaptest: two files: OK</span><br><span class="line">== Test   mmaptest: fork_test ==</span><br><span class="line">  mmaptest: fork_test: OK</span><br><span class="line">== Test usertests ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">usertests: OK (272.3s)</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 140/140</span><br></pre></td></tr></table></figure>
<h2 id="遇到的困难以及收获">4. 遇到的困难以及收获</h2>
<ul>
<li>这个 lab
做起来很舒服，一方面提示给得很完整，另一方面我对文件系统的理解也更加深入了
<ul>
<li>这个 lab 可以说是 lab4-lazy 的延伸，lazy
机制缺失在很多地方都很有用</li>
</ul></li>
<li>做完这个 lab，感觉自己对 xv6 -riscv 文件系统了解更深入了</li>
</ul>
<h2 id="对课程或-lab-的意见和建议">5. 对课程或 lab 的意见和建议</h2>
<ul>
<li>建议提供一些关于 lab 的 debug 功能的指导</li>
</ul>
<h2 id="参考文献">6. 参考文献</h2>
<ul>
<li>https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev1.pdf</li>
</ul>
]]></content>
      <categories>
        <category>OS.xv6-labs</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Server 递归查询.狼羊过河问题</title>
    <url>/2021/06/22/DB/SQLServer/Wolf.Sheep.Vegetable.River/</url>
    <content><![CDATA[<h1 id="狼羊过河问题">狼羊过河问题</h1>
<h2 id="问题描述">问题描述</h2>
<ul>
<li>一个人带着一只狼、一只羊、一棵白菜要过河，小船一次只能容下一个人和一样动植物</li>
<li>人不在场的时候，狼要吃掉羊、羊要吃掉白菜</li>
<li>问应当如何渡河？</li>
</ul>
<h2 id="sql-server-求解">SQL Server 求解</h2>
<ul>
<li>安装之后命令行直接输入如下命令便可进入 SQL Server 命令行模式</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sqlcmd</span><br></pre></td></tr></table></figure>
<ul>
<li>新建数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database River;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use River;</span><br></pre></td></tr></table></figure>
<h3 id="状态表">状态表</h3>
<ul>
<li>新建一个数据库表 <code>STATE</code> 用于存储可行的状态，state
表示当前河岸的状态</li>
<li>使用一个 4 位的二级制数表示状态</li>
<li>低 4 位分别表示人（3）、狼（2）、羊（1）、菜（0）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> STATE (</span><br><span class="line">    state tinyint</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用循环把可行的状态插入表中</li>
<li>可行的状态，满足以下一个条件即可
<ul>
<li>人在</li>
<li>人不在，但是不存在狼羊或羊菜同时存在的情况</li>
</ul></li>
<li>最大的状态为 0b1111 = 15
<ul>
<li>判断人不在：state &lt; 0b1000
<ul>
<li>0b1000 = 8</li>
</ul></li>
<li>判断狼羊都在：state &amp; 0b0110 == 0b0110
<ul>
<li>0b0110 = 6</li>
</ul></li>
<li>判断羊菜都在：state &amp; 0b0011 == 0b0011
<ul>
<li>0b0011 = 3</li>
</ul></li>
</ul></li>
<li>同时对岸也得满足这个条件</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable">@i</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable">@j</span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@i</span><span class="operator">=</span><span class="number">0</span></span><br><span class="line">while <span class="variable">@i</span><span class="operator">&lt;=</span><span class="number">15</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">set</span> <span class="variable">@j</span><span class="operator">=</span><span class="number">15</span><span class="operator">-</span><span class="variable">@i</span></span><br><span class="line">    <span class="comment">/* 当前岸 */</span></span><br><span class="line">    if ((<span class="variable">@i</span> <span class="operator">&gt;=</span> <span class="number">8</span>) <span class="keyword">or</span> <span class="keyword">not</span> ((<span class="variable">@i</span> <span class="operator">&amp;</span> <span class="number">6</span> <span class="operator">=</span> <span class="number">6</span>) <span class="keyword">or</span> (<span class="variable">@i</span> <span class="operator">&amp;</span> <span class="number">3</span> <span class="operator">=</span> <span class="number">3</span>)))</span><br><span class="line">    <span class="keyword">and</span></span><br><span class="line">    <span class="comment">/* 对岸 */</span></span><br><span class="line">    ((<span class="variable">@j</span> <span class="operator">&gt;=</span> <span class="number">8</span>) <span class="keyword">or</span> <span class="keyword">not</span> ((<span class="variable">@j</span> <span class="operator">&amp;</span> <span class="number">6</span> <span class="operator">=</span> <span class="number">6</span>) <span class="keyword">or</span> (<span class="variable">@j</span> <span class="operator">&amp;</span> <span class="number">3</span> <span class="operator">=</span> <span class="number">3</span>)))</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">insert</span> STATE <span class="keyword">values</span> (<span class="variable">@i</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">set</span> <span class="variable">@i</span><span class="operator">=</span><span class="variable">@i</span><span class="operator">+</span><span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过如下指令，我们可以看到一共有 10 个状态</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> STATE</span><br></pre></td></tr></table></figure>
<h3 id="路径表">路径表</h3>
<ul>
<li>新建一个表，用于表示相邻边</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> PATH(</span><br><span class="line">    state_from  tinyint,</span><br><span class="line">    state_to    tinyint,</span><br><span class="line">    path        <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>对 STATE 表做笛卡尔积，挑选出可行边，保存在 PATH 中，path
字段记录中间节点</li>
<li>可行边，同时满足以下所有条件
<ul>
<li>满足下列两个条件之一
<ul>
<li>state_from - state_to 中有人，且最多有一件物品，同时 state_to
中不能有 state_from 没有的东西
<ul>
<li>人过河</li>
</ul></li>
<li>state_to - state_from 中有人，且最多有一件物品，同时 state_from
中不能有 state_to 没有的东西
<ul>
<li>人从对岸回来</li>
</ul></li>
</ul></li>
<li>state_from、state_to 都是合法的
<ul>
<li>这个由 STATE 表保证了</li>
</ul></li>
</ul></li>
<li>实际解决
<ul>
<li>state_from - state_to 中有人（最高位为 1）
<ul>
<li>打表：1-0=1，1-1=0，0-1=0，0-0=0
<ul>
<li>state_from - state_to = state_from &amp; ~state_to &gt;= 0b1000 =
8</li>
</ul></li>
</ul></li>
<li>最多只有一件物品
<ul>
<li>state_from - state_to 的低三位只有一位为 1，或者全为 0</li>
</ul></li>
<li>state_to 中不能有 state_from 没有的东西
<ul>
<li>state_to &amp; ~state_from == 0</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> PATH</span><br><span class="line"><span class="keyword">select</span> S1.state, S2.state, &quot;&quot;</span><br><span class="line"><span class="keyword">from</span> STATE S1, STATE S2</span><br><span class="line"><span class="keyword">where</span> (</span><br><span class="line">    (S1.state <span class="operator">&amp;</span> <span class="operator">~</span>S2.state <span class="operator">&gt;=</span> <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">and</span></span><br><span class="line">    (S2.state <span class="operator">&amp;</span> <span class="operator">~</span>S1.state <span class="operator">=</span> <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">and</span> (</span><br><span class="line">        (S1.state <span class="operator">&amp;</span> <span class="operator">~</span>S2.state <span class="operator">&amp;</span> <span class="number">7</span> <span class="operator">=</span> <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">or</span> (S1.state <span class="operator">&amp;</span> <span class="operator">~</span>S2.state <span class="operator">&amp;</span> <span class="number">7</span> <span class="operator">=</span> <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">or</span> (S1.state <span class="operator">&amp;</span> <span class="operator">~</span>S2.state <span class="operator">&amp;</span> <span class="number">7</span> <span class="operator">=</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">or</span> (S1.state <span class="operator">&amp;</span> <span class="operator">~</span>S2.state <span class="operator">&amp;</span> <span class="number">7</span> <span class="operator">=</span> <span class="number">4</span>)</span><br><span class="line">    )</span><br><span class="line">) <span class="keyword">or</span> (</span><br><span class="line">    (S2.state <span class="operator">&amp;</span> <span class="operator">~</span>S1.state <span class="operator">&gt;=</span> <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">and</span></span><br><span class="line">    (S1.state <span class="operator">&amp;</span> <span class="operator">~</span>S2.state <span class="operator">=</span> <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">and</span> (</span><br><span class="line">        (S2.state <span class="operator">&amp;</span> <span class="operator">~</span>S1.state <span class="operator">&amp;</span> <span class="number">7</span> <span class="operator">=</span> <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">or</span> (S2.state <span class="operator">&amp;</span> <span class="operator">~</span>S1.state <span class="operator">&amp;</span> <span class="number">7</span> <span class="operator">=</span> <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">or</span> (S2.state <span class="operator">&amp;</span> <span class="operator">~</span>S1.state <span class="operator">&amp;</span> <span class="number">7</span> <span class="operator">=</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">or</span> (S2.state <span class="operator">&amp;</span> <span class="operator">~</span>S1.state <span class="operator">&amp;</span> <span class="number">7</span> <span class="operator">=</span> <span class="number">4</span>)</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>可以做一个简单的优化</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> PATH</span><br><span class="line"><span class="keyword">select</span> S1.state, S2.state, &quot;&quot;</span><br><span class="line"><span class="keyword">from</span> STATE S1, STATE S2</span><br><span class="line"><span class="keyword">where</span> (</span><br><span class="line">    (S2.state <span class="operator">&amp;</span> <span class="operator">~</span>S1.state <span class="operator">=</span> <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">and</span> (</span><br><span class="line">        (S1.state <span class="operator">&amp;</span> <span class="operator">~</span>S2.state <span class="operator">=</span> <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">or</span>(S1.state <span class="operator">&amp;</span> <span class="operator">~</span>S2.state <span class="operator">=</span> <span class="number">9</span>)</span><br><span class="line">        <span class="keyword">or</span> (S1.state <span class="operator">&amp;</span> <span class="operator">~</span>S2.state <span class="operator">=</span> <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">or</span> (S1.state <span class="operator">&amp;</span> <span class="operator">~</span>S2.state <span class="operator">=</span> <span class="number">12</span>)</span><br><span class="line">    )</span><br><span class="line">) <span class="keyword">or</span> (</span><br><span class="line">    (S1.state <span class="operator">&amp;</span> <span class="operator">~</span>S2.state <span class="operator">=</span> <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">and</span> (</span><br><span class="line">        (S2.state <span class="operator">&amp;</span> <span class="operator">~</span>S1.state <span class="operator">=</span> <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">or</span>(S2.state <span class="operator">&amp;</span> <span class="operator">~</span>S1.state <span class="operator">=</span> <span class="number">9</span>)</span><br><span class="line">        <span class="keyword">or</span> (S2.state <span class="operator">&amp;</span> <span class="operator">~</span>S1.state <span class="operator">=</span> <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">or</span> (S2.state <span class="operator">&amp;</span> <span class="operator">~</span>S1.state <span class="operator">=</span> <span class="number">12</span>)</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="求解">求解</h3>
<ul>
<li>我们简单的用一个表 <code>ANSWER</code> 记录结果</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> ANSWER(</span><br><span class="line">    path    <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>找一条路径满足起始点为 0b1111=15，终点为 0b0000=0，输出这条路径</li>
<li>我们需要进行一个环路检测，我们简单的使用一个变量记录路径，不允许路径上的点重复出现</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> MultiBouncePath(state_from, state_to, path) <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> state_from, state_to, <span class="built_in">cast</span>(path <span class="keyword">as</span> <span class="type">varchar</span>)</span><br><span class="line">    <span class="keyword">from</span> PATH</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注意顺序 M,P, 末尾增长边 */</span></span><br><span class="line">    <span class="keyword">select</span> M.state_from , P.state_to, <span class="built_in">cast</span>(M.path <span class="operator">+</span> <span class="string">&#x27;,&#x27;</span> <span class="operator">+</span> <span class="built_in">cast</span>(M.state_to <span class="keyword">as</span> <span class="type">varchar</span>) <span class="keyword">as</span> <span class="type">varchar</span>)</span><br><span class="line">    <span class="keyword">from</span> MultiBouncePath M, PATH P</span><br><span class="line">    <span class="comment">/* M.path 中找不到子串 P.state_t 说明路径上没有这个点 */</span></span><br><span class="line">    <span class="keyword">where</span> M.state_to <span class="operator">=</span> P.state_from <span class="keyword">and</span> CHARINDEX(<span class="built_in">cast</span>(P.state_to <span class="keyword">as</span> <span class="type">varchar</span>) ,M.path) <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> ANSWER</span><br><span class="line"><span class="keyword">select</span> (<span class="built_in">cast</span>(state_from <span class="keyword">as</span> <span class="type">varchar</span>) <span class="operator">+</span> path <span class="operator">+</span> &quot;,&quot; <span class="operator">+</span> <span class="built_in">cast</span>(state_to <span class="keyword">as</span> <span class="type">varchar</span>))</span><br><span class="line"><span class="keyword">from</span> MultiBouncePath</span><br><span class="line"><span class="keyword">where</span> state_from <span class="operator">=</span> <span class="number">15</span> <span class="keyword">and</span> state_to <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以查看具体的路径</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ANSWER</span><br></pre></td></tr></table></figure>
<ul>
<li>结果如下
<ul>
<li>15,5,13,4,14,2,10,0</li>
<li>15,5,13,1,11,2,10,0</li>
</ul></li>
<li>我们将其转化为我们能够直接读得懂的内容</li>
<li>增加一个标识 ID</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> ANSWER <span class="keyword">add</span> ID <span class="type">int</span> <span class="keyword">identity</span>(<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>辅助实现</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> ANSWER</span><br><span class="line"><span class="keyword">set</span> path <span class="operator">=</span> path <span class="operator">+</span> <span class="string">&#x27;,&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义一个从数字到状态的转换函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 架构名.函数名 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> dbo.to_zh(</span><br><span class="line"><span class="variable">@num1</span> <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">returns</span> <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> <span class="variable">@ans1</span> <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">declare</span> <span class="variable">@ans2</span> <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">declare</span> <span class="variable">@disc</span> <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">declare</span> <span class="variable">@index</span> <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">set</span> <span class="variable">@disc</span> <span class="operator">=</span> &quot;人狼羊菜&quot;</span><br><span class="line">    <span class="keyword">set</span> <span class="variable">@index</span> <span class="operator">=</span> &quot;8421&quot;</span><br><span class="line">    <span class="keyword">set</span> <span class="variable">@ans1</span> <span class="operator">=</span> &quot;&quot;</span><br><span class="line">    <span class="keyword">set</span> <span class="variable">@ans2</span> <span class="operator">=</span> &quot;&quot;</span><br><span class="line">    <span class="keyword">declare</span> <span class="variable">@i</span> <span class="type">int</span></span><br><span class="line">    <span class="keyword">set</span> <span class="variable">@i</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    while(<span class="variable">@i</span> <span class="operator">&lt;=</span> <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        if ((<span class="variable">@num1</span> <span class="operator">&amp;</span> (ASCII(<span class="built_in">SUBSTRING</span>(<span class="variable">@index</span>, <span class="variable">@i</span>, <span class="number">1</span>)) <span class="operator">-</span> ASCII(&quot;0&quot;))) <span class="operator">&gt;</span> <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">set</span> <span class="variable">@ans1</span> <span class="operator">=</span> <span class="variable">@ans1</span> <span class="operator">+</span> <span class="built_in">SUBSTRING</span>(<span class="variable">@disc</span>, <span class="variable">@i</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">set</span> <span class="variable">@ans2</span> <span class="operator">=</span> <span class="variable">@ans2</span> <span class="operator">+</span> <span class="built_in">SUBSTRING</span>(<span class="variable">@disc</span>, <span class="variable">@i</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">set</span> <span class="variable">@i</span> <span class="operator">=</span> <span class="variable">@i</span> <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">@ans1</span> <span class="operator">+</span> &quot;|&quot; <span class="operator">+</span> <span class="variable">@ans2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>取出一个结果进行输出
<ul>
<li>master..spt_values 是系统中一个表</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> dbo.to_zh(M.item) <span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">SUBSTRING</span>(ans.path, number, CHARINDEX(<span class="string">&#x27;,&#x27;</span>, ans.path <span class="operator">+</span> <span class="string">&#x27;,&#x27;</span>, number) <span class="operator">-</span> number) <span class="keyword">as</span> item</span><br><span class="line">    <span class="keyword">from</span> ANSWER ans, master..spt_values</span><br><span class="line">    <span class="comment">/* 查第 1 条记录*/</span></span><br><span class="line">    <span class="keyword">where</span> ID <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">and</span> number <span class="operator">&gt;=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">and</span> number <span class="operator">&lt;</span> len(ans.path)</span><br><span class="line">    <span class="keyword">and</span> type <span class="operator">=</span> <span class="string">&#x27;p&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;,&#x27;</span> <span class="operator">+</span> ans.path, number, <span class="number">1</span>)<span class="operator">=</span><span class="string">&#x27;,&#x27;</span></span><br><span class="line">) M</span><br></pre></td></tr></table></figure>
<ul>
<li>输出结果如下</li>
<li>15,5,13,4,14,2,10,0</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">人狼羊菜|</span><br><span class="line">狼菜|人羊</span><br><span class="line">人狼菜|羊</span><br><span class="line">狼|人羊菜</span><br><span class="line">人狼羊|菜</span><br><span class="line">羊|人狼菜</span><br><span class="line">人羊|狼菜</span><br><span class="line">|人狼羊菜</span><br></pre></td></tr></table></figure>
<ul>
<li>15,5,13,1,11,2,10,0</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">人狼羊菜<span class="operator">|</span></span><br><span class="line">狼菜<span class="operator">|</span>人羊</span><br><span class="line">人狼菜<span class="operator">|</span>羊</span><br><span class="line">菜<span class="operator">|</span>人狼羊</span><br><span class="line">人羊菜<span class="operator">|</span>狼</span><br><span class="line">羊<span class="operator">|</span>人狼菜</span><br><span class="line">人羊<span class="operator">|</span>狼菜</span><br><span class="line"><span class="operator">|</span>人狼羊菜</span><br></pre></td></tr></table></figure>
<h2 id="其他-sql-server-相关">其他 SQL Server 相关</h2>
<ul>
<li>删除整个表中的条目</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> STATE</span><br></pre></td></tr></table></figure>
<ul>
<li>删除函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> dbo.to_zh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB.SQLServer</category>
      </categories>
      <tags>
        <tag>DB</tag>
        <tag>SQL</tag>
        <tag>SQLServer</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Server json 查询练习</title>
    <url>/2021/06/22/DB/SQLServer/json.practice/</url>
    <content><![CDATA[<h1 id="json-查询">Json 查询</h1>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/sql/relational-databases/json/json-data-sql-server?view=sql-server-ver15">官网教程</a></li>
</ul>
<h2 id="sql-server-json-功能使用">SQL Server json 功能使用</h2>
<ul>
<li>新建数据库 <code>json_test</code> 并使用</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database json_test</span><br><span class="line">use json_test</span><br></pre></td></tr></table></figure>
<ul>
<li>每一条 json 的格式如下</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;01001&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;city&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;AGAWAM&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;loc&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">-72.622739</span><span class="punctuation">,</span> <span class="number">42.070206</span> <span class="punctuation">]</span><span class="punctuation">,</span> <span class="attr">&quot;pop&quot;</span> <span class="punctuation">:</span> <span class="number">15338</span><span class="punctuation">,</span> <span class="attr">&quot;state&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;MA&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将 json 文件修改为标准格式
<ul>
<li>逗号分隔，最外面加上大括号</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123; &quot;_id&quot; : &quot;01001&quot;, &quot;city&quot; : &quot;AGAWAM&quot;, &quot;loc&quot; : [ <span class="number">-72.622739</span>, <span class="number">42.070206</span> ], &quot;pop&quot; : <span class="number">15338</span>, &quot;state&quot; : &quot;MA&quot; &#125;,</span><br><span class="line">    &#123; &quot;_id&quot; : &quot;99950&quot;, &quot;city&quot; : &quot;KETCHIKAN&quot;, &quot;loc&quot; : [ <span class="number">-133.18479</span>, <span class="number">55.942471</span> ], &quot;pop&quot; : <span class="number">422</span>, &quot;state&quot; : &quot;AK&quot; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="读成数据项">读成数据项</h3>
<ul>
<li>按照格式新建一个表用于存储</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    city nvarchar(<span class="number">20</span>),</span><br><span class="line">    locx <span class="type">float</span>,</span><br><span class="line">    locy <span class="type">float</span>,</span><br><span class="line">    pop <span class="type">int</span>,</span><br><span class="line">    state <span class="type">char</span>(<span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用如下命令将数据读入表中
<ul>
<li>OPENJSON</li>
<li>OPENROWSET</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable">@json</span> NVARCHAR(MAX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@json</span> <span class="operator">=</span> BulkColumn</span><br><span class="line"><span class="keyword">from</span> OPENROWSET (BULK <span class="string">&#x27;D:/MyTemp/zips.json&#x27;</span>, SINGLE_CLOB) <span class="keyword">as</span> j</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> test</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> OPENJSON(<span class="variable">@json</span>)</span><br><span class="line"><span class="keyword">with</span> (</span><br><span class="line">    id <span class="type">int</span> <span class="string">&#x27;strict $._id&#x27;</span>,</span><br><span class="line">    city nvarchar(<span class="number">30</span>) <span class="string">&#x27;$.city&#x27;</span>,</span><br><span class="line">    locx <span class="type">float</span> <span class="string">&#x27;$.loc[0]&#x27;</span>,</span><br><span class="line">    locy <span class="type">float</span> <span class="string">&#x27;$.loc[1]&#x27;</span>,</span><br><span class="line">    pop <span class="type">int</span> <span class="string">&#x27;$.pop&#x27;</span>,</span><br><span class="line">    state <span class="type">char</span>(<span class="number">10</span>) <span class="string">&#x27;$.state&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>导入数据库之后便可以使用之前简单的查询方式执行了</li>
</ul>
<h4 id="简单查询">简单查询</h4>
<h5 id="查询-1">查询 1</h5>
<ul>
<li>简单查看数据库有多少行</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> test</span><br><span class="line"><span class="comment">-- 29353</span></span><br></pre></td></tr></table></figure>
<h5 id="查询-2">查询 2</h5>
<ul>
<li>查询前 6 条记录
<ul>
<li>SQL Server 不支持 limit，使用 top 查询</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">6</span> <span class="operator">*</span> <span class="keyword">from</span> test</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/22/DB/SQLServer/json.practice/image-20210623130431989.png"></p>
<h5 id="查询-3">查询 3</h5>
<ul>
<li>统计不同状态（state）的条目</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> state, <span class="built_in">count</span>(<span class="operator">*</span>) num</span><br><span class="line"><span class="keyword">from</span> test</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> state</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> num <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>结果如下
<ul>
<li>一共有 51 种状态</li>
<li>其中最多的是 TX（1671条），最少的是 DC（24）条</li>
<li>（条目太多了，这里只显示首尾几条）</li>
</ul></li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">state      num</span><br><span class="line">---------- -----------</span><br><span class="line">TX                1671</span><br><span class="line">NY                1595</span><br><span class="line">CA                1516</span><br><span class="line">PA                1458</span><br><span class="line">...                ...</span><br><span class="line">HI                  80</span><br><span class="line">RI                  69</span><br><span class="line">DE                  53</span><br><span class="line">DC                  24</span><br><span class="line"></span><br><span class="line">(51 行受影响)</span><br></pre></td></tr></table></figure>
<h5 id="查询-4">查询 4</h5>
<ul>
<li>找到 pop 值最大的 6 个城市</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">6</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> test</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> pop <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>pop 值最大的是 CHICAGO，值为 112047</li>
</ul>
<p><img src="/2021/06/22/DB/SQLServer/json.practice/image-20210623132642510.png"></p>
<h3 id="读成-json-格式">读成 json 格式</h3>
<ul>
<li>新建数据表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test2 (</span><br><span class="line">    info nvarchar(max)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>将每一条按照 json 的格式读入</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable">@json</span> nvarchar(max)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@json</span> <span class="operator">=</span> BulkColumn</span><br><span class="line"><span class="keyword">from</span> OPENROWSET (BULK <span class="string">&#x27;D:/MyTemp/zips.json&#x27;</span>, SINGLE_CLOB) <span class="keyword">as</span> j</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> test2</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">value</span> <span class="keyword">as</span> info</span><br><span class="line"><span class="keyword">from</span> OPENJSON(<span class="variable">@json</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>重复上面的查询</li>
</ul>
<h5 id="查询-1-1">查询 1</h5>
<ul>
<li>简单查看数据库有多少行</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> test2</span><br><span class="line"><span class="comment">-- 29353</span></span><br></pre></td></tr></table></figure>
<h5 id="查询-2-1">查询 2</h5>
<ul>
<li>查询前 6 条记录</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">6</span> <span class="operator">*</span> <span class="keyword">from</span> test2</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/22/DB/SQLServer/json.practice/image-20210623135414634.png"></p>
<h5 id="查询-3-1">查询 3</h5>
<ul>
<li>统计不同状态（state）的条目</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">JSON_VALUE</span>(info, <span class="string">&#x27;$.state&#x27;</span>) state, <span class="built_in">count</span>(<span class="operator">*</span>) num</span><br><span class="line"><span class="keyword">from</span> test2</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="built_in">JSON_VALUE</span>(info, <span class="string">&#x27;$.state&#x27;</span>)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> num <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>结果是一样的，不过由于格式的原因，显示出来看起来很奇怪</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">state      num</span><br><span class="line"><span class="comment">---------- -----------</span></span><br><span class="line">TX                <span class="number">1671</span></span><br><span class="line">NY                <span class="number">1595</span></span><br><span class="line">CA                <span class="number">1516</span></span><br><span class="line">PA                <span class="number">1458</span></span><br><span class="line">...                ...</span><br><span class="line">HI                  <span class="number">80</span></span><br><span class="line">RI                  <span class="number">69</span></span><br><span class="line">DE                  <span class="number">53</span></span><br><span class="line">DC                  <span class="number">24</span></span><br><span class="line"></span><br><span class="line">(<span class="number">51</span> 行受影响)</span><br></pre></td></tr></table></figure>
<ul>
<li>以上的查询方法很慢</li>
<li>优化查询如下（输出是一样的）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> state, <span class="built_in">count</span>(<span class="operator">*</span>) num</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">JSON_VALUE</span>(info, <span class="string">&#x27;$.state&#x27;</span>) state</span><br><span class="line">    <span class="keyword">from</span> test2</span><br><span class="line">) M</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> state</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> num <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<h5 id="查询-4-1">查询 4</h5>
<ul>
<li>找到 pop 值最大的 6 个城市</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">6</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> test2</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">JSON_VALUE</span>(info, <span class="string">&#x27;$.pop&#x27;</span>) <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/22/DB/SQLServer/json.practice/image-20210623140626496.png"></p>
<ul>
<li>格式化输出如下
<ul>
<li>注意这里需要使用 cast 把 pop 转化为
int，否在会被当作字符串，排序失效</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">6</span> city, pop</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">JSON_VALUE</span>(info, <span class="string">&#x27;$.city&#x27;</span>) city, <span class="built_in">cast</span>(<span class="built_in">JSON_VALUE</span>(info, <span class="string">&#x27;$.pop&#x27;</span>) <span class="keyword">as</span> <span class="type">int</span>) pop</span><br><span class="line">    <span class="keyword">from</span> test2</span><br><span class="line">) M</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> pop <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB.SQLServer</category>
      </categories>
      <tags>
        <tag>DB</tag>
        <tag>SQL</tag>
        <tag>SQLServer</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.00.说明</title>
    <url>/2021/03/24/DB/CLJ/00/</url>
    <content><![CDATA[<h1 id="说明">1. 说明</h1>
<ul>
<li>课程：《数据库概论》</li>
<li>授课老师：陈立军</li>
</ul>
]]></content>
      <categories>
        <category>0</category>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.01.数据库系统简介</title>
    <url>/2021/03/24/DB/CLJ/01/</url>
    <content><![CDATA[<h1 id="数据库系统简介">数据库系统简介</h1>
<ul>
<li><strong>数据项</strong>：数据记录中最小的、不可分的有名数据单位（姓名、性别）</li>
<li><strong>数据元素</strong> 由若干个数据项组成</li>
<li><strong>数据与信息</strong>
<ul>
<li>数据是信息的符号表示，或称载体</li>
<li>信息是数据的内涵，是数据的语义解释</li>
</ul></li>
</ul>
<h2 id="数据结构">数据结构</h2>
<ul>
<li>按照逻辑关系组织起来的一批数据，按一定的存储方法把它存储在计算机中，并在这些数据上定义了一个运算的集合</li>
<li><strong>逻辑结构</strong>：数据之间存在的逻辑关系
<ul>
<li>表、树、图</li>
</ul></li>
<li><strong>物理结构</strong>：数据在计算机内的存储方式
<ul>
<li>顺序方式、链接方式</li>
</ul></li>
</ul>
<h2 id="数据类型">数据类型</h2>
<ul>
<li>具有相同数据结构的数据属同一类，同一类数据的全体称为一个数据类型</li>
<li>数据类型说明了数据在数据分类中的<strong>归属</strong>，用以限定该数据的<strong>变化范围</strong></li>
</ul>
<h3 id="数据类型分类">数据类型分类</h3>
<p><img src="/2021/03/24/DB/CLJ/01/1616586993177.png"></p>
<ul>
<li><strong>数据结构＋算法＝程序</strong></li>
</ul>
<h2 id="数据独立性">数据独立性</h2>
<ul>
<li>当数据结构发生变化时，通过系统提供的映象（转换）功能，使应用程序不必改变</li>
<li><strong>物理独立性</strong>：当数据<strong>存储结构</strong>发生变化时，使应用程序不必改变</li>
<li><strong>逻辑独立性</strong>：当数据<strong>逻辑结构</strong>发生变化时，使应用程序不必改变</li>
</ul>
<h2 id="数据管理">数据管理</h2>
<ul>
<li>数据定义、数据操作、数据约束</li>
<li><strong>数据定义</strong>
<ul>
<li>逻辑结构、物理结构等</li>
</ul></li>
<li><strong>数据操作</strong>
<ul>
<li>查询、更新等</li>
</ul></li>
<li><strong>数据约束</strong>
<ul>
<li>对客观事物的合理反映、数据一致性等</li>
</ul></li>
<li>数据独立性的实现视角：将数据管理从应用程序中剥离出来</li>
<li><strong>数据管理</strong>：对数据的分类、组织、编码、存储、检索和维护</li>
</ul>
<p><img src="/2021/03/24/DB/CLJ/01/1616587588951.png" style="zoom:80%;"></p>
<h2 id="数据管理的发展阶段">数据管理的发展阶段</h2>
<ul>
<li>各阶段的技术及应用背景
<ul>
<li>计算机应用范围</li>
<li>外存储设备</li>
<li>数据管理软件</li>
</ul></li>
<li>各个阶段的差别体现
<ul>
<li>谁管理数据</li>
<li>数据面向谁</li>
<li>数据与应用的独立性</li>
</ul></li>
</ul>
<h3 id="人工管理阶段">人工管理阶段</h3>
<ul>
<li><strong>计算机主要用于科学计算</strong>
<ul>
<li>数据量小、结构简单，如高阶方程、曲线拟和等</li>
</ul></li>
<li><strong>外存为顺序存取设备</strong>
<ul>
<li>磁带、卡片、纸带</li>
</ul></li>
<li>磁带的特点
<ul>
<li>廉价地存放大容量数据</li>
<li>顺序访问；1%所需，100%访问</li>
</ul></li>
<li><strong>没有操作系统，没有数据管理软件</strong>
<ul>
<li>用户用<strong>机器指令编码</strong>，<strong>通过纸带机输入程序和数据</strong>，程序运行完毕后，由用户取走纸带和运算结果，再让下一用户上机操作</li>
</ul></li>
<li><strong>用户完全负责数据管理工作</strong>
<ul>
<li>数据的组织、存储结构、存取方法、输入输出等</li>
</ul></li>
<li><strong>数据完全面向特定的应用程序</strong>
<ul>
<li>每个用户使用自己的数据，数据不保存，用完就撤走</li>
</ul></li>
<li><strong>数据与程序没有独立性</strong>
<ul>
<li>存取数据的子程序随着存储结构的改变而改变</li>
</ul></li>
</ul>
<h3 id="文件系统阶段">文件系统阶段</h3>
<ul>
<li><strong>计算机不但用于科学计算，还用于管理</strong></li>
<li><strong>外存有了磁盘、磁鼓等直接存取设备</strong>
<ul>
<li>无须顺序存取</li>
<li>由地址直接访问所需记录</li>
</ul></li>
<li><strong>产生了操作系统</strong>
<ul>
<li>管理和控制计算机软硬件资源的计算机程序</li>
</ul></li>
<li>文件系统的<strong>功能</strong>
<ul>
<li>文件存储空间的管理</li>
<li>目录管理</li>
<li>文件读写管理</li>
<li>文件保护</li>
<li>向用户提供操作接口</li>
</ul></li>
<li><strong>文件系统解放了用户对外存的访问</strong></li>
<li>文件系统提供了一定的物理独立性</li>
<li>文件系统的 <strong>数据定义独立性</strong>
<ul>
<li><strong>数据与程序紧密结合</strong>
<ul>
<li>数据的逻辑结构改变则必须修改应用程序</li>
</ul></li>
<li><strong>数据分散管理</strong>
<ul>
<li>许多文件，许多数据格式</li>
</ul></li>
<li><strong>数据的语义信息只能由程序来解释</strong>
<ul>
<li>数据的组织方式以及按何种含义进行处理，只有全权管理它的程序知道</li>
</ul></li>
<li><strong>数据共享困难</strong>
<ul>
<li>一个应用若想共享另一个应用生成的数据，必须同另一个应用沟通，了解数据的语义与组织方式</li>
</ul></li>
</ul></li>
<li>文件系统的 <strong>数据完整性独立性</strong>
<ul>
<li>由于数据存在很多<strong>副本</strong>，给数据的修改与维护带来了困难，容易造成数据的不一致性</li>
<li><strong>数据完整性难于维护</strong></li>
</ul></li>
<li>文件系统的 <strong>数据操作独立性</strong>
<ul>
<li>记录之间无联系</li>
<li>用户自己编程实现</li>
<li>对每个查询都重新编码</li>
</ul></li>
<li><strong>困难的本质</strong>
<ul>
<li>文件系统眼中的数据：<strong>字符流</strong></li>
<li>面对一串字符流，要从中找到目标对象，你需要对其解析、遍历、匹配等</li>
</ul></li>
<li>基于文件系统的查询
<ul>
<li>分别组织几个文件，存储各类对象的记录</li>
<li>ad hoc query</li>
</ul></li>
<li>基于文件系统维护数据完整性
<ul>
<li>insert，delete</li>
<li>很复杂，需要修改大量文件</li>
<li>容易出错</li>
</ul></li>
</ul>
<h3 id="数据库系统阶段">数据库系统阶段</h3>
<ul>
<li><strong>外存有了大容量磁盘，光盘</strong></li>
<li><strong>数据管理需求旺盛</strong>
<ul>
<li>数据量大，关系复杂，共享性要求强（多种应用、不同语言共享数据）</li>
</ul></li>
<li>软件相对于硬件：从 Feature 到 future
<ul>
<li>软件价格上升，硬件价格下降，编制和维护软件及应用程序成本相对增加，其中维护的成本更高，力求降低</li>
</ul></li>
<li>数据<strong>不是依赖于处理过程的附属品</strong>，而是现实世界中<strong>独立存在的对象</strong></li>
</ul>
<h4 id="数据库系统阶段的特点">数据库系统阶段的特点</h4>
<ul>
<li>有了数据库管理系统</li>
<li>面向全组织，面向现实世界</li>
<li>独立性较强</li>
<li>由 DBMS 统一存取，维护数据语义及结构
<ul>
<li>DBMS：DataBase Management System ，数据库管理系统</li>
</ul></li>
<li><strong>面向全组织的数据结构</strong>
<ul>
<li>支持<strong>全企业的应用</strong>而<strong>不是某一个应用</strong></li>
<li>数据反映了客观事物间的<strong>本质联系</strong>，而不是着眼于面向某个应用，是有结构的数据</li>
<li><strong>文件系统</strong>只是记录的<strong>内部有结构</strong>，一个文件的记录之间是个线性序列，<strong>记录之间无联系</strong></li>
<li>数据库系统眼中的数据：<strong>结构化数据</strong></li>
</ul></li>
<li><strong>数据的冗余度小，易扩充</strong>
<ul>
<li><strong>冗余度小</strong>
<ul>
<li>数据面向整个系统，而不是面向某一应用，数据集中管理，数据共享</li>
</ul></li>
<li><strong>集中管理</strong>
<ul>
<li>节省存储空间，减少存取时间，避免数据之间的不相容性和不一致性</li>
</ul></li>
<li><strong>易扩充性</strong>
<ul>
<li>每个应用选用数据库的一个子集，只要重新选取不同子集或者加上一小部分数据，就可以满足新的应用要求</li>
</ul></li>
</ul></li>
<li>数据库的<strong>高数据独立性</strong>
<ul>
<li>把数据库定义和描述从应用程序中分离出去</li>
<li>数据描述是分级的（全局逻辑、局部逻辑、存储）</li>
<li>数据存取由系统管理，用户不必考虑存取路径等细节，从而简化了应用程序(SQL)</li>
</ul></li>
<li><strong>统一的数据控制功能</strong>
<ul>
<li>安全性控制（Security）
<ul>
<li>保护数据以防止不合法的使用所造成的数据泄露和破坏</li>
<li>措施：用户标识与鉴定，存取控制</li>
</ul></li>
<li>完整性控制（Integrity）
<ul>
<li>数据的正确性、有效性、相容性</li>
<li>措施：完整性约束条件定义和检查</li>
</ul></li>
<li>并发控制（Concurrency）
<ul>
<li>对多用户并发操作加以控制，防止其互相干扰而得到错误的结果并使数据库完整性遭到破坏</li>
<li>措施：封锁</li>
</ul></li>
<li>恢复控制（Recovery）
<ul>
<li>将数据库从故障中恢复到某个一致状态</li>
<li>措施：冗余</li>
</ul></li>
</ul></li>
</ul>
<h3 id="数据库与文件系统的对比">数据库与文件系统的对比</h3>
<p><img src="/2021/03/24/DB/CLJ/01/1616589550344.png" style="zoom: 67%;"></p>
<h2 id="数据模型">数据模型</h2>
<ul>
<li>数据建模过程
<ul>
<li>用户 -- 计算机</li>
<li>现实世界 --（概念化）-- 信息世界 -- （形式化）-- 计算机世界</li>
<li>应用 -- 概念数据模型 -- 结构数据模型</li>
</ul></li>
</ul>
<h3 id="数据模型定义">数据模型定义</h3>
<ul>
<li><strong>数据模型</strong>：数据库系统中用于提供信息表示和操作手段的形式构架</li>
</ul>
<h4 id="概念数据模型">概念数据模型</h4>
<ul>
<li>按<strong>用户的观点</strong>来对数据和信息建模</li>
<li>用于组织信息世界的概念，表现从现实世界中抽象出来的事物以及它们之间的联系</li>
<li>这类模型<strong>强调其语义表达能力</strong>，概念简单、清晰，易于用户理解</li>
<li>概念数据模型是<strong>现实世界到信息世界的抽象</strong>，是用户与数据库设计人员之间进行交流的语言</li>
<li>例子
<ul>
<li><strong>E/R 模型</strong>：实体、联系、属性</li>
<li><strong>ODL</strong>：属性、管线、类</li>
</ul></li>
</ul>
<h4 id="结构数据模型">结构数据模型</h4>
<ul>
<li>从<strong>计算机实现</strong>的观点来对数据建模
<ul>
<li>是信息世界中的概念和联系在计算机世界中的表示方法</li>
</ul></li>
<li>有严格形式化定义，以便于在计算机上实现
<ul>
<li>层次模型、网状模型、关系模型、面向对象模型</li>
</ul></li>
<li>结构数据模型的三要素
<ul>
<li><strong>数据结构、数据操作、数据约束条件</strong></li>
</ul></li>
<li><strong>数据结构</strong>：描述系统的<strong>静态特性</strong>，即组成数据库的对象类型
<ul>
<li><strong>数据本身</strong>：类型、内容、性质。如关系模型中的域、属性，关系等</li>
<li>数据之间的<strong>联系</strong>。如关系模型中的外码</li>
<li>一般按数据结构的类型来<strong>命名</strong>数据模型</li>
</ul></li>
<li><strong>数据操作</strong>：描述系统的<strong>动态特性</strong>
<ul>
<li>一般有检索、更新（插入、删除、修改）操作</li>
<li>数据模型要定义操作含义、操作符号、操作规则，以及实现操作的语言</li>
</ul></li>
<li><strong>数据约束条件</strong>：完整性规则的集合
<ul>
<li>规定数据库状态及状态变化所应满足的<strong>条件</strong></li>
<li>保证数据的正确、有效、相容</li>
</ul></li>
</ul>
<h5 id="层次模型">层次模型</h5>
<ul>
<li>用<strong>树</strong>结构表示实体之间联系</li>
<li>树由<strong>结点</strong>和<strong>连线</strong>组成
<ul>
<li>结点：实体型</li>
<li>连线：两实体型间的一对多联系</li>
</ul></li>
<li>树的特性
<ul>
<li>每棵树有且仅有一个结点无父结点，称为树的根</li>
<li>树中的其它结点都有且仅有一个父结点</li>
</ul></li>
<li>层次模型的特点
<ul>
<li><strong>结构简单，易于实现</strong></li>
<li><strong>支持的联系种类太少</strong>
<ul>
<li>只支持<strong>二元</strong>一对多联系</li>
<li>只允许实体集间的<strong>一种</strong>联系，不支持实体集间的多种联系</li>
</ul></li>
<li><strong>数据操纵不方便</strong>
<ul>
<li>子结点的存取只能通过父结点来进行</li>
<li>插入、删除复杂，父结点的删除导致子结点的删除，丢失必要的信息</li>
</ul></li>
</ul></li>
<li>代表产品：IBM 的 <strong>IMS 数据库</strong>，<strong>1969</strong>
年研制成功</li>
<li>IMS 的数据存储
<ul>
<li><strong>邻接法</strong>：自顶向下、自左向右排列（<strong>层次遍历</strong>）</li>
<li><strong>层次序列法</strong>：自顶向下、自左向右链接（<strong>中序遍历</strong>）</li>
<li><strong>子女-兄弟指引元法</strong>：指向最大的子女，指向最近的兄弟（每个结点包括数据域、两个指针）</li>
</ul></li>
</ul>
<h5 id="网状模型">网状模型</h5>
<ul>
<li>是一个满足下列条件的<strong>有向图</strong>
<ul>
<li>可以有一个以上的结点无父结点</li>
<li>至少有一个结点有多于一个的父结点（排除树）</li>
</ul></li>
<li>存储结构
<ul>
<li>通过<strong>指针</strong>表达联系</li>
</ul></li>
<li>特点
<ul>
<li>表达的联系种类丰富</li>
<li>性能良好，存取效率高</li>
<li>结构复杂，语言复杂</li>
</ul></li>
<li>典型代表：IDMS，IMAGE</li>
</ul>
<h5 id="关系模型">关系模型</h5>
<ul>
<li>用<strong>二维表</strong>来表示实体及其相互联系</li>
<li><strong>特点</strong>
<ul>
<li><strong>简单</strong>：表的概念直观、单一，用户易理解</li>
<li><strong>非过程化的数据请求</strong>：数据请求可以不指明路径</li>
<li><strong>数据独立性高</strong>：用户只需提出”做什么”，无须说明
“怎么做”</li>
<li><strong>坚实的理论基础</strong>：（曾经的）效率低</li>
</ul></li>
</ul>
<h5 id="面向对象模型">面向对象模型</h5>
<ul>
<li><strong>嵌套表</strong>：用嵌套表表示<strong>复杂实体</strong>（我的类型我定义）
<ul>
<li><strong>平面表</strong>：把嵌套表展开</li>
</ul></li>
</ul>
<h2 id="数据库模式">数据库模式</h2>
<h3 id="元数据">元数据</h3>
<ul>
<li><strong>元数据</strong>（meta-data)：描述数据的数据
<ul>
<li>描述数据的含义和性质，以便更好地理解、管理和使用数据的数据，信息检索的入口</li>
</ul></li>
<li>例子</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">数据</th>
<th style="text-align: center;">元数据</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">数据库概论</td>
<td style="text-align: center;">课程名</td>
</tr>
<tr class="even">
<td style="text-align: center;">《数据库系统概念》</td>
<td style="text-align: center;">参考教材</td>
</tr>
</tbody>
</table>
<h3 id="数据库模式-1">数据库模式</h3>
<ul>
<li><strong>模式</strong>：数据的抽象，数据的描述
<ul>
<li>模式：数据管理的基石</li>
</ul></li>
<li><strong>数据字典</strong>：存取和管理数据的依据
<ul>
<li>对于数据模型中的数据对象或者项目的描述的集合</li>
</ul></li>
</ul>
<h4 id="实例与模式的关系">实例与模式的关系</h4>
<p><img src="/2021/03/24/DB/CLJ/01/1616594843050.png" style="zoom:67%;"></p>
<ul>
<li><strong>型</strong>，<strong>值</strong></li>
<li>例子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    string address;</span><br><span class="line">&#125;;</span><br><span class="line">person TOM;</span><br></pre></td></tr></table></figure>
<ul>
<li>TOM 是<strong>变量</strong></li>
<li>person 是<strong>其类型</strong></li>
<li>TOM 在某时刻的<strong>值</strong>是<strong>实例</strong></li>
</ul>
<h4 id="数据库模式的分级设计">数据库模式的分级设计</h4>
<ul>
<li>Why
<ul>
<li>提高数据的<strong>物理独立性</strong>和<strong>逻辑独立性</strong></li>
<li>将数据库的用户观点（用户看到的数据库）与数据库的物理方面（实际存储的数据库）区分开来</li>
</ul></li>
</ul>
<h5 id="三级模式">三级模式</h5>
<ul>
<li>由 CODASYL 美国数据系统语言协商会提出</li>
<li>三级模式：<strong>外模式</strong>、<strong>模式</strong>、<strong>存储模式</strong></li>
<li>三级模式之间有<strong>两级映象</strong></li>
</ul>
<p><img src="/2021/03/24/DB/CLJ/01/1616595098025.png" style="zoom: 67%;"></p>
<ul>
<li>外模式（Sub-Schema）
<ul>
<li>用户的<strong>数据视图</strong></li>
<li>数据的<strong>局部逻辑结构</strong>，<strong>模式的子集</strong></li>
</ul></li>
<li>模式（Schema）
<ul>
<li>所有用户的<strong>公共数据视图</strong></li>
<li>数据库中全体数据的<strong>全局逻辑结构</strong>和<strong>特性的描述</strong></li>
</ul></li>
<li>内模式（Storage Schema）
<ul>
<li><strong>存储模式</strong>，数据的<strong>物理结构</strong>及<strong>存储方式</strong></li>
<li>位置、压缩、分区、合并、索引</li>
</ul></li>
</ul>
<h6 id="两级模式映像">两级模式映像</h6>
<ul>
<li>外模式 / 模式映象
<ul>
<li>定义某个外模式和模式之间的对应关系</li>
<li>映象<strong>定义通常包含在各外模式</strong>中</li>
<li>当模式改变时，修改外模式 /
模式映象，使外模式保持不变，从而应用程序可以保持不变，称为数据的<strong>逻辑独立性</strong></li>
</ul></li>
<li>模式 / 内模式映象
<ul>
<li>定义数据逻辑结构与存储结构之间的对应关系</li>
<li>存储结构改变时，修改模式 /
内模式映象，使模式保持不变，从而应用程序可以保持不变，称为数据的<strong>物理独立性</strong></li>
</ul></li>
</ul>
<h2 id="数据库系统的构成">数据库系统的构成</h2>
<p><img src="/2021/03/24/DB/CLJ/01/1616595674183.png" style="zoom:67%;"></p>
<h3 id="几个相关概念">几个相关概念</h3>
<ul>
<li><strong>数据库</strong>
<ul>
<li>数据的集合</li>
<li>由 DBMS 统一管理，多用户共享</li>
</ul></li>
<li><strong>数据库管理系统 DBMS</strong>
<ul>
<li>系统软件，对<strong>数据库</strong>进行统一<strong>管理</strong>和<strong>控制</strong></li>
</ul></li>
<li><strong>数据库系统</strong>
<ul>
<li>带有数据库的整个计算机系统，包括硬件、软件、数据、人员</li>
</ul></li>
</ul>
<h3 id="dbms-的层次结构">DBMS 的层次结构</h3>
<p><img src="/2021/03/24/DB/CLJ/01/1616596572946.png" style="zoom:67%;"></p>
<h3 id="dbms-的数据定义功能">DBMS 的数据定义功能</h3>
<ul>
<li>DDL 语言
<ul>
<li>Data Description Language</li>
<li>描述外模式、模式、内模式（源模式）</li>
</ul></li>
<li>模式翻译程序
<ul>
<li>把源模式翻译成目标模式，存入数据字典中</li>
<li>源模式 --（模式翻译程序）-- 目标模式（保存在数据字典中）</li>
</ul></li>
</ul>
<h3 id="dbms-的数据存取功能">DBMS 的数据存取功能</h3>
<ul>
<li>DML 语言
<ul>
<li>Data manipulation Language</li>
<li>对数据库进行检索、插入、修改、删除</li>
</ul></li>
<li>DML 类型
<ul>
<li><strong>宿主型</strong>：DML不独立使用，嵌入到高级语言（主语言）程序中使用</li>
<li><strong>自含型</strong>：独立使用，交互式命令方式</li>
</ul></li>
<li>DML 语句执行方式
<ul>
<li>宿主型：<strong>预编译和增强编译</strong></li>
<li>自含型：<strong>解释执行</strong></li>
</ul></li>
</ul>
<h3 id="dbms的数据控制功能">DBMS的数据控制功能</h3>
<ul>
<li><strong>数据库运行管理</strong>
<ul>
<li>并发控制、存取控制、完整性约束条件检查和执行，日志组织和管理，事务管理和自动恢复</li>
</ul></li>
<li><strong>数据组织存储和管理</strong>
<ul>
<li>用户数据、索引、数据字典的组织、存储和管理，包括文件结构、存取方式、数据之间联系的实现</li>
</ul></li>
<li><strong>数据库建立和维护功能</strong>
<ul>
<li>数据的装入、转换、卸出</li>
<li>数据库的转储、恢复、性能监视和分析</li>
</ul></li>
</ul>
<h3 id="数据库系统的用户">数据库系统的用户</h3>
<ul>
<li><strong>最终用户</strong>
<ul>
<li>通过应用系统的用户接口（菜单等）使用数据库</li>
</ul></li>
<li><strong>应用程序员</strong>
<ul>
<li>通过应用系统的用户接口（菜单等）使用数据库</li>
</ul></li>
<li><strong>系统分析员</strong>
<ul>
<li>负责应用系统的需求分析和规范定义，确定系统软硬件配置，参与数据库模式设计</li>
</ul></li>
<li><strong>数据库管理员 DBA</strong>
<ul>
<li>负责数据库的全面管理和控制</li>
</ul></li>
</ul>
<h2 id="数据库系统的用户界面">数据库系统的用户界面</h2>
<ul>
<li>面向浏览器的基于菜单的界面</li>
<li>基于表单的界面</li>
<li>图形用户界面</li>
<li>自然语言界面</li>
<li>语音输入和输出</li>
<li>面向DBA的界面</li>
</ul>
<h2 id="dba-的职责">DBA 的职责</h2>
<ul>
<li><strong>建库</strong>
<ul>
<li>确定模式、外模式、存储结构、存取策略</li>
<li>负责数据的整理和装入</li>
</ul></li>
<li><strong>用库</strong>
<ul>
<li>定义完整性约束条件</li>
<li>规定数据的保密级别、用户权限</li>
<li>监督和控制数据库的运行情况</li>
<li>制定后援和恢复策略，负责故障恢复</li>
</ul></li>
<li><strong>改进</strong>
<ul>
<li>监督分析系统的性能（空间利用率，处理效率）</li>
<li>数据库重组织，物理上重组织，以提高性能</li>
<li>数据库重构造，设计上较大改动，模式和内模式修改</li>
</ul></li>
</ul>
<h2 id="数据管理能力成熟度评估模型">数据管理能力成熟度评估模型</h2>
<ul>
<li>DCMM：Data Capability Maturity Model</li>
</ul>
<p><img src="/2021/03/24/DB/CLJ/01/1616597979333.png" style="zoom: 67%;"></p>
<h2 id="数据库的若干研究方向">数据库的若干研究方向</h2>
<ul>
<li>新的数据库管理系统</li>
<li>新的数据库应用</li>
<li>特种数据库</li>
<li>领域数据库</li>
</ul>
<h3 id="新的数据模型">新的数据模型</h3>
<ul>
<li>面向对象数据库</li>
<li>对象-关系数据库</li>
<li>XML数据库</li>
<li>图数据库</li>
<li>序列数据库</li>
<li>数组数据库</li>
<li>矩阵数据库</li>
</ul>
<h3 id="新的体系结构">新的体系结构</h3>
<ul>
<li>分布式数据库
<ul>
<li>网络+数据库，对等(P2P)数据库，集群</li>
</ul></li>
<li>并行数据库
<ul>
<li>数据划分、操作并行</li>
</ul></li>
<li>NoSQL 数据库
<ul>
<li>互联网应用：海量、快速、多样</li>
<li>CAP、存储模型、分区、容错、map/reduce</li>
</ul></li>
<li>数据流管理系统
<ul>
<li>实时监视：传感网络、股市行情、交通状况…</li>
</ul></li>
</ul>
<h3 id="新的硬件平台">新的硬件平台</h3>
<ul>
<li>主存数据库</li>
<li>闪存数据库</li>
<li>嵌入数据库</li>
<li>GPU，FPGA，多核处理器</li>
</ul>
<h3 id="新的数据库应用">新的数据库应用</h3>
<ul>
<li>商业智能
<ul>
<li>从事务型操作转向分析型操作</li>
<li>决策支持：数据仓库、数据挖掘、OLAP</li>
</ul></li>
<li>信息集成
<ul>
<li>“turn the Web into database”</li>
<li>各式信息门户、知识图谱</li>
</ul></li>
<li>社会测量
<ul>
<li>社会媒体，社会网络，推荐系统</li>
</ul></li>
</ul>
<h3 id="移动数据库">移动数据库</h3>
<ul>
<li>分布式数据库的扩展</li>
<li>传感网络、物联网</li>
<li>手机、汽车、PDA...</li>
<li>信息访问的即时性和就地性</li>
<li>移动：数据库+无线网络（偶尔断连）</li>
</ul>
<h3 id="主动数据库">主动数据库</h3>
<ul>
<li><strong>被动服务</strong>：<strong>命令驱动</strong></li>
<li><strong>主动服务</strong>：<strong>事件驱动</strong></li>
<li>实时监控系统：异常情况主动处理 ...</li>
<li>信息推送系统：RSS 新闻聚合服务</li>
<li>大规模触发器、复杂事件处理</li>
</ul>
<h3 id="演绎数据库">演绎数据库</h3>
<ul>
<li>人工智能 + 数据库</li>
<li>专家系统</li>
<li>事实＋推理规则</li>
<li>规则计算：递归查询</li>
</ul>
<h3 id="时态数据库">时态数据库</h3>
<ul>
<li><strong>快照数据库</strong>：只记录实体的<strong>当前信息</strong></li>
<li>管理被处理事件的历史性信息</li>
<li>管理数据库系统中元事件的时态信息</li>
<li>数据仓库的前驱？</li>
</ul>
<h3 id="模糊数据库">模糊数据库</h3>
<ul>
<li>处理模糊对象：高矮胖瘦、好恶优劣…</li>
<li>模糊数学：L.A.Zadeh</li>
<li>模糊隶属函数</li>
<li>模糊专家系统，模拟计算 ......</li>
</ul>
<h3 id="实时数据库">实时数据库</h3>
<ul>
<li>对数据的 “定时” 存取和对 “短暂有效” 数据的存取</li>
<li>工厂生产过程控制、证券交易、雷达跟踪 ...</li>
<li>给数据和事务安装定时装置</li>
<li>基于优先级调度事务的执行</li>
</ul>
<h3 id="概率数据库">概率数据库</h3>
<ul>
<li>关键之一：概率查询的合理定义</li>
<li>关键之二：对 Possible world 的高效搜索算法</li>
</ul>
<h3 id="领域数据库">领域数据库</h3>
<ul>
<li>生物数据库
<ul>
<li>序列、图、高维数据…</li>
</ul></li>
<li>空间数据库
<ul>
<li>几何数据、空间查询</li>
</ul></li>
<li>多媒体数据库</li>
<li>天文数据库：虚拟天文台</li>
<li>CAD数据库
<ul>
<li>面向对象数据库</li>
</ul></li>
</ul>
<h2 id="dbms-的运行过程">DBMS 的运行过程</h2>
<p><img src="/2021/03/24/DB/CLJ/01/1616598580054.png" style="zoom:67%;"></p>
<ul>
<li>Step1：用户向 DBMS
<strong>发出</strong>调用数据库数据的<strong>命令</strong></li>
<li>Step2：DBMS
对命令进行<strong>语法检查、语义检查、存取权限检查</strong>，<strong>决定是否执行该命令</strong></li>
<li>Step3：DBMS
执行<strong>查询优化</strong>，把命令转换为一串单记录的存取操作序列</li>
<li>Step4：<strong>执行存取操作序列</strong>（反复执行以下各步，直至结束）</li>
<li>Step5：DBMS
首先在<strong>缓冲区</strong>内查找记录，若找到转10，否则转6</li>
<li>Step6：DBMS
查看存储模式，决定从<strong>哪个文件存取哪个物理记录</strong></li>
<li>Step7：DBMS 根据 6
的结果，<strong>向操作系统发出读取记录的命令</strong></li>
<li>Step8：<strong>操作系统</strong>执行<strong>读取数据</strong>的命令</li>
<li>Step9：<strong>操作系统</strong>将<strong>数据</strong>从<strong>数据库存储区</strong>送到<strong>系统缓冲区</strong></li>
<li>Step10：DBMS
根据<strong>用户命令</strong>和<strong>数据字典</strong>的内容<strong>导出用户所要读取的数据格式</strong></li>
<li>Step11：DBMS
将数据记录从<strong>系统缓冲区传送到用户工作区</strong></li>
<li>Step12：DBMS将执行状态信息<strong>返回给用户</strong></li>
</ul>
<h2 id="补充内容">补充内容</h2>
<ul>
<li>多维数组的应用场景
<ul>
<li>联机分析处理、多维分析
<ul>
<li>通过关系数据库的多表连接实现，效率比较低</li>
<li>多维数组，数组定位快，但是比较稀疏</li>
</ul></li>
<li>多维数组体现了局部性
<ul>
<li>存储时空数据</li>
<li>通常出现在科研领域：遥感数据、图像数据等</li>
</ul></li>
</ul></li>
<li>搜索引擎查询和数据库查询的区别
<ul>
<li>数据库查询：局部化查询</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.02.ER 模型(2)</title>
    <url>/2021/03/31/DB/CLJ/02-1/</url>
    <content><![CDATA[<h1 id="er-模型">ER 模型</h1>
<h2 id="扩展-er-特性">扩展 ER 特性</h2>
<h3 id="弱实体集">弱实体集</h3>
<h4 id="还款与贷款的关系建立">还款与贷款的关系建立</h4>
<ul>
<li>还款：还款号，还款日期，金额</li>
<li>贷款：贷款号，金额</li>
<li>贷款对应多个还款</li>
</ul>
<h5 id="表示-1把还款作为普通实体">表示 1：把还款作为普通实体</h5>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331100724583.png" style="zoom:67%;"></p>
<ul>
<li>问题：还款的所有属性都不能作为主码
<ul>
<li>不满足实体的条件</li>
</ul></li>
</ul>
<h5 id="表示-2把贷款号借给还款实体">表示 2：把贷款号借给还款实体</h5>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331100814603.png" style="zoom:67%;"></p>
<ul>
<li>问题：贷款号冗余</li>
</ul>
<h5 id="表示-3把还款作为贷款的多值属性">表示
3：把还款作为贷款的多值属性</h5>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331100943794.png" style="zoom:67%;"></p>
<ul>
<li>问题：还款概念消失了
<ul>
<li>还款应当会和帐户发生支付联系</li>
</ul></li>
</ul>
<h5 id="表示-4把还款作为复合属性">表示 4：把还款作为复合属性</h5>
<ul>
<li>图上的还款应该是<strong>两个圈</strong>（复合属性）</li>
</ul>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331101201338.png" style="zoom:67%;"></p>
<ul>
<li>问题：还款作为复合<strong>属性</strong>，不能和帐户（<strong>实体</strong>）发生<strong>联系</strong></li>
</ul>
<h5 id="表示-5还款作为弱实体">表示 5：还款作为弱实体</h5>
<ul>
<li>下图少了个属性（还款日期）</li>
</ul>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331101458616.png" style="zoom:67%;"></p>
<ul>
<li>弱实体的表示
<ul>
<li><strong>两层矩形框</strong></li>
</ul></li>
<li>标识性联系
<ul>
<li><strong>两层菱形框</strong></li>
</ul></li>
</ul>
<h4 id="弱实体集-1">弱实体集</h4>
<ul>
<li>弱实体集（Weak Entity Set）
<ul>
<li>一个实体集的所有属性都不足以形成主码</li>
</ul></li>
<li>标识性联系（identifying relationship）
<ul>
<li>弱实体集与其拥有者之间的联系</li>
<li>弱实体集与强实体集之间是一对多的联系</li>
</ul></li>
<li>弱实体集必然存在依赖于强实体集</li>
<li><strong>存在依赖并不总会导致一个弱实体集</strong>，从属实体集可以有自己的主码</li>
</ul>
<h4 id="弱实体集的分辨符">弱实体集的分辨符</h4>
<ul>
<li>分辨符（Discriminator)
<ul>
<li>弱实体集中用于区别依赖于某个特定强实体集的属性集合，也称作部分码（partial
key)</li>
</ul></li>
<li><strong>弱实体集的主码 = 强实体集的主码+ 弱实体集的分辨符</strong>
<ul>
<li>“还款” 主码＝贷款号＋还款号</li>
</ul></li>
</ul>
<h4 id="弱实体集在-er-图中的表示">弱实体集在 ER 图中的表示</h4>
<ul>
<li><strong>弱实体集</strong>以<strong>双边框的矩形</strong>表示</li>
<li><strong>标识性联系</strong>以<strong>双边框的菱形</strong>表示</li>
<li><strong>弱实体集的分辨符</strong>用<strong>下划虚线</strong>标明</li>
<li>从联系集用<strong>双线（全部参与）</strong>连接弱实体集，用<strong>箭头（一对多联系）</strong>指向强实体集</li>
</ul>
<h4 id="何时引入弱实体集">何时引入弱实体集</h4>
<ul>
<li>作为<strong>层次结构</strong>的一部分
<ul>
<li>cs.pku.edu.cn</li>
</ul></li>
<li>实体集的一些多值、复合属性可以抽取出来作为弱实体集
<ul>
<li>贷款的还款属性</li>
</ul></li>
<li>如果弱实体集不但参与和强实体集之间的标识性联系，而且参与和其它实体集的联系，或者弱实体集本身含有很多属性，则将其表述为弱实体集</li>
</ul>
<h3 id="特化">特化</h3>
<ul>
<li>实体集中某些子集具有区别于该实体集内其它实体的特性，可以根据这些差异特性对实体集进行分组，这一分组的过程称作特化
<ul>
<li>类似细分</li>
</ul></li>
<li><strong>自顶向下</strong>、<strong>逐步求精</strong>的数据库设计过程</li>
<li>子类＝特例＝更小的实体集＝更多的属性</li>
<li>细化：父类 <span class="math inline">\(\to\)</span> 子类</li>
</ul>
<h4 id="特化在-er-图中的表示">特化在 ER 图中的表示</h4>
<ul>
<li>特化用标记为 <strong>ISA</strong> 的三角形来表示
<ul>
<li>ISA = “ isａ”</li>
<li>表示高层实体和低层实体之间的 “父类－子类” 联系</li>
</ul></li>
</ul>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331102621106.png" style="zoom:67%;"></p>
<ul>
<li>特化使得联系的对象更精确
<ul>
<li>可以让一些属性精确定位到子类当中</li>
</ul></li>
</ul>
<h3 id="概化">概化</h3>
<ul>
<li>各个实体集根据共有的性质，合成一个较高层的实体集。概化是一个高层实体集与若干个低层实体集之间的包含关系</li>
<li><strong>自底向上</strong>、<strong>逐步合成</strong>的数据库设计过程</li>
<li>泛化：子类 <span class="math inline">\(\to\)</span> 父类</li>
</ul>
<h4 id="概化与特化对比">概化与特化对比</h4>
<ul>
<li>概化与特化是互逆的，在E-R图中的表示方法相同</li>
<li>特化强调同一实体集内不同实体之间的差异</li>
<li>概化强调不同实体集之间的相似性</li>
<li>反映了数据库设计的不同方法</li>
</ul>
<h4 id="概化中的属性继承">概化中的属性继承</h4>
<ul>
<li>高层实体集的属性被低层实体集自动继承</li>
<li>低层实体集特有的性质仅适用于某个特定的低层实体集</li>
</ul>
<h5 id="两种继承结构">两种继承结构</h5>
<ul>
<li>层次结构（Hierarchy）
<ul>
<li>实体集作为低层实体集只能参与到一个 ISA 联系中</li>
</ul></li>
<li>格结构（Lattice）
<ul>
<li>低层实体集可以参与到多个 ISA 联系中</li>
<li>例如下图中的博士参与了两个 ISA 联系</li>
</ul></li>
</ul>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331103140711.png" style="zoom:67%;"></p>
<ul>
<li>“博士” 继承了 “研究生” 与 “职工” 的所有属性</li>
<li>格结构的问题
<ul>
<li>如果 “研究生” 与 “职工” 有相同名称的属性，如 “姓名”</li>
<li>可以在 “博士” 中用 “研究生.姓名”，“职工.姓名” 区别开来</li>
</ul></li>
</ul>
<h4 id="概化中的成员身份">概化中的成员身份</h4>
<ul>
<li><strong>成员身份</strong>：同一个概化中，一个高层实体<strong>是否可以属于多个</strong>不同低层实体集</li>
</ul>
<h5 id="两种成员身份">两种成员身份</h5>
<ul>
<li>不相交的 (Disjoint)
<ul>
<li>一个实体至多属于一个低层实体集
<ul>
<li>如一个学生只能参加一个项目组</li>
</ul></li>
</ul></li>
<li>有重叠的 (Overlapping)
<ul>
<li>同一实体可同时属于同一概化的多个低层实体集
<ul>
<li>如一个老师可以参加多个项目组</li>
</ul></li>
</ul></li>
</ul>
<h4 id="概化中的全部性约束">概化中的全部性约束</h4>
<ul>
<li><strong>全部性约束</strong>：确定高层实体集中的一个实体<strong>是否必须属于至少一个</strong>低层实体集</li>
</ul>
<h5 id="两种全部性约束">两种全部性约束</h5>
<ul>
<li>全部的 (Total)
<ul>
<li>每个高层实体必须属于一个低层实体集
<ul>
<li>如学生必须属于本科生或研究生的一种</li>
</ul></li>
<li>ER 图的设计中，一般用<strong>双线</strong>连接 ISA</li>
</ul></li>
<li>部分的 (Partial)
<ul>
<li>允许一些高层实体不属于任何低层实体集
<ul>
<li>如学生可以不属于任何项目组</li>
</ul></li>
</ul></li>
</ul>
<h3 id="聚集">聚集</h3>
<ul>
<li>如何表达联系之间的联系</li>
<li>某些联系之间存在重叠</li>
</ul>
<h4 id="实例职工参加项目并在此过程中可能使用机器">实例：职工参加项目，并在此过程中可能使用机器</h4>
<h5 id="表示为三元联系">表示为三元联系</h5>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331104250886.png" style="zoom:67%;"></p>
<ul>
<li>问题
<ul>
<li>作为三元联系，有些职工并不和机器发生联系</li>
<li>不雅驯的命名对于 ER 是个大问题</li>
</ul></li>
</ul>
<h5 id="表示为二元联系">表示为二元联系</h5>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331104412625.png" style="zoom:70%;"></p>
<ul>
<li>问题
<ul>
<li>看不出来职工在项目 A 使用什么机器</li>
</ul></li>
</ul>
<h4 id="聚集-1">聚集</h4>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331104555488.png" style="zoom:67%;"></p>
<ul>
<li>一个看上去的三元联系实则是<strong>两个动作序列</strong></li>
<li>实体集 A 与 B 以及它们的联系可被看成实体集，然后与另一实体集 C
发生联系</li>
<li><strong>聚集是一种抽象</strong>
<ul>
<li>通过聚集联系被抽象为高层实体集</li>
</ul></li>
</ul>
<h2 id="er-模型设计要点">ER 模型设计要点</h2>
<h3 id="er-模型设计中的选择问题">ER 模型设计中的选择问题</h3>
<ul>
<li>实体 / 属性</li>
<li>实体 / 联系</li>
<li>二元 / 多元</li>
<li>聚集 / 三元</li>
</ul>
<h4 id="如何选择">如何选择</h4>
<ul>
<li>目标</li>
<li>利弊</li>
</ul>
<h3 id="实体-属性">实体 / 属性</h3>
<ul>
<li>实体有多方面性质，属性没有</li>
<li>属性通常是<strong>原子性</strong>的</li>
</ul>
<h3 id="实体-联系">实体 / 联系</h3>
<ul>
<li>实体与联系：静态与动态</li>
<li>联系的属性一般是动态的，否则可以抽象成一个（弱）实体</li>
</ul>
<h3 id="二元-多元">二元 / 多元</h3>
<ul>
<li>多元到二元的瓠瓜式通用转换方式
<ul>
<li>新构建一个<strong>标识实体集</strong> <span class="math inline">\(E\)</span>，构造三个新联系集 <span class="math inline">\(R_A\)</span>，<span class="math inline">\(R_B\)</span>，<span class="math inline">\(B_C\)</span>，对每个 <span class="math inline">\((a_i,b_i,c_i)\in R\)</span>，在 <span class="math inline">\(E\)</span> 中创建一个 <span class="math inline">\(e_i\)</span>，然后在 <span class="math inline">\(R_A\)</span>，<span class="math inline">\(R_B\)</span>，<span class="math inline">\(B_C\)</span> 中分别加入联系 <span class="math inline">\((e_i,a_i)\)</span>， <span class="math inline">\((e_i,b_i)\)</span>， <span class="math inline">\((e_i,c_i)\)</span></li>
<li>但是这样子没有实际意义，单纯是一个标识</li>
</ul></li>
</ul>
<h3 id="能否用实体之间的二元联系替换三元联系">能否用实体之间的二元联系替换三元联系</h3>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331110718065.png" style="zoom:67%;"></p>
<ul>
<li>多出来其他的元素 (4,2,3)</li>
<li>一般情况下很难</li>
</ul>
<h3 id="聚集-三元">聚集 / 三元</h3>
<h4 id="实例">实例</h4>
<ul>
<li>一个项目由多个部门资助，一个部门资助多个项目，每个资助协议由一个或多个雇员监督
<ul>
<li>监督有属性截至时间，资助有属性起始时间</li>
</ul></li>
<li>三元联系
<ul>
<li>不明确，如果资助和监督有自己的属性则不能明确表示属性是属于资助的还是监督的</li>
<li>用词奇怪</li>
</ul></li>
</ul>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331110934320.png" style="zoom:67%;"></p>
<ul>
<li>聚集</li>
</ul>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331111102199.png" style="zoom:67%;"></p>
<h2 id="概念数据库设计过程">概念数据库设计过程</h2>
<h3 id="总体流程">总体流程</h3>
<pre class="mermaid">graph LR;
A[需求分析结果];
B[局部 ER 模式设计];
C[全局 ER 模式设计];
D[全局 ER 模式优化];
A--->B--->C--->D;</pre>
<h3 id="局部-er-模式设计">局部 ER 模式设计</h3>
<pre class="mermaid">graph LR;
B[确定局部结构范围];
C[实体定义];
D[联系定义];
E[属性分配];
subgraph 局部 ER 模式设计
B--->C--->D--->E;
end</pre>
<h3 id="全局-er-模式设计">全局 ER 模式设计</h3>
<pre class="mermaid">graph LR;
B[确定公共实体类型];
C[合并两个局部 ER 模式];
D[检查并消除冲突];
E{是否还有未合并的局部模式};
F[全局 ER 模式优化];
subgraph 全局 ER 模式设计
B--->C--->D--->E;
E--->|有|C;
end
E--->|无|F;</pre>
<h4 id="消除冲突">消除冲突</h4>
<h5 id="属性冲突">属性冲突</h5>
<ul>
<li><strong>属性域的冲突</strong></li>
<li><strong>属性的类型、取值范围不同</strong>
<ul>
<li>如不同学校的学号编码方式不同</li>
</ul></li>
<li><strong>属性取值单位冲突</strong>
<ul>
<li>如重量分别采用磅、千克</li>
</ul></li>
</ul>
<h5 id="命名冲突">命名冲突</h5>
<ul>
<li><strong>同名异义</strong>
<ul>
<li>不同意义的对象具有相同的名字</li>
</ul></li>
<li><strong>异名同义</strong>
<ul>
<li>同一意义的对象具有不同的名字</li>
</ul></li>
</ul>
<h5 id="结构冲突">结构冲突</h5>
<ul>
<li>同一对象在不同应用中的抽象不同
<ul>
<li>职工在某应用中是实体，在另一应用中则抽象为属性</li>
</ul></li>
<li>同一实体在不同 ER 图中属性组成不同
<ul>
<li>有的职工实体有 email，有的职工实体则没有</li>
</ul></li>
<li>实体之间的联系在不同 ER 图中呈现不同的类型
<ul>
<li>联系种类不同</li>
<li>参与联系的实体不同</li>
</ul></li>
</ul>
<h3 id="全局-er-模式优化">全局 ER 模式优化</h3>
<pre class="mermaid">graph LR;
subgraph 全局 ER 模式优化
B[合并实体类型];
C[消除冗余属性];
D[消除冗余联系];
B--->C--->D;
end
E[逻辑数据库设计]
D--->E;</pre>
<h2 id="er-模型向关系模式的转换">ER 模型向关系模式的转换</h2>
<ul>
<li>ER 模型：概念数据模型</li>
<li>关系模式：结构数据模型</li>
</ul>
<h3 id="实体">实体</h3>
<ul>
<li>每个实体一张表</li>
<li>实体 <span class="math inline">\(\to\)</span> 关系</li>
<li>属性 <span class="math inline">\(\to\)</span> 关系的属性</li>
</ul>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331114247389.png" style="zoom:67%;"></p>
<h3 id="复合属性">复合属性</h3>
<ul>
<li>将每个组合属性作为复合属性所在实体的属性
<ul>
<li>复合属性拆解为原子属性</li>
</ul></li>
<li>复合属性定义为视图，或由应用定义</li>
</ul>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331114423388.png" style="zoom:67%;"></p>
<h3 id="多值属性">多值属性</h3>
<ul>
<li>多值属性 <span class="math inline">\(\to\)</span> 新的关系 +
所在实体的码</li>
<li>单独放在一个表里，避免出现冗余</li>
</ul>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331114552570.png" style="zoom:67%;"></p>
<h3 id="联系">联系</h3>
<h4 id="一对多联系">一对多联系</h4>
<ul>
<li>将单方参与实体的码作为多方参与实体的属性</li>
</ul>
<h5 id="实例-1">实例</h5>
<ul>
<li>教师：教工号、姓名</li>
<li>学生：学生号、姓名</li>
</ul>
<pre class="mermaid">graph RL;
A[教师];
B{导师};
C[学生];
C---B--->A</pre>
<ul>
<li>直接多开一个表存教工和学生之间的联系
<ul>
<li>有些浪费</li>
</ul></li>
<li>简单的关系表</li>
</ul>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331114846206.png" style="zoom:70%;"></p>
<h4 id="多对多联系">多对多联系</h4>
<ul>
<li>将联系定义为新的关系，属性为参与双方的码</li>
</ul>
<h5 id="实例-2">实例</h5>
<pre class="mermaid">graph LR;
A[学生];
B{选修};
C[课程];
A---B---C;</pre>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210331115240634.png" style="zoom:67%;"></p>
<h4 id="一对一联系">一对一联系</h4>
<ul>
<li>若联系双方均部分参与，则将联系定义为一个新的关系，属性为参与双方的码
<ul>
<li>新建一个表</li>
</ul></li>
<li>若联系一方全部参与，则将联系另一方的码作为全部参与一方的属性
<ul>
<li>看成特殊的一对多联系</li>
</ul></li>
</ul>
<h3 id="弱实体">弱实体</h3>
<ul>
<li>弱实体集所对应的关系的码由<strong>弱实体集本身的分辩符</strong>再加上<strong>所依赖的强实体集的码</strong></li>
<li>弱实体集一个表，同时加上其所依赖的强实体的一个码</li>
</ul>
<h4 id="例题">例题</h4>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210402170643926.png" style="zoom:67%;"></p>
<ul>
<li>关系表有 3 个
<ul>
<li>C（c，f）</li>
<li>B（b，c，e）</li>
<li>A（a，b，c，d）</li>
</ul></li>
</ul>
<h3 id="概括">概括</h3>
<ul>
<li>概化和特化</li>
<li>高层实体集和低层实体集<strong>分别转为表</strong>，低层实体集所对应的关系包括<strong>高层实体集的码</strong>
<ul>
<li>低层实体集记录自己独有的属性，以及高层实体集的一个码</li>
<li>性能上不利的地方：如果需要查询低层实体的某些属性信息时（这些属性属于高层实体集时），需要和高层实体的表做一个连接操作</li>
</ul></li>
<li>如果概括是<strong>不相交</strong>并且是<strong>全部</strong>的，<strong>则可以不为高层实体集建立关系</strong>，低层实体集所对应的关系<strong>包括</strong>上层实体集的的<strong>所有属性</strong>
<ul>
<li>高层实体刚好可以<strong>不重不漏</strong>的划分为低层实体</li>
<li>获取所有高层实体的信息只需要两个表求并即可（求并很快）</li>
</ul></li>
</ul>
<h3 id="聚集-2">聚集</h3>
<ul>
<li>实体集 A 与 B 及其联系 R 被抽象成实体集 C，C 与另一实体集 D 构成联系
S，则 S 的码由 C 和 D 的码构成</li>
<li>具体 C 的码是什么需要分情况考虑（看 S 怎么表示）
<ul>
<li>参考上面的不同联系的码（一对一、多对多、一对多）</li>
</ul></li>
</ul>
<h2 id="逆向工程关系模式向er的转换">逆向工程：关系模式向ER的转换</h2>
<h3 id="例子">例子</h3>
<ul>
<li>描述
<ul>
<li>已知有如下关系模式：R1(<strong>a1</strong>,a2,a3)，R2(<strong>a3</strong>,a4)，R3(<strong>a5</strong>,a6)，R4(<strong>a3</strong>,<strong>a5</strong>,a7)</li>
<li>其中加粗的属性标识为所在关系模式的主码，试画出合适的 ER
图，使得可以将该 ER 图转换为上述关系模式</li>
</ul></li>
<li>关键
<ul>
<li><strong>重合属性体现了实体之间的联系</strong></li>
</ul></li>
<li>答案</li>
</ul>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210402173109921.png" style="zoom:80%;"></p>
<h2 id="er-模型总结">ER 模型总结</h2>
<h3 id="总结">总结</h3>
<ul>
<li>概念模型：人脑中的信息世界</li>
<li>概念模型需要<strong>清晰</strong></li>
<li>数据组织必须契合处理需求</li>
<li>操作型应用：ER 模型</li>
<li>综合分析型应用，ER 模型则不太合适</li>
</ul>
<h3 id="符号总览">符号总览</h3>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210402173229472.png"></p>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210402173718878.png"></p>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210402173728842.png"></p>
<h2 id="uml">UML</h2>
<ul>
<li>UML：Unified Modeling Language</li>
<li>UML 图谱系
<ul>
<li>用例图（use case diagrams）：用户和系统的交互</li>
<li>顺序图（sequence
diagram）：用例中活动者与系统其它模块之间交互的时间顺序图</li>
<li>状态图（state diagram）：系统中不同对象的行为</li>
<li>行为图（activity diagram）：说明行为是如何协同的</li>
<li>协作图（collaboration
diagram）：描述组成一个复杂系统的不同对象之间的交互（即，消息交换）</li>
</ul></li>
</ul>
<h3 id="从-er-模型到-uml">从 ER 模型到 UML</h3>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210402174515751.png"></p>
<p><img src="/2021/03/31/DB/CLJ/02-1/image-20210402174526831.png"></p>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.02.ER 模型(1)</title>
    <url>/2021/03/30/DB/CLJ/02/</url>
    <content><![CDATA[<h1 id="er-模型">ER 模型</h1>
<ul>
<li>实体联系模型</li>
</ul>
<h2 id="数据库设计过程">数据库设计过程</h2>
<h3 id="三阶段数据库设计过程">三阶段数据库设计过程</h3>
<ul>
<li>三阶段：<strong>概念结构设计</strong>、<strong>逻辑结构设计</strong>、<strong>物理结构设计</strong>
<ul>
<li>出发点是基于需求分析</li>
</ul></li>
<li><strong>需求分析</strong>
<ul>
<li>确定存储哪些数据，建立哪些应用，常用的操作及对象有哪些等</li>
</ul></li>
<li><strong>概念数据库设计</strong>
<ul>
<li>对需求分析所得到数据的更高层的抽象描述</li>
<li><strong>ER 模型</strong>、<strong>UML</strong></li>
</ul></li>
<li><strong>逻辑数据库设计</strong>
<ul>
<li>将概念模型所描述的数据映射为某个特定的 DBMS 模式数据</li>
</ul></li>
<li><strong>物理数据库设计</strong></li>
</ul>
<h3 id="四阶段数据库设计过程">四阶段数据库设计过程</h3>
<ul>
<li>把逻辑结构设计进行<strong>细分</strong></li>
<li><strong>概念阶段</strong>
<ul>
<li>发掘实体及其联系</li>
<li>发掘业务规则</li>
</ul></li>
<li><strong>逻辑阶段</strong>
<ul>
<li>规范化设计</li>
</ul></li>
<li><strong>实现阶段</strong>
<ul>
<li>选择数据类型、定义表、约束、触发器</li>
</ul></li>
<li><strong>物理阶段</strong>
<ul>
<li>索引、磁盘组织</li>
</ul></li>
</ul>
<h3 id="不同数据库设计阶段中的术语称谓">不同数据库设计阶段中的术语称谓</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">阶段</th>
<th style="text-align: center;">表术语</th>
<th style="text-align: center;">列术语</th>
<th style="text-align: center;">行术语</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">关系理论</td>
<td style="text-align: center;">关系</td>
<td style="text-align: center;">--</td>
<td style="text-align: center;">元组</td>
</tr>
<tr class="even">
<td style="text-align: center;">概念/逻辑</td>
<td style="text-align: center;">实体</td>
<td style="text-align: center;">属性</td>
<td style="text-align: center;">实例</td>
</tr>
<tr class="odd">
<td style="text-align: center;">实现</td>
<td style="text-align: center;">行集、表</td>
<td style="text-align: center;">列</td>
<td style="text-align: center;">行</td>
</tr>
<tr class="even">
<td style="text-align: center;">物理</td>
<td style="text-align: center;">文件</td>
<td style="text-align: center;">字段</td>
<td style="text-align: center;">记录</td>
</tr>
</tbody>
</table>
<h2 id="er模型基本概念">ER模型基本概念</h2>
<h3 id="er-模型的重要性">ER 模型的重要性</h3>
<ul>
<li>ER：<strong>最佳信息模型</strong>
<ul>
<li>能够很快速的向用户展示内部事务的逻辑</li>
</ul></li>
<li>启示：<strong>把 ER 设计作为数据库设计的第一步</strong></li>
</ul>
<h3 id="er-模型的诞生">ER 模型的诞生</h3>
<ul>
<li>Entity-Relationship Model</li>
<li>1976年，P.P.S.Chen提出 ER 模型，用 ER 图来描述概念模型</li>
<li>ER 模型眼中的世界
<ul>
<li>世界是有一组称作实体的<strong>基本对象</strong>和这些对象之间的<strong>联系</strong>构成的</li>
</ul></li>
</ul>
<h3 id="er-模型中的实体">ER 模型中的实体</h3>
<ul>
<li><strong>实体</strong>（Entity）
<ul>
<li><strong>客观存在</strong>并可<strong>相互区分</strong>的事物叫实体</li>
</ul></li>
<li><strong>属性</strong>（Attribute）
<ul>
<li>实体所具有的某一<strong>特性</strong></li>
<li>一个实体可以由若干个属性来刻画</li>
</ul></li>
<li><strong>域</strong>（Domain）
<ul>
<li>属性的<strong>取值范围</strong></li>
</ul></li>
</ul>
<h4 id="实体型与实体集">实体型与实体集</h4>
<ul>
<li>实体型（Entity Type)
<ul>
<li><strong>实体名</strong> + <strong>属性名</strong>集合</li>
<li>实体（值）是实体型的一个特例</li>
<li>抽象的概念</li>
</ul></li>
<li>实体集（Entity Set）
<ul>
<li>同型实体的集合</li>
</ul></li>
<li>例子
<ul>
<li>实体型：学生（姓名、性别）</li>
<li>实体：（张三，男）</li>
<li>实体集：全体学生</li>
</ul></li>
</ul>
<h3 id="er-模型中的联系">ER 模型中的联系</h3>
<ul>
<li><strong>联系</strong>（Relationship）
<ul>
<li>实体之间的相互关联</li>
</ul></li>
<li><strong>联系也可以有属性</strong></li>
<li>联系的<strong>元</strong>（Degree）
<ul>
<li>参与联系的<strong>实体集</strong>的个数</li>
<li><strong>一元联系</strong>又被称为<strong>递归联系</strong></li>
</ul></li>
<li>联系是发生在<strong>实体集</strong>之间的，而不是实体型</li>
</ul>
<h4 id="例子">例子</h4>
<ul>
<li>联系与联系的元
<ul>
<li><strong>学生</strong>与<strong>老师</strong>间的授课联系
<ul>
<li>二元联系</li>
</ul></li>
<li><strong>学生</strong>与<strong>学生</strong>间有班长联系
<ul>
<li>可以是实体集内部的联系</li>
<li><strong>一元联系</strong>，只有一个实体集</li>
</ul></li>
</ul></li>
<li>联系的属性
<ul>
<li>如学生与课程之间有选课联系，每个选课联系都有一个成绩作为其属性</li>
</ul></li>
</ul>
<h3 id="实体的码key">实体的码（Key）</h3>
<ul>
<li><strong>超码</strong>（superkey）
<ul>
<li>能<strong>唯一标识</strong>实体的属性或属性组</li>
<li>超码的任意超集也是超码</li>
</ul></li>
<li><strong>候选码</strong>（candidate key）
<ul>
<li>其任意真子集都不能成为超码的<strong>最小超码</strong></li>
</ul></li>
<li><strong>主码</strong>（primary key）
<ul>
<li>从所有候选码中<strong>选定一个</strong>用来区别同一实体集中的不同实体</li>
<li>一个实体集中任意两个实体在主码上的取值不能相同</li>
<li>选择上一般越简单越好</li>
</ul></li>
</ul>
<h4 id="一个例子">一个例子</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">C</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">6</td>
</tr>
</tbody>
</table>
<ul>
<li>超码
<ul>
<li>C、AC、BC、ABC、AB</li>
</ul></li>
<li>候选码
<ul>
<li>C、AB</li>
</ul></li>
</ul>
<h4 id="如何确定联系的码">如何确定联系的码</h4>
<ul>
<li>联系的种类不一样的时候，联系的码也不一样</li>
<li>例子：实体集 A，实体集 B，AB 之间存在联系 C
<ul>
<li>如果每个 A 只能和一个 B 发生联系 C
<ul>
<li>联系的码：实体集 B 中的一个候选码即可</li>
</ul></li>
<li>如果每个 A 可以和多个 B 发生联系 C，多个 A 可以与一个相同的 B
发生联系
<ul>
<li>联系的码：实体集 A 和实体集 B 中的各选一个候选码进行组合</li>
</ul></li>
</ul></li>
</ul>
<h4 id="码在-er-图中的表示">码在 ER 图中的表示</h4>
<ul>
<li>实体集属性中<strong>作为主码的一部分的属性</strong>用<strong>下划线</strong>来标明</li>
</ul>
<p><img src="/2021/03/30/DB/CLJ/02/image-20210330170242822.png" style="zoom:67%;"></p>
<h4 id="其他的码">其他的码</h4>
<ul>
<li><strong>替代码</strong>
<ul>
<li>除去主码之外的候选码</li>
</ul></li>
<li><strong>自然码</strong>
<ul>
<li>一个与行中属性有逻辑联系的候选码，它是实体的 <strong>“真正的”
属性</strong></li>
</ul></li>
<li><strong>代理码</strong>
<ul>
<li><strong>人工码</strong>，<strong>只起唯一标识作用的序列号</strong>，不是实体本身的属性</li>
</ul></li>
<li><strong>智能码</strong>
<ul>
<li>经过编码的标识符</li>
<li>例如：身份证</li>
</ul></li>
</ul>
<h3 id="基本-er-图要点">基本 ER 图要点</h3>
<ul>
<li>一个例子：学生选修课程</li>
</ul>
<p><img src="/2021/03/30/DB/CLJ/02/image-20210330170654534.png" style="zoom:67%;"></p>
<ul>
<li>实体集
<ul>
<li>用<strong>矩形</strong>表示实体集，在框内写上实体名</li>
</ul></li>
<li>实体的属性
<ul>
<li>用<strong>椭圆</strong>表示实体的属性</li>
<li>用<strong>无向边</strong>把实体与其属性连接起来</li>
</ul></li>
<li>联系
<ul>
<li>用<strong>菱形</strong>表示实体间的联系</li>
<li>将参与联系的实体用线段连接
<ul>
<li>联系的数量</li>
</ul></li>
</ul></li>
</ul>
<h3 id="一些-er-图的例子">一些 ER 图的例子</h3>
<ul>
<li><strong>一个实体集只能出现一次</strong></li>
<li>因此实体集内部的联系应该这么表示</li>
</ul>
<p><img src="/2021/03/30/DB/CLJ/02/image-20210330171253835.png" style="zoom:50%;"></p>
<ul>
<li>ER 图的连通性
<ul>
<li>连通：可以进行一些探索性的查询</li>
<li>不连通：可以放在独立的数据库里</li>
</ul></li>
<li>联系是<strong>实体集</strong>之间的联系，而不是<strong>实体</strong>之间的联系</li>
</ul>
<h3 id="参与">参与</h3>
<ul>
<li>参与（Participation）</li>
<li>实体集之间的关联称为参与，即<strong>实体参与联系</strong></li>
<li>例子
<ul>
<li>王军选修 “数据库基础”</li>
<li>表示实体 “王军” 与 “数据库基础” 参与了联系 “选修”</li>
</ul></li>
<li>类型
<ul>
<li>E <strong>全部参与</strong> R
<ul>
<li>实体集 E 中的每个实体都参与到联系集 R 中的至少一个联系</li>
</ul></li>
<li>E <strong>部分参与</strong> R
<ul>
<li>实体集 E 中只有部分实体参与参与到联系集 R 的联系中</li>
</ul></li>
</ul></li>
<li>一个联系的两个实体集可能一个完全参与，一个部分参与</li>
<li>参与在 ER 图中的表示
<ul>
<li>用<strong>双线连接</strong>联系与完全参与的实体</li>
</ul></li>
</ul>
<p><img src="/2021/03/30/DB/CLJ/02/image-20210330171925043.png" style="zoom:60%;"></p>
<ul>
<li>识别联系的参与度有何作用？
<ul>
<li>在设计关系表时可以确定更优的设计方式</li>
<li>例子：上面的职工、部门之间的管理联系
<ul>
<li>设计的时候会把管理这个联系放在部门的表里，而不是放在职工的表里</li>
<li>放在职工的表里，空的地方太多</li>
</ul></li>
</ul></li>
</ul>
<h3 id="存在依赖">存在依赖</h3>
<ul>
<li>存在依赖（Existence Dependency）</li>
<li>x 存在依赖于 y
<ul>
<li>实体 x 的存在依赖于实体 y 的存在</li>
<li>y 称作<strong>支配实体</strong></li>
<li>x 称作<strong>从属实体</strong></li>
<li>如果 y 被删除，则 x 也要被删除</li>
</ul></li>
<li>例子</li>
</ul>
<p><img src="/2021/03/30/DB/CLJ/02/image-20210330172659994.png" style="zoom:60%;"></p>
<ul>
<li>存在依赖必是<strong>完全参与</strong>
<ul>
<li>还款存在依赖于贷款，则<strong>还款</strong>全部参与和贷款之间的属于联系</li>
</ul></li>
</ul>
<h3 id="角色">角色</h3>
<ul>
<li>角色（Role）</li>
<li>实体在联系中的作用称为实体的角色</li>
<li>多元联系中的角色是相对清晰的，一元联系需要显式注明</li>
<li>对于一元联系，为区别各实体参与联系的方式，需要显式指明其角色</li>
</ul>
<h4 id="角色在-er-图中的表示">角色在 ER 图中的表示</h4>
<ul>
<li>当需要显式区分角色时，在连接菱形和矩形的线上加上说明性标注以区别不同的角色</li>
</ul>
<p><img src="/2021/03/30/DB/CLJ/02/image-20210330173111443.png" style="zoom:50%;"></p>
<h2 id="属性类型">属性类型</h2>
<h3 id="简单属性与复合属性">简单属性与复合属性</h3>
<ul>
<li><strong>简单属性</strong>
<ul>
<li>不可再分的属性</li>
</ul></li>
<li><strong>复合属性</strong>（Composite）
<ul>
<li>可以划分为更小的属性</li>
</ul></li>
<li>为什么使用复合属性？
<ul>
<li>把相关属性聚集起来以反映更高层次的概念，可以使<strong>模型更清晰</strong></li>
</ul></li>
<li>例子</li>
</ul>
<p><img src="/2021/03/30/DB/CLJ/02/image-20210330173317919.png" style="zoom:70%;"></p>
<h3 id="单值属性与多值属性">单值属性与多值属性</h3>
<ul>
<li><strong>单值属性</strong>
<ul>
<li>每一个特定的实体在该属性上的取值唯一</li>
</ul></li>
<li><strong>多值属性</strong>
<ul>
<li>某个特定实体在该属性上有多于一个的取值</li>
</ul></li>
<li>多值属性的问题
<ul>
<li>拆开成表的时候，会产生<strong>冗余</strong>（其他的单值属性由于这个多值属性的展开而被多次存储）</li>
<li>一般会单独来存</li>
</ul></li>
</ul>
<h3 id="派生属性与基属性">派生属性与基属性</h3>
<ul>
<li><strong>派生属性</strong>（Derived）
<ul>
<li>可以从其他相关的属性或实体派生出来的属性值</li>
</ul></li>
<li>例子：学生的绩点可以由器所选课程的成绩计算出来
<ul>
<li>绩点为<strong>派生属性</strong></li>
<li>成绩为<strong>基属性</strong>，或<strong>存储属性</strong></li>
</ul></li>
<li>数据库设计的时候，一般把基属性放在实际的表里，派生属性用<strong>视图</strong>
<ul>
<li>只存基属性值，而派生属性只存其定义或依赖关系，用时再从基属性中计算出来</li>
</ul></li>
</ul>
<h3 id="属性在-er-图中的表示">属性在 ER 图中的表示</h3>
<ul>
<li><strong>多值属性</strong>用<strong>双椭圆</strong>表示</li>
</ul>
<p><img src="/2021/03/30/DB/CLJ/02/image-20210330173936528.png" style="zoom:60%;"></p>
<ul>
<li><strong>派生属性</strong>用<strong>虚椭圆</strong>表示</li>
</ul>
<p><img src="/2021/03/30/DB/CLJ/02/image-20210330174008276.png" style="zoom:50%;"></p>
<h3 id="null-属性">NULL 属性</h3>
<ul>
<li>null 表示 ”无意义“
<ul>
<li>当实体在某个属性上没有值时设为 null</li>
<li>表示对于这个实体而言，这个属性是不合适的（不存在这个属性）</li>
</ul></li>
<li>null 表示 “值未知”
<ul>
<li>值存在，但目前没有获得该信息</li>
</ul></li>
<li>三值逻辑：true、false、unkown</li>
<li><strong>实体完整性要求主码取值不能为 null</strong></li>
</ul>
<h2 id="联系的基数">联系的基数</h2>
<h3 id="联系的种类">联系的种类</h3>
<ul>
<li>实体之间的<strong>联系的数量</strong>，即<strong>一个实体</strong>通过<strong>一个联系集</strong>能与<strong>另一实体集相关联的实体</strong>的<strong>数目</strong></li>
<li>一对一（1：1）</li>
<li>一对多（1：m）</li>
<li>多对多（m：n）</li>
</ul>
<h3 id="联系种类在-er-图中的表示">联系种类在 ER 图中的表示</h3>
<h4 id="表示-1">表示 1</h4>
<ul>
<li>用<strong>箭头</strong>或<strong>线段</strong>来表示联系的种类，<strong>箭头指向单方实体集</strong></li>
</ul>
<p><img src="/2021/03/30/DB/CLJ/02/image-20210330174728017.png" style="zoom:50%;"></p>
<ul>
<li>一个解释：A 同学，B 导师
<ul>
<li>一个学生只能有一个导师</li>
<li>一个导师可以有多个学生</li>
</ul></li>
</ul>
<h4 id="表示-2">表示 2</h4>
<ul>
<li><strong>多方实体的箭头指向联系集</strong></li>
</ul>
<p><img src="/2021/03/30/DB/CLJ/02/image-20210330175030298.png" style="zoom: 60%;"></p>
<ul>
<li>同样的理解
<ul>
<li>一个同学只能参与到一个联系里面，一个老师可以参与到多个联系里面</li>
</ul></li>
</ul>
<h4 id="表示-3">表示 3</h4>
<ul>
<li>在多方实体和联系之间的线段上标注字母</li>
<li>在单方实体和联系之间的线段上标注数字 1</li>
</ul>
<p><img src="/2021/03/30/DB/CLJ/02/image-20210330175427506.png" style="zoom:67%;"></p>
<h3 id="二元联系的种类">二元联系的种类</h3>
<h4 id="一对一">一对一</h4>
<ul>
<li>两个实体集 <span class="math inline">\(E_1\)</span>、<span class="math inline">\(E_2\)</span>
之间的<strong>一对一</strong>联系</li>
<li><span class="math inline">\(E_1\)</span> 中的一个实体与 <span class="math inline">\(E_2\)</span>
中<strong>至多一个</strong>实体相联系，并且 <span class="math inline">\(E_2\)</span> 中的一个实体与 <span class="math inline">\(E_1\)</span>
中<strong>至多一个</strong>实体相联系</li>
<li><strong>一对一不是一一对应</strong>
<ul>
<li>可能有实体集中的实体不参与联系（如下图右边）</li>
</ul></li>
</ul>
<p><img src="/2021/03/30/DB/CLJ/02/image-20210330175742026.png" style="zoom:67%;"></p>
<h4 id="一对多">一对多</h4>
<ul>
<li>两个实体集 <span class="math inline">\(E_1\)</span>、<span class="math inline">\(E_2\)</span>
之间的<strong>一对多</strong>联系</li>
<li><span class="math inline">\(E_1\)</span> 中的一个实体与 <span class="math inline">\(E_2\)</span> 中 <span class="math inline">\(n(n\ge0)\)</span> 个实体相联系，并且 <span class="math inline">\(E_2\)</span> 中的一个实体与 <span class="math inline">\(E_1\)</span>
中<strong>至多一个</strong>实体相联系</li>
</ul>
<p><img src="/2021/03/30/DB/CLJ/02/image-20210330232018728.png" style="zoom: 67%;"></p>
<h4 id="多对多">多对多</h4>
<ul>
<li>两个实体集 <span class="math inline">\(E_1\)</span>、<span class="math inline">\(E_2\)</span>
之间的<strong>多对多</strong>联系</li>
<li><span class="math inline">\(E_1\)</span> 中的一个实体与 <span class="math inline">\(E_2\)</span> 中 <span class="math inline">\(n(n\ge0)\)</span> 个实体相联系，并且 <span class="math inline">\(E_2\)</span> 中的一个实体与 <span class="math inline">\(E_1\)</span> 中 <span class="math inline">\(m(m\ge0)\)</span> 个实体相联系</li>
</ul>
<p><img src="/2021/03/30/DB/CLJ/02/image-20210330232156769.png" style="zoom:67%;"></p>
<h3 id="一个实体集内的递归联系">一个实体集内的递归联系</h3>
<ul>
<li>一对一</li>
</ul>
<pre class="mermaid">graph RL;
B{配偶};
A[职工];
B --->|妻子| A
B --->|丈夫| A</pre>
<ul>
<li>一对多</li>
</ul>
<pre class="mermaid">graph RL;
B{领导};
A[职工];
B ---|属下| A
B --->|上级| A</pre>
<ul>
<li>多对多</li>
</ul>
<pre class="mermaid">graph RL;
B{构成};
A[零件];
B ---|母零件| A
B ---|子零件| A</pre>
<h3 id="多元联系">多元联系</h3>
<h4 id="歧义">歧义</h4>
<ul>
<li>如下的 ER 图可能会出现歧义
<ul>
<li>每个职工只有一个工种</li>
<li>每个职工在每个部门只有一个工种</li>
</ul></li>
</ul>
<pre class="mermaid">graph LR;
A[工种];
B[职工];
C{工作};
D[部门];
B --- C;
D --- C;
C ---> A;</pre>
<ul>
<li>修改为二元联系
<ul>
<li>每个职工只有一个工种</li>
</ul></li>
</ul>
<pre class="mermaid">graph LR;
A[工种];
B[职工];
C{工作};
E{分配};
D[部门];
B --- C;
C --- D;
B --- E;
E ---> A;</pre>
<h4 id="多元联系中最多允许出现一个箭头">多元联系中最多允许出现一个箭头</h4>
<ul>
<li>否则可能会有歧义
<ul>
<li>（学生，评估报告），老师</li>
<li>（学生，评估报告，项目），老师</li>
</ul></li>
</ul>
<pre class="mermaid">graph LR;
A[学生] --- B{指导} ---> C[老师];
D[评估报告] --- B ---> E[项目];</pre>
<h4 id="联系的势">联系的势</h4>
<ul>
<li>势表达了一个实体出现在联系中的次数</li>
</ul>
<pre class="mermaid">graph LR;
A[教师];
B{教授};
C[课程];
A ---|"(0,2)"| B;
B ---|"(1,4)"| C;</pre>
<ul>
<li>0 表示教师可以不教授课程</li>
<li>区分<strong>强制性</strong>和<strong>可选性</strong>联系</li>
</ul>
<h3 id="复合实体">复合实体</h3>
<ul>
<li>复合实体也称联合实体或<strong>桥接实体</strong></li>
<li><strong>过时了</strong>
<ul>
<li>早期由于图模型不能表示多对多的联系而产生的</li>
</ul></li>
<li>复合实体
<ul>
<li>一个 M：N 联系分解成一个 1：M 和一个 1：N</li>
</ul></li>
<li>原来的联系</li>
</ul>
<pre class="mermaid">graph LR;
A[学生]---B{选修}---C[课程];</pre>
<ul>
<li>复合实体
<ul>
<li>由选修这个实体有关系衍生而来</li>
</ul></li>
</ul>
<p><img src="/2021/03/30/DB/CLJ/02/image-20210331095818361.png" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.03.关系模型(2)</title>
    <url>/2021/04/02/DB/CLJ/03-1/</url>
    <content><![CDATA[<h1 id="关系模型">关系模型</h1>
<h2 id="关系代数的分类">关系代数的分类</h2>
<ul>
<li>基本运算
<ul>
<li>一元运算
<ul>
<li>选择、投影、更名</li>
</ul></li>
<li>多元运算
<ul>
<li>笛卡儿积、集合并、集合差</li>
</ul></li>
</ul></li>
<li>扩展运算
<ul>
<li>集合交、<span class="math inline">\(\theta\)</span>
连接、自然连接、外连接</li>
</ul></li>
<li>其它运算
<ul>
<li>赋值、广义投影、插入、删除、更新</li>
</ul></li>
</ul>
<h2 id="关系代数基本运算">关系代数基本运算</h2>
<h3 id="选择运算">选择运算</h3>
<ul>
<li>在关系中选择满足给定条件的元组（行角度）</li>
</ul>
<p><span class="math display">\[
\sigma_F(R)=\left\{t|t\in R,F(t)=true\right\}
\]</span></p>
<ul>
<li><span class="math inline">\(F\)</span> 是选择的条件，<span class="math inline">\(\forall t\in R,F(t)\)</span>
要么为真，要么为假</li>
<li><span class="math inline">\(F\)</span>
由<strong>逻辑运算符</strong>连接<strong>算术表达式</strong>而成</li>
<li>逻辑运算符：<span class="math inline">\(\land,
\lor,\lnot\)</span></li>
<li>算术表达式：<span class="math inline">\(X\ \theta\ Y\)</span>
<ul>
<li><span class="math inline">\(X,Y\)</span>是属性名、常量、或简单函数</li>
<li><span class="math inline">\(\theta\)</span> 是比较算符
<ul>
<li><span class="math inline">\(\theta\in\left\{&gt;,\ge,&lt;,\le,=,\ne\right\}\)</span></li>
</ul></li>
</ul></li>
<li>例子：找年龄不小于 20 的男学生
<ul>
<li>表达上等效</li>
<li>实际查询中谁更高效？取决于数据库的设计
<ul>
<li>如果索引中含有 age，则 （3） 可能最高效</li>
<li>一般不会是（2），性别这种二值属性不适于建索引</li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
(1)\ &amp;\sigma_{age\ge20\land sex=&#39;M&#39;}(S)\\
(2)\ &amp;\sigma_{age\ge20}\left(\sigma_{sex=&#39;M&#39;}(S)\right)\\
(3)\ &amp;\sigma_{sex=&#39;M&#39;}\left(\sigma_{age\ge20}(S)\right)\\
\end{aligned}
\]</span></p>
<h3 id="投影运算">投影运算</h3>
<ul>
<li>从关系中取若干列组成新的关系（从列的角度）</li>
</ul>
<p><span class="math display">\[
%% Π𝑨𝑨𝑹𝑹=𝒕𝒕𝑨𝑨𝒕𝒕∈𝑹𝑹},𝑨𝑨⊆𝑹𝑹
\prod_A(R)\left\{ t[A]|t\in R\right\},A\subseteq R
\]</span></p>
<ul>
<li>注意：<strong>投影的结果中要去掉相同的行</strong></li>
<li>例子：给出所有学生的姓名和年龄
<ul>
<li><span class="math inline">\(\prod_{sno,age}(S)\)</span></li>
</ul></li>
</ul>
<h3 id="更名">更名</h3>
<ul>
<li>将关系 <span class="math inline">\(R\)</span> 更名为 <span class="math inline">\(S\)</span>
<ul>
<li><span class="math inline">\(\rho_S(R)\)</span></li>
<li>对现有的表进行更名</li>
</ul></li>
<li>将计算表达式 <span class="math inline">\(E\)</span> 更名为关系 <span class="math inline">\(S\)</span>
<ul>
<li><span class="math inline">\(\rho_{S(A_1,A_2,\cdots,A_n)}(E)\)</span></li>
<li>将中间结果存储到自己定义的表里面</li>
</ul></li>
<li>更名运算的必要性
<ul>
<li>将更名运算施加到关系上，得到具有不同名字的同一关系</li>
<li>当同一关系多次参与同一运算时需要更名</li>
</ul></li>
</ul>
<h3 id="并运算">并运算</h3>
<ul>
<li>所有至少出现在两个关系中之一的元组集合</li>
</ul>
<p><span class="math display">\[
R\cup S=\left\{r|r\in R\lor r\in S\right\}
\]</span></p>
<ul>
<li>关系 <span class="math inline">\(R\)</span> 和 <span class="math inline">\(S\)</span>
进行并运算的前提是它们必须是<strong>相容</strong>的
<ul>
<li>关系 <span class="math inline">\(R\)</span> 和 <span class="math inline">\(S\)</span>
必须是<strong>同元</strong>的，其<strong>属性数目必须相同</strong></li>
<li>对 <span class="math inline">\(\forall i\)</span>，<span class="math inline">\(R\)</span> 的第 <span class="math inline">\(i\)</span> 个属性和 <span class="math inline">\(S\)</span> 的第 <span class="math inline">\(i\)</span>
个属性的<strong>域</strong>必须相同</li>
</ul></li>
<li>简单地说，得具有相同的表结构</li>
<li>例子：求选修了 001 号或 002 号课程的学生号
<ul>
<li>两种表示</li>
<li><span class="math inline">\(\prod_{sno}(\sigma_{cno=001\lor
cno=002}(SC))\)</span></li>
<li><span class="math inline">\(\prod_{sno}(\sigma_{cno=001}(SC))\cup\prod_{sno}(\sigma_{cno=001}(SC))\)</span></li>
</ul></li>
</ul>
<h3 id="差运算">差运算</h3>
<ul>
<li>所有出现在一个关系而不在另一关系中的元组集合</li>
</ul>
<p><span class="math display">\[
R-S=\left\{r|r\in R\land r\notin S\right\}
\]</span></p>
<ul>
<li><span class="math inline">\(R,S\)</span>
必须是<strong>相容</strong>的</li>
<li>例子：求选修了001号但未选修002号课程的学生号
<ul>
<li><span class="math inline">\(\prod_{sno}(\sigma_{cno=001}(SC))-\prod_{sno}(\sigma_{cno=002}(SC))\)</span></li>
<li><span class="math inline">\(\prod_{sno}(\sigma_{cno=001\land
cno\ne002}(SC))\)</span>
<ul>
<li>这种表示是<span style="color:red;font-weight:bold">错误</span>的，一方面第二个条件是多余的，另一方面不适用于如下场景</li>
<li>每个人有多个行，表示选择了不同的课程</li>
</ul></li>
</ul></li>
</ul>
<h3 id="交运算">交运算</h3>
<ul>
<li>所有同时出现在两个关系中的元组集合
<ul>
<li>交运算可以通过差运算来重写</li>
</ul></li>
</ul>
<p><span class="math display">\[
R\cap S=R-(R-S)
\]</span></p>
<ul>
<li>是一种扩展运算，早期定义的时候把差运算定义成了基本运算</li>
<li>例子：求同时选修了 001 号和 002 号课程的学生号
<ul>
<li><span class="math inline">\(\prod_{sno}(\sigma_{cno=001}(SC))\cap\prod_{sno}(\sigma_{cno=001}(SC))\)</span></li>
<li><span class="math inline">\(\prod_{sno}(\sigma_{cno=001\land
cno=002}(SC))\)</span>
<ul>
<li>这种表示是<span style="color:red;font-weight:bold">错误</span>的，结果为空</li>
</ul></li>
</ul></li>
</ul>
<h3 id="笛卡尔积运算">笛卡尔积运算</h3>
<ul>
<li>元组的连串（Concatenation）</li>
<li><span class="math inline">\(r=(r_1,\cdots,r_n),
s=(s_1,\cdots,s_m)\)</span></li>
<li>则 <span class="math inline">\(r\)</span> 与 <span class="math inline">\(s\)</span> 的连串定义为</li>
</ul>
<p><span class="math display">\[
\hat{rs}=(r_1,\cdots,r_n,s_1,\cdots,s_m)
\]</span></p>
<ul>
<li>关系的笛卡尔积</li>
</ul>
<p><span class="math display">\[
R\times S=\left\{\hat{rs}|r\in R\land s\in S\right\}
\]</span></p>
<ul>
<li><span class="math inline">\(R\times S\)</span> 的度为 <span class="math inline">\(R\)</span> 与 <span class="math inline">\(S\)</span> 的度之和</li>
<li><span class="math inline">\(R\times S\)</span> 的元组个数为 <span class="math inline">\(R\)</span> 与 <span class="math inline">\(S\)</span> 的元组个数的乘积</li>
<li>计算的一个例子</li>
</ul>
<p><img src="/2021/04/02/DB/CLJ/03-1/image-20210406155455129.png" style="zoom:80%;"></p>
<ul>
<li>包打天下：<strong>选择</strong>、<strong>投影</strong>、<strong>笛卡尔积</strong></li>
</ul>
<h4 id="例子-1">例子 1</h4>
<ul>
<li>求选修 c1 课程的学生姓名</li>
<li>两个表的连接</li>
<li>SN：student name</li>
</ul>
<p><span class="math display">\[
\prod_{SN}\left(\sigma_{S.sno=SC.sno\land R.cno=c1}(S\times SC)\right)
\]</span></p>
<h4 id="例子-2">例子 2</h4>
<ul>
<li>表 S</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">姓名</th>
<th style="text-align: center;">课程</th>
<th style="text-align: center;">成绩</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">80</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">b</td>
<td style="text-align: center;">70</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">b</td>
<td style="text-align: center;">90</td>
</tr>
</tbody>
</table>
<ul>
<li>另外一个例子：课程 b 成绩比 A 高的成员</li>
<li>自己和自己连接，更名</li>
</ul>
<p><span class="math display">\[
\prod_{S.姓名}\left(\sigma_{R.姓名=A \land R.课程=b\land S.课程=b\land
S.成绩&gt;R.成绩}(S\times\rho_R(S))\right)
\]</span></p>
<ul>
<li>如果要比较同一个表里的三行，则可能需要再乘一次</li>
</ul>
<h2 id="关系代数扩展运算">关系代数扩展运算</h2>
<h3 id="theta-连接"><span class="math inline">\(\theta\)</span>
连接</h3>
<ul>
<li>因为这个操作很常见，抽象成一个运算</li>
<li>从两个关系的<strong>广义笛卡尔积</strong>中选取给定<strong>属性间满足一定条件</strong>的元组</li>
</ul>
<p><span class="math display">\[
R{\bowtie\atop A\ \theta\ B}S=\left\{\hat{rs}|r\in R\land s\in S\land
r[A]\
\theta s[B]\ \right\}
\]</span></p>
<ul>
<li><span class="math inline">\(\theta\)</span>
为算术比较符，为<strong>等号</strong>时称为<strong>等值连接</strong></li>
<li>A, B 为 R 和 S 上度数相等且可比的属性列</li>
<li>例子：笛卡尔积运算的例子 2</li>
</ul>
<p><span class="math display">\[
\prod_{S.姓名}\left(\left(\sigma_{R.姓名=A \land
R.课程=b}\right){\bowtie\atop
R.成绩&lt;S.成绩}\left(\sigma_{S.课程=b}\right)\right)
\]</span></p>
<h3 id="自然连接">自然连接</h3>
<ul>
<li>从两个关系的广义笛卡儿积中选取在<strong>相同属性列 B
上取值相等</strong>的元组，并<strong>去掉重复的列</strong></li>
</ul>
<p><span class="math display">\[
R\bowtie S=\left\{\hat{rs}[\bar{B}]|r\in R\land s\in S\land
r[B]=s[B]\right\}
\]</span></p>
<ul>
<li>自然连接与等值连接的不同
<ul>
<li>自然连接中相等的分量必须是相同的属性组，并且要在结果中去掉重复的属性，而等值连接则不必</li>
<li>自然连接要求必须有公共的列，等值连接只要求可比</li>
</ul></li>
<li>自然连接非常有用
<ul>
<li>实体之间的联系在自然连接之后能够合成一张表</li>
</ul></li>
<li>例子</li>
</ul>
<p><img src="/2021/04/02/DB/CLJ/03-1/image-20210406162724169.png" style="zoom:80%;"></p>
<ul>
<li>相同属性列的相同元素越多，结果行数越多
<ul>
<li>如果全部相同，退化为笛卡尔积</li>
</ul></li>
<li>例子：求001号学生所在系的名称
<ul>
<li><span class="math inline">\(\prod_{dname}(\sigma_{sno=001}(S\bowtie
dept))\)</span></li>
<li><span class="math inline">\(\prod_{dname}((\sigma_{sno=001}(S))\bowtie
dept)\)</span>
<ul>
<li>效率更高</li>
</ul></li>
</ul></li>
<li>一般而言，我们先做选择，再做连接
<ul>
<li>先做连接可能出来很大的表</li>
</ul></li>
</ul>
<h4 id="例子">例子</h4>
<ul>
<li>关系 <span class="math inline">\(R(A, B)\)</span>、<span class="math inline">\(S(A, C)\)</span>、<span class="math inline">\(R\)</span> 与 <span class="math inline">\(S\)</span> 中元组个数分别为10，15</li>
<li><strong>不考虑空值的情况</strong></li>
</ul>
<table>
<colgroup>
<col style="width: 21%">
<col style="width: 21%">
<col style="width: 27%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">条件</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">最小元组数</th>
<th style="text-align: center;">最大元组数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">无任何条件</td>
<td style="text-align: center;"><span class="math inline">\(R\bowtie
S\)</span></td>
<td style="text-align: center;">0<br>（R 的 A 属性和 S 的 A
属性都不相等）</td>
<td style="text-align: center;">150<br>（都相等）</td>
</tr>
<tr class="even">
<td style="text-align: center;">无任何条件</td>
<td style="text-align: center;"><span class="math inline">\(\prod_{A}(R)\bigcup \prod_{A}(S)\)</span></td>
<td style="text-align: center;">1<br>（都相等）</td>
<td style="text-align: center;">25<br>（都不相等）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">A 是 R 的主码</td>
<td style="text-align: center;"><span class="math inline">\(R\bowtie
S\)</span></td>
<td style="text-align: center;">0<br>（R 的 A 属性和 S 的 A
属性都不相等）</td>
<td style="text-align: center;">15<br>（S 里的一行最多只能够和 R
的一行连接）</td>
</tr>
<tr class="even">
<td style="text-align: center;">A 是 R 的主码</td>
<td style="text-align: center;"><span class="math inline">\(\prod_{A}(R)\bigcup \prod_{A}(S)\)</span></td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">25</td>
</tr>
<tr class="odd">
<td style="text-align: center;">A 是 R 的主码<br>且 A 是 S 的外码</td>
<td style="text-align: center;"><span class="math inline">\(R\bowtie
S\)</span></td>
<td style="text-align: center;">15<br>（外码）</td>
<td style="text-align: center;">15<br>（S 里的一行最多只能够和 R
的一行连接）</td>
</tr>
<tr class="even">
<td style="text-align: center;">A 是 R 的主码<br>且 A 是 S 的外码</td>
<td style="text-align: center;"><span class="math inline">\(\prod_{A}(R)\bigcup \prod_{A}(S)\)</span></td>
<td style="text-align: center;">10<br>（外码 + 主码）</td>
<td style="text-align: center;">10<br>（外码 + 主码）</td>
</tr>
</tbody>
</table>
<ul>
<li>A 是 R 的主码表示 A 中的 R 各不相同</li>
<li>A 是 S 的外码，则 S 在 A 上的取值必须在 R 的 A
上出现（参照完整性）</li>
</ul>
<h4 id="自然连接的问题">自然连接的问题</h4>
<ul>
<li>如果某个元素在某个表中缺失的话，结果将会有些元素缺失</li>
<li>解决方案：<strong>外连接</strong></li>
</ul>
<h3 id="外连接">外连接</h3>
<ul>
<li><p>为避免自然连接时因失配而发生的信息丢失，可以<strong>假定往参与连接的一方表中附加一个取值全为空值的行</strong>，它和参与连接的另一方表中的任何一个未匹配上的元组都能匹配，称之为<strong>外连接</strong></p></li>
<li><p>外连接 = 自然连接 + 未匹配元组（悬挂元组）</p></li>
<li><p>外连接的形式：<strong>左外连接</strong>、<strong>右外连接</strong>、<strong>全外连接</strong></p>
<ul>
<li>左外连接 = 自然连接 + 左侧表中未匹配元组
<ul>
<li>⟕</li>
</ul></li>
<li>右外连接 = 自然连接 + 右侧表中未匹配元组
<ul>
<li>⟖</li>
</ul></li>
<li>全外连接 = 自然连接 + 两侧表中未匹配元组
<ul>
<li>⟗</li>
</ul></li>
</ul></li>
<li><p>外连接不满足结合律</p></li>
</ul>
<h4 id="例子-1-1">例子 1</h4>
<p><img src="/2021/04/02/DB/CLJ/03-1/image-20210406163333505.png" style="zoom:80%;"></p>
<h4 id="例子-2-1">例子 2</h4>
<ul>
<li>外连接不满足结合律</li>
<li>这个例子的巧妙之处在于：AB、BC、CA</li>
</ul>
<p><img src="/2021/04/02/DB/CLJ/03-1/image-20210406170707244.png" style="zoom:80%;"></p>
<h3 id="半连接">半连接</h3>
<ul>
<li><span class="math inline">\(R⋉S\)</span>
<ul>
<li>提取出 R 里面<strong>能</strong>和 S 参与自然连接的那些行</li>
</ul></li>
<li>反半连接
<ul>
<li>提取出 R 里面<strong>不能</strong>和 S 参与自然连接的那些行</li>
</ul></li>
</ul>
<p><img src="/2021/04/02/DB/CLJ/03-1/image-20210406171102917.png" style="zoom:80%;"></p>
<ul>
<li>反半连接的应用场景
<ul>
<li>物理底层的 not in/not exist 查询</li>
</ul></li>
<li>半连接的应用场景：<strong>减少分布式数据库的数据传输</strong></li>
</ul>
<p><img src="/2021/04/02/DB/CLJ/03-1/image-20210406171708087.png" style="zoom:80%;"></p>
<h3 id="外部并">外部并</h3>
<ul>
<li>outer union</li>
<li>R(AB) outer join S(BC)
<ul>
<li>在 B 上相同的行为合并成一行</li>
</ul></li>
</ul>
<p><img src="/2021/04/02/DB/CLJ/03-1/image-20210624162240468.png" style="zoom:50%;"></p>
<ul>
<li>子实体集合合并为父实体集合</li>
<li>例子：不同部门收集客户信息，然后将不同部门收集的信息整合起来</li>
<li><span class="math inline">\({\color{red}\mathrm{TODO}}\)</span>
<ul>
<li>外部并和全外连接的区别？<strong>没啥区别</strong></li>
</ul></li>
</ul>
<h3 id="象集">象集</h3>
<ul>
<li>除法</li>
<li>应用场景：找到选修了所有课程的同学
<ul>
<li>涉及到<strong>所有</strong>、<strong>全部</strong>问题</li>
</ul></li>
<li>关系 <span class="math inline">\(R(X,Z)\)</span>，<span class="math inline">\(X,Z\)</span> 是属性组，<span class="math inline">\(x\)</span> 是 <span class="math inline">\(X\)</span> 上的取值，定义 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(R\)</span> 中的象集为</li>
</ul>
<p><span class="math display">\[
Z_x=\left\{t[Z]|t\in R\land t[X]=x\right\}
\]</span></p>
<ul>
<li>象集：先选择，后投影</li>
<li>从R 中选出在 X 上取值为 x 的元组，只留 Z 属性
<ul>
<li><span class="math inline">\(Z_x\)</span></li>
</ul></li>
</ul>
<h4 id="例子-3">例子</h4>
<ul>
<li>如何求得选修了全部课程的学生？</li>
</ul>
<h5 id="思路-1">思路 1</h5>
<ul>
<li>判断每个学生的课程象集是否包含了整个课程集合 C</li>
</ul>
<p><span class="math display">\[
\left\{u|r\in SC\land u=r[姓名]\land 课程名_{u}\supseteq C\right\}
\]</span></p>
<h5 id="思路-2">思路 2</h5>
<ul>
<li>判断学生与课程集合构成的笛卡尔积是否完全包含在选课集合中</li>
</ul>
<p><span class="math display">\[
\left\{u|u\in\prod_{姓名}(SC)\land\forall v\in C(\hat{uv}\in SC)\right\}
\]</span></p>
<ul>
<li>理解图示</li>
</ul>
<p><img src="/2021/04/02/DB/CLJ/03-1/image-20210406175312104.png" style="zoom:80%;"></p>
<h3 id="除法">除法</h3>
<ul>
<li><strong>所有</strong>、<strong>全部</strong>、<strong>任意</strong>问题</li>
<li>定义表达式（2 种）
<ul>
<li>上面提到的两种方式</li>
</ul></li>
</ul>
<p><span class="math display">\[
R(X,Y)\div S(Y)=\left\{x|r\in R\land x=r[X]\land Y_x\supseteq S\right\}
\]</span></p>
<p><span class="math display">\[
R(X,Y)\div S(Y)=\left\{u|u\in\prod_X(R)\land\forall v\in S(\hat{uv}\in
R)\right\}
\]</span></p>
<ul>
<li>计算表达式
<ul>
<li>巧妙了</li>
<li>先计算出不存在的关系，如果有不存在的说明就不是完全</li>
</ul></li>
</ul>
<p><span class="math display">\[
R(X,Y)\div
S(Y)=\prod_X(R)-\prod_X\left(\prod_X(R)\times\prod_{Y}(S)-R\right)
\]</span></p>
<ul>
<li>减法计算
<ul>
<li>补集：区分两类不同性质的子集</li>
<li>表结构必须相同</li>
</ul></li>
</ul>
<h4 id="例子-4">例子</h4>
<ul>
<li>SC(sno, cno, grade)</li>
<li>求选修了所有课程的学生
<ul>
<li>方案1：<span class="math inline">\(\prod_{sno,cno}(SC)\div
\prod_{cno}(C)\)</span></li>
<li>方案2：<span class="math inline">\(\prod_{sno}(SC\div
\prod_{cno}(C))\)</span></li>
</ul></li>
<li><span style="color:red;font-weight:bold;">方案 2 是错误的</span>
<ul>
<li>除法的 X 表示 “课程+成绩”</li>
</ul></li>
</ul>
<p><img src="/2021/04/02/DB/CLJ/03-1/image-20210406231848054.png" style="zoom: 80%;"></p>
<h2 id="关系代数查询实例">关系代数查询实例</h2>
<h3 id="求没有选修-c1-号课程的学生">求没有选修 c1 号课程的学生</h3>
<ul>
<li><strong>没有</strong>：求补</li>
<li>所有学生 – 选修了c1号课程学生</li>
</ul>
<p><span class="math display">\[
\prod_{sno}(SC)-\prod_{sno}(\sigma_{cno=c1}(SC))
\]</span></p>
<ul>
<li><span class="math inline">\(\prod_{sno}(\sigma_{cno\ne
c1}(SC))\)</span>
<ul>
<li>这是错误的</li>
<li>可能有人选了好几门课，注意这是对<strong>每条记录进行处理判断的</strong></li>
<li>这个表示的含义：仅选 c1 号课程之外的其他学生（类 2 + 类 3）
<ul>
<li>选了其他不是 c1 的课的学生</li>
</ul></li>
<li>所有的人分为 3 类
<ul>
<li>类1：只选了 c1（只选了一门课，就是 c1）</li>
<li>类2：没有选 c1 （选了课，但是没有选 c1）</li>
<li>类3：选了好几门课，其中有一门是 c1（至少选了两门课）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="求仅选修了-c1-号课程的学生号">求仅选修了 c1 号课程的学生号</h3>
<ul>
<li>所有的学生－仅选 c1 号课程之外的学生
<ul>
<li>所有的学生 - （类 2 + 类 3）</li>
</ul></li>
</ul>
<p><span class="math display">\[
\prod_{sno}(SC)-\prod_{sno}(\sigma_{cno\ne c1}(SC))
\]</span></p>
<ul>
<li>选修 c1 号课程的学生－仅选 c1 号课程之外的学生
<ul>
<li>对上面的 3 类人进行判断</li>
</ul></li>
</ul>
<p><span class="math display">\[
\prod_{sno}(\sigma_{cno=c1}(SC))-\prod_{sno}(SC-\sigma_{cno=c1}(SC))
\]</span></p>
<ul>
<li>上面两个式子<strong>减去的部分</strong>等价</li>
</ul>
<h3 id="求选修-c1-课程比-s1-学生的该门课程成绩高的学生">求选修 c1 课程比
s1 学生的该门课程成绩高的学生</h3>
<ul>
<li><p>sno, cno, G</p></li>
<li><p>笛卡尔积</p></li>
</ul>
<p><span class="math display">\[
\prod_{S.sno}\left(\sigma_{R.sno=s1\land R.cno=c1\land S.cno=c1\land
R.G&lt; S.G}\left(\rho_R(SC)\times\rho_S(SC)\right)\right)
\]</span></p>
<h3 id="求每门课程的先修课的先修课">求每门课程的先修课的先修课</h3>
<ul>
<li>cno, pcno</li>
<li>递归查询</li>
</ul>
<p><span class="math display">\[
\prod_{C.cno,R.pcno}\left(\sigma_{C.pcno=R.cno}\left(C\times\rho_R(C)\right)\right)
\]</span></p>
<ul>
<li>怎么查找所有的祖辈先修课？
<ul>
<li>传递闭包</li>
<li>从关系完备性来讲，我们目前的关系运算符是不够完备的，不能够表示这种运算</li>
<li>现在的主流数据库是支持递归查询的</li>
</ul></li>
</ul>
<h3 id="求选修了至少两门课的学生">求选修了至少两门课的学生</h3>
<ul>
<li>sno, cno, G</li>
</ul>
<p><span class="math display">\[
\prod_{R.sno}\left(\sigma_{R.sno=S.sno\land R.cno\ne
S.cno\left(\rho_R(SC)\times\rho_S(SC)\right)}\right)
\]</span></p>
<ul>
<li>求选修了至少 N 门课的学生
<ul>
<li><span class="math inline">\({n \choose2}\)</span> 个不等号</li>
</ul></li>
<li>求只选修了 1 门课的学生
<ul>
<li>所有同学 - 至少选修了两门课的同学</li>
</ul></li>
</ul>
<h3 id="求最低的成绩">求最低的成绩</h3>
<ul>
<li>sno, cno, G</li>
<li>笛卡尔积</li>
</ul>
<p><span class="math display">\[
\prod_G(SC)-\prod_{S.G}\left(\sigma_{R.G&lt;S.G}\left(\rho_R(SC)\times\rho_S(SC)\right)\right)
\]</span></p>
<ul>
<li>小于等于好像不行，多个值的时候会变成空集</li>
</ul>
<h3 id="求选修课程中包含了所有-s01-号学生所选修课程的学生号">求选修课程中包含了所有
S01 号学生所选修课程的学生号</h3>
<ul>
<li>cno, sno</li>
<li>除法</li>
</ul>
<p><span class="math display">\[
\prod_{cno,sno}(SC)\div\prod_{cno}(\sigma_{sno=S01}(SC))
\]</span></p>
<h3 id="找出一直上涨的股票">找出一直上涨的股票</h3>
<ul>
<li>stock(sno, date, price)</li>
<li>上涨过的股票</li>
</ul>
<p><span class="math display">\[
\prod_{R,sno}\left(\sigma_{R.sno=S.sno\land R.date&gt;S.date\land
R.price&gt;S.price}\left(\rho_R(stock)\times\rho_S(stock)\right)\right)
\]</span></p>
<ul>
<li>一直上涨的股票
<ul>
<li>持续上涨的股票 = 所有股票 -下跌过的股票</li>
</ul></li>
</ul>
<h3 id="去重">去重</h3>
<ul>
<li>guanxi(source,destination)</li>
<li>可交换的</li>
<li><strong>序列号可比</strong></li>
</ul>
<p><img src="/2021/04/02/DB/CLJ/03-1/image-20210407002232950.png" style="zoom:70%;">
<span class="math display">\[
guanxi-\prod_{S.S,S.D}\left(\sigma_{R.D=S.S\land R.S=S.D\land
R.S&lt;S.S}\left(\rho_R(guanxi)\times\rho_S(guanxi)\right)\right)
\]</span></p>
<h2 id="关系代数更新运算">关系代数更新运算</h2>
<h3 id="赋值运算">赋值运算</h3>
<ul>
<li>为使查询表达简单、清晰，可以将一个复杂关系代数表达式分成几个部分</li>
<li>每一部分都赋予一个临时关系变量</li>
<li>该变量可被看作关系而在后续表达式中使用</li>
<li>临时关系变量 <span class="math inline">\(\leftarrow\)</span>
关系代数表达式</li>
<li>尽可能在一个表达式内写完</li>
</ul>
<h3 id="广义投影">广义投影</h3>
<ul>
<li>在投影列表中使用算术表达式来对投影进行扩展</li>
</ul>
<p><span class="math display">\[
\prod_{F_1,F_2,\cdots,F_n}(E),\ F_i是算术表达式
\]</span></p>
<h3 id="数据库修改删除">数据库修改：删除</h3>
<ul>
<li>将满足条件的元组从关系中删除</li>
<li><span class="math inline">\(R\leftarrow R-E\)</span></li>
<li>是对永久关系的赋值运算</li>
</ul>
<h4 id="例子-5">例子</h4>
<ul>
<li>删除 001 号老师所担任的课程</li>
</ul>
<p><span class="math display">\[
PC\leftarrow PC-\sigma_{pno=001}(PC)
\]</span></p>
<ul>
<li>删除没有选课的学生
<ul>
<li>注意减法的表结构必须相同</li>
</ul></li>
</ul>
<p><span class="math display">\[
S\leftarrow S-\left(\prod_{sno}(S)-\prod_{sno}(SC)\right)\bowtie S
\]</span></p>
<h3 id="数据库修改插入">数据库修改：插入</h3>
<ul>
<li>插入一个指定的元组，或者插入一个查询结果</li>
</ul>
<p><span class="math display">\[
R\leftarrow R\ \bigcup E
\]</span></p>
<h4 id="例子-6">例子</h4>
<ul>
<li>加入计算机系学生选修 “数据结构” 的信息</li>
<li>SC: sno,cno,G（学号、课程、成绩）</li>
</ul>
<p><span class="math display">\[
SC\leftarrow
SC\bigcup\left(\prod_{sno}\left(S\bowtie\sigma_{dname=&quot;计算机系&quot;}(DEPT)\right)\times
\prod_{cno}\left(\sigma_{name=&quot;数据结构&quot;}(C)\right)\times{\color{red}\{null\}}\right)
\]</span></p>
<ul>
<li>缺少成绩信息，一个 trick，和一个 <code>null</code>
属性相乘（笛卡尔积）</li>
</ul>
<h3 id="数据库修改更新">数据库修改：更新</h3>
<ul>
<li>利用广义投影改变元组的某些属性上的值</li>
</ul>
<p><span class="math display">\[
\prod_{F_1,F_2,\cdots,F_n}(E)
\]</span></p>
<h4 id="例子-7">例子</h4>
<ul>
<li>给每位老师上调 10% 的工资</li>
</ul>
<p><span class="math display">\[
PROF\leftarrow \prod_{pno,pname,sal\leftarrow
sal*1.1,dno}\left(PROF\right)
\]</span></p>
<ul>
<li>对工资超过 3000 的老师征收 5% 所得税</li>
</ul>
<p><span class="math display">\[
PROF\leftarrow \left(\prod_{pno,pname,sal\leftarrow
sal*1.1,dno}\left(\sigma_{sal&gt;3000}PROF\right)\right){\color{red}\bigcup\left(\sigma_{sal\le
3000}(PROF)\right)}
\]</span></p>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.03.关系模型(3)</title>
    <url>/2021/04/11/DB/CLJ/03-2/</url>
    <content><![CDATA[<h1 id="关系模型">关系模型</h1>
<h2 id="包">包</h2>
<ul>
<li>bag</li>
<li>允许重复的集合，或者称为<strong>多集</strong>（multi-set）</li>
<li>引入包的原因
<ul>
<li>效率，不用去重</li>
<li>合理地计算聚集函数的值</li>
</ul></li>
</ul>
<h3 id="包的关系代数运算">包的关系代数运算</h3>
<h4 id="包的选择投影笛卡尔积">包的选择、投影、笛卡尔积</h4>
<ul>
<li>和集合上定义是一样的，只需保留重复即可</li>
</ul>
<h4 id="包的并交差">包的并、交、差</h4>
<ul>
<li>假定一个元组 <span class="math inline">\(t\)</span> 在包 <span class="math inline">\(R\)</span> 中重复出现了 <span class="math inline">\(n\)</span> 次，在包 <span class="math inline">\(S\)</span> 中重复出现了 <span class="math inline">\(m\)</span> 次
<ul>
<li>在 <span class="math inline">\(R\cup S\)</span> 中，<span class="math inline">\(t\)</span> 出现 <span class="math inline">\(n+m\)</span> 次</li>
<li>在 <span class="math inline">\(R-S\)</span> 中，<span class="math inline">\(t\)</span> 出现 <span class="math inline">\(\max\{n-m,0\}\)</span> 次</li>
<li>在 <span class="math inline">\(R\cap S\)</span> 中，<span class="math inline">\(t\)</span> 出现 <span class="math inline">\(\min\{n,m\}\)</span> 次</li>
</ul></li>
</ul>
<h4 id="包的关系代数运算律">包的关系代数运算律</h4>
<ul>
<li>以下的运算律集合运算都满足，但是<span style="color:red;font-weight:bold">包运算只满足前4条</span>
<ul>
<li><p><span class="math inline">\((R\cup S)\cup T=R\cup(S\cup
T)\)</span></p></li>
<li><p><span class="math inline">\((R\cap S)\cap T=R\cap(S\cap
T)\)</span></p></li>
<li><p><span class="math inline">\(R\cup(S\cap T)=(R\cup S)\cap(R\cup
T)\)</span></p></li>
<li><p><span class="math inline">\(\sigma_{A\land
B}(R)=\sigma_{A}(R)\cap \sigma_{B}(R)\)</span></p>
<ul>
<li>选择</li>
</ul></li>
<li><p><span class="math inline">\((R\cap S)-T=R\cap(S-T)\)</span></p>
<ul>
<li>反例：<span class="math inline">\(R=\{1,1\},S=\{1,1,1\},T=\{1\}\)</span></li>
<li><span class="math inline">\(\{1\}\ne\{1,1\}\)</span></li>
</ul></li>
<li><p><span class="math inline">\(R\cap(S\cup T)=(R\cap S)\cup(R\cap
T)\)</span></p>
<ul>
<li>反例：<span class="math inline">\(R=\{1\},S=\{1\},T=\{1\}\)</span></li>
<li><span class="math inline">\(\{1\}\ne\{1,1\}\)</span></li>
</ul></li>
<li><p><span class="math inline">\(\sigma_{A\lor B}(R)=\sigma_{A}(R)\cup
\sigma_{B}(R)\)</span></p>
<ul>
<li>反例：<span class="math inline">\(A=\{t|t.a=1\},B\{t|t.b=1\}\)</span>，下图</li>
<li><span class="math inline">\(\{x,y,z\}\ne\{x,y,y,z\}\)</span></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">ID</th>
<th style="text-align: center;">a</th>
<th style="text-align: center;">b</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">x</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;">y</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">z</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ul>
<h2 id="作为约束语言的关系代数">作为约束语言的关系代数</h2>
<h3 id="约束">约束</h3>
<ul>
<li>关系代数表达<strong>约束</strong>的形式
<ul>
<li><span class="math inline">\(R=\phi\)</span> 或者 <span class="math inline">\(R\subseteq S\)</span></li>
</ul></li>
<li><span class="math inline">\(R=\phi\)</span>：声明不满足条件的关系代数为 <span class="math inline">\(R\)</span> ，令 <span class="math inline">\(R\)</span> 为空集</li>
<li><span class="math inline">\(R\subseteq S\)</span></li>
</ul>
<h4 id="例子">例子</h4>
<ul>
<li>参照完整性</li>
<li><span class="math inline">\(R(A,B),S(B,C),S\)</span> 中的 <span class="math inline">\(B\)</span> 是参照 <span class="math inline">\(R\)</span> 的 <span class="math inline">\(B\)</span> 的外码</li>
<li><span class="math inline">\(\prod_{B}(S)\subseteq\prod_{B}(A)\)</span></li>
</ul>
<h3 id="函数依赖">函数依赖</h3>
<ul>
<li><span class="math inline">\(R(A,B)\)</span> 要求在 <span class="math inline">\(A\)</span>上相等的在 <span class="math inline">\(B\)</span> 上也相等</li>
<li>通过反面来表达</li>
<li><span class="math inline">\(\sigma_{R.A=S.A\land R.B\ne
S.B}\left(R\times \rho_S(R)\right)=\phi\)</span></li>
</ul>
<h4 id="思考">思考</h4>
<ul>
<li><span class="math inline">\(R(A,B)\)</span> 如何确定 <span class="math inline">\(A\)</span> 的唯一性（列 <span class="math inline">\(A\)</span> 上的取值都不相同）
<ul>
<li>只有两个属性 <span class="math inline">\(A,B\)</span>，而且是对<strong>集合</strong>而言</li>
<li>表达式和上面函数依赖的结果是相同的</li>
</ul></li>
<li><span class="math inline">\(R(A,B,C)\)</span> 如何确定 <span class="math inline">\(A\)</span> 的唯一性（列 <span class="math inline">\(A\)</span> 上的取值都不相同）
<ul>
<li>有三个属性 <span class="math inline">\(A,B,C\)</span>，而且是对<strong>集合</strong>而言</li>
<li><span class="math inline">\(\sigma_{R.A=S.A\land (R.B\ne S.B\lor
R.C\ne S.C)}\left(R\times \rho_S(R)\right)=\phi\)</span></li>
</ul></li>
</ul>
<h2 id="全关系系统">全关系系统</h2>
<h3 id="系统对关系的支持能力">系统对关系的支持能力</h3>
<ul>
<li><strong>表式系统</strong>
<ul>
<li>仅支持<strong>关系（即表）数据结构</strong>，<span style="color:red;font-weight:bold">不支持集合级操作</span></li>
<li>表式系统不能算关系系统</li>
</ul></li>
<li><strong>最小关系系统</strong>
<ul>
<li>仅<strong>支持关系数据结构</strong>和<strong>三种关系</strong>搡作（选择、投影、链接）
<ul>
<li>三种关系操作可以支持大部分的操作</li>
</ul></li>
<li>许多微机关系数据库系统如 FoxPro 属于此类</li>
</ul></li>
<li><strong>完备关系系统</strong>
<ul>
<li>支持<strong>关系数据结构</strong>和<strong>所有的关系代数操作</strong></li>
<li>90年代初的许多关系数据库管理系统属于这一类</li>
</ul></li>
<li><strong>全关系系统</strong>
<ul>
<li>这类系统支持关系模型的所有特征</li>
</ul></li>
</ul>
<h4 id="表示粗略表示">表示（粗略表示）</h4>
<ul>
<li>S：数据模型</li>
<li>M：数据操作</li>
<li>I：数据完整性</li>
</ul>
<p><img src="/2021/04/11/DB/CLJ/03-2/image-20210411211358339.png" style="zoom:50%;"></p>
<h3 id="全关系系统的十二条准则">全关系系统的十二条准则</h3>
<h4 id="准则-0">准则 0</h4>
<ul>
<li>一个关系型的 DBMS 必须能完全通过它的关系能力来管理数据库
<ul>
<li>所有功能的实现必须在关系的层面来体现</li>
</ul></li>
</ul>
<h4 id="准则-1信息准则">准则 1：信息准则</h4>
<ul>
<li>关系型 DBMS
的<strong>所有信息</strong>都应在逻辑一级上用一种方法即表中的值显式地表示
<ul>
<li>所有的信息都必须保存在关系表里面
<ul>
<li>业务表</li>
<li>数据字典/元数据（表结构的定义）</li>
<li>安全性、完整性条件的声明</li>
</ul></li>
<li><strong>所有信息都得用关系表达</strong></li>
</ul></li>
</ul>
<h4 id="准则-2保证访问准则">准则 2：保证访问准则</h4>
<ul>
<li>依靠表名、主码和列名的组合，保证能以逻辑方式访问关系数据库中的每个数据项（分量值）
以关联寻址代替面向机器的访问方式</li>
<li><strong>所有的操作都必须是集合层面的</strong></li>
</ul>
<h4 id="准则-3空值的系统化处理">准则 3：空值的系统化处理</h4>
<ul>
<li>全关系型 DBMS 应支持空值概念，并用系统化的方式处理空值
<ul>
<li>空值的定义和检测都在系统层面实现</li>
<li>如果系统不支持控制，都需要应用检测
<ul>
<li>例如特殊字符（问题：特殊字符不够特殊）</li>
</ul></li>
</ul></li>
</ul>
<h4 id="准则-4基于关系模型的动态的联机数据字典">准则
4：基于关系模型的动态的联机数据字典</h4>
<ul>
<li>数据库的描述在逻辑级上应该和普通数据采用同样的表示方式，使得授权用户可以使用查询一般数据所用的关系语言来查询数据库的描述信息
<ul>
<li>数据字典（元数据）也应该一关系表的形式存储在数据库中</li>
<li>自描述、自复制代码</li>
</ul></li>
</ul>
<h4 id="准则-5统一的数据子语言">准则 5：统一的数据子语言</h4>
<ul>
<li>一个关系系统可以有几种语言和多种终端使用方式（如QBE、嵌入式SQL），但必须有一种语言，它的语句可以表示为具有严格语法规定的字符串
<ul>
<li>前端界面可以是各种操作，但是在系统内部必须有一种严格的关于数据操作的语言</li>
</ul></li>
</ul>
<h4 id="准则-6视图更新准则">准则 6：视图更新准则</h4>
<ul>
<li>所有理论上可更新的视图也应该由系统更新，即对视图的更新要求，存在一个算法可以无二义地把更新要求转换为对基本表的更新序列
<ul>
<li>视图，在关系表的基础上生成的虚拟表</li>
</ul></li>
<li>一个例子</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 原始关系表 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">    snochar(<span class="number">10</span>) <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">unique</span>,</span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建视图 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> student_info <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> name, age <span class="keyword">from</span> student</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不是理论上可更新的视图, 因为不包含主键, 而主键不能为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_infovalues (‘tom’, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是理论上可更新的视图</span></span><br><span class="line"><span class="comment"> * 因为 name 加了 unique 关键字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">update</span> student_info <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">20</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;jerry&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>具体分析是否语义上可更新很难</li>
<li>现在实际的数据库在这点上做了权衡
<ul>
<li>仅支持部分的更新（符合某种定义形式的视图）</li>
<li>例如要求视图必须是行列子集的（通过选择、投影得到的结果）、还要包括原表的主码、不能包括聚集函数（min/max）</li>
</ul></li>
</ul>
<h4 id="准则-7高级的插入删除和修改操作">准则
7：高级的插入、删除和修改操作</h4>
<ul>
<li>关系系统的操作对象是单一的关系
<ul>
<li>都应该在关系层面上定义</li>
</ul></li>
</ul>
<h4 id="准则-8数据物理独立性">准则 8：数据物理独立性</h4>
<ul>
<li>无论数据库的数据在存储表示和存取方法上作任何变化，应用程序和终端活动都保持逻辑上的不变性</li>
</ul>
<h4 id="准则-9数据逻辑独立性">准则 9：数据逻辑独立性</h4>
<ul>
<li>当对基本关系进行理论上信息不受损害的任何改变时，应用程序和终端活动都保持逻辑上的不变性</li>
</ul>
<h4 id="准则-10数据完整性的独立性">准则 10：数据完整性的独立性</h4>
<ul>
<li>关系数据库的完整性约束条件必须是用数据库语言定义并存储在数据字典中的，而不是由应用程序加以定义
<ul>
<li>系统支持数据完整性的检查，用户不需要自己做数据完整性的检查</li>
</ul></li>
</ul>
<h4 id="准则-11分布独立性">准则 11：分布独立性</h4>
<ul>
<li>分布独立性是指 DBMS
具有这样的数据库语言，使得应用程序和终端活动在下列情况下都保持逻辑上的不变性：
<ul>
<li>在第一次引入分布式数据时，即如果原来的DBMS只管理非分布式的数据，而现在引入了分布式数据</li>
<li>当数据重新分布时，即如果原来DBMS能管理分布式数据，现在要改变原来的数据分布</li>
</ul></li>
<li>分布的透明性，用户感觉不到分布式系统</li>
</ul>
<h4 id="准则-12无破坏准则">准则 12：无破坏准则</h4>
<ul>
<li>如果一个关系系统具有一个低级（一次一记录）语言，则这个低级语言不能违背或绕过完整性准则
<ul>
<li>为获得完整性的独立性，需要让完整性约束条件和数据的逻辑结构相独立</li>
<li>不能旁路（bypass）或者关闭约束检查子系统</li>
</ul></li>
</ul>
<h2 id="元组关系演算">元组关系演算</h2>
<ul>
<li>形式化定义：<span class="math inline">\(\{t|P(t)\}\)</span>
<ul>
<li>表示所有使谓词 <span class="math inline">\(P\)</span>
为真的元组集合</li>
</ul></li>
<li><span class="math inline">\(t\)</span> 为<strong>元组变量</strong>
<ul>
<li>如果元组变量前有“全称”（<span class="math inline">\(\forall\)</span>）或“存在”（<span class="math inline">\(\exists\)</span>）量词，则称其为<strong>约束变量</strong>，否则称为<strong>自由变量</strong></li>
</ul></li>
<li><span class="math inline">\(P\)</span>
是<strong>公式</strong>，由<strong>原子公式</strong>和<strong>运算符</strong>组成</li>
</ul>
<h3 id="原子公式">原子公式</h3>
<ul>
<li><span class="math inline">\(s\in R\)</span>
<ul>
<li><span class="math inline">\(s\)</span> 是关系 <span class="math inline">\(R\)</span> 中的一个元组</li>
</ul></li>
<li><span class="math inline">\(s[X]\ \theta\ u[Y]\)</span>
<ul>
<li><span class="math inline">\(s[X]\)</span> 与 <span class="math inline">\(u[Y]\)</span> 为元组分量，它们之间满足比较关系
<span class="math inline">\(\theta\)</span></li>
</ul></li>
<li><span class="math inline">\(s[X]\ \theta\ c\)</span>
<ul>
<li>分量 <span class="math inline">\(s[X]\)</span> 与常量 <span class="math inline">\(c\)</span> 之间满足比较关系 <span class="math inline">\(\theta\)</span></li>
</ul></li>
</ul>
<h3 id="公式的递归定义">公式的递归定义</h3>
<ul>
<li>原子公式是公式</li>
<li>若 <span class="math inline">\(P\)</span> 是公式，则 <span class="math inline">\(\neg P\)</span> 也是公式</li>
<li>若 <span class="math inline">\(P_1,P_2\)</span> 是公式，则 <span class="math inline">\(P_1\land P_2,P_1\lor P_2,P_1\Rightarrow
P_2\)</span> 也是公式</li>
<li>若 <span class="math inline">\(P(t)\)</span> 是公式，<span class="math inline">\(R\)</span> 是关系，则 <span class="math inline">\(\forall t\in R\left(P(t)\right),\forall t\in
R\left(P(t)\right)\)</span> 也是公式</li>
</ul>
<h3 id="元组关系演算示例">元组关系演算示例</h3>
<p><img src="/2021/04/11/DB/CLJ/03-2/image-20210411221216654.png" style="zoom:70%;"></p>
<p><img src="/2021/04/11/DB/CLJ/03-2/image-20210411221514781.png" style="zoom:70%;"></p>
<h3 id="公式的等价性">公式的等价性</h3>
<ul>
<li><span class="math inline">\(P_1\land P_2 \Leftrightarrow \neg(\neg
P_1\lor\neg P_2)\)</span></li>
<li><span class="math inline">\(\forall t\in R(P(t)) \Leftrightarrow
\neg \exists t\in R(\neg P(t))\)</span></li>
<li><span class="math inline">\(P_1\Rightarrow P_2 \Leftrightarrow \neg
P_1\lor P_2\)</span></li>
</ul>
<h3 id="关系演算表达式的安全性">关系演算表达式的安全性</h3>
<ul>
<li>元组关系演算有可能会产生<strong>无限关系</strong>，这样的表达式是<strong>不安全的</strong></li>
<li>如 <span class="math inline">\(\{t| \neg(t\in
R)\}\)</span>，求所有不在 <span class="math inline">\(R\)</span>
中的元组</li>
<li>引入公式 <span class="math inline">\(P\)</span>
的<strong>域</strong>概念，用 <span class="math inline">\(dom(P)\)</span> 表示
<ul>
<li><span class="math inline">\(dom(P)=\)</span> 显式出现在 <span class="math inline">\(P\)</span> 中的值 + 在 <span class="math inline">\(P\)</span>
中出现的关系的元组中出现的值（不必是最小集）</li>
<li>如定义 <span class="math inline">\(dom(\{t| \neg(t\in R)\})\)</span>
= <span class="math inline">\(\{R\)</span> 中出现的所有值的集合 <span class="math inline">\(\}\)</span></li>
</ul></li>
<li>如果出现在表达式 <span class="math inline">\(\{t|P(t)\}\)</span>
结果中的所有值均来自 <span class="math inline">\(dom(P)\)</span>，则称
<span class="math inline">\(\{t|P(t)\}\)</span> 是安全的</li>
</ul>
<h3 id="元组关系演算查询示例">元组关系演算查询示例</h3>
<ul>
<li>区分找老师、找老师姓名（加一个投影）</li>
</ul>
<p><img src="/2021/04/11/DB/CLJ/03-2/image-20210414101835852.png" style="zoom: 67%;"></p>
<ul>
<li>先选择，再投影</li>
</ul>
<p><img src="/2021/04/11/DB/CLJ/03-2/image-20210411223607384.png" style="zoom:50%;"></p>
<h3 id="元组关系演算与关系代数的等价性">元组关系演算与关系代数的等价性</h3>
<p><img src="/2021/04/11/DB/CLJ/03-2/image-20210411223924994.png" style="zoom:50%;"></p>
<h2 id="域关系演算">域关系演算</h2>
<ul>
<li><strong>形式化定义</strong>
<ul>
<li><span class="math inline">\(\left\{&lt;x_1,\cdots,x_n&gt;|P(x_1,\cdots,x_n)\right\}\)</span></li>
<li><span class="math inline">\(x_i\)</span> 代表域变量，<span class="math inline">\(P\)</span> 为由原子构成的公式</li>
</ul></li>
<li><strong>原子公式</strong>
<ul>
<li><span class="math inline">\(&lt;x_1,\cdots,x_n&gt;\in
R\)</span>：<span class="math inline">\(x_i\)</span>
是<strong>域变量</strong>或<strong>域常量</strong></li>
<li><span class="math inline">\(x\ \theta\ y\)</span>：域变量 <span class="math inline">\(x\)</span> 与 <span class="math inline">\(y\)</span> 满足比较关系 <span class="math inline">\(\theta\)</span></li>
<li><span class="math inline">\(x\ \theta\ c\)</span>：域变量 <span class="math inline">\(x\)</span> 与常量 <span class="math inline">\(c\)</span> 满足比较关系 <span class="math inline">\(\theta\)</span></li>
</ul></li>
</ul>
<h3 id="域关系演算例子">域关系演算例子</h3>
<p><img src="/2021/04/11/DB/CLJ/03-2/image-20210411224956871.png" style="zoom:50%;"></p>
<p><img src="/2021/04/11/DB/CLJ/03-2/image-20210411225250003.png" style="zoom:67%;"></p>
<p><img src="/2021/04/11/DB/CLJ/03-2/image-20210411225347128.png" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.04.SQL 索引</title>
    <url>/2021/04/20/DB/CLJ/04-1/</url>
    <content><![CDATA[<h1 id="sql-索引">SQL 索引</h1>
<h2 id="sql-索引定义">SQL 索引定义</h2>
<ul>
<li>索引是对数据库<strong>性能</strong>影响最关键的一个因素</li>
</ul>
<h3 id="为什么需要索引">为什么需要索引</h3>
<ul>
<li>关系表是个无序集合</li>
<li>如果想要找到某一条记录需要逐行的进行扫描，开销非常大</li>
<li>连接操作是嵌套循环的，开销为 <span class="math inline">\(n^2\)</span> 的</li>
<li>索引：希望建立起一个有序结构</li>
<li>RowID：（文件号，页面号，页内偏移号）
<ul>
<li>物理结构的存储</li>
</ul></li>
<li>索引实现的直观解释</li>
</ul>
<p><img src="/2021/04/20/DB/CLJ/04-1/image-20210420164754395.png" style="zoom:60%;"></p>
<ul>
<li>B+树</li>
</ul>
<p><img src="/2021/04/20/DB/CLJ/04-1/image-20210420164903887.png" style="zoom:47%;"></p>
<h3 id="索引的作用">索引的作用</h3>
<ul>
<li>查找元组
<ul>
<li>查找特定行</li>
</ul></li>
<li>表连接
<ul>
<li>如果行上都有索引的话，可以基于索引进行归并连接</li>
</ul></li>
<li>排序
<ul>
<li>排序列上有索引的话，直接按照索引排序</li>
</ul></li>
<li>分组
<ul>
<li>取值相同的行分在一起</li>
</ul></li>
<li>保证唯一性
<ul>
<li>声明一个列是唯一的，系统在内部会自动创建一个唯一的索引来支持它</li>
<li>有序结构中插入元素，判断是否唯一很快</li>
</ul></li>
</ul>
<h3 id="索引的定义">索引的定义</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span> ] index 索引名</span><br><span class="line">[ <span class="keyword">using</span>&#123; btree<span class="operator">|</span> hash &#125; ]</span><br><span class="line"><span class="keyword">on</span> 表名(列名[<span class="keyword">asc</span><span class="operator">/</span><span class="keyword">desc</span>] [ , 列名 <span class="keyword">asc</span><span class="operator">/</span><span class="keyword">desc</span>]...)</span><br></pre></td></tr></table></figure>
<h4 id="ascdesc">asc/desc</h4>
<ul>
<li>索引表中索引值的排序次序，缺省为 asc</li>
<li>降序索引的用处</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> A, B <span class="keyword">from</span> R <span class="keyword">order</span> <span class="keyword">by</span> A <span class="keyword">asc</span>, B <span class="keyword">desc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index my_idx <span class="keyword">on</span> R(A <span class="keyword">asc</span>, B <span class="keyword">desc</span>)</span><br></pre></td></tr></table></figure>
<h4 id="unique">unique</h4>
<ul>
<li>唯一性索引</li>
<li>不允许表中不同的行在索引列上取相同值</li>
<li>若已有相同值存在，则系统给出相关信息，不建此索引</li>
<li>系统拒绝违背唯一性的插入、更新</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> uidxTb(</span><br><span class="line">    col1 <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    col2 <span class="type">int</span> <span class="keyword">unique</span>,</span><br><span class="line">    col3 <span class="type">int</span> <span class="keyword">unique</span> index (col3)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>效果是一致的，系统会建立三个索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> uidxTb</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/20/DB/CLJ/04-1/image-20210420165801101.png"></p>
<h4 id="innodb_fill_factor">InnoDB_fill_factor</h4>
<ul>
<li>fill_factor
指定在<strong>创建索引</strong>的过程中，各索引页的填满程度</li>
<li>为何索引页要预留空间？
<ul>
<li>如果某个索引页填满，系统就必须花时间拆分该索引页，以便为新行腾出空间，这需要很大开销并造成索引碎片</li>
<li>新来的索引码如果恰好在某个填满的索引页，则需要进行拆分，开销比较大</li>
</ul></li>
</ul>
<h5 id="索引碎片">索引碎片</h5>
<p><img src="/2021/04/20/DB/CLJ/04-1/image-20210420170749539.png" style="zoom:70%;"></p>
<ul>
<li>由于经常性的拆分操作，会导致页面逻辑顺序和物理顺序不一致的情况</li>
<li>索引碎片的负面影响？
<ul>
<li>读盘较多</li>
</ul></li>
<li>如何消除索引碎片？
<ul>
<li>把索引删了重建</li>
</ul></li>
</ul>
<h3 id="聚簇索引">聚簇索引</h3>
<ul>
<li>cluster：聚簇索引</li>
<li>表中元组按索引项的值排序并<strong>物理地聚簇</strong>在一起</li>
<li>一个基本表上只能建一个聚簇索引</li>
<li><strong>聚簇索引使得逻辑访问顺序和物理存储顺序尽可能一致</strong></li>
<li>聚簇索引的好处</li>
</ul>
<p><img src="/2021/04/20/DB/CLJ/04-1/image-20210420170015594.png" style="zoom:60%;"></p>
<ul>
<li>如果建立了聚簇索引，那么原来的表就没了，数据存储在聚簇索引的叶结点上</li>
</ul>
<h3 id="索引的选择度">索引的选择度</h3>
<h4 id="理想选择度">理想选择度</h4>
<ul>
<li>索引的理想选择度 = 1 / 索引列的唯一值个数
<ul>
<li>集势：cardinality（NUM_DISTINCT）</li>
</ul></li>
<li>选择度越小，越适合建索引
<ul>
<li>例如某一列上只有两个值，对其建索引只能排除一半的数据，效率不高</li>
</ul></li>
</ul>
<h4 id="实际选择度">实际选择度</h4>
<ul>
<li>针对特定的查询，系统会通过评估来确定是否启用现有的索引
<ul>
<li>如果满足条件的行太多了，则没必要启用索引</li>
<li>索引中的行一定比原表少，但是对表查询和用索引查询效率是不一样的</li>
<li><strong>对表查询是顺序扫描磁盘</strong>，对索引查询是随机读</li>
<li><strong>顺序读性能比随机读高很多</strong></li>
</ul></li>
<li>索引的实际选择度 = 查询结果行数 / 总行数</li>
<li>早期 Oracle 设定的选择度阈值为 20%</li>
<li>现在：2%
<ul>
<li>顺序读的性能远远超过随机读的性能</li>
</ul></li>
<li>估计选择度
<ul>
<li>“=” 的索引选择度为 1 / NUM_DISTINCT</li>
<li>“&lt;&gt;” 的索引选择度是多少？</li>
<li>“&gt;=” 的索引选择度是多少？</li>
<li>在分布不均匀的情况，如何估计选择度的大小？</li>
</ul></li>
<li>事先做一个直方图</li>
</ul>
<h3 id="组合索引">组合索引</h3>
<ul>
<li>组合索引：建立在多个属性列上的索引</li>
<li>如何排序？按照哪一个索引来排序</li>
<li>组合索引建立在 A, B, C 上, 索引码该如何排序？
<ul>
<li>先看 A， 再看 B，再看 C</li>
</ul></li>
<li>该索引只对检索条件中包含 A 列的查询起作用
<ul>
<li>根据组合索引的排序原则看出来</li>
<li>只是对 A 有序，对 B、C 是无序 的</li>
</ul></li>
<li>那为什么需要组合索引呢？</li>
</ul>
<h4 id="应用场景">应用场景</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> A, B, C</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> B <span class="keyword">from</span> R <span class="keyword">where</span> A <span class="operator">&gt;</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>加快查询：对 A 建索引，而不是 B
<ul>
<li>可能系统不使用索引，预估表查询更快</li>
</ul></li>
<li>更快：组合索引 A，B</li>
<li>组合属性不需要回到原表中获取第二个属性，可以直接通过属性获取到</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> R <span class="keyword">where</span> A <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">and</span> B <span class="operator">=</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>组合索引会把 B 放在前面，<strong>等于</strong>过滤能力上更强</li>
</ul>
<h3 id="覆盖索引">覆盖索引</h3>
<ul>
<li><strong>把 select
中的列也包含进索引中</strong>，这样就可以完全基于索引回答查询，避免对表的访问</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index my_idx <span class="keyword">on</span> R(A) include B</span><br></pre></td></tr></table></figure>
<ul>
<li>与组合索引的区别
<ul>
<li><strong>B 值不出现在索引的中间结点上</strong>，只在叶结点上出现（B
值不参与排序）</li>
</ul></li>
</ul>
<h3 id="过滤索引">过滤索引</h3>
<ul>
<li>在索引的定义中加入 where
语句，索引中只包括那些满足过滤条件的列值</li>
<li>例如在数据分布不均匀的条件下，对数据少的部分建索引</li>
<li>例子：女生很少的场景</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index my_idxon S(sex) <span class="keyword">where</span> sex <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以用 <code>where is not null</code> 使得索引中不包括 null</li>
</ul>
<h3 id="函数索引">函数索引</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对姓名建索引 */</span></span><br><span class="line"><span class="keyword">create</span> index idx1 <span class="keyword">on</span> S(sname)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按照选择某个人, 但是他的输入可能不规范(大小写) */</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">from</span> S <span class="keyword">where</span> sname<span class="operator">=</span><span class="string">&#x27;tOm&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上面的索引对这个查询是无效的 */</span></span><br><span class="line"><span class="comment">/* 上面索引是针对 sname 建的, 但是这个查询是 UPEER(sname) */</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">from</span> S <span class="keyword">where</span> <span class="built_in">UPPER</span>(sname)<span class="operator">=</span><span class="string">&#x27;TOM&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 先针对其建立函数索引,再查询 */</span></span><br><span class="line"><span class="keyword">create</span> index idx2 <span class="keyword">on</span> S(<span class="built_in">UPPER</span>(sname))</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> myTb(</span><br><span class="line">    x <span class="type">int</span>,</span><br><span class="line">    y <span class="type">int</span>,</span><br><span class="line">    index func_idx (<span class="built_in">sqrt</span>(<span class="built_in">power</span>(x,<span class="number">2</span>)<span class="operator">+</span><span class="built_in">power</span>(y,<span class="number">2</span>)))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> myTb(</span><br><span class="line">    id <span class="type">char</span>(<span class="number">18</span>),</span><br><span class="line">    index idx1(<span class="built_in">substring</span>(id,<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> myTb</span><br><span class="line"><span class="keyword">where</span> <span class="built_in">substring</span>(id,<span class="number">7</span>,<span class="number">8</span>)<span class="operator">=</span><span class="string">&#x27;20000101&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="索引的删除">索引的删除</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 索引名</span><br></pre></td></tr></table></figure>
<ul>
<li>drop index 语句不适用于通过定义 primary key 或 unique
约束创建的索引，它们必须通过除去约束来撤销</li>
<li>只能够删除用户定义的索引</li>
</ul>
<h3 id="索引的使用说明">索引的使用说明</h3>
<ul>
<li>一个表上可建多个索引</li>
<li>可以动态地定义索引，随时建立和删除索引</li>
<li>索引可以提高查询效率
<ul>
<li>耗费空间，降低了插入、删除、更新的效率</li>
</ul></li>
<li>理想化状态：不允许用户在数据操作中引用索引</li>
<li>数据的物理独立性：索引如何使用完全由系统决定</li>
<li>强行让系统使用索引
<ul>
<li>select ... from MyTb force index(idx_name)</li>
</ul></li>
</ul>
<h3 id="索引的选择">索引的选择</h3>
<ul>
<li>工作负载集：首先确定在这个数据集经常运行的命令</li>
<li>分析每一个查询在不同索引条件下的执行代价</li>
<li>推荐执行代价最小的索引</li>
</ul>
<p><img src="/2021/04/20/DB/CLJ/04-1/image-20210420174817557.png" style="zoom:50%"></p>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.03.关系模型(1)</title>
    <url>/2021/04/02/DB/CLJ/03/</url>
    <content><![CDATA[<h1 id="关系模型">关系模型</h1>
<ul>
<li>简单即是有力</li>
</ul>
<h2 id="关系模型基本概念">关系模型基本概念</h2>
<ul>
<li>Table
<ul>
<li>An arrangement of words, numbers, orsigns, or combinations of them,
as in parallel columns, to exhibit a set off acts or relations in a
definite, compact, and comprehensive form; a synopsis or scheme.</li>
</ul></li>
</ul>
<h3 id="关系模型的诞生">关系模型的诞生</h3>
<ul>
<li>E.F.Codd 于 70 年代初提出关系数据理论，他因此获得 1981 年的 ACM
图灵奖
<ul>
<li>1970: “A Relational Model of data for Large Shared Data Banks”</li>
</ul></li>
<li>提出关系代数和关系演算</li>
<li>1972：1NF, 2NF, 3NF</li>
<li>1974：BCNF</li>
<li><strong>关系理论</strong>建立在<strong>集合代数理论基础</strong>之上，有着坚实的数学基础</li>
</ul>
<h3 id="早期代表系统">早期代表系统</h3>
<ul>
<li>SystemＲ：由 IBM 研制</li>
<li>INGRES：由加州 Berkeley 分校研制</li>
</ul>
<h3 id="数据库与图灵奖">数据库与图灵奖</h3>
<ul>
<li>数据库有 4 位获得图灵奖的人</li>
<li>Charles W. Bachman（查尔斯 • 巴赫曼）
<ul>
<li>1973 主持设计与开发了最早的<strong>网状</strong>数据库管理系统
IDS</li>
</ul></li>
<li>Edgar F. Codd（埃德加 • 科德）
<ul>
<li>1981 提出了<strong>关系数据库</strong></li>
</ul></li>
<li>James Gray（詹姆斯 • 格雷）
<ul>
<li>1998
解决保障数据的完整性、安全性、并行性，以及从故障恢复方面发挥了十分关键的作用，提出并实现数据库事务处理</li>
</ul></li>
<li>Michael Stonebraker（迈克尔.斯通布雷克）
<ul>
<li>2014 创造了数据库系统一系列奠基性基本概念和实际技术</li>
<li>基于 INGRES</li>
</ul></li>
</ul>
<h3 id="目前主流的商业数据库系统">目前主流的商业数据库系统</h3>
<ul>
<li>Oracle, SQLServer, DB2</li>
<li>开源数据库：MySQL, PostgreSQL</li>
<li>OceanBase, GaussDB, 达梦
<ul>
<li>GaussDB 基于 PostgreSQL：华为</li>
<li>达梦：武大</li>
<li>OceanBase：阿里</li>
</ul></li>
<li>Access, SQLite
<ul>
<li>SOLite 装机量最大，手机上都有</li>
</ul></li>
</ul>
<h3 id="笛卡尔积">笛卡尔积</h3>
<h4 id="基本概念">基本概念</h4>
<ul>
<li><strong>域</strong>（Domain）
<ul>
<li>具有相同数据类型的一组值的集合</li>
<li>如整数集合、字符串集合、全体学生集合</li>
</ul></li>
<li>一组域 <span class="math inline">\(D_1,D_1,\cdots,D_n\)</span>
的<strong>笛卡尔积</strong></li>
</ul>
<p><span class="math display">\[
D_1\times D_2\times\cdots\times D_n=\left\{(d_1,d_2,\cdots,d_n)|d_i\in
D_i,i=1,2,\cdots,n\right\}
\]</span></p>
<ul>
<li>n <strong>元组</strong>（tuple）：笛卡尔积的元素 <span class="math inline">\((d_1,d_2,\cdots,d_n)\)</span></li>
<li>元组的每个值 <span class="math inline">\(d_i\)</span>
称作<strong>分量</strong>（component）</li>
<li>若 <span class="math inline">\(D_i\)</span> 的基数为 <span class="math inline">\(m_i\)</span>，则笛卡尔积的<strong>基数</strong>为
<span class="math inline">\(\prod_{i=1}^{n}m_i\)</span></li>
<li>笛卡尔积可以表示为<strong>二维表</strong>的形式
<ul>
<li>每一列表示一个分量</li>
</ul></li>
<li><strong>关系</strong>：笛卡尔积的子集
<ul>
<li>笛卡尔积 <span class="math inline">\(D_1\times D_2\times\cdots\times
D_n\)</span> 的<strong>子集</strong>称作在域 <span class="math inline">\(D_1,D_2,\cdots,D_n\)</span>
上的<strong>关系</strong> 用 <span class="math inline">\(R(D_1,D_2,\cdots,D_n)\)</span> 表示</li>
<li><span class="math inline">\(R\)</span> 是关系的名字，<span class="math inline">\(n\)</span>
是关系的<strong>度</strong>或<strong>目</strong></li>
</ul></li>
</ul>
<h4 id="笛卡尔积与关系">笛卡尔积与关系</h4>
<ul>
<li>笛卡尔积：<strong>可能的世界</strong></li>
<li>关系：<strong>实际的世界</strong></li>
<li>关系是笛卡尔积中有意义的子集
<ul>
<li>有意义：子集得有名字</li>
<li>名称不一样，反应的现实中的关系也不一样</li>
<li>例子
<ul>
<li>Teach（老师、学生、课程）：老师教授课程</li>
<li>Assistant（老师、学生、课程）：学生给老师当助教</li>
</ul></li>
</ul></li>
</ul>
<h4 id="数学问题">数学问题</h4>
<ul>
<li><p><span class="math inline">\(D_1,D_2,D_3\)</span> 的基数分别为
<span class="math inline">\(d_1,d_2.d_3\)</span>，则 <span class="math inline">\(D_1\times D_2\times D_3\)</span>
包含的关系数目</p>
<ul>
<li>笛卡尔积元组个数：<span class="math inline">\(d_1\times d_2\times
d_3\)</span></li>
</ul></li>
<li><p>关系数目：<span class="math inline">\(2^{d_1\times d_2\times
d_3}\)</span></p></li>
<li><p>13
个元素的集合，划分为多少个域，每个域多少个元素，使得笛卡尔积包含的关系数目最多</p>
<ul>
<li>4 x 3 x 3 x 3 = 108</li>
<li>关系数目：<span class="math inline">\(2^{108}\)</span></li>
</ul></li>
</ul>
<h3 id="关系的性质">关系的性质</h3>
<ul>
<li>列是<strong>同质</strong>的，是<strong>同一类型的数据</strong>，即每一列中的分量来自同一域</li>
<li>不同的列可以来自同一域，每列必须有不同的属性名
<ul>
<li>一元联系</li>
</ul></li>
<li>行列的顺序无关紧要</li>
<li>任意两个元组不能完全相同（集合内不能有相同的两个元素）
<ul>
<li>实际的数据库的表允许重复行的存在</li>
</ul></li>
<li><strong>每一分量必须是不可再分的数据</strong>，称其为作满足第一范式（1NF）的关系</li>
</ul>
<p><img src="/2021/04/02/DB/CLJ/03/image-20210402205215019.png" style="zoom:80%;"></p>
<ul>
<li>从查询的角度，深入分析嵌套关系的利弊
<ul>
<li>如果查询某个学生选修的课程哪些
<ul>
<li>嵌套关系性能更高，直接通过学号索引就行</li>
<li>1NF 关系需要先对学号过滤，再取出来课程</li>
</ul></li>
<li>如果查询选修的某个课程的学生有哪些
<ul>
<li>嵌套关系没办法直接表达（无法使用声明式查询，需要编程进行路径式查询）</li>
<li>1NF 各种属性的查询没有区别</li>
</ul></li>
</ul></li>
</ul>
<h2 id="关系模型-3-要素">关系模型 3 要素</h2>
<h3 id="数据结构">数据结构</h3>
<ul>
<li>单一的数据结构：<strong>关系</strong>
<ul>
<li>实体集、联系都表示成关系</li>
</ul></li>
<li>单一的数据结构好处是什么
<ul>
<li>实现数据库的时候，只需要实现一种数据结构</li>
</ul></li>
</ul>
<h4 id="码">码</h4>
<ul>
<li><strong>候选码</strong>（Candidate Key）
<ul>
<li>关系中的一个属性组，其值能唯一标识一个元组</li>
<li>若从属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称作候选码</li>
</ul></li>
<li><strong>任何一个候选码</strong>中的属性称作<strong>主属性</strong>
<ul>
<li>主属性：<strong>存在</strong>一个候选码包含这个属性</li>
</ul></li>
<li><strong>主码</strong>（PK: Primary Key）
<ul>
<li>进行数据库设计时，从一个关系的多个<strong>候选码</strong>中<strong>选定一个</strong>作为主码</li>
</ul></li>
<li><strong>外码</strong>（FK: Foreign Key）
<ul>
<li>关系 R 中的一个属性组，它不是 R 的码，但它与另一个关系 S
的码相对应，称这个属性组为 R 的外码</li>
<li>反映实体之间的联系</li>
</ul></li>
</ul>
<h4 id="关系模式与关系">关系模式与关系</h4>
<h5 id="关系模式">关系模式</h5>
<ul>
<li>关系的描述，记作 <span class="math inline">\(R(A_1,A_2,\cdots,A_n)\)</span> 包括：
<ul>
<li><strong>关系名</strong>、<strong>关系中的属性名</strong></li>
<li>属性向域的<strong>映象</strong>，通常说明为属性的类型、长度等</li>
<li>属性间的<strong>数据依赖</strong>关系
<ul>
<li>比如在特定的时间和教室只能安排一门课</li>
</ul></li>
</ul></li>
<li><strong>关系模式</strong>是<strong>型</strong>，是<strong>稳定</strong>的</li>
</ul>
<h5 id="关系">关系</h5>
<ul>
<li>某一时刻对应某个关系模式的内容（元组的集合）</li>
<li><strong>关系</strong>是<strong>某一时刻的值</strong>，是<strong>随时间不断变化</strong>的</li>
</ul>
<h4 id="关系数据库的构成">关系数据库的构成</h4>
<ul>
<li>关系数据库的<strong>型</strong>
<ul>
<li>是<strong>关系模式</strong>的集合，即数据库描述</li>
<li>称作数据库的<strong>内涵</strong>（Intension）</li>
</ul></li>
<li>关系数据库的<strong>值</strong>
<ul>
<li>是<strong>某一时刻关系</strong>的集合</li>
<li>称作数据库的<strong>外延</strong>（Extension）</li>
</ul></li>
</ul>
<h3 id="数据操作">数据操作</h3>
<h4 id="关系操作">关系操作</h4>
<ul>
<li>关系操作是<strong>集合操作</strong></li>
<li>操作的对象及结果都是集合</li>
<li>是<strong>一次一集合</strong>（Set-at-a-time）的方式
<ul>
<li>非关系型的数据操作方式是<strong>一次一记录</strong>
（Record-at-a-time）</li>
</ul></li>
</ul>
<h4 id="关系数据语言的特点">关系数据语言的特点</h4>
<ul>
<li><strong>一体化</strong>
<ul>
<li>对象单一，都是关系，因此操作符也单一</li>
</ul></li>
<li><strong>非过程化</strong>
<ul>
<li>用户只需提出 “做什么”，无须说明 “怎么做”</li>
<li>存取路径的选择和操作过程由系统自动完成</li>
</ul></li>
<li><strong>面向集合的存取方式</strong>
<ul>
<li>操作对象是一个或多个关系，结果是一个新的关系（一次一关系）</li>
</ul></li>
</ul>
<h4 id="抽象的关系模型查询语言">抽象的关系模型查询语言</h4>
<ul>
<li>关系代数（主流）</li>
<li>关系演算
<ul>
<li>元组关系演算</li>
<li>域关系演算</li>
</ul></li>
</ul>
<h5 id="关系演算">关系演算</h5>
<ul>
<li>用<strong>谓词</strong>来表达查询，只需描述所需信息的特性</li>
<li>元组关系演算
<ul>
<li>谓词变元的<strong>基本对象</strong>是<strong>元组变量</strong></li>
</ul></li>
<li>域关系演算
<ul>
<li>谓词变元的<strong>基本对象</strong>是<strong>域变量</strong></li>
</ul></li>
</ul>
<h5 id="关系代数">关系代数</h5>
<ul>
<li>用<strong>对关系的运算</strong>来表达查询</li>
<li>需要指明所用操作</li>
<li>相比关系演算，关系代数是过程性操作语言
<ul>
<li>这里的过程性指的是需要人为地把<strong>关系序列</strong>定义出来
<ul>
<li>和之前的过程性查询不是一个概念</li>
</ul></li>
<li>而关系演算只是通过一系列谓词来描述</li>
</ul></li>
</ul>
<h5 id="具体系统中的关系操作语言">具体系统中的关系操作语言</h5>
<ul>
<li>SQL
<ul>
<li>介于关系代数和关系演算之间</li>
<li>由 IBM 公司在研制 System R 时提出</li>
</ul></li>
<li>QUEL
<ul>
<li>基于 Codd 提出的<strong>元组关系演算</strong>语言 ALPHA</li>
<li>在 INGRES 上实现</li>
</ul></li>
<li>QBE
<ul>
<li>基于<strong>域关系</strong>演算</li>
<li>由 IBM 公司研制</li>
</ul></li>
</ul>
<h3 id="完整性约束">完整性约束</h3>
<ul>
<li><strong>实体完整性</strong>、<strong>参照完整性</strong>、<strong>用户定义完整性</strong></li>
</ul>
<h4 id="实体完整性">实体完整性</h4>
<ul>
<li>关系的主码中的属性值不能为空值</li>
<li>意义：关系对应到现实世界中的实体集，元组对应到实体，<strong>实体是相互可区分的</strong>，通过主码来唯一标识，若主码为空，则出现不可标识的实体，这是不容许的</li>
<li>三值逻辑</li>
</ul>
<h4 id="参照完整性">参照完整性</h4>
<ul>
<li>相对于外码而言的</li>
<li>如果关系 <span class="math inline">\(R_2\)</span> 的外码 <span class="math inline">\(F_k\)</span> 与关系 <span class="math inline">\(R_1\)</span> 的主码 <span class="math inline">\(P_k\)</span> 相对应，则 <span class="math inline">\(R_2\)</span> 中每个元组的 <span class="math inline">\(F_k\)</span> 值或者等于 <strong><span class="math inline">\(R_1\)</span> 中某个元组的 <span class="math inline">\(P_k\)</span>
值</strong>，或者为<strong>空值</strong>
<ul>
<li>空值是允许的，可以认为是未分配、不知道</li>
</ul></li>
<li>如果关系 <span class="math inline">\(R_2\)</span> 的某个元组 <span class="math inline">\(t_2\)</span> 参照了关系 <span class="math inline">\(R_1\)</span> 的某个元组 <span class="math inline">\(t_1\)</span>，则 <span class="math inline">\(t_1\)</span>
必须存在，也即必须与客观存在的实体发生联系</li>
</ul>
<h4 id="用户定义的完整性">用户定义的完整性</h4>
<ul>
<li>用户针对具体应用环境定义的完整性约束条件</li>
<li>数据库应该支持这些功能，否则对应用程序言而言，就需要它自己去判断</li>
</ul>
<h4 id="比较">比较</h4>
<ul>
<li>实体完整性和参照完整性由系统自动支持</li>
<li>系统提供定义和检验用户定义的完整性的机制</li>
</ul>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.04.SQL 数据查询(2)</title>
    <url>/2021/04/24/DB/CLJ/04-3/</url>
    <content><![CDATA[<h1 id="sql-数据查询">SQL 数据查询</h1>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> ...</span><br><span class="line"><span class="keyword">From</span> ...</span><br><span class="line"><span class="keyword">Where</span> ...</span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">by</span> ...</span><br><span class="line"><span class="keyword">Having</span> ...</span><br><span class="line"><span class="keyword">Union</span> ...</span><br><span class="line"><span class="keyword">Order</span> <span class="keyword">by</span> ...</span><br><span class="line">Limit ...</span><br></pre></td></tr></table></figure>
<h2 id="在线资源">在线资源</h2>
<ul>
<li>http://sqlfiddle.com</li>
</ul>
<h2 id="分组">分组</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 列名 [ <span class="keyword">having</span> 条件表达式 ]</span><br></pre></td></tr></table></figure>
<ul>
<li>group by
将表中行按指定列上值相等的原则分组，然后在每一分组上使用聚集函数，得到单一值</li>
<li>having
对<strong>分组</strong>进行选择，只将聚集函数作用到<strong>满足条件的分组</strong>上</li>
</ul>
<h3 id="需求">需求</h3>
<ul>
<li>统计每个同学的平均成绩</li>
<li>统计每个课程的平均成绩</li>
</ul>
<h3 id="使用">使用</h3>
<ul>
<li><strong>目标列必须是分组属性</strong></li>
<li>select 语句后面的列必须是 group by 后面的列
<ul>
<li>因为在 group by 之后，对每一个 group
会输出一条记录，使用其他的属性会导致每一个属性有多个值，不满足原子性
<ul>
<li>MySQL 测试好像是可以的，不过只输出第一条记录</li>
</ul></li>
</ul></li>
<li><strong>如果其他属性使用的是聚集函数，那么是可以的</strong></li>
<li>列出每个学生的最高、最低、平均成绩</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno, <span class="built_in">max</span>(grade), <span class="built_in">min</span>(grade), <span class="built_in">avg</span>(grade)</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sno</span><br></pre></td></tr></table></figure>
<ul>
<li>having 是对分组进行过滤</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 列出没有挂科经历同学的平均成绩 */</span></span><br><span class="line"><span class="keyword">select</span> sno, <span class="built_in">avg</span>(grade)</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sno</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">min</span>(grade)<span class="operator">&gt;=</span><span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 列出所有同学及格课程的平均成绩 */</span></span><br><span class="line"><span class="keyword">select</span> sno, <span class="built_in">avg</span>(grade)</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> grade<span class="operator">&gt;=</span><span class="number">60</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sno</span><br></pre></td></tr></table></figure>
<h3 id="分组查询中各子句的顺序">分组查询中各子句的顺序</h3>
<ul>
<li>列出每一年龄组中男学生（超过50人）的人数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> age, <span class="built_in">count</span>(sno)</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> sex<span class="operator">=</span><span class="string">&#x27;M&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> age</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">50</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行顺序
<ul>
<li>where、group by、having</li>
<li>先过滤、再分组、在对分组进行选择</li>
</ul></li>
</ul>
<h3 id="group_concat">group_concat</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> dname,</span><br><span class="line">    group_concat(sname)</span><br><span class="line"><span class="keyword">from</span> ds</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dname</span><br></pre></td></tr></table></figure>
<ul>
<li>串接字符串的功能</li>
<li>例如上面的 select 之中的列如果不是 group by 中的属性列，把
group_concat 当作一个聚集函数，作用是把这一组内的所有数据用
<code>,</code> 拼接成字符串</li>
</ul>
<h3 id="cube">cube</h3>
<ul>
<li>对 group by 的扩展</li>
<li>所有的 group by 进行一个预先计算，把结果保存起来，这样在之后机型
group by 的操作的时候，很快就可以得到结果</li>
</ul>
<p><span class="math display">\[
\mathrm{Cube}=\bigcup_{A_i\in A}\mathrm{group\ by} A_{i}
\]</span></p>
<ul>
<li>n 个属性的 group by，一共有 <span class="math inline">\(2^n\)</span>
个</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Model,<span class="keyword">Year</span>,Color,<span class="built_in">sum</span>(Sales)</span><br><span class="line"><span class="keyword">from</span> car_sales</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Model,<span class="keyword">Year</span>,Color <span class="keyword">with</span> <span class="keyword">cube</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>行数计算</strong>
<ul>
<li>(model值个数+1) x (year值个数+1) x (color值个数+1)</li>
</ul></li>
</ul>
<p><img src="/2021/04/24/DB/CLJ/04-3/image-20210425233923278.png" style="zoom:50%;"></p>
<ul>
<li>cube 在实际过程中并不是生成 All，而是为每条记录生成一个 null
<ul>
<li>问题来了，怎么区分原来的 null 和生成的 null（我们需要处理成
All）</li>
<li><strong>grouping</strong></li>
</ul></li>
</ul>
<h4 id="grouping">grouping</h4>
<ul>
<li>grouping 是一个聚合函数</li>
<li>它产生一个附加的列，当用 cube 或 rollup
运算符添加行时，附加的列输出值为 1，否则为 0</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;TotleSold&#x27;</span> <span class="operator">=</span> <span class="built_in">sum</span>(sales),</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">when</span>(<span class="keyword">grouping</span>(model)<span class="operator">=</span><span class="number">1</span>) <span class="keyword">then</span> <span class="string">&#x27;ALL&#x27;</span></span><br><span class="line">        <span class="keyword">else</span> isnull(model, <span class="string">&#x27;????&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span> model,</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">when</span>(<span class="keyword">grouping</span>(<span class="keyword">year</span>)<span class="operator">=</span><span class="number">1</span>) <span class="keyword">then</span> <span class="string">&#x27;ALL&#x27;</span></span><br><span class="line">        <span class="keyword">else</span> isnull(<span class="keyword">year</span>, <span class="string">&#x27;????&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">year</span>,</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">when</span>(<span class="keyword">grouping</span>(color)<span class="operator">=</span><span class="number">1</span>) <span class="keyword">then</span> <span class="string">&#x27;ALL&#x27;</span></span><br><span class="line">        <span class="keyword">else</span> isnull(color, <span class="string">&#x27;????&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span> color</span><br><span class="line"><span class="keyword">from</span> my_cube</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> model, theyear, color <span class="keyword">with</span> <span class="keyword">cube</span></span><br></pre></td></tr></table></figure>
<h3 id="rollup">rollup</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Model,<span class="keyword">Year</span>,Color <span class="keyword">with</span> <span class="keyword">rollup</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/24/DB/CLJ/04-3/image-20210427140108269.png" style="zoom:50%;"></p>
<ul>
<li>顺序不一样，结果就不一样</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> A, B, C <span class="keyword">with</span> <span class="keyword">rollup</span></span><br><span class="line"><span class="comment">/* 效果上等价于 */</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> A,B,C</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> A,B</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> A</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="行数计算">行数计算</h4>
<ul>
<li><span class="math inline">\(|colA|=a,|colB|=b,|colC|=c\)</span></li>
<li>求 <code>group by colA, colB, colC with rollup</code>
的行数是多少</li>
<li><span class="math inline">\(a*(b*(c+1)+1)+1\)</span></li>
<li><strong>相当于每一个属性增加了一个 All</strong></li>
<li>一个例子</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> color,model, <span class="built_in">sum</span>(amount)</span><br><span class="line"><span class="keyword">from</span> sales</span><br><span class="line"><span class="keyword">group</span> bycolor, model <span class="keyword">with</span> <span class="keyword">rollup</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/24/DB/CLJ/04-3/image-20210427140905325.png"></p>
<h3 id="如何生成多个分组语句的合并报表">如何生成多个分组语句的合并报表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> model, <span class="keyword">year</span>, <span class="keyword">null</span> <span class="keyword">as</span> color, <span class="built_in">sum</span>( sales)</span><br><span class="line"><span class="keyword">from</span> car_sales</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> model, <span class="keyword">year</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> model, <span class="keyword">null</span> <span class="keyword">as</span> <span class="keyword">year</span>, color, <span class="built_in">sum</span>(sales)</span><br><span class="line"><span class="keyword">from</span> car_sales</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> model, color</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">null</span> <span class="keyword">as</span> model, <span class="keyword">year</span>, color, <span class="built_in">sum</span>(sales)</span><br><span class="line"><span class="keyword">from</span> car_sales</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">year</span>, color</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">null</span> <span class="keyword">as</span> model, <span class="keyword">null</span> <span class="keyword">as</span> <span class="keyword">year</span>, <span class="keyword">null</span> <span class="keyword">as</span> color, <span class="built_in">sum</span>(sales)</span><br><span class="line">fromcar_sales</span><br></pre></td></tr></table></figure>
<ul>
<li>繁琐
<ul>
<li>代码繁琐</li>
</ul></li>
<li>低效
<ul>
<li>car_sale 访问 4 遍</li>
<li>如果 group by 之间有包含关系的话，可以在另外一个基础上进行操作
<ul>
<li>例如 <code>group by A</code> 在 <code>group by A, B</code>
的基础上进行</li>
</ul></li>
</ul></li>
</ul>
<h4 id="分组属性集">分组属性集</h4>
<ul>
<li>grouping sets</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">grouping</span> sets ((分组属性集<span class="number">1</span>), (分组属性集<span class="number">2</span>), ..., (分组属性集n))</span><br></pre></td></tr></table></figure>
<ul>
<li>系统可以只扫描一次，如果包含包含关系的话系统可以更加高效的执行</li>
<li>例子</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> model,<span class="keyword">year</span>,color,<span class="built_in">sum</span>(sales)</span><br><span class="line"><span class="keyword">from</span> car_sales</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">grouping</span> sets (</span><br><span class="line">    (model,theyear),</span><br><span class="line">    (model,color),</span><br><span class="line">    (theyear,color),</span><br><span class="line">    ()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="产生分组属性集的代数操作">产生分组属性集的代数操作</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cube</span>(a,b) <span class="operator">=</span> <span class="keyword">grouping</span> sets(</span><br><span class="line">    (a,b),</span><br><span class="line">    (a),</span><br><span class="line">    (b),</span><br><span class="line">    ()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rollup</span>(x, y, z) <span class="operator">=</span> <span class="keyword">grouping</span> sets(</span><br><span class="line">    (x, y, z),</span><br><span class="line">    (x, y),</span><br><span class="line">    (x),</span><br><span class="line">    ()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">cube</span>(a,b),<span class="keyword">rollup</span>(x,y,z)</span><br><span class="line"><span class="operator">=</span> <span class="keyword">group</span> <span class="keyword">by</span> groupingsets((a,b),(a),(b),()), groupingsets((x,y,z),(x,y),(x),())</span><br><span class="line"><span class="operator">=</span> <span class="keyword">group</span> <span class="keyword">by</span> groupingsets(</span><br><span class="line">    (a,b,x,y,z),(a,b,x,y),(a,b,x),(a,b),</span><br><span class="line">    (a,x,y,z),(a,x,y),(a,x),(a),</span><br><span class="line">    (b,x,y,z),(b,x,y),(b,x),(b),</span><br><span class="line">    (x,y,z),(x,y),(x),()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="如何标识合并报表中行的分组归属">如何标识合并报表中行的分组归属</h3>
<ul>
<li>grouping_id() 函数可以标示每一行到底和哪个 group by 相关联</li>
<li>这是通过为不同的分组分配不同的整数来做到的（<strong>二进制位表示</strong>）</li>
<li>例子</li>
<li>对于grouping_id(A, B, C, D)
<ul>
<li>分组 (A,B,C,D) 的标识为 <span class="math inline">\(8\ast0+4\ast0+2\ast0+1\ast0＝0\)</span></li>
<li>分组 (C) 的标识为 <span class="math inline">\(8\ast1+4\ast1+2\ast0+1\ast1＝13\)</span></li>
</ul></li>
</ul>
<h2 id="嵌套子查询">嵌套子查询</h2>
<ul>
<li>集合成员资格（in子查询）</li>
<li>集合之间的比较（some/all子查询）</li>
<li>集合基数的测试（exists子查询）</li>
</ul>
<h3 id="集合成员资格in子查询">集合成员资格（in子查询）</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">表达式 [<span class="keyword">not</span>] <span class="keyword">in</span> (子查询)</span><br></pre></td></tr></table></figure>
<ul>
<li>判断表达式的值是否在子查询的结果中</li>
</ul>
<h4 id="应用">应用</h4>
<ul>
<li>列出张军和王红同学的所有信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> sname <span class="keyword">in</span> (<span class="string">&#x27;张军&#x27;</span>, <span class="string">&#x27;王红&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>列出选修了c1号课程的学生的姓名
<ul>
<li>效果上是等价的</li>
<li>连接操作一定不会比 in 子查询差
<ul>
<li>一般的数据库会试图将 in 子查询转换为连接操作</li>
</ul></li>
<li>in 子查询效率不高
<ul>
<li>在执行完 in 之后的操作之后，会进行一个排序的工作实现高效的查找</li>
<li>排序是个比较大的开销</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 连接操作 */</span></span><br><span class="line"><span class="keyword">select</span> sname</span><br><span class="line">fromS, SC</span><br><span class="line"><span class="keyword">where</span> S.sno<span class="operator">=</span> SC.sno <span class="keyword">and</span> cno<span class="operator">=</span>c1</span><br><span class="line"></span><br><span class="line"><span class="comment">/* in 子查询 */</span></span><br><span class="line"><span class="keyword">select</span> sname</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> sno <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> sno</span><br><span class="line">    <span class="keyword">from</span> SC</span><br><span class="line">    <span class="keyword">where</span> cno<span class="operator">=</span>c1</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>列出选修了 c1 号和 c2 号课程的学生的学号</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> SC.cno<span class="operator">=</span>c1</span><br><span class="line"><span class="keyword">and</span> sno <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> sno</span><br><span class="line">    <span class="keyword">from</span> SC</span><br><span class="line">    <span class="keyword">where</span> cno<span class="operator">=</span>c2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="集合之间的比较someall子查询">集合之间的比较（some/all子查询）</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">表达式 比较运算符θ <span class="keyword">some</span>(子查询)</span><br></pre></td></tr></table></figure>
<ul>
<li>表达式的值至少与子查询结果中的一个值相比，满足比较运算符 θ</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">表达式 比较运算符θ <span class="keyword">all</span>(子查询)</span><br></pre></td></tr></table></figure>
<ul>
<li>表达式的值与子查询结果中的所有的值相比，都满足比较运算符θ</li>
</ul>
<h4 id="和-in-子查询的比较">和 in 子查询的比较</h4>
<ul>
<li>(<span class="math inline">\(\ne\)</span>all) 等价于 not in</li>
<li>(=all) <span style="color:red;font-weight:bold">不等价于</span>
in</li>
<li>(=some) <span style="color:red;font-weight:bold">不等价于</span>
in</li>
<li>(<span class="math inline">\(\ne\)</span>some) 等价 not in</li>
</ul>
<h4 id="应用-1">应用</h4>
<ul>
<li>找出平均成绩最高的学生号</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sno</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(grade)<span class="operator">&gt;=</span><span class="keyword">all</span> (</span><br><span class="line">    <span class="comment">/* 分组属性 sno 可以不出现在 select 后面 */</span></span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">avg</span>(grade)</span><br><span class="line">    <span class="keyword">from</span> SC</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> sno</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>求每个系平均成绩最高的同学</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> dno, X.sno</span><br><span class="line"><span class="keyword">from</span> S X,SC</span><br><span class="line"><span class="keyword">where</span> X.sno<span class="operator">=</span>SC.sno</span><br><span class="line"><span class="comment">/* select 后面的属性必须是分组属性(或者聚集函数) */</span></span><br><span class="line"><span class="comment">/* 单从分组而言, dno 无用 */</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dno, X.sno</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(grade)<span class="operator">&gt;=</span><span class="keyword">all</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">avg</span>(grade)</span><br><span class="line">    <span class="keyword">from</span> S,SC</span><br><span class="line">    <span class="keyword">where</span> S.sno<span class="operator">=</span>SC.sno <span class="keyword">and</span> S.dno<span class="operator">=</span>X.dno</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> S.sno</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="集合基数的测试exists子查询">集合基数的测试（exists子查询）</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">not</span>] <span class="keyword">exists</span> (子查询)</span><br></pre></td></tr></table></figure>
<ul>
<li>判断子查询的结果集合中<strong>是否有任何元组存在</strong></li>
</ul>
<h4 id="in-和-exists">in 和 exists</h4>
<ul>
<li>in
后的子查询与外层查询无关，每个子查询<strong>执行一次</strong></li>
<li>而 exists
后的子查询与外层查询有关，需要<strong>执行多次</strong>，称之为<strong>相关子查询</strong>
<ul>
<li>实际查询数据库可能会做优化</li>
<li>如果有索引，并不慢</li>
</ul></li>
</ul>
<h4 id="应用-2">应用</h4>
<ul>
<li>列出选修了 c1 号课程的学生姓名
<ul>
<li>对每位同学<strong>探测</strong>他是否选修了 c1 课程</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sname</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> SC</span><br><span class="line">    <span class="comment">/* 不加表名的 sno 是指子查询的 sno */</span></span><br><span class="line">    <span class="keyword">where</span> cno<span class="operator">=</span>c1 <span class="keyword">and</span> sno<span class="operator">=</span>S.sno</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>列出选修了 c1 号和 c2 号课程的学生的学号
<ul>
<li>先找到选修了 c1 的同学，然后再探测他是否也选修了 c2</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno</span><br><span class="line"><span class="keyword">from</span> SC SC1</span><br><span class="line"><span class="keyword">where</span> SC1.cno <span class="operator">=</span> c1</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> sno</span><br><span class="line">    <span class="keyword">from</span> SC</span><br><span class="line">    <span class="keyword">where</span> cno <span class="operator">=</span> c2 <span class="keyword">and</span> sno <span class="operator">=</span> SC1.sno</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="反半连接not-in-not-exists">反半连接：not in, not exists</h4>
<ul>
<li><strong>集合减法</strong></li>
<li>列出没有选修课程的学生的姓名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* not in */</span></span><br><span class="line"><span class="keyword">select</span> sname</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> sno <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> sno</span><br><span class="line">    <span class="keyword">from</span> SC</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* not exsits */</span></span><br><span class="line"><span class="keyword">select</span> sname</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> sno</span><br><span class="line">    <span class="keyword">from</span> SC</span><br><span class="line">    <span class="keyword">where</span> sno <span class="operator">=</span> S.sno</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="except">except</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sname</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> sno <span class="keyword">in</span> (</span><br><span class="line">    ( <span class="keyword">select</span> sno <span class="keyword">from</span> S )</span><br><span class="line">    <span class="keyword">except</span> <span class="comment">/* MySQL 不支持 except */</span></span><br><span class="line">    ( <span class="keyword">select</span> sno <span class="keyword">from</span> SC )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="left-join">left join</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sname</span><br><span class="line"><span class="keyword">from</span>(S <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> SC <span class="keyword">on</span> S.sno<span class="operator">=</span>SC.sno)</span><br><span class="line"><span class="keyword">where</span> cno <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<h3 id="子查询中的属性解析匹配">子查询中的属性解析匹配</h3>
<ul>
<li><strong>就近匹配</strong></li>
<li>两个表中表达相同含义的列，具有不同的名称</li>
</ul>
<p><img src="/2021/04/24/DB/CLJ/04-3/image-20210427151820962.png" style="zoom:50%;"></p>
<ul>
<li>输出没有选 c01 课程的同学
<ul>
<li><strong>错误解法</strong></li>
<li>输出 null</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno</span><br><span class="line"><span class="keyword">from</span> MyS</span><br><span class="line"><span class="keyword">where</span> sno <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line">    <span class="keyword">select</span> sno</span><br><span class="line">    <span class="comment">/* SC 中没有找到 sno 属性列, 此时数据库向外层继续查找</span></span><br><span class="line"><span class="comment">     * 发现 MyS 中含有这个属性, 于是把 sno 解析为 MyS.sno</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">from</span> SC</span><br><span class="line">    <span class="keyword">where</span> cno<span class="operator">=</span><span class="string">&#x27;c01&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实际执行的代码如下 */</span></span><br><span class="line"><span class="keyword">select</span> sno</span><br><span class="line"><span class="keyword">from</span> MyS</span><br><span class="line"><span class="keyword">where</span> sno <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line">    <span class="keyword">select</span> MyS.sno</span><br><span class="line">    <span class="keyword">from</span> SC</span><br><span class="line">    <span class="keyword">where</span> cno<span class="operator">=</span><span class="string">&#x27;c01&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="not-inexists-与空值">not in/exists 与空值</h3>
<p><img src="/2021/04/24/DB/CLJ/04-3/image-20210427152445309.png" style="zoom:50%;"></p>
<ul>
<li>如下查询返回<strong>空集</strong>（<strong>非真即假</strong>）
<ul>
<li>in 做的是一个相等的判断</li>
<li>t1 中的某个 a 元素和 null 做相等的判断，返回 null</li>
<li>null 做 not 的判断，返回 null</li>
<li>where 只会返回结果为 true 的值</li>
<li>因此最后返回空集</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> t1</span><br><span class="line"><span class="keyword">where</span> a <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2)</span><br></pre></td></tr></table></figure>
<ul>
<li>如下查询返回 <strong>1,2</strong>（<strong>非假即真</strong>）
<ul>
<li><code>select * from t2 where a=b</code> 返回空</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> t1</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> a<span class="operator">=</span>b)</span><br></pre></td></tr></table></figure>
<ul>
<li>用于实际数据库测试</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 建表 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T_1(A <span class="type">int</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T_2(B <span class="type">int</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T_3(C <span class="type">int</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T_1 <span class="keyword">values</span>(<span class="number">1</span>), (<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T_2 <span class="keyword">values</span>(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询 */</span></span><br><span class="line"><span class="comment">/* 空 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T_1 <span class="keyword">where</span> A <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1,2 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T_1 <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T_2 <span class="keyword">where</span> T_1.A<span class="operator">=</span>T_2.B);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T_1 <span class="keyword">where</span> A <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T_3);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T_1 <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T_3 <span class="keyword">where</span> T_1.A<span class="operator">=</span>T_3.C);</span><br></pre></td></tr></table></figure>
<h3 id="除法实现">除法实现</h3>
<ul>
<li><span class="math inline">\(\forall \Leftrightarrow\)</span> not
exists ... not exists
<ul>
<li><strong>双重否定的形式</strong></li>
</ul></li>
<li>列出选修了全部课程的学生姓名
<ul>
<li>学生 s1 选修了所有课程</li>
<li>不存在任何一门课程 c1 所求学生 s1 没有选 c1</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sname</span><br><span class="line"><span class="keyword">from</span> S S1</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> cno</span><br><span class="line">    <span class="keyword">from</span> C C1</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">from</span> SC</span><br><span class="line">        <span class="keyword">where</span> cno<span class="operator">=</span>C1.cno</span><br><span class="line">        <span class="keyword">and</span> sno<span class="operator">=</span>S1.sno</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>列出至少选修了 s1 号学生选修的所有课程的学生名
<ul>
<li>s2 选修了 s1 选修的所有课程</li>
<li>不存在任何一门课程，s1 选修了但是 s2 没有选修</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sname</span><br><span class="line"><span class="keyword">from</span> S S2</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> cno</span><br><span class="line">    <span class="keyword">from</span> C C1</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">exists</span> (</span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">from</span> SC</span><br><span class="line">        <span class="keyword">where</span> cno<span class="operator">=</span>C1.cno <span class="keyword">and</span> sno<span class="operator">=</span>s1</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">from</span> SC</span><br><span class="line">        <span class="keyword">where</span> cno<span class="operator">=</span> C1.cno <span class="keyword">and</span> sno<span class="operator">=</span>S2.sno</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.04.SQL 数据查询(1)</title>
    <url>/2021/04/20/DB/CLJ/04-2/</url>
    <content><![CDATA[<h1 id="sql-数据查询">SQL 数据查询</h1>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> ...</span><br><span class="line"><span class="keyword">From</span> ...</span><br><span class="line"><span class="keyword">Where</span> ...</span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">by</span> ...</span><br><span class="line"><span class="keyword">Having</span> ...</span><br><span class="line"><span class="keyword">Union</span> ...</span><br><span class="line"><span class="keyword">Order</span> <span class="keyword">by</span> ...</span><br><span class="line">Limit ...</span><br></pre></td></tr></table></figure>
<h2 id="在线资源">在线资源</h2>
<ul>
<li>http://sqlfiddle.com</li>
</ul>
<h2 id="查询基本结构">查询基本结构</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> A1, A2, ..., An</span><br><span class="line"><span class="keyword">from</span> r1, r2, ..., rm</span><br><span class="line"><span class="keyword">where</span> P</span><br></pre></td></tr></table></figure>
<ul>
<li>上面 3 行对应着投影、<strong>笛卡尔积</strong>、选择</li>
</ul>
<p><span class="math display">\[
\prod_{A_1,A_2,\times ,A_n}(\sigma_{P}(r_1,\times r_2\times \cdots\times
r_m))
\]</span></p>
<ul>
<li>SQL 返回结果是<span style="color:red;font-weight:bold">多集</span></li>
<li>快速生成测试数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> R1 <span class="keyword">values</span>(</span><br><span class="line">    (<span class="number">0</span>), (<span class="number">1</span>), (<span class="number">2</span>), (<span class="number">3</span>), (<span class="number">4</span>), (<span class="number">5</span>), (<span class="number">6</span>), (<span class="number">7</span>), (<span class="number">8</span>), (<span class="number">9</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成 10000 行数据 */</span></span><br><span class="line"><span class="keyword">select</span> R1.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> R R1, R R2, R R3, R R4, R R5</span><br></pre></td></tr></table></figure>
<ul>
<li>但是真正要用于生成数据的话应该使用数据库提供的工具，指定概率分布生成随机数据</li>
<li>理解笛卡尔积
<ul>
<li>如下 sql 语句选择出来的结果是所有学生</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 所有的学生 */</span></span><br><span class="line"><span class="keyword">select</span> sname, dname</span><br><span class="line"><span class="keyword">from</span> S, DEPT</span><br><span class="line"><span class="keyword">where</span> dname <span class="operator">=</span> <span class="string">&#x27;计算机系&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算机系的学生 */</span></span><br><span class="line"><span class="keyword">select</span> sname, dname</span><br><span class="line"><span class="keyword">from</span> S, DEPT</span><br><span class="line"><span class="keyword">where</span> dname <span class="operator">=</span> <span class="string">&#x27;计算机系&#x27;</span> <span class="keyword">and</span> S.dno <span class="operator">=</span> DEPT.dno</span><br></pre></td></tr></table></figure>
<h3 id="select子句">select子句</h3>
<ul>
<li>select xx</li>
<li>xx 可以为
<ul>
<li>列名</li>
<li><code>*</code>：表示所有的属性</li>
<li>算术表达式</li>
<li>聚集函数</li>
</ul></li>
<li>给出学生的所有信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> S</span><br></pre></td></tr></table></figure>
<ul>
<li><code>*</code> 对性能的影响
<ul>
<li>丧失使用组合索引技术的可能</li>
<li>中间表的规模很大</li>
</ul></li>
<li>算术表达式
<ul>
<li>给出所有学生的姓名及出生日期</li>
<li>存储年龄并不是一个好的设计，好的设计应该是存储出生日期
<ul>
<li>把年龄作为出身日期的派生属性</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sname, <span class="number">2020</span><span class="operator">-</span>age</span><br><span class="line"><span class="keyword">from</span> S</span><br></pre></td></tr></table></figure>
<ul>
<li>将多个列组合成一个目标列
<ul>
<li>可以用作 web 前端（智能客服）</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pname <span class="operator">+</span> <span class="string">&#x27;老师的工资是&#x27;</span> <span class="operator">+</span> salary <span class="operator">+</span> <span class="string">&#x27;,年龄是&#x27;</span> <span class="operator">+</span> age <span class="operator">+</span> <span class="string">&#x27;,职称是&#x27;</span> <span class="operator">+</span> title</span><br><span class="line"><span class="keyword">from</span> professor</span><br></pre></td></tr></table></figure>
<h3 id="from子句">from子句</h3>
<ul>
<li>from 子句列出查询的对象表
<ul>
<li>对象表</li>
<li>做<strong>笛卡尔积</strong></li>
</ul></li>
<li>当目标列取自多个表时，需要<strong>显式</strong>指明来自哪个关系</li>
<li>写出与 <span class="math inline">\(R(A,B)\bowtie S(B,C)\)</span>
等价的 SQL</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 错误, 无法分辨 B 来自于哪一个表 */</span></span><br><span class="line"><span class="keyword">select</span> A, B, C</span><br><span class="line"><span class="keyword">from</span> R, S</span><br><span class="line"><span class="keyword">where</span> R.B <span class="operator">=</span> S.B</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不正确, 输出结果为 R.A, R.B, S.A, S.B */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> R, S</span><br><span class="line"><span class="keyword">where</span> R.B <span class="operator">=</span> S.B</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 正确 */</span></span><br><span class="line"><span class="keyword">select</span> A, R.B, C</span><br><span class="line"><span class="keyword">from</span> R, S</span><br><span class="line"><span class="keyword">where</span> R.B <span class="operator">=</span> S.B</span><br></pre></td></tr></table></figure>
<h3 id="where子句">where子句</h3>
<ul>
<li>比较运算符</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;、&lt;=、&gt;、&gt;=、=、&lt;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>逻辑运算符</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">and、or、not</span><br></pre></td></tr></table></figure>
<ul>
<li>虽然不同的表达式可以表示相同的结果，但是使用不同的表达方式效率上可能不一样
<ul>
<li>某些写法，系统可能会使用索引，但是针对其他写法，系统可能不使用索引</li>
</ul></li>
</ul>
<h4 id="between-子句">between 子句</h4>
<ul>
<li>判断表达式的值是否在某范围内</li>
<li>列出工资在500~800之间的老师姓名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pname</span><br><span class="line"><span class="keyword">from</span> PROF</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">between</span> <span class="number">500</span> <span class="keyword">and</span> <span class="number">800</span></span><br></pre></td></tr></table></figure>
<ul>
<li>between 前后两个词的大小关系
<ul>
<li>SQL Server：都可以</li>
<li>其他：一般得满足前面小于后面</li>
<li>得看数据库的具体实现</li>
</ul></li>
<li><strong>优化小窍门</strong>：使用 between 合并两个比较谓词
<ul>
<li>使用 between 来写，可能让系统有使用索引的机会</li>
</ul></li>
</ul>
<h3 id="重复行的处理">重复行的处理</h3>
<ul>
<li>SQL 缺省为保留重复行（多集），也可用关键字 all 显式指明
<ul>
<li>若要去掉重复行，可用关键字 distinct 指明</li>
</ul></li>
<li>找出所有选修课程的学生</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> sno</span><br><span class="line"><span class="keyword">from</span> SC</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>优化小窍门</strong>：只在<strong>必要</strong>的时候去重
<ul>
<li>开销比较大
<ul>
<li>怎么去重：排序，哈希</li>
</ul></li>
<li>必要：业务要求</li>
<li>如果能够明确知道不会有重复的结果，则不需要加 distinct</li>
</ul></li>
</ul>
<h4 id="优化问题">优化问题</h4>
<ul>
<li>两个表
R(A,B)、S(A,C)，其中A是这两个表的主码,哪些查询中的distinct可以去掉？</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 可以去掉 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> R.A, S.A</span><br><span class="line"><span class="keyword">from</span> R,S</span><br><span class="line"><span class="keyword">where</span> R.B <span class="operator">=</span> S.C</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不能去掉 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> R.A</span><br><span class="line"><span class="keyword">from</span> R,S</span><br><span class="line"><span class="keyword">where</span> R.B <span class="operator">=</span> S.C</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可以去掉 */</span></span><br><span class="line"><span class="comment">/* 一行 R 最多和一行 S 对应, 否则不满足 A 为 S 的主码 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> R.A</span><br><span class="line"><span class="keyword">from</span> R,S</span><br><span class="line"><span class="keyword">where</span> R.B <span class="operator">=</span> S.A</span><br></pre></td></tr></table></figure>
<h3 id="输出显示顺序">输出显示顺序</h3>
<ul>
<li>order by</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 列名 [<span class="keyword">asc</span> <span class="operator">|</span> <span class="keyword">desc</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>按年龄升序列出学生信息，相同年龄学生按姓名降序排列</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>, sname <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>order by 后面出现<strong>数字</strong>，表示 select
后的第几个属性</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对教工按缴纳所得税的多少排序 */</span></span><br><span class="line"><span class="keyword">select</span> pname, salary<span class="operator">*</span><span class="number">0.2</span></span><br><span class="line"><span class="keyword">from</span> PROF</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>允许排序的属性不是目标列</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 按年龄顺序输出学生姓名 */</span></span><br><span class="line"><span class="keyword">select</span> sname</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> age</span><br></pre></td></tr></table></figure>
<h3 id="table">table</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 (r1 <span class="type">int</span>, r2 <span class="type">int</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> aa(a,b)</span><br><span class="line"><span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="number">1</span>, <span class="number">1</span> <span class="comment">/* 先插入 1,1 */</span></span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> a<span class="operator">+</span><span class="number">1</span>, cee(rand()<span class="operator">*</span><span class="number">20</span>)</span><br><span class="line">    <span class="keyword">from</span> aa</span><br><span class="line">    <span class="keyword">where</span> a <span class="operator">&lt;</span> <span class="number">10</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> aa</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t2 <span class="comment">/* 表形式统一 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">table</span> t1 <span class="comment">/* 插入数据 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> (r1,r2) <span class="keyword">in</span> (<span class="keyword">table</span> t1) <span class="comment">/* t2 中在 t1 内的行 */</span></span><br></pre></td></tr></table></figure>
<h3 id="valuesrow">values/row</h3>
<ul>
<li>values 表值构造器</li>
<li>row 行值构造器</li>
<li>用于简单的生成行或者表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ex 1 */</span></span><br><span class="line"><span class="keyword">values</span> <span class="type">row</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), <span class="type">row</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ex 2 */</span></span><br><span class="line"><span class="keyword">values</span> <span class="type">row</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), <span class="type">row</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">values</span> <span class="type">row</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>), <span class="type">row</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<h2 id="更名运算">更名运算</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">old_name <span class="keyword">as</span> new_name</span><br></pre></td></tr></table></figure>
<ul>
<li>为<strong>关系</strong>和<strong>属性</strong>重新命名</li>
<li>可出现在 select 和 from 子句中</li>
<li><strong>as 可选</strong></li>
</ul>
<h3 id="属性更名列">属性更名（列）</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 输出的时候吧英文转化为中文 */</span></span><br><span class="line"><span class="keyword">select</span> sname <span class="string">&#x27;姓名&#x27;</span> ,sex <span class="string">&#x27;性别&#x27;</span>, <span class="number">2019</span><span class="operator">-</span>age <span class="string">&#x27;出生日期&#x27;</span></span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 出生日期 <span class="comment">/* 或者 order by 3 */</span></span><br></pre></td></tr></table></figure>
<h3 id="关系更名表">关系更名（表）</h3>
<ul>
<li>例如：表的自连接</li>
<li>找出比 s1 学生选修 c1 课程成绩高的学生号</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> S2.sno</span><br><span class="line"><span class="keyword">from</span> SC <span class="keyword">as</span> S1, SC <span class="keyword">as</span> S2</span><br><span class="line"><span class="keyword">where</span> S1.sno <span class="operator">=</span> <span class="string">&#x27;s1&#x27;</span></span><br><span class="line"><span class="keyword">and</span> S1.cno <span class="operator">=</span> <span class="string">&#x27;c1&#x27;</span></span><br><span class="line"><span class="keyword">and</span> S2.cno <span class="operator">=</span> <span class="string">&#x27;c1&#x27;</span></span><br><span class="line"><span class="keyword">and</span> S1.grade <span class="operator">&lt;</span> S2.grade</span><br></pre></td></tr></table></figure>
<h2 id="连接操作">连接操作</h2>
<ul>
<li><strong>连接成分</strong>
<ul>
<li>包括<strong>两个输入关系</strong>、<strong>连接条件</strong>、<strong>连接类型</strong></li>
</ul></li>
<li><strong>连接条件</strong>
<ul>
<li>决定两个关系中哪些元组相互匹配，以及连接结果中出现哪些属性</li>
</ul></li>
<li><strong>连接类型</strong>
<ul>
<li>决定如何处理与连接条件<strong>不匹配</strong>的元组</li>
</ul></li>
<li>SQL
<ul>
<li>连接类型
<ul>
<li>inner join</li>
<li>left outer join</li>
<li>right outer join</li>
<li>full outer join</li>
</ul></li>
<li>连接条件
<ul>
<li>on <谓词></谓词></li>
<li>(R cross join S) as T
<ul>
<li>两个关系的笛卡儿积</li>
</ul></li>
</ul></li>
</ul></li>
<li>列出所有老师的教工号、姓名、工资、所教课程号
<ul>
<li>需要保留没有授课的老师</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pno, pname, salary, cno</span><br><span class="line"><span class="keyword">from</span> prof <span class="keyword">left</span> <span class="keyword">join</span> PC <span class="keyword">on</span> PROF.pno<span class="operator">=</span>PC.pno</span><br></pre></td></tr></table></figure>
<ul>
<li>如果不支持外连接，实现方式</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 有教授课程的老师 + 没有教授课程的老师 */</span></span><br><span class="line"><span class="keyword">select</span> pno, pname, salary, cno</span><br><span class="line"><span class="keyword">from</span> PROF, PC</span><br><span class="line"><span class="keyword">where</span> PROF.pno<span class="operator">=</span>PC.pno</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> pno, pname, salary, <span class="keyword">null</span></span><br><span class="line"><span class="keyword">from</span> PROF</span><br><span class="line"><span class="keyword">where</span> pno <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> pno <span class="keyword">from</span> PC)</span><br></pre></td></tr></table></figure>
<ul>
<li>注意 SQL 不删除重复列（因为 on 的条件可能不是等于）</li>
</ul>
<h3 id="inner-join">inner join</h3>
<p><img src="/2021/04/20/DB/CLJ/04-2/image-20210422211110317.png" style="zoom:50%;"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tbA <span class="keyword">inner</span> <span class="keyword">join</span> tbC <span class="keyword">on</span> tbA.b<span class="operator">=</span>tbC.b</span><br></pre></td></tr></table></figure>
<h3 id="left-join">left join</h3>
<p><img src="/2021/04/20/DB/CLJ/04-2/image-20210422211343137.png" style="zoom:50%;"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tbA <span class="keyword">left</span> <span class="keyword">join</span> tbC <span class="keyword">on</span> tbA.b<span class="operator">=</span>tbC.b</span><br></pre></td></tr></table></figure>
<h3 id="right-join">right join</h3>
<p><img src="/2021/04/20/DB/CLJ/04-2/image-20210422211402914.png" style="zoom:50%;"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tbA <span class="keyword">right</span> <span class="keyword">join</span> tbC <span class="keyword">on</span> tbA.b<span class="operator">=</span>tbC.b</span><br></pre></td></tr></table></figure>
<h3 id="left-join-excluding-inner-join">left join excluding inner
join</h3>
<p><img src="/2021/04/20/DB/CLJ/04-2/image-20210422211610961.png" style="zoom:50%;"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> tbA.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tbA <span class="keyword">left</span> tbC <span class="keyword">on</span> tbA.b<span class="operator">=</span>tbC.b</span><br><span class="line"><span class="keyword">where</span> tbC.b <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<h3 id="full-join-excluding-inner-join">full join excluding inner
join</h3>
<p><img src="/2021/04/20/DB/CLJ/04-2/image-20210422211721180.png" style="zoom:50%;"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tbA <span class="keyword">left</span> tbC <span class="keyword">on</span> tbA.b<span class="operator">=</span>tbC.b</span><br><span class="line"><span class="keyword">where</span> tbC.b <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tbA <span class="keyword">right</span> tbC <span class="keyword">on</span> tbA.b<span class="operator">=</span>tbC.b</span><br><span class="line"><span class="keyword">where</span> tbA.b <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<h3 id="cross-join">cross join</h3>
<ul>
<li>做笛卡尔积</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tbA <span class="keyword">cross</span> <span class="keyword">join</span> tbC</span><br><span class="line"><span class="comment">/* 等价于 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tbA, tbC</span><br></pre></td></tr></table></figure>
<h3 id="natural-join">natural join</h3>
<ul>
<li>去除重复（公共）列</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ex 1*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tbA <span class="keyword">natural</span> <span class="keyword">join</span> tbC</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ex2 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tbA <span class="keyword">join</span> tbC <span class="keyword">using</span>(b)</span><br></pre></td></tr></table></figure>
<h3 id="straight_join">straight_join</h3>
<ul>
<li>嵌套循环</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> R straight_join S</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/20/DB/CLJ/04-2/image-20210422212426321.png" style="zoom:80%;"></p>
<h3 id="多表连接">多表连接</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tbA A <span class="keyword">inner</span> <span class="keyword">join</span> tbA B <span class="keyword">on</span> A.b<span class="operator">=</span>B.b</span><br><span class="line">           <span class="keyword">inner</span> <span class="keyword">join</span> tbA C <span class="keyword">on</span> A.b<span class="operator">=</span>C.b</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tbA A</span><br><span class="line"><span class="keyword">join</span>(tbA B, tbA C)</span><br><span class="line"><span class="keyword">on</span>(A.b<span class="operator">=</span>B.b <span class="keyword">and</span> A.b<span class="operator">=</span>C.b)</span><br></pre></td></tr></table></figure>
<h2 id="集合操作">集合操作</h2>
<ul>
<li>默认去重，显式声明 all 才表示不去重</li>
<li>集合并：union(all)</li>
<li>集合交：intersect(all)</li>
<li>集合差：except(all)</li>
<li>优先级
<ul>
<li>intersect 的优先级高于其他集合操作的优先级</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">S1 <span class="keyword">intersect</span> <span class="keyword">all</span> S2</span><br><span class="line">S1 <span class="keyword">intersect</span> S2</span><br></pre></td></tr></table></figure>
<ul>
<li>求工资大于1000或者年龄大于60的教工</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">select</span> pno</span><br><span class="line"><span class="keyword">from</span> PROF</span><br><span class="line"><span class="keyword">where</span> sal<span class="operator">&gt;</span> <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">(<span class="keyword">select</span> pno</span><br><span class="line"><span class="keyword">from</span> PROF</span><br><span class="line"><span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">60</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">select</span> pno</span><br><span class="line"><span class="keyword">from</span> PROF</span><br><span class="line"><span class="keyword">where</span> sal<span class="operator">&gt;</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">or</span> age <span class="operator">&gt;</span> <span class="number">60</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>union all 不去重</li>
<li>效率
<ul>
<li>第一种写法可能会让数据库使用索引</li>
<li>第二种写法，很多数据库看到 or 直接就不使用索引了</li>
</ul></li>
</ul>
<h3 id="用集合运算实现除法">用集合运算实现除法</h3>
<ul>
<li>选修了所有课程的同学</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno</span><br><span class="line"><span class="keyword">from</span> S S1</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">(</span><br><span class="line">    <span class="comment">/* 所有的课程 */</span></span><br><span class="line">    <span class="keyword">select</span> cno</span><br><span class="line">    <span class="keyword">from</span> C</span><br><span class="line">    <span class="keyword">except</span></span><br><span class="line">    <span class="comment">/* S1 同学选修的所有课程 */</span></span><br><span class="line">    <span class="keyword">select</span> cno</span><br><span class="line">    <span class="keyword">from</span> SC</span><br><span class="line">    <span class="keyword">where</span> S1.sno<span class="operator">=</span>SC.sno</span><br><span class="line">)</span><br><span class="line"><span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<h2 id="空值">空值</h2>
<ul>
<li>很麻烦但是是必要的</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">No cat has 12 tails.</span><br><span class="line">A cat has one more tail than no cat.</span><br><span class="line">Therefore, a cat has 13 tails.</span><br></pre></td></tr></table></figure>
<ul>
<li>谬论，no cat 不是一个实体</li>
<li>C.J Date
<ul>
<li>null 是标识，不是值</li>
<li>包含 null 违反了关系定义</li>
</ul></li>
<li>Codd 提出了两类 null
<ul>
<li>A-Mark null：未知的</li>
<li>T-Mark null：不适用的</li>
<li>但是数据库没有办法区分这两类 null</li>
</ul></li>
</ul>
<h3 id="空值的逻辑计算">空值的逻辑计算</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">and</th>
<th style="text-align: center;">true</th>
<th style="text-align: center;">false</th>
<th style="text-align: center;">unknown</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">true</td>
<td style="text-align: center;">true</td>
<td style="text-align: center;">false</td>
<td style="text-align: center;">unknown</td>
</tr>
<tr class="even">
<td style="text-align: center;">false</td>
<td style="text-align: center;">false</td>
<td style="text-align: center;">false</td>
<td style="text-align: center;">false</td>
</tr>
<tr class="odd">
<td style="text-align: center;">unknown</td>
<td style="text-align: center;">unknown</td>
<td style="text-align: center;">false</td>
<td style="text-align: center;">unknown</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">or</th>
<th style="text-align: center;">true</th>
<th style="text-align: center;">false</th>
<th style="text-align: center;">unknown</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">true</td>
<td style="text-align: center;">true</td>
<td style="text-align: center;">true</td>
<td style="text-align: center;">true</td>
</tr>
<tr class="even">
<td style="text-align: center;">false</td>
<td style="text-align: center;">true</td>
<td style="text-align: center;">false</td>
<td style="text-align: center;">unknown</td>
</tr>
<tr class="odd">
<td style="text-align: center;">unknown</td>
<td style="text-align: center;">true</td>
<td style="text-align: center;">unknown</td>
<td style="text-align: center;">unknown</td>
</tr>
</tbody>
</table>
<ul>
<li>强度：true &gt; unknown &gt; false</li>
</ul>
<h3 id="问题">问题</h3>
<p><img src="/2021/04/20/DB/CLJ/04-2/image-20210423150349419.png" style="zoom:50%;"></p>
<ul>
<li>列出满足如下条件的(SNO, PNO)对：
<ul>
<li>或者供应商和零件的所在城市不同，或者零件所在城市不是 Paris</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> S.SNO, P.PNO</span><br><span class="line"><span class="keyword">from</span> S, P</span><br><span class="line"><span class="keyword">where</span> S.CITY <span class="operator">&lt;&gt;</span> P.CITY</span><br><span class="line"><span class="keyword">or</span> P.CITY <span class="operator">&lt;&gt;</span> <span class="string">&#x27;Paris&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>返回结果为 <code>S1, P2</code></strong></li>
<li>不会返回结果 <code>S1,P1</code>
<ul>
<li>(S1.CITY = P1.CITY) 返回 null(unknown)</li>
<li>(P1.CITY = 'Paris') 返回 null(unknown)</li>
<li><strong>而数据库只返回结果为 true 的行</strong></li>
</ul></li>
<li><span style="color:red;font-weight:bold">问题</span>：P1.CITY虽目前未知，但肯定是或不是Paris，总会满足查询条件之一
<ul>
<li>应该输出 <code>S1,P1</code></li>
</ul></li>
</ul>
<h3 id="空值测试">空值测试</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">is</span> [<span class="keyword">not</span>] <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<h3 id="空值的查询">空值的查询</h3>
<ul>
<li>除 is [not] null 之外，空值不满足任何查找条件</li>
<li>如果 null 参与算术运算，则该算术表达式的值为 null</li>
<li>如果 null 参与比较运算，则结果可视为 unknown</li>
</ul>
<h3 id="例子">例子</h3>
<ul>
<li>表中存在两行(1, 2, null), (1, 2, null)
<ul>
<li>请问 select distinct * 的输出结果是？</li>
<li><span style="color:red;font-weight:bold">输出一行</span></li>
<li>可能底层的判断并不是简单的 =</li>
</ul></li>
<li>找出成绩值为空的学生号</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> grade <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="comment">/* 不可写为 where grade = null */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>空串、null、'null'</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> NULL_TB(col <span class="type">char</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> NULL_TB <span class="keyword">values</span>(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> NULL_TB <span class="keyword">values</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> NULL_TB <span class="keyword">values</span>(<span class="string">&#x27;null&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下 3 个查询都只会返回一个记录 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> NULL_TB <span class="keyword">where</span> col<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> NULL_TB <span class="keyword">where</span> col<span class="operator">=</span><span class="string">&#x27;null&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> NULL_TB <span class="keyword">where</span> col <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<h3 id="空值处理函数">空值处理函数</h3>
<h4 id="isnull">isnull</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">isnull(check_expression, replacement_value)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 check_expression 值为空，则返回
replacement_value，否则返回check_expression</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno, cno, isnull( grade, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">from</span> SC</span><br></pre></td></tr></table></figure>
<h4 id="coalesce">coalesce</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">coalesce</span>(expression1, expression2, ...)</span><br></pre></td></tr></table></figure>
<ul>
<li>返回第一个不为 null 的expression</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno,cno,<span class="built_in">coalesce</span>(grade, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> <span class="built_in">coalesce</span>(grade,<span class="number">0</span>) <span class="operator">&lt;</span> <span class="number">60</span></span><br></pre></td></tr></table></figure>
<h4 id="nullif">nullif</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nullif</span>(expression1, expression2)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果两个表达式相等则返回空值，否则返回第一个表达式</li>
</ul>
<h3 id="空值的排序处理">空值的排序处理</h3>
<ul>
<li>缺省情况下空值是最后输出的</li>
<li>当指定 order by
时，<strong>降序</strong>情况下<strong>首先</strong>输出空值，升序情况下最后输出空值
<ul>
<li>把空值看成是最大的</li>
</ul></li>
<li>首先输出 null，由大到小输出工资</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pname,salary</span><br><span class="line"><span class="keyword">from</span> prof</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="number">2</span> <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>首先输出 null，再由小到大输出工资</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pname,salary</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> pname,salary,</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">when</span> salary <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">as</span> is_null</span><br><span class="line">    <span class="keyword">from</span> prof</span><br><span class="line">) temp_faculty</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> is_null, salary</span><br></pre></td></tr></table></figure>
<h2 id="聚集函数">聚集函数</h2>
<ul>
<li>将一列中所有的值聚集为单个值
<ul>
<li>平均值：avg</li>
<li>最小值：min</li>
<li>最大值：max</li>
<li>总和：sum</li>
<li>记数：count</li>
</ul></li>
</ul>
<h3 id="max">max</h3>
<ul>
<li>错误的写法
<ul>
<li>两种理解方式
<ul>
<li>max(grade) 没有限定语</li>
<li>执行树上，max 应该在最后执行，where
语句不能引用后面计算得到的结果</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> grade <span class="operator">=</span> <span class="built_in">max</span>(grade)</span><br></pre></td></tr></table></figure>
<ul>
<li>正确的写法</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> grade <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">max</span>(grade)</span><br><span class="line">    <span class="keyword">from</span> SC</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="count">count</h3>
<ul>
<li>只有 count(*) 会考虑空值，其他都会将空值排除在外
<ul>
<li>count(*) 是对行数的计数</li>
<li>count(grade) 是对有效值的计数</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC(</span><br><span class="line">    sno   <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">    cno   <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">    grade <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(&quot;s1&quot;, &quot;c1&quot;, <span class="number">90</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(&quot;s1&quot;, &quot;c1&quot;, <span class="number">90</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(&quot;s1&quot;, &quot;c2&quot;, <span class="number">90</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(&quot;s1&quot;, &quot;c3&quot;, <span class="number">90</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(&quot;s2&quot;, &quot;c1&quot;, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 输出 4 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(grade)</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出 5 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> SC</span><br></pre></td></tr></table></figure>
<h3 id="统计型聚集函数">统计型聚集函数</h3>
<ul>
<li>std</li>
<li>stddev</li>
<li>stddev_pop</li>
<li>stddev_samp</li>
<li>variance</li>
<li>var_pop</li>
<li>var_samp</li>
</ul>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.04.SQL 数据查询(3)</title>
    <url>/2021/04/27/DB/CLJ/04-4/</url>
    <content><![CDATA[<h1 id="sql-数据查询">SQL 数据查询</h1>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> ...</span><br><span class="line"><span class="keyword">From</span> ...</span><br><span class="line"><span class="keyword">Where</span> ...</span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">by</span> ...</span><br><span class="line"><span class="keyword">Having</span> ...</span><br><span class="line"><span class="keyword">Union</span> ...</span><br><span class="line"><span class="keyword">Order</span> <span class="keyword">by</span> ...</span><br><span class="line">Limit ...</span><br></pre></td></tr></table></figure>
<h2 id="在线资源">在线资源</h2>
<ul>
<li>http://sqlfiddle.com</li>
</ul>
<h2 id="字符串操作">字符串操作</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">列名 [<span class="keyword">not</span>] <span class="keyword">like</span> <span class="string">&#x27;字符串&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="匹配规则">匹配规则</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">%       匹配零个或多个字符</span><br><span class="line">_       匹配任意单个字符</span><br><span class="line">[]      任何在指定范围内的字符, [a-f], [abcdef]</span><br><span class="line">[^]     任何不在指定范围内的字符, [^a-f], [^abcdef]</span><br></pre></td></tr></table></figure>
<h3 id="转义字符">转义字符</h3>
<ul>
<li><strong>用 escape
定义转义字符</strong>，以去掉特殊字符的特定含义，使其被作为普通字符看待
<ul>
<li>如 escape <code>\</code>，定义 <code>\</code> 作为转义字符</li>
<li>则可用 <code>\%</code> 去匹配 <code>%</code>，用
<code>\_</code>去匹配 <code>_</code></li>
<li>用什么去匹配 <code>\</code>：<code>\\</code></li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> my_tb</span><br><span class="line"><span class="keyword">where</span> col1 <span class="keyword">like</span> <span class="string">&#x27;x%%x__xx&#x27;</span> <span class="keyword">escape</span> <span class="string">&#x27;x&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x%x_x    (x)</span></span><br><span class="line"><span class="comment">%xx_x    (x)</span></span><br><span class="line"><span class="comment">%xx_xx   (v)</span></span><br><span class="line"><span class="comment">%__x     (v)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="例子">例子</h3>
<ul>
<li>列出姓名以“张”打头的教师的所有信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> PROF</span><br><span class="line"><span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>列出名称中含有3个以上字符，且倒数第三个是d，倒数第二个是
<code>_</code> 的课程</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> C</span><br><span class="line"><span class="keyword">where</span> cname <span class="keyword">like</span> <span class="string">&#x27;%_d\__&#x27;</span> <span class="keyword">escape</span> <span class="string">&#x27;\&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="索引">索引</h3>
<ul>
<li>在 cname 上建有索引
cname_idx，观察下面查询的执行计划，看谁用到了该索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 放弃使用索引 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> C <span class="keyword">where</span> cname <span class="keyword">like</span> <span class="string">&#x27;%d&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用索引 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> C <span class="keyword">where</span> cname <span class="keyword">like</span> <span class="string">&#x27;d%&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>like 作用有限，如何增强数据库的文本处理能力
<ul>
<li><strong>全文检索</strong> + <strong>正则表达式</strong></li>
</ul></li>
</ul>
<h2 id="正则表达式">正则表达式</h2>
<ul>
<li>Regular Expression</li>
<li>一些例子</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">用户名</span><br><span class="line">/^[a-z0-9_-]&#123;3,16&#125;$/</span><br><span class="line"></span><br><span class="line">密码</span><br><span class="line">/^[a-z0-9_-]&#123;6,18&#125;$/</span><br><span class="line"></span><br><span class="line">电子邮箱</span><br><span class="line">/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)$/</span><br><span class="line"></span><br><span class="line">IP地址</span><br><span class="line">/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/</span><br><span class="line"></span><br><span class="line">HTML标签</span><br><span class="line">/^&lt;([a-z]+)([^&lt;]+)*(?:&gt;(.*)&lt;\/\1&gt;|\s+\/&gt;)$/</span><br></pre></td></tr></table></figure>
<ul>
<li>如果数据库本身不支持正则表达式，那么一切都会变得很麻烦
<ul>
<li><strong>现在的数据库都是直接支持的</strong></li>
</ul></li>
<li>用 check 约束表达正则表达式</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> IP_Address(ip <span class="type">char</span>(<span class="number">15</span>) <span class="keyword">primary</span> key)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> IP_Address <span class="keyword">add</span> <span class="keyword">constraint</span> CHK_IP_Valid <span class="keyword">check</span>(</span><br><span class="line">    ip <span class="keyword">like</span> <span class="string">&#x27;_%._%._%._%&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> ip <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;%.%.%.%.%&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> ip <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;%[^0-9.]%&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> ip <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;%[0-9][0-9][0-9][0-9]%&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> ip <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;%[3-9][0-9][0-9]%&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> ip <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;%2[6-9][0-9]%&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> ip <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;%25[6-9]%&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>数据库中的正则表达式
<ul>
<li>按照 PPT 中，好像是含有正则表示式项即可</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> my_name</span><br><span class="line"><span class="keyword">where</span> name regexp <span class="string">&#x27;^吴&#x27;</span> <span class="comment">/* 名字以 &#x27;吴&#x27; 开头 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> my_name</span><br><span class="line"><span class="keyword">where</span> name regexp <span class="string">&#x27;吴&#x27;</span> <span class="comment">/* 名字中含有 &#x27;吴&#x27; */</span></span><br></pre></td></tr></table></figure>
<h3 id="oracle">Oracle</h3>
<ul>
<li>在表定义的时候，可以在添加 constraint 的时候使用正则表达式
<ul>
<li>MySQL 和 SQL Server 好像都没有</li>
</ul></li>
</ul>
<table>
<colgroup>
<col style="width: 19%">
<col style="width: 80%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数名</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">REGEXP_LIKE</td>
<td style="text-align: center;">类似于LIKE
运算符，但执行正则表达式匹配而不是简单的模式匹配</td>
</tr>
<tr class="even">
<td style="text-align: center;">REGEXP_INSTR</td>
<td style="text-align: center;">在给定字符串中搜索某个正则表达式模式，并返回匹配项的位置</td>
</tr>
<tr class="odd">
<td style="text-align: center;">REGEXP_REPLACE</td>
<td style="text-align: center;">搜索某个正则表达式模式并使用替换字符串替换它</td>
</tr>
<tr class="even">
<td style="text-align: center;">REGEXP_SUBSTR</td>
<td style="text-align: center;">在给定字符串中搜索某个正则表达式模式并返回匹配的子字符串</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Alter</span> <span class="keyword">table</span> students</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> stud_ssn_ck</span><br><span class="line"><span class="keyword">check</span> (</span><br><span class="line">    REGEXP_LIKE(</span><br><span class="line">        ssn,</span><br><span class="line">        <span class="string">&#x27;^([[:digit:]]&#123;3&#125;-[[:digit:]]&#123;2&#125;-[[:digit:]]&#123;4&#125;|[[:digit:]]&#123;9&#125;)$&#x27;</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="标准-sql">标准 SQL</h3>
<ul>
<li>similar to</li>
</ul>
<h2 id="全文检索">全文检索</h2>
<ul>
<li>大量文档不适用于用 like 查询</li>
</ul>
<h3 id="倒排索引">倒排索引</h3>
<p><img src="/2021/04/27/DB/CLJ/04-4/image-20210427164844348.png" style="zoom:60%;"></p>
<h3 id="sql-server-中的全文索引">SQL Server 中的全文索引</h3>
<h4 id="创建全文索引">创建全文索引</h4>
<ul>
<li>key index 指定 table_name 上唯一码索引的名称, 最好是聚簇索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> fulltext catalog catalog_name</span><br><span class="line"><span class="keyword">create</span> fulltext index <span class="keyword">on</span></span><br><span class="line">    table_name[(column_name]</span><br><span class="line">key index index_name</span><br><span class="line"><span class="keyword">on</span> catalog_name</span><br></pre></td></tr></table></figure>
<h4 id="全文索引的使用">全文索引的使用</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Contains</span>(属性列<span class="operator">|</span><span class="operator">*</span>, 查找条件)</span><br><span class="line">freetext(属性列<span class="operator">|</span><span class="operator">*</span>, 查找文本)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 freetext
时，全文查询引擎内部将查找文本拆分为若干个搜索词，并赋予每个词以不同的加权，然后查找匹配</li>
</ul>
<h4 id="示例">示例</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">doc(doc_id,title,author,abstract,content)</span><br><span class="line"><span class="comment">/* 聚簇索引 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> clustered index doc_idxondoc(doc_id)</span><br><span class="line"><span class="comment">/* 建立全文索引 */</span></span><br><span class="line"><span class="keyword">create</span> fulltext catalog doc_fulltext_catalog</span><br><span class="line"><span class="keyword">create</span> fulltext index <span class="keyword">on</span> doc(title,author,abstract,content)</span><br><span class="line">key index doc_idx</span><br><span class="line"><span class="keyword">on</span> doc_fulltext_catalog</span><br><span class="line"><span class="comment">/* 使用 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> doc</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">contains</span>(author,<span class="string">&#x27;Tom and Jerry&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> doc</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">contains</span>(<span class="operator">*</span>, <span class="string">&#x27;database and not dataspace&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> doc</span><br><span class="line"><span class="keyword">where</span> freetext(content, <span class="string">&#x27;DeepLearning&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="mysql全文索引">MySQL全文索引</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> fulltextindex ft_indx_nameontb_name(col_name,...)</span><br><span class="line"><span class="keyword">match</span> (col_name,...) against(search_expr[search_modifier])</span><br></pre></td></tr></table></figure>
<ul>
<li>search_modifier:
<ul>
<li>in natural language mode</li>
<li>in natural language mode with query expansion</li>
<li>in booleanmode</li>
<li>with query expansion</li>
</ul></li>
<li>例子</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> myDoc(</span><br><span class="line">    id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    title <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    content text,</span><br><span class="line">    fulltext(title,content)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> myDoc(title,content) <span class="keyword">values</span></span><br><span class="line">    (<span class="string">&#x27;MySQL Tutorial&#x27;</span>,<span class="string">&#x27;DBMSstands for DataBase...&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;How To Use MySQL Well&#x27;</span>,<span class="string">&#x27;Afteryou went through a ...&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Optimizing MySQL&#x27;</span>,<span class="string">&#x27;Inthis tutorial we will show ...&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;1001 MySQL Tricks&#x27;</span>,<span class="string">&#x27;1. Never run mysqldas root. 2. ...&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;MySQL vs. YourSQL&#x27;</span>,<span class="string">&#x27;In the following database comparison ...&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;MySQL Security&#x27;</span>,<span class="string">&#x27;Whenconfigured properly, MySQL ...&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> myDoc</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">match</span>(title,content)</span><br><span class="line">against(<span class="string">&#x27;database&#x27;</span> <span class="keyword">in</span> <span class="keyword">natural</span> <span class="keyword">language</span> mode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> id,<span class="keyword">match</span>(title,content)</span><br><span class="line">against(<span class="string">&#x27;database&#x27;</span>) <span class="keyword">as</span> score <span class="comment">/* 匹配分 */</span></span><br><span class="line"><span class="keyword">from</span> myDoc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span>(title,content) against(<span class="string">&#x27;+MySQL -YourSQL&#x27;</span><span class="keyword">in</span> <span class="type">boolean</span> mode)</span><br><span class="line"><span class="keyword">match</span>(title,content) against(<span class="string">&#x27;+MySQL +YourSQL&#x27;</span><span class="keyword">in</span> <span class="type">boolean</span> mode) <span class="comment">/* 且 */</span></span><br><span class="line"><span class="keyword">match</span>(title,content) against(<span class="string">&#x27;+MySQL YourSQL&#x27;</span><span class="keyword">in</span> <span class="type">boolean</span> mode)  <span class="comment">/* 或 */</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串函数">字符串函数</h2>
<p><img src="/2021/04/27/DB/CLJ/04-4/image-20210427170647485.png"></p>
<p><img src="/2021/04/27/DB/CLJ/04-4/image-20210427170713249.png"></p>
<p><img src="/2021/04/27/DB/CLJ/04-4/image-20210427170725681.png"></p>
<p><img src="/2021/04/27/DB/CLJ/04-4/image-20210427170740562.png"></p>
<h3 id="例子-1">例子</h3>
<ul>
<li>计算字符 a 出现次数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> len(<span class="string">&#x27;databases&#x27;</span>) − len(replace(<span class="string">&#x27;databases&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;&#x27;</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>如果是检索多个字符出现次数的话，还要除以相应的字符个数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> len(<span class="string">&#x27;databases&#x27;</span>) − len(replace(<span class="string">&#x27;databases&#x27;</span>,<span class="string">&#x27;ta&#x27;</span>,<span class="string">&#x27;&#x27;</span>))<span class="operator">/</span>len(<span class="string">&#x27;ta&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.04. 数据更新</title>
    <url>/2021/04/27/DB/CLJ/04-5/</url>
    <content><![CDATA[<h1 id="数据更新">数据更新</h1>
<ul>
<li>Insert</li>
<li>Delete</li>
<li>Truncate</li>
<li>Update</li>
<li>Output</li>
<li>Merge</li>
</ul>
<h2 id="全局变量">全局变量</h2>
<h3 id="row_count">row_count()</h3>
<ul>
<li>返回<strong>受上一语句影响的行数</strong></li>
<li>任何不返回行的语句将这一变量设置为 0</li>
<li>例子：删除了多少行</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">select</span> row_count()</span><br></pre></td></tr></table></figure>
<h2 id="insert">Insert</h2>
<ul>
<li>形式</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插入一条指定好值的行 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名[(列名[, 列名]...)] <span class="keyword">values</span> (值[,值],...,)</span><br><span class="line"><span class="comment">/* 插入子查询结果中的若干行 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名[(列名[, 列名]...](子查询)</span><br></pre></td></tr></table></figure>
<h3 id="插入显式行">插入显式行</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> PROF <span class="keyword">values</span></span><br><span class="line">    (P123,<span class="string">&#x27;王明&#x27;</span>,<span class="number">35</span>,D08,<span class="number">498</span>),</span><br><span class="line">    (P124,<span class="string">&#x27;李明&#x27;</span>,<span class="number">38</span>,D01,<span class="number">698</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> PROF(pno, pname, dno) <span class="keyword">values</span></span><br><span class="line">    <span class="type">row</span>(P123, <span class="string">&#x27;王明&#x27;</span>, D08),</span><br><span class="line">    <span class="type">row</span>(P125, <span class="string">&#x27;李明&#x27;</span>, D08)</span><br></pre></td></tr></table></figure>
<h3 id="插入子查询">插入子查询</h3>
<ul>
<li>将平均成绩大于 90 的学生加入到 EXCELLENT 中</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> EXCELLENT (sno, grade)</span><br><span class="line"><span class="keyword">select</span> sno,<span class="built_in">avg</span>(grade)</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>(sno)</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(grade) <span class="operator">&gt;</span> <span class="number">90</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sno, <span class="built_in">avg</span>(grade)</span><br><span class="line"><span class="keyword">into</span> EXCELLENT (sno, grade)</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>(sno)</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(grade) <span class="operator">&gt;</span> <span class="number">90</span></span><br></pre></td></tr></table></figure>
<h3 id="replace-into">replace into</h3>
<ul>
<li>替换原有的数据行</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_replace(</span><br><span class="line">    id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">    cur_time datetime</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_replace (name,cur_time)</span><br><span class="line"><span class="keyword">values</span>(<span class="string">&#x27;A&#x27;</span>,now()),(<span class="string">&#x27;B&#x27;</span>,now())</span><br><span class="line"></span><br><span class="line">replace test_replace <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;AA&#x27;</span>,now())</span><br></pre></td></tr></table></figure>
<h2 id="delete">Delete</h2>
<ul>
<li>从表中删除符合条件的元组</li>
<li><strong>如果没有 where 语句，则删除所有元组</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件表达式]</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 清除所有选课记录 */</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> SC</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除王明老师所有的任课记录 */</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> PC</span><br><span class="line"><span class="keyword">where</span> pno <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> pno</span><br><span class="line">    <span class="keyword">from</span> PROF</span><br><span class="line">    <span class="keyword">where</span> pname<span class="operator">=</span><span class="string">&#x27;王明&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>删除的时候，用 in 而不是 =
<ul>
<li>可能有两个人都叫王明，使用 = 会报错</li>
<li>运行时错误</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> delA(a <span class="type">int</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> delB(b <span class="type">int</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> delA <span class="keyword">values</span>(<span class="number">1</span>),(<span class="number">3</span>),(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> delB <span class="keyword">values</span>(<span class="number">3</span>),(<span class="number">4</span>),(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* =/in */</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> delA <span class="keyword">where</span> a<span class="operator">=</span>(<span class="keyword">select</span> b <span class="keyword">from</span> delB <span class="keyword">where</span> b<span class="operator">&lt;</span><span class="number">4</span>);</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> delA <span class="keyword">where</span> a<span class="operator">=</span>(<span class="keyword">select</span> b <span class="keyword">from</span> delB <span class="keyword">where</span> b<span class="operator">&gt;</span><span class="number">3</span>);</span><br><span class="line"><span class="comment">/* ERROR 1242(21000):Subquery returns more than 1 row */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用 <code>limit 1</code> 限制只输出一行</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> delB</span><br><span class="line"><span class="keyword">where</span> b<span class="operator">&lt;</span><span class="number">5</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="多表删除操作">多表删除操作</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> t1,t2 <span class="keyword">from</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t2 <span class="keyword">inner</span> <span class="keyword">join</span> t3</span><br><span class="line"><span class="keyword">where</span> t1.id<span class="operator">=</span>t2.id <span class="keyword">and</span> t2.id<span class="operator">=</span>t3.id</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t1,t2 <span class="keyword">using</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t2 <span class="keyword">inner</span> <span class="keyword">join</span> t3</span><br><span class="line"><span class="keyword">where</span> t1.id<span class="operator">=</span>t2.id <span class="keyword">and</span> t2.id<span class="operator">=</span>t3.id</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> PC <span class="keyword">from</span> PROF <span class="keyword">inner</span> <span class="keyword">join</span> PC</span><br><span class="line"><span class="keyword">where</span> pname<span class="operator">=</span><span class="string">&#x27;王明&#x27;</span> <span class="keyword">and</span> PROF.pno<span class="operator">=</span>PC.pno</span><br></pre></td></tr></table></figure>
<h3 id="删除操作">删除操作</h3>
<h3 id="例子">例子</h3>
<ul>
<li>删除低于平均工资的老师记录</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这样的语句是错误的 */</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> PROF</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">avg</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> PROF</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>思考：是先找到所有符合条件的行，一并删除，还是找到一个删除一个
<ul>
<li>应该是先找到，然后会一并删除</li>
<li>删除的时候会加锁，一并删除可以保持对外的一致性</li>
</ul></li>
<li><strong>MySQL 不允许从子查询中出现的表中删除数据</strong></li>
<li>解决方法，先找出平均工资，然后再删除</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 生成临时视图 */</span></span><br><span class="line"><span class="keyword">with</span> tmp <span class="keyword">as</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">avg</span>(val) <span class="keyword">as</span> A</span><br><span class="line">    <span class="keyword">from</span> test_del</span><br><span class="line">)</span><br><span class="line"><span class="keyword">delete</span> test_del <span class="keyword">from</span> test_del <span class="keyword">inner</span> <span class="keyword">join</span> tmp <span class="keyword">where</span> val <span class="operator">&gt;</span> A;</span><br></pre></td></tr></table></figure>
<h2 id="truncate">Truncate</h2>
<ul>
<li>清空表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除表中的所有行，而不记录单个行删除操作
<ul>
<li>相对于用 delete 语句删除整个表而言，更加高效</li>
<li>数据库一般都有<strong>日志记录</strong>，用于恢复数据库
<ul>
<li>delete 删除一个表会产生行级的记录</li>
<li>truncate 删除整个表只会产生页级的记录</li>
</ul></li>
</ul></li>
<li>truncate table 在功能上与不带 where 子句的 delete 语句相同
<ul>
<li>但 truncate table 比 delete
速度快，且使用的系统和事务日志资源少</li>
<li>auto_increment 计数器重置为种子值</li>
</ul></li>
</ul>
<h2 id="update">Update</h2>
<ul>
<li>更新操作的命令格式</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名</span><br><span class="line"><span class="keyword">set</span> 列名 <span class="operator">=</span> 表达式<span class="operator">|</span>子查询</span><br><span class="line">    列名 <span class="operator">=</span> [,表达式<span class="operator">|</span>子查询]</span><br><span class="line">    ...</span><br><span class="line">[<span class="keyword">where</span> 条件表达式]</span><br></pre></td></tr></table></figure>
<ul>
<li>指定对哪些列进行更新，以及更新后的值是什么</li>
</ul>
<h3 id="例子-1">例子 1</h3>
<ul>
<li>老师工资上调 5%</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> PROF</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> salary<span class="operator">*</span><span class="number">1.05</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将 D01系系主任的工资改为该系的平均工资</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SQL 语句无效 */</span></span><br><span class="line"><span class="comment">/* 和删除一样, MySQL 不允许从子查询中出现的表中更新数据 */</span></span><br><span class="line"><span class="keyword">update</span> PROF</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">avg</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> PROF</span><br><span class="line">    <span class="keyword">where</span> dno<span class="operator">=</span>D01</span><br><span class="line">)</span><br><span class="line"><span class="keyword">where</span> pno<span class="operator">=</span> (</span><br><span class="line">    selectdean</span><br><span class="line">    <span class="keyword">from</span> DEPT</span><br><span class="line">    <span class="keyword">where</span> dno<span class="operator">=</span>D01</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>解决方法是一致的，临时视图</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tmp <span class="keyword">as</span>(<span class="keyword">select</span> <span class="built_in">avg</span>(salary) avgsal <span class="keyword">from</span> PROF <span class="keyword">where</span> dno<span class="operator">=</span>D01)</span><br><span class="line"><span class="keyword">update</span> PROF,tmp</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> tmp.avgsal</span><br></pre></td></tr></table></figure>
<h3 id="例子-2">例子 2</h3>
<ul>
<li>当 C1 课程的成绩小于该课程的平均成绩时，将其提高 5%</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tmp <span class="keyword">as</span>(<span class="keyword">select</span> <span class="built_in">avg</span>(grade) avggrade <span class="keyword">from</span> SC <span class="keyword">where</span> cno<span class="operator">=</span>C1)</span><br><span class="line"><span class="keyword">update</span> SC,tmp</span><br><span class="line"><span class="keyword">set</span> grade <span class="operator">=</span> grade<span class="operator">*</span><span class="number">1.05</span> <span class="keyword">where</span> cno<span class="operator">=</span>C1 <span class="keyword">and</span> grade<span class="operator">&lt;</span>tmp.avggrade</span><br></pre></td></tr></table></figure>
<ul>
<li>对所有的课程，满足上述条件的都进行修改</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tmp <span class="keyword">as</span>(</span><br><span class="line">    <span class="keyword">select</span> cno, <span class="built_in">avg</span>(grade) avggrade</span><br><span class="line">    <span class="keyword">from</span> SC</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> cno</span><br><span class="line">)</span><br><span class="line"><span class="keyword">update</span> SC,tmp</span><br><span class="line"><span class="keyword">where</span> SC.cno<span class="operator">=</span>tmp.cno</span><br><span class="line"><span class="keyword">set</span> grade <span class="operator">=</span> grade<span class="operator">*</span><span class="number">1.05</span> <span class="keyword">where</span> grade<span class="operator">&lt;</span>tmp.avggrade</span><br></pre></td></tr></table></figure>
<h3 id="例子-3-case-when">例子 3 (case when)</h3>
<ul>
<li>工资超过 2000 的缴纳 10% 所得税，其余的缴纳 5% 所得税</li>
<li>如果写成两个 SQL，需要考虑执行顺序
<ul>
<li>这里需要先写 5% 的征税（工资小于等于2000），再写 10%
的征税（工资大于2000）</li>
<li><strong>写成多个 SQL 是不好的习惯</strong></li>
</ul></li>
<li>最好写成一个 SQL
<ul>
<li><code>case when</code></li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> PROF</span><br><span class="line"><span class="keyword">set</span> SAL <span class="operator">=</span></span><br><span class="line">    <span class="keyword">case</span> SAL</span><br><span class="line">        <span class="keyword">when</span> SAL <span class="operator">&gt;</span> <span class="number">2000</span> <span class="keyword">then</span> SAL <span class="operator">*</span> <span class="number">0.9</span></span><br><span class="line">        <span class="keyword">when</span> SAL <span class="operator">&lt;=</span> <span class="number">2000</span> <span class="keyword">then</span> SAL <span class="operator">*</span> <span class="number">0.95</span></span><br></pre></td></tr></table></figure>
<h2 id="merge">Merge</h2>
<h3 id="行拷贝">行拷贝</h3>
<ul>
<li>R(ID, A, B), S(ID, A, B)</li>
<li>使用 S 相同 ID 的记录覆盖 R 中相同 ID 的记录</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 错误的写法 */</span></span><br><span class="line"><span class="keyword">update</span> R</span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">    A <span class="operator">=</span> (<span class="keyword">select</span> S.A <span class="keyword">from</span> S <span class="keyword">where</span> R.ID<span class="operator">=</span>S.ID),</span><br><span class="line">    B <span class="operator">=</span> (<span class="keyword">select</span> S.B <span class="keyword">from</span> S <span class="keyword">where</span> R.ID<span class="operator">=</span>S.ID)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>怎么处理呢？</strong>
<ul>
<li><strong>表同步问题</strong></li>
</ul></li>
</ul>
<h3 id="表同步-upsert">表同步: UPSERT</h3>
<ul>
<li>UPSERT：表同步</li>
<li>在把一组记录加载到表中时，一个经典的挑战是如何识别和处理目标表中已有的记录</li>
<li>常用的方法如下
<ul>
<li>如果某记录不存在，就将它插入</li>
<li>如果存在，就用源表中的数据更新该记录</li>
</ul></li>
<li>需要定义复杂的存储过程来完成一系列 INSERT 或 UPDATE
命令，这个技术通常被称为 UPSERT</li>
<li>应用场景
<ul>
<li>业务表不能够一直增大，否则会拖慢系统的性能，因此需要定时保存到历史表中</li>
</ul></li>
</ul>
<h3 id="merge-命令">Merge 命令</h3>
<ul>
<li>merge 子句指定作为插入、更新或删除操作目标的表</li>
<li>using 子句指定要与目标联接的数据源</li>
<li>on 子句指定决定目标与源的匹配位置的联接条件</li>
<li>when 子句基于 on 子句的结果指定所要采取的操作
<ul>
<li>when matched</li>
<li>when not matched by target</li>
<li>when not matched by source</li>
</ul></li>
</ul>
<h3 id="表同步一个典型的应用场景">表同步一个典型的应用场景</h3>
<ul>
<li>数据仓库中的 FactBuyingHabits
表跟踪客户购买产品的最后日期，事务数据库每周都会生成一个包括该周采购情况的PurchaseRecords
表</li>
<li>需要定期将 PurchaseRecords 表中的信息合并到 FactBuyingHabits 表中
<ul>
<li>对于不存在的产品-客户对，插入新行</li>
<li>对于已存在的产品-客户对，更新最近的购买日期</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 指定目标表 */</span></span><br><span class="line"><span class="keyword">merge</span> dbo.FactBuyingHabits <span class="keyword">as</span> target</span><br><span class="line"><span class="comment">/* 指定源表(可以是表或子查询) */</span></span><br><span class="line"><span class="keyword">using</span> (</span><br><span class="line">    <span class="keyword">select</span> CustomerID, ProductID, PurchaseDate</span><br><span class="line">    <span class="keyword">from</span> dbo.Purchases</span><br><span class="line">) <span class="keyword">as</span> source</span><br><span class="line"><span class="comment">/* 指定行匹配(连接条件) */</span></span><br><span class="line"><span class="keyword">on</span>(</span><br><span class="line">    Target.ProductID <span class="operator">=</span> Source.ProductID</span><br><span class="line">    <span class="keyword">and</span> Target.CustomerID <span class="operator">=</span> Source.CustomerID</span><br><span class="line">)</span><br><span class="line"><span class="comment">/* 不同情况的操作 */</span></span><br><span class="line"><span class="comment">/* 匹配上 */</span></span><br><span class="line"><span class="keyword">when</span> matched <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">update</span> setTarget.LastPurchaseDate <span class="operator">=</span> Source.PurchaseDate</span><br><span class="line"><span class="comment">/* 目标表中没有 */</span></span><br><span class="line"><span class="keyword">when</span> <span class="keyword">not</span> matched <span class="keyword">by</span> target <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">insert</span>(CustomerID, ProductID, LastPurchaseDate)</span><br><span class="line">    <span class="keyword">values</span>(Source.CustomerID, Source.ProductID, Source.PurchaseDate)</span><br></pre></td></tr></table></figure>
<ul>
<li>Merge 命令的产生是源于本是据数据仓库的发展</li>
<li>更新操作对于数据库而言是很关键的，一般会有记录（谁更新了什么）
<ul>
<li>审计</li>
</ul></li>
</ul>
<h2 id="output">Output</h2>
<ul>
<li>Output：记录更新历史</li>
<li>执行修改操作只返回影响了多少行的信息，无从获知到底影响到了哪些行</li>
<li>如果在修改操作语句中带上output，就可以输出具体的影响信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">output&#123; deleted<span class="operator">|</span>inserted&#125;.&#123; <span class="operator">*</span> <span class="operator">|</span> column_name&#125;</span><br><span class="line">[<span class="keyword">into</span> table_name]</span><br></pre></td></tr></table></figure>
<ul>
<li>deleted 和 inserted 是两个虚表，deleted
里面存放修改之前的值，inserted 里面存放的是修改之后的值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable">@recordChange</span> <span class="keyword">table</span>(</span><br><span class="line">    beforeGrade <span class="type">int</span>,</span><br><span class="line">    afterGrade  <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> sc</span><br><span class="line"><span class="keyword">set</span> grade<span class="operator">=</span>grade<span class="operator">*</span><span class="number">1.05</span></span><br><span class="line">output deleted.grade,inserted.gradeinto <span class="variable">@recordChange</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> sc</span><br><span class="line">output deleted.<span class="operator">*</span> <span class="keyword">into</span> delHistory</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.04.SQL 完整性</title>
    <url>/2021/05/03/DB/CLJ/04-6/</url>
    <content><![CDATA[<h1 id="在线-sql">在线 SQL</h1>
<ul>
<li>http://sqlfiddle.com/</li>
<li>MySQL 5.6</li>
</ul>
<h1 id="sql-完整性">SQL 完整性</h1>
<h2 id="关系模型中的完整性">关系模型中的完整性</h2>
<h3 id="实体完整性">实体完整性</h3>
<ul>
<li>关系的主码中的属性值不能为空值</li>
<li>实体是相互可区分的</li>
</ul>
<h3 id="参照完整性">参照完整性</h3>
<ul>
<li>外码必须和某个参照的属性相同</li>
<li>必须与客观存在的实体发生联系</li>
</ul>
<h3 id="用户定义的完整性">用户定义的完整性</h3>
<ul>
<li>用户针对具体应用环境定义的完整性约束条件</li>
<li>例如一些具体的限定
<ul>
<li>sno要求是8位整数，首位是0或1</li>
<li>飞行员的飞行里程与星级评定</li>
<li>选课人数不能少于10人，多于100人</li>
<li>在本地纳税记录超过5年才有购房资格</li>
<li>婚姻登记必须购买百年好合保险</li>
</ul></li>
</ul>
<h3 id="比较">比较</h3>
<ul>
<li>实体完整性和参照完整性由系统自动支持</li>
<li>系统提供定义和检验用户定义的完整性的机制</li>
</ul>
<h2 id="约束类型">约束类型</h2>
<ul>
<li>列级约束
<ul>
<li>列值范围</li>
<li>例子
<ul>
<li>取值范围</li>
</ul></li>
</ul></li>
<li>行级约束
<ul>
<li>同一行各列之间</li>
<li>例子
<ul>
<li>飞行员的等级和他的飞行里程有关</li>
<li>主码约束</li>
</ul></li>
</ul></li>
<li>表级约束
<ul>
<li>行间、表上、表间</li>
<li>例子
<ul>
<li>外码约束</li>
</ul></li>
</ul></li>
<li>查看约束：sp_helpconstraint</li>
<li>SQL
<ul>
<li>primarykey</li>
<li>unique</li>
<li>foreignkey</li>
<li>check</li>
<li>default</li>
</ul></li>
</ul>
<h2 id="约束系统表">约束系统表</h2>
<ul>
<li>Sysconstraints 系统表</li>
</ul>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 10%">
<col style="width: 80%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">列名</th>
<th style="text-align: center;">数据类型</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">constid</td>
<td style="text-align: center;">int</td>
<td style="text-align: center;">约束号</td>
</tr>
<tr class="even">
<td style="text-align: center;">id</td>
<td style="text-align: center;">int</td>
<td style="text-align: center;">拥有该约束的表ID</td>
</tr>
<tr class="odd">
<td style="text-align: center;">colid</td>
<td style="text-align: center;">smallint</td>
<td style="text-align: center;">在其上定义约束的列ID，如果是表约束则为0</td>
</tr>
<tr class="even">
<td style="text-align: center;">status</td>
<td style="text-align: center;">int</td>
<td style="text-align: center;">位图指示状态。可能的值包括：<br>1 =
PRIMARY KEY 约束<br>2 = UNIQUE KEY 约束<br>3 = FOREIGN KEY 约束<br>4
= CHECK 约束<br>5 = DEFAULT 约束<br>16 = 列级约束<br>32 =
表级约束</td>
</tr>
</tbody>
</table>
<h2 id="primary-key-与-unique">primary key 与 unique</h2>
<ul>
<li>都是通过<strong>唯一性索引</strong>来支持</li>
<li>区别
<ul>
<li>primary key 不能为空值，unique 可以为空值</li>
<li><strong>unique 列只能有一个 null</strong></li>
</ul></li>
<li>unique 可以定义在多个列上，此时可以出现多个 null</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 (</span><br><span class="line">    col1 intunique,</span><br><span class="line">    col2 <span class="type">int</span>,</span><br><span class="line">    col3 <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">unique</span>(col2,col3)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Col1</th>
<th style="text-align: center;">Col2</th>
<th style="text-align: center;">Col3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">null</td>
</tr>
<tr class="odd">
<td style="text-align: center;">null</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">null</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 (</span><br><span class="line">    col1 <span class="type">int</span> <span class="keyword">unique</span>,</span><br><span class="line">    col2 <span class="type">int</span>,</span><br><span class="line">    col3 <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">unique</span>(col2,col3)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> t1 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">/* insert t1 values(1,2,2);*/</span>     <span class="comment">/* ERROR */</span></span><br><span class="line"><span class="keyword">insert</span> t1 <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">insert</span> t1 <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">1</span>,<span class="keyword">null</span>);       <span class="comment">/* OK */</span></span><br><span class="line"><span class="keyword">insert</span> t1 <span class="keyword">values</span>(<span class="number">4</span>,<span class="number">1</span>,<span class="keyword">null</span>);       <span class="comment">/* OK */</span></span><br><span class="line"><span class="comment">/* insert t1 values(5,1,1);*/</span>     <span class="comment">/* ERROR */</span></span><br></pre></td></tr></table></figure>
<h3 id="primary-key-与-unique-的背后">primary key 与 unique 的背后</h3>
<ul>
<li>系统自动生成一张约束系统表</li>
</ul>
<p><img src="/2021/05/03/DB/CLJ/04-6/image-20210504225355792.png" style="zoom:55%;"></p>
<h2 id="foreign-key">foreign key</h2>
<ul>
<li><strong>基本关系</strong>：主码所在的关系</li>
<li><strong>依赖关系</strong>：外码所在的关系</li>
<li>参照完整性
<ul>
<li>当外码所在的表需要插入一个记录的时候，需要检查外码的值再主码中存在</li>
<li>当主码所在的表删除一个记录的时候，可能也会影响参照完整性</li>
</ul></li>
</ul>
<h3 id="foreign-key-的三种定义方式">foreign key 的三种定义方式</h3>
<h4 id="restrict-方式">RESTRICT 方式</h4>
<ul>
<li>只有当依赖关系中<strong>没有一个外码值</strong>与要删除（更新）的基本关系的主码值相对应时，才可以删除（更新）该行（的主码），否则系统<strong>拒绝此删除操作</strong></li>
</ul>
<h4 id="cascade方式">CASCADE方式</h4>
<ul>
<li>将<strong>依赖关系</strong>中所有外码值与基本关系中要删除的主码值所对应的行<strong>一起删除</strong>（将依赖关系中所有与基本关系中要修改的主码值所对应的外码值一起修改为新值）</li>
</ul>
<h4 id="set-null方式">SET NULL方式</h4>
<ul>
<li>删除（更新）基本关系中的行时，将<strong>依赖关系</strong>中与基本关系中被删（更新）主码值相对应的<strong>外码值置为空值</strong></li>
</ul>
<h2 id="表级约束">表级约束</h2>
<ul>
<li>涉及多行或多表之间的联系</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC (</span><br><span class="line">    sno <span class="type">char</span>(<span class="number">8</span>),</span><br><span class="line">    cno <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">    grade <span class="type">smallint</span>,</span><br><span class="line">    primay key(sno,cno),</span><br><span class="line">    <span class="keyword">check</span>(sno <span class="keyword">in</span>(<span class="keyword">select</span> sno <span class="keyword">from</span> S)),</span><br><span class="line">    <span class="keyword">check</span>(cno <span class="keyword">in</span>(<span class="keyword">select</span> cno <span class="keyword">from</span> C))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>好像是在声明外码约束，有一些细节上的区别
<ul>
<li><strong>check 定义在 SC 中，当修改 S 表或 C
表的时候是不会有检查的</strong></li>
</ul></li>
</ul>
<h2 id="约束命名及其定义">约束命名及其定义</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constraint</span> 约束名<span class="operator">&lt;</span>约束条件<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>撤销与添加约束</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> ... <span class="keyword">drop</span> <span class="keyword">constraint</span> ...</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> ... <span class="keyword">add</span> <span class="keyword">constraint</span> ...</span><br></pre></td></tr></table></figure>
<ul>
<li>例子</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> S (</span><br><span class="line">    sno <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">constraint</span> S_PK <span class="keyword">primary</span> key</span><br><span class="line">)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> S <span class="keyword">drop</span> <span class="keyword">constraint</span> S_PK</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> SC <span class="keyword">add</span> <span class="keyword">constraint</span> SC_CHECK</span><br><span class="line">    <span class="keyword">check</span>(sno <span class="keyword">in</span>(<span class="keyword">select</span> sno <span class="keyword">from</span> S))</span><br></pre></td></tr></table></figure>
<h2 id="约束检查">约束检查</h2>
<ul>
<li><strong>相互参照的表</strong>，如何插入行</li>
</ul>
<p><img src="/2021/05/03/DB/CLJ/04-6/image-20210504232355476.png" style="zoom:50%;"></p>
<ul>
<li>同样的问题，<strong>自参照的表</strong></li>
</ul>
<p><img src="/2021/05/03/DB/CLJ/04-6/image-20210504232541030.png" style="zoom:50%;"></p>
<ul>
<li>先 drop constraint，在插入之后再 add constraint
<ul>
<li><strong>不可行的，可能会有不满足约束条件的数据混入，不安全</strong></li>
</ul></li>
<li>可以先整理成一个树形的结构，然后从根部开始插入数据</li>
</ul>
<h2 id="延迟约束">延迟约束</h2>
<ul>
<li>deferred constraints
<ul>
<li>将<strong>多个更新操作语句放入一个事务</strong>，在提交时才检查约束</li>
</ul></li>
<li>如何设置延迟约束</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在约束创建时 */</span></span><br><span class="line">[<span class="keyword">not</span>] deferrable</span><br><span class="line">initially deferred [immediate]</span><br><span class="line"><span class="comment">/* 对现有约束 */</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">constraint</span> 约束名 deferried</span><br></pre></td></tr></table></figure>
<ul>
<li>例子</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">    eno     <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">primary</span> key,</span><br><span class="line">    ename   <span class="type">char</span>(<span class="number">20</span>),</span><br><span class="line">    mgr     <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">constraint</span> FK_Constraint   <span class="keyword">foreign</span> key</span><br><span class="line">                    <span class="keyword">references</span>  emp(eno)</span><br><span class="line">                    deferrable initially immediate <span class="comment">/* 初始的时候立即检查 */</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在导入数据的时候,设置延迟约束 */</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">constraint</span> FK_Constraint deferried</span><br></pre></td></tr></table></figure>
<h3 id="sql-server-的约束开关">SQL Server 的约束开关</h3>
<ul>
<li>with nocheck</li>
<li>暂时关闭约束开关</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(col_a <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">with</span> nocheck</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> skip_check <span class="keyword">check</span>(col_a <span class="operator">&gt;</span> <span class="number">1</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">-2</span>) <span class="comment">/* 可以执行 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>禁用</strong>并<strong>重新启用</strong>一个约束(nocheck)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 nocheck <span class="keyword">constraint</span> skip_check</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">VALUES</span>(<span class="number">-2</span>)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">check</span> <span class="keyword">constraint</span> skip_check</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的操作很危险，可能混入不满足约束条件的记录</li>
<li>SQL Server 提供了一个补救措施</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 列出不满足条件的行记忆他们不满足哪一个约束条件 */</span></span><br><span class="line">dbcc checkconstraints</span><br></pre></td></tr></table></figure>
<h2 id="函数约束">函数约束</h2>
<ul>
<li>约束条件非常复杂，简单的 check 无法实现</li>
</ul>
<h3 id="例子-1">例子 1</h3>
<ul>
<li>当插入一个新行的时候，使用的值是当前没有使用的最小值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建表 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> noGap(</span><br><span class="line">    <span class="keyword">no</span> <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">/* 函数约束 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> fn_noGap_minUnusedKey()</span><br><span class="line"><span class="keyword">returns</span> <span class="type">int</span> <span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">/* 尚未申请则返回 1 */</span></span><br><span class="line">    if(<span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> noGap <span class="keyword">where</span> <span class="keyword">no</span> <span class="operator">=</span> <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">declare</span> <span class="variable">@min</span>_unused_no <span class="type">int</span></span><br><span class="line">    <span class="keyword">select</span> <span class="variable">@min</span>_unused_no <span class="operator">=</span> <span class="built_in">min</span>(<span class="keyword">no</span> <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">from</span> noGap NO1</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">from</span> noGap NO2</span><br><span class="line">        <span class="keyword">where</span> NO2.no <span class="operator">=</span> NO1.no <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">@min</span>_unused_no</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用约束 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> noGap</span><br><span class="line">      <span class="keyword">add</span> <span class="keyword">constraint</span> DF_no <span class="keyword">default</span>(fn_noGap_minUnusedKey())<span class="keyword">for</span> <span class="keyword">no</span></span><br></pre></td></tr></table></figure>
<h3 id="例子-2">例子 2</h3>
<ul>
<li>选课人数不能超过 100</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> fn_registerCount(<span class="variable">@cno</span> <span class="type">varchar</span> )</span><br><span class="line"><span class="keyword">returns</span> <span class="type">int</span> <span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        selectcount(<span class="operator">*</span>)</span><br><span class="line">        <span class="keyword">from</span> sc</span><br><span class="line">        <span class="keyword">where</span> cno<span class="operator">=</span> <span class="variable">@cno</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">End</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> sc</span><br><span class="line">      <span class="keyword">add</span> <span class="keyword">constraint</span> CK_registerCount <span class="keyword">check</span>(fn_registerCount(cno) <span class="operator">&lt;=</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<h2 id="assertion">assertion</h2>
<ul>
<li>实际数据库不支持</li>
<li>检查开销太大了</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* AtoB 只能有一条路径 */</span></span><br><span class="line"><span class="keyword">create</span> assertion AtoB <span class="keyword">check</span> (</span><br><span class="line">    <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">        <span class="keyword">select</span> A</span><br><span class="line">        <span class="keyword">from</span> R</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> A</span><br><span class="line">        <span class="keyword">having</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> B) <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.04.SQL 安全性</title>
    <url>/2021/05/03/DB/CLJ/04-7/</url>
    <content><![CDATA[<h1 id="在线-sql">在线 SQL</h1>
<ul>
<li>http://sqlfiddle.com/</li>
<li>MySQL 5.6</li>
</ul>
<h1 id="sql-安全性">SQL 安全性</h1>
<ul>
<li>数据库的安全性是很重要的</li>
</ul>
<h2 id="主体">主体</h2>
<ul>
<li>主体（principal）
<ul>
<li>是可以授予权限以访问特定数据库对象的对象，包括<strong>登录用户</strong>、<strong>角色</strong>、<strong>应用程序</strong></li>
</ul></li>
</ul>
<h3 id="sql-server-下三个级别的主体">SQL Server 下三个级别的主体</h3>
<h4 id="windows-级别的主体">Windows 级别的主体</h4>
<ul>
<li>Windows 域用户帐号/组、本地用户帐号/组，基于 Windows 身份验证</li>
<li>创建Windows登录名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> login login_name <span class="keyword">from</span> windows</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> login [ljchen<span class="operator">-</span>PC\SQLUser] <span class="keyword">from</span> windows</span><br></pre></td></tr></table></figure>
<ul>
<li>删除Windows登录名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> login login_name</span><br></pre></td></tr></table></figure>
<ul>
<li>拒绝和允许 Windows 用户访问 SQL Server</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">deny <span class="keyword">connect</span> <span class="keyword">SQL</span> <span class="keyword">to</span> login_name</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">connect</span> <span class="keyword">SQL</span> <span class="keyword">to</span> login_name</span><br></pre></td></tr></table></figure>
<ul>
<li>查看Windows登录名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sys.server_principals</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,type,sid,principal_id</span><br><span class="line"><span class="keyword">from</span> sys.server_principals</span><br><span class="line"><span class="keyword">where</span> type_desc<span class="operator">=</span><span class="string">&#x27;WINDOWS_LOGIN&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="sql-server-级别的主体">SQL Server 级别的主体</h4>
<ul>
<li><p>SQL Server 级别的登录名和固定服务器角色</p></li>
<li><p>创建 SQL Server 登录名</p></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> login login_name</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> login sweetHeart</span><br><span class="line"><span class="keyword">with</span> password<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span></span><br><span class="line">default_database<span class="operator">=</span><span class="string">&#x27;demoDB&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看 SQL Server 登录名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,type,sid,principal_id</span><br><span class="line"><span class="keyword">from</span> sys.server_principals</span><br><span class="line"><span class="keyword">where</span> type_desc<span class="operator">=</span><span class="string">&#x27;SQL_LOGIN&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="数据库级别的主体">数据库级别的主体</h4>
<ul>
<li><p>数据库用户、数据库角色、应用程序角色</p></li>
<li><p>创建 SQL Server 数据库用户</p></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> user_name</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> Carefully</span><br><span class="line"><span class="keyword">for</span> login [ljchen<span class="operator">-</span>PC\SQLUser]</span><br><span class="line"><span class="keyword">with</span> default_schema<span class="operator">=</span>Finance</span><br></pre></td></tr></table></figure>
<ul>
<li>删除数据库用户</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure>
<ul>
<li>报告数据库用户信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sp_helpuser</span><br></pre></td></tr></table></figure>
<h3 id="角色">角色</h3>
<ul>
<li>角色是一组<strong>相关权限</strong>的集合，即将多个不同的权限集合在一起就形成了角色</li>
<li>如果直接把权限分给用户，权限授予关系非常繁琐</li>
<li>通常数据库上的权限是和职位（角色）对应的</li>
</ul>
<p><img src="/2021/05/03/DB/CLJ/04-7/image-20210505214704801.png" style="zoom:50%;"></p>
<ul>
<li>查看 SQL Server 固定服务器角色</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> sys.server_principals</span><br><span class="line"><span class="keyword">where</span> type_desc<span class="operator">=</span><span class="string">&#x27;SERVER_ROLE&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>添加登录名到固定服务器角色</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sp_addsrvrolemember</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sp_addsrvrolemember <span class="string">&#x27;sweetHeart&#x27;</span>, <span class="string">&#x27;sysadmin&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>从固定服务器角色删除登录名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sp_dropsrvrolemember</span><br></pre></td></tr></table></figure>
<ul>
<li>添加用户名到数据库角色</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sp_addrolemember</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exec</span> sp_addrolemember <span class="string">&#x27;db_datawriter&#x27;</span>, <span class="string">&#x27;Carefully&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>从数据库角色删除用户名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sp_droprolemember</span><br></pre></td></tr></table></figure>
<ul>
<li>查看 SQL Server 固定数据库角色</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sp_helpdbfixedrole</span><br></pre></td></tr></table></figure>
<ul>
<li>查看角色成员</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sp_helprolemember</span><br></pre></td></tr></table></figure>
<h2 id="客体">客体</h2>
<ul>
<li>客体
<ul>
<li>安全对象（securable）</li>
<li>主体所操纵的对象</li>
</ul></li>
<li>服务器范围：登录名、数据库和端点</li>
<li>数据库范围：数据库用户、角色、架构</li>
<li>架构范围：各种对象，如表、视图、函数、存储过程等</li>
</ul>
<h2 id="权限">权限</h2>
<ul>
<li>权限（permission）
<ul>
<li>允许主体在安全对象上执行操作</li>
</ul></li>
<li>权限的转授和回收
<ul>
<li>允许用户<strong>把已获得的权限转授给其他用户</strong>，或者<strong>把已授给其他用户的权限再回收上来</strong></li>
</ul></li>
</ul>
<h3 id="权限图">权限图</h3>
<ul>
<li>结点是用户，根结点是 DBA</li>
<li>有向边 <span class="math inline">\(U_i\to\;U_j\)</span>，表示用户
<span class="math inline">\(U_i\)</span> 把某权限授给用户 <span class="math inline">\(U_j\)</span></li>
<li>一个用户拥有权限的<strong>充分必要条件</strong>是在权限图中有一条从根结点到该用户结点的路径</li>
<li>回收某个结点权限的时候，需要把这个结点转授的权限收回
<ul>
<li>上面一行
<ul>
<li>回收 U1 的时候，需要回收 U4 的权限</li>
</ul></li>
<li>下面一行
<ul>
<li>只回收 U2，结果是第二张小图</li>
<li>回收 U2、U3，需要把 U2、U3 之间的权限都回收</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/05/03/DB/CLJ/04-7/image-20210505221247912.png" style="zoom:50%;"></p>
<h3 id="报告可用权限">报告可用权限</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sys.fn_builtin_permissions</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> class_desc,</span><br><span class="line">    permission_name,</span><br><span class="line">    covering_permission_name,</span><br><span class="line">    parent_class_desc,</span><br><span class="line">    parent_covering_permission_name</span><br><span class="line"><span class="keyword">from</span> sys.fn_builtin_permissions(<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="授权命令">授权命令</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限</span><br><span class="line"><span class="keyword">on</span> 对象名</span><br><span class="line"><span class="keyword">to</span> &#123;用户[,用户]...<span class="operator">|</span>public&#125;</span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">grant</span> option]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>with grant option</code>：获得权限的用户可以把权限再授予其它用户</li>
<li><strong>表级权限</strong>
<ul>
<li>select, update, insert, delete, index, alter, drop, resource
等以及它们的总和 all</li>
</ul></li>
<li>为什么需要 references 权限
<ul>
<li>是否允许其他用户定义外码来参照这个表？</li>
<li>可能出现泄密的可能</li>
</ul></li>
</ul>
<h3 id="回收权限">回收权限</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span> 权限</span><br><span class="line"><span class="keyword">on</span> 对象</span><br><span class="line"><span class="keyword">from</span> &#123;用户[,用户]...<span class="operator">|</span>public&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>授权路径的起点一定是 DBA</li>
<li>收回权限时，若该用户已将权限转授给其它用户，则也一并收回</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 授予权限 */</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>, <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> S</span><br><span class="line"><span class="keyword">to</span> Liming</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">grant</span> option</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回收权限 */</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> S</span><br><span class="line"><span class="keyword">from</span> Liming</span><br></pre></td></tr></table></figure>
<h3 id="当前用户">当前用户</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable">@usrchar</span>(<span class="number">30</span>)</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@usr</span><span class="operator">=</span><span class="keyword">user</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;The current user is: &#x27;</span> <span class="operator">+</span> <span class="variable">@usr</span></span><br></pre></td></tr></table></figure>
<ul>
<li>实现精细存取控制
<ul>
<li>普通员工只能查看自己的记录</li>
<li>部门经理可以查看他所管理的员工</li>
<li>人力资源代表可以查看所有员工</li>
</ul></li>
<li>不同的用户执行相同的命令，可能返回的结果是不一样的</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> SNAME <span class="operator">=</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure>
<h2 id="审计">审计</h2>
<ul>
<li>审计就是对指定用户在数据库中的操作情况进行<strong>监控和记录</strong>，用以审查用户的相关活动
<ul>
<li>数据被非授权用户删除，用户越权管理，权限管理不正确，用户获得不应有的系统权限等</li>
</ul></li>
<li>审计就是<strong>监视和收集关于指定数据库获得的数据</strong>
<ul>
<li>哪些表经常被修改，用户共执行了多少次 I/O 操作等，为优化提供依据</li>
</ul></li>
</ul>
<h3 id="sql-server">SQL Server</h3>
<ul>
<li>服务器审核</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> server audit MyServerAuditto file ...</span><br></pre></td></tr></table></figure>
<ul>
<li>服务器审核规范</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> server audit specification MyServerAuditSpe</span><br><span class="line"><span class="keyword">for</span> server audit MyServerAudit</span><br><span class="line"><span class="keyword">alter</span> server audit specification MyServerAuditSpe</span><br><span class="line"><span class="keyword">add</span> (SERVER_PRINCIPAL_CHANGE_GROUP)</span><br></pre></td></tr></table></figure>
<ul>
<li>数据库审核规范</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database audit specification MyDBAudit</span><br><span class="line"><span class="keyword">for</span> server audit MyServerAudit</span><br><span class="line"><span class="keyword">alter</span> database audit specification MyDBAudit</span><br><span class="line"><span class="keyword">add</span> (SELECTONS)</span><br></pre></td></tr></table></figure>
<ul>
<li>查看审核历史</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> event_time, succeeded, statement</span><br><span class="line"><span class="keyword">from</span> sys.fn_get_audit_file(…)</span><br></pre></td></tr></table></figure>
<h2 id="加密">加密</h2>
<h3 id="短语加密">短语加密</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">encryptByPassPhrase(&#123; <span class="string">&#x27;passphrase&#x27;</span>, <span class="string">&#x27;cleartext&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> encryptByPassPhrase(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;whoami&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="还原数据">还原数据</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">decryptByPassPhrase( &#123; <span class="string">&#x27;passphrase&#x27;</span>, <span class="string">&#x27;ciphertext&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> decryptByPassPhrase(<span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line"><span class="number">0x0100000021D68E2E078E3EA6752239788B69D8B9BF1AD542A7C9774C9CAF66304F215F49</span>)</span><br></pre></td></tr></table></figure>
<h3 id="非对称密钥加密">非对称密钥加密</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">asymmetric</span> key myAsym_key</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(ename, salary)</span><br><span class="line"><span class="keyword">values</span>(<span class="string">&#x27;tom&#x27;</span>, EncryptByAsymkey(Asymkey_ID(<span class="string">&#x27;myAsym_key&#x27;</span>),<span class="number">100000000</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> DecryptByAsymkey(</span><br><span class="line">    Asymkey_ID(<span class="string">&#x27;myAsym_key&#x27;</span>), salary</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;tom&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="对称密钥加密">对称密钥加密</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">symmetric</span> key mySym_key</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(ename,salary)</span><br><span class="line"><span class="keyword">values</span>(<span class="string">&#x27;tom&#x27;</span>, EncryptBykey(Key_GUID(<span class="string">&#x27;mySym_key&#x27;</span>),<span class="number">100000000</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> DecryptByKey(</span><br><span class="line">Key_GUID(<span class="string">&#x27;mySym_key&#x27;</span>),salary)</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;tom&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="sql-注入">SQL 注入</h2>
<h3 id="一个例子">一个例子</h3>
<ul>
<li>认证过程发出的查询语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;jake&#x27;</span></span><br><span class="line"><span class="keyword">and</span> PASSWORD<span class="operator">=</span><span class="string">&#x27;jakespasswd&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>攻击者篡改这个SQL语句
<ul>
<li>这样的话始终为真</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;jake&#x27;</span></span><br><span class="line"><span class="keyword">and</span>(PASSWORD<span class="operator">=</span><span class="string">&#x27;jakespasswd&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;x&#x27;</span><span class="operator">=</span><span class="string">&#x27;x&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>现在这种情况比较少，数据库会先对用户的输入进行一个检查</li>
</ul>
<h2 id="基于视图的安全性控制">基于视图的安全性控制</h2>
<ul>
<li>授权 Tom 只有察看职工平均工资的权限</li>
<li>定义一个视图，仅授予用户这个权限</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> avg_sal</span><br><span class="line"><span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">avg</span>(sal)</span><br><span class="line">    <span class="keyword">from</span> PROF</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">SELECT</span> <span class="keyword">on</span> avg_sal <span class="keyword">to</span> <span class="string">&#x27;Tom&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="资源控制oracle">资源控制：Oracle</h2>
<ul>
<li>PROFILE</li>
</ul>
<p><img src="/2021/05/03/DB/CLJ/04-7/image-20210505225532090.png" style="zoom:70%;"></p>
<h2 id="统计数据库安全">统计数据库安全</h2>
<ul>
<li>要求：<strong>用户只能查询数据的聚集值，不能访问个体</strong></li>
</ul>
<h3 id="漏洞">漏洞</h3>
<ul>
<li>漏洞一：个体太少
<ul>
<li>查询选修 ”古典哲学史“ 的学生的平均成绩（假设只有一个人选）</li>
<li>解决方案：可以做一个限制，如果返回记录数小于设定值 k
条，则不返回结果</li>
</ul></li>
<li>漏洞二：多次查询，太多交叠
<ul>
<li>Q1：查询 n 个学生的总成绩为 x</li>
<li>Q2：查询 n 个学生＋A 的总成绩为 y</li>
<li>A 的总成绩为 y-x</li>
<li>解决方案：两个查询的交不能多于m</li>
</ul></li>
</ul>
<h3 id="解决方案">解决方案</h3>
<ul>
<li>查询引用的数据不能少于 n</li>
<li>两个查询的交不能多于 m</li>
<li>推出个体信息至少需要 <span class="math inline">\(1+\dfrac{n-2}{m}\)</span> 次查询</li>
</ul>
<h4 id="例子">例子</h4>
<ul>
<li>Student (ID, GPA)，ID从1 到 50</li>
<li>任何查询结果只能是一个聚集值</li>
<li>每次至少使用 4 条元组</li>
<li>任何两个查询的交不能大于 2 条元组</li>
<li>给出一个查询集合，使得能确定 ID=9 的 GPA</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 我的一个解答 */</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">9</span>;</span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span>;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span>;</span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span>;</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<h2 id="隐私保护">隐私保护</h2>
<h3 id="数据发布">数据发布</h3>
<ul>
<li>数据脱敏处理
<ul>
<li>例如把个体姓名抹去</li>
</ul></li>
</ul>
<p><img src="/2021/05/03/DB/CLJ/04-7/image-20210505231933683.png" style="zoom:60%;"></p>
<ul>
<li>还是可能会出现数据泄露的问题</li>
</ul>
<h3 id="连接推理">连接推理</h3>
<ul>
<li>[Swe00]
的研究表明，87％的美国人口信息可以通过性别、出生日期、5位邮政编码进行个人重建</li>
</ul>
<p><img src="/2021/05/03/DB/CLJ/04-7/image-20210505232109407.png" style="zoom:60%;"></p>
<h3 id="k-anonymity">k-anonymity</h3>
<ul>
<li>k 匿名</li>
<li>有相同的准标识属性组（QI）的元组至少有 k 个（2-anonymous）</li>
</ul>
<p><img src="/2021/05/03/DB/CLJ/04-7/image-20210505232433215.png" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.04.非关系型数据</title>
    <url>/2021/05/24/DB/CLJ/04-8/</url>
    <content><![CDATA[<h1 id="sql-非关系型数据">SQL 非关系型数据</h1>
<ul>
<li>关系型数据库中的非关系数据</li>
<li>关系型数据库的目标：One Size Fits All</li>
<li>非关系数据
<ul>
<li>序列、树、图、XML、JSON、RDF</li>
<li>...</li>
</ul></li>
</ul>
<h2 id="窗口函数">窗口函数</h2>
<ul>
<li>股票走势的指标
<ul>
<li>移动平均线</li>
<li>MACD：指数平滑异同平均线</li>
<li>KDJ</li>
<li>BOLL</li>
<li>K 线</li>
</ul></li>
<li><strong>需要窗口函数的支持</strong></li>
<li>移动方式
<ul>
<li>滑动窗口：最近</li>
<li>跳动窗口：每隔</li>
</ul></li>
<li>窗口范围
<ul>
<li>基于时间</li>
<li>基于行</li>
<li>基于值</li>
</ul></li>
<li>基于行的滑动窗口
<ul>
<li>基准：current row</li>
</ul></li>
</ul>
<p><img src="/2021/05/24/DB/CLJ/04-8/image-20210524161712986.png" style="zoom:50%;"></p>
<h3 id="窗口函数声明">窗口函数声明</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">function_name(<span class="operator">&lt;</span>argument<span class="operator">&gt;</span>, <span class="operator">&lt;</span>argument<span class="operator">&gt;</span>, ...)</span><br><span class="line"><span class="keyword">over</span> (</span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">Partition</span> <span class="keyword">by</span> 子句<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">Order</span> <span class="keyword">by</span> 子句<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>Windowing 子句<span class="operator">&gt;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>Partition by：对表进行分区，类似group by</li>
<li>Order by：排序</li>
<li>Windowing：窗口函数</li>
</ul>
<h3 id="一个例子">一个例子</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">stock(stock_id, trade_day, open_price, high_price, low_price, close_price)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> stock_id</span><br><span class="line"><span class="comment">-- 按照股票号分区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> trade_day</span><br><span class="line"><span class="comment">-- 按照交易日期排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">5</span> preceding <span class="keyword">and</span> <span class="number">3</span> following</span><br><span class="line"><span class="comment">-- 基于行</span></span><br><span class="line"><span class="comment">-- 每行对应的数据窗口是之前 5 行, 之后 3 行</span></span><br><span class="line"><span class="comment">-- 一共 9 行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> unbounded following(<span class="keyword">current</span> <span class="type">row</span>)</span><br><span class="line"><span class="comment">-- 基于行</span></span><br><span class="line"><span class="comment">-- 每行对应的数据窗口是从第一行到最后一行(当前行)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">range</span> <span class="keyword">between</span> <span class="number">50</span> preceding <span class="keyword">and</span> <span class="number">150</span> following</span><br><span class="line"><span class="comment">-- 基于值</span></span><br><span class="line"><span class="comment">-- 每行对应的数据窗口包含比当前行值大50以及小于150的行</span></span><br></pre></td></tr></table></figure>
<ul>
<li>应用例子
<ul>
<li>下面例子的边界情况</li>
<li>第一行没有前一行，那么就是当前行和下一行两行的平均</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> stock_id,trade_day,close_price,</span><br><span class="line">       <span class="built_in">avg</span>(close_price) <span class="keyword">over</span>(</span><br><span class="line">           <span class="keyword">order</span> <span class="keyword">by</span> trade_day</span><br><span class="line">           <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> preceding <span class="keyword">and</span> <span class="number">1</span> following</span><br><span class="line">       ) <span class="keyword">as</span> avg_price</span><br><span class="line"><span class="keyword">from</span> stock</span><br></pre></td></tr></table></figure>
<h3 id="窗口函数类型">窗口函数类型</h3>
<ul>
<li>传统聚集函数：sum,avg,count,max,min</li>
<li>排名函数：rank,dense_rank,row_number</li>
<li>分布函数：percent_rank,cume_dist</li>
<li>逆分布函数：percent_cont,percentile_disc</li>
<li>偏移函数：lag,lead</li>
</ul>
<h4 id="示例表">示例表</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">testid</th>
<th style="text-align: center;">studentid</th>
<th style="text-align: center;">score</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Test ABC</td>
<td style="text-align: center;">Student E</td>
<td style="text-align: center;">50</td>
</tr>
<tr class="even">
<td style="text-align: center;">Test ABC</td>
<td style="text-align: center;">Student C</td>
<td style="text-align: center;">55</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Test ABC</td>
<td style="text-align: center;">Student D</td>
<td style="text-align: center;">55</td>
</tr>
<tr class="even">
<td style="text-align: center;">Test ABC</td>
<td style="text-align: center;">Student H</td>
<td style="text-align: center;">65</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Test ABC</td>
<td style="text-align: center;">Student I</td>
<td style="text-align: center;">75</td>
</tr>
<tr class="even">
<td style="text-align: center;">Test ABC</td>
<td style="text-align: center;">Student B</td>
<td style="text-align: center;">80</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Test ABC</td>
<td style="text-align: center;">Student F</td>
<td style="text-align: center;">80</td>
</tr>
<tr class="even">
<td style="text-align: center;">Test ABC</td>
<td style="text-align: center;">Student A</td>
<td style="text-align: center;">95</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Test ABC</td>
<td style="text-align: center;">Student G</td>
<td style="text-align: center;">95</td>
</tr>
<tr class="even">
<td style="text-align: center;">Test XYZ</td>
<td style="text-align: center;">Student E</td>
<td style="text-align: center;">50</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Test XYZ</td>
<td style="text-align: center;">Student C</td>
<td style="text-align: center;">55</td>
</tr>
<tr class="even">
<td style="text-align: center;">Test XYZ</td>
<td style="text-align: center;">Student D</td>
<td style="text-align: center;">55</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Test XYZ</td>
<td style="text-align: center;">Student H</td>
<td style="text-align: center;">65</td>
</tr>
<tr class="even">
<td style="text-align: center;">Test XYZ</td>
<td style="text-align: center;">Student I</td>
<td style="text-align: center;">75</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Test XYZ</td>
<td style="text-align: center;">Student B</td>
<td style="text-align: center;">80</td>
</tr>
<tr class="even">
<td style="text-align: center;">Test XYZ</td>
<td style="text-align: center;">Student F</td>
<td style="text-align: center;">80</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Test XYZ</td>
<td style="text-align: center;">Student A</td>
<td style="text-align: center;">95</td>
</tr>
<tr class="even">
<td style="text-align: center;">Test XYZ</td>
<td style="text-align: center;">Student G</td>
<td style="text-align: center;">95</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Test XYZ</td>
<td style="text-align: center;">Student J</td>
<td style="text-align: center;">95</td>
</tr>
</tbody>
</table>
<h4 id="一般聚合函数">一般聚合函数</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> testid, studentid, score,</span><br><span class="line">       <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">over</span>(</span><br><span class="line">           <span class="keyword">partition</span> <span class="keyword">by</span> testid</span><br><span class="line">           <span class="keyword">order</span> <span class="keyword">by</span> score</span><br><span class="line">           <span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span></span><br><span class="line">       ) <span class="keyword">as</span> cnt</span><br><span class="line"><span class="keyword">from</span> Stats.Scores</span><br></pre></td></tr></table></figure>
<h4 id="排名函数对比">排名函数对比</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> studentid, score,</span><br><span class="line">       <span class="built_in">rank</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> rk,</span><br><span class="line">       <span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>)<span class="keyword">as</span> drk,</span><br><span class="line">       <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>)<span class="keyword">as</span> rn</span><br><span class="line">fromStats.Scores</span><br></pre></td></tr></table></figure>
<ul>
<li>部分结果展示
<ul>
<li>rank、dense_rank、row_number 区别如下</li>
</ul></li>
</ul>
<p><img src="/2021/05/24/DB/CLJ/04-8/image-20210524163924647.png" style="zoom:67%;"></p>
<h4 id="ntile">ntile</h4>
<ul>
<li>划档，<strong>尽可能</strong>让每个档中的人数相同</li>
<li>每条记录的返回值就是一个序号</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> studentid, score,</span><br><span class="line">       <span class="built_in">ntile</span>(<span class="number">4</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> nt1,</span><br><span class="line">       <span class="built_in">ntile</span>(<span class="number">3</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> nt2</span><br><span class="line"><span class="keyword">from</span> Stats.Scores</span><br></pre></td></tr></table></figure>
<ul>
<li>参照效果如下（数据似乎和示例表有出入）</li>
</ul>
<p><img src="/2021/05/24/DB/CLJ/04-8/image-20210524164537316.png" style="zoom:60%;"></p>
<h4 id="percent_rank">percent_rank</h4>
<ul>
<li>返回分位数</li>
<li>计算一个值在一组值当中的相对位置或排名</li>
<li>rk：rank 排名</li>
<li>nr：窗口内总行数</li>
<li><span class="math inline">\(\mathrm{percent\_rank=\dfrac{rk-1}{nr-1}}\)</span></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> studentid, score,</span><br><span class="line">       <span class="built_in">percent_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> pr</span><br><span class="line"><span class="keyword">from</span> Stats.Scores</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/24/DB/CLJ/04-8/image-20210524165211519.png" style="zoom:67%;"></p>
<h4 id="cume_dist">cume_dist</h4>
<ul>
<li>与 percent_rank 类似</li>
<li>计算某个值一组值内的累积分布，也即计算某指定值在一组值中的相对位置</li>
<li>对于值 r，假定采用升序，r 的 cume_dist
是值<strong>低于或等于</strong> r 的值的行数除以整个行数</li>
</ul>
<p><img src="/2021/05/24/DB/CLJ/04-8/image-20210524165328336.png" style="zoom:67%;"></p>
<h4 id="逆分布函数">逆分布函数</h4>
<ul>
<li>percentile_disc：离散百分位
<ul>
<li>找到的结果一定是数据中存在的</li>
</ul></li>
<li>percentile_cont：连续百分位
<ul>
<li>找到的结果不一定是数据中存在的</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> testid,</span><br><span class="line">       <span class="built_in">percentile_disc</span>(<span class="number">0.5</span>) <span class="keyword">with</span> <span class="keyword">in</span> <span class="keyword">group</span>(<span class="keyword">order</span> <span class="keyword">by</span> score)</span><br><span class="line">           <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> testid) <span class="keyword">as</span> d_median,</span><br><span class="line">       <span class="built_in">percentile_cont</span>(<span class="number">0.5</span>) <span class="keyword">with</span> <span class="keyword">in</span> <span class="keyword">group</span>(<span class="keyword">order</span> <span class="keyword">by</span> score)</span><br><span class="line">           <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> testid) <span class="keyword">as</span> c_median,</span><br><span class="line">       <span class="built_in">percentile_disc</span>(<span class="number">0.25</span>) <span class="keyword">with</span> <span class="keyword">in</span> <span class="keyword">group</span>(<span class="keyword">order</span> <span class="keyword">by</span> score)</span><br><span class="line">           <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> testid) <span class="keyword">as</span> d_lower_quartile,</span><br><span class="line">       <span class="built_in">percentile_cont</span>(<span class="number">0.25</span>) <span class="keyword">with</span> <span class="keyword">in</span> <span class="keyword">group</span>(<span class="keyword">order</span> <span class="keyword">by</span> score)</span><br><span class="line">           <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> testid) <span class="keyword">as</span> c_lower_quartile,</span><br><span class="line">       <span class="built_in">percentile_disc</span>(<span class="number">0.75</span>) <span class="keyword">with</span> <span class="keyword">in</span> <span class="keyword">group</span>(<span class="keyword">order</span> <span class="keyword">by</span> score)</span><br><span class="line">           <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> testid) <span class="keyword">as</span> d_upper_quartile,</span><br><span class="line">       <span class="built_in">percentile_cont</span>(<span class="number">0.75</span>) <span class="keyword">with</span> <span class="keyword">in</span> <span class="keyword">group</span>(<span class="keyword">order</span> <span class="keyword">by</span> score)</span><br><span class="line">           <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> testid) <span class="keyword">as</span> c_upper_quartile</span><br><span class="line"><span class="keyword">from</span> Stats.Scores</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/24/DB/CLJ/04-8/image-20210524165631469.png"></p>
<h4 id="偏移函数">偏移函数</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lag</span>(表达式,偏移量,缺省值) <span class="keyword">over</span>(...)</span><br><span class="line"><span class="comment">-- 将当前行与同一值集中的先前行进行比较</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">lead</span>(表达式,偏移量,缺省值) <span class="keyword">over</span>(...)</span><br><span class="line"><span class="comment">-- 将当前行与同一值集中的后续行进行比较</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">lag</span>(score,<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">as</span> pre_score,</span><br><span class="line">       score,</span><br><span class="line">       <span class="built_in">lead</span>(score,<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">as</span> next_score</span><br><span class="line"><span class="keyword">from</span> Stats.Scores</span><br></pre></td></tr></table></figure>
<h2 id="树">树</h2>
<h3 id="层次结构">层次结构</h3>
<ul>
<li>数据结构
<ul>
<li><strong>树</strong>：职工之间的领导联系</li>
<li><strong>有向图</strong>：零件之间的构成联系</li>
<li><strong>无向图</strong>：交通网络</li>
</ul></li>
<li>操作需求
<ul>
<li>返回指定节点的所有子（父）节点，显示格式</li>
<li>改变隶属关系</li>
<li>环路检测</li>
<li>生成传递闭包</li>
<li>最短路径</li>
</ul></li>
</ul>
<h4 id="层次结构的例子">层次结构的例子</h4>
<p><img src="/2021/05/24/DB/CLJ/04-8/image-20210524170430597.png" style="zoom:67%;"></p>
<h4 id="层次结构的关系表示方法">层次结构的关系表示方法</h4>
<ul>
<li>对于树、图等数据结构，其关系存储有以下三种方式</li>
</ul>
<pre class="mermaid">graph TD;
A-->B;
A-->C;
B-->D;
B-->E;
C-->F</pre>
<h5 id="邻接表">邻接表</h5>
<ul>
<li>adjacent(child,parent)</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">child</th>
<th style="text-align: center;">parent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">A</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">A</td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: center;">B</td>
</tr>
<tr class="odd">
<td style="text-align: center;">E</td>
<td style="text-align: center;">B</td>
</tr>
<tr class="even">
<td style="text-align: center;">F</td>
<td style="text-align: center;">C</td>
</tr>
</tbody>
</table>
<h5 id="物化路径">物化路径</h5>
<ul>
<li>记录所有的路径</li>
<li>materialize_path(node,path)</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">node</th>
<th style="text-align: center;">path</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">.A</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">.A.B</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">.A.C</td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: center;">.A.B.D</td>
</tr>
<tr class="odd">
<td style="text-align: center;">E</td>
<td style="text-align: center;">.A.B.E</td>
</tr>
<tr class="even">
<td style="text-align: center;">F</td>
<td style="text-align: center;">.A.C.F</td>
</tr>
</tbody>
</table>
<h5 id="嵌套集合">嵌套集合</h5>
<ul>
<li>子结点的范围是父结点的一个细分</li>
<li>nested_net(node,left_value,right_value)</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">node</th>
<th style="text-align: center;">left_value</th>
<th style="text-align: center;">right_value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">12</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">7</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">11</td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">E</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="even">
<td style="text-align: center;">F</td>
<td style="text-align: center;">9</td>
<td style="text-align: center;">10</td>
</tr>
</tbody>
</table>
<p><img src="/2021/05/24/DB/CLJ/04-8/image-20210524171544028.png" style="zoom:50%;"></p>
<h4 id="应用需求">应用需求</h4>
<ul>
<li>找到某个结点的所有子孙节点</li>
<li><strong>递归查询</strong></li>
</ul>
<h3 id="递归查询">递归查询</h3>
<ul>
<li>内部实现，多次连接直到最终形成的表为空</li>
</ul>
<h4 id="oracle">Oracle</h4>
<ul>
<li>Connect By</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> part, subpart</span><br><span class="line"><span class="keyword">From</span> Components</span><br><span class="line"><span class="keyword">Start</span> <span class="keyword">with</span> part <span class="operator">=</span> <span class="string">&#x27;trike&#x27;</span></span><br><span class="line"><span class="keyword">Connect</span> <span class="keyword">by</span> prior subart<span class="operator">=</span>part</span><br><span class="line"><span class="comment">-- 上一条的 subpart 是本条的 part</span></span><br></pre></td></tr></table></figure>
<h4 id="sql-server">SQL Server</h4>
<ul>
<li>基本事实：儿子是孩子</li>
<li>规则：儿子的孩子还是孩子</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> RecursiveCTE</span><br><span class="line"><span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">-- 定位点成员 Anchor Member</span></span><br><span class="line">    <span class="keyword">SELECT</span> ...</span><br><span class="line">    <span class="keyword">FROM</span> BaseTable</span><br><span class="line"></span><br><span class="line">    UNIONALL</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 递归成员 Recursive Member</span></span><br><span class="line">    <span class="keyword">SELECT</span> ...</span><br><span class="line">    <span class="keyword">FROM</span> RecursiveCTE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">Recursive</span> CTE;</span><br></pre></td></tr></table></figure>
<ul>
<li>实际例子</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> Components(part, subpart) <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> part, subpart</span><br><span class="line">    <span class="keyword">from</span> Assembly</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- C 的子零件也是 A 的子零件</span></span><br><span class="line">    <span class="keyword">select</span> A.part, C.subpart</span><br><span class="line">    <span class="keyword">from</span> Assembly A, Components C</span><br><span class="line">    <span class="keyword">where</span> A.subpart<span class="operator">=</span>C.part</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Components <span class="keyword">where</span> part<span class="operator">=</span><span class="string">&#x27;trike&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>从最基础的语法出发实现的递归查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> dbo.fn_subordinates(<span class="variable">@root</span> <span class="keyword">as</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">returns</span> <span class="variable">@Subs</span> <span class="keyword">Table</span> (</span><br><span class="line">    empid <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,</span><br><span class="line">    level <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> <span class="variable">@lvl</span> <span class="keyword">as</span> <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">set</span> <span class="variable">@lvl</span><span class="operator">=</span><span class="number">0</span>; <span class="comment">--Initialize level counter with 0</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> <span class="variable">@Subs</span>(empid,level) <span class="comment">--Insertrootnodeto@Subs</span></span><br><span class="line">    <span class="keyword">select</span> empid, <span class="variable">@lvl</span></span><br><span class="line">    <span class="keyword">from</span> emp</span><br><span class="line">    <span class="keyword">where</span> empid<span class="operator">=</span><span class="variable">@root</span>;</span><br><span class="line">    while @<span class="variable">@rowcount</span><span class="operator">&gt;</span><span class="number">0</span> <span class="comment">--while previous level had rows</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">set</span> <span class="variable">@lvl</span> <span class="operator">=</span> <span class="variable">@lvl</span><span class="operator">+</span><span class="number">1</span>; <span class="comment">--Increment level counter</span></span><br><span class="line">        <span class="comment">--Insert next level of sub ordinates to@Subs</span></span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> <span class="variable">@Subs</span>(empid,level)</span><br><span class="line">        <span class="keyword">select</span> C.empid,<span class="variable">@lvl</span></span><br><span class="line">        <span class="keyword">from</span> <span class="variable">@Subs</span> <span class="keyword">AS</span> P <span class="comment">--P=Parent</span></span><br><span class="line">            <span class="keyword">join</span> emp <span class="keyword">AS</span> C <span class="comment">--C=Child</span></span><br><span class="line">            <span class="keyword">on</span> P.lvl<span class="operator">=</span><span class="variable">@lvl</span><span class="number">-1</span> <span class="comment">--Filter parents from previous level</span></span><br><span class="line">        <span class="keyword">and</span> C.mgrid<span class="operator">=</span>P.empid;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="hierachyidsql-server">Hierachyid：SQL Server</h4>
<ul>
<li>可以存储树的结点，存储树形结构</li>
<li>hierarchyid 表示层次结构中的位置，由应用程序来生成和分配 hierarchyid
值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp (</span><br><span class="line">    NodeID hierarchyid <span class="keyword">primary</span> key clustered,</span><br><span class="line">    NodeLevel <span class="keyword">as</span> NodeID.GetLevel(),</span><br><span class="line">    eno <span class="type">int</span>,</span><br><span class="line">    ename <span class="type">char</span>(<span class="number">20</span>),</span><br><span class="line">    title <span class="type">char</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable">@root</span> hierarchyid,</span><br><span class="line">        <span class="variable">@child1</span> hierarchyid,</span><br><span class="line">        <span class="variable">@child2</span> hierarchyid,</span><br><span class="line">        <span class="variable">@grandchild1</span> hierarchyid</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(NodeID,eno,ename,title)</span><br><span class="line"><span class="keyword">values</span>(hierarchyid::GetRoot(),<span class="number">1</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;CEO&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@root</span><span class="operator">=</span>hierarchyid::GetRoot()</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@child1</span><span class="operator">=</span><span class="variable">@root</span>.GetDescendant(<span class="keyword">null</span>,<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(NodeID,eno,ename,title)</span><br><span class="line"><span class="keyword">values</span>(<span class="variable">@child1</span>,<span class="number">2</span>,<span class="string">&#x27;bob&#x27;</span>,<span class="string">&#x27;VP&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@child2</span><span class="operator">=</span><span class="variable">@root</span>.GetDescendant(<span class="variable">@child1</span>,<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp (NodeID,eno,ename,title)</span><br><span class="line"><span class="keyword">values</span>(<span class="variable">@child2</span>,<span class="number">3</span>,<span class="string">&#x27;Arm&#x27;</span>,<span class="string">&#x27;MS&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@grandchild1</span><span class="operator">=</span><span class="variable">@child1</span>.GetDescendant(<span class="keyword">null</span>, <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(NodeID,eno,ename,title)</span><br><span class="line"><span class="keyword">values</span>(<span class="variable">@grandchild1</span>,<span class="number">4</span>,<span class="string">&#x27;jerry&#x27;</span>,<span class="string">&#x27;PM&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> NodeID.ToString() <span class="keyword">as</span> NodePath,<span class="operator">*</span> <span class="keyword">from</span> emp</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> NodeID.GetAncestor(<span class="number">2</span>) <span class="keyword">as</span> GrandPa,ename</span><br><span class="line"><span class="keyword">from</span> emp <span class="keyword">where</span> eno<span class="operator">=</span><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="图">图</h2>
<h3 id="sql-server-1">SQL Server</h3>
<ul>
<li>图 = 顶点表 + 边表</li>
</ul>
<p><img src="/2021/05/24/DB/CLJ/04-8/image-20210524173555632.png" style="zoom:50%;"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> (...) <span class="keyword">as</span> NODE</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> (...) <span class="keyword">as</span> EDGE</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> ForumMembers(</span><br><span class="line">    MemberID <span class="type">int</span>,</span><br><span class="line">    MemberName <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">as</span> node</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> ForumPosts(</span><br><span class="line">    PostID <span class="type">int</span>,</span><br><span class="line">    PostTitle <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    Postbody <span class="type">varchar</span>(<span class="number">1000</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">as</span> node</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Written_By</span><br><span class="line"><span class="keyword">as</span> edge</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Likes</span><br><span class="line"><span class="keyword">as</span> edge</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Reply_To</span><br><span class="line"><span class="keyword">as</span> edge</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> ForumMembers <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Mike&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> ForumPosts <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;Intro&#x27;</span>,<span class="string">&#x27;I&#x27;&#x27;m Mike from Argentina&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> Written_By($to_id,$from_id) <span class="keyword">values</span>(</span><br><span class="line">    (<span class="keyword">select</span> $node_id <span class="keyword">from</span> ForumMembers <span class="keyword">where</span> MemberId<span class="operator">=</span><span class="number">1</span>),</span><br><span class="line">    (<span class="keyword">select</span> $node_id <span class="keyword">from</span> dbo.ForumPosts <span class="keyword">where</span> PostID<span class="operator">=</span><span class="number">8</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="xml">XML</h2>
<h3 id="mysql">MySQL</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@xml</span><span class="operator">=</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">&lt;bibliography&gt;</span></span><br><span class="line"><span class="string">    &lt;book&gt;</span></span><br><span class="line"><span class="string">        &lt;title&gt;Foundations…&lt;/title&gt;</span></span><br><span class="line"><span class="string">        &lt;author&gt;Abiteboul&lt;/author&gt;</span></span><br><span class="line"><span class="string">        &lt;author&gt;Hull&lt;/author&gt;</span></span><br><span class="line"><span class="string">        &lt;author&gt;Vianu&lt;/author&gt;</span></span><br><span class="line"><span class="string">        &lt;publisher&gt;AddisonWesley&lt;/publisher&gt;</span></span><br><span class="line"><span class="string">        &lt;year&gt;1995&lt;/year&gt;</span></span><br><span class="line"><span class="string">    &lt;/book&gt;</span></span><br><span class="line"><span class="string">&lt;/bibliography&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ExtractValue(<span class="variable">@xml</span>, <span class="string">&#x27;//author&#x27;</span>)</span><br><span class="line"><span class="comment">-- Abiteboul,Hull,Vianu</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> ExtractValue(<span class="variable">@xml</span>, <span class="string">&#x27;//author[2]&#x27;</span>)</span><br><span class="line"><span class="comment">-- Hull</span></span><br></pre></td></tr></table></figure>
<h2 id="json">JSON</h2>
<ul>
<li>对象：{属性名：属性值，属性名：属性值 ...}</li>
<li>数组：[ value, value, value ...]</li>
</ul>
<h3 id="mysql-1">MySQL</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 解析为一个 JSON 数组</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">json_array</span>(<span class="number">1</span>, &quot;abc&quot;, <span class="keyword">null</span>, <span class="literal">true</span>, curtime())</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解析成一个 JSON 对象</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">json_object</span>(<span class="string">&#x27;id&#x27;</span>, <span class="number">87</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;carrot&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tj10 (a json, b <span class="type">int</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tj10 <span class="keyword">values</span></span><br><span class="line">    (<span class="string">&#x27;[3,10,5,&quot;x&quot;,44]&#x27;</span>, <span class="number">33</span>),</span><br><span class="line">    (<span class="string">&#x27;[3,10,5,17,[22,&quot;y&quot;,66]]&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> a<span class="operator">-</span><span class="operator">&gt;</span>&quot;$[3]&quot;, a<span class="operator">-</span><span class="operator">&gt;</span>&quot;$[4][1]&quot; <span class="keyword">from</span> tj10</span><br><span class="line"><span class="comment">-- &quot;X&quot;, NULL</span></span><br><span class="line"><span class="comment">-- 17 , &quot;Y&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> jemp(</span><br><span class="line">    c json,</span><br><span class="line">    g <span class="type">int</span> generated always <span class="keyword">as</span>(c<span class="operator">-</span><span class="operator">&gt;</span>&quot;$.id&quot;),</span><br><span class="line">    index i(g)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> jemp(c) <span class="keyword">values</span></span><br><span class="line">    (<span class="string">&#x27;&#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;Fred&quot;&#125;&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;&#123;&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;Wilma&quot;&#125;&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;&#123;&quot;id&quot;:&quot;3&quot;,&quot;name&quot;:&quot;Barney&quot;&#125;&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;&#123;&quot;id&quot;:&quot;4&quot;,&quot;name&quot;:&quot;Betty&quot;&#125;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> c, json_extract(c,&quot;$.id&quot;),g</span><br><span class="line"><span class="keyword">from</span> jemp</span><br><span class="line"><span class="keyword">where</span> json_extract(c,&quot;$.id&quot;)<span class="operator">&gt;</span><span class="number">1</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> json_extract(c,&quot;$.name&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="rdf">RDF</h2>
<ul>
<li>资源描述框架 RDF</li>
</ul>
<p><img src="/2021/05/24/DB/CLJ/04-8/image-20210524174716862.png"></p>
<ul>
<li>三元组
<ul>
<li>&lt;标识符，属性名，属性值&gt;</li>
</ul></li>
</ul>
<p><img src="/2021/05/24/DB/CLJ/04-8/image-20210524174749568.png"></p>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.04.SQL 简介</title>
    <url>/2021/04/11/DB/CLJ/04/</url>
    <content><![CDATA[<h1 id="sql-简介">SQL 简介</h1>
<ul>
<li>SQL：StruceuredQuery Languang</li>
<li>1974年，由 Boyce 和 Chamber 提出</li>
<li>1975-1979年，在 System R 上实现， 由 IBM 的 San Jose
研究室研制，称为 Sequel</li>
</ul>
<h2 id="sql-语言的特点">SQL 语言的特点</h2>
<ul>
<li>语言简洁，易学易用</li>
<li><strong>一体化</strong>：
<ul>
<li>集 DDL，DML，DCL 于一体
<ul>
<li>数据定义语言 DDL</li>
<li>数据操纵语言 DML</li>
<li>数据控制语言 DCL</li>
</ul></li>
<li>单一的结构（关系），带来了数据操作符的统一</li>
</ul></li>
<li><strong>面向集合的操作方式</strong>
<ul>
<li>一次一集合</li>
</ul></li>
<li><strong>高度非过程化</strong>
<ul>
<li>用户只需提出“做什么”，无须告诉“怎么做”，不必了解存取路径</li>
</ul></li>
<li>两种使用方式，统一的语法结构
<ul>
<li>既是自含式的（用户使用）</li>
<li>又是嵌入式的（程序员使用）</li>
</ul></li>
</ul>
<h2 id="sql-的标准化">SQL 的标准化</h2>
<ul>
<li>SQL-86：“数据库语言SQL”</li>
<li>SQL-89：“具有完整性增强的数据库语言SQL”，增加了对完整性约束的支持</li>
<li>SQL-92：“数据库语言SQL”
<ul>
<li>是 SQL-89
的超集，增加了新的数据类型，更丰富的数据操作，更强的完整性、安全性支持等</li>
</ul></li>
<li>SQL:1999：增加对面向对象模型的支持</li>
<li>SQL:2003：XML、Merge</li>
<li>SQL:2008：truncate table、insteadof</li>
<li>SQL:2011：分析函数</li>
</ul>
<h2 id="sql-主要操作符">SQL 主要操作符</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">SQL 功能</th>
<th style="text-align: center;">操作符</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">数据定义</td>
<td style="text-align: center;">create, alter, drop</td>
</tr>
<tr class="even">
<td style="text-align: center;">数据查询</td>
<td style="text-align: center;">select</td>
</tr>
<tr class="odd">
<td style="text-align: center;">数据修改</td>
<td style="text-align: center;">insert, update, delete</td>
</tr>
<tr class="even">
<td style="text-align: center;">数据控制</td>
<td style="text-align: center;">grant, revoke</td>
</tr>
</tbody>
</table>
<h2 id="sql数据访问的事实标准">SQL：数据访问的事实标准</h2>
<ul>
<li>SQL 成为很多数据库都会提供的一些接口</li>
</ul>
<p><img src="/2021/04/11/DB/CLJ/04/image-20210411232314758.png" style="zoom: 43%;"></p>
<ul>
<li>约定俗成的提供一个类 SQL 接口</li>
</ul>
<p><img src="/2021/04/11/DB/CLJ/04/image-20210411232640103.png" style="zoom:50%;"></p>
<ul>
<li>自然语言转化为 SQL</li>
</ul>
<h2 id="sql-模式定义">SQL 模式定义</h2>
<ul>
<li><strong>主要语法都是 MySQL 的语法，标识了的才是其他的，例如 SQL
Server</strong></li>
</ul>
<h3 id="sql-数据定义特点">SQL 数据定义特点</h3>
<ul>
<li>SQL 中，任何时候都可以执行一个数据定义语句，随时修改数据库结构
<ul>
<li>数据库定义不断增长（不必一开始就定义完整）</li>
<li>数据库定义随时修改（不必一开始就完全合理）</li>
<li>可进行增加索引、撤消索引的实验，检验其效率影响</li>
</ul></li>
<li>在非关系型的数据库系统中，必须在数据库装入和使用前全部完成数据库的定义。若要修改已投入运行的数据库，则需停下一切数据库活动，把数据库卸出，修改数据库定义并重新编译，再按修改过的数据库结构重新装入数据</li>
</ul>
<h3 id="标准-sql-中的数据定义对象">标准 SQL 中的数据定义对象</h3>
<p><img src="/2021/04/11/DB/CLJ/04/image-20210411233555901.png" style="zoom:50%;"></p>
<ul>
<li>簇：物理概念，一个文件组</li>
<li>目录：数据库</li>
<li>模式：业务上挨得比较近的表放在一起</li>
<li>对象：表</li>
</ul>
<h3 id="sql-server-定义对象">SQL Server 定义对象</h3>
<p><img src="/2021/04/11/DB/CLJ/04/image-20210411233827361.png" style="zoom:50%;"></p>
<h3 id="sql-server-数据库定义">SQL Server 数据库定义</h3>
<ul>
<li>创建数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">on</span> [<span class="keyword">primary</span>] <span class="operator">&lt;</span>文件描述<span class="operator">&gt;</span> <span class="operator">&lt;</span>文件组<span class="operator">&gt;</span>...]</span><br><span class="line">[log <span class="keyword">on</span><span class="operator">&lt;</span>文件描述<span class="operator">&gt;</span><span class="operator">&lt;</span>文件组<span class="operator">&gt;</span>...]</span><br></pre></td></tr></table></figure>
<ul>
<li>最简单的创建数据库的命令</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database University</span><br></pre></td></tr></table></figure>
<ul>
<li>指定当前要使用的数据库
<ul>
<li>使用 use 命令，指定当前要使用的数据库</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use University</span><br></pre></td></tr></table></figure>
<h3 id="sql-server-模式定义">SQL Server 模式定义</h3>
<ul>
<li>模式把对象和用户分离开来</li>
<li>对象是属于模式的，而不是属于用户的</li>
<li>创建模式</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> schema <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span></span><br><span class="line"><span class="comment">/* 一个例子 */</span></span><br><span class="line"><span class="keyword">create</span> schema University.Library</span><br></pre></td></tr></table></figure>
<ul>
<li>对象命名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span>数据库<span class="operator">&gt;</span>.<span class="operator">&lt;</span>模式<span class="operator">&gt;</span>.<span class="operator">&lt;</span>表<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="mysql-数据库定义">MySQL 数据库定义</h3>
<ul>
<li>MySQL 没有模式的概念</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database<span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">default</span> <span class="type">character</span> <span class="keyword">set</span> utf8</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">collate</span> utf8_Chinese_ci]</span><br></pre></td></tr></table></figure>
<ul>
<li>create database 等同于 create schema</li>
</ul>
<h3 id="mysql-表空间">MySQL 表空间</h3>
<ul>
<li>逻辑概念，物理上由若干个磁盘文件构成</li>
<li>把相关的文件定义在一个表空间里</li>
</ul>
<p><img src="/2021/04/11/DB/CLJ/04/image-20210411234953125.png" style="zoom:80%;"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建一个表空间, 存储引擎为 innodb(MySQL有两个存储引擎) */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>space myTs <span class="string">&#x27;ts1.ibd&#x27;</span> engine<span class="operator">=</span> innodb</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为表空间添加文件 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>space myTs <span class="keyword">add</span> datafile <span class="string">&#x27;F:\\test_mysql_tablespace\\first.ibd&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 建表的时候可以指定表空间 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> myTb(...) tablespace myTs</span><br></pre></td></tr></table></figure>
<ul>
<li>SQL Server 数据库建在文件组上面，表建在数据库上面</li>
<li>MySQL 表建在表空间上面</li>
</ul>
<h3 id="创建基本表">创建基本表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>表名(</span><br><span class="line">    列名 数据类型 [<span class="keyword">default</span> 缺省值] [<span class="keyword">not</span> <span class="keyword">null</span>][<span class="keyword">unique</span>]</span><br><span class="line">    [,列名 数据类型[<span class="keyword">default</span> 缺省值][notnull]]</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 主码 */</span></span><br><span class="line">    [,<span class="keyword">primary</span> key(列名[,列名]...)]</span><br><span class="line">    <span class="comment">/* 外码 */</span></span><br><span class="line">    [,<span class="keyword">foreign</span> key(列名[,列名]...) <span class="keyword">references</span> 表名(列名[,列名]..)]</span><br><span class="line">    <span class="comment">/* 约束条件 */</span></span><br><span class="line">    [,<span class="keyword">check</span>(条件)]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>创建表示例</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 学生表 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> S (</span><br><span class="line">    sno     <span class="type">char</span>(<span class="number">8</span>),</span><br><span class="line">    sname   <span class="type">char</span>(<span class="number">8</span>)     <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;佚名&#x27;</span>,</span><br><span class="line">    age     tinyint,</span><br><span class="line">    sex     <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">primary</span> key(sno),</span><br><span class="line">    <span class="keyword">check</span>(sex<span class="operator">=</span><span class="string">&#x27;M&#x27;</span> <span class="keyword">or</span> sex<span class="operator">=</span><span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 课程表 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> C (</span><br><span class="line">    cno     <span class="type">char</span>(<span class="number">8</span>)     <span class="keyword">primary</span> key,</span><br><span class="line">    cname   <span class="type">char</span>(<span class="number">8</span>)     <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">    <span class="comment">/* 外码 */</span></span><br><span class="line">    pcno    <span class="type">char</span>(<span class="number">8</span>)     <span class="keyword">foreign</span> key <span class="keyword">references</span> C(cno),</span><br><span class="line">    credit  tinyint</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选课结果 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC (</span><br><span class="line">    sno     <span class="type">char</span>(<span class="number">8</span>)     <span class="keyword">foreign</span> key <span class="keyword">references</span> S(sno),</span><br><span class="line">    cno     <span class="type">char</span>(<span class="number">8</span>)     <span class="keyword">foreign</span> key <span class="keyword">references</span> C(cno),</span><br><span class="line">    grade   tinyint,</span><br><span class="line">    <span class="comment">/* 对于复杂的运算, 把计算结果存起来 */</span></span><br><span class="line">    <span class="comment">/* persisted 持久化, 如果不加每次访问都需要重新计算 */</span></span><br><span class="line">    au_grade    <span class="built_in">sqrt</span>(grade)<span class="operator">*</span><span class="number">10</span>  persisted,</span><br><span class="line">    <span class="comment">/* 主码 */</span></span><br><span class="line">    primarykey(sno,cno),</span><br><span class="line">    <span class="keyword">check</span>((grade <span class="keyword">is</span> <span class="keyword">null</span>) <span class="keyword">or</span> grade <span class="keyword">between</span> <span class="number">0</span> <span class="keyword">and</span> <span class="number">100</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="sql-server-表定义相关的字典表">SQL Server
表定义相关的字典表</h3>
<p><img src="/2021/04/11/DB/CLJ/04/image-20210412000650284.png" style="zoom:50%;"></p>
<p><img src="/2021/04/11/DB/CLJ/04/image-20210412000711578.png" style="zoom:47%;"></p>
<ul>
<li>标准SQL中的信息视图
<ul>
<li>像查询普通的表那样查询数据字典</li>
</ul></li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">INFORMATION_SCHEMA.SCHEMATA</span><br><span class="line">INFORMATION_SCHEMA.TABLES</span><br><span class="line">INFORMATION_SCHEMA.COLUMNS</span><br><span class="line">INFORMATION_SCHEMA.CHECK_CONSTRAINTS</span><br><span class="line">INFORMATION_SCHEMA.VIEWS</span><br><span class="line">INFORMATION_SCHEMA.DOMAINS</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="修改基本表">修改基本表</h3>
<ul>
<li>更改、添加、除去列和约束</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名</span><br><span class="line"><span class="comment">/* 增加列 */</span></span><br><span class="line">[<span class="keyword">add</span> <span class="keyword">column</span> 子句]</span><br><span class="line"><span class="comment">/* 增加限制条件 */</span></span><br><span class="line">[<span class="keyword">add</span> <span class="keyword">constraint</span> 子句]</span><br><span class="line"><span class="comment">/* 删除某一列 */</span></span><br><span class="line">[<span class="keyword">drop</span> 子句]</span><br><span class="line"><span class="comment">/* 修改某一列的属性, 比如数据类型 */</span></span><br><span class="line">[<span class="keyword">alter</span> <span class="keyword">column</span> 子句]</span><br></pre></td></tr></table></figure>
<ul>
<li>一些问题</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 执行失败,添加的属性在原来的表里面不存在, not null 与之矛盾 */</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>S <span class="keyword">add</span> resume <span class="type">char</span>[<span class="number">100</span>] <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把数据数组大小改小, 通常是不允许的, 可能会丢失数据 */</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>S <span class="keyword">alter</span> <span class="keyword">column</span> resume <span class="type">char</span>[<span class="number">80</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>如何定义两个相互参照的表
<ul>
<li>定义第一个表的时候声明外码的时候，数据库会判断外码的表是否存在</li>
<li>定义第一个表的时候先不加入参照，当建完第二个表后再加入参照</li>
</ul></li>
</ul>
<p><img src="/2021/04/11/DB/CLJ/04/image-20210412001530774.png" style="zoom:50%;"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(eno <span class="keyword">primary</span> key...)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept(dno <span class="keyword">primary</span> key, manager <span class="keyword">foreign</span> key...)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> dno <span class="keyword">foreign</span> key...</span><br></pre></td></tr></table></figure>
<h3 id="删除表">删除表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名</span><br></pre></td></tr></table></figure>
<ul>
<li>删除表定义及该表的所有数据、索引、触发器、约束和权限规范</li>
<li>任何引用已删除表的视图或存储过程必须通过 drop view 或 drop procedure
语句<strong>显式</strong>除去</li>
<li>drop table 不能删除由 foreign key 约束引用的表，必须先除去引用的
foreign key 约束或引用的表
<ul>
<li>例如上面的例子，如果删除第一个表，则会报错（第二个表在引用它）</li>
<li>所以要先去除约束</li>
</ul></li>
</ul>
<h3 id="临时表与内存表">临时表与内存表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 临时表 */</span></span><br><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> tmpT</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存表 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmpT() engine <span class="operator">=</span> memory</span><br></pre></td></tr></table></figure>
<ul>
<li>对比</li>
</ul>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 34%">
<col style="width: 54%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">临时表</th>
<th style="text-align: center;">内存表</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">存储</td>
<td style="text-align: center;">表结构和数据都存储在内存中</td>
<td style="text-align: center;">表结构存储在磁盘中<br>表数据存储在内存中</td>
</tr>
<tr class="even">
<td style="text-align: center;">会话</td>
<td style="text-align: center;">单个会话独享</td>
<td style="text-align: center;">多个会话共享</td>
</tr>
<tr class="odd">
<td style="text-align: center;">断开连接</td>
<td style="text-align: center;">表结构和表数据都没了</td>
<td style="text-align: center;">表结构和表数据都存在</td>
</tr>
<tr class="even">
<td style="text-align: center;">服务重启</td>
<td style="text-align: center;">表结构和表数据都没了</td>
<td style="text-align: center;">表结构存在<br>表数据不存在</td>
</tr>
</tbody>
</table>
<ul>
<li>临时表可以作为临时变量存储，对于一致性要求没有那么高（并发控制可能速度更快）</li>
<li>临时表的有效范围是在一个连接之内</li>
</ul>
<h3 id="视图">视图</h3>
<ul>
<li>创建视图</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> csStudent <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> sname, dname</span><br><span class="line">    <span class="keyword">from</span> S, DEPT</span><br><span class="line">    <span class="keyword">where</span> S.dno<span class="operator">=</span>DEPT.dno <span class="keyword">and</span> dname<span class="operator">=</span><span class="string">&#x27;计算机系&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> niuGrade <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> sno,cno,grade</span><br><span class="line">    <span class="keyword">from</span> SC</span><br><span class="line">    <span class="keyword">where</span> grade<span class="operator">&gt;=</span><span class="number">95</span></span><br><span class="line">) <span class="keyword">with</span> <span class="keyword">check</span> option</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * with check option</span></span><br><span class="line"><span class="comment"> * 检查对视图的更新操作是不是符合视图定义的约束条件</span></span><br><span class="line"><span class="comment"> * 当插入一个数据不满足视图定义的约束条件时, 不允许插入</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="公共表表达式">公共表表达式</h3>
<ul>
<li>只对这个查询有效</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> S<span class="operator">-</span>total(S#, <span class="keyword">value</span>) <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> sno, <span class="built_in">sum</span> (grade)</span><br><span class="line">    <span class="keyword">from</span> SC</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> sno</span><br><span class="line">), S<span class="operator">-</span>total<span class="operator">-</span><span class="built_in">avg</span>(<span class="keyword">value</span>) <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">avg</span> (<span class="keyword">value</span>)</span><br><span class="line">    <span class="keyword">from</span> S<span class="operator">-</span>total</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> sno</span><br><span class="line"><span class="keyword">from</span> S<span class="operator">-</span>total, S<span class="operator">-</span>total<span class="operator">-</span>avg</span><br><span class="line"><span class="keyword">where</span> S<span class="operator">-</span>total.value <span class="operator">&gt;=</span> S<span class="operator">-</span>total<span class="operator">-</span>avg.value</span><br></pre></td></tr></table></figure>
<h3 id="往表中载入数据">往表中载入数据</h3>
<ul>
<li>文本中载入数据</li>
<li>指定 replace，新行将代替相同码值的现有行</li>
<li>指定 ignore，跳过和现有码值相同的新行输入</li>
<li>不指定任何一个选项，出现重复码时，报错并终止</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">load data infile <span class="string">&#x27;file_name&#x27;</span></span><br><span class="line">[replace<span class="operator">|</span>ignore]</span><br><span class="line"><span class="keyword">into</span> <span class="keyword">table</span> tbl_name</span><br><span class="line">fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span></span><br><span class="line">lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">ignore number lines</span><br><span class="line">[(col_name,)]</span><br></pre></td></tr></table></figure>
<h2 id="sql-数据类型">SQL 数据类型</h2>
<ul>
<li>SQL数据类型
<ul>
<li>数值
<ul>
<li>整数</li>
<li>浮点数</li>
<li>精确数</li>
</ul></li>
<li>字符
<ul>
<li>定长</li>
<li>变长</li>
</ul></li>
<li>日期</li>
<li>二进制</li>
</ul></li>
</ul>
<h3 id="整形">整形</h3>
<ul>
<li>tinyint（1）、smallint（2）、mediumint（3）、int（4）、bigint（8）</li>
<li>int，unsigned int</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_int(</span><br><span class="line">    <span class="comment">/* zero前面填充0, 输入的个数不够的话, 前面补充0 */</span></span><br><span class="line">    a(<span class="number">6</span>)    tinyint zerofill,</span><br><span class="line">    b(<span class="number">6</span>)    tinyint unsigned</span><br><span class="line">)</span><br><span class="line"><span class="comment">/* 输出表的描述 */</span></span><br><span class="line"><span class="keyword">desc</span> test_int</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/11/DB/CLJ/04/image-20210412094127009.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_int <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">111</span>)</span><br><span class="line"><span class="comment">/* 输出表示 zerofill 的效果 */</span></span><br><span class="line"><span class="keyword">select</span> a,b <span class="keyword">from</span> test_int</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/11/DB/CLJ/04/image-20210412094330299.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a<span class="operator">-</span>b <span class="keyword">from</span> test_int</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/11/DB/CLJ/04/image-20210412094446501.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 模式 */</span></span><br><span class="line"><span class="comment">/* 严格模式上述报错 */</span></span><br><span class="line"><span class="keyword">set</span> sql_mode<span class="operator">=</span><span class="string">&#x27;traditional&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宽松模式 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_int <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1111</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/11/DB/CLJ/04/image-20210412094636820.png"></p>
<h3 id="定点数与浮点数">定点数与浮点数</h3>
<ul>
<li>float(m, d)：4 字节
<ul>
<li>m 是总位数，d 是小数点后位数</li>
</ul></li>
<li>double(m ,d)：8 字节</li>
<li>decimal(m, d) / numeric：精确小数
<ul>
<li>最大位数 m 为 65，最大支持小数 d 为 30</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_float(</span><br><span class="line">    <span class="comment">/* insert 浮点数小数部分溢出会被近似, 整数部分溢出会报错 */</span></span><br><span class="line">    a   <span class="type">float</span>(<span class="number">3</span>,<span class="number">2</span>),</span><br><span class="line">    b   <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">desc</span> test_float</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/11/DB/CLJ/04/image-20210412140151720.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_float <span class="keyword">values</span>(<span class="number">1.125</span>,<span class="number">2.123</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_float <span class="keyword">values</span>(<span class="number">1.126</span>,<span class="number">2.1239</span>)</span><br><span class="line"><span class="comment">/* 位数溢出会被截断 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_float</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/11/DB/CLJ/04/image-20210412141040214.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_decimal(</span><br><span class="line">    <span class="comment">/* 默认 (10, 0) */</span></span><br><span class="line">    a   <span class="type">decimal</span>,</span><br><span class="line">    b   <span class="type">decimal</span>(<span class="number">6</span>,<span class="number">4</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/11/DB/CLJ/04/image-20210412141445776.png"></p>
<h3 id="money-数据类型">money 数据类型</h3>
<ul>
<li>money 使用 4 位小数存储数据，所以很容易发生小数的舍入错误</li>
<li>基本上被废弃</li>
<li>对精度敏感，则使用 decimal</li>
</ul>
<h3 id="字符型">字符型</h3>
<ul>
<li>char(n)，0~255，定长字符串，n字节</li>
<li>varchar(n)，0~65535，变长字符串，实际字符串长度</li>
<li>tinytext：<span class="math inline">\(2^8\)</span></li>
<li>text：<span class="math inline">\(2^{16}\)</span></li>
<li>mediumtext：<span class="math inline">\(2^{24}\)</span></li>
<li>longtext：<span class="math inline">\(2^{32}\)</span></li>
</ul>
<h3 id="枚举型">枚举型</h3>
<ul>
<li>enum('v1','v2',...)：只能取一个值</li>
<li>set('v1','v2',...)：可以取多个值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_enum(</span><br><span class="line">    a   enum(<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;女&#x27;</span>),</span><br><span class="line">    b   <span class="keyword">set</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_enum <span class="keyword">values</span>(<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;2,4&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="字符集">字符集</h3>
<ul>
<li>字符集（characterset）：字符 + 编码</li>
<li>字符序（collation）：字符的比较规则
<ul>
<li>需要自己定义字符序，例如
<ul>
<li>字符按其编码比较大小</li>
<li>如果两个字符为大小写关系，则它们相等</li>
</ul></li>
</ul></li>
<li>设置字符集</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="type">character</span> <span class="keyword">set</span> <span class="keyword">like</span> <span class="string">&#x27;UTF*&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use information_schema</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> collations</span><br><span class="line"><span class="keyword">where</span> character_set_name <span class="operator">=</span> <span class="string">&#x27;UTF8&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看当前数据库的字符集</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character*&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果两个列的字符集不同，对他们作比较的时候可能会报错</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 为列和表指定字符集 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmpT(</span><br><span class="line">    c1 <span class="type">char</span>(<span class="number">6</span>) charset utf8 <span class="keyword">collate</span> utf8_romanian_ci,</span><br><span class="line">    c2 <span class="type">char</span>(<span class="number">6</span>) charset utf8 <span class="keyword">collate</span> utf8_spanish_ci</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 报错 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmpT <span class="keyword">values</span>(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tmpT <span class="keyword">where</span> c1<span class="operator">=</span>c2</span><br></pre></td></tr></table></figure>
<h3 id="二进制类型">二进制类型</h3>
<ul>
<li>binary(n)：255</li>
<li>varbinary(n)：16384</li>
<li>tinyblob, blob, mediumblob, longblob
<ul>
<li>256, 16K,16M, 4G</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_binary(abinary(<span class="number">30</span>))</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_binary <span class="keyword">values</span>(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="日期类型">日期类型</h3>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 21%">
<col style="width: 59%">
<col style="width: 9%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">类型名称</th>
<th style="text-align: center;">日期格式</th>
<th style="text-align: center;">日期范围</th>
<th style="text-align: center;">存储需求</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">year</td>
<td style="text-align: center;">YYYY</td>
<td style="text-align: center;">1901<br>2155</td>
<td style="text-align: center;">1 个字节</td>
</tr>
<tr class="even">
<td style="text-align: center;">time</td>
<td style="text-align: center;">HH:MM:SS</td>
<td style="text-align: center;">-838:59:59<br>838:59:59</td>
<td style="text-align: center;">3 个字节</td>
</tr>
<tr class="odd">
<td style="text-align: center;">date</td>
<td style="text-align: center;">YYYY-MM-DD</td>
<td style="text-align: center;">1000-01-01<br>9999-12-3</td>
<td style="text-align: center;">3 个字节</td>
</tr>
<tr class="even">
<td style="text-align: center;">datetime</td>
<td style="text-align: center;">YYYY-MM-DD HH:MM:SS</td>
<td style="text-align: center;">1000-01-01 00:00:00<br>9999-12-31
23:59:59</td>
<td style="text-align: center;">8 个字节</td>
</tr>
<tr class="odd">
<td style="text-align: center;">timestamp</td>
<td style="text-align: center;">YYYY-MM-DD HH:MM:SS</td>
<td style="text-align: center;">1980-01-01 00:00:01 UTC<br>2040-01-19
03:14:07 UTC</td>
<td style="text-align: center;">4 个字节</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_date(a <span class="type">date</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_date <span class="keyword">values</span>(<span class="string">&#x27;2020401&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_date <span class="keyword">values</span>(<span class="string">&#x27;2020-4-1&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_date <span class="keyword">values</span>(<span class="string">&#x27;2020-04-01&#x27;</span>)</span><br><span class="line"><span class="comment">/* 都会统一转化为 2020-04-01 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_datetime(a datetime)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_datetime <span class="keyword">values</span>(<span class="number">2020401235959</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_datetime <span class="keyword">values</span>(<span class="string">&#x27;2020-04-0123:59:59&#x27;</span>)</span><br><span class="line"><span class="comment">/* 会统一转化为 2020-04-01 23:59:59 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_time(atime)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_time <span class="keyword">values</span>(<span class="string">&#x27;22:30:34&#x27;</span>) <span class="comment">/* 22:30:34 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_time <span class="keyword">values</span>(<span class="string">&#x27;123456&#x27;</span>)   <span class="comment">/* 12:34:56 */</span></span><br></pre></td></tr></table></figure>
<h3 id="sql-server-的日期类型">SQL Server 的日期类型</h3>
<ul>
<li>date
<ul>
<li>0001-1-1</li>
<li>9999-12-31</li>
</ul></li>
<li>smalldatetime
<ul>
<li>1900-1-1</li>
<li>2079-6-6</li>
</ul></li>
<li>datetime
<ul>
<li>1753-1-1</li>
<li>9999-12-31</li>
</ul></li>
<li>datetime2：由于设计问题，datetime 从 1753 开始不够用
<ul>
<li>0001-1-1</li>
<li>9999-12-31</li>
</ul></li>
<li>为什么 datetime 从 1753 开始
<ul>
<li>英国从 1753 年开始，用的日历才和欧洲大陆统一起来</li>
</ul></li>
</ul>
<h3 id="特殊类型">特殊类型</h3>
<ul>
<li>XML、Json、空间数据</li>
<li>数据类型决定了数据库的适用范围，数据库支持的数据类型越多，能够支持的应用场景也越多</li>
</ul>
<h3 id="rowversion">rowversion</h3>
<ul>
<li>rowversion 数据类型</li>
<li>如果表中有一列被声明为 rowversion，那么只要一行被修改，该行的
rowversion 列就会发生改变
它是<strong>跨表唯一</strong>的，也即任何表的修改都会使该值递增</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> verTb(val <span class="type">char</span>(<span class="number">10</span>),ver rowversion)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> verTb(val) <span class="keyword">values</span>(<span class="string">&#x27;zero&#x27;</span>) <span class="comment">/* 该操作会修改 ver 的值 */</span></span><br><span class="line"><span class="keyword">update</span> verTb <span class="keyword">set</span> val<span class="operator">=</span><span class="string">&#x27;one&#x27;</span> <span class="comment">/* 该操作会修改 ver 的值 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> verTB</span><br><span class="line"><span class="keyword">update</span> verTb setval<span class="operator">=</span><span class="string">&#x27;two&#x27;</span> <span class="comment">/* 该操作会修改 ver 的值 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> verTB</span><br></pre></td></tr></table></figure>
<ul>
<li>作用，判断某一行是否发生修改</li>
</ul>
<h3 id="uniqueidentifier">uniqueidentifier</h3>
<ul>
<li>uniqueidentifier 数据类型
<ul>
<li>128位</li>
</ul></li>
<li>uniqueidentifier
产生<strong>跨数据库和服务器</strong>的<strong>全局唯一标识符</strong>(GUID)</li>
<li>newid() 函数产生 uniqueidentifier 类型的值</li>
<li>newsequentialid() 产生的 GUID 总是大于先前通过该函数生成的 GUID</li>
<li>select newid() 的输出结果：DD64B592-D477-4114-8131-32E9FCB540FA</li>
</ul>
<h3 id="显式数据类型转换">显式数据类型转换</h3>
<ul>
<li>将一种数据类型转换为另一种</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cast</span>(表达式 <span class="keyword">as</span> 数据类型[(数据长度)] )</span><br><span class="line"><span class="keyword">convert</span>(数据类型[(数据长度)], 表达式[, 输出样式])</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">cast</span>(<span class="number">123.45</span> <span class="keyword">as</span> <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">/* 123.4500 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">cast</span>(<span class="number">123.45</span> <span class="keyword">as</span> <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment">/* 123.5 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">cast</span>(<span class="number">12.34567</span> <span class="keyword">as</span> money)</span><br><span class="line"><span class="comment">/* 12.3457 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;Myageis:&#x27;</span> <span class="operator">+</span><span class="built_in">cast</span>(<span class="number">28</span> <span class="keyword">as</span> <span class="type">char</span>(<span class="number">4</span>))</span><br><span class="line"><span class="comment">/* Myageis:28 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">cast</span>(<span class="built_in">cast</span>(<span class="number">123.45</span> <span class="keyword">as</span> <span class="type">int</span>) <span class="keyword">as</span> <span class="type">char</span>(<span class="number">10</span>))</span><br><span class="line"><span class="comment">/* 123 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">convert</span>(<span class="type">varchar</span>(<span class="number">30</span>), getdate(), <span class="number">106</span>)</span><br><span class="line"><span class="comment">/* 17082012 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">convert</span>(<span class="type">varchar</span>(<span class="number">30</span>), getdate(), <span class="number">110</span>)</span><br><span class="line"><span class="comment">/* 08-17-2012 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">cast</span>(<span class="string">&#x27;SQL&#x27;</span> <span class="keyword">as</span> <span class="type">binary</span>(<span class="number">3</span>))</span><br><span class="line"><span class="comment">/* 0x53514C */</span></span><br></pre></td></tr></table></figure>
<h3 id="隐式数据类型转换">隐式数据类型转换</h3>
<ul>
<li>如果不指定显式的类型转换，那么在对两个不同数据类型的列值进行运算时，系统会进行隐式的类型转换，也即先将它们转换为同一个数据类型，然后再进行运算</li>
<li><strong>注意数据类型之间的优先级</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span><span class="operator">+</span><span class="string">&#x27;1&#x27;</span> <span class="comment">/* 2 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">1</span><span class="operator">+</span><span class="string">&#x27;a&#x27;</span> <span class="comment">/* 显示类型转换错误 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> iff(<span class="number">1</span><span class="operator">=</span><span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">88.8</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">MySQL: 输出 &#x27;A&#x27;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SQL Server: 报错</span></span><br><span class="line"><span class="comment">    首先确定表达式数据类型, 是 decimal</span></span><br><span class="line"><span class="comment">    发现 &#x27;A&#x27; 不能隐式转换为 decimal</span></span><br><span class="line"><span class="comment">    报错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 随意与严谨 */</span></span><br></pre></td></tr></table></figure>
<h3 id="用户定义数据类型">用户定义数据类型</h3>
<ul>
<li>标准数据库语法</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> domain 域名 数据类型</span><br><span class="line"><span class="comment">/* 例子 */</span></span><br><span class="line"><span class="keyword">create</span> domain person<span class="operator">-</span>name <span class="type">char</span>(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>SQL</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">typedef ADDRESS_LIST &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> telephone[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> location[<span class="number">20</span>]</span><br><span class="line">&#125;;</span><br><span class="line">ADDRESS_LIST tom;</span><br></pre></td></tr></table></figure>
<ul>
<li>SQL Server</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> type user_DT <span class="keyword">from</span> Sys_DT</span><br><span class="line"><span class="comment">/* 例子 */</span></span><br><span class="line"><span class="keyword">create</span> type phone_numberfrom <span class="type">varchar</span>(<span class="number">20</span>)<span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> customer(</span><br><span class="line">    cust_id <span class="type">smallint</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    cust_phone phone_number,</span><br><span class="line">    cust_fax <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="如何选择数据类型">如何选择数据类型</h3>
<h4 id="定长与变长">定长与变长</h4>
<ul>
<li>变长之利：减少存储开销＋元组数/页高</li>
<li>变长之弊：查询计算偏移＋更新挪移数据
<ul>
<li>空间不够需要挪移数据</li>
<li>如果当前页面没有空间空闲，留下一个指针，指针指向其他的具体页面</li>
<li>导致的后果是，在实际读取数据的时候，需要读取更多的物理页面</li>
</ul></li>
<li>变长之用：长短显著不一＋很少发生变化</li>
</ul>
<h3 id="主码的选择">主码的选择</h3>
<ul>
<li>主码不能太长
<ul>
<li>保证其惟一性必须进行<strong>字符匹配</strong></li>
<li>一个表的主码经常是另外一个表的<strong>外码</strong>，而外码是对主码的复制，如果主码太长的话，加上外码则会占据很大的表空间</li>
<li>表连接一般是基于主外码的，为加快查询会在主外码上建立索引，太长的主码会使得<strong>一个页面里容纳很少的索引项</strong>，从而增加查找数据时的磁盘I/O数</li>
</ul></li>
<li>如果没有一个很好的自然码作为主码，可以增设一个人工码</li>
<li>MySQL
<ul>
<li>auto_increment：自增的数据类型</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_incr(</span><br><span class="line">    id <span class="type">bigint</span> auto_increment,</span><br><span class="line">    name <span class="type">char</span>(<span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>SQL Server 中的序列号：identity
<ul>
<li>identity[( seed, increment) ]</li>
<li>为一些没有有效主码的表提供计数器</li>
<li>有一个起始数(种子)，增量值(步长)</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> customer1 (</span><br><span class="line">    cust_id <span class="type">smallint</span> <span class="keyword">identity</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    cust_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> customer2 (</span><br><span class="line">    cust_id <span class="type">smallint</span> <span class="keyword">identity</span>(<span class="number">100</span>,<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    cust_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>SQL Server中的序列号：sequence</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> sequence sequence_name <span class="keyword">as</span> 整型 [ <span class="keyword">start</span> <span class="keyword">with</span>] [ increment <span class="keyword">by</span> ] [ <span class="keyword">cycle</span> ]</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> sequence mySeq <span class="keyword">as</span> <span class="type">int</span> <span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span> increment <span class="keyword">by</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> myTb(id,Name) <span class="keyword">values</span>(next <span class="keyword">value</span> <span class="keyword">for</span> mySeq, <span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> myTb(id,Name) <span class="keyword">values</span>(next <span class="keyword">value</span> <span class="keyword">for</span> mySeq, <span class="string">&#x27;jerry&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.05.关系规范化(3)</title>
    <url>/2021/05/19/DB/CLJ/05-2/</url>
    <content><![CDATA[<h1 id="模式分解">模式分解</h1>
<ul>
<li>例子：给定一个关系模式，通过模式分解解决异常</li>
<li>关系模式：<span class="math inline">\(R(ABCD;A\to B,B\to
C)\)</span></li>
<li>分解一
<ul>
<li><span class="math inline">\(R_1(AB;A\to B),R_2(BC;B\to
C)\)</span></li>
<li>不是正确的分解，缺失了属性 <span class="math inline">\(D\)</span></li>
</ul></li>
<li>分解二
<ul>
<li><span class="math inline">\(R_1(ABD;A\to B),R_2(BC;B\to
C),R_3(BD)\)</span></li>
<li>不是正确的分解，<span class="math inline">\(R_3\)</span> 包含在
<span class="math inline">\(R_1\)</span> 中，没必要</li>
</ul></li>
<li>分解三
<ul>
<li><span class="math inline">\(R_1(AB;A\to
B),R_2(AC),R_3(AD)\)</span></li>
<li>不是正确的分解，和原来的关系模式函数依赖不等价（<span class="math inline">\(A\to C\)</span>）</li>
</ul></li>
<li>分解四
<ul>
<li><span class="math inline">\(R_1(AB;A\to B),R_2(AC;A\to
C),R_3(AD)\)</span></li>
<li>正确</li>
</ul></li>
</ul>
<h2 id="模式分解的定义">模式分解的定义</h2>
<ul>
<li>属性上来看
<ul>
<li>子模式的属性集的并集和原来相同</li>
<li>子模式的属性集之间不能有包含关系</li>
</ul></li>
<li>函数依赖上看
<ul>
<li>原来函数依赖集要正确的投影到子模式的属性集上面</li>
</ul></li>
</ul>
<h3 id="函数依赖在属性集上的投影">函数依赖在属性集上的投影</h3>
<ul>
<li>函数依赖集 <span class="math inline">\(F\)</span> 在属性集 <span class="math inline">\(U_i\)</span> 上的投影定义为：<span class="math inline">\(F_i=\{X\to Y|X\to Y\in F^+\land XY\subseteq
U_i\}\)</span></li>
</ul>
<h4 id="例子1">例子1</h4>
<ul>
<li>求 <span class="math inline">\(F=\{A\to B, B\to C, C\to D\}\)</span>
在 <span class="math inline">\(S(ACD)\)</span> 上的投影</li>
<li>先求出闭包
<ul>
<li><span class="math inline">\(A_F^+=ABCD,C_F^+=CD,D_F^+=D\)</span></li>
</ul></li>
<li>写出函数依赖
<ul>
<li>需要考虑二元（多元）
<ul>
<li><span class="math inline">\(A_F^+\)</span>
已经是全集了，于是不需要考虑 <span class="math inline">\(A\)</span>
和其他的组合</li>
<li><span class="math inline">\((CD_F)^+=CD\)</span>，于是也不需要了</li>
</ul></li>
<li><span class="math inline">\(A\to C,A\to D,C\to D\)</span></li>
</ul></li>
<li>消除冗余依赖
<ul>
<li><span class="math inline">\(A\to C,C\to D\)</span></li>
</ul></li>
</ul>
<h4 id="例子2">例子2</h4>
<ul>
<li>计算下面函数依赖集在 <span class="math inline">\(S(ABC)\)</span>
上的投影
<ul>
<li><span class="math inline">\(F=\{AB\to DE,C\to E,D\to C,E\to
A\}\)</span></li>
<li><span class="math inline">\(F=\{A\to D,BD\to E,AC\to E,DE\to
B\}\)</span></li>
<li><span class="math inline">\(F=\{AB\to D,AC\to E,BC\to D,D\to A,E\to
B\}\)</span></li>
</ul></li>
</ul>
<h5 id="fabto-decto-edto-ceto-a"><span class="math inline">\((1)\;F=\{AB\to DE,C\to E,D\to C,E\to
A\}\)</span></h5>
<ul>
<li><p><span class="math inline">\({\color{red}\{C\to A,AB\to C,BC\to
A\}}\)</span></p></li>
<li><p><span class="math inline">\(A_F^+=A\)</span></p></li>
<li><p><span class="math inline">\(B_F^+=B\)</span></p></li>
<li><p><span class="math inline">\(C_F^+=CEA\)</span></p></li>
<li><p><span class="math inline">\((AB)_F^+=ABDEC\)</span></p></li>
<li><p><span class="math inline">\((AC)_F^+=ACE\)</span></p></li>
<li><p><span class="math inline">\((BC)_F^+=BCEAD\)</span></p></li>
</ul>
<h5 id="fato-dbdto-eacto-edeto-b"><span class="math inline">\((2)\;F=\{A\to D,BD\to E,AC\to E,DE\to
B\}\)</span></h5>
<ul>
<li><span class="math inline">\({\color{red}\{AC\to B\}}\)</span></li>
<li><span class="math inline">\(A_F^+=AD\)</span></li>
<li><span class="math inline">\(B_F^+=B\)</span></li>
<li><span class="math inline">\(C_F^+=C\)</span></li>
<li><span class="math inline">\((AB)_F^+=ABDE\)</span></li>
<li><span class="math inline">\((AC)_F^+=ACDEB\)</span></li>
<li><span class="math inline">\((BC)_F^+=BC\)</span></li>
</ul>
<h5 id="fabto-dacto-ebcto-ddto-aeto-b"><span class="math inline">\((3)\;F=\{AB\to D,AC\to E,BC\to D,D\to A,E\to
B\}\)</span></h5>
<ul>
<li><span class="math inline">\({\color{red}\{AC\to B,BC\to
A\}}\)</span></li>
<li><span class="math inline">\(A_F^+=A\)</span></li>
<li><span class="math inline">\(B_F^+=B\)</span></li>
<li><span class="math inline">\(C_F^+=C\)</span></li>
<li><span class="math inline">\((AB)_F^+=ABD\)</span></li>
<li><span class="math inline">\((AC)_F^+=ACEBD\)</span></li>
<li><span class="math inline">\((BC)_F^+=BCDAE\)</span></li>
</ul>
<h3 id="模式分解的定义-1">模式分解的定义</h3>
<ul>
<li>关系模式 <span class="math inline">\(R(U , F)\)</span>
的一个分解是指
<ul>
<li><span class="math inline">\(\rho=\{R_1(U_1,F_1),\cdots,R_n(U_n,F_n)\}\)</span></li>
<li>其中 <span class="math inline">\(U=\bigcup_{i=1}^{n}U_i\)</span>，并且没有 <span class="math inline">\(U_i\subseteq U_j,1\le i,j\le n\)</span></li>
<li><span class="math inline">\(F_i\)</span> 是 <span class="math inline">\(F\)</span> 在 <span class="math inline">\(U_i\)</span> 上的投影</li>
</ul></li>
<li>模式分解的代数运算
<ul>
<li>分解：投影</li>
<li>还原：自然连接</li>
</ul></li>
</ul>
<h3 id="模式分解的目标">模式分解的目标</h3>
<ul>
<li>trade off
<ul>
<li><strong>达到更高级的范式</strong></li>
<li><strong>无损连接分解</strong></li>
<li><strong>保持函数依赖</strong></li>
</ul></li>
</ul>
<h2 id="模式分解中的问题">模式分解中的问题</h2>
<h3 id="异常">异常</h3>
<ul>
<li>分解的过于完全：丢失信息</li>
</ul>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520000151424.png" style="zoom:50%;"></p>
<h3 id="违约违章">违约/违章</h3>
<ul>
<li>在分解之后的表中执行插入操作，重构的时候可能违反原始表的函数依赖
<ul>
<li>问题是丢失了函数依赖</li>
<li><span class="math inline">\(A\to B,A\to C\)</span> 推导不出原来的
<span class="math inline">\(B\to C\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520113036080.png" style="zoom:50%;"></p>
<h3 id="有损">有损</h3>
<ul>
<li>有损分解：信息损失了</li>
</ul>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520113541161.png" style="zoom:50%;"></p>
<h3 id="正确的分解">正确的分解</h3>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520113735780.png" style="zoom:50%;"></p>
<ul>
<li>有损比违章害处更大，违章的数据可以通过检查剔除</li>
</ul>
<h2 id="保持函数依赖的分解">保持函数依赖的分解</h2>
<ul>
<li>设关系模式 <span class="math inline">\(R(U , F)\)</span>
的一个分解是
<ul>
<li><span class="math inline">\(\rho=\{R_1(U_1,F_1),\cdots,R_n(U_n,F_n)\}\)</span></li>
<li>如果 <span class="math inline">\(F^+=(\bigcup_{i=1}^nF_i)^+\)</span></li>
<li>则称 <span class="math inline">\(\rho\)</span>
是保持函数依赖的分解</li>
</ul></li>
<li>等价于验证 <span class="math inline">\(F\subseteq
(\bigcup_{i=1}^nF_i)^+,F_i\subseteq F\)</span></li>
<li>由于 <span class="math inline">\(F_i\)</span> 都是由 <span class="math inline">\(F\)</span> 导出的，我们只需要验证 <span class="math inline">\(F\)</span> 中的函数依赖能够被 <span class="math inline">\(\bigcup F_i\)</span> 导出即可</li>
</ul>
<h3 id="丢失函数依赖的分解实例">丢失函数依赖的分解实例</h3>
<ul>
<li><span class="math inline">\(U=\{CITY,ST,ZIP\},F=\{(CITY,ST)\to
ZIP,ZIP\to CITY\}\)</span></li>
<li>分解如下
<ul>
<li><span class="math inline">\(U_1=\{ST,ZIP\},F1=\{\}\)</span></li>
<li><span class="math inline">\(U_2=\{CITY,ZIP\},F2=\{ZIP\to
CITY\}\)</span></li>
</ul></li>
<li>丢失了函数依赖 <span class="math inline">\((CITY,ST)\to
ZIP\)</span></li>
<li>插入数据导致的问题</li>
</ul>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520114858895.png" style="zoom:50%;"></p>
<h3 id="有损分解的例子">有损分解的例子</h3>
<ul>
<li>构造方法：公共属性上相同值多一些</li>
</ul>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520114954753.png" style="zoom:50%;"></p>
<h2 id="无损连接分解">无损连接分解</h2>
<h3 id="定义">定义</h3>
<ul>
<li>设关系模式 <span class="math inline">\(R(U , F)\)</span>
的一个分解是
<ul>
<li><span class="math inline">\(\rho=\{R_1(U_1,F_1),\cdots,R_n(U_n,F_n)\}\)</span></li>
<li><span class="math inline">\(r\)</span> 是 <span class="math inline">\(R\)</span> 的任意一个关系实例</li>
<li>定义 <span class="math inline">\(m_{\rho}(r)=\prod_{U_i}(r)\)</span></li>
<li>若 <span class="math inline">\(m_{\rho}(r)=r\)</span>，则称 <span class="math inline">\(\rho\)</span> 是 <span class="math inline">\(R\)</span> 的一个无损分解</li>
</ul></li>
</ul>
<h3 id="无损连接分解的判别算法">无损连接分解的判别算法</h3>
<ul>
<li><span class="math inline">\(U=\{A_1,A_2,\cdots,A_n\}\)</span></li>
<li><span class="math inline">\(\rho=\{R_1(U_1,F_1),\cdots,R_k(U_k,F_k)\}\)</span></li>
</ul>
<h4 id="建立一个-n-列-k-行的矩阵-tb">(1) 建立一个 <span class="math inline">\(n\)</span> 列 <span class="math inline">\(k\)</span> 行的矩阵 TB</h4>
<ul>
<li>填充矩阵</li>
<li><span class="math inline">\(TB=\{C_{ij}|若A_i\in
U_i,C_{ij}=a_j,否则C_{ij}=b_{ij}\}\)</span></li>
</ul>
<h4 id="对-f-中每一个函数依赖-xto-y">(2) 对 <span class="math inline">\(F\)</span> 中每一个函数依赖 <span class="math inline">\(X\to Y\)</span></h4>
<ul>
<li>若 TB 中存在元组 <span class="math inline">\(t_1,t_2\)</span>，使得
<span class="math inline">\(t_1[X]=t_2[X],t_1[Y]\ne t_2[Y]\)</span></li>
<li>则对每一个 <span class="math inline">\(A_i\in Y\)</span>
进行如下操作
<ul>
<li>若 <span class="math inline">\(t_1[A_i],t_2[A_i]\)</span>
中有一个等于<span class="math inline">\(a_j\)</span>，则另一个也改为
<span class="math inline">\(a_j\)</span></li>
<li>否则取 <span class="math inline">\(t_1[A_i]=t_2[A_i]\)</span>（<span class="math inline">\(t_2\)</span> 的行号小于 <span class="math inline">\(t_1\)</span>）</li>
</ul></li>
</ul>
<h4 id="反复执行-2直至如下情况发生">(3) 反复执行
(2)，直至如下情况发生</h4>
<ul>
<li>TB 中出现一行全为 <span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>的一行（无损分解）</li>
<li>TB 不再变化，而且没有一行为 <span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>（有损分解）</li>
</ul>
<h4 id="一个算法的例子">一个算法的例子</h4>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520121032976.png" style="zoom:50%;"></p>
<h3 id="分解为两个关系模式的无损分解">分解为两个关系模式的无损分解</h3>
<ul>
<li>关系模式 <span class="math inline">\(R(U),U_1\cup U_2 =
U\)</span></li>
<li><span class="math inline">\(r\)</span> 是 <span class="math inline">\(R\)</span> 上的任一关系，<span class="math inline">\(r_1=\prod_{U_1}(r),r_2=\prod_{U_2}(r)\)</span></li>
<li>若<span class="math inline">\(r = r_1\bowtie r_2\)</span>，则称
<span class="math inline">\(\{U_1,U_2\}\)</span> 是 <span class="math inline">\(U\)</span> 的一个无损连接分解</li>
</ul>
<h4 id="判定">判定</h4>
<ul>
<li><span class="math inline">\(\rho\)</span> 是无损连接分解 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(U_1\cap U_2\to U_1−U_2\)</span> 或 <span class="math inline">\(U_1\cap U_2\to U_2−U_1\)</span></li>
<li>使用之前的判定算法做一个简单的证明</li>
</ul>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520121911067.png" style="zoom:50%;"></p>
<ul>
<li>在这里没有证明， 如果是无损的，则能推出上述函数依赖</li>
</ul>
<h4 id="例子">例子</h4>
<ul>
<li><span class="math inline">\(R=ABC,F=\{A\to B\}\)</span></li>
<li>分解一：<span class="math inline">\(\rho_1={R_1(AB),R_2(AC)}\)</span>
<ul>
<li><span class="math inline">\(R_1\cap R_2=A,R_1-R_2=B\)</span></li>
<li>由 <span class="math inline">\(A\to B\)</span>，得到 <span class="math inline">\(\rho_1\)</span></li>
<li>是无损连接分解</li>
</ul></li>
<li>分解二：<span class="math inline">\(\rho_2=\{R_1(AB),R_2(BC)\}\)</span>
<ul>
<li><span class="math inline">\(R_1\cap
R_2=B,R_1-R_2=A,R_2-R_1=C\)</span></li>
<li><span class="math inline">\(B\to A,B\to C\)</span> 均不成立</li>
<li>不是无损连接分解</li>
</ul></li>
</ul>
<h3 id="达到-bcnf-无损连接分解算法">达到 BCNF 无损连接分解算法</h3>
<ul>
<li>BCNF：对于每个子模式，所有的函数依赖的左边都是码</li>
</ul>
<h4 id="算法流程">算法流程</h4>
<ul>
<li>给定关系模式 <span class="math inline">\(R(U,F)\)</span>
<ul>
<li><ol type="1">
<li>令 <span class="math inline">\(\rho=R(U,F)\)</span></li>
</ol></li>
<li><ol start="2" type="1">
<li>检查 <span class="math inline">\(\rho\)</span>
中各关系模式是否属于BCNF，若是，则算法终止</li>
</ol></li>
<li><ol start="3" type="1">
<li>设 <span class="math inline">\(\rho\)</span> 中 <span class="math inline">\(R_i(U_i,F_i)\)</span> 不属于 BCNF</li>
</ol>
<ul>
<li>则存在函数依赖 <span class="math inline">\(X\to A\in
F_i^+\)</span>，且 <span class="math inline">\(X\)</span> 不是 <span class="math inline">\(R_i\)</span> 的码</li>
<li>将 <span class="math inline">\(R_i\)</span> 分解为 <span class="math inline">\(\sigma=\{S_1(U_1),S_2(U_2)\}\)</span></li>
<li>其中 <span class="math inline">\(U_1=XA,U_2=U_i-A\)</span></li>
<li>以 <span class="math inline">\(\sigma\)</span> 代替 <span class="math inline">\(R_i\)</span>，返回到 (2)</li>
</ul></li>
</ul></li>
<li>结果一定能够达到 BCNF</li>
<li>结果一定是无损的，可以通过上面 ”分解为两个关系模式的无损分解算法“
证明
<ul>
<li><span class="math inline">\(U_1\cap U_2=X\)</span></li>
<li><span class="math inline">\(U_1-U_2=A\)</span></li>
<li><span class="math inline">\(X\to A\)</span></li>
</ul></li>
</ul>
<h4 id="一个例子">一个例子</h4>
<ul>
<li>码是 AD，A 不是码，B 不是码</li>
</ul>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520151750073.png" style="zoom:50%;"></p>
<ul>
<li>当原来的关系模式中，存在多个函数依赖不满足
BCNF，处理的先后顺序会影响最终的结果</li>
<li>如何构造一个有 N 种 BCNF 分解结果的关系模式？
<ul>
<li>一个例子：3</li>
<li><span class="math inline">\(A\to D,B\to D,C\to D\)</span>，码是
<span class="math inline">\(ABC\)</span></li>
</ul></li>
</ul>
<h4 id="关于bcnf分解的额外讨论">关于BCNF分解的额外讨论</h4>
<ul>
<li><span class="math inline">\(R(ABCD),FD=\{A\to B,A\to
C\}\)</span></li>
<li>码是 <span class="math inline">\(AD\)</span>，分解为 BCNF
<ul>
<li>分解结果为 <span class="math inline">\(R_1(AB),R_2(AC),R_3(AD)\)</span></li>
</ul></li>
<li><span class="math inline">\(R_1,R_2\)</span> 没必要分开</li>
<li>优化方法：基于 <span class="math inline">\(X\to A\)</span> 的 BCNF
分解，<span style="font-weight:bold;color:red">将右边扩展为 <span class="math inline">\(X\)</span> 的闭包</span>
<ul>
<li>分解结果为 <span class="math inline">\(R_1(ABC),R_2(AD)\)</span></li>
</ul></li>
</ul>
<h3 id="达到-4nf-无损连接分解算法">达到 4NF 无损连接分解算法</h3>
<ul>
<li>给定关系模式 <span class="math inline">\(R(U,F)\)</span>
<ul>
<li><ol type="1">
<li>令 <span class="math inline">\(\rho=R(U,F)\)</span></li>
</ol></li>
<li><ol start="2" type="1">
<li>检查 <span class="math inline">\(\rho\)</span>
中各关系模式是否属于BCNF，若是，则算法终止</li>
</ol></li>
<li><ol start="3" type="1">
<li>设 <span class="math inline">\(\rho\)</span> 中 <span class="math inline">\(R_i(U_i,F_i)\)</span> 不属于 BCNF</li>
</ol>
<ul>
<li>则存在非平凡多值依赖 <span class="math inline">\(X\to\to
A\)</span>，且 <span class="math inline">\(X\)</span> 不是 <span class="math inline">\(R_i\)</span> 的码</li>
<li>将 <span class="math inline">\(R_i\)</span> 分解为 <span class="math inline">\(\sigma=\{S_1(U_1),S_2(U_2)\}\)</span></li>
<li>其中 <span class="math inline">\(U_1=XA,U_2=U_i-A\)</span></li>
<li>以 <span class="math inline">\(\sigma\)</span> 代替 <span class="math inline">\(R_i\)</span>，返回到 (2)</li>
</ul></li>
</ul></li>
<li>一个例子</li>
</ul>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520152425047.png" style="zoom:50%;"></p>
<h3 id="丢失函数依赖的-bcnf-分解">丢失函数依赖的 BCNF 分解</h3>
<ul>
<li>若要求分解保持函数依赖，那么分解后的模式总可以达到
3NF，但不一定能达到 BCNF</li>
<li>例子
<ul>
<li><span class="math inline">\(U=(sno, tno, cno),F=\{(sno, cno)\to tno,
tno\to cno\}\)</span></li>
<li>不属于BCNF，分解为 <span class="math inline">\(U_1=(sno,
tno),U_2=(tno, cno),F_2=\{tno\to cno\}\)</span></li>
<li>丢失了函数依赖 <span class="math inline">\((sno, cno)\to
tno\)</span></li>
</ul></li>
</ul>
<h3 id="达到-3nf-保持函数依赖的分解">达到 3NF 保持函数依赖的分解</h3>
<ul>
<li>求 <span class="math inline">\(F\)</span> 的最小覆盖 <span class="math inline">\(F_{min}\)</span></li>
<li>找出不在 <span class="math inline">\(F_{min}\)</span>
中出现的属性，将它们构成一个关系模式，并从 <span class="math inline">\(U\)</span> 中去掉它们（剩余属性仍记为<span class="math inline">\(U\)</span>）</li>
<li>若有 <span class="math inline">\(X\to A\in F_{min}\)</span>，且
<span class="math inline">\(XA=U\)</span>，<span class="math inline">\(\rho=\{R\}\)</span>，算法终止</li>
<li>对 <span class="math inline">\(F_{min}\)</span>
按具有相同左部的原则进行分组（设为 <span class="math inline">\(k\)</span> 组）
<ul>
<li>每一组函数依赖所涉及的属性全体为 <span class="math inline">\(U_i\)</span></li>
<li>令 <span class="math inline">\(F_i\)</span> 为 <span class="math inline">\(F_{min}\)</span>在 <span class="math inline">\(U_i\)</span>上的投影</li>
<li>则 <span class="math inline">\(\rho=\{R_1(U_1,F_1),\cdots,R_k(U_k,F_k)\}\)</span>
是 <span class="math inline">\(R(U,F)\)</span>
的一个保持函数依赖的分解</li>
<li>并且每个 <span class="math inline">\(R_i(U_i,F_i)\in
3NF\)</span></li>
</ul></li>
</ul>
<h4 id="例子-1">例子</h4>
<ul>
<li><span class="math inline">\(U=\{A,B,C,D,E\},F=\{A\to B,B\to C,AD\to
E\}\)</span></li>
<li>分组
<ul>
<li><span class="math inline">\(\{(AB),A\to B\}\)</span></li>
<li><span class="math inline">\(\{(BC),B\to C\}\)</span></li>
<li><span class="math inline">\(\{(ADE),AD\to E\}\)</span></li>
</ul></li>
</ul>
<h3 id="同时保持函数依赖和无损连接的分解">同时保持函数依赖和无损连接的分解</h3>
<ul>
<li><span class="math inline">\(R(ABC;A\to C, B\to C)\)</span></li>
<li>按保持无损连接分解，码为 <span class="math inline">\(AB\)</span>
<ul>
<li>分解为 <span class="math inline">\(\{AC;A\to
C\},\{AB\}\)</span></li>
<li>丢失了函数依赖 <span class="math inline">\(B\to C\)</span></li>
</ul></li>
<li>按保持函数依赖分解
<ul>
<li>进行分组 <span class="math inline">\(\{AC;A\to C\},\{BC;B\to
C\}\)</span></li>
<li>分解是有损的</li>
</ul></li>
</ul>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520155032495.png" style="zoom:50%;"></p>
<ul>
<li>如何在保持函数依赖的同时，进行无损分解？
<ul>
<li>从重构的表中删除不在原来表里的行</li>
<li>怎么删除？和原来的表的码做一次连接</li>
</ul></li>
<li>上述分解为 <span class="math inline">\(\{AC;A\to C\},\{BC;B\to
C\},\{AB\}\)</span></li>
</ul>
<h4 id="分解算法">分解算法</h4>
<ul>
<li>设 <span class="math inline">\(\rho=\{R_1(U_1,F_1),\cdots,R_k(U_k,F_k)\}\)</span>
是 <span class="math inline">\(R(U,F)\)</span> 的一个保持函数依赖的 3NF
分解</li>
<li>设 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(R(U,F)\)</span> 的码，若有某个 <span class="math inline">\(U_i,X\subseteq U_i\)</span> 则 <span class="math inline">\(\rho\)</span> 即为所求</li>
<li>否则结果为 <span class="math inline">\(\rho\cup
\{R^\ast(X,F_X)\}\)</span></li>
</ul>
<h2 id="其他">其他</h2>
<h3 id="其他分解方式">其他分解方式</h3>
<ul>
<li>先将所有的关系模式打散，然后合并
<ul>
<li><span class="math inline">\(R_1(AB;\{A\to B\})\)</span></li>
<li><span class="math inline">\(R_2(AC;\{A\to C\})\)</span></li>
<li><span class="math inline">\(R_3(AD; \{A\to D\})\)</span></li>
<li>合并为 <span class="math inline">\(R(ABCD;A\to B,A\to C;A\to
D)\)</span></li>
</ul></li>
</ul>
<h3 id="悬挂元组">悬挂元组</h3>
<ul>
<li><strong>泛关系</strong>
<ul>
<li><span class="math inline">\(R\)</span> 分解为 <span class="math inline">\(R_1,\cdots,R_n\)</span> ，则 <span class="math inline">\(r_1\bowtie r_2\bowtie\cdots\bowtie r_n\)</span>
称为泛关系</li>
</ul></li>
<li>在 <span class="math inline">\(r_i\)</span> 中出现，但在 <span class="math inline">\(\prod_{R_i}(r_1\bowtie r_2\bowtie\cdots\bowtie
r_n)\)</span> 中没有出现的元组，称为<strong>悬挂元组</strong></li>
<li>悬挂元组代表了不完整信息</li>
</ul>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520162648780.png" style="zoom:50%;"></p>
<ul>
<li>模式分解允许一些不完整信息在数据库中的记录</li>
</ul>
<h3 id="模式调优">模式调优</h3>
<ul>
<li>规范化为了消除异常，模式调优是追求性能</li>
<li><span class="math inline">\(R(XYZ)\)</span> 还是 <span class="math inline">\(R_1(XY)\)</span> 和 <span class="math inline">\(R_2(XZ)\)</span>
<ul>
<li>一般情况下 <span class="math inline">\(R\)</span> 好于 <span class="math inline">\(R_1\)</span> 和 <span class="math inline">\(R_2\)</span>，在下面情况下后者较好：
<ul>
<li>大多数用户的存取分别在两个集合上
<ul>
<li><span class="math inline">\(Y\)</span> 经常访问，但是 <span class="math inline">\(Z\)</span> 很少访问</li>
</ul></li>
<li>属性 <span class="math inline">\(Y\)</span> 和 <span class="math inline">\(Z\)</span> 的值占用很大空间</li>
</ul></li>
</ul></li>
</ul>
<h3 id="冗余列">冗余列</h3>
<ul>
<li>把一个表里的某一列，复制到另一个表中</li>
<li>反规范化的设计</li>
<li>冗余列的好处：避免表连接</li>
<li>模式1
<ul>
<li>Order1(supplier_ID,part_ID,quantity,supplier_address)</li>
<li>Supplier(supplier_ID,supplier_name,supplier_address)</li>
</ul></li>
<li>模式2
<ul>
<li>Order2(supplier_ID,part_ID,quantity)</li>
<li>Supplier(supplier_ID,supplier_name,supplier_address)</li>
</ul></li>
<li>冗余列可以减少复杂查询中的表连接操作</li>
<li>模式 1 有利于经常查询供应某种零件的供应商地址</li>
<li>模式 2 有利于新订单的插入</li>
</ul>
<h3 id="星形模式">星形模式</h3>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520163507285.png" style="zoom: 67%;"></p>
<ul>
<li>对于每个产品而言，产品分类是有冗余的</li>
</ul>
<h3 id="雪花模式星形模式的规范化">雪花模式：星形模式的规范化</h3>
<ul>
<li>不是好的设计</li>
<li>虽然没有冗余，但是如果需要看某个类别的销售情况，需要通过好几步才能实现，不直观，速度慢</li>
</ul>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520163631550.png" style="zoom:50%;"></p>
<h3 id="冗余与分解">冗余与分解</h3>
<ul>
<li>分解通常使得对复杂查询的回答的效率更差，因为在查询求值期间必须执行额外的连接</li>
<li>分解使得对简单查询的回答更有效，因为这种查询通常涉及相同关系的一小部分属性</li>
<li>分解通常使得简单的更新事务更有效</li>
<li>分解能降低存储空间的要求，因为它一般能消除冗余数据</li>
<li>如果冗余级别低，则分解会增加存储的需求</li>
</ul>
<h3 id="垂直划分">垂直划分</h3>
<ul>
<li>将经常同时访问的属性放在同一个表里</li>
<li>对每个查询，我们统计不同属性之间被同时访问的次数</li>
<li><strong>事务-属性交叉矩阵</strong></li>
</ul>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520164000533.png"></p>
<ul>
<li>统计结果</li>
<li><strong>属性关联矩阵</strong></li>
</ul>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520164045282.png"></p>
<ul>
<li><strong>属性带权关联图</strong></li>
</ul>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520164113081.png" style="zoom:50%;"></p>
<ul>
<li><strong>图分割</strong></li>
</ul>
<p><img src="/2021/05/19/DB/CLJ/05-2/image-20210520164130508.png" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.05.关系规范化(2)</title>
    <url>/2021/05/14/DB/CLJ/05-1/</url>
    <content><![CDATA[<h1 id="关系规范化">关系规范化</h1>
<ul>
<li>如何判断关系模式的范式级别？
<ul>
<li>看看其他属性有无对候选码的不良依赖</li>
</ul></li>
<li>如何求关系模式的候选码？</li>
<li>一般化这个问题
<ul>
<li>给定一组函数依赖，是否能导出另外一些函数依赖，或另外的函数依赖是否成立？</li>
</ul></li>
</ul>
<h2 id="逻辑蕴涵">逻辑蕴涵</h2>
<h3 id="逻辑蕴含定义">逻辑蕴含定义</h3>
<ul>
<li>关系模式 <span class="math inline">\(R(U,F)\)</span> ，<span class="math inline">\(F\)</span> 是其函数依赖集，<span class="math inline">\(X,Y\subseteq U\)</span>，如果从 <span class="math inline">\(F\)</span> 的函数依赖能够推出 <span class="math inline">\(X\to Y\)</span>，则称 <span class="math inline">\(F\)</span> <span style="color:red;font-weight:bold">逻辑蕴涵</span> <span class="math inline">\(X\to Y\)</span> ,记作 <span class="math inline">\(F\vdash X\to Y\)</span></li>
<li>直观上的理解，<span class="math inline">\(X\to Y\)</span> 能通过
<span class="math inline">\(F\)</span> 的函数依赖推导出来</li>
</ul>
<h3 id="闭包">闭包</h3>
<ul>
<li>被 <span class="math inline">\(F\)</span>
所逻辑蕴涵的函数依赖的全体所构成的集合称作 <span class="math inline">\(F\)</span> 的<span style="color:red;font-weight:bold">闭包</span>，记作 <span class="math inline">\(F^+=\left\{X\to Y|F\vdash X\to
Y\right\}\)</span></li>
<li><span id="ex1">一个例子</span></li>
</ul>
<p><span class="math display">\[
R(X,Y),F=\{X\to Y\}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
F^+=&amp;\{\\
&amp;X\to\Phi,X\to X,X\to Y,X\to XY\\
&amp;Y\to\Phi,Y\to Y\\
&amp;XY\to\Phi,XY\to X,XY\to Y,XY\to XY\\
&amp;\}
\end{aligned}
\]</span></p>
<ul>
<li>规模是指数级的</li>
</ul>
<h2 id="armstrong-公理系统">Armstrong 公理系统</h2>
<ul>
<li><strong>自反律（reflexivity）</strong>
<ul>
<li>若 <span class="math inline">\(Y\subseteq X\)</span> ，则 <span class="math inline">\(X\to Y\)</span></li>
</ul></li>
<li><strong>增广律（augmentation）</strong>
<ul>
<li>若 <span class="math inline">\(X\to Y\)</span>，则 <span class="math inline">\(XZ\to YZ\)</span></li>
</ul></li>
<li><strong>传递律（transitivity）</strong>
<ul>
<li>若 <span class="math inline">\(X\to Y,Y\to Z\)</span> 则 <span class="math inline">\(X\to Z\)</span></li>
</ul></li>
</ul>
<h3 id="应用">应用</h3>
<ul>
<li>上面的<a href="#ex1">例子</a></li>
<li><span class="math inline">\(X\to XY\)</span>：增广律
<ul>
<li><span class="math inline">\(X\to Y\Rightarrow XX\to
XY\Leftrightarrow X\to XY\)</span></li>
</ul></li>
</ul>
<h3 id="正确性及完备性">正确性及完备性</h3>
<ul>
<li><span class="math inline">\(A=\{\;f\;|\;用\;\mathrm{Armstrong}\;公理从\;F\;中导出的函数依赖\;f\;\}\)</span></li>
<li><span class="math inline">\(B=\{\;f\;|\;被\;F\;所逻辑蕴涵的函数依赖\;f\;\}\)</span></li>
<li><strong>完备性</strong>
<ul>
<li><span class="math inline">\(B\subseteq A\)</span></li>
<li><span class="math inline">\(F\)</span> 所蕴涵的函数依赖都能用
Armstrong 公理从 <span class="math inline">\(F\)</span> 中导出</li>
</ul></li>
<li><strong>正确性</strong>
<ul>
<li><span class="math inline">\(A\subseteq B\)</span></li>
<li>用 Armstrong 公理从 <span class="math inline">\(F\)</span>
中导出的函数依赖必为 <span class="math inline">\(F\)</span> 所蕴涵</li>
</ul></li>
</ul>
<h3 id="armstrong-公理正确性证明">Armstrong 公理正确性证明</h3>
<h4 id="自反律">自反律</h4>
<ul>
<li>设 <span class="math inline">\(r\)</span> 是 <span class="math inline">\(R&lt;U, F&gt;\)</span>上的任一关系，<span class="math inline">\(t,s\in r\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;t[X]=s[X],Y\subseteq X\\
\Rightarrow\;&amp;t[Y]=s[Y]\\
\Rightarrow\;&amp;X\to Y\\
\end{aligned}
\]</span></p>
<ul>
<li>函数依赖 <span class="math inline">\(X\to Y\)</span> 的定义
<ul>
<li><span class="math inline">\(t[X]=s[X]\Rightarrow
t[Y]=s[Y]\)</span></li>
</ul></li>
</ul>
<h4 id="增广律">增广律</h4>
<p><span class="math display">\[
\begin{aligned}
&amp;t[XZ]=s[XZ],X\to Y\\
&amp;\\
&amp;t[XZ]=s[XZ],X\to Y\\
\Rightarrow\;&amp;t[X]=s[X]\\
\Rightarrow\;&amp;t[Y]=s[Y]\\
&amp;\\
&amp;t[XZ]=s[XZ]\\
\Rightarrow\;&amp;t[Z]=s[Z]\\
&amp;\\
&amp;t[Z]=s[Z],t[Y]=s[Y]\\
\Rightarrow\;&amp;t[YZ]=s[YZ]\\
\Rightarrow\;&amp;XZ\to YZ\\
\end{aligned}
\]</span></p>
<h4 id="传递律">传递律</h4>
<p><span class="math display">\[
\begin{aligned}
&amp;t[X]=s[X],X\to Y,Y\to Z\\
&amp;\\
&amp;t[X]=s[X],X\to Y\\
\Rightarrow\;&amp;t[Y]=s[Y]\\
&amp;\\
&amp;t[Y]=s[Y],Y\to Z\\
\Rightarrow\;&amp;t[Z]=s[Z]\\
\Rightarrow\;&amp;X\to Z\\
\end{aligned}
\]</span></p>
<h3 id="导出的其他定理">导出的其他定理</h3>
<ul>
<li>合并律（union rule）
<ul>
<li>若 <span class="math inline">\(X\to Y,X\to Z\)</span> ,则 <span class="math inline">\(X\to YZ\)</span></li>
</ul></li>
<li>分解律（decomposition rule）
<ul>
<li>若 <span class="math inline">\(X\to YZ\)</span> ,则 <span class="math inline">\(X\to Y,X\to Z\)</span></li>
</ul></li>
<li>伪传递律（pseudotransitivity rule）
<ul>
<li>若 <span class="math inline">\(X\to Y,WY\to Z\)</span> 则 <span class="math inline">\(WX\to Z\)</span></li>
</ul></li>
</ul>
<h4 id="合并律">合并律</h4>
<p><span class="math display">\[
\begin{aligned}
&amp;X\to Y,Y\to Z\\
&amp;\\
&amp;X\to Y\\
\Rightarrow\;&amp;X\to XY\\
&amp;\\
&amp;X\to Z\\
\Rightarrow\;&amp;XY\to YZ\\
&amp;\\
&amp;X\to XY,XY\to YZ\\
\Rightarrow\;&amp;X\to YZ\\
\end{aligned}
\]</span></p>
<h4 id="分解律">分解律</h4>
<p><span class="math display">\[
\begin{aligned}
&amp;X\to YZ\\
&amp;\\
&amp;Z\subseteq YZ\\
\Rightarrow\;&amp;YZ\to Z\\
&amp;\\
&amp;X\to YZ,YZ\to Z\\
\Rightarrow\;&amp;X\to Z\\
&amp;\\
&amp;同理,X\to Y\\
\end{aligned}
\]</span></p>
<h4 id="伪传递律">伪传递律</h4>
<p><span class="math display">\[
\begin{aligned}
&amp;X\to Y,WY\to Z\\
&amp;\\
&amp;X\to Y\\
\Rightarrow\;&amp;XW\to WY\\
&amp;\\
&amp;XW\to WY,WY\to Z\\
\Rightarrow\;&amp;XW\to Z\\
\end{aligned}
\]</span></p>
<h3 id="公理应用示例">公理应用示例</h3>
<ul>
<li>已知
<ul>
<li><span class="math inline">\(R&lt; U, F &gt;\)</span></li>
<li><span class="math inline">\(U = (A, B, C, G, H, I)\)</span></li>
<li><span class="math inline">\(F = \{A\to B, A\to C, CG\to H, CG\to I,
B→H\}\)</span></li>
</ul></li>
<li>问如下函数依赖是否成立
<ul>
<li><span class="math inline">\(A\to H\)</span> <span style="color:red;font-weight:bold">成立</span></li>
<li><span class="math inline">\(CG\to HI\)</span> <span style="color:red;font-weight:bold">成立</span></li>
<li><span class="math inline">\(AG\to I\)</span> <span style="color:red;font-weight:bold">成立</span></li>
</ul></li>
</ul>
<h3 id="属性集的闭包">属性集的闭包</h3>
<ul>
<li>将之前的一个<strong>证明</strong>的问题转化为<strong>计算</strong>的一个问题</li>
</ul>
<h4 id="定义">定义</h4>
<ul>
<li>设 <span class="math inline">\(F\)</span> 为属性集 <span class="math inline">\(U\)</span> 上的一组函数依赖，<span class="math inline">\(X\subseteq U\)</span></li>
<li><span class="math inline">\(X_F^+=\{A|X\to
A\;能由\;F\;根据\;\mathrm{Armstrong}\;公理导出\}\)</span></li>
<li>称 <span class="math inline">\(X_F^+\)</span> 为属性集 <span class="math inline">\(X\)</span> 关于函数依赖集 <span class="math inline">\(F\)</span> 的闭包</li>
</ul>
<h4 id="例子">例子</h4>
<ul>
<li><span class="math inline">\(U=\{A,B,C\}\)</span></li>
<li><span class="math inline">\(F=\{A\to B,B\to C\}\)</span></li>
<li>则属性集的闭包如下
<ul>
<li><span class="math inline">\(A_F^+=ABC\)</span></li>
<li><span class="math inline">\(B_F^+=BC\)</span></li>
<li><span class="math inline">\(C_F^+=C\)</span></li>
</ul></li>
</ul>
<h3 id="求解属性集闭包的通用算法">求解属性集闭包的通用算法</h3>
<ul>
<li>输入：<span class="math inline">\(X, F\)</span></li>
<li>输出：<span class="math inline">\(X_F^+\)</span></li>
<li>初始化为本身：<span class="math inline">\(X_F^+:=X\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\mathrm{while}\;(X_F^+发生变化)\;\mathrm{do}\\
&amp;\quad \mathrm{for\;each}\;函数依赖\;A\to
B\;\mathrm{in}\;\mathrm{do}\\
&amp;\qquad \mathrm{begin}\\
&amp;\qquad \quad \mathrm{if}\;A\subseteq
X_F^+\;\mathrm{then}\;X_F^+:=X_F^+\cup B\\
&amp;\qquad \mathrm{end}\\
\end{aligned}
\]</span></p>
<h4 id="算法正确性">算法正确性</h4>
<p><span class="math display">\[
\begin{aligned}
&amp;A\subseteq X_F^+\Rightarrow X\to A\\
&amp;X\to A,A\to B\Rightarrow X\to B\\
\end{aligned}
\]</span></p>
<h4 id="算法会终止">算法会终止</h4>
<ul>
<li>最多 <span class="math inline">\(|U-X|\)</span> 步</li>
</ul>
<h4 id="算法示例">算法示例</h4>
<ul>
<li><span class="math inline">\(U = (A, B, C, G, H, I)\)</span></li>
<li><span class="math inline">\(F = \{A\to B, A\to C, CG\to H, CG\to I,
B\to H\}\)</span></li>
<li>计算 <span class="math inline">\((AG)_F^+\)</span></li>
<li>算法流程
<ul>
<li><span class="math inline">\((AG)_F^+=AG\)</span></li>
<li><span class="math inline">\((AG)_F^+=ABCGHI\)</span></li>
</ul></li>
<li>算法效率并不是很高
<ul>
<li><strong>提高效率可以将函数依赖进行排列</strong></li>
</ul></li>
</ul>
<h3 id="闭包的封闭性">闭包的封闭性</h3>
<ul>
<li><span class="math inline">\((X^+)^+=X^+\)</span></li>
</ul>
<h4 id="证明">证明</h4>
<ul>
<li>证明他们互相包含</li>
<li><span class="math inline">\((X^+)^+\supseteq X^+\)</span> 显然</li>
<li><span class="math inline">\((X^+)^+\subseteq X^+\)</span>
<ul>
<li><span class="math inline">\(\forall A\in(X^+)^+\Rightarrow X^+\to
A\)</span></li>
<li><span class="math inline">\(X^+\to A,X\to X^+\Rightarrow X\to
A\Rightarrow A\in X^+\)</span></li>
<li>由任意性，<span class="math inline">\((X^+)^+\subseteq
X^+\)</span></li>
</ul></li>
</ul>
<h4 id="封闭的">封闭的</h4>
<ul>
<li>如果 <span class="math inline">\(X^+=X\)</span>，则称 <span class="math inline">\(X\)</span> 是<strong>封闭</strong>的</li>
</ul>
<h4 id="例题">例题</h4>
<ul>
<li><span class="math inline">\(R(ABCD)\)</span> 的封闭属性集只有 <span class="math inline">\(\Phi\)</span> 和 <span class="math inline">\(\{ABCD\}\)</span>，求 <span class="math inline">\(R\)</span> 的函数依赖集
<ul>
<li>每一个码都是候选码</li>
<li><span class="math inline">\(A\to B,B\to C,C\to D, D\to
A\)</span></li>
</ul></li>
<li><span class="math inline">\(R(ABCD)\)</span> 的封闭属性集只有 <span class="math inline">\(\Phi,\{AB\},\{ABCD\}\)</span>，求 <span class="math inline">\(R\)</span> 的函数依赖集
<ul>
<li><span class="math inline">\(A\to B,B\to A,C\to D,D\to C,C\to
A\)</span></li>
</ul></li>
</ul>
<h3 id="闭包与函数依赖证明之间的关系">闭包与函数依赖证明之间的关系</h3>
<ul>
<li>有没有一般性的算法判定 <span class="math inline">\(X\to Y\)</span>
是否能由 <span class="math inline">\(F\)</span> 根据 Armstrong
公理导出？</li>
<li>如果计算出 <span class="math inline">\(F^+\)</span>，再判断 <span class="math inline">\(X\to Y\)</span> 是否属于 <span class="math inline">\(F^+\)</span>，则由于 <span class="math inline">\(F^+\)</span> 的计算非常复杂，实际上是不可行的</li>
<li>通过属性集的闭包计算
<ul>
<li><span class="math inline">\(X\to Y\)</span> 能由 Armstrong 公理导出
<span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(Y\subseteq X_F^+\)</span></li>
</ul></li>
<li><strong>从几何证明到代数计算</strong></li>
</ul>
<h3 id="armstrong-公理完备性证明">Armstrong 公理完备性证明</h3>
<ul>
<li><strong>反证法</strong></li>
<li>假定存在函数依赖 <span class="math inline">\(X\to Y\)</span> 被
<span class="math inline">\(F\)</span> 逻辑蕴涵，但 <span class="math inline">\(X\to Y\)</span> 不能用 Armstrong 公理从 <span class="math inline">\(F\)</span> 中导出，则存在 <span class="math inline">\(Y\)</span> 的子集不属于 <span class="math inline">\(X\)</span> 的闭包，也即：<span class="math inline">\(Y\not\subseteq
X_F^+,Y-X^+_F\ne\Phi,U-X_F^+\ne\Phi\)</span></li>
<li>构造 <span class="math inline">\(R(U)\)</span> 上的关系 <span class="math inline">\(r\)</span> 如下：</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(r\)</span></th>
<th style="text-align: center;"><span class="math inline">\(X_F^+\)</span></th>
<th style="text-align: center;"><span class="math inline">\(U-X_F^+\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(t\)</span></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(s\)</span></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<ul>
<li>下面证明，由于 (1)(2) 本身是矛盾的，推出假设不成立
<ul>
<li><ol type="1">
<li><span class="math inline">\(r\)</span> 满足 <span class="math inline">\(F\)</span></li>
</ol></li>
<li><ol start="2" type="1">
<li><span class="math inline">\(r\)</span> 不满足 <span class="math inline">\(X\to Y\)</span></li>
</ol></li>
</ul></li>
<li><span class="math inline">\(r\)</span> 满足 <span class="math inline">\(F\)</span>
<ul>
<li>设 <span class="math inline">\(W\to V\)</span> 是 <span class="math inline">\(F\)</span> 的任意一个函数依赖，由下述推导得到
<span class="math inline">\(r\)</span> 满足 <span class="math inline">\(W\to V\)</span>（<span class="math inline">\(t[W]=s[W]\Rightarrow t[V]=s[V]\)</span>）</li>
<li>即 <span class="math inline">\(r\)</span> 是 <span class="math inline">\(R(U,F)\)</span> 上的关系</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
t[W]=s[W]&amp;\Rightarrow W\subseteq X_F^+(构造决定,看关系\;r)\\
&amp;\Rightarrow X\to W\\
X\to W,W\to V&amp;\Rightarrow X\to V\\
&amp;\Rightarrow V\subseteq X_F^+\\
&amp;\Rightarrow t[V]=s[V]\\
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\(r\)</span> 不满足 <span class="math inline">\(X\to Y\)</span>
<ul>
<li><span class="math inline">\(Y-X^+_F\ne\Phi\)</span></li>
<li>故 <span class="math inline">\(Y\)</span> 中存在一个属性 <span class="math inline">\(A\notin X_F^+\)</span></li>
<li>在 <span class="math inline">\(r\)</span> 中有 <span class="math inline">\(t[X]=s[X]\)</span> ，而 <span class="math inline">\(t[A]≠s[A]\)</span></li>
<li>所以 <span class="math inline">\(t[Y]\ne s[Y]\)</span>，即 <span class="math inline">\(X\to Y\)</span> 不成立</li>
</ul></li>
</ul>
<h2 id="候选码的计算">候选码的计算</h2>
<ul>
<li>NP 的</li>
<li>我们期望通过一些约束条件，限制搜索范围</li>
</ul>
<h3 id="属性集的派性">属性集的派性</h3>
<ul>
<li><strong>左部属性</strong>，<strong>只</strong>出现在 <span class="math inline">\(F\)</span> 左边的属性</li>
<li><strong>右部属性</strong>，<strong>只</strong>出现在 <span class="math inline">\(F\)</span> 右边的属性</li>
<li><strong>双部属性</strong>，出现在 <span class="math inline">\(F\)</span> 两边的属性</li>
<li><strong>外部属性</strong>，不出现在 <span class="math inline">\(F\)</span> 中的属性</li>
</ul>
<h4 id="不同派性的性质">不同派性的性质</h4>
<ul>
<li><strong>左部属性</strong>一定<strong>出现</strong>在任何候选码中</li>
<li><strong>右部属性</strong>一定<strong>不出现</strong>在任何候选码中</li>
<li><strong>外部属性</strong>一定<strong>出现</strong>在任何候选码中</li>
</ul>
<h4 id="做题的-trick">做题的 trick</h4>
<ul>
<li>出现在左边的属性加上划线，出现在右边的属性加下划线</li>
</ul>
<h3 id="候选码的计算-1">候选码的计算</h3>
<ul>
<li>先求出左部属性和外部属性，再求属性集闭包</li>
<li>如果闭包已经是属性集全集，说明左部属性已经是候选码（<strong>唯一的候选码</strong>）</li>
<li>否则则需要和双部属性组合</li>
</ul>
<h4 id="例子1">例子1</h4>
<ul>
<li><span class="math inline">\(U=\{C,T,H,R,S\}\)</span></li>
<li><span class="math inline">\(F=\{C\to T,HR\to C,HT\to R,HS\to
R\}\)</span></li>
<li>左部属性+外部属性：<span class="math inline">\(HS\)</span></li>
<li><span class="math inline">\((HS)_F^+=HSRCT\)</span></li>
<li>候选码唯一：<span class="math inline">\(HS\)</span></li>
<li>主属性 <span class="math inline">\(HS\)</span>，非主属性 <span class="math inline">\(CTR\)</span></li>
<li>是 <span class="math inline">\(2NF\)</span>：没有部分依赖（求出
<span class="math inline">\(H_F^+,S_F^+\)</span>）</li>
<li>不是 <span class="math inline">\(3NF\)</span>：<span class="math inline">\(HS\to C,C\to T\)</span></li>
</ul>
<h4 id="例子2">例子2</h4>
<ul>
<li><span class="math inline">\(U = \{A，B，C，D，E\}\)</span></li>
<li><span class="math inline">\(F = \{AE\to C,AC\to D,CD\to B,D\to
E\}\)</span></li>
<li>左部属性+外部属性：<span class="math inline">\(A\)</span></li>
<li>双部属性：<span class="math inline">\(C,E,D\)</span></li>
<li><span class="math inline">\(A_F^+=A\)</span> 不是候选码</li>
<li>和双部属性组合
<ul>
<li><span class="math inline">\((AC)_F^+=ACDBE\)</span> 是候选码</li>
<li><span class="math inline">\((AD)_F^+=ADECB\)</span> 是候选码</li>
<li><span class="math inline">\((AE)_F^+=AECDB\)</span> 是候选码</li>
</ul></li>
<li>主属性 <span class="math inline">\(ACDE\)</span>，非主属性 <span class="math inline">\(B\)</span></li>
<li>是 <span class="math inline">\(2NF\)</span></li>
<li>不是 <span class="math inline">\(3NF\)</span>
<ul>
<li><span class="math inline">\(AC\to CD, CD\to B\)</span></li>
</ul></li>
</ul>
<h3 id="求一个候选码的一般算法">求<span style="color:red;font-weight:bold">一个</span>候选码的一般算法</h3>
<ul>
<li>输入：关系模式 <span class="math inline">\(&lt;U,
F&gt;\)</span></li>
<li>输出：一个候选码 <span class="math inline">\(K\)</span></li>
<li>思路：每次删除一个属性，看它的闭包是否还是整个属性集</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\mathrm{Key-Finding}(U, F)\\
&amp;\mathrm{Begin}\\
&amp;\quad(1)\;K:= U\\
&amp;\quad(2)\;构造一个\;FD: K\to T,其中\;T\notin U\\
&amp;\quad(3)\;\mathrm{for}\;每一个属性\;A\in K\;\mathrm{do}\\
&amp;\quad\qquad\mathrm{if\;Membership}(F\cup\{K\to T\},(K-A)\to T)\\
&amp;\quad\qquad\mathrm{then}\;K:= K-A\\
&amp;\quad\mathrm{return}(K)\\
&amp;\mathrm{end}\\
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\(\mathrm{Membership}(F, X\to
Y)\)</span>： 判断 <span class="math inline">\(X\to Y \in
F^+\)</span></li>
<li>上面算法为什么要这么构造？
<ul>
<li><span class="math inline">\(K-A\)</span> 是候选码 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\((K-A)_F^+=U\)</span> <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\((K-A)\to K \in F^+\)</span></li>
</ul></li>
</ul>
<h3 id="求全部候选码的算法替换法">求全部候选码的算法：替换法</h3>
<ul>
<li>输入：关系模式 <span class="math inline">\(R&lt;U，F&gt;\)</span></li>
<li>输出：<span class="math inline">\(R&lt;U，F&gt;\)</span>
的全部候选码 <span class="math inline">\(W\)</span></li>
<li>思路
<ul>
<li>先找到一个候选码，这个候选码包括左部属性和双部属性（不考虑外部属性，考虑的话将其当作左部属性即可）</li>
<li>用其他的双部属性替代候选码中得到双部属性</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\mathrm{begin}\\
&amp;(1)\;K:=\mathrm{Key-Finding}(U,F)\\
&amp;(2)\;K\;入队列\;Q\\
&amp;(3)\;\mathrm{while}\;队列\;Q\ne\Phi\;\mathrm{do}\\
&amp;\qquad\quad K:=队列\;Q\;的头\\
&amp;\qquad\quad W:=W\cup\{K\}\\
&amp;\qquad\quad D:=K\;中全部双部属性\\
&amp;\qquad\quad\mathrm{while}\;D\ne\Phi\;\mathrm{do}\\
&amp;\qquad\qquad A:=D\;中一个双部属性\\
&amp;\qquad\qquad D:=D-\{A\}\\
&amp;\qquad\qquad\mathrm{for}\;每一个\;X\to Y\in F\;\mathrm{do}\\
&amp;\qquad\qquad\quad \mathrm{if}\;A\in
Y\;\mathrm{then}\;K’:=(K-A)\cup\{X\}\\
&amp;\qquad\qquad\quad\mathrm{if}\;K’\notin
Q\;\mathrm{then}\;K’\;入队列\;Q\\
&amp;\mathrm{end}\\
\end{aligned}
\]</span></p>
<h3 id="求全部候选码的算法示例">求全部候选码的算法示例</h3>
<ul>
<li><span class="math inline">\(U=\{A, B, C, D, E, G\}\)</span></li>
<li><span class="math inline">\(F=\{AB\to C, C\to A, C\to B, AD\to B,
BE\to G, G\to A\}\)</span></li>
<li>所有候选码 = <span class="math inline">\(\{EDC, EDA, EDG,
EDB\}\)</span></li>
</ul>
<h2 id="函数依赖集的等价性">函数依赖集的等价性</h2>
<ul>
<li>目的：利用等价性找到一个简化的函数依赖集</li>
<li>函数依赖越少，检查起来越简单</li>
</ul>
<h3 id="等价性的定义闭包相同">等价性的定义(闭包相同)</h3>
<ul>
<li>对于函数依赖集 <span class="math inline">\(F,G\)</span> ,若 <span class="math inline">\(F^+=G^+\)</span>，则称 <span class="math inline">\(F\)</span> 与 <span class="math inline">\(G\)</span> 等价</li>
</ul>
<h3 id="如何判定两个函数依赖集等价">如何判定两个函数依赖集等价</h3>
<ul>
<li><span class="math inline">\(F^+=G^+\Leftrightarrow F\subseteq
G^+,G\subseteq F^+\)</span></li>
<li>证明起来还是挺复杂的</li>
</ul>
<h3 id="函数依赖集的最小覆盖">函数依赖集的最小覆盖</h3>
<ul>
<li>函数依赖集 <span class="math inline">\(F\)</span> 的最小覆盖 <span class="math inline">\(F_{min}\)</span></li>
<li><strong>单属性化</strong>：对于 <span class="math inline">\(F\)</span> 中任一函数依赖 <span class="math inline">\(X\to A\)</span>, <span class="math inline">\(A\)</span> 必是单属性</li>
<li><strong>无冗余化</strong>：<span class="math inline">\(F\)</span>
中不存在这样的函数依赖 <span class="math inline">\(X\to A\)</span>，使得
<span class="math inline">\(F\)</span> 与 <span class="math inline">\(F−\{X\to A\}\)</span> 等价</li>
<li><strong>既约化</strong>：<span class="math inline">\(F\)</span>
中不存在这样的函数依赖 <span class="math inline">\(X\to A\)</span>, 在
<span class="math inline">\(X\)</span> 中有真子集 <span class="math inline">\(Z\)</span>, 使得 <span class="math inline">\(F\)</span> 与 <span class="math inline">\((F−\{X\to A\})\cup\{Z\to A\}\)</span> 等价
<ul>
<li>消除冗余属性</li>
</ul></li>
</ul>
<h3 id="求解函数依赖集的最小覆盖">求解函数依赖集的最小覆盖</h3>
<h4 id="单属性化">单属性化</h4>
<ul>
<li>逐个检查 <span class="math inline">\(F\)</span> 中各函数依赖 <span class="math inline">\(F_i:X\to Y\)</span></li>
<li>若 <span class="math inline">\(Y=A_1A_2\cdots
A_k,k\ge2\)</span>，则用诸 <span class="math inline">\(X\to A_i\)</span>
代替 <span class="math inline">\(Y\)</span></li>
</ul>
<h4 id="无冗余化">无冗余化</h4>
<ul>
<li>逐个检查 <span class="math inline">\(F\)</span> 中各函数依赖 <span class="math inline">\(X\to A\)</span></li>
<li>令 <span class="math inline">\(G=F-\{X\to A\}\)</span>，若 <span class="math inline">\(A\in X_G^+\)</span>，则从 <span class="math inline">\(F\)</span> 中去掉该函数依赖</li>
</ul>
<h4 id="既约化">既约化</h4>
<ul>
<li>逐个检查 <span class="math inline">\(F\)</span> 中各函数依赖 <span class="math inline">\(X\to A\)</span></li>
<li>设 <span class="math inline">\(X=B_1\cdots B_m\)</span>，逐个考查
<span class="math inline">\(B_i\)</span></li>
<li>若 <span class="math inline">\(A\in(X-B_i)_F^+\)</span>，则以 <span class="math inline">\(X−B_i\)</span> 取代 <span class="math inline">\(X\)</span></li>
</ul>
<h3 id="求最小覆盖例子">求最小覆盖例子</h3>
<h4 id="无冗余化-1">无冗余化</h4>
<ul>
<li><span class="math inline">\(F=\{A\to B,B\to A,A\to C,B\to
C\}\)</span>，求 <span class="math inline">\(F_{min}\)</span></li>
<li><span class="math inline">\(F_{min}=\{A\to B,B\to A,A\to
C\}\)</span></li>
<li><span class="math inline">\(F_{min}=\{A\to B,B\to A,B\to
C\}\)</span></li>
</ul>
<h4 id="既约化-1">既约化</h4>
<ul>
<li><span class="math inline">\(F=\{C\to A,A\to G ,CG\to B,B\to
A\}\)</span>，求 <span class="math inline">\(F_{min}\)</span></li>
<li><span class="math inline">\(F\)</span> 是无冗余的</li>
<li><span class="math inline">\(F_{min}=\{C\to A,A\to G ,C\to B,B\to
A\}\)</span>
<ul>
<li>还得进一步无冗余化</li>
<li><span class="math inline">\(F_{min}=\{A\to G ,C\to B,B\to
A\}\)</span></li>
</ul></li>
</ul>
<h4 id="顺序">顺序</h4>
<ul>
<li>先既约化，再无冗余化</li>
</ul>
<h2 id="函数依赖和多值依赖的推理规则">函数依赖和多值依赖的推理规则</h2>
<p><img src="/2021/05/14/DB/CLJ/05-1/image-20210514222913294.png" style="zoom:50%;"></p>
<h3 id="联合律的证明">联合律的证明</h3>
<p><img src="/2021/05/14/DB/CLJ/05-1/image-20210514223139159.png" style="zoom:50%;"></p>
<ul>
<li>填表的方式证明</li>
</ul>
<p><img src="/2021/05/14/DB/CLJ/05-1/image-20210514224014953.png" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.06.事务(2) 事务隔离性</title>
    <url>/2021/05/22/DB/CLJ/06-1/</url>
    <content><![CDATA[<h1 id="事务">事务</h1>
<h2 id="事务隔离性级别">事务隔离性级别</h2>
<h3 id="sql-中隔离性级别的定义">SQL 中隔离性级别的定义</h3>
<ul>
<li>（事务隔离性级别从低到高）</li>
<li>read uncommitted
<ul>
<li>允许读取未提交的记录</li>
</ul></li>
<li>read uncommitted
<ul>
<li>只允许读取已提交的记录，但不要求可重复读</li>
</ul></li>
<li>repeatable read
<ul>
<li>只允许读取已提交的记录，并且一个事务对同一记录的两次读取之间，其它事务不能对该记录进行更新</li>
</ul></li>
<li>serializable
<ul>
<li>调度的执行必须等价于串行调度</li>
</ul></li>
</ul>
<h3 id="隔离性级别的内部实现">隔离性级别的内部实现</h3>
<ul>
<li>在数据库内部，如果一个事务要对某个记录项进行读或写操作，要先获得这个数据项上的读锁或者写锁，这由<strong>锁管理器</strong>统一控制
<ul>
<li>读 S 锁，写 X 锁</li>
<li>二者不兼容，只能有一个锁</li>
</ul></li>
<li>写事务 W，读事务 R，锁管理器 L
<ul>
<li>以下是不同隔离性级别的内部实现</li>
</ul></li>
</ul>
<h4 id="read-uncommitted">read uncommitted</h4>
<ul>
<li>W：申请 X 锁</li>
<li>L：同意（X 锁被加上）</li>
<li>R：读取数据项（不需要申请 S 锁）</li>
</ul>
<h4 id="read-committed">read committed</h4>
<ul>
<li>W：申请 X 锁</li>
<li>L：同意（X 锁被加上）</li>
<li>R：申请 S 锁（阻塞），等待</li>
<li>W：提交（释放 X 锁）</li>
<li>L：同意 R 读（S 锁被加上）</li>
<li>R：读取数据项</li>
</ul>
<h5 id="read-commited-不能实现-repeatable-read">read commited 不能实现
repeatable read</h5>
<ul>
<li>R：申请 S 锁</li>
<li>L：同意（S 锁被加上）</li>
<li>R：读取数据项（读完立刻释放 S 锁）</li>
<li>W：申请 X 锁</li>
<li>L：同意（X 锁被加上）</li>
<li>W：提交（X 锁被释放）</li>
<li>R：读取数据项，（<strong>读取到的数据与之前不一致</strong>）</li>
</ul>
<h5 id="原因">原因</h5>
<ul>
<li><span style="color:red;font-weight:bold">read committed
的读锁是短锁</span>
<ul>
<li>短锁：操作一执行完，锁立即释放</li>
<li>长锁：长锁会一直到保持到事务结束，提交之后才释放</li>
</ul></li>
<li><strong>只有读事务有短锁和长锁的区别，写事务都是长锁</strong></li>
</ul>
<h4 id="repeatable-read">repeatable read</h4>
<ul>
<li>R：申请 S 锁</li>
<li>L：同意（S 锁被加上）</li>
<li>R：读取数据项（S 锁是长锁）</li>
<li>W：申请 X 锁（阻塞）等待</li>
<li>R：读取数据项（<strong>读取到的数据与之前一致</strong>）</li>
<li>R：提交（S 锁被释放）</li>
<li>L：同意（X 锁被加上）</li>
<li>W：提交（X 锁被释放）</li>
</ul>
<h3 id="隔离性级别与不一致现象的关系">隔离性级别与不一致现象的关系</h3>
<table>
<colgroup>
<col style="width: 11%">
<col style="width: 5%">
<col style="width: 7%">
<col style="width: 37%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">隔离性级别</th>
<th style="text-align: center;">读脏数据</th>
<th style="text-align: center;">不能重复读</th>
<th style="text-align: center;">幻象</th>
<th style="text-align: center;">丢失修改</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Read uncommitted</td>
<td style="text-align: center;">是</td>
<td style="text-align: center;">是</td>
<td style="text-align: center;">是</td>
<td style="text-align: center;">是</td>
</tr>
<tr class="even">
<td style="text-align: center;">Read committed</td>
<td style="text-align: center;">否</td>
<td style="text-align: center;">是</td>
<td style="text-align: center;">是</td>
<td style="text-align: center;"><span style="color:red;font-weight:bold">是</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Repeatable read</td>
<td style="text-align: center;">否</td>
<td style="text-align: center;">否</td>
<td style="text-align: center;"><span style="color:red;font-weight:bold">是</span></td>
<td style="text-align: center;">否</td>
</tr>
<tr class="even">
<td style="text-align: center;">Serializable</td>
<td style="text-align: center;">否</td>
<td style="text-align: center;">否</td>
<td style="text-align: center;">否</td>
<td style="text-align: center;">否</td>
</tr>
</tbody>
</table>
<h3 id="具体场景的演示">具体场景的演示</h3>
<h4 id="read-uncommitted-下发生脏读">read uncommitted 下发生脏读</h4>
<table>
<colgroup>
<col style="width: 42%">
<col style="width: 57%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">事务1</th>
<th style="text-align: center;">事务2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">set transaction isolation level <span style="color:red;font-weight:bold">read uncommitted</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">begin tran<br>select sname from
S<br>where sname = '王红'<br>--只有一个学生名为王红</td>
</tr>
<tr class="odd">
<td style="text-align: center;">begin tran<br>update S<br>set sname=
'王红'</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">select sname from S<br>where sname=
'王红'<br>--所有学生姓名均为王红</td>
</tr>
<tr class="odd">
<td style="text-align: center;">rollback tran</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">select sname from S<br>where
sname='王红'<br>--只有一个学生名为王红</td>
</tr>
</tbody>
</table>
<h4 id="read-committed-下避免脏读">read committed 下避免脏读</h4>
<table>
<colgroup>
<col style="width: 42%">
<col style="width: 57%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">事务1</th>
<th style="text-align: center;">事务2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">set transaction isolation level <span style="color:red;font-weight:bold">read committed</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">begin tran</td>
</tr>
<tr class="odd">
<td style="text-align: center;">begin tran<br>update S<br>set sname=
'王红'</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">select sname from S<br>where
sname='王红'<br>--阻塞，"正在执行批查询"</td>
</tr>
<tr class="odd">
<td style="text-align: center;">commit tran</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">--所有学生姓名均为王红</td>
</tr>
</tbody>
</table>
<h4 id="read-committed-下发生不可重复读">read committed
下发生不可重复读</h4>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">事务1</th>
<th style="text-align: center;">事务2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">set transaction isolation level <span style="color:red;font-weight:bold">read committed</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">begin tran<br>select sname from
S<br>where sname= '王红'<br>--只有一个学生名为王红</td>
</tr>
<tr class="odd">
<td style="text-align: center;">begin tran<br>update S<br>set
sname='王红'<br>commit tran</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">select sname from S<br>where sname=
'王红'<br>--所有学生姓名均为王红</td>
</tr>
</tbody>
</table>
<h4 id="repeatable-read-下避免不可重复读">repeatable read
下避免不可重复读</h4>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">事务1</th>
<th style="text-align: center;">事务2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">set transaction isolation level <span style="color:red;font-weight:bold">repeatable read</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">begin tran<br>select sname from
S<br>where sname= '王红'<br>--有一个学生名为王红</td>
</tr>
<tr class="odd">
<td style="text-align: center;">begin tran<br>update S<br>set
sname='王明'<br>where sname='王红'<br>--<span style="color:red;font-weight:bold">阻塞</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">select sname from S<br>where sname=
'王红'<br>--有一个学生名为王红</td>
</tr>
</tbody>
</table>
<h4 id="repeatable-read-下发生幻象">repeatable read 下发生幻象</h4>
<ul>
<li>对于其他事务的 insert 操作，无法阻塞</li>
</ul>
<table>
<colgroup>
<col style="width: 41%">
<col style="width: 58%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">事务1</th>
<th style="text-align: center;">事务2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">set transaction isolation level <span style="color:red;font-weight:bold">repeatable read</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">begin tran<br>select snamef rom
S<br>where sname= '王%'<br>--只有一个学生，名为王红</td>
</tr>
<tr class="odd">
<td style="text-align: center;">insert into S values('s08', '王明', 23,
1)</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">select sname from S<br>where sname=
'王%'<br>--有两个学生，名为王红和王明</td>
</tr>
</tbody>
</table>
<h4 id="serializable-下避免幻象">serializable 下避免幻象</h4>
<table>
<colgroup>
<col style="width: 46%">
<col style="width: 53%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">事务1</th>
<th style="text-align: center;">事务2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">set transaction isolation level <span style="color:red;font-weight:bold">serializable</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">begin tran<br>select snamef rom
S<br>where sname= '王%'<br>--只有一个学生，名为王红</td>
</tr>
<tr class="odd">
<td style="text-align: center;">insert into S values('s08', '王明', 23,
1)<br>--阻塞</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">select sname from S<br>where sname=
'王%'<br>--只有一个学生，名为王红</td>
</tr>
</tbody>
</table>
<h4 id="read-committed-下的丢失修改">read committed 下的丢失修改</h4>
<ul>
<li>注意读和读不会发生不一致现象，允许多个事务同时申请读锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> chair(</span><br><span class="line">    seat_id <span class="type">int</span>,</span><br><span class="line">    host <span class="type">char</span>(<span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> chair <span class="keyword">values</span> (<span class="number">1</span>,<span class="keyword">null</span>),(<span class="number">2</span>,<span class="keyword">null</span>),(<span class="number">3</span>,<span class="keyword">null</span>),(<span class="number">4</span>,<span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">事务1</th>
<th style="text-align: center;">事务2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">set transaction isolation level <span style="color:red;font-weight:bold">read committed</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">begin tran</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">set transaction isolation level <span style="color:red;font-weight:bold">read committed</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">begin tran</td>
</tr>
<tr class="odd">
<td style="text-align: center;">select seat_id from chair<br>where host
is null</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">select seat_id from chair<br>where host
is null<br>--<span style="color:red;font-weight:bold">read committed
的读锁是短锁，操作完马上释放</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">update chair set host='tom'<br>where
seat_id=1</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">commit</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">update chair set host='jerry' where
seat_id=1<br>update chair set host='bob' where seat_id=2</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">commit</td>
</tr>
</tbody>
</table>
<ul>
<li>将事务 2 的隔离性级别修改为 repeatable read
<ul>
<li>这样事务 1 的 update 操作会被阻塞</li>
<li>但是事务 2 的 update 操作也会被阻塞，引发死锁</li>
<li>数据库中有专门的进程定期做死锁检测，检测到死锁会撤销一个事务，打开死锁</li>
</ul></li>
</ul>
<h3 id="不同隔离性级别下的可能调度">不同隔离性级别下的可能调度</h3>
<ul>
<li>考虑关系 <code>Employee(ID,salary)</code>，有两个元组
<code>(A,20)</code> 和 <code>(B,30)</code></li>
<li>两个事务 T1，T2 如下</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- T1:</span></span><br><span class="line"><span class="keyword">begin</span> transaction;</span><br><span class="line"><span class="keyword">update</span> Employee <span class="keyword">set</span> salary <span class="operator">=</span> <span class="number">2</span><span class="operator">*</span>salary <span class="keyword">where</span> ID<span class="operator">=</span><span class="string">&#x27;A&#x27;</span>;  <span class="comment">-- t11</span></span><br><span class="line"><span class="keyword">update</span> Employee <span class="keyword">set</span> salary <span class="operator">=</span> salary<span class="operator">+</span><span class="number">10</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="string">&#x27;A&#x27;</span>; <span class="comment">-- t12</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- T2:</span></span><br><span class="line"><span class="keyword">begin</span> transaction;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(salary) <span class="keyword">as</span> sal1 <span class="keyword">from</span> Employee;            <span class="comment">-- t21</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(salary) <span class="keyword">as</span> sal2 <span class="keyword">from</span> Employee;            <span class="comment">-- t22</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>给出 T2 在不同隔离性级别下所返回的 sal1 与 sal2
所有可能的值的情况</li>
<li>思路：列出所有调度的可能性，在不同的隔离性级别下判断是否能够成立</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">S1: t11, t12, t21, t22 -&gt; (sal1, sal2) = (80,80)</span><br><span class="line">S2: t11, t21, t12, t22 -&gt; (sal1, sal2) = (70,80)</span><br><span class="line">S3: t11, t21, t22, t12 -&gt; (sal1, sal2) = (70,70)</span><br><span class="line">S4: t21, t22, t11, t12 -&gt; (sal1, sal2) = (50,50)</span><br><span class="line">S5: t21, t11, t22, t12 -&gt; (sal1, sal2) = (50,70)</span><br><span class="line">S6: t21, t11, t12, t22 -&gt; (sal1, sal2) = (50,80)</span><br></pre></td></tr></table></figure>
<ul>
<li>read uncommitted
<ul>
<li>S1,S2,S3,S4,S5,S6</li>
</ul></li>
<li>read committed（读短锁，写长锁）
<ul>
<li>S1,S4,S6</li>
</ul></li>
<li>repeatable read
<ul>
<li>S1,S4</li>
</ul></li>
<li>serializable
<ul>
<li>S1,S4</li>
</ul></li>
</ul>
<h3 id="乐观锁定快照隔离-si">乐观锁定：快照隔离 SI</h3>
<ul>
<li>Snapshot Isolation</li>
<li>上述的隔离性是通过<strong>内部封锁</strong>来实现的（锁管理器）</li>
<li>这样的设计是有代价的，<strong>锁请求</strong></li>
<li>如果在某个应用场景下，只有很多读事务，产生冲突的可能性很小，加锁的方式效率很低
<ul>
<li>不必要加锁</li>
</ul></li>
<li>也就是说写操作比较多的时候，冲突较多的时候，加锁才是一个好的解决方法
<ul>
<li>锁：悲观的态度，假定冲突概率很高</li>
</ul></li>
<li>乐观的态度：假定发生冲突的概率很小</li>
</ul>
<h4 id="快照隔离-si">快照隔离 SI</h4>
<ul>
<li><strong>一旦检测到冲突，把某个事务回滚</strong></li>
<li>通过<strong>多版本</strong>的方式实现的
<ul>
<li>更新事务修改数据项的时候形成一个新的版本</li>
</ul></li>
<li>一些关系
<ul>
<li>读不会阻塞写</li>
<li>写不会阻塞读</li>
<li><strong>写发生在提交时</strong></li>
<li>冲突时先提交者赢</li>
</ul></li>
<li>一个例子：左到右时间顺序
<ul>
<li>T2 先提交，回滚 T4，因此 T3 保留下来了</li>
<li>T5 读取到的结果是一开始的，T5 开始的时候，T3 还没写（提交才写）
<ul>
<li><strong>标准的快照隔离只能读取到事务一开始的版本</strong></li>
</ul></li>
<li>T1 事务无论在什么时候发出读命令，读取到的 X 都是一开始的</li>
<li>T7 读取的是 T6 更新的结果</li>
</ul></li>
</ul>
<p><img src="/2021/05/22/DB/CLJ/06-1/image-20210524150236052.png" style="zoom:67%;"></p>
<h4 id="快照隔离中的不一致现象">快照隔离中的不一致现象</h4>
<ul>
<li>一致性要求：A+B &gt;= 0</li>
<li>当前：A＋B＝5</li>
<li>调度：r1(x), r1(y), r2(x), r2(y), w1(y), w2(x)</li>
<li>T1、T2 分别将 x、y 减去 5，发生了什么？
<ul>
<li>调度可以执行，但是最终的结果是不满足一致性的</li>
</ul></li>
<li>问题原因：<strong>写偏斜</strong>
<ul>
<li>两个事务写不同的数据项</li>
</ul></li>
<li>悲观锁定的情况下，repeatable read 会防止这种情况的发生
<ul>
<li><strong>读长锁</strong>，后面的写操作阻塞</li>
</ul></li>
<li>写偏斜的另外一个例子
<ul>
<li>初始值：x=3, y=5</li>
<li>T1: x := y；T2: y := x</li>
<li>SI 下 r1(x), r1(y), r2(x), r2(y), w1(y), w2(x) 的结果是什么？
<ul>
<li>x=5, y=3</li>
</ul></li>
<li>串行的结果：(3,3) 或者 (5,5)</li>
</ul></li>
</ul>
<h4 id="sql-server-下的快照隔离">SQL Server 下的快照隔离</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database demo</span><br><span class="line">use demo</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> isolation_1 (</span><br><span class="line">    id1 <span class="type">int</span>,</span><br><span class="line">    des <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> isolation_1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;asdf&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="快照隔离si可重复读">快照隔离SI：可重复读</h5>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">连接1</th>
<th style="text-align: center;">连接2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">begin tran<br>update
isolation_1<br>set des ='UPDATED'<br>where id1=1</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">begin tran<br>select * from
isolation_1<br>-- 读到的结果是 asdf（事务起点的状态）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">commit tran</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">select * from isolation_1<br>commit
tran<br>-- 读到的结果是 asdf（事务起点的状态）</td>
</tr>
</tbody>
</table>
<h5 id="快照隔离si回滚">快照隔离SI：回滚</h5>
<ul>
<li>发生冲突的时候，先提交者胜</li>
<li>右边事务会被回滚</li>
</ul>
<table>
<colgroup>
<col style="width: 55%">
<col style="width: 44%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">连接1</th>
<th style="text-align: center;">连接2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">SET TRANSACTION ISOLATION<br>LEVEL
SNAPSHOT</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">begin tran<br>select id1 from
isolation_1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">begin tran<br>update
isolation_1<br>set id1 = id1+10</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">update isolation_1<br>set id1 =
id1+20</td>
</tr>
<tr class="odd">
<td style="text-align: center;">commit tran</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h4 id="sql-server快照隔离-rcsi">SQL Server：快照隔离 RCSI</h4>
<ul>
<li>语句级别的快照隔离</li>
<li>当前语句操作的数据库是当前语句对应的数据库的状态
<ul>
<li>而不是事务开始时的版本</li>
</ul></li>
</ul>
<h5 id="快照隔离-rcsi不可重复读">快照隔离 RCSI：不可重复读</h5>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">连接1</th>
<th style="text-align: center;">连接2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">begin tran<br>update
isolation_1<br>set des ='UPDATED'<br>where id1=1</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">begin tran<br>select * from
isolation_1<br>-- 读到的结果是 asdf（语句开始的状态）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">commit tran</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">select * from isolation_1<br>commit
tran<br>-- 读到的结果是 UPDATED（语句开始的状态）</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.06.事务(3)</title>
    <url>/2021/05/23/DB/CLJ/06-2/</url>
    <content><![CDATA[<h1 id="事务">事务</h1>
<h2 id="事务冲突可串行化">事务冲突可串行化</h2>
<ul>
<li>一个调度是否正确，看它执行的结果是否和某一个串行调度执行的结果相同</li>
<li>核心问题：
<ul>
<li>如何判定一个调度是可串行化的？</li>
<li>如何判定两个调度是等价的？</li>
</ul></li>
<li>微观视角：<strong>交换非冲突指令</strong>
<ul>
<li>如何把一个调度转换为另一个等价调度？</li>
</ul></li>
<li>宏观视角：<strong>从读一致性</strong>
<ul>
<li>如何保证每个事务在两个调度中是相同的？</li>
<li>调度内部逻辑相同，因此对于每个事务，如果输入相同则结果一致</li>
</ul></li>
</ul>
<h3 id="指令顺序对调度结果的影响">指令顺序对调度结果的影响</h3>
<ul>
<li>考虑一个调度 S 中的两条连续指令（仅限于 read 与 write 操作）Ii 与
Ij，分别属于事务 Ti 与 Tj</li>
<li>考虑如下四种情况
<ul>
<li>A：Ii=read(Q), Ij=read(Q)</li>
<li>B：Ii=read(Q), Ij=write(Q)</li>
<li>C：Ii=write(Q), Ij=read(Q)</li>
<li>D：Ii=write(Q), Ij=write(Q)</li>
</ul></li>
<li>只有 A 操作可以交换，也就是说两条指令中存在写指令则不能交换</li>
<li>引出冲突指令的定义</li>
</ul>
<h3 id="调度中的冲突指令">调度中的冲突指令</h3>
<ul>
<li><strong>冲突指令</strong>
<ul>
<li>两条指令是不同事务在<strong>相同数据项</strong>上的操作，并且其中<strong>至少有一个</strong>是
<strong>write</strong> 指令</li>
</ul></li>
<li>非冲突指令（满足一条即可）
<ul>
<li>都是 read 操作</li>
<li>操作不同数据项</li>
</ul></li>
</ul>
<h3 id="冲突等价">冲突等价</h3>
<ul>
<li>如果调度 S 可以经过交换一系列非冲突指令转换成调度 S'，则称调度 S 与
S' 是冲突等价的</li>
</ul>
<h3 id="冲突可串行化的定义">冲突可串行化的定义</h3>
<ul>
<li>当一个调度 S
与一个串行调度冲突等价时，则称该调度是冲突可串行化的</li>
</ul>
<h4 id="非冲突串行化的例子">非冲突串行化的例子</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">T1</th>
<th style="text-align: center;">T2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">read(A)</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">write(A)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">write(A)</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h3 id="冲突可串行化的判定">冲突可串行化的判定</h3>
<ul>
<li><strong>优先图</strong>（precedence graph）</li>
<li>调度 S 的优先图的构造方式
<ul>
<li>它是一个有向图 G=(V，E)，V是顶点集，E是边集</li>
<li>顶点集由所有参与调度的事务组成</li>
<li>边集由满足下述条件之一的边 Ti <span class="math inline">\(\to\)</span> Tj 组成（冲突指令）
<ul>
<li>在 Tj 执行 read(Q) 之前，Ti 执行 write(Q)</li>
<li>在 Tj 执行 write(Q) 之前，Ti 执行 read(Q)</li>
<li>在 Tj 执行 write(Q) 之前，Ti 执行 write(Q)</li>
</ul></li>
</ul></li>
</ul>
<h4 id="优先图构造例子">优先图构造例子</h4>
<p><img src="/2021/05/23/DB/CLJ/06-2/image-20210525144122354.png" style="zoom:50%;"></p>
<ul>
<li>如果优先图中存在边 Ti <span class="math inline">\(\to\)</span>
Tj，则在任何等价于 S 的串行调度 S' 中，Ti 都必须出现在 Tj 之前</li>
<li>如果调度 S 的优先图中有环，则 S 是非冲突可串行化的</li>
<li>如果调度 S 的优先图中无环，则是冲突可串行化的
<ul>
<li>拓扑排序</li>
</ul></li>
</ul>
<h4 id="与冲突可串行化等价的串行顺序">与冲突可串行化等价的串行顺序</h4>
<ul>
<li>串行顺序可由拓扑排序得到，求出与优先图的偏序相一致的线序</li>
<li>优先图</li>
</ul>
<pre class="mermaid">graph LR;
T1-->T2;
T1-->T3;
T2-->T4;
T3-->T4;</pre>
<ul>
<li>等价串行线序</li>
</ul>
<pre class="mermaid">graph LR;
T1-->T2;
T2-->T3;
T3-->T4;</pre>
<pre class="mermaid">graph LR;
T1-->T3;
T3-->T2;
T2-->T4;</pre>
<h3 id="可串行化但非冲突可串行化的调度">可串行化但非冲突可串行化的调度</h3>
<ul>
<li>满足上面冲突可串行化判断的调度一定是可串行化的</li>
<li>不满足判断的调度不一定是不可串行化的</li>
<li>一个例子：转账
<ul>
<li>在实际编写中应当尽量避免如下操作，应该按照相同的数据项的顺序进行处理</li>
<li>容易造成死锁等问题</li>
</ul></li>
</ul>
<p><img src="/2021/05/23/DB/CLJ/06-2/image-20210525145111210.png" alt="image-20210525145414073" style="zoom:50%;"></p>
<ul>
<li>冲突可串行化的要求太苛刻了，引入视图可串行化的判定</li>
</ul>
<h2 id="事务视图可串行化">事务视图可串行化</h2>
<h3 id="从读一致性">从读一致性</h3>
<ul>
<li>如果两个调度从读一致，则是等价的</li>
<li>把两个调度的 read 指令挑出来，看对应的 read
指令读到的数据是否相同</li>
<li>每个 read 指令往前找，离它最近的 write
相同数据项的指令，就是他读出来的值</li>
</ul>
<h4 id="例子-1s1-和-s2-从读一致">例子 1：S1 和 S2 从读一致</h4>
<p><img src="/2021/05/23/DB/CLJ/06-2/image-20210525145951520.png" style="zoom:67%;"></p>
<ul>
<li>S1 中的从读关系
<ul>
<li>r1(A) 和 r1(B) 读取的是数据库中的初值</li>
<li>r2(A) 读取的是 w1(A)，r2(B) 读取 w1(B)</li>
</ul></li>
<li>S2 中的从读关系
<ul>
<li>r1(A) 和 r1(B) 读取的是数据库中的初值</li>
<li>r2(A) 读取的是 w1(A)，r2(B) 读取 w1(B)</li>
</ul></li>
</ul>
<h4 id="例子-2s1-和-s3-从读不一致">例子 2：S1 和 S3 从读不一致</h4>
<p><img src="/2021/05/23/DB/CLJ/06-2/image-20210525150148422.png" style="zoom:67%;"></p>
<ul>
<li>S1 中的从读关系
<ul>
<li>r1(A) 和 r1(B) 读取的是数据库中的初值</li>
<li>r2(A) 读取的是 w1(A)，r2(B) 读取 w1(B)</li>
</ul></li>
<li>S3 中的从读关系
<ul>
<li>r1(A) 和 r1(B) 读取的是数据库中的初值</li>
<li>r2(A) 读取的是数据库中的初值</li>
<li>r2(B) 读取 w1(B)</li>
</ul></li>
</ul>
<h3 id="视图等价的调度">视图等价的调度</h3>
<ul>
<li>考虑关于某个事务集的两个调度 S，S'，若调度 S，S'
满足以下条件，则称它们是视图等价的
<ul>
<li>数据库初值 <span class="math inline">\({\buildrel{S}\over\longrightarrow}\)</span>
ri(Q)，数据库初值 <span class="math inline">\({\buildrel{S&#39;}\over\longrightarrow}\)</span>
ri(Q)</li>
<li>wj(Q) <span class="math inline">\({\buildrel{S}\over\longrightarrow}\)</span>
ri(Q)，wj(Q) <span class="math inline">\({\buildrel{S&#39;}\over\longrightarrow}\)</span>
ri(Q)</li>
<li>wj(Q) <span class="math inline">\({\buildrel{S}\over\longrightarrow}\)</span>
数据库终值，wj(Q) <span class="math inline">\({\buildrel{S&#39;}\over\longrightarrow}\)</span>
数据库终值</li>
</ul></li>
<li>前两条保证从读一致性</li>
<li>最后一条保证两个调度得到最终相同的系统状态</li>
</ul>
<h4 id="视图等价的例子">视图等价的例子</h4>
<p><img src="/2021/05/23/DB/CLJ/06-2/image-20210525150856508.png" style="zoom:50%;"></p>
<h3 id="视图可串行化">视图可串行化</h3>
<ul>
<li>如果某个调度视图等价于一个串行调度，则称该调度是视图可串行化的</li>
<li><strong>冲突可串行化调度一定是视图可串行化的</strong>
<ul>
<li>冲突可串行化的调度一定满足从读一致性</li>
<li>交换一系列非冲突指令，不会破坏从读一致性</li>
</ul></li>
<li><strong>存在视图可串行化但非冲突可串行化的调度</strong></li>
</ul>
<p><img src="/2021/05/23/DB/CLJ/06-2/image-20210525151342084.png" style="zoom:50%;"></p>
<ul>
<li>盲目写操作：不读就写</li>
</ul>
<h3 id="视图可串行化判定">视图可串行化判定</h3>
<h4 id="思想">思想</h4>
<ul>
<li>找出所有的从读关系</li>
<li>如果有其他事务对某个数据项有写操作，这个写操作不能破坏这个数据项的从读关系</li>
</ul>
<h4 id="算法">算法</h4>
<ul>
<li>设调度 S 包含了事务 {T1,T2, ... ,Tn} ，设 Tb,Tf 是两个虚事务，其中
Tb 为 S 中所有 write(Q) 操作，Tf 为 S 中所有 read(Q) 操作。在调度 S
的开头插入 Tb ，在调度 S 的末尾插入 Tf，得到新的调度 S'
<ul>
<li>如果 Tj 读取 Ti 写入的数据项的值，则加入边 Ti <span class="math inline">\({\buildrel{0}\over\longrightarrow}\)</span>
Tj</li>
<li>删除所有关联无用事务的边。如果在优先图中不存在从 Ti 到 Tf 的通路，则
Ti 是无用事务</li>
<li>对于每个数据项 Q，如果 Tj 读取 Ti 写入的 Q 值，Tk 执行 write(Q)
操作且 Tk <span class="math inline">\(\ne\)</span> Tb，则
<ul>
<li>如果 Ti = Tb 且 Tj <span class="math inline">\(\ne\)</span>
Tf，则在带标记的优先图中插入边 Tj <span class="math inline">\({\buildrel{0}\over\longrightarrow}\)</span>
Tk</li>
<li>如果Ti <span class="math inline">\(\ne\)</span> Tb 且
Tj=Tf，则在带标记的优先图中插入边 Tk <span class="math inline">\({\buildrel{0}\over\longrightarrow}\)</span>
Ti</li>
<li>如果 Ti <span class="math inline">\(\ne\)</span> Tb且 Tj <span class="math inline">\(\ne\)</span> Tf，则在带标记的优先图中插入边 Tk
<span class="math inline">\({\buildrel{p}\over\longrightarrow}\)</span>
Ti 与 Tj <span class="math inline">\({\buildrel{p}\over\longrightarrow}\)</span> Tk
<ul>
<li>其中 p 是一个唯一的，在前面边的标记中未曾用过的大于 0 的整数</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="算法解释">算法解释</h4>
<ul>
<li>读数据库初值的，就是读取 Tb 的</li>
<li>最终加入一个 Tf，表示读数据库终值</li>
</ul>
<h4 id="简单的算法操作">简单的算法操作</h4>
<ul>
<li>找到所有的从读关系，加边（包括读初值、写中止）</li>
<li>对剩下的写操作做分析，不能破坏上面的从读关系
<ul>
<li>只能加前面 / 只能加后面：标记 0</li>
<li>否则加两条边，并标记 p</li>
</ul></li>
</ul>
<h4 id="算法解释例子1">算法解释（例子1）</h4>
<p><img src="/2021/05/23/DB/CLJ/06-2/image-20210525153235697.png" style="zoom:50%;"></p>
<ul>
<li>找出从读关系（红边）
<ul>
<li>read(A) 读取数据库初值，加上一条边（Tb <span class="math inline">\(\to\)</span> T1）</li>
<li>write(A) 写数据库终值，加上一条边 （T1 <span class="math inline">\(\to\)</span> Tf）</li>
</ul></li>
<li>对从读关系进行判断，找到和从读关系操作数据项相同的 write 操作
<ul>
<li>write(A) 不能破坏边（Tb <span class="math inline">\(\to\)</span>
T1）的从读关系，因此 T2 只能在 Tb 的前面（这不允许，Tb是第一个事务）或者
T1 的后面</li>
<li>write(A) 不能破坏边（T1 <span class="math inline">\(\to\)</span>
Tf）的从读关系，因此 T2 只能在 T1 的前面或者 Tf 的后面（这不允许，Tf
是最后一个事务）</li>
</ul></li>
<li>结果有环，不是视图可串行化的</li>
</ul>
<h4 id="例子-2">例子 2</h4>
<p><img src="/2021/05/23/DB/CLJ/06-2/image-20210525154116982.png" style="zoom:50%;"></p>
<ul>
<li>按照上面的算法构造优先图
<ul>
<li>标号相同且不为 0 的边，有一条边成立即可</li>
</ul></li>
<li>判定
<ul>
<li>每个优先图包含标号大于 1 的边对中的一条</li>
<li>判定准则：只要有一个优先图无环，则调度是视图可串行化的</li>
</ul></li>
</ul>
<p><img src="/2021/05/23/DB/CLJ/06-2/image-20210525154541252.png" style="zoom:60%;"></p>
<ul>
<li>左图无环，是视图可串行化的</li>
</ul>
<h3 id="视图可串行化判定示例">视图可串行化判定示例</h3>
<ul>
<li>满足上面视图可串行化判断的调度一定是可串行化的</li>
<li>不满足判断的调度不一定是不可串行化的</li>
<li>例子
<ul>
<li>另外一种判定方法：如下调度与任意一个串行调度都不是视图等价的
<ul>
<li>T1, T2</li>
<li>T2, T1</li>
</ul></li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">T1</th>
<th style="text-align: center;">T2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">read(A)</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">A := A - 50</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">write(A)</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">read(B)</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">B := B - 10</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">write(B)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">read(B)</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">B := B + 50</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">write(B)</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">read(A)</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">A := A + 10</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">write(A)</td>
</tr>
</tbody>
</table>
<h2 id="事务模型">事务模型</h2>
<h3 id="平面事务">平面事务</h3>
<ul>
<li><strong>一层结构</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span> transaction ... <span class="keyword">commit</span></span><br></pre></td></tr></table></figure>
<ul>
<li>平面事务的缺点
<ul>
<li><strong>不能部分回滚</strong></li>
</ul></li>
<li>某些应用场合有部分回滚的需求</li>
</ul>
<h4 id="部分回滚应用场合">部分回滚应用场合</h4>
<ul>
<li>确定旅行路线
<ul>
<li>某条线路不通应该回滚到上一个分支点，而不是回滚整个事务</li>
</ul></li>
<li>批量更新
<ul>
<li>如银行结算利息，可以把更新每个帐号作为一个事务，也可以把更新所有帐号作为一个事务</li>
<li>一部分记录更新后，做 一个保存点</li>
</ul></li>
</ul>
<h4 id="保存点">保存点</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">begin_transaction()</span><br><span class="line">    S1;</span><br><span class="line">    sp1 :<span class="operator">=</span> create_savepoint();</span><br><span class="line">    ...</span><br><span class="line">    Sn;</span><br><span class="line">    spn:<span class="operator">=</span> create_savepoint();</span><br><span class="line">    ...</span><br><span class="line">    if(<span class="keyword">condition</span>)&#123;</span><br><span class="line">        <span class="keyword">rollback</span>(spi);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">commit</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>一个例子</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span> tran</span><br><span class="line"><span class="comment">----转账部分</span></span><br><span class="line"><span class="keyword">update</span> accounts</span><br><span class="line"><span class="keyword">set</span> amounts<span class="operator">=</span>amounts<span class="number">-100</span></span><br><span class="line"><span class="keyword">where</span> account_id<span class="operator">=</span><span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">update</span> accounts</span><br><span class="line"><span class="keyword">set</span> amounts<span class="operator">=</span>amounts<span class="operator">+</span><span class="number">100</span></span><br><span class="line"><span class="keyword">where</span> account_id<span class="operator">=</span><span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">----结算利息, 然后撤销</span></span><br><span class="line">save tran add_interest <span class="comment">--保存点</span></span><br><span class="line"><span class="keyword">update</span> accounts</span><br><span class="line"><span class="keyword">set</span> amounts<span class="operator">=</span>amounts<span class="operator">*</span><span class="number">1.02</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> accounts</span><br><span class="line"><span class="keyword">rollback</span> tranadd_interest</span><br><span class="line"><span class="keyword">commit</span> tran</span><br></pre></td></tr></table></figure>
<h3 id="分布式事务">分布式事务</h3>
<p><img src="/2021/05/23/DB/CLJ/06-2/image-20210525163716093.png" style="zoom:67%;"></p>
<h3 id="moss-的嵌套事务模型">Moss 的嵌套事务模型</h3>
<ul>
<li>嵌套事务是一棵<strong>事务树</strong>，<strong>子树</strong>可以是<strong>嵌套</strong>的也可以是<strong>平面</strong>的</li>
<li><strong>叶结点事务是平面事务</strong>，从根结点到各个叶结点的距离可以是不同的</li>
<li>根结点事务称作<strong>顶层事务</strong>，其他称作<strong>子事务</strong></li>
<li>子事务可以提交也可以回滚，但它的提交并不起作用，除非它的父事务提交
<ul>
<li><strong>只有根结点的提交才会使得所有子事务提交</strong></li>
</ul></li>
<li>树中任何一个事务的回滚导致它的所有子事务的回滚</li>
<li>子事务具有一般事务的 A,C,I 特性，但不具有 D 特性</li>
<li>实际工作只发生在叶结点事务中，只有它们可以访问数据库，发送消息等
<ul>
<li>上层事务只是组织控制流以及决定什么时候该激活哪个子事务</li>
</ul></li>
</ul>
<h4 id="规则">规则</h4>
<ul>
<li>提交规则
<ul>
<li>当子事务提交时，它的结果只能被它的父事务所访问</li>
<li>只有当一个子事务提交了，并且它的一直到根的所有祖先也都提交了，该子事务才最终提交</li>
<li>因此，只有根结点提交了，所有子事务才会提交</li>
</ul></li>
<li>回滚规则
<ul>
<li>如果任何一个嵌套层次的事务回滚了，它的所有子事务也都要回滚，不管它们当前是否已经提交</li>
<li>因此，如果根结点回滚，整个嵌套事务也就回滚</li>
</ul></li>
<li>可见规则
<ul>
<li>当子事务提交后，它的修改对其父事务是可见的，而对其兄弟是不可见的</li>
<li>父事务的任何对象对其子事务都是可访问的</li>
</ul></li>
</ul>
<h4 id="例子">例子</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> TestNestTrans(Col <span class="type">char</span>(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">create</span> proccedure TransProc <span class="variable">@CharCol</span> <span class="type">char</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span> transaction InProc</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> TestNestTrans <span class="keyword">values</span>(<span class="variable">@CharCol</span>)</span><br><span class="line"><span class="keyword">commit</span> transaction InProc</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span> transaction OutOfProc</span><br><span class="line">    <span class="keyword">exec</span> TransProc <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line"><span class="keyword">rollback</span> transaction OutOfProc</span><br><span class="line"></span><br><span class="line"><span class="keyword">exec</span> TransProc <span class="string">&#x27;bbb&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> TestTrans</span><br><span class="line"><span class="comment">--最终 TestNestTrans 表中只有元组 bbb</span></span><br></pre></td></tr></table></figure>
<h3 id="工作流workflow">工作流（workflow）</h3>
<ul>
<li>实现某种商业目的的一组相关活动（或步骤）
<ul>
<li>银行或保险公司的贷款申请或保险索赔</li>
<li>一次科技会议的规划(邀请、评论、通知等等)</li>
<li>购买房地产的行政程序</li>
<li>病人在医院中的“行程”</li>
</ul></li>
<li>工作流使得机构把他们重复的、一成不变的处理自动化，同时保持灵活性，根据不断变化的商业需求来很快调整处理过程</li>
<li>工作流可能跨越不同的负责人和不同的、独立的信息系统，甚至跨越不同的企业</li>
<li>银行借贷工作流</li>
</ul>
<p><img src="/2021/05/23/DB/CLJ/06-2/image-20210525164238665.png" style="zoom:60%;"></p>
<h4 id="工作流任务间的依赖关系">工作流任务间的依赖关系</h4>
<ul>
<li>其他任务的执行状态
<ul>
<li>任务 tj 结束了，任务 ti 才能开始</li>
</ul></li>
<li>其他任务的输出值
<ul>
<li>如果任务 tj 返回一个大于 20 的值，则任务 ti 可以开始</li>
<li>如果秘书审批任务返回 OK，则经理审批任务可以开始</li>
</ul></li>
<li>外部时间修改的外部变量
<ul>
<li>上午9点以后任务 ti 才能开始</li>
<li>在任务 tj 完成后的 24 小时内必须开始任务 ti</li>
</ul></li>
</ul>
<h4 id="工作流的执行">工作流的执行</h4>
<ul>
<li>工作流执行
<ul>
<li>提交的可接受终止状态</li>
<li>中止的可接受终止状态</li>
</ul></li>
<li>整个工作流作为一个事务？
<ul>
<li>工作流持续时间很长</li>
<li>每个活动作为一个事务？</li>
</ul></li>
<li>如何取消一个活动？补偿事务</li>
</ul>
<h3 id="长事务">长事务</h3>
<ul>
<li>运行时间过长，不能采用传统的封锁机制</li>
<li>业务事务：涉及多个相关步骤、运行较长时间</li>
<li>例如购物包括以下若干步骤
<ul>
<li>订购商品、商议价格、确定发货日期、确认发货、开具发票、收到货款、发货、...</li>
</ul></li>
<li>不能用普通事务实现，否则锁死很久</li>
</ul>
<h4 id="典型例子">典型例子</h4>
<ul>
<li>传统的 DBMS 应用
<ul>
<li>计算所有银行账户余额</li>
</ul></li>
<li>设计系统
<ul>
<li>设计被分为不同部分，不同设计者同时工作在不同部分上</li>
</ul></li>
<li>工作流系统</li>
</ul>
<h4 id="特点">特点</h4>
<ul>
<li>持续时间长</li>
<li>暴露未提交的数据</li>
<li>子任务
<ul>
<li>中止其中某个子任务，而不必中止整个事务</li>
</ul></li>
<li>可恢复性
<ul>
<li>不要将整个事务撤销，而恢复到系统崩溃之前的某一状态，使丢掉的工作尽量少</li>
</ul></li>
<li>性能
<ul>
<li>响应时间 vs 事务吞吐量</li>
</ul></li>
</ul>
<h4 id="saga">Saga</h4>
<ul>
<li>Saga：构成长事务的一系列动作</li>
<li>一个图，其结点是动作或中止及完成结点，弧连接结点对
<ul>
<li>中止及完成结点称为<strong>终止结点</strong></li>
</ul></li>
<li>关于动作从哪个结点开始的指示，称为<strong>开始节点</strong></li>
<li>Saga 的并发控制
<ul>
<li>每个动作是一个一个短事务，采用传统的并发控制</li>
<li>整个事务的完整性由<strong>补偿事务</strong>来保证
<ul>
<li>整个事务，即任何通向终止结点的路径通过补偿事务来管理，也即每个结点上短事务的逆（用于撤销回滚）</li>
</ul></li>
</ul></li>
</ul>
<h4 id="service-broker">Service Broker</h4>
<ul>
<li>转化为异步的消息队列</li>
<li>每个部门处理订单的一部分，每个部分处理完自己的短事务之后，打包成一个消息传递给下一个部门</li>
<li>可靠的（reliable）、有序的（in order）、异步的（asynchronous）</li>
</ul>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.06.事务</title>
    <url>/2021/05/21/DB/CLJ/06/</url>
    <content><![CDATA[<h1 id="事务">事务</h1>
<h2 id="事务概念">事务概念</h2>
<ul>
<li>transaction（交易）</li>
<li>交易的核心：<strong>完整性</strong></li>
<li>Jim Gray：在事务处理方面做出巨大的贡献
<ul>
<li>书籍：transaction processing: concept and techniques</li>
</ul></li>
<li>commitment
<ul>
<li>事务包含了很多操作，commitment
指把所有的操作完整的提交到数据库上</li>
<li>It's like bacon and eggs. The chicken participants. The pig
commited.</li>
</ul></li>
<li><strong>一致性条件</strong>
<ul>
<li>银行转账，两个账户的总和在转账前后保持不变</li>
<li>存在两个操作，转出账户余额减去转账金额，转入账户余额加上转账金额
<ul>
<li><strong>必须保证这组操作的整体性</strong></li>
</ul></li>
</ul></li>
</ul>
<h3 id="事务定义">事务定义</h3>
<ul>
<li>事务是由一系列操作序列构成的执行单元，这些操作<strong>要么都做，要么都不做</strong>，是一个<strong>不可分割</strong>的工作单位</li>
<li><span class="math inline">\({\color{red}\mathrm{All\;or\;None}}\)</span></li>
</ul>
<h3 id="事务中的数据访问原语">事务中的数据访问原语</h3>
<ul>
<li>read(X)：从数据库传送数据项 X 到事务的工作区中
<ul>
<li><strong>从数据缓冲区读出来</strong></li>
</ul></li>
<li>write(X)：从事务的工作区中将数据项 X 写回数据库</li>
</ul>
<p><img src="/2021/05/21/DB/CLJ/06/image-20210521223649619.png" style="zoom:50%;"></p>
<h4 id="转账事务的原语表达">转账事务的原语表达</h4>
<ul>
<li>事务 T 从 A 帐户过户 50 到 B 帐户</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;read(A);\\
&amp;A := A –50;\\
&amp;write(A);\\
&amp;read(B);\\
&amp;B := B + 50;\\
&amp;write(B);\\
\end{aligned}
\]</span></p>
<ul>
<li>电子商务：<strong>事务是现代信息系统的基石</strong></li>
</ul>
<h3 id="sql中事务的定义">SQL中事务的定义</h3>
<ul>
<li>事务以 Begin transaction 开始，以 Commit transaction 或 Rollback
transaction 结束
<ul>
<li>Commit transaction
表示<strong>提交</strong>，<strong>事务正常结束</strong></li>
<li>Rollback transaction
表示事务非正常结束，<strong>撤消事务已做的操作</strong>，回滚到事务开始时状态</li>
</ul></li>
<li>具体的结束方式，通过加入某些条件判断</li>
<li>terminate 与 abort
<ul>
<li>Terminate：终止（中性）</li>
<li>Abort：中止（失败，需要 rollback）</li>
</ul></li>
</ul>
<h3 id="事务执行模式">事务执行模式</h3>
<h4 id="显式事务">显式事务</h4>
<ul>
<li>以 begin transaction 开始，以 commit 或 rollback 结束</li>
</ul>
<h4 id="隐含事务">隐含事务</h4>
<ul>
<li>事务自动开始，直到遇到 commit 或 rollback 时结束</li>
<li>set implicit_transactions{ ON | OFF }</li>
</ul>
<h4 id="自动事务">自动事务</h4>
<ul>
<li>每个数据操作语句作为一个事务</li>
<li>update SC set GRADE = GRADE+15</li>
</ul>
<h3 id="事务中的错误检查">事务中的错误检查</h3>
<ul>
<li>GRADE 约束小于等于100，现在数据库中有两个 GRADE (80, 90)</li>
<li>事务 <code>update SC set GRADE = GRADE+15</code> 操作的结果
<ul>
<li>(80,90)，事务出错，整个回滚</li>
</ul></li>
<li>如下事务操作的结果
<ul>
<li>(85, 95)
<ul>
<li>不做设置的前提下，会将第一个操作提交</li>
</ul></li>
<li>设置 <code>set XACT_ABORT ON</code> 之后结果为 (80,90)</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Begin</span> tran</span><br><span class="line"><span class="keyword">Update</span> SC</span><br><span class="line"><span class="keyword">Set</span> grade <span class="operator">=</span> grade<span class="operator">+</span><span class="number">5</span></span><br><span class="line"><span class="comment">--没有违反 grade&lt;=100 约束</span></span><br><span class="line"><span class="keyword">Update</span> SC</span><br><span class="line"><span class="keyword">Set</span> grade <span class="operator">=</span> grade<span class="operator">+</span><span class="number">20</span></span><br><span class="line"><span class="comment">--违反了 grade&lt;=100 约束</span></span><br><span class="line"><span class="keyword">Commit</span> tran</span><br></pre></td></tr></table></figure>
<ul>
<li>如下事务操作的结果
<ul>
<li>(80, 90)</li>
<li>rollback 把整个事务回滚</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Begin</span> tran</span><br><span class="line"><span class="keyword">Update</span> SC</span><br><span class="line"><span class="keyword">Set</span> grade <span class="operator">=</span> grade<span class="operator">+</span><span class="number">5</span></span><br><span class="line"><span class="keyword">Update</span> SC</span><br><span class="line"><span class="keyword">Set</span> grade <span class="operator">=</span> grade<span class="operator">+</span><span class="number">20</span></span><br><span class="line">If @<span class="variable">@error</span><span class="operator">&lt;&gt;</span><span class="number">0</span> <span class="comment">-- 全局变量, 上一行语句操作设置</span></span><br><span class="line">    <span class="keyword">rollback</span> tran</span><br><span class="line"><span class="keyword">Commit</span> tran</span><br></pre></td></tr></table></figure>
<h3 id="事务基本特性acid">事务基本特性ACID</h3>
<ul>
<li><span class="math inline">\(\mathrm{ACID:Atomicity\;Consistency\;Isolation\;Durability}\)</span></li>
</ul>
<h4 id="原子性atomicity">原子性(Atomicity)</h4>
<ul>
<li>事务中包含的所有操作要么全做，要么全不做</li>
<li>原子性由<strong>恢复机制</strong>实现
<ul>
<li>通过<strong>日志</strong>进行恢复</li>
</ul></li>
</ul>
<h4 id="一致性consistency">一致性(Consistency)</h4>
<ul>
<li>事务的隔离执行必须保证数据库的一致性</li>
<li>事务开始前，数据库处于一致性的状态；事务结束后，数据库必须仍处于一致性状态</li>
<li><strong>数据库的一致性状态由用户来负责</strong></li>
<li>如银行转帐，转帐前后两个帐户金额之和应保持不变
<ul>
<li>意大利香肠术，Salami technique</li>
<li>偷小钱的盗窃术被称为意大利香肠术（意大利香肠切得很薄，偷一片看不出来）</li>
</ul></li>
</ul>
<h4 id="隔离性isolation">隔离性(Isolation)</h4>
<ul>
<li>系统必须保证事务不受其它并发执行事务的影响</li>
<li>对任何一对事务 T1，T2，在 T1 看来，T2 要么在 T1
开始之前已经结束，要么在 T1 完成之后再开始执行
<ul>
<li><strong>等价于串行执行的效果</strong></li>
</ul></li>
<li>隔离性通过<strong>并发控制机制</strong>实现</li>
</ul>
<h4 id="持久性durability">持久性(Durability)</h4>
<ul>
<li>一个事务一旦提交之后，它对数据库的影响必须是永久的</li>
<li>系统发生故障不能改变事务的持久性
<ul>
<li>系统的<strong>抗故障能力</strong></li>
<li>大企业的数据，备份，多个物理实体（物理上相隔较远，避免自然灾害的影响）</li>
</ul></li>
<li>持久性通过<strong>恢复机制</strong>实现</li>
<li>持久性：将来总能够再现这个事务</li>
</ul>
<h3 id="事务生命周期图">事务生命周期图</h3>
<p><img src="/2021/05/21/DB/CLJ/06/image-20210521234852488.png" style="zoom:50%;"></p>
<ul>
<li>部分提交状态：事务的所有操作都做完了</li>
<li>一个事务的所有操作都做完了，并不意味着一定能成功提交，因为要保证持久性
<ul>
<li>数据库在做完事务的所有操作之后，在向程序客户端发送成功消息之前，<strong>把这个事务对应的<span style="color:red">日志记录</span>从内存写入磁盘</strong></li>
<li>如果系统崩溃，内存中的数据丢失了，可以从日志记录恢复数据</li>
</ul></li>
</ul>
<h2 id="事务调度">事务调度</h2>
<ul>
<li><strong>事务的执行顺序</strong>称为一个调度，表示事务的指令在系统中<strong>执行的时间顺序</strong></li>
<li>一组事务的调度必须保证
<ul>
<li>包含了<strong>所有事务</strong>的操作指令</li>
<li><strong>一个事务中指令的顺序必须保持不变</strong></li>
</ul></li>
</ul>
<h3 id="事务调度例子">事务调度例子</h3>
<ul>
<li><span class="math inline">\(T_1:i_{11},i_{12},T_2:i_{21},i_{22}\)</span>
<ul>
<li><span class="math inline">\(S_1:i_{11},i_{12},i_{21}\)</span></li>
<li><span class="math inline">\(S_2:i_{11},i_{22},i_{12},i_{21}\)</span></li>
<li><span class="math inline">\(S_2:i_{11},i_{21},i_{12},i_{22}\)</span></li>
</ul></li>
<li><span class="math inline">\(S_1,S_2\)</span> 不是一个调度，<span class="math inline">\(S_3\)</span> 是一个调度</li>
</ul>
<h3 id="并行与串行">并行与串行</h3>
<h4 id="串行调度">串行调度</h4>
<ul>
<li>在串行调度中，属于同一事务的指令紧挨在一起</li>
<li>串行调度总是正确的</li>
<li>对于有 <span class="math inline">\(n\)</span>个事务的事务组，可以有
<span class="math inline">\(n!\)</span> 个有效调度</li>
</ul>
<h4 id="并行调度">并行调度</h4>
<ul>
<li>在并行调度中，来自不同事务的指令可以交叉执行</li>
<li><strong>当并行调度等价于某个串行调度时，则称它是正确的</strong></li>
<li><span class="math inline">\(n\)</span> 个事务，<span class="math inline">\(t_i\)</span> 有 <span class="math inline">\(k_i\)</span> 条指令，则可能的并发调度有多少个
<ul>
<li><span class="math inline">\(\dfrac{(\sum
k_i)!}{\prod(k_i!)}\)</span></li>
<li>事务内有序</li>
</ul></li>
</ul>
<h4 id="并行和串行的比较">并行和串行的比较</h4>
<h5 id="基本比较">基本比较</h5>
<ul>
<li>并行事务有可能破坏数据库的一致性</li>
<li>串行事务效率低</li>
</ul>
<h5 id="并行的优点">并行的优点</h5>
<ul>
<li>一个事务由不同的步骤组成，所涉及的系统资源也不同。这些步骤可以并发执行，<strong>提高系统的吞吐量</strong></li>
<li>系统中存在着周期不等的各种事务，串行会导致难于预测的时延。如果各个事务所涉及的是数据库的不同部分，采用并发会<strong>减少平均响应时间</strong></li>
</ul>
<h3 id="事务调度例子-1">事务调度例子</h3>
<ul>
<li>两个转账事务
<ul>
<li><span class="math inline">\(T_1\)</span>：从 A 过户 50 到 B</li>
<li><span class="math inline">\(T_2\)</span>：从 A 过户存款的 10% 到
B</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;T1\\
&amp;read(A);\\
&amp;A := A −50;\\
&amp;write(A);\\
&amp;read(B);\\
&amp;B := B + 50;\\
&amp;write(B);\\\\
&amp;T2\\
&amp;read(A);\\
&amp;temp := A*0.1;\\
&amp;A := A −temp;\\
&amp;write(A);\\
&amp;read(B);\\
&amp;B := B + temp;\\
&amp;write(B);\\
\end{aligned}
\]</span></p>
<ul>
<li>开始状态：A=1000，B=2000，A+B=3000</li>
</ul>
<h4 id="串行调度1">串行调度1</h4>
<ul>
<li><span class="math inline">\(T_1,T_2\)</span></li>
<li>结束状态：A=855，B=2145，A+B=3000</li>
</ul>
<h4 id="串行调度2">串行调度2</h4>
<ul>
<li><span class="math inline">\(T_2,T_1\)</span></li>
<li>结束状态：A=850，B=2150，A+B=3000</li>
<li>串行调度可能会有不同的结果，但是都满足一致性，都是正确的</li>
</ul>
<h4 id="并行调度1">并行调度1</h4>
<p><span class="math display">\[
\begin{aligned}
&amp;T1:\;read(A);\\
&amp;T1:\;A := A −50;\\
&amp;T1:\;write(A);\\
&amp;T2:\;read(A);\\
&amp;T2:\;temp := A*0.1;\\
&amp;T2:\;A := A −temp;\\
&amp;T2:\;write(A);\\
&amp;T1:\;read(B);\\
&amp;T1:\;B := B + 50;\\
&amp;T1:\;write(B);\\
&amp;T2:\;read(B);\\
&amp;T2:\;B := B + temp;\\
&amp;T2:\;write(B);\\
\end{aligned}
\]</span></p>
<ul>
<li>需要保证操作 4 在操作 3 之后，否则是错误的</li>
<li>结束状态：A=855，B=2145，A+B=3000</li>
<li>等价于串行调度 <span class="math inline">\(T_1,T_2\)</span></li>
</ul>
<h4 id="并行调度2">并行调度2</h4>
<p><span class="math display">\[
\begin{aligned}
&amp;T1:\;read(A);\\
&amp;T1:\;A := A −50;\\
&amp;T2:\;read(A);\\
&amp;T1:\;write(A);\\
&amp;T2:\;temp := A*0.1;\\
&amp;T2:\;A := A −temp;\\
&amp;T2:\;write(A);\\
&amp;T1:\;read(B);\\
&amp;T1:\;B := B + 50;\\
&amp;T1:\;write(B);\\
&amp;T2:\;read(B);\\
&amp;T2:\;B := B + temp;\\
&amp;T2:\;write(B);\\
\end{aligned}
\]</span></p>
<ul>
<li>错误的</li>
<li>结束状态：A=900，B=2150，A+B=3050</li>
</ul>
<h3 id="可恢复调度">可恢复调度</h3>
<ul>
<li>事务的恢复
<ul>
<li>一个事务失败了，应该能够撤消该事务对数据库的影响</li>
<li>如果有其它事务读取了失败事务写入的数据，则该事务应该撤消</li>
</ul></li>
<li>一个不可恢复调度的例子</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">T1</th>
<th style="text-align: center;">T2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">read(A)</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">write(A)</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">read(A)</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">commit</td>
</tr>
<tr class="odd">
<td style="text-align: center;">read(B)</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">rollback</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<ul>
<li>回滚 T1 的时候，T2 已经提交了，如果 T2
被撤销了，那么就违反了事务的持久性
<ul>
<li>在真实场景中， 会向 T2 发起一个<strong>补偿事务</strong></li>
</ul></li>
</ul>
<h4 id="可恢复调度定义">可恢复调度定义</h4>
<ul>
<li>对于每对事务 T1 与 T2，如果 T2 读取了 T1 所写的数据，则 T1 必须先于
T2 提交</li>
</ul>
<h3 id="无级联调度">无级联调度</h3>
<ul>
<li>级联调度
<ul>
<li>由于一个事务故障而导致一系列事务回滚</li>
</ul></li>
<li>级联调度例子</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">T1</th>
<th style="text-align: center;">T2</th>
<th style="text-align: center;">T3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">read(A)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">read(B)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">write(B)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">read(A)</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">write(A)</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">read(A)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">rollback</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h4 id="无级联调度定义">无级联调度定义</h4>
<ul>
<li>对于每对事务 T1 与 T2，如果 T2 读取了 T1 所写的数据，则 T1 必须在
<strong>T2 读取</strong>之前提交</li>
<li><strong>无级联调度必是可恢复调度</strong>
<ul>
<li>要求比可恢复调度更加严格</li>
</ul></li>
</ul>
<h2 id="并发调度中的不一致现象">并发调度中的不一致现象</h2>
<h3 id="丢失修改">丢失修改</h3>
<ul>
<li>两个事务 T1 和 T2 读入同一数据并修改，T1 提交的结果破坏了 T2
提交的结果，导致 T2 的修改丢失</li>
<li>一个例子：售票窗口
<ul>
<li>下面的操作只反映了售票窗口 T1 的结果，但是没有反应售票窗口 T2
的结果</li>
</ul></li>
</ul>
<p><img src="/2021/05/21/DB/CLJ/06/image-20210522110153105.png" style="zoom:50%;"></p>
<ul>
<li><strong>写 —— 写</strong>不一致</li>
</ul>
<h3 id="读脏数据">读脏数据</h3>
<ul>
<li>事务 T1 修改某一数据，并将其写回磁盘，事务 T2 读取同一数据后，T1
由于某种原因被撤消，这时 T1 已修改过的数据恢复原值，T2
读到的数据与数据库中数据不一致，则 T2 读到的数据就是脏数据</li>
<li>一个例子</li>
</ul>
<p><img src="/2021/05/21/DB/CLJ/06/image-20210522110848800.png" style="zoom:50%;"></p>
<ul>
<li><strong>写 —— 读</strong>不一致</li>
</ul>
<h3 id="不能重复读">不能重复读</h3>
<ul>
<li>事务 T2 读取某一数据后，事务 T1 对其做了修改，当 T2
再次读取该数据时，得到与前次不同的值</li>
</ul>
<p><img src="/2021/05/21/DB/CLJ/06/image-20210522111134680.png" style="zoom:50%;"></p>
<ul>
<li><strong>读 —— 写</strong>不一致</li>
<li>发生概率比读脏数据小</li>
<li>例子
<ul>
<li>r1(list) r2(list) w2(list) r2(count) w2(count) commit(t2)
r1(count)</li>
<li>r1(list) 和 r1(count) 不一致</li>
</ul></li>
</ul>
<h3 id="发生幻象phantom">发生幻象(Phantom)</h3>
<ul>
<li>事务 T2 按一定条件读取了某些数据后，事务 T1
插入了一些满足这些条件的数据，当 T2
再次按相同条件读取数据时，发现多了一些记录</li>
</ul>
<p><img src="/2021/05/21/DB/CLJ/06/image-20210522111831336.png" style="zoom:50%;"></p>
<ul>
<li>不可重复读是指对同一条记录出现不一致情况，幻象指的是多出来或者少掉某些记录
<ul>
<li>防止幻象更难</li>
<li>例如
<ul>
<li>防范不可重复读只需要将原来在数据库中的数据锁住</li>
<li>防范幻象则比较难，怎么处理新来的数据</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.05.关系规范化</title>
    <url>/2021/05/05/DB/CLJ/05/</url>
    <content><![CDATA[<h1 id="关系规范化">关系规范化</h1>
<ul>
<li>为什么需要关系规范化</li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210505233157308.png" style="zoom: 50%;"></p>
<h2 id="关系模式的设计问题">关系模式的设计问题</h2>
<h3 id="例子-1">例子 1</h3>
<ul>
<li>为管理职工信息而设计如下一个关系模式
<ul>
<li>问题：当删除职工 A 后，没有等级 4 的员工了，此时如果想再招聘一个等级
4 的员工，不知道如何安排工资</li>
<li>不完整了</li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">职工</th>
<th style="text-align: center;">级别</th>
<th style="text-align: center;">工资</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">500</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">600</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">700</td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">600</td>
</tr>
<tr class="odd">
<td style="text-align: center;">E</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">700</td>
</tr>
</tbody>
</table>
<ul>
<li>问题根源：在属性如何取值的问题上，表结构与现实出现偏离
<ul>
<li>现实中
<ul>
<li>职工只和岗位有关系</li>
<li>每个级别的工资和职工没关系，只和级别有关系</li>
</ul></li>
</ul></li>
<li>应该这样设计
<ul>
<li>职工 - 级别一张表</li>
<li>级别 - 工资一张表</li>
</ul></li>
<li>问题根源：<strong>人为造成了现实当中本来无关属性之间的依赖</strong></li>
</ul>
<h4 id="异常">异常</h4>
<ul>
<li><strong>信息的不可表示问题</strong>
<ul>
<li><strong>插入异常</strong>：如果没有职工具有 8 级工资，则 8
级工资的工资数额就难以插入</li>
<li><strong>删除异常</strong>：如果仅有职工 A 具有 4 级工资，删除 A
则会将有关 4 级工资的工资数额信息也一并删除</li>
</ul></li>
<li><strong>信息的冗余问题</strong>
<ul>
<li><strong>数据冗余</strong>：职工很多，工资级别有限，每一级别的工资数额反复存储多次</li>
<li><strong>更新异常</strong>：如果将 5 级工资的工资数额调为
620，则需要找到每个具有 5 级工资的职工，逐一修改</li>
</ul></li>
</ul>
<h4 id="不良的数据依赖">不良的数据依赖</h4>
<ul>
<li>解决方案</li>
<li>应该这样设计
<ul>
<li>职工 - 级别一张表</li>
<li>级别 - 工资一张表</li>
</ul></li>
</ul>
<h3 id="例子-2">例子 2</h3>
<ul>
<li>有些人可能有很多爱好，主码设置为 <strong>姓名+爱好</strong></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">姓名</th>
<th style="text-align: center;">年龄</th>
<th style="text-align: center;">性别</th>
<th style="text-align: center;">爱好</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">20</td>
<td style="text-align: center;">男</td>
<td style="text-align: center;">电影</td>
</tr>
<tr class="even">
<td style="text-align: center;">A</td>
<td style="text-align: center;">20</td>
<td style="text-align: center;">男</td>
<td style="text-align: center;">音乐</td>
</tr>
<tr class="odd">
<td style="text-align: center;">B</td>
<td style="text-align: center;">18</td>
<td style="text-align: center;">女</td>
<td style="text-align: center;">购物</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">18</td>
<td style="text-align: center;">女</td>
<td style="text-align: center;">美食</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">23</td>
<td style="text-align: center;">null</td>
<td style="text-align: center;">null</td>
</tr>
</tbody>
</table>
<ul>
<li>有些人可能没有爱好，此时它不能插入
<ul>
<li>C 的记录是无法插入的（主码非 null ）</li>
</ul></li>
</ul>
<h2 id="函数依赖">函数依赖</h2>
<h3 id="函数依赖的定义">函数依赖的定义</h3>
<ul>
<li>设 <span class="math inline">\(R(U)\)</span> 是属性集 <span class="math inline">\(U\)</span> 上的关系模式，<span class="math inline">\(X,Y\subseteq U\)</span>，<span class="math inline">\(r\)</span> 是 <span class="math inline">\(R(U)\)</span> 上的任意一个关系
<ul>
<li>如果成立 对 <span class="math inline">\(\forall t,s\in R\)</span> 若
<span class="math inline">\(t[X]=s[X]\)</span>，则 <span class="math inline">\(t[Y]=s[Y]\)</span></li>
<li>则称 “<span class="math inline">\(X\)</span> 函数决定 <span class="math inline">\(Y\)</span> ” 或 “ <span class="math inline">\(Y\)</span> 函数依赖于 <span class="math inline">\(X\)</span> “，记作 <span class="math inline">\(X\to Y\)</span></li>
<li><strong>称 <span class="math inline">\(X\)</span>
为决定因素</strong></li>
</ul></li>
<li>函数依赖的双重否定定义
<ul>
<li>不存在 <span class="math inline">\(t, s \in r\)</span>，<span class="math inline">\(t[X] = s[X]\)</span>，但 <span class="math inline">\(t[Y]\ne s[Y]\)</span></li>
</ul></li>
<li>函数依赖的例子
<ul>
<li>姓名 <span class="math inline">\(\to\)</span> 学号</li>
</ul></li>
</ul>
<h3 id="例子-1-1">例子 1</h3>
<ul>
<li>给定如下关系示例，判断如下函数依赖是否成立</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">C</th>
<th style="text-align: center;">D</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">a1</td>
<td style="text-align: center;">b1</td>
<td style="text-align: center;">c1</td>
<td style="text-align: center;">d1</td>
</tr>
<tr class="even">
<td style="text-align: center;">a1</td>
<td style="text-align: center;">b2</td>
<td style="text-align: center;">c1</td>
<td style="text-align: center;">d2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">a2</td>
<td style="text-align: center;">b2</td>
<td style="text-align: center;">c2</td>
<td style="text-align: center;">d2</td>
</tr>
<tr class="even">
<td style="text-align: center;">a2</td>
<td style="text-align: center;">b3</td>
<td style="text-align: center;">c2</td>
<td style="text-align: center;">d3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">a3</td>
<td style="text-align: center;">b3</td>
<td style="text-align: center;">c2</td>
<td style="text-align: center;">d4</td>
</tr>
</tbody>
</table>
<ul>
<li><span class="math inline">\(A\to C\)</span>：成立
<ul>
<li>判断在 A 上相等的两行，在 C 上是否相等</li>
</ul></li>
<li><span class="math inline">\(C\to A\)</span>：不成立</li>
<li><span class="math inline">\(AB\to D\)</span>：成立
<ul>
<li><span class="math inline">\(AB\)</span> 上取值是唯一的</li>
</ul></li>
</ul>
<h3 id="两种依赖的等级">两种依赖的等级</h3>
<ul>
<li>满足依赖的关系：<strong>依赖在模式的某个关系实例上成立</strong>
<ul>
<li>可能在插入几行之后，函数依赖就不成立了</li>
</ul></li>
<li>模式上成立的依赖：<strong>依赖在模式的所有关系实例上都成立</strong></li>
</ul>
<h3 id="例子2">例子2</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">C</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">3</td>
</tr>
</tbody>
</table>
<ul>
<li>找出所有可能的函数依赖</li>
<li><span class="math inline">\(A\to B,A\to C,B\to C\)</span></li>
<li><span class="math inline">\(A\to A,B\to B,C\to C\)</span></li>
<li><span class="math inline">\(AB\to A,ABC\to A,\cdots\)</span></li>
<li><span class="math inline">\(\cdots\)</span></li>
</ul>
<h3 id="平凡函数依赖">平凡函数依赖</h3>
<ul>
<li>如果 <span class="math inline">\(X\to Y\)</span>，<span class="math inline">\(Y\subseteq
X\)</span>，则称其为<strong>平凡的函数依赖</strong>，否则称为<strong>非平凡的函数依赖</strong></li>
<li>一个关系模式有 n
个属性，在它上面成立的所有可能的函数依赖有多少个？非平凡的函数依赖有多少个？
<ul>
<li>函数依赖：<span class="math inline">\(4^n\)</span></li>
<li>平凡的函数依赖：<span class="math inline">\(3^n\)</span>
<ul>
<li><span class="math inline">\(\sum{n \choose i}2^i=\sum{n \choose
i}2^i1^{n-i}=(2+1)^n=3^n\)</span></li>
</ul></li>
<li>非平凡的函数依赖：<span class="math inline">\(4^n-3^n\)</span></li>
</ul></li>
<li>如果 R(U) 的候选码是整个属性集 U，这称为全码
<ul>
<li>例如选课表，只有两个属性（学号、课程号）</li>
</ul></li>
<li>一个全码的关系模式存在非平凡的函数依赖吗？
<ul>
<li><strong>不存在</strong></li>
<li>如果存在 <span class="math inline">\(A\to
B\)</span>，则存在一个候选码 <span class="math inline">\(A\)</span>，而且 <span class="math inline">\(A\)</span> 不是整个属性集</li>
</ul></li>
<li>如果存在非平凡关系依赖 <span class="math inline">\(A\to
B\)</span>，则 <span class="math inline">\(B\)</span>
可以不作为码的一部分</li>
</ul>
<h3 id="部分函数依赖">部分函数依赖</h3>
<ul>
<li>如果 <span class="math inline">\(X\to Y\)</span>，且对于任意 <span class="math inline">\(X\)</span> 的真子集 <span class="math inline">\(X&#39;\)</span>，都有 <span class="math inline">\(X′\not\to Y\)</span>，则称 <span class="math inline">\(Y\)</span> 对 <span class="math inline">\(X\)</span> <strong>完全函数依赖</strong>，记作
<span class="math inline">\(X\overset{f}{\to} Y\)</span></li>
<li>否则称 <span class="math inline">\(Y\)</span> 对 <span class="math inline">\(X\)</span> <strong>部分函数依赖</strong>，记作
<span class="math inline">\(X\overset{p}{\to} Y\)</span></li>
<li><strong>如果在一个关系模式里面存在部分函数依赖的话，则是一个不好的设计</strong></li>
</ul>
<h4 id="例子">例子</h4>
<ul>
<li>(sno, cno) <span class="math inline">\(\overset{f}{\to}\)</span>
grade</li>
<li>(sno, cno) <span class="math inline">\(\overset{p}{\to}\)</span>
sname</li>
</ul>
<h3 id="传递函数依赖">传递函数依赖</h3>
<ul>
<li>如果关系模式中存在传递函数依赖，则也是一种差的设计</li>
<li>在 <span class="math inline">\(R(U)\)</span> 中，如果 <span class="math inline">\(X\to Y,Y\to Z,Y\not\to X,Z\nsubseteq
Y\)</span>，则称 <span class="math inline">\(Z\)</span> 对 <span class="math inline">\(X\)</span> <strong>传递函数依赖</strong></li>
<li>排除 <span class="math inline">\(Z\nsubseteq Y\)</span> 原因
<ul>
<li>平凡函数依赖是一定成立的，关系模式中存在这样的函数依赖是正常的</li>
</ul></li>
<li>排除 <span class="math inline">\(Y\not\to X\)</span> 原因
<ul>
<li>说明 <span class="math inline">\(X,Y\)</span> 都是候选码</li>
<li>多个候选码，在在关系模式的设计中是允许的</li>
</ul></li>
<li>如何把函数的部分依赖整理成传递函数依赖的形式？
<ul>
<li><span class="math inline">\(X&#39;\subset X,X\to Y,X&#39;\to
Y\)</span></li>
<li><span class="math inline">\(X\to X&#39;,X&#39;\to Y\)</span></li>
</ul></li>
<li>部分函数依赖一定能够转化为传递函数依赖</li>
</ul>
<h3 id="函数依赖的方式定义之前的码">函数依赖的方式定义之前的码</h3>
<ul>
<li><strong>超码</strong>
<ul>
<li>设 <span class="math inline">\(K\)</span> 为 <span class="math inline">\(R(U,F)\)</span> 的属性或属性组，若 <span class="math inline">\(K\to U\)</span>，则称 <span class="math inline">\(K\)</span> 为 <span class="math inline">\(R\)</span> 的超码</li>
</ul></li>
<li><strong>候选码</strong>
<ul>
<li>设 <span class="math inline">\(K\)</span> 为 <span class="math inline">\(R(U,F)\)</span> 的超码，若 <span class="math inline">\(K\overset{f}{\to} U\)</span>，则称 <span class="math inline">\(K\)</span> 为 <span class="math inline">\(R\)</span> 的候选码</li>
</ul></li>
<li><strong>主属性</strong>
<ul>
<li>包含在每一个候选码中的属性，称作主属性
<ul>
<li>候选码属性集的并，而不是交</li>
<li>例如属性集 (A,B,C)，候选码 A, (B,C)，则主属性是 A,B,C</li>
</ul></li>
</ul></li>
<li><strong>非主属性</strong>
<ul>
<li>不包含在任何候选码中的属性称为非主属性</li>
</ul></li>
<li><strong>全码</strong>
<ul>
<li>关系模式的码由整个属性组构成，如 SPJ</li>
</ul></li>
</ul>
<h2 id="范式">范式</h2>
<ul>
<li>一个不好的设计的例子</li>
<li>学号，姓名、系号、系主任、选修课程、成绩</li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507105954851.png" style="zoom: 43%;"></p>
<ul>
<li>范式是对关系的<strong>不同数据依赖程度</strong>的要求</li>
<li>通过<strong>模式分解</strong>将一个低级范式转换为若干个高级范式的过程称作<strong>规范化</strong>（<strong>概念的纯粹化</strong>）</li>
<li>排除法：在某一的范式中，不存在某些类型的函数依赖</li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507110327834.png" style="zoom:50%;"></p>
<h2 id="nf">1NF</h2>
<ul>
<li>关系中每一分量不可再分，也即不能以集合、序列等作为属性值</li>
</ul>
<h3 id="nf-与查询效率的折中">1NF 与查询效率的折中</h3>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507110548289.png" style="zoom:50%;"></p>
<h3 id="nf-与应用对属性粒度的处理需求">1NF
与应用对属性粒度的处理需求</h3>
<ul>
<li><strong>分量是否需要再分，与具体应用有关</strong></li>
<li>如果用到值的一部分，则需要进一步分割，否则需要应用编码解析</li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507110723397.png" style="zoom:50%;"></p>
<h3 id="nf-与数据质量的控制准则">1NF 与数据质量的控制准则</h3>
<ul>
<li>较细的原子粒度有助于标准化，施加约束，避免输入错误，从而提高数据质量</li>
<li>例如通讯地址，如果保存为一个属性，则输入格式可能不统一，导致解析困难</li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507111147090.png" style="zoom:50%;"></p>
<h3 id="nf-关系模式的不良特性">1NF 关系模式的不良特性</h3>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507105954851.png" style="zoom: 43%;"></p>
<ul>
<li>基于上面的例子</li>
<li><strong>插入异常</strong>：如果学生没有选课，关于他的个人信息及所在系的信息就无法插入</li>
<li><strong>删除异常</strong>：如果删除学生的选课信息，则他的个人信息及所在系的信息也随之删除</li>
<li><strong>更新异常</strong>：如果学生转系，若他选修了 k
门课，则需要修改 k 次</li>
<li><strong>数据冗余</strong>：如果一个学生选修了 k
门课，则有关他的所在系的信息重复</li>
</ul>
<h2 id="nf-1">2NF</h2>
<ul>
<li>若 R <span class="math inline">\(\in\)</span> 1NP
，且每个<strong>非</strong>主属性<strong>完全依赖</strong>于码，则称 R
<span class="math inline">\(\in\)</span> 2NF</li>
<li><strong>2NF 消除了非主属性对码的部分依赖</strong>
<ul>
<li>不要求主属性对码没有部分依赖</li>
</ul></li>
</ul>
<h3 id="如何将关系模式改进到-2nf">如何将关系模式改进到 2NF</h3>
<ul>
<li>非主属性有两种，一种完全依赖于码，一种部分依赖于码，据此将属性集划分为两部分</li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507112037025.png" style="zoom:50%;"></p>
<ul>
<li>关系模式R(A,B,C,D)，给出它的一个函数依赖集，使得码为 AB，并且 R 属于
1NF 而不属于 2NF
<ul>
<li>设置一个部分函数依赖即可</li>
</ul></li>
</ul>
<p><span class="math display">\[
AB\to C,B\to D
\]</span></p>
<ul>
<li>但是这样子的设计还是存在<strong>传递函数依赖</strong>
<ul>
<li>sno 决定 dno，dno 决定 dean</li>
</ul></li>
</ul>
<h3 id="nf关系模式的不良特性">2NF关系模式的不良特性</h3>
<ul>
<li><strong>插入异常</strong>：如果系中没有学生，则有关系的信息就无法插入</li>
<li><strong>删除异常</strong>：如果删除某系中全部学生，则该系的系主任信息也随之删除</li>
<li><strong>更新异常</strong>：如果学生转系，不但要修改 dno，还要修改
dean</li>
<li><strong>数据冗余</strong>：每个学生都存储了其系主任的信息</li>
</ul>
<h2 id="nf-2">3NF</h2>
<ul>
<li><p>关系模式 <span class="math inline">\(R(U)\)</span>
中,若不存在这样的码 <span class="math inline">\(X\)</span>，属性组 <span class="math inline">\(Y\)</span> 及非主属性 <span class="math inline">\(Z(Z\not\subseteq Y)\)</span>，使得 <span class="math inline">\(X\to Y,Y\to Z,Y\not\to X\)</span> 成立，则称 R
<span class="math inline">\(\in\)</span> 3NF</p></li>
<li><p>3NF 的目标是消除<strong>非主属性对码的传递依赖</strong></p></li>
</ul>
<h3 id="如何将关系模式改进到3nf">如何将关系模式改进到3NF</h3>
<ul>
<li>砸断函数依赖的传递链</li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507135841410.png" style="zoom:50%;"></p>
<ul>
<li>关系模式R(A,B,C,D)，给出它的一个函数依赖集，使得码为 AB，并且 R 属于
2NF 而不属于 3NF
<ul>
<li>设置一个传递函数依赖即可（当然不能存在部分函数依赖）</li>
</ul></li>
</ul>
<p><span class="math display">\[
AB\to C, C\to D
\]</span></p>
<ul>
<li>正常情况下数据库的设计要求达到 3NF 就可以了</li>
</ul>
<h3 id="nf-的问题">3NF 的问题</h3>
<ul>
<li>没有限定<strong>主属性</strong>的<strong>函数依赖</strong></li>
</ul>
<h3 id="主属性部分依赖的例子stc">主属性部分依赖的例子：<span id="STC">STC</span></h3>
<ul>
<li>关系模式：STC(sno,tno,cno)</li>
<li>每位老师只教授一门课：tno <span class="math inline">\(\to\)</span>
cno</li>
<li>某学生选定一门课，就对应一位老师：(sno,cno) <span class="math inline">\(\to\)</span> tno</li>
<li>候选码：(sno, cno)、(sno, tno)</li>
<li>STC <span class="math inline">\(\in\)</span> 3NF
<ul>
<li>没有非主属性，因此是满足 3NF 的</li>
</ul></li>
</ul>
<h3 id="nf-的不良特性">3NF 的不良特性</h3>
<ul>
<li><strong>插入异常</strong>：如果没有学生选修某位老师的任课，则该老师担任课程的信息就无法插入</li>
<li><strong>删除异常</strong>：删除学生选课信息，会删除掉老师的任课信息</li>
<li><strong>更新异常</strong>：如果老师的授课信息有所改动，则所有选修其课程的学生元组都要做改动</li>
<li><strong>数据冗余</strong>：每位学生都存储了老师的授课信息</li>
</ul>
<h3 id="为什么给主属性留后门">为什么给主属性留后门</h3>
<ul>
<li>一种折衷的考虑</li>
</ul>
<h2 id="bcnf">BCNF</h2>
<ul>
<li>关系模式 <span class="math inline">\(R(U)\)</span> 中,对于属性组
<span class="math inline">\(X,Y\)</span>，若 <span class="math inline">\(X\to Y,Y\not\subseteq X\)</span> ，那么 <span class="math inline">\(X\)</span> 必是码，则 R <span class="math inline">\(\in\)</span> BCNF</li>
<li>BCNF：所有属性都由码直接决定</li>
<li>所有非平凡的函数依赖的左边都需要是候选码</li>
</ul>
<h3 id="如何将关系模式改造成bcnf的">如何将关系模式改造成BCNF的</h3>
<ul>
<li>将属性划归到以决定它的属性作为码的关系模式中</li>
<li>3NF 中的例子 <a href="#STC">STC</a> 是不属于 BCNF 的
<ul>
<li>STC (sno,tno,cno)</li>
<li>修改为 (sno,tno)，(tno,cno)</li>
</ul></li>
</ul>
<h3 id="例子-3">例子</h3>
<ul>
<li>(sno, cno, order) 表示学生选修课程的名次（名次各不相同）</li>
<li>函数依赖
<ul>
<li>(sno, cno) <span class="math inline">\(\to\)</span> order</li>
<li>(cno, order) <span class="math inline">\(\to\)</span> sno</li>
</ul></li>
<li>候选码：(sno, cno) 、(cno, order)</li>
<li>是属于 BCNF 的，函数依赖的左边都是属于候选码</li>
</ul>
<h3 id="nf-和-bcnf-的比较">3NF 和 BCNF 的比较</h3>
<ul>
<li>比较下面两个模式各自的优缺点
<ul>
<li>模式一：STC(sno,tno,cno)</li>
<li>模式二：ST(sno,tno), TC(tno,cno)</li>
</ul></li>
<li>为什么有时会需要 3NF 而非 BCNF 的模式设计？
<ul>
<li>BCNF
可能会导致表分的过碎，表的数目过多，可能对一些复杂的查询造成<strong>性能</strong>上的影响</li>
<li>例如原始的 STC 表中是有函数依赖 (sno,cno) <span class="math inline">\(\to\)</span> tno 的，但是分开成 ST、C
两张表之后，这个函数不能体现了。这样我们可以在 ST
表（全码）中随意插入数据，而这样插入的数据可能不不满足<strong>函数依赖</strong>
(sno,cno) <span class="math inline">\(\to\)</span> tno</li>
</ul></li>
<li><strong>全码是 BCNF 的</strong></li>
</ul>
<h3 id="nf-的另外一种定义">3NF 的另外一种定义</h3>
<ul>
<li>关系模式 R 中的函数依赖 <span class="math inline">\(X\to
Y\)</span>，必须满足下述条件之一：
<ul>
<li><span class="math inline">\(X\to Y\)</span> 是平凡的函数依赖</li>
<li>X 是 R 的码</li>
<li><strong>Y 是主属性</strong></li>
</ul></li>
<li>上面表示，如果 Y 是主属性的话，则不要求 X
是候选码，这样允许函数传递依赖
<ul>
<li>Z <span class="math inline">\(\to\)</span> X <span class="math inline">\(\to\)</span> Y</li>
</ul></li>
<li>3NF 允许存在主属性对码的不良依赖</li>
</ul>
<h3 id="bcnf-不良依赖的例子">BCNF 不良依赖的例子</h3>
<ul>
<li>关系模式 TEACH(cno, tno, bno)</li>
<li>一门课程由多个教员担任</li>
<li>一门课程使用相同的一套参考书</li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507145742043.png" style="zoom:50%;"></p>
<ul>
<li>码是 (cno, tno, bno)，全码，属于 BCNF</li>
<li><strong>数据冗余很严重</strong></li>
<li>如果有一门课程没有参考书的话，就无法插入数据</li>
</ul>
<h3 id="bcnf-的不良依赖">BCNF 的不良依赖</h3>
<ul>
<li><strong>插入异常</strong>：当某门课程增加一名教员时，其有多少本参考书就必须插入多少个元组</li>
<li><strong>删除异常</strong>：当删除一门课程的某个教员或者某本参考书时，需要删除多个元组</li>
<li><strong>更新异常</strong>：当一门课程的教员或参考书作出改变时，需要修改多个元组</li>
<li><strong>数据冗余</strong>：同一门课的教员与参考书的信息被反复存储多次</li>
</ul>
<h3 id="bcnf-冗余的根源">BCNF 冗余的根源</h3>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507150123890.png" style="zoom:50%;"></p>
<ul>
<li>能否使用如下精简的表示</li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507150236800.png" style="zoom:50%;"></p>
<ul>
<li>信息都还在，是完整的</li>
<li>问题
<ul>
<li>语义上是有问题的</li>
<li>删除的时候有问题，删除 B1 会把 T1 也删除掉</li>
</ul></li>
<li><strong>对等原则</strong>：标红的额外两行并不能提供更多信息，他们的存在纯粹是为了保证
tno 和 bno 彼此取值无关</li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507150434164.png" style="zoom:50%;"></p>
<h2 id="多值依赖">多值依赖</h2>
<h3 id="多值依赖的描述型定义">多值依赖的描述型定义</h3>
<ul>
<li>关系模式 <span class="math inline">\(R(U)\)</span>，<span class="math inline">\(X,Y,Z\subseteq U,Z=U-X-Y\)</span>，多值依赖 <span class="math inline">\(X\to\to Y\)</span> 成立当且仅当
<ul>
<li>对 <span class="math inline">\(R(U)\)</span> 的任一关系 <span class="math inline">\(r\)</span>，给定的一对 <span class="math inline">\((x,z)\)</span> 值对应有一组 <span class="math inline">\(Y\)</span> 的值，这组值仅仅决定于 <span class="math inline">\(x\)</span> 值而与 <span class="math inline">\(z\)</span> 值无关</li>
</ul></li>
<li>一个例子：<span id="CTB">CTB</span>
<ul>
<li>cno <span class="math inline">\(\to\to\)</span> tno</li>
</ul></li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507150434164.png" style="zoom:50%;"></p>
<ul>
<li>关系模式中的除法</li>
</ul>
<p><span class="math display">\[
\forall xz,Y_{xz}=Y_x
\]</span></p>
<h3 id="多值依赖的形式化定义">多值依赖的形式化定义</h3>
<ul>
<li>关系模式 <span class="math inline">\(R(U)\)</span>，<span class="math inline">\(X,Y,Z\subseteq U,Z=U-X-Y\)</span></li>
<li>对 <span class="math inline">\(R(U)\)</span> 的任一关系 <span class="math inline">\(r\)</span>，若存在行 <span class="math inline">\(t_1,t_2\)</span> 使得 <span class="math inline">\(t_1[X]=t_2[X]\)</span></li>
<li>那么就必然存在行 <span class="math inline">\(t_3,t_4\)</span>，使得
<span class="math inline">\(t_3=(t_1[X],t_1[Y],t_2[Z]),t_4=(t_2[X],t_2[Y],t_1[Z])\)</span></li>
<li>则称 <span class="math inline">\(Y\)</span> 多值依赖 <span class="math inline">\(X\)</span>，记作 <span class="math inline">\(X\to\to Y\)</span></li>
</ul>
<h4 id="理解">理解</h4>
<ul>
<li>结合上面的例子，交换 t[Z] 之后还是存在在表中，说明 Z 和 Y 无关</li>
<li><strong>对等原则</strong></li>
</ul>
<h3 id="例子-4">例子</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">C</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">a1</td>
<td style="text-align: center;">b1</td>
<td style="text-align: center;">c1</td>
</tr>
<tr class="even">
<td style="text-align: center;">a1</td>
<td style="text-align: center;">b1</td>
<td style="text-align: center;">c2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">a2</td>
<td style="text-align: center;">b1</td>
<td style="text-align: center;">c1</td>
</tr>
<tr class="even">
<td style="text-align: center;">a2</td>
<td style="text-align: center;">b1</td>
<td style="text-align: center;">c3</td>
</tr>
</tbody>
</table>
<ul>
<li>是否满足 <span class="math inline">\(C\to\to B\)</span>
<ul>
<li>满足</li>
<li>交换 A 还在表中</li>
</ul></li>
<li>改成满足 <span class="math inline">\(B\to\to
C\)</span>，需要加入那些行</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">C</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">a1</td>
<td style="text-align: center;">b1</td>
<td style="text-align: center;">c3</td>
</tr>
<tr class="even">
<td style="text-align: center;">a2</td>
<td style="text-align: center;">b1</td>
<td style="text-align: center;">c2</td>
</tr>
</tbody>
</table>
<h3 id="多值依赖的基本性质">多值依赖的基本性质</h3>
<ul>
<li>多值依赖具有<strong>对称性</strong>
<ul>
<li>若 <span class="math inline">\(X\to\to Y\)</span>，则 <span class="math inline">\(X\to\to Z\)</span>，其中 <span class="math inline">\(Z=U-X-Y\)</span></li>
</ul></li>
<li><strong>函数依赖是多值依赖的特例</strong>
<ul>
<li>若 <span class="math inline">\(X\to Y\)</span>，则 <span class="math inline">\(X\to\to Y\)</span></li>
</ul></li>
<li>若 <span class="math inline">\(X\to\to Y\)</span>，<span class="math inline">\(U-X-Y=\emptyset\)</span>，称 <span class="math inline">\(X\to\to Y\)</span>
为<strong>平凡的多值依赖</strong></li>
</ul>
<h2 id="nf-3">4NF</h2>
<ul>
<li>关系模式 <span class="math inline">\(R(U)\in 1NF\)</span>
，对于非平凡的多值依赖 <span class="math inline">\(X\to\to
Y(Y\not\subseteq X)\)</span>，X 含有码，则称 <span class="math inline">\(R\in 4NF\)</span></li>
<li>非 4NF 的主要弊端：<strong>数据冗余非常大</strong></li>
<li>如下，不满足 4NF
<ul>
<li>cno <span class="math inline">\(\to\to\)</span> tno 不满足</li>
<li>cno <span class="math inline">\(\to\to\)</span> bno 不满足</li>
</ul></li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210624235429721.png" style="zoom:50%;"></p>
<h3 id="如何将关系模式改造为4nf的">如何将关系模式改造为4NF的</h3>
<ul>
<li>多值属性单独放在独立的关系模式中</li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507154339812.png" style="zoom:50%;"></p>
<h2 id="多值依赖与函数依赖">多值依赖与函数依赖</h2>
<h3 id="多值依赖与函数依赖的基本区别">多值依赖与函数依赖的基本区别</h3>
<ul>
<li><strong>相等产生依赖</strong>
<ul>
<li><strong>函数依赖</strong>规定某些元组不能出现在关系中</li>
<li>现有的行可能会排斥新来的行</li>
</ul></li>
<li><strong>元组产生依赖</strong>
<ul>
<li><strong>多值依赖</strong>要求某种形式的其它元组必须在关系中</li>
<li>现有的行要求新来的行同时插入一些其他行</li>
</ul></li>
</ul>
<h3 id="多值依赖与函数依赖有效性范围的不同">多值依赖与函数依赖有效性范围的不同</h3>
<ul>
<li><span class="math inline">\(X\to Y\)</span> 的有效性仅决定于 <span class="math inline">\(X,Y\)</span> 属性集上的值,，它在任何属性集 <span class="math inline">\(W(XY\subseteq W\subseteq U)\)</span> 上都成立</li>
<li><span class="math inline">\(X\to\to Y\)</span> 在属性集 <span class="math inline">\(W(XY\subseteq W\subseteq U)\)</span> 上成立，但在
<span class="math inline">\(U\)</span> 上不一定成立
<ul>
<li>只能说明 Y 和 W-X-Y 无关</li>
<li>例如 <span class="math inline">\(A\to\to B\)</span> 在 ABC上成立，在
ABCD 上不一定成立</li>
<li>例子如下</li>
</ul></li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507160447953.png" style="zoom:50%;"></p>
<ul>
<li>有效性
<ul>
<li>监视函数依赖：更新、插入</li>
<li>监视多值依赖：更新、插入、删除</li>
</ul></li>
<li>若 <span class="math inline">\(X\to\to Y\)</span> 在属性集 <span class="math inline">\(W(XY\subseteq W\subseteq U)\)</span> 上成立，则称
<span class="math inline">\(X\to\to Y\)</span> 为 <span class="math inline">\(R(U)\)</span>
的<strong>嵌入式多值依赖</strong></li>
<li>若 <span class="math inline">\(X\to\to Y\)</span> 在属性集
U上成立，则 <span class="math inline">\(X\to\to Y\)</span> 在属性集
<span class="math inline">\(W(XY\subseteq W\subseteq U)\)</span>
上成立</li>
<li>若 <span class="math inline">\(X\to Y\)</span> 在 <span class="math inline">\(R(U)\)</span> 上成立，则对于 <span class="math inline">\(\forall Y&#39;\subseteq Y\)</span> ，均有 <span class="math inline">\(X\to Y&#39;\)</span> 成立</li>
<li>若 <span class="math inline">\(X\to\to Y\)</span> 在 <span class="math inline">\(R(U)\)</span> 上成立，则对于 <span class="math inline">\(\forall Y&#39;\subseteq Y\)</span> ，<span style="color:red;font-weight:bold">不能保证</span>有 <span class="math inline">\(X\to\to Y&#39;\)</span> 成立
<ul>
<li>不能保证 Y' 和 U-X-Y' 是否相关</li>
<li>例子如下</li>
</ul></li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507160447953.png" style="zoom:50%;"></p>
<h3 id="验证函数依赖和多值依赖">验证函数依赖和多值依赖</h3>
<ul>
<li>函数依赖 <span class="math inline">\(A\to B\)</span> ：下式为空</li>
</ul>
<p><span class="math display">\[
\sigma_{R.A=S.A\land R.B\ne S.B}(R\times \rho_S(R))
\]</span></p>
<ul>
<li>多值依赖 <span class="math inline">\(A\to\to B\)</span>
<ul>
<li>C 的取值和 B 无关</li>
</ul></li>
</ul>
<p><span class="math display">\[
R=\prod_{AB}(R)\bowtie\prod_{AC}(R)
\]</span></p>
<h2 id="连接依赖">连接依赖</h2>
<ul>
<li><span class="math inline">\(R_1(U_1),R_2(U_2),\cdots,R_n(U_n)\)</span> 是
<span class="math inline">\(R(U)\)</span> 的一个分解，<span class="math inline">\(r\)</span> 是 <span class="math inline">\(R(U)\)</span> 上的一个关系，若 <span class="math inline">\(r=\bowtie_{i=1}^{n}\prod R_i(r)\)</span></li>
<li>则称 <span class="math inline">\(r\)</span>
满足<strong>连接依赖</strong> <span class="math inline">\({}^\ast(R_1,R_2,\cdots,R_n)\)</span></li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507161727543.png" style="zoom:50%;"></p>
<ul>
<li><strong>说明存在冗余</strong></li>
<li>现实中很少考虑连接依赖，检测代价太高</li>
<li>平凡连接依赖</li>
<li>连接依赖与多值依赖</li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507161852990.png" style="zoom:50%;"></p>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507162027483.png" style="zoom:50%;"></p>
<h2 id="pjnf">PJNF</h2>
<ul>
<li>投影-连接范式（PJNF）</li>
<li>若<span class="math inline">\(R\in PJNF\)</span>，则对于 <span class="math inline">\(R\)</span> 的任一连接依赖 <span class="math inline">\({}^\ast(R_1,R_2,\cdots,R_n)\)</span>
必是下述情况之一：
<ul>
<li><span class="math inline">\({}^\ast(R_1,R_2,\cdots,R_n)\)</span>
是平凡的连接依赖</li>
<li>每个 <span class="math inline">\(R_i\)</span> 是 <span class="math inline">\(R\)</span> 的超码</li>
</ul></li>
</ul>
<h2 id="一些其他问题">一些其他问题</h2>
<ul>
<li>任何一个二目关系模式 <span class="math inline">\(R(A,B)\)</span>
，一定属于 BCNF 吗？一定属于4NF 吗？</li>
<li>一个候选码全是<strong>单属性</strong>的关系模式最高一定可以达到第几范式？</li>
<li>一个全是<strong>主属性</strong>的关系模式最高一定可以达到第几范式？</li>
<li>一个只有一个候选码的 3NF 关系模式是 BCNF 的吗？</li>
<li>一个<strong>全码</strong>的关系模式最高一定可以达到第几范式？</li>
</ul>
<h2 id="各种范式的关系">各种范式的关系</h2>
<ul>
<li>3NF <span class="math inline">\(\in\)</span> 2NF</li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507162525769.png" style="zoom:50%;"></p>
<ul>
<li>BCNF <span class="math inline">\(\in\)</span> 3NF</li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507162539860.png" style="zoom:50%;"></p>
<ul>
<li>PJNF <span class="math inline">\(\in\)</span> 4NF</li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507162558208.png" style="zoom:50%;"></p>
<ul>
<li>总结</li>
</ul>
<p><img src="/2021/05/05/DB/CLJ/05/image-20210507162613036.png" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.07.并发控制(2)</title>
    <url>/2021/06/04/DB/CLJ/07-1/</url>
    <content><![CDATA[<h1 id="并发控制">并发控制</h1>
<h2 id="显示锁类型">显示锁类型</h2>
<h3 id="sql-server-查询">SQL Server 查询</h3>
<ul>
<li>使用 sp_lock 或者查询 sys.dm_tran_locks 视图</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> DBlocks <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> request_session_id <span class="keyword">as</span> spid,</span><br><span class="line">    db_name(resource_database_id) <span class="keyword">as</span> dbname,</span><br><span class="line">    <span class="keyword">CASE</span> <span class="keyword">WHEN</span> resource_type<span class="operator">=</span><span class="string">&#x27;OBJECT&#x27;</span></span><br><span class="line">            <span class="keyword">THEN</span> object_name(resource_associated_entity_id)</span><br><span class="line">        <span class="keyword">WHEN</span> resource_associated_entity_id<span class="operator">=</span><span class="number">0</span></span><br><span class="line">            <span class="keyword">THEN</span><span class="string">&#x27;n/a&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> object_name(p.object_id) <span class="keyword">END</span> <span class="keyword">as</span> entity_name,</span><br><span class="line">    index_id,resource_type <span class="keyword">as</span> resource, resource_description <span class="keyword">as</span> description,</span><br><span class="line">    request_mode <span class="keyword">as</span> mode,</span><br><span class="line">    request_status <span class="keyword">as</span> status</span><br><span class="line"><span class="keyword">FROM</span> sys.dm_tran_locks t LEFTJOIN sys.partitions p</span><br><span class="line">    <span class="keyword">ON</span> p.hobt_id <span class="operator">=</span> t.resource_associated_entity_id</span><br><span class="line"><span class="keyword">WHERE</span> resource_database_id<span class="operator">=</span>db_id()</span><br></pre></td></tr></table></figure>
<h4 id="repeatable-read">repeatable read</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE student</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL REPEATABLE READ</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> AGE<span class="operator">&gt;</span><span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询当前进程的锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Dblocks</span><br><span class="line"><span class="keyword">WHERE</span> spid<span class="operator">=</span>@<span class="variable">@spid</span></span><br><span class="line"><span class="keyword">AND</span> entity_name<span class="operator">=</span><span class="string">&#x27;S&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN</span><br></pre></td></tr></table></figure>
<h4 id="read-committed">read committed</h4>
<ul>
<li>read committed 是短锁，执行完就释放了</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE student</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> AGE<span class="operator">&gt;</span><span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_lock@<span class="variable">@spid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN</span><br></pre></td></tr></table></figure>
<ul>
<li>只有数据库上有一个读锁</li>
</ul>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">spid</th>
<th style="text-align: center;">Database</th>
<th style="text-align: center;">ObjId</th>
<th style="text-align: center;">IndId</th>
<th style="text-align: center;">Type</th>
<th style="text-align: center;">Resource</th>
<th style="text-align: center;">Mode</th>
<th style="text-align: center;">Status</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">DB</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">S</td>
<td style="text-align: center;">GRANT</td>
</tr>
</tbody>
</table>
<h4 id="repeatabel-read">repeatabel read</h4>
<ul>
<li>长锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE student</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL REPEATABLE READ</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> AGE<span class="operator">&gt;</span><span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_lock @<span class="variable">@spid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN</span><br></pre></td></tr></table></figure>
<ul>
<li>自己加读锁，祖先节点加意向读锁
<ul>
<li>聚簇索引，主码上有索引，KEY 来标一条记录</li>
</ul></li>
</ul>
<table>
<colgroup>
<col style="width: 7%">
<col style="width: 14%">
<col style="width: 18%">
<col style="width: 9%">
<col style="width: 7%">
<col style="width: 25%">
<col style="width: 7%">
<col style="width: 10%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">spid</th>
<th style="text-align: center;">Database</th>
<th style="text-align: center;">ObjId</th>
<th style="text-align: center;">IndId</th>
<th style="text-align: center;">Type</th>
<th style="text-align: center;">Resource</th>
<th style="text-align: center;">Mode</th>
<th style="text-align: center;">Status</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">DB</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">S</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="even">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">PAG</td>
<td style="text-align: center;">1:31</td>
<td style="text-align: center;">IS</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">PAG</td>
<td style="text-align: center;">1:30</td>
<td style="text-align: center;">IS</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="even">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">KEY</td>
<td style="text-align: center;">(930085dfee46)</td>
<td style="text-align: center;">S</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">TAB</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">IS</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="even">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">KEY</td>
<td style="text-align: center;">(a8007c139223)</td>
<td style="text-align: center;">S</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">KEY</td>
<td style="text-align: center;">(ab008cdbe580)</td>
<td style="text-align: center;">S</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="even">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">KEY</td>
<td style="text-align: center;">(930022f0d614)</td>
<td style="text-align: center;">S</td>
<td style="text-align: center;">GRANT</td>
</tr>
</tbody>
</table>
<h4 id="serializable">serializable</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE student</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> AGE<span class="operator">&gt;</span><span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_lock@<span class="variable">@spid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN</span><br></pre></td></tr></table></figure>
<ul>
<li>为了防止幻象，得加码范围锁</li>
</ul>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 13%">
<col style="width: 16%">
<col style="width: 8%">
<col style="width: 6%">
<col style="width: 23%">
<col style="width: 13%">
<col style="width: 10%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">spid</th>
<th style="text-align: center;">Database</th>
<th style="text-align: center;">ObjId</th>
<th style="text-align: center;">IndId</th>
<th style="text-align: center;">Type</th>
<th style="text-align: center;">Resource</th>
<th style="text-align: center;">Mode</th>
<th style="text-align: center;">Status</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">DB</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">S</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="even">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">PAG</td>
<td style="text-align: center;">1:31</td>
<td style="text-align: center;">IS</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">PAG</td>
<td style="text-align: center;">1:30</td>
<td style="text-align: center;">IS</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="even">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">KEY</td>
<td style="text-align: center;">(930085dfee46)</td>
<td style="text-align: center;">S</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">TAB</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">IS</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="even">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">KEY</td>
<td style="text-align: center;">(a8007c139223)</td>
<td style="text-align: center;">RangeS-S</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">KEY</td>
<td style="text-align: center;">(ab008cdbe580)</td>
<td style="text-align: center;">RangeS-S</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="even">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">KEY</td>
<td style="text-align: center;">(ffffffffffff)</td>
<td style="text-align: center;">RangeS-S</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">51</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">KEY</td>
<td style="text-align: center;">(930022f0d614)</td>
<td style="text-align: center;">S</td>
<td style="text-align: center;">GRANT</td>
</tr>
</tbody>
</table>
<h3 id="sql-server-更新">SQL Server 更新</h3>
<h4 id="read-committed-1">read committed</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE student</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> S</span><br><span class="line"><span class="keyword">SET</span> SEX<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">WHERE</span> AGE<span class="operator">&gt;</span><span class="number">20</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_lock@<span class="variable">@spid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span> TRAN</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 7%">
<col style="width: 14%">
<col style="width: 18%">
<col style="width: 9%">
<col style="width: 7%">
<col style="width: 25%">
<col style="width: 7%">
<col style="width: 10%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">spid</th>
<th style="text-align: center;">Database</th>
<th style="text-align: center;">ObjId</th>
<th style="text-align: center;">IndId</th>
<th style="text-align: center;">Type</th>
<th style="text-align: center;">Resource</th>
<th style="text-align: center;">Mode</th>
<th style="text-align: center;">Status</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">52</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">DB</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">S</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="even">
<td style="text-align: center;">52</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">PAG</td>
<td style="text-align: center;">1:30</td>
<td style="text-align: center;">IX</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">52</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">KEY</td>
<td style="text-align: center;">(930085dfee46)</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="even">
<td style="text-align: center;">52</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">TAB</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">IX</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">52</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2025058250</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">KEY</td>
<td style="text-align: center;">(930022f0d614)</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">GRANT</td>
</tr>
</tbody>
</table>
<h3 id="sql-server-创建表">SQL Server 创建表</h3>
<h4 id="read-committed-2">read committed</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE student</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">INTO</span> OldS</span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> AGE<span class="operator">&gt;</span><span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_lock2@<span class="variable">@spid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN</span><br></pre></td></tr></table></figure>
<ul>
<li>创建表加写锁</li>
<li>Sch-M 模式修改锁，避免在建表的时候其他事务访问它</li>
</ul>
<table style="width:100%;">
<colgroup>
<col style="width: 7%">
<col style="width: 14%">
<col style="width: 17%">
<col style="width: 8%">
<col style="width: 12%">
<col style="width: 14%">
<col style="width: 15%">
<col style="width: 10%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">spid</th>
<th style="text-align: center;">Database</th>
<th style="text-align: center;">ObjId</th>
<th style="text-align: center;">IndId</th>
<th style="text-align: center;">Type</th>
<th style="text-align: center;">Resource</th>
<th style="text-align: center;">Mode</th>
<th style="text-align: center;">Status</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">54</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><strong>EXT</strong></td>
<td style="text-align: center;">1:112</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="even">
<td style="text-align: center;">54</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">PAG</td>
<td style="text-align: center;">1:127</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">54</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">PAG</td>
<td style="text-align: center;">1:124</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="even">
<td style="text-align: center;">54</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">PAG</td>
<td style="text-align: center;">1:125</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">54</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">PAG</td>
<td style="text-align: center;">1:122</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="even">
<td style="text-align: center;">54</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">PAG</td>
<td style="text-align: center;">1:123</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">54</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">PAG</td>
<td style="text-align: center;">1:120</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="even">
<td style="text-align: center;">54</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">PAG</td>
<td style="text-align: center;">1:121</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">54</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2041058307</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><strong>TAB</strong></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><strong>Sch-M</strong></td>
<td style="text-align: center;">GRANT</td>
</tr>
</tbody>
</table>
<h3 id="sql-server-行锁">SQL Server 行锁</h3>
<h4 id="read-committed-3">read committed</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE student</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"><span class="keyword">UPDATE</span> OldS</span><br><span class="line"><span class="keyword">SET</span> SNAME<span class="operator">=</span><span class="string">&#x27;王非&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> S# <span class="operator">=</span> <span class="string">&#x27;s1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_lock@<span class="variable">@spid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN</span><br></pre></td></tr></table></figure>
<ul>
<li>SQL Server 没有指定主码，则不会建立聚簇索引，是一个无序的堆表
<ul>
<li>Row ID
<ul>
<li>文件号：文件里面的页面号：页面内的偏移</li>
</ul></li>
<li>MySQL 会默认有一个自增的字段</li>
</ul></li>
</ul>
<table>
<colgroup>
<col style="width: 4%">
<col style="width: 9%">
<col style="width: 12%">
<col style="width: 6%">
<col style="width: 45%">
<col style="width: 9%">
<col style="width: 4%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">spid</th>
<th style="text-align: center;">Database</th>
<th style="text-align: center;">ObjId</th>
<th style="text-align: center;">IndId</th>
<th style="text-align: center;">Type</th>
<th style="text-align: center;">Resource</th>
<th style="text-align: center;">Mode</th>
<th style="text-align: center;">Status</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">52</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">DB</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">S</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="even">
<td style="text-align: center;">52</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2073058421</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">PAG</td>
<td style="text-align: center;">1:96</td>
<td style="text-align: center;">IX</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">52</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2073058421</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><strong><span style="color:red">RID</span></strong></td>
<td style="text-align: center;">1:96:0</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">GRANT</td>
</tr>
<tr class="even">
<td style="text-align: center;">52</td>
<td style="text-align: center;">student</td>
<td style="text-align: center;">2073058421</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">TAB</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">IX</td>
<td style="text-align: center;">GRANT</td>
</tr>
</tbody>
</table>
<h3 id="mysql-的锁字典表">MySQL 的锁字典表</h3>
<h4 id="innodb_trx">innodb_trx</h4>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 69%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">字段名</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">trx_id</td>
<td style="text-align: center;">事务id</td>
</tr>
<tr class="even">
<td style="text-align: center;">trx_state</td>
<td style="text-align: center;">事务状态</td>
</tr>
<tr class="odd">
<td style="text-align: center;">trx_started</td>
<td style="text-align: center;">事务开始时间</td>
</tr>
<tr class="even">
<td style="text-align: center;">trx_requested_lock_id</td>
<td style="text-align: center;">等待事务的锁id</td>
</tr>
<tr class="odd">
<td style="text-align: center;">trx_wait_started</td>
<td style="text-align: center;">事务等待开始的时间</td>
</tr>
<tr class="even">
<td style="text-align: center;">trx_weight</td>
<td style="text-align: center;">事务的权重，锁住的行数，死锁时回滚权重最小的事务</td>
</tr>
<tr class="odd">
<td style="text-align: center;">trx_mysql_thread_id</td>
<td style="text-align: center;">线程id</td>
</tr>
<tr class="even">
<td style="text-align: center;">trx_query</td>
<td style="text-align: center;">事务运行的sql语句</td>
</tr>
</tbody>
</table>
<h4 id="innodb_locks">innodb_locks</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字段名</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">lock_id</td>
<td style="text-align: center;">锁id</td>
</tr>
<tr class="even">
<td style="text-align: center;">lock_trx_id</td>
<td style="text-align: center;">事务id</td>
</tr>
<tr class="odd">
<td style="text-align: center;">lock_mode</td>
<td style="text-align: center;">锁模式</td>
</tr>
<tr class="even">
<td style="text-align: center;">lock_type</td>
<td style="text-align: center;">锁类型，表锁还是行锁</td>
</tr>
<tr class="odd">
<td style="text-align: center;">lock_table</td>
<td style="text-align: center;">锁定的表</td>
</tr>
<tr class="even">
<td style="text-align: center;">lock_index</td>
<td style="text-align: center;">锁定的索引</td>
</tr>
<tr class="odd">
<td style="text-align: center;">lock_space</td>
<td style="text-align: center;">锁对象的space id</td>
</tr>
<tr class="even">
<td style="text-align: center;">lock_page</td>
<td style="text-align: center;">锁定的页</td>
</tr>
<tr class="odd">
<td style="text-align: center;">lock_rec</td>
<td style="text-align: center;">锁定的行</td>
</tr>
<tr class="even">
<td style="text-align: center;">lock_data</td>
<td style="text-align: center;">锁定行的主码</td>
</tr>
</tbody>
</table>
<h4 id="innodb_lock_waits">innodb_lock_waits</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字段名</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">requesting_trx_id</td>
<td style="text-align: center;">申请锁资源的事务id</td>
</tr>
<tr class="even">
<td style="text-align: center;">requesting_lock_id</td>
<td style="text-align: center;">事务正在申请的锁的id</td>
</tr>
<tr class="odd">
<td style="text-align: center;">blocking_trx_id</td>
<td style="text-align: center;">阻塞的事务id</td>
</tr>
<tr class="even">
<td style="text-align: center;">blocking_lock_id</td>
<td style="text-align: center;">阻塞的锁的id</td>
</tr>
</tbody>
</table>
<h2 id="各种操作下的锁授予">各种操作下的锁授予</h2>
<ul>
<li>以查询为例
<ul>
<li>当你发出一个查询请求之后，数据库会先经过一个查询优化器，确定一个执行计划（直接扫描表/借助某个索引），系统会对执行计划的每一个路径加锁</li>
</ul></li>
</ul>
<h3 id="聚簇表和堆表的不同sql-server">聚簇表和堆表的不同（SQL
Server）</h3>
<ul>
<li>ClusterOrders：基于 OrderID 的聚簇表
<ul>
<li>在 ClusterOrders 的 ShipName 上建有非聚簇索引</li>
</ul></li>
<li>HeapOrders：堆表
<ul>
<li>在 HeapOrders 的 EmployeeID 上建有非聚簇索引</li>
</ul></li>
</ul>
<h4 id="查询">查询</h4>
<h5 id="聚簇表基于聚簇索引的查找">聚簇表：基于聚簇索引的查找</h5>
<ul>
<li>索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> ClusterOrders</span><br><span class="line"><span class="keyword">where</span> OrderID<span class="operator">=</span><span class="number">10250</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612173334329.png" style="zoom:150%;"></p>
<h5 id="堆表基于非索引项的查找">堆表：基于非索引项的查找</h5>
<ul>
<li>RID</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> HeapOrders</span><br><span class="line"><span class="keyword">where</span> OrderID<span class="operator">=</span><span class="number">10250</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612173417287.png" style="zoom:150%;"></p>
<h5 id="堆表基于非聚簇索引的查找">堆表：基于非聚簇索引的查找</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> HeapOrders</span><br><span class="line"><span class="keyword">where</span> EmploeeID <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行计划如下
<ul>
<li>先在非聚簇索引上查找，找到满足条件的索引码之后再到原表中查找</li>
<li>现在满足条件的非聚簇索引上加锁，然后在 RID 上加锁</li>
</ul></li>
</ul>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612173903573.png" style="zoom:150%;"></p>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612173624408.png" style="zoom:150%;"></p>
<ul>
<li>当修改查询语句如下时，查询计划改变了
<ul>
<li>为什么？</li>
<li>系统发现在索引中有很多满足条件的项，基于索引反而是低效的</li>
<li>转变为基于<strong>表扫描</strong>的查找</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> HeapOrders</span><br><span class="line"><span class="keyword">where</span> EmploeeID<span class="operator">=</span><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612174447634.png" style="zoom:150%;"></p>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612174503222.png" style="zoom:150%;"></p>
<h4 id="删除">删除</h4>
<h5 id="堆表删除行操作非索引">堆表：删除行操作（非索引）</h5>
<ul>
<li>RID 加写锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> HeapOrders</span><br><span class="line"><span class="keyword">where</span> orderID<span class="operator">=</span><span class="number">10253</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612174657367.png" style="zoom:150%;"></p>
<h5 id="堆表删除行操作索引非聚簇索引">堆表：删除行操作（索引、非聚簇索引）</h5>
<ul>
<li>索引码、原表中对应的行都得加写锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> HeapOrders</span><br><span class="line"><span class="keyword">where</span> EmployeeID <span class="operator">=</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612174853968.png" style="zoom:150%;"></p>
<h4 id="更新">更新</h4>
<h5 id="堆表基于非聚簇索引的更新操作">堆表：基于非聚簇索引的更新操作</h5>
<ul>
<li>索引、RID 加写锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> HeapOrders</span><br><span class="line"><span class="keyword">set</span> ShipVia <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">where</span> EmployeeID <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612195145842.png" style="zoom:150%;"></p>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612195357141.png" style="zoom:150%;"></p>
<h5 id="聚簇表更新操作">聚簇表：更新操作</h5>
<ul>
<li>只有索引表需要加锁
<ul>
<li>因为 ShipName 上有非聚簇索引，同时需要给这些记录加写锁</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> ClusterOrders</span><br><span class="line"><span class="keyword">set</span> ShipName <span class="operator">=</span> <span class="string">&#x27;tatatata&#x27;</span></span><br><span class="line"><span class="keyword">where</span> OrderID <span class="operator">=</span> <span class="number">10255</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612195530118.png" style="zoom:150%;"></p>
<h3 id="缺少索引而引起的阻塞sql-server">缺少索引而引起的阻塞（SQL
Server）</h3>
<ul>
<li><strong>建立索引能够减少减少阻塞的情况，能够提高索引的并发度</strong></li>
</ul>
<h4 id="没有索引的情况">没有索引的情况</h4>
<ul>
<li>建立两个表 T1、T2</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T1(id <span class="type">int</span>, col1 <span class="type">char</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T2(id <span class="type">int</span>, col2 <span class="type">char</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T1 <span class="keyword">values</span> (<span class="number">101</span>,<span class="string">&#x27;A&#x27;</span>), (<span class="number">102</span>,<span class="string">&#x27;B&#x27;</span>), (<span class="number">103</span>,<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T2 <span class="keyword">values</span> (<span class="number">201</span>,<span class="string">&#x27;A&#x27;</span>), (<span class="number">202</span>,<span class="string">&#x27;B&#x27;</span>), (<span class="number">203</span>,<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>事务 1</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span> tran</span><br><span class="line"><span class="keyword">update</span> T1</span><br><span class="line"><span class="keyword">set</span> col1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> <span class="number">101</span></span><br></pre></td></tr></table></figure>
<ul>
<li>事务 2</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span> tran</span><br><span class="line"><span class="keyword">update</span> T1</span><br><span class="line"><span class="keyword">set</span> col1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> <span class="number">103</span></span><br></pre></td></tr></table></figure>
<ul>
<li>实际过程中，事务 2 被事务 1 阻塞了
<ul>
<li>事务 1 加了写锁，更新事务在更新完整个表之后才会释放所有的锁
<ul>
<li>这样的原因如下
<ul>
<li>举个例子，如果更新完一条记录就释放这条记录上的锁，事务 1 更新完 A
记录后马上释放锁，此时事务 2 也更新 A 记录，但是事务 2
出现错误，需要回滚，此时出现问题，回滚之后把事务 2 的更新也回滚掉了</li>
</ul></li>
<li>SQL Server 的更新操作
<ul>
<li>先把所有满足条件的行找出来，此时会申请 U
锁（先读后写），满足条件的行被更新时升级为写锁</li>
</ul></li>
</ul></li>
<li>事务 2 在通过 where 查询整个表的时候，查询被事务 1
锁住的记录的时候，被阻塞</li>
</ul></li>
<li>输出两个进程持有锁的情况</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 事务 1 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Dblocks</span><br><span class="line"><span class="keyword">WHERE</span> spid<span class="operator">=</span><span class="number">52</span></span><br><span class="line"><span class="keyword">AND</span> entity_name<span class="operator">=</span><span class="string">&#x27;T1&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612200436574.png" style="zoom: 67%;"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 事务 2 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Dblocks</span><br><span class="line"><span class="keyword">WHERE</span> spid<span class="operator">=</span><span class="number">54</span></span><br><span class="line"><span class="keyword">AND</span> entity_name<span class="operator">=</span><span class="string">&#x27;T1&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612201349846.png" style="zoom:67%;"></p>
<ul>
<li>注意上面事务 2 的行探查阶段申请的是 U 锁</li>
</ul>
<h4 id="在-id-上建立索引">在 id 上建立索引</h4>
<ul>
<li>在更新的时候不需要扫描所有行，可以通过索引直接定位到行</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_T1_id <span class="keyword">on</span> T1(id)</span><br></pre></td></tr></table></figure>
<ul>
<li>此时不会出现事务 2 被事务 1 挂起的情况，锁持有情况如下
<ul>
<li>先加 U 锁，更新的时候再升级为写锁</li>
</ul></li>
</ul>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612203132870.png" style="zoom:150%;"></p>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612203151601.png" style="zoom:150%;"></p>
<h3 id="mysql-的当前读">MySQL 的当前读</h3>
<ul>
<li><strong>当前读</strong>：特殊的读操作，需要加锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? lock <span class="keyword">in</span> share mode</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">values</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> ? <span class="keyword">where</span> ?</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?</span><br></pre></td></tr></table></figure>
<h3 id="mysql-加锁处理分析">MySQL 加锁处理分析</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SQL1 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SQL2 */</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>前提
<ul>
<li>前提一：id列是不是主键？</li>
<li>前提二：当前系统的隔离级别是什么？</li>
<li>前提三：id列如果不是主键，那么id列上有索引吗？</li>
<li>前提四：id列上如果有二级索引，这个索引是唯一索引吗？</li>
<li>前提五：两个SQL的执行计划是什么？索引扫描？全表扫描？</li>
</ul></li>
<li>通过对前提的不同组合会有不同的结果</li>
<li>组合
<ul>
<li>组合一：id列是主键，RC隔离级别</li>
<li>组合二：id列是二级唯一索引，RC隔离级别</li>
<li>组合三：id列是二级非唯一索引，RC隔离级别</li>
<li>组合四：id列上没有索引，RC隔离级别</li>
<li>组合五：id列是主键，RR隔离级别</li>
<li>组合六：id列是二级唯一索引，RR隔离级别</li>
<li>组合七：id列是二级非唯一索引，RR隔离级别</li>
<li>组合八：id列上没有索引，RR隔离级别</li>
<li>组合九：Serializable隔离级别</li>
</ul></li>
</ul>
<h4 id="组合一id主键rc">组合一：id主键+RC</h4>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612205745033.png" style="zoom: 67%;"></p>
<h4 id="组合二id唯一索引rc">组合二：id唯一索引+RC</h4>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612210128618.png" style="zoom:67%;"></p>
<h4 id="组合三id非唯一索引rc">组合三：id非唯一索引+RC</h4>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612210240187.png" style="zoom: 80%;"></p>
<h4 id="组合四id无索引rc">组合四：id无索引+RC</h4>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612210313852.png" style="zoom:67%;"></p>
<h4 id="组合七id非唯一索引rr">组合七：id非唯一索引+RR</h4>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612210408732.png" style="zoom:80%;"></p>
<h4 id="组合八id无索引rr">组合八：id无索引+RR</h4>
<p><img src="/2021/06/04/DB/CLJ/07-1/image-20210612210600528.png" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.07.并发控制(3)</title>
    <url>/2021/06/12/DB/CLJ/07-2/</url>
    <content><![CDATA[<h1 id="并发控制">并发控制</h1>
<h2 id="锁的实现">锁的实现</h2>
<ul>
<li><strong>锁管理器</strong>、<strong>锁表</strong></li>
<li>锁管理器
<ul>
<li>事务向锁管理器发送封锁请求和释放请求</li>
<li>锁管理器维护一个锁表记录锁的授予情况和处于等待状态的封锁请求</li>
</ul></li>
<li>锁表
<ul>
<li>锁表一般作为内存中的 hash 表，按被封锁对象的名字建立索引</li>
</ul></li>
</ul>
<h3 id="锁表结构">锁表结构</h3>
<ul>
<li>内存中的哈希表</li>
</ul>
<p><img src="/2021/06/12/DB/CLJ/07-2/image-20210612214643658.png" style="zoom:67%;"></p>
<ul>
<li>黑矩形表示已被授予的锁，白色表示等待的封锁请求</li>
<li>锁表同时记录锁的类型
<ul>
<li>需要检查锁是否想容</li>
</ul></li>
<li>新的封锁请求加到对应请求队列的<strong>末尾</strong>，当封锁请求与前面的锁相容时被批准</li>
<li><strong>释放</strong>封锁时请求从队列中<strong>删除</strong>并<strong>检查后续请求是否满足</strong></li>
<li>如果<strong>事务放弃</strong>，<strong>所有授予的和等待的锁请求都被删除</strong>
<ul>
<li>为提高效率，<strong>锁管理器会记录每个事务持有锁的情况</strong></li>
<li>红线：把一个事务所有的锁串成一个链</li>
</ul></li>
<li>封锁资源如下
<ul>
<li>但是锁管理器对资源一无所知，它只是 ”memcmp()”</li>
<li>锁管理器不需要去区分被锁的是什么逻辑单元，只需要将这个字符串锁起来即可</li>
</ul></li>
</ul>
<p><img src="/2021/06/12/DB/CLJ/07-2/image-20210612215429062.png" style="zoom:67%;"></p>
<h3 id="锁升级sql-server">锁升级（SQL Server）</h3>
<ul>
<li>这里的锁升级不是强度上的升级（读锁升级为写锁），而是粒度上的升级（行锁升级为表锁）</li>
<li><strong>行锁太多的时候</strong>，我们可以把这些行锁升级为表锁</li>
<li>封锁开销与并发度的 trade off</li>
</ul>
<p><img src="/2021/06/12/DB/CLJ/07-2/image-20210612215648266.png" style="zoom:67%;"></p>
<ul>
<li>行锁代价高、并发度高</li>
<li>表锁代价低、并发度低</li>
</ul>
<h4 id="锁升级的定义与操作">锁升级的定义与操作</h4>
<ul>
<li>锁升级是将<strong>众多细粒度锁</strong>转换为<strong>较少的粗粒度的锁</strong>的过程，以削减系统开销</li>
<li>当事务超过它的升级极限时，系统自动将行锁和页锁升级为表锁</li>
<li>当事务从表中请求行时，系统获取相应行上的锁，并在包含这些行的页和表上放置意向锁。当事务控制的锁数量超过其极限时，系统将表上的意向锁更改为更强的锁（如将IX锁更改为X锁），释放事务持有的所有页级锁和行级锁，从而削减锁的开销。</li>
</ul>
<h3 id="mysql-没有锁升级">MySQL 没有锁升级</h3>
<ul>
<li>InnoDB 不存在锁升级的问题</li>
<li>InnoDB
不是根据每个记录来产生行锁，而是<strong>根据页进行加锁，并采用位图方式定位到行</strong>，锁住页中一个记录还是多个记录，其开销是一样的</li>
</ul>
<h4 id="开销对比">开销对比</h4>
<ul>
<li>假设一张表有 <span class="math inline">\(3\times10^6\)</span>
个数据页，每个页大约有 <span class="math inline">\(100\)</span>
条记录，那么总共有 <span class="math inline">\(3\times10^8\)</span>
条记录。</li>
<li>若有一个事务执行全表更新的 SQL 语句，则需要对所有记录加 X 锁</li>
<li>若根据每行记录产生锁对象进行加锁，并且每个锁占用 <span class="math inline">\(10\)</span> 字节，则仅对锁管理就需要差不多需要
<span class="math inline">\(3\mathrm{GB}\)</span> 的内存</li>
<li>而 InnoDB
存储引擎根据页进行加锁，并采用位图方式，假设每个页存储的锁信息占用 <span class="math inline">\(30\)</span> 个字节，则锁对象仅需 <span class="math inline">\(90\mathrm{MB}\)</span> 的内存
<ul>
<li><span class="math inline">\(30\)</span> 字节：位图 <span class="math inline">\(\dfrac{100}{8}=12.5\)</span>，加上一些其他信息</li>
</ul></li>
<li>由此可见两者对于锁资源开销的差距之大</li>
</ul>
<h2 id="封锁带来的问题">封锁带来的问题</h2>
<h3 id="死锁deadlock">死锁(Deadlock)</h3>
<ul>
<li>两个事务都封锁了一些数据对象，并相互等待对方释放另一些数据对象以便对其封锁，结果两个事务都不能结束，则发生死锁</li>
</ul>
<p><img src="/2021/06/12/DB/CLJ/07-2/image-20210612221909284.png" style="zoom: 33%;"></p>
<ul>
<li>死锁发生的条件（4）
<ul>
<li><ol type="1">
<li><strong>互斥条件</strong>：事务请求对资源的独占控制</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>占有等待条件</strong>：事务已持有一定资源，又去申请并等待其它资源</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>非抢占条件</strong>：直到资源被持有它的事务释放之前，不能将该资源强制从持有它的事务夺去</li>
</ol></li>
<li><ol start="4" type="1">
<li><strong>循环等待条件</strong>：存在事务相互等待的等待圈</li>
</ol></li>
</ul></li>
<li>定理：<strong>在条件 (1)(2)(3) 成立的前提下，条件 (4)
是死锁存在的充分必要条件</strong></li>
</ul>
<h4 id="一个例子">一个例子</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>事务号</strong></th>
<th style="text-align: center;"><strong>占有资源号</strong></th>
<th style="text-align: center;"><strong>请求资源号</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">T1</td>
<td style="text-align: center;">R1</td>
<td style="text-align: center;">R2</td>
</tr>
<tr class="even">
<td style="text-align: center;">T2</td>
<td style="text-align: center;">R3</td>
<td style="text-align: center;">R1，R2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T3</td>
<td style="text-align: center;">R2</td>
<td style="text-align: center;">R3</td>
</tr>
</tbody>
</table>
<pre class="mermaid">graph LR;
T1[T1]--->T3[T3]
T2--->T1
T2--->T3
T3--->T2</pre>
<ul>
<li>在数据库中定期扫描锁表，如果发现死锁，则破坏第 3
个条件（回滚某个事务）
<ul>
<li>系统同时会向这个事务发送一个信号</li>
<li>SQL Server：<strong>1205</strong></li>
</ul></li>
</ul>
<h4 id="循环死锁例子">循环死锁例子</h4>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">事务1</th>
<th style="text-align: center;">事务2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">begin tran<br>update S<br>set sname=
'张三'<br>where sno= ' S1'</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">begin tran<br>update C<br>set cname=
'数据库基础'<br>where cno= ' c1'</td>
</tr>
<tr class="odd">
<td style="text-align: center;">update C<br>set cname=
'数据库教程'<br>WHERE cno= ' c1'<br>commit tran</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">update S<br>set sname= '李四'<br>where
sno= ' S1'<br>commit tran</td>
</tr>
</tbody>
</table>
<h4 id="转换死锁例子">转换死锁例子</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> transaction isolation level repeatable read</span><br><span class="line"><span class="keyword">begin</span> tran</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> sno<span class="operator">=</span><span class="string">&#x27;S1&#x27;</span></span><br><span class="line">waitfor delay <span class="string">&#x27;00:00:10&#x27;</span></span><br><span class="line"><span class="keyword">update</span> S</span><br><span class="line"><span class="keyword">set</span> sname<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span></span><br><span class="line"><span class="keyword">where</span> sno<span class="operator">=</span><span class="string">&#x27;S1&#x27;</span></span><br><span class="line"><span class="keyword">commit</span> tran</span><br></pre></td></tr></table></figure>
<ul>
<li><p>两个事务都执行如上代码，都是先读后写，死锁</p></li>
<li><p>解决方案</p>
<ul>
<li>调整事务的隔离性级别</li>
<li>强制 SQL Server 使用更新锁</li>
</ul>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> S (UPDLOCK)</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="因缺少索引而导致死锁">因缺少索引而导致死锁</h4>
<ul>
<li>扫描全表导致的相互阻塞</li>
<li>可以通过显示锁表展示死锁信息</li>
</ul>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">事务1</th>
<th style="text-align: center;">事务2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">begin tran<br>update T1<br>set col1 =
'a'<br>where id = 101</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">begin tran<br>update T2<br>set col2 =
'a'<br>where id = 201</td>
</tr>
<tr class="odd">
<td style="text-align: center;">select col2<br>from T2<br>where id =
203</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">select col1<br>from T1<br>where id =
103</td>
</tr>
</tbody>
</table>
<h3 id="预防死锁">预防死锁</h3>
<h4 id="破坏占有等待条件">破坏占有等待条件</h4>
<ul>
<li>死锁根源：T1 持有 R1，申请 R2；T2 持有 R2，申请 R1</li>
<li><strong>预先占据所需的全部资源</strong>
<ul>
<li>要么一次全部封锁，要么全不封锁</li>
<li>缺点：<strong>难于预知需要封锁哪些数据并且数据使用率低</strong></li>
</ul></li>
<li><strong>所有资源预先排序，事务按规定顺序封锁数据</strong>
<ul>
<li>按照相同的资源顺序获取锁</li>
<li>不允许 T3 在没有获得资源 R1 时就去获取 R3</li>
</ul></li>
</ul>
<p><img src="/2021/06/12/DB/CLJ/07-2/image-20210612225653498.png" style="zoom:67%;"></p>
<h4 id="破坏非抢占条件">破坏非抢占条件</h4>
<ul>
<li>人为规定一个优先级，将非抢占式转化为抢占式</li>
<li><strong>使用抢占与事务回滚</strong>
<ul>
<li><strong>规定老事务优先级高于新事务</strong></li>
</ul></li>
<li>下图为例，不允许两个箭头同时出现即可</li>
</ul>
<p><img src="/2021/06/12/DB/CLJ/07-2/image-20210612231229609.png" style="zoom:50%;"></p>
<ul>
<li>死锁序列
<ul>
<li>start(T1), start(T2), w1(R1), w2(R2), r1(R2), r2(R1)</li>
</ul></li>
<li><strong>注意以下两种策略，在任何时候都是回滚优先级低的新事物</strong></li>
<li>策略1：<strong>wait-die</strong>
<ul>
<li>如果 T1 等待 T2，仅当 T1 的时间戳小于 T2 时，允许 T1 等待，否则回滚
T1</li>
<li>执行结果：r2(R1) 时触发，回滚 T2</li>
</ul></li>
</ul>
<p><img src="/2021/06/12/DB/CLJ/07-2/image-20210612231540349.png" style="zoom:50%;"></p>
<ul>
<li>策略2：<strong>wound-wait</strong>
<ul>
<li>如果 T1 等待 T2，仅当 T1 的时间戳大于 T2 时，允许 T1 等待，否则回滚
T2</li>
<li>r1(R2) 时触发，回滚 T2</li>
</ul></li>
</ul>
<p><img src="/2021/06/12/DB/CLJ/07-2/image-20210612231658264.png" style="zoom:50%;"></p>
<ul>
<li>在实际数据库中以上的预防方法都不适用，一般都是通过死锁检测找到死锁，然后接触死锁
<ul>
<li><strong>超时法</strong>：如果等待封锁的时间超过限时，则撤消该事务</li>
<li><strong>等待图法</strong>：LOCK_MONITOR</li>
</ul></li>
</ul>
<h3 id="活锁live-lock">活锁(live lock)</h3>
<ul>
<li>可能存在某个事务永远处于等待状态，得不到执行，称之为<strong>活锁（饿死）</strong></li>
<li>饥饿例子：读者优先策略
<ul>
<li>T2 持有对 R 的 S 锁，T1 申请对 R 的 X 锁，则 T1 必须等待 T2 释放 S
锁；若在 T2 完成之前有 T3 申请对 R 的 S 锁，则可以获得授权封锁，于是 T1
必须等待 T2、T3 释放 S 锁</li>
</ul></li>
<li>避免活锁的策略是遵从“<strong>先来先服务”</strong>
的原则，按请求封锁的顺序对各事务排队
<ul>
<li>降低了系统的并发度（总吞吐量）</li>
</ul></li>
<li>先来先服务
<ul>
<li>当事务 Ti 对数据项 R 加 M 型锁时，获得封锁的条件是
<ul>
<li>不存在在 R 上持有与 M 型锁冲突的锁的其他事务</li>
<li>不存在等待对 R 加锁且先于 Ti 申请加锁的事务</li>
</ul></li>
</ul></li>
</ul>
<h2 id="使用绑定连接">使用绑定连接</h2>
<ul>
<li>一个事务对应多个连接的需求</li>
<li><strong>绑定连接</strong>
<ul>
<li>绑定连接允许两个或多个连接共享同一个事务和锁定</li>
<li>绑定连接可以对同一个数据进行操作，而不会有锁冲突</li>
</ul></li>
<li>把不同的连接上的操作绑定在同一个事务中
<ul>
<li>sp_getbindtoken：返回事务的唯一标识符，将其作为绑定令牌</li>
<li>sp_bindsession：绑定与同一 SQL Server 实例中的其它事务的连接</li>
</ul></li>
</ul>
<h2 id="锁定提示">锁定提示</h2>
<ul>
<li>一般而言，操作加的锁是由数据库系统本身决定的，但是我们可以添加一些要求加什么锁的提示</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> table_name[<span class="keyword">with</span> (lock hint)]</span><br></pre></td></tr></table></figure>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">holdlock</td>
<td style="text-align: center;">readuncommitted</td>
</tr>
<tr class="even">
<td style="text-align: center;">updlock</td>
<td style="text-align: center;">readcommitted</td>
</tr>
<tr class="odd">
<td style="text-align: center;">xlock</td>
<td style="text-align: center;">repeatableread</td>
</tr>
<tr class="even">
<td style="text-align: center;">tablock</td>
<td style="text-align: center;">serializable</td>
</tr>
<tr class="odd">
<td style="text-align: center;">paglock</td>
<td style="text-align: center;">readcommittedlock</td>
</tr>
<tr class="even">
<td style="text-align: center;">tablockx</td>
<td style="text-align: center;">nolock</td>
</tr>
<tr class="odd">
<td style="text-align: center;">rowlock</td>
<td style="text-align: center;">readpast</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.07.并发控制(4)</title>
    <url>/2021/06/13/DB/CLJ/07-3/</url>
    <content><![CDATA[<h1 id="并发控制">并发控制</h1>
<ul>
<li>传统的数据库，Oracle、SQL Server
都是基于封锁来实现的，但是也有其他的并发控制方式</li>
</ul>
<h2 id="基于时间戳的协议">基于时间戳的协议</h2>
<ul>
<li><strong>时间戳</strong>
<ul>
<li>每个事务 Ti 进入系统被分配一个时间戳 TS(Ti)</li>
<li>如果 Tj 晚于 Ti 进入系统，TS(Ti)&lt;TS(Tj)</li>
<li>回滚的事务重新启动，分配新的时间戳</li>
</ul></li>
<li>时间戳顺序决定了串行化顺序，<strong>回滚违反发出串行性操作的事务</strong>
<ul>
<li><strong>整个调度必须和按照他们的时间戳顺序的串行调度等价</strong></li>
<li>检测冲突，一旦检测到冲突，则按照上述规则回滚某个事务</li>
</ul></li>
<li>每个数据项Q有两个时间戳与之联系
<ul>
<li>数据项上的读写时间戳，数据项上的读写时间戳是所有操作该数据项的事务中最大的时间戳</li>
<li>WT(Q)：执行 write(Q) 的事务中最大的时间戳</li>
<li>RT(Q)：执行 read(Q) 的事务中最大的时间戳</li>
</ul></li>
</ul>
<h3 id="问题">问题</h3>
<h4 id="可能的脏读">可能的脏读</h4>
<ul>
<li>start1, w1(R), start2, r2(R), abort_t1</li>
<li>T1 事务回滚了，T2 事务读到的 R 是 T1 写的
R，是脏读（不是正确的数据项）</li>
<li>解决方案：为每一个数据项设置一个提交位
<ul>
<li><strong>提交位</strong> C(R)：拥有 R 上写时间戳的事务是否提交</li>
<li>r2(R) 发现 R 上的提交位没有被设置为 1（尚未被提交），此时等待</li>
</ul></li>
</ul>
<h4 id="跳过的写">跳过的写</h4>
<ul>
<li>start1, start2, w2(R), w1(R)
<ul>
<li>与时间戳顺序等价的串行调度为：start1, start2, w1(R), w2(R)</li>
<li>于是最后会检测到 w1(R) 不满足时间戳的协议，回滚掉事务 T1</li>
</ul></li>
<li>实际上我们没有必要回滚事务 T1，把 w1(R) 忽略掉即可
<ul>
<li>满足时间戳的串行调度，w1(R) 在前面也会被覆盖，因此只需要把 w1(R)
忽略即可</li>
</ul></li>
</ul>
<h5 id="thomas-写规则">Thomas 写规则</h5>
<ul>
<li>写操作在更晚的写操作已经发生时可以跳过</li>
</ul>
<h3 id="执行时间戳协议">执行时间戳协议</h3>
<h4 id="读操作">读操作</h4>
<ul>
<li>假定事务 Ti 发出 read(Q)</li>
</ul>
<h5 id="过晚的读">过晚的读</h5>
<ul>
<li>本来应该是在别人写之前读，但是别人写完你才读</li>
<li>如果 TS(Ti)&lt;WT(Q)，则 Ti 需读入的值已经被覆盖，read
操作被拒绝，<strong>回滚 Ti</strong></li>
<li>start1, start2, w2(R), r1(R)
<ul>
<li>此时 r1(R) 已经违反了时间戳协议，回滚事务 T1</li>
</ul></li>
</ul>
<h5 id="正常的读">正常的读</h5>
<ul>
<li>正常的读 TS(Ti) <span class="math inline">\(\ge\)</span> WT(Q)</li>
<li>若 C(Q) 为真则执行 read 操作，RT(Q) =
max(RT(Q),TS(Ti))，若为假则推迟到 C(Q) 为真或写 Q 的事务中止</li>
<li>start2, start1, w2(R), r1(R)</li>
</ul>
<h4 id="写操作">写操作</h4>
<ul>
<li>假定事务 Ti 发出 write(Q)</li>
</ul>
<h5 id="过晚的写">过晚的写</h5>
<ul>
<li>本来应该是在别人读之前写，但是别人读完你才写</li>
<li>如果 TS(Ti)&lt;RT(Q)，则 Ti 产生的 Q 值是先前所需要的值，write
操作被拒绝，回滚Ti</li>
<li>start1, start2, r2(R), w1(R)
<ul>
<li>此时 w1(R) 不满足时间戳协议，回滚事务 T1</li>
</ul></li>
</ul>
<h5 id="正常的写">正常的写</h5>
<ul>
<li>正常的写：TS(Ti) &gt; RT(Q)</li>
<li>TS(Ti) &gt; RT(Q)，并且 TS(Ti) &gt;
WT(Q)，执行write操作，WT(Q)＝TS(Ti)</li>
<li>start1, start2, start3, r1(R), w2(R), w3(R)</li>
</ul>
<h5 id="忽略的写">忽略的写</h5>
<ul>
<li>Thomas 写规则</li>
<li>TS(Ti) &gt; RT(Q)，但是TS(Ti) &lt; WT(Q)，跳过 write 操作</li>
<li>start1, start2, start3, w2(R), r3(R), w1(R)</li>
<li>跳过 w1(R) 操作</li>
</ul>
<h3 id="一个例子">一个例子</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">T1</th>
<th style="text-align: center;">T2</th>
<th style="text-align: center;">T3</th>
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">C</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">200</td>
<td style="text-align: center;">150</td>
<td style="text-align: center;">175</td>
<td style="text-align: center;">RT=0<br>WT=0</td>
<td style="text-align: center;">RT=0<br>WT=0</td>
<td style="text-align: center;">RT=0<br>WT=0</td>
</tr>
<tr class="even">
<td style="text-align: center;">r1(B)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">RT=200</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">r2(A)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">RT=150</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">r3(C)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">RT=175</td>
</tr>
<tr class="odd">
<td style="text-align: center;">w1(B)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">WT=200</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">w1(A)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">WT=200</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">w2(C)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">RT=0</td>
<td style="text-align: center;">过晚的写<br>回滚T2</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">中止</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">w3(A)</td>
<td style="text-align: center;">忽略的写</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h2 id="有效性检查协议">有效性检查协议</h2>
<ul>
<li>把事务的过程分为 3 个阶段
<ul>
<li>读阶段、有效性检查阶段、写阶段</li>
</ul></li>
</ul>
<h3 id="三阶段">三阶段</h3>
<h4 id="读阶段">读阶段</h4>
<ul>
<li><p>事务 Ti 在这一阶段中执行</p></li>
<li><p>各数据项值被读入并保存在 Ti
的<strong>局部变量</strong>中</p></li>
<li><p><strong>所有 write
操作都是对局部临时变量进行的，并不对数据库进行真正的更新</strong></p></li>
</ul>
<h4 id="有效性检查阶段">有效性检查阶段</h4>
<ul>
<li>Ti
进行有效性检查，通过与其他事务的读写集合进行比较，来判定是否可以将 write
操作所更新的临时局部变量值拷入数据库而不违反可串行性</li>
</ul>
<h4 id="写阶段">写阶段</h4>
<ul>
<li>若 Ti 通过有效性检查，则进行实际的数据库更新，否则 Ti 回滚</li>
</ul>
<h3 id="三个时间戳">三个时间戳</h3>
<ul>
<li>每个事务 Ti 有 <strong>3</strong> 个时间戳与之联系
<ul>
<li>Start(Ti)：Ti <strong>开始</strong>执行的时间</li>
<li>Validation(Ti)：Ti <strong>进入</strong>其有效性检查阶段的时间</li>
<li>Finish(Ti)：Ti <strong>完成</strong>其写阶段的时间</li>
</ul></li>
<li>令TS(Ti) = Validation(Ti)，等价的串行顺序与有效性确认时间戳一致</li>
</ul>
<h3 id="违反串行性的情况">违反串行性的情况</h3>
<h4 id="规则-1">规则 1</h4>
<ul>
<li><span class="math inline">\({\color{red}\mathrm{if}}\;\mathrm{finish(U)&gt;start(T)}\;{\color{red}\mathrm{then}}\;\mathrm{RS(T)\bigcap
WS(U)=\Phi}\)</span></li>
<li>避免过早地读</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/07-3/image-20210613110906866.png" style="zoom:67%;"></p>
<h4 id="规则-2">规则 2</h4>
<ul>
<li><span class="math inline">\({\color{red}\mathrm{if}}\;\mathrm{finish(U)&gt;validation(T)}\;{\color{red}\mathrm{then}}\;\mathrm{WS(T)\bigcap
WS(U)=\Phi}\)</span></li>
<li>避免过早的写</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/07-3/image-20210613111322706.png" style="zoom:67%;"></p>
<h3 id="一个有效性检查的例子">一个有效性检查的例子</h3>
<p><img src="/2021/06/13/DB/CLJ/07-3/image-20210613112124549.png" style="zoom:67%;"></p>
<ul>
<li>确认T2：在T1完成写入之前开始，可能先于T1的写入进行读写，需要判断T1的写集合与T2读集合的相交性，同时判断T1的写集合与T2的写集合的相交性
<ul>
<li>写判断，防止 T2 的写在 T1 之前</li>
</ul></li>
<li>确认T3：在T1完成写入之后开始，不需要判定T3和T1的相交性；在T2完成写入之前开始，需要判断T2的写集合与T3读集合的相交性；T2在T3确认前完成，不需要判定T3的写集合和T2的写集合的相交性</li>
</ul>
<h3 id="例子2">例子2</h3>
<p><img src="/2021/06/13/DB/CLJ/07-3/image-20210613112605153.png" style="zoom:67%;"></p>
<ul>
<li>确认 U
<ul>
<li>最早的确认，通过</li>
</ul></li>
<li>确认 T
<ul>
<li>U 写、T 读：通过</li>
<li>U 写、T 写：通过</li>
</ul></li>
<li>确认 V
<ul>
<li>U 写、V 读：通过</li>
<li>T 写、V 读：通过</li>
<li>T 写、V 写：通过</li>
</ul></li>
<li>确认 W
<ul>
<li>W 读之前，U 已经 finish，不需要比较</li>
<li>T 写、W 读：<strong>未通过</strong></li>
<li>V 写、W 写：通过</li>
<li>V 写、W 读：<strong>未通过</strong></li>
</ul></li>
</ul>
<h2 id="mvcc">MVCC</h2>
<ul>
<li>MVCC：Multiple Version Concurrent Control</li>
<li>以下是 MySQL 对于 MVCC 的实现</li>
</ul>
<h2 id="mysql-一致性非锁定读">MySQL 一致性非锁定读</h2>
<ul>
<li>一致性非锁定读（consistent nonlocking read）</li>
<li>多版本实现的并发控制</li>
</ul>
<h3 id="说明">说明</h3>
<ul>
<li>在 read committed 和 repeatable read 下 InnoDB
使用非锁定的一致性读</li>
<li>read committed
的非一致性读总是读取被锁定行的<strong>最新</strong>一份快照数据
<ul>
<li><strong>语句开始的版本</strong></li>
</ul></li>
<li>repeatable read
的非一致性读总是读取<strong>事务开始</strong>时的行数据版本</li>
</ul>
<h3 id="三个隐藏列">三个隐藏列</h3>
<ul>
<li>InnoDB 为每行数据增加三个隐藏列用于实现 MVCC</li>
<li>DB_TRX_ID
<ul>
<li>插入或更新行的<strong>最后一个事务的事务标识符（</strong>删除视为更新，将其标记为已删除）</li>
</ul></li>
<li>DB_ROLL_PTR
<ul>
<li>写入回滚段的撤消日志记录（若行已更新，则撤消日志记录包含在更新行之前重建行内容所需的信息）</li>
<li>将所有的老版本通过一个指针串起来</li>
</ul></li>
<li>DB_ROW_ID：行标识（隐藏单调自增id）</li>
<li><strong>快照存放在日志 undo 段中</strong></li>
<li>InnoDB 新版本的数据是叶子结点的值，老版本的数据则通过 UNDO
记录存储在回滚段（Rollback Segment）中</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/07-3/image-20210613115931178.png" style="zoom: 40%;"></p>
<h3 id="可见性算法">可见性算法</h3>
<ul>
<li>read-view：事务在进行快照读的时候会创建一个读视图</li>
<li>在执行读操作的时候，基于读视图判定当前行对于读操作是否可见</li>
<li>一些数据段
<ul>
<li>alive_trx_list：读视图生成时刻系统中正在活跃的事务 id</li>
<li>up_limit_id：记录上面的 alive_trx_list 中的最小事务
id（最老的事务）</li>
<li>low_limit_id：读视图生成时刻，目前已出现的事务 ID 的最大值 +1</li>
</ul></li>
<li>判定
<ul>
<li>判断这条记录的 DB_TRX_ID 是否是小于 up_limit_id 或者等于当前事务 id
<ul>
<li>若是，则当前事务能看到这条记录</li>
</ul></li>
<li>判断这条记录的 DB_TRX_ID 是否大于等于 low-limit-id
<ul>
<li>如果大于等于则说明此事务无法看见该条记录</li>
</ul></li>
<li>判断该条记录的 DB_TRX_ID 是否在活跃事务的数组中
<ul>
<li>如果在则说明这条记录还未提交，对于当前操作的事务是不可见的</li>
<li>如果不在则说明已经提交，则是可见的
<ul>
<li>这种情况是当前事务一开始之后很短的时间内，开始后很快就提交了</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/07-3/image-20210613120615944.png"></p>
<ul>
<li>对于 read committed 来说，每读一次都会生成新的读视图</li>
<li>对于 repeatable read 来说，读视图时是事务一开始就确定不变的</li>
</ul>
<h3 id="pg-与-mysql-写操作的不同">PG 与 MySQL 写操作的不同</h3>
<ul>
<li>PG 对写操作也是乐观并发控制
<ul>
<li><strong>在表中保存同一行数据记录的多个不同版本</strong>，每次写操作，都是创建，而回避更新
<ul>
<li>PG 有表膨胀的问题</li>
<li>MySQL 把老版本放在回滚段里</li>
</ul></li>
<li>在事务提交时，按版本号检查当前事务提交的数据是否存在写冲突，抛异常告知用户，回滚事务</li>
</ul></li>
<li>innodb 只对读无锁，写操作仍是上锁的悲观并发控制
<ul>
<li>每行数据只在表中保留一份，在更新数据时上行锁，同时将旧版数据写入
undo log</li>
<li>表和 undo log 中行数据都记录着事务
ID，在检索时，只读取来自当前已提交的事务的行数据</li>
</ul></li>
</ul>
<h3 id="sql-server-中查看多版本">SQL Server 中查看多版本</h3>
<ul>
<li>tempdb</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/07-3/image-20210613122121649.png" style="zoom:50%;"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> database ljchen</span><br><span class="line"><span class="keyword">set</span> allow_snapshot_isolation <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> faculty</span><br><span class="line"><span class="keyword">set</span> salary<span class="operator">=</span>salary<span class="operator">*</span><span class="number">1.01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> sys.dm_tran_version_store</span><br></pre></td></tr></table></figure>
<h3 id="mvcc-论文">MVCC 论文</h3>
<ul>
<li>An Empirical Evaluation of In-Memory Multi-Version Concurrency
Control</li>
<li>设计要点
<ul>
<li>并发控制 (ConcurrencyControl)</li>
<li>版本存储 (VersionStorage)</li>
<li>垃圾回收 (GarbageCollection)</li>
<li>索引管理 (Indexmanagement)</li>
</ul></li>
</ul>
<h2 id="mysql-一致性锁定读">MySQL 一致性锁定读</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对读取的行加 X 锁 */</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对读取的行加 S 锁 */</span></span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/13/DB/CLJ/07-3/image-20210613121728756.png" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.07.并发控制</title>
    <url>/2021/05/25/DB/CLJ/07/</url>
    <content><![CDATA[<h1 id="并发控制">并发控制</h1>
<ul>
<li>并发问题</li>
<li>资源争用</li>
<li>关键：调度</li>
</ul>
<h2 id="两段锁协议">两段锁协议</h2>
<h3 id="封锁的定义">封锁的定义</h3>
<ul>
<li>封锁就是一个事务对某个数据对象加锁，取得对它一定的控制，限制其它事务对该数据对象使用</li>
<li>要访问一个数据项 <span class="math inline">\(R\)</span>，事务 <span class="math inline">\(T_i\)</span> 必须先申请对 <span class="math inline">\(R\)</span> 的封锁，如果 <span class="math inline">\(R\)</span> 已经被事务 <span class="math inline">\(T_j\)</span> 加了不相容的锁，则 <span class="math inline">\(T_i\)</span> 需要等待，直至 <span class="math inline">\(T_j\)</span> 释放它的封锁</li>
<li>例子：信号灯</li>
<li>封锁性能
<ul>
<li>事务吞吐量</li>
<li>TPC-C：测数据库事务性能
<ul>
<li>目前的第一：Ocean Base（阿里）</li>
</ul></li>
</ul></li>
<li>一些其他的指标
<ul>
<li>TPC-H：测数据库的大数据分析处理能力</li>
</ul></li>
<li>数据库追求的目标：在避免冲突的前提下，提高事务吞吐量（提高并发度）</li>
</ul>
<h3 id="锁持有期">锁持有期</h3>
<ul>
<li>长锁：保持到事务结束时才释放的锁</li>
<li>短锁：在事务中途就可以释放的锁</li>
<li>例子
<ul>
<li>read uncommitted：不申请锁</li>
<li>read committed：短 S 锁</li>
<li>repeatable read：长 S 锁</li>
</ul></li>
</ul>
<h3 id="两段锁协议-1">两段锁协议</h3>
<ul>
<li>Two-Phase Locking Protocol</li>
<li>事务加锁和解锁过程是严格分开的</li>
<li><strong>增长阶段</strong>（Growing Phase）
<ul>
<li>事务可以获得锁，但不能释放锁</li>
</ul></li>
<li><strong>缩减阶段</strong>（Shrinking Phase）
<ul>
<li>事务可以释放锁，但不能获得锁</li>
</ul></li>
<li>图示</li>
</ul>
<p><img src="/2021/05/25/DB/CLJ/07/image-20210603213524078.png" style="zoom:60%;"></p>
<ul>
<li>哪个事务隔离性级别不满足 2PL（两段锁协议）
<ul>
<li>read committed</li>
</ul></li>
</ul>
<h4 id="两阶段封锁协议的作用">两阶段封锁协议的作用</h4>
<ul>
<li>若一组事务均服从两阶段封锁协议，则它们的调度一定是<strong>可串行化</strong>的</li>
<li><strong>封锁点</strong>：事务获得其最后封锁的时间
<ul>
<li>获得最后一个锁的时间</li>
</ul></li>
<li><strong>事务调度等价于和其封锁点顺序一致的串行调度</strong></li>
<li>例子
<ul>
<li>如下图，t1, t2, t3 满足 2PL 则等价的串行顺序是 t1, t3, t2</li>
</ul></li>
</ul>
<p><img src="/2021/05/25/DB/CLJ/07/image-20210603214644809.png" style="zoom: 67%;"></p>
<h4 id="为什么两阶段封锁协议保证可串行化">为什么两阶段封锁协议保证可串行化？</h4>
<ul>
<li>令 <span class="math inline">\(\{T_0,T_1,\cdots,T_n\}\)</span>
是参与调度 <span class="math inline">\(S\)</span> 的事务集</li>
<li>如果 <span class="math inline">\(T_i\)</span> 对数据项 <span class="math inline">\(R\)</span> 加 <span class="math inline">\(A\)</span> 型锁，<span class="math inline">\(T_j\)</span> 对数据项 <span class="math inline">\(R\)</span> 加 <span class="math inline">\(B\)</span> 型锁，且 <span class="math inline">\(\mathrm{comp(A,B)=false}\)</span>（不相容的锁），若
<span class="math inline">\(T_i\)</span> 先获得锁，则 <span class="math inline">\(T_i\)</span> 先于 <span class="math inline">\(T_j\)</span>，记作 <span class="math inline">\(T_i\to T_j\)</span>，得到一个优先图</li>
<li>设 <span class="math inline">\(t_i\)</span>是 <span class="math inline">\(T_i\)</span> 的封锁点，若 <span class="math inline">\(T_i\to T_j\)</span>，则必然有 <span class="math inline">\(t_i&lt;t_j\)</span>
<ul>
<li>事务 <span class="math inline">\(T_j\)</span> 需要等待 <span class="math inline">\(T_i\)</span>
释放不相容的锁之后，才能获得锁，不妨设这个时间为 <span class="math inline">\(t_m\)</span></li>
<li><span class="math inline">\(t_i&lt;t_m\le t_j\)</span></li>
</ul></li>
<li>若 <span class="math inline">\(\{T_0,T_1,\cdots,T_n\}\)</span>
不可串行化，则在优先图中存在环，不妨设为 <span class="math inline">\(T_0\to T_1\to\cdots\to T_n\to T_0\)</span>，则
<span class="math inline">\(t_0&lt;t_1&lt;\cdots&lt;t_n&lt;t_0\)</span>，时间不可能成环，矛盾</li>
</ul>
<h2 id="封锁类型">封锁类型</h2>
<ul>
<li>基本锁类型：X 锁、S 锁、U 锁</li>
<li>意向锁：IS、IX、IU、SIX</li>
<li>码范围锁：RangeS_S、RangeI_N…</li>
<li>其他锁：模式锁、闩锁、BU锁</li>
</ul>
<h3 id="基本锁类型排他锁共享锁更新锁">基本锁类型（排他锁、共享锁、更新锁）</h3>
<h4 id="排他锁与共享锁">排他锁与共享锁</h4>
<ul>
<li>排它锁（X 锁，eXclusive lock）
<ul>
<li>lock-X(R)：又称写锁，持有 X 锁可以读写数据项</li>
<li>事务 T 对数据对象 R 加上 X 锁，则其它事务对 R
的<strong>任何封锁请求都不能成功</strong>，直至 T 释放 R 上的 X 锁</li>
</ul></li>
<li>共享锁（S 锁，Share lock）
<ul>
<li>lock-S(R)：又称读锁，持有 S 锁只能读取数据项</li>
<li>事务 T 对数据对象 R 加上 S 锁，则其它事务对 R 的 <strong>X
锁请求不能成功</strong>，而对 R 的 <strong>S
锁请求可以成功</strong></li>
</ul></li>
<li>封锁的相容矩阵 <span class="math inline">\(\mathrm{comp(A,B)}\)</span></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">请求锁模式A  现有锁模式B</th>
<th style="text-align: center;">S</th>
<th style="text-align: center;">X</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">S</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">X</td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
</tr>
</tbody>
</table>
<h4 id="先读后写场合中的锁转换">先读后写场合中的锁转换</h4>
<ul>
<li>两个事务 T1, T2
<ul>
<li>T1: read(a1); read(a2); ...; read(an); write(a1)</li>
<li>T2: read(a1); ...</li>
</ul></li>
<li>T1 需要对 a1 加 X 锁（因为后面要写）
<ul>
<li>这样的方案是不好的，因为 T2 无法执行</li>
</ul></li>
<li>更好的并发方式
<ul>
<li>T1 在 read(a1) 上加 S 锁，在执行 write(a1) 之前升级锁（upgrade）为 X
锁</li>
<li>升级的时候要求没有事务在 a1 上持有锁</li>
</ul></li>
<li>如下左图等价于串行调度 T1,T2，右图等价于串行调度 T2,T1</li>
</ul>
<p><img src="/2021/05/25/DB/CLJ/07/image-20210603221848187.png"></p>
<h4 id="带有锁转换的两段锁协议">带有锁转换的两段锁协议</h4>
<ul>
<li><strong>增长阶段</strong>
<ul>
<li>可获得 lock-S</li>
<li>可获得 lock-X</li>
<li><strong>可将 lock-S 升级为 lock-X（upgrade）</strong></li>
</ul></li>
<li><strong>缩减阶段</strong>
<ul>
<li>可释放 lock-S</li>
<li>可释放 lock-X</li>
<li><strong>可将 lock-X 降级为 lock-S（downgrade）</strong></li>
</ul></li>
</ul>
<h4 id="锁升级与重新申请锁">锁升级与重新申请锁</h4>
<ul>
<li>升级锁和重新申请锁的区别
<ul>
<li>申请锁是维护一个队列的
<ul>
<li>重新申请锁则会排在队列的最后</li>
<li>升级锁则会排在队列的前面，可能更早考虑</li>
</ul></li>
</ul></li>
<li>在那个隔离性级别下会出现锁升级
<ul>
<li>repeatable read</li>
<li>read committed 不会，因为是短 S 锁</li>
</ul></li>
</ul>
<h4 id="锁转化带来的问题">锁转化带来的问题</h4>
<ul>
<li>死锁</li>
<li>两个事务都是<strong>先读后写</strong></li>
<li><span id="ex1">如下例子</span>
<ul>
<li>repeatable read 情况下（read 为长 S 锁）
<ul>
<li>T1 在 write(a1) 时需要锁升级，但是如果此时 T2 已经执行到了 read(a1)
之后，此时 T1 等待</li>
<li>同样的道理 T2 也等待，导致死锁</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/05/25/DB/CLJ/07/image-20210603233000188.png" style="zoom:67%;"></p>
<h4 id="怎么避免锁转换导致的死锁">怎么避免锁转换导致的死锁</h4>
<ul>
<li>引入更新锁（U 锁）</li>
</ul>
<h4 id="更新锁">更新锁</h4>
<ul>
<li>U 锁，Update lock
<ul>
<li><strong>只有读权限</strong></li>
</ul></li>
<li>当一个事务查询数据以便将来要进行修改时，可以对数据项施加更新锁
<ul>
<li>先读后写的操作申请 U 锁</li>
<li>只读则申请 S 锁</li>
</ul></li>
<li>如果事务修改资源，需将更新锁转换为排它锁（X 锁）</li>
<li>一次只有一个事务可以获得资源上的更新锁
<ul>
<li>这样就避免了死锁</li>
<li>U 锁和 U 锁不相容，因此<a href="#ex1">上面的例子</a></li>
</ul></li>
</ul>
<h5 id="更新锁的相容矩阵">更新锁的相容矩阵</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">请求锁模式A  现有锁模式B</th>
<th style="text-align: center;">S</th>
<th style="text-align: center;">X</th>
<th style="text-align: center;">U</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">S</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">X</td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">U</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
</tr>
</tbody>
</table>
<h3 id="封锁粒度">封锁粒度</h3>
<ul>
<li>封锁对象
<ul>
<li>属性值、属性值集合、元组、关系、索引项、整个索引、整个数据库、物理页、块</li>
</ul></li>
<li>不同封锁粒度
<ul>
<li>封锁粒度大，则并发度低，开销小</li>
<li>封锁粒度小，则并发度高，开销高</li>
</ul></li>
<li>一个锁在数据库中大概占据 100 来个字节</li>
<li>事务的完整性相关域：
<ul>
<li>只封锁与操作有关的的数据对象</li>
</ul></li>
</ul>
<h4 id="封锁粒度与查询性能">封锁粒度与查询性能</h4>
<ul>
<li>一份早期的数据，数据表<strong>五道口技工学院</strong>中性别为女的记录非常少</li>
<li>满足条件的数据非常少时，最佳粒度为<strong>行锁</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> 五道口技工学院</span><br><span class="line"><span class="keyword">where</span> 性别<span class="operator">=</span><span class="string">&#x27;女&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>满足条件的数据非常多时，最佳粒度为<strong>表锁</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> 五道口技工学院</span><br><span class="line"><span class="keyword">where</span> 性别<span class="operator">=</span><span class="string">&#x27;男&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>系统必须支持多粒度锁，根据查询范围选择最佳粒度</li>
</ul>
<h4 id="多粒度封锁中的隐含冲突">多粒度封锁中的隐含冲突</h4>
<ul>
<li>事务 T1（表锁）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> 五道口技工学院</span><br><span class="line"><span class="keyword">where</span> 性别<span class="operator">=</span><span class="string">&#x27;男&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>事务 T2（表锁）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 修改表的属性 */</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 五道口技工学院</span><br></pre></td></tr></table></figure>
<ul>
<li>事务 T3</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> 五道口技工学院</span><br><span class="line"><span class="keyword">where</span> 性别<span class="operator">=</span><span class="string">&#x27;女&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>T1 和 T2 的冲突是能够检测出来的
<ul>
<li>锁表中有表的 id</li>
</ul></li>
<li>事务 T2 和 T3 的冲突无法检测
<ul>
<li>锁表中只有行 id 和表 id，无法检测</li>
</ul></li>
<li>冲突无法检测的原因：大集合中包含小集合，存在包含冲突
<ul>
<li>在分层封锁中，封锁了上层节点就意味着封锁了所有内层节点</li>
<li>如果有事务 T3 对某元组加了 S 锁，而事务 T2 对该元组所在的关系加了 X
锁，因而隐含地 X 封锁了该元组，从而造成矛盾</li>
</ul></li>
</ul>
<p><img src="/2021/05/25/DB/CLJ/07/image-20210604114515233.png" style="zoom: 50%;"></p>
<ul>
<li>在对某个粒度加锁的同时，在其父节点贴上告示条，表示被占用
<ul>
<li>告示条和告示条之间不冲突</li>
<li>告示条告诉别人不能直接加锁</li>
<li>告示条只起到提示作用</li>
</ul></li>
<li>引入意向锁（起到告示条的作用）</li>
</ul>
<h3 id="意向锁">意向锁</h3>
<h4 id="意向锁-iintend">意向锁 I（Intend）</h4>
<ul>
<li>引入意向锁 I（Intend）</li>
<li>当为某节点加上 I
锁，表明其某些内层节点已发生事实上的封锁，防止其它事务再去显式封锁该节点</li>
<li>I
锁的实施是<strong>从封锁层次的根开始</strong>，依次占据路径上的所有节点，直至要真正进行显式封锁的节点的<strong>父节点</strong>为止</li>
</ul>
<h5 id="意向锁-i-的相容性">意向锁 I 的相容性</h5>
<table>
<colgroup>
<col style="width: 31%">
<col style="width: 26%">
<col style="width: 10%">
<col style="width: 31%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">请求锁模式A  现有锁模式B</th>
<th style="text-align: center;">S</th>
<th style="text-align: center;">X</th>
<th style="text-align: center;">I</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">S</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\times}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">X</td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">I</td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\times}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\checkmark}\)</span></td>
</tr>
</tbody>
</table>
<h5 id="意向锁-i-的不足之处">意向锁 I 的不足之处</h5>
<ul>
<li>能够防范读写冲突</li>
</ul>
<p><img src="/2021/05/25/DB/CLJ/07/image-20210604115935940.png" style="zoom: 67%;"></p>
<ul>
<li>让读读操作变成了不相容</li>
</ul>
<p><img src="/2021/05/25/DB/CLJ/07/image-20210604120016324.png" style="zoom:67%;"></p>
<ul>
<li>降低了并发度</li>
<li>根本原因：<strong>I 锁没有告诉我们内层加的锁的类型</strong></li>
<li>引入意向锁 IS 锁，IX 锁</li>
</ul>
<h4 id="更为精细化的意向锁is-锁ix-锁">更为精细化的意向锁（IS 锁，IX
锁）</h4>
<ul>
<li><strong>IS 锁</strong>：如果对一个数据对象加 IS
锁，表示它的后裔节点拟（意向）加 S 锁</li>
<li><strong>IX 锁</strong>：如果对一个数据对象加 IX
锁，表示它的后裔节点拟（意向）加 X 锁</li>
<li>本质还是意向锁，起到告示条的作用</li>
</ul>
<h5 id="意向锁-isix-的相容性">意向锁 IS/IX 的相容性</h5>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 17%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">请求锁模式A  现有锁模式B</th>
<th style="text-align: center;">S</th>
<th style="text-align: center;">X</th>
<th style="text-align: center;">IS</th>
<th style="text-align: center;">IX</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">S</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\checkmark}\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\times}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">X</td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\times}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">IS</td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\checkmark}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\checkmark}\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\checkmark}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">IX</td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\times}\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\times}\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\checkmark}\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\checkmark}\)</span></td>
</tr>
</tbody>
</table>
<h5 id="实际例子">实际例子</h5>
<ul>
<li>能够防范读写冲突</li>
</ul>
<p><img src="/2021/05/25/DB/CLJ/07/image-20210604120643062.png" style="zoom:67%;"></p>
<ul>
<li>读读操作还是相容的
<ul>
<li>解决了简单的意向锁 I 降低了并发度的问题</li>
</ul></li>
</ul>
<p><img src="/2021/05/25/DB/CLJ/07/image-20210604120726693.png" style="zoom:67%;"></p>
<h4 id="共享与意向排他锁-six">共享与意向排他锁 SIX</h4>
<ul>
<li><strong>共享</strong>、<strong>意向排他</strong>
<ul>
<li><strong>S + IX</strong></li>
</ul></li>
<li>解决如下事务的加锁问题
<ul>
<li>在表的级别应该加什么锁呢？</li>
<li>IX 和 S 单独都不能支持这个操作</li>
<li>X 锁并发性很低</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> transaction isolation level repeatable read</span><br><span class="line"><span class="keyword">begin</span> tran <span class="string">&#x27;audit&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> bigtable</span><br><span class="line"><span class="keyword">update</span> bigtable</span><br><span class="line"><span class="keyword">set</span> col <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">where</span> keycolumn <span class="operator">=</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在表上加 SIX 锁，则表示该事务要读整个表（S
锁），同时会更新个别元组（IX 锁）</li>
<li>SIX 锁只和 IS 锁相容
<ul>
<li>找同时与 S 锁和 IX 锁相容的锁</li>
</ul></li>
</ul>
<h5 id="相容矩阵">相容矩阵</h5>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 15%">
<col style="width: 13%">
<col style="width: 7%">
<col style="width: 15%">
<col style="width: 15%">
<col style="width: 15%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">请求锁模式A  现有锁模式B</th>
<th style="text-align: center;">S</th>
<th style="text-align: center;">X</th>
<th style="text-align: center;">U</th>
<th style="text-align: center;">IS</th>
<th style="text-align: center;">IX</th>
<th style="text-align: center;">SIX</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">S</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\checkmark}\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\times}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">X</td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\times}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">U</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">IS</td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\checkmark}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\checkmark}\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\checkmark}\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\checkmark}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">IX</td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\times}\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\times}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\checkmark}\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\checkmark}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">SIX</td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\checkmark}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
</tr>
</tbody>
</table>
<h3 id="sql-server-的锁模式">SQL Server 的锁模式</h3>
<p><img src="/2021/05/25/DB/CLJ/07/image-20210604135729531.png" style="zoom: 67%;"></p>
<h4 id="模式修改锁sch-m锁">模式修改锁（Sch-M锁）</h4>
<ul>
<li>执行表的 DDL 操作时使用模式修改锁</li>
<li>Sch-M 锁与所有锁模式都不相容</li>
</ul>
<h4 id="模式稳定锁sch-s锁">模式稳定锁（Sch-S锁）</h4>
<ul>
<li>当编译查询时，使用模式稳定锁</li>
<li>Sch-S 锁与除了 Sch-M 锁之外所有其它锁模式相容</li>
<li>此时其它事务都能继续运行，但不能对表执行 DDL 操作</li>
</ul>
<h4 id="sql-server中的大容量更新锁">SQL Server中的大容量更新锁</h4>
<ul>
<li>BU 锁，Bulk update lock</li>
<li>当使用 <code>bulk insert</code> 命令或 <code>bcp</code>
工具将数据大容量复制到表，且指定了 <code>TABLOCK</code> 提示或者使用
<code>sp_tableoption</code> 设置了 <code>table lock on bulk</code>
表选项时，将使用大容量更新锁</li>
<li>大容量更新锁允许多个进程将数据并行地大容量复制到同一表，同时防止其它不进行大容量复制数据的进程访问该表</li>
</ul>
<h3 id="sql-server-码范围锁">SQL Server 码范围锁</h3>
<ul>
<li>如何避免<strong>幻象</strong>的产生</li>
<li><strong>只封锁现有数据是无效的</strong></li>
<li>查询例子</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> R <span class="keyword">where</span> A<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> A<span class="operator">&lt;=</span><span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>应该防止其他事务往区间 <span class="math inline">\([10,20]\)</span>
插入数据
<ul>
<li>如何防止？</li>
</ul></li>
<li>如何找到这样一个区间？</li>
<li>表本身是无序的集合，只能用整个表覆盖这个区间，也即需要申请表级锁，并发度极低</li>
<li>数据库中什么对象是有序的？
<ul>
<li>索引是有序的</li>
</ul></li>
<li>如果在 A 上存在索引，则可以找到一个紧凑区间</li>
</ul>
<h4 id="码范围锁范围扫描查询">码范围锁：范围扫描查询</h4>
<ul>
<li>码范围锁定原理解决了幻像并发问题</li>
<li>码范围锁通过覆盖索引行和索引行之间的范围来工作，因为第二个事务在该范围内进行任何行插入、更新或删除操作时均需要修改索引，而码范围锁覆盖了索引项，所以在第一个事务完成之前会阻塞第二个事务的进行</li>
<li>要求（同时满足）
<ul>
<li>必须在查询项上存在索引</li>
<li>隔离性级别为 serializable</li>
</ul></li>
</ul>
<h4 id="码范围锁模式">码范围锁模式</h4>
<ul>
<li>码范围锁包括<strong>范围组件</strong>和<strong>行组件</strong>
<ul>
<li>前者表示保护两个连续<strong>索引项之间范围的锁模式</strong>（RangeT）</li>
<li>后者表示保护<strong>索引项的锁模式</strong>（K），这两部分用下划线连接，如
RangeT_K</li>
</ul></li>
</ul>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">范围</th>
<th style="text-align: center;">行</th>
<th style="text-align: center;">模式</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">RangeS</td>
<td style="text-align: center;">S</td>
<td style="text-align: center;">RangeS_S</td>
<td style="text-align: center;">共享范围，共享资源锁；可串行范围扫描</td>
</tr>
<tr class="even">
<td style="text-align: center;">RangeS</td>
<td style="text-align: center;">U</td>
<td style="text-align: center;">RangeS_U</td>
<td style="text-align: center;">共享范围，更新资源锁；可串行更新扫描</td>
</tr>
<tr class="odd">
<td style="text-align: center;">RangeI</td>
<td style="text-align: center;">NULL</td>
<td style="text-align: center;">RangeI_N</td>
<td style="text-align: center;">插入范围，空资源锁；用于在索引中插入新码之前测试范围</td>
</tr>
<tr class="even">
<td style="text-align: center;">RangeX</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">RangeX_X</td>
<td style="text-align: center;">排它范围，排它资源锁；用于更新范围中的码</td>
</tr>
</tbody>
</table>
<h4 id="码范围锁的相容矩阵">码范围锁的相容矩阵</h4>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">请求模式</th>
<th style="text-align: center;">S</th>
<th style="text-align: center;">U</th>
<th style="text-align: center;">X</th>
<th style="text-align: center;">RangeS_S</th>
<th style="text-align: center;">RangeS_U</th>
<th style="text-align: center;">RangeI_N</th>
<th>RangeX_X</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">共享(S)</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">更新(U)</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">排它(X)</td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">RangeS_S</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">RangeS_U</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">RangeI_N</td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\checkmark}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\checkmark}\)</span></td>
<td style="text-align: center;"><span class="math inline">\({\color{red}\times}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">RangeX_X</td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\times\)</span></td>
<td><span class="math inline">\(\times\)</span></td>
</tr>
</tbody>
</table>
<h4 id="一个例子">一个例子</h4>
<ul>
<li>employees 表上存在 last_name 上的索引</li>
</ul>
<p><img src="/2021/05/25/DB/CLJ/07/image-20210604142311541.png" style="zoom: 70%;"></p>
<ul>
<li>在 serializable 隔离性级别上执行如下查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> last_name <span class="keyword">between</span> <span class="string">&#x27;Delaney&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;DuLaney&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在索引上找到一个覆盖上面范围的最小区间 <span class="math inline">\(\mathrm{(Dallas,Duluth)}\)</span></li>
<li>如果 Dallas, Donovan 和 Duluth
是叶级的顺序索引码，前两个码将获得码范围锁 RangeS_S
<ul>
<li>码范围锁防止任何向以这两个码结束的区间插入数据
<ul>
<li>锁住了 Dallas 和 Donovan 后面的区间</li>
</ul></li>
<li>没有大于 Dallas 且小于等于 Donovan 的行可以插入，也没有大于 Donovan
且小于等于 Duluth 的行可以插入</li>
</ul></li>
<li>能否插入 Dashagua？
<ul>
<li><strong><span style="color:red">不能插入</span></strong>，虽然是在查询范围之外，但是在最小覆盖的索引范围内部</li>
</ul></li>
</ul>
<h3 id="sql-server-锁">SQL Server 锁</h3>
<p><img src="/2021/05/25/DB/CLJ/07/image-20210604143943619.png" style="zoom:130%;"></p>
<h3 id="mysql-中的行锁模式">MySQL 中的行锁模式</h3>
<ul>
<li>MySQL 的 innode
引擎，在建表的时候，默认会有一个隐含的自增字段，缺省的会在这个字段上建立聚簇索引</li>
<li>缺省的 MySQL 就是有序的表</li>
<li>MySQL 中的行锁模式
<ul>
<li>lock_rec_not_gap：只锁记录</li>
<li>lock_gap：间隙锁，锁两个记录之间的gap，防止记录插入</li>
<li>lock_ordinary：也称为Next-KeyLock，锁一条记录及其之前的间隙</li>
<li>lock_insert_intension：插入意向gap锁，插入记录时使用，是lock_gap的一种特例</li>
</ul></li>
<li>图示</li>
</ul>
<p><img src="/2021/05/25/DB/CLJ/07/image-20210604144317013.png"></p>
<ul>
<li>相容性</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">RECORD</th>
<th style="text-align: center;">GAP</th>
<th style="text-align: center;">NEXT-KEY</th>
<th style="text-align: center;">II GAP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">RECORD</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">GAP</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">NEXT-KEY</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">II GAP</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
</tr>
</tbody>
</table>
<h4 id="闩锁">闩锁</h4>
<ul>
<li>lock：保护逻辑对象</li>
<li>latch：保护内存页</li>
<li>以下显示不对内存页加保护的结果
<ul>
<li>页头的写入需要做保护</li>
</ul></li>
</ul>
<p><img src="/2021/05/25/DB/CLJ/07/image-20210604145703323.png" style="zoom:67%;"></p>
<ul>
<li>为什么不直接使用排他锁实现？
<ul>
<li>太慢了，需要向锁管理器申请，锁表的处理慢</li>
</ul></li>
<li>闩锁是自旋锁（spinlock）</li>
<li>使用序列号锁聚簇索引码的问题
<ul>
<li>由于自增 id，最新的页面会被很多进程同时写，闩锁竞争激烈</li>
</ul></li>
</ul>
<h4 id="mysql-的自增器">MySQL 的自增器</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SQL1 */</span></span><br><span class="line"><span class="comment">/* 已知条数 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span> (<span class="number">1</span>),(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SQL2 */</span></span><br><span class="line"><span class="comment">/* 未知条数 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1</span><br></pre></td></tr></table></figure>
<ul>
<li>已知行数用闩锁（mutex），未知行数使用自增锁（auto-inc locking）</li>
<li>为了保证同一个事务插入的数据，自增 id 是连续的</li>
</ul>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.08.数据挖掘简述</title>
    <url>/2021/06/13/DB/CLJ/08/</url>
    <content><![CDATA[<h1 id="数据挖掘">数据挖掘</h1>
<ul>
<li>一个广为流传的例子：啤酒和尿布</li>
<li>数据挖掘是识别数据中<strong>有效的</strong>、<strong>新颖的</strong>、<strong>潜在有用的</strong>、<strong>最终可被理解的模式</strong>的非平凡过程</li>
</ul>
<h2 id="预测型工具">预测型工具</h2>
<ul>
<li>有效的
<ul>
<li>该模式具有足够的通用性，即对于新数据，该模式同样适用</li>
</ul></li>
<li>新颖的
<ul>
<li>该模式是深层次的，事先无法预料的</li>
</ul></li>
<li>潜在有用的
<ul>
<li>该模式可以指导一些有效的行为，不仅仅是检索有效的新颖的模式，可以指导决策人员进行科学决策</li>
</ul></li>
<li>最终可被理解的
<ul>
<li>该模式必须简单易懂</li>
</ul></li>
</ul>
<h2 id="数据挖掘方法论">数据挖掘方法论</h2>
<p><img src="/2021/06/13/DB/CLJ/08/image-20210613132636291.png" style="zoom: 67%;"></p>
<h2 id="数据挖掘的任务与方法">数据挖掘的任务与方法</h2>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 45%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">数据挖掘任务</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">相关技术</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">数据划分</td>
<td style="text-align: center;">聚类分析:
在预先没有确定类别的情况下，根据数据的不同属性，将数据分成不同的类别。<br>分类分析：将数据映射到预先定义的数据类别中</td>
<td style="text-align: center;">聚类分析<br>Bayesian分类<br>决策树或分类树<br>人工神经网络</td>
</tr>
<tr class="even">
<td style="text-align: center;">依赖分析</td>
<td style="text-align: center;">找出各个属性之间的依赖关系</td>
<td style="text-align: center;">Bayesian网络<br>关联分析</td>
</tr>
<tr class="odd">
<td style="text-align: center;">奇异点分析</td>
<td style="text-align: center;">找出与一般数据行为不一致的数据项</td>
<td style="text-align: center;">聚类分析<br>奇异点检测</td>
</tr>
<tr class="even">
<td style="text-align: center;">趋势检测</td>
<td style="text-align: center;">通常在时间序列上，对数据库中的数据利用线性回归或曲线拟合等方式进行综合分析</td>
<td style="text-align: center;">回归分析<br>序列模式分析</td>
</tr>
</tbody>
</table>
<h2 id="查询分析">查询分析</h2>
<ul>
<li>查询哪些商品经常被购买</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> item, <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">From</span> trans</span><br><span class="line"><span class="keyword">Where</span> <span class="keyword">condition</span></span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">by</span> item</span><br><span class="line"><span class="keyword">Having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查询哪两个商品经常一起被购买</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> t1.item, t2.item, <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">From</span> trans t1, trans t2</span><br><span class="line"><span class="keyword">Where</span> t1.bucket_id <span class="operator">=</span> t2.bucket_id</span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">by</span> t1.item, t2.item</span><br><span class="line"><span class="keyword">Having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面简单的连接，效果很差，运行很慢</li>
</ul>
<h2 id="关联分析">关联分析</h2>
<ul>
<li>目的：发现数据间的相互关联</li>
<li>购物篮分析：给定一组商品，一个交易集合，通过分析交易记录集合，推导出商品间的相关性</li>
<li>基本形式
<ul>
<li>给定：一组事务集，每一个事务中包含若干个数据项</li>
<li>挖掘：各个数据项之间的关联</li>
</ul></li>
<li>结论：98% 的顾客在购买电动剃须刀的同时会购买一些电池</li>
</ul>
<h3 id="关联分析支持度support">关联分析支持度（support）</h3>
<ul>
<li>在关联分析中表示满足规则的记录数与总记录数的比</li>
<li>它表明了规则的模式在数据库中出现的频度</li>
<li>对于规则：<span class="math inline">\(X\to
Y\)</span>，其支持度表示为</li>
</ul>
<p>$$</p>
<p>$$</p>
<h3 id="关联分析置信度confidence">关联分析置信度（confidence）</h3>
<ul>
<li>在关联分析中表示为满足规则的记录数与出现被分析数据项的记录数之比</li>
<li>对于规则：<span class="math inline">\(X\to
Y\)</span>，其置信度表示为</li>
</ul>
<p><span class="math display">\[
C=\dfrac{同时购买商品\;X\;和\;Y\;的交易数}{购买商品\;X\;的交易数}
\]</span></p>
<h3 id="关联分析核心发现频繁项集">关联分析核心：发现频繁项集</h3>
<ul>
<li>频繁项集：出现频率超过<strong>预设支持度</strong>的项集</li>
<li><strong>关联分析就是发现频繁项集的过程</strong></li>
<li>不能够先生成商品组合然后逐一过滤，这样候选集太大了</li>
</ul>
<h4 id="先验apriori法则">先验（Apriori）法则</h4>
<ul>
<li><p><strong>一个频繁项集的任何非空子集肯定也是频繁项集</strong></p></li>
<li><p><span class="math inline">\(\{A,B\}\)</span>
为频繁项集，那么其子集 <span class="math inline">\(\{A\}\)</span>、<span class="math inline">\(\{B\}\)</span> 也都为频繁项集</p></li>
<li><p><strong>反单调</strong></p>
<ul>
<li>一个集合如果不是频繁的，则它的任何超集也不是频繁的</li>
</ul></li>
<li><p><strong>由低阶频繁项集构造高阶频繁项集</strong></p></li>
</ul>
<h3 id="关联分析示例">关联分析示例</h3>
<ul>
<li>表格如下</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">TID</th>
<th style="text-align: center;">项集</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">面包，牛奶</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">面包，啤酒，鸡蛋，尿布</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">牛奶，啤酒，尿布，可乐</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">面包，牛奶，啤酒，尿布</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">面包，牛奶，尿布，可乐</td>
</tr>
</tbody>
</table>
<ul>
<li>结果
<ul>
<li>尿布 <span class="math inline">\(\to\)</span> 啤酒 支持度 <span class="math inline">\(\dfrac35\)</span>，置信度 <span class="math inline">\(\dfrac34\)</span> 啤酒 <span class="math inline">\(\to\)</span> 尿布 支持度 <span class="math inline">\(\dfrac35\)</span>，置信度 <span class="math inline">\(\dfrac33\)</span></li>
</ul></li>
</ul>
<h4 id="先验法则求解">先验法则求解</h4>
<ul>
<li>设定最小支持度为 3</li>
<li>依次寻找一阶项、二阶项、三阶项</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">1阶项</th>
<th style="text-align: center;">计数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">啤酒</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;">面包</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">可乐</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;">尿布</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">牛奶</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">鸡蛋</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">2阶项</th>
<th style="text-align: center;">计数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">啤酒, 面包</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;">啤酒, 尿布</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">啤酒, 牛奶</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;">面包, 尿布</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">面包, 牛奶</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;">尿布, 牛奶</td>
<td style="text-align: center;">3</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">3阶项</th>
<th style="text-align: center;">计数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">面包, 尿布, 牛奶</td>
<td style="text-align: center;">3</td>
</tr>
</tbody>
</table>
<h3 id="关联分析算法过程">关联分析算法过程</h3>
<h4 id="连接步">连接步</h4>
<ul>
<li>对 K-1 阶频繁项集 Lk-1 做 Self-Join 操作，形成 K 阶频繁项集的候选集
Ck
<ul>
<li>前 K-1 项相同，第 K 项 p&lt;q（避免重复）</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ck</span><br><span class="line"><span class="keyword">select</span> p.item1, p.item2, ... , p.itemk<span class="number">-1</span>, q.itemk<span class="number">-1</span></span><br><span class="line"><span class="keyword">from</span> Lk<span class="number">-1</span>p,Lk<span class="number">-1</span>q</span><br><span class="line"><span class="keyword">where</span> p.item1<span class="operator">=</span>q.item1, ... , p.itemk<span class="number">-2</span><span class="operator">=</span>q.itemk<span class="number">-2</span>, p.itemk<span class="number">-1</span><span class="operator">&lt;</span>q.itemk<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h4 id="剪枝步">剪枝步</h4>
<ul>
<li>任何 K-1 阶非频繁项集，则其不可能为 K 阶频繁项集的子集</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">all</span> itemsets c <span class="keyword">in</span> Ck do:</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">all</span> (k-<span class="number">1</span>)-subsets s of c do:</span><br><span class="line">        <span class="keyword">if</span>(s <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> Lk-<span class="number">1</span>):</span><br><span class="line">            then delete c <span class="keyword">from</span> Ck</span><br></pre></td></tr></table></figure>
<h3 id="关联分析算法例子">关联分析算法例子</h3>
<ul>
<li>3 阶高频项目集：L3={ abc, abd, acd, ace, bcd }</li>
<li>连接步
<ul>
<li>Self-joining:L3*L3</li>
<li>abc, abd <span class="math inline">\(\to\)</span> abcd</li>
<li>acd, ace <span class="math inline">\(\to\)</span> acde</li>
</ul></li>
<li>剪枝步 acde 移出，因为 ade 不包含在 L3 中</li>
<li>4 阶候选集：C4={ abcd }
<ul>
<li>还得在数据库中验证之后才能称为 4 阶高频项目集</li>
</ul></li>
</ul>
<h3 id="sql-实现">SQL 实现</h3>
<ul>
<li>最核心的问题：<strong>如何实现对候选集的计数</strong></li>
<li>论文：Integrating Association Rule Mining with Relational Database
Systems: Alternatives and Implications</li>
</ul>
<h4 id="基于连接实现">基于连接实现</h4>
<ul>
<li>K-ways joins</li>
<li>代码</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/08/image-20210613140959356.png"></p>
<ul>
<li>图示</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/08/image-20210613141012312.png"></p>
<h4 id="基于子查询实现">基于子查询实现</h4>
<ul>
<li>subquery</li>
<li>代码</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/08/image-20210613141317487.png"></p>
<ul>
<li>图示</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/08/image-20210613141337247.png"></p>
<h4 id="基于面向对象的-sql-实现">基于面向对象的 SQL 实现</h4>
<ul>
<li>代码</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/08/image-20210613141413985.png"></p>
<ul>
<li>图示</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/08/image-20210613141506870.png"></p>
<h3 id="关联分析和相关性分析">关联分析和相关性分析</h3>
<ul>
<li>实际可能是负相关</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/08/image-20210613142232147.png" style="zoom:67%;"></p>
<h3 id="关联分析的辛普森悖论">关联分析的辛普森悖论</h3>
<ul>
<li>数据子集显示出来的结果和数据集本身相反</li>
<li>数据集</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/08/image-20210613142457403.png" style="zoom:67%;"></p>
<ul>
<li>数据子集</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/08/image-20210613142538884.png" alt="image-20210613142600824" style="zoom:67%;"></p>
<ul>
<li>原因</li>
</ul>
<p><span class="math display">\[
\begin{align}
\dfrac{a}{b}&amp;&lt;\dfrac{c}{d}\\
\dfrac{p}{q}&amp;&lt;\dfrac{r}{s}\\
\dfrac{a+p}{b+q}&amp;&lt;\dfrac{c+r}{d+s}\\
\end{align}
\]</span></p>
<ul>
<li>提示：数据子集的划分要仔细，否则可能得出相反结论
<ul>
<li>连锁超市的购物篮应按商店位置分层</li>
<li>病人医疗记录应按年龄、性别等分层</li>
</ul></li>
</ul>
<h4 id="序列关联分析">序列关联分析</h4>
<h2 id="分类分析">分类分析</h2>
<ul>
<li>决策树</li>
<li>朴素贝叶斯</li>
<li>支持向量机 SVM</li>
</ul>
<h2 id="聚类分析">聚类分析</h2>
<ul>
<li>无监督学习</li>
<li>基于划分</li>
<li>K-means</li>
</ul>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.09.恢复控制(2)</title>
    <url>/2021/06/13/DB/CLJ/09-1/</url>
    <content><![CDATA[<h1 id="恢复控制">恢复控制</h1>
<h2 id="恢复">恢复</h2>
<h3 id="事务故障恢复">事务故障恢复</h3>
<ul>
<li>撤消事务已对数据库所做的修改</li>
</ul>
<h3 id="事务故障恢复过程">事务故障恢复过程</h3>
<ul>
<li><strong>反向</strong>扫描日志文件，查找该事务的更新操作</li>
<li>对该事务的更新操作执行 undo
操作，即将事务更新前的<strong>旧值</strong>写入数据库</li>
<li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理</li>
<li>直至读到事务的开始标识，结束事务故障恢复过程</li>
<li><strong>同一事务的日志需要反向链接在一起</strong>
<ul>
<li>加速事务的撤销操作</li>
</ul></li>
<li>正向撤销会出错
<ul>
<li>这是显然的，撤销是写的逆过程</li>
</ul></li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/09-1/image-20210613231700809.png" style="zoom:67%;"></p>
<h3 id="山寨版系统故障恢复">山寨版系统故障恢复</h3>
<ul>
<li>不一致状态原因
<ul>
<li>未完成事务对数据库的更新已写入数据库
<ul>
<li>Steal policy</li>
</ul></li>
<li>已提交事务对数据库的更新未写入数据库
<ul>
<li>还在 OS Buffer 中</li>
</ul></li>
</ul></li>
</ul>
<h4 id="系统故障恢复过程">系统故障恢复过程</h4>
<ul>
<li>正向扫描日志文件，找出圆满事务，记入重做队列；找出夭折事务，记入撤消队列</li>
<li>反向扫描日志，对撤消队列中事务 Ti 的每一个日志记录执行 undo
操作</li>
<li>正向扫描日志文件，对重做队列中事务 Ti 的每一个日志记录执行 redo
操作</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/09-1/image-20210613233141824.png" style="zoom:67%;"></p>
<h5 id="实际数据库">实际数据库</h5>
<ul>
<li>对所有操作（不区分成功还是失败），都进行 redo 操作
<ul>
<li>连续操作，磁盘 I/O 友好</li>
</ul></li>
<li>然后再对夭折事务进行 undo</li>
</ul>
<h3 id="介质故障恢复">介质故障恢复</h3>
<ul>
<li>磁盘上数据文件和日志文件遭到破坏</li>
</ul>
<h4 id="介质故障恢复过程">介质故障恢复过程</h4>
<ul>
<li>装入最新的数据库后备副本，使数据库恢复到最近一次转储时的一致性状态</li>
<li>装入相应的日志文件副本，重做已完成的事务</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/09-1/image-20210613233249680.png" style="zoom: 67%;"></p>
<ul>
<li>数据文件和日志文件最好不要放在一个磁盘上</li>
</ul>
<h3 id="检查点checkpoint">检查点(Checkpoint)</h3>
<ul>
<li>当系统故障发生时，我们必须搜索整个日志，以决定哪些事务需要
redo，哪些需要 undo</li>
<li>大多数需要被重做的事务其更新已经写入了数据库中（<span class="math inline">\(\mathrm{redo}^2\)</span>）
<ul>
<li>因为我们不知道数据是否已经被写入磁盘（异步写缓冲区）</li>
<li>尽管对它们重做不会造成不良后果，但会使恢复过程变得更长</li>
</ul></li>
<li>检查点原理：且行且珍惜
<ul>
<li><strong>保证在检查点时刻，日志与数据库的内容是一致的</strong></li>
</ul></li>
</ul>
<h4 id="带有检查点记录的日志生成">带有检查点记录的日志生成</h4>
<ul>
<li>将当前日志缓冲区的所有日志记录写入稳存中</li>
<li>在日志文件中写入一个检查点记录</li>
<li>将当前数据缓冲区的所有数据记录写入稳存中</li>
<li>输出检查点时活跃事务的列表 L</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/09-1/image-20210613233943188.png" style="zoom: 67%;"></p>
<ul>
<li>我们对检查点之前就已经提交的事务，不需要做 redo 处理</li>
<li>只需要对检查点时刻还在活跃的事务、检查点之后出现的事务进行 redo
处理</li>
<li>最小日志序列号
<ul>
<li>生成检查点时刻的还在活跃的最小日志记录的序列号</li>
</ul></li>
<li>长事务再数据库中危害很大
<ul>
<li>并发</li>
<li>长事务不释放，检查点做的恢复工作不会少
<ul>
<li>最小序列号之后、但是在检查点之前已经提交的事务需要重做吗？</li>
</ul></li>
</ul></li>
</ul>
<h4 id="sql-server最小恢复lsn">SQL Server：最小恢复LSN</h4>
<ul>
<li>MinLSN 是下面这些 LSN 中的最小 LSN：
<ul>
<li>检查点起点的 LSN</li>
<li>最旧的活动事务起点的 LSN</li>
</ul></li>
</ul>
<h4 id="sql-server生成检查点">SQL Server：生成检查点</h4>
<ol type="1">
<li>将标记检查点起点的记录写入日志文件</li>
<li>将为检查点记录的信息存储在检查点日志记录链内，将这条链起点的 LSN
写入数据库根页</li>
<li>将最小恢复 LSN(MinLSN) 保存在检查点记录中</li>
<li>将所有未完成的活动事务列表保存在检查点记录中</li>
<li>如果数据库使用的是简单恢复模式，则删除新的 MinLSN
之前的所有日志记录</li>
<li>将所有脏日志和数据页写入磁盘</li>
<li>将标记检查点末端的记录写入日志文件</li>
</ol>
<h5 id="恢复过程">恢复过程</h5>
<ul>
<li>检查点线程遍历缓冲区池，按照缓冲区编号顺序扫描页面，当它发现脏页时，它将查看与该页面<strong>物理(磁盘上)连续的其他页面</strong>是否也是脏的，这样它可以进行大块写操作
<ul>
<li>顺序写性能远高于随机写</li>
</ul></li>
<li>如果它看到页面5是脏的时，它可能会写入页面10、25、380、500等，这些页面在磁盘上是连续的。这样，缓冲区中非连续的页面可以被一次聚集写入（<strong>gather-write</strong>）磁盘</li>
<li>以后检查点会到达页面
500，为避免将该页面重复写入磁盘，检查点算法会为每个页面设置标志位，开始时所有的位都相同(都为0或1)。当检查点检查到某个页面时，它将其标志位翻转。如果检查点碰到具有相反位的页面，它就跳过该页面</li>
<li><strong>对于在检查点期间新近引入的页面，或者已经被检查点输出到磁盘但又重新变脏的页面，都不会被该次检查点操作写入</strong></li>
</ul>
<h5 id="recovery-interval">recovery interval</h5>
<ul>
<li>recovery interval 选项设置 SQL Server
恢复数据库所需的最大分钟数</li>
<li>据此 SQL Server
将估计在恢复时间间隔期间可以处理多少更新的数据，从而决定在每一个数据库中
SQL Server 何时生成一次检查点</li>
<li>SQL Server 根据 10MB 的日志可以在 1
分钟内得到恢复这样一个估计来确定它的恢复间隔</li>
<li>当最近一个检查点之后数据更新操作达到了 SQL Server
认为可以在恢复时间间隔更新的数量时，它将进行一个检查点操作</li>
</ul>
<h4 id="mysql-检查点执行时机">MySQL 检查点执行时机</h4>
<ul>
<li>Master Thread Checkpoint
<ul>
<li>每秒或每10秒刷出一定比例的脏页</li>
</ul></li>
<li>FLUSH_LRU_LIST Checkpoint
<ul>
<li>LRU 列表中空闲页不够时淘汰的页面中有脏页</li>
</ul></li>
<li>Dirty Page too much Checkpoint
<ul>
<li>innodb_max_dirty_pages_pct</li>
</ul></li>
<li>Async/Sync Flush Checkpoint
<ul>
<li>redo_lsn–checkpoing_lsn 超过日志文件大小75%</li>
</ul></li>
</ul>
<h2 id="杂项">杂项</h2>
<h3 id="mysql-日志文件">MySQL 日志文件</h3>
<ul>
<li>重做日志（redolog）</li>
<li>回滚日志（undolog）</li>
<li>二进制日志（binlog）</li>
<li>错误日志（errorlog）</li>
<li>慢查询日志（slowquerylog）</li>
<li>一般查询日志（generallog）</li>
<li>中继日志（relaylog）</li>
</ul>
<h3 id="事务日志物理构架">事务日志物理构架</h3>
<ul>
<li>循环使用
<ul>
<li>生成检查点的时候，可以释放之前的一些无用日志块</li>
</ul></li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/09-1/image-20210613235856513.png" style="zoom:67%;"></p>
<h3 id="逻辑-undo-日志">逻辑 Undo 日志</h3>
<ul>
<li><strong>针对索引页</strong></li>
<li>一般恢复技术要求一旦事务更新了一个数据项，其它事务都不能更新该数据项，直至第一个事务提交或回滚</li>
<li>严格两阶段封锁协议实施到某些特殊结构如 B+
树索引页时，并发性极度下降。为提高并发性，可以使锁较早释放
<ul>
<li>提早释放会导致问题</li>
<li>如果是物理日志
<ul>
<li>A 事务写页 a，B 事务也写页 a，此时 A 事务出错，回滚，页 a
回滚（页面为单位），此时把事务 B 修改的部分给覆盖了</li>
</ul></li>
<li>逻辑日志则没有这个问题</li>
<li>插入操作必须通过一个逻辑 undo
来完成，即通过执行一次删除操作撤消</li>
</ul></li>
<li><strong>闩锁，自旋锁</strong></li>
<li>如果事务 T 向 B+
树插入了一项，在插入操作结束后但在事务提交前释放了某些锁，那么在锁释放后，其它事务可执行插入或删除操作，于是造成对
B+ 树结点的进一步改变</li>
<li>如果使用物理 undo 执行事务回滚，即事务回滚时我们将 B+
树内部结点(执行插入操作前)的旧值写回，那么其它事务在其后执行的插入或删除操作所做的某些更新可能会丢失</li>
</ul>
<h3 id="其他恢复技术">其他恢复技术</h3>
<h4 id="提交日志commit-logging">提交日志（Commit Logging）</h4>
<ul>
<li>特点
<ul>
<li><strong>只有 redo 记录，没有 undo 记录</strong></li>
<li><strong>脏数据不会持久化</strong></li>
<li><strong>提交时将事务日志都刷写到磁盘</strong></li>
</ul></li>
<li>如果日志只写到一半时出现系统故障，事务修改也会随之消失。当数据库系统重新恢复时，会发现日志中事务没有完成标记，就好像完全没有发生过一样</li>
<li>OceanBase、Hekaton（SQL Server 内存存储引擎）</li>
<li>如果在系统故障后，重启的时候发现有一条事务没有 commit 标记，怎么办？
<ul>
<li>不需要做任何操作，是一条失败的操作记录（日志不完整而且脏数据没写回磁盘）</li>
<li>只需要重做已经成功的日志</li>
</ul></li>
</ul>
<h4 id="shadow-paging">Shadow Paging</h4>
<ul>
<li><strong>影子页</strong>，没有日志的概念</li>
<li>在事务操作过程中，被修改的数据会同时存在两份，一份<strong>修改前</strong>的数据，一份是<strong>修改后</strong>的数据，这就是影子（Shadow）这个名字的由来</li>
<li>持久性保证：事务的修改直接持久化在硬盘上</li>
<li>如果在事务提交前出现系统故障，数据库恢复时见不到未完成事务的修改，硬盘上的这个事务曾经修改的数据也会由垃圾回收模块回收</li>
<li>SQLite</li>
</ul>
<h5 id="例子">例子</h5>
<ul>
<li>A 向 B 转账 100</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/09-1/image-20210721151303697.png" style="zoom: 50%;"></p>
<ul>
<li>当事务提交时，以一次原子的数据写入让整个事务新的修改生效</li>
<li>A 和 B 的余额都是直接写入新的位置，保证原先的数据没有改动</li>
<li>系统通过两个目录结构分别指向修改前的数据和修改后的数据，最后 Current
指针原子切换到新的目录上，表示事务提交成功</li>
</ul>
<h3 id="镜像数据库">镜像数据库</h3>
<ul>
<li><strong>主体服务器</strong>
<ul>
<li>存放数据库</li>
<li>执行事务</li>
<li>推送更新（内容数据同步）</li>
</ul></li>
<li><strong>镜像服务器</strong>
<ul>
<li>存放数据库副本</li>
<li>接受更新</li>
<li>替补篡位（主题服务器宕机）</li>
</ul></li>
<li><strong>见证服务器</strong>
<ul>
<li>自动故障转移</li>
<li>判断主体服务器不可用</li>
</ul></li>
<li>实际部署的问题（为什么需要见证服务器）
<ul>
<li>怎么判断主体服务器是否还在工作：heartbeat
<ul>
<li>如果是由网络故障导致接收不到
heartbeat，镜像服务器不能贸然替补篡位</li>
<li>这个由见证服务器判断</li>
</ul></li>
<li>通常使用投票来决定谁是主题服务器</li>
</ul></li>
<li>split-brain quorum</li>
</ul>
<h3 id="复制">复制</h3>
<ul>
<li>实现系统的安全性，抗故障能力</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/09-1/image-20210721151848266.png"></p>
<ul>
<li>读写分离、伸缩性、安全性</li>
<li>提高访问的本地性（可以在比较近的服务器上读取数据）</li>
<li>增加系统可靠性（一个结点失效，其他结点还是可用的）</li>
</ul>
<h4 id="数据复制的更新传播策略">数据复制的更新传播策略</h4>
<ul>
<li><strong>紧密复制</strong>：将所有结点上的副本更新作为一个原子事务的一部分，所有结点上的副本严格同步
<ul>
<li>更新代价大</li>
</ul></li>
<li><strong>松散复制</strong>：更新事务提交之后，异步的将更新传向其他结点
<ul>
<li>各个结点之间会有短暂的不一致</li>
</ul></li>
</ul>
<h4 id="数据复制的更新控制策略">数据复制的更新控制策略</h4>
<ul>
<li><strong>主方式</strong>（master）
<ul>
<li>每一对象都有一起主结点，只有主结点能够更新对象的主拷贝，其他副本是只读的。其他与更新该对象的结点请求主结点完成更新，由主结点将更新传向其他结点。</li>
</ul></li>
<li><strong>群方式</strong>（group）
<ul>
<li>任何拥有某数据项拷贝的结点都可以更新该拷贝，称之为随处更新（update
everywhere）并将更新操作广播到其他结点</li>
<li>需要设计冲突协调策略？怎么解决冲突？
<ul>
<li>人为设计：时间靠后、值较大 ······</li>
</ul></li>
</ul></li>
</ul>
<h4 id="数据复制的更新策略">数据复制的更新策略</h4>
<p><img src="/2021/06/13/DB/CLJ/09-1/image-20210721153646701.png"></p>
<ul>
<li>松散 + 群：数据一致性很差，数据库场景中实际应用较少</li>
<li>SQL Server 4 种都支持</li>
</ul>
<h4 id="mysql-复制类型">MySQL 复制类型</h4>
<ul>
<li>没有群方式，只有主从
<ul>
<li>所有的更新都发生在主结点，再由主结点将更新推送给其他结点</li>
</ul></li>
<li><strong>主从 + 同步/异步</strong></li>
</ul>
<h5 id="同步复制">同步复制</h5>
<ul>
<li>只有所有的 slaver 更新完成之后，整个事务才完成</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/09-1/image-20210721153844233.png"></p>
<ul>
<li>主结点发送一个 binlog 到其他的从结点，slaver 结点再现这个 log
，然后发送 ACK 回主结点</li>
</ul>
<h5 id="异步复制">异步复制</h5>
<ul>
<li>主结点不会等待从节点更新完成</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/09-1/image-20210721154306532.png"></p>
<ul>
<li>问题
<ul>
<li>主结点更新完就挂了，此时数据丢失，无法恢复</li>
</ul></li>
</ul>
<h5 id="半同步复制">半同步复制</h5>
<ul>
<li>主结点等待某一个从结点更新结束之再进行接下来的操作</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/09-1/image-20210721154443488.png"></p>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.09.恢复控制(3)</title>
    <url>/2021/07/21/DB/CLJ/09-2/</url>
    <content><![CDATA[<h1 id="恢复控制">恢复控制</h1>
<h2 id="aries-算法">ARIES 算法</h2>
<ul>
<li>相当复杂的算法</li>
<li>A Transaction Recovery Method Supporting Fine-Franularity Locking
and Partial Rollbacks Using Write-Ahead Logging</li>
</ul>
<h3 id="日志类型">日志类型</h3>
<ul>
<li>Redo Log 记录了提交更新操作所需要的信息</li>
<li>Undo Log 记录了回滚更新操作所需要的信息</li>
<li>使用 Page-oriented 级的 Redo
<ul>
<li><strong>Redo 物理级（页级）</strong></li>
</ul></li>
<li>使用 Logical 级的 Undo
<ul>
<li><strong>Undo 逻辑级</strong></li>
</ul></li>
<li><strong>实际数据库中日志是以页为单位记录的，而不是数据项级别的</strong>
<ul>
<li>数据项 &lt;事务, 修改前的值, 修改后的值&gt;</li>
<li>页级 &lt;事务, 页面, 叶偏移, 修改前的值, 修改后的值&gt;</li>
</ul></li>
<li>CLR（Compensation Log Record）：补偿日志
<ul>
<li>对于一条 undolog，这个 CLR 在 Page-oriented
级记录了如何更改一个页面来达到 Undo 的效果</li>
<li>将逻辑级的 undo 操作转化成物理页级的操作</li>
</ul></li>
</ul>
<h3 id="数据结构">数据结构</h3>
<ul>
<li>LSN
<ul>
<li>在增长的日志记录空间中的日志记录的第一个字节的地址</li>
<li>这是一个<strong>单调递增</strong>的数值</li>
</ul></li>
<li>Type
<ul>
<li>表示一个记录是补偿日志（'compensation'）</li>
<li>正常更新记录（'update'）</li>
<li>一个提交协议相关记录（例如 'prepare'）</li>
</ul></li>
<li>TransID
<ul>
<li>事务的标记，如有，则写入到日志记录中</li>
</ul></li>
<li>PrevLSN
<ul>
<li>本事务的前一条日志记录的 LSN</li>
<li>对该事务的第一条日志记录而言是0，因此不需要用一条日志记录显式地表示一条事务的开始</li>
</ul></li>
<li>PageID
<ul>
<li>只在 Update 和 compensation
类型的记录中出现，它记录本记录所更新页面的标记</li>
</ul></li>
<li>Data
<ul>
<li>这是描述欲更新的 redo 和/或 undo 数据</li>
<li>CLR 只包含 redo 信息，因为它们不能 undo</li>
</ul></li>
<li>UndoNxtLSN
<ul>
<li>只在 CLR
中出现，它指的是回滚阶段要处理的下一个本事务的日志记录，也即 UndoNxtLSN
是当前日志正在补偿的日志记录的 PrevLSN 的数值</li>
</ul></li>
<li>页面结构
<ul>
<li>数据库的<strong>每个页</strong>都有 page_LSN 域</li>
<li>它包含对该页面所做的<strong>最近更新日志记录的 LSN</strong></li>
<li>redo 恢复的时候如果发现修改页的 LSN 比当前操作的 LSN
要大，则可以直接跳过（这个修改已经反映到页面上了）</li>
<li>注意算法是以<strong>页</strong>为单位，以页为单位向磁盘上刷数据</li>
</ul></li>
</ul>
<h4 id="事务表">事务表</h4>
<ul>
<li>记录活跃事务的状态</li>
<li>TransID：事务的ID</li>
<li>State：事务的提交状态</li>
<li>LastLSN：事务所写的最后一条LSN</li>
<li>UndoNxtLSN：在回滚阶段下一个记录的LSN
<ul>
<li>如果本事务的最近日志记录是一个可 undo 的非 CLR
记录，这个字段的值就会被设为 LastLSN</li>
<li>如果最近日志记录是 CLR，该字段就设为此 CLR 的 UndoNxtLSN 的值</li>
</ul></li>
</ul>
<h4 id="脏页表">脏页表</h4>
<ul>
<li>包含一个在数据库缓冲区中已更新页的列表，它为每一页保存其 PageID
和一个称为RecLSN 的字段</li>
<li>RecLSN
用于标识日志记录，也即引起该页变脏的<strong>第一个</strong>日志记录的
LSN</li>
<li>当一页被插入到脏页表时，RecLSN 被设置成日志的当前末尾</li>
<li>只要页被写入磁盘，该页就被从脏页表中移除</li>
</ul>
<h4 id="检查点日志记录">检查点日志记录</h4>
<ul>
<li>包含脏页和活动事务的列表，同时记录每个事务的LastLSN</li>
</ul>
<h3 id="三个原理">三个原理</h3>
<ul>
<li><strong>先写日志</strong>
<ul>
<li>在将更新的数据库对象的修改写入磁盘之前，先将对应的日志记录写入稳存</li>
</ul></li>
<li><strong>重做时重复历史</strong>
<ul>
<li>在崩溃后进行重新启动时，重做崩溃前的所有操作，使系统恢复到崩溃时的状态，然后回滚崩溃时还在执行的事务已完成的操作</li>
</ul></li>
<li><strong>恢复修改的记录数据</strong>
<ul>
<li>在回滚某些事务时，如果出现对数据库的改变，则需要在日志中记录这些改变，保证在重复进行重新启动时不需要重复这些操作</li>
</ul></li>
</ul>
<h3 id="三个过程">三个过程</h3>
<ul>
<li><strong>分析过程</strong>
<ul>
<li>决定哪些事务要undo，哪些页在崩溃时是脏的，以及 redo 应从哪个 LSN
开始</li>
<li>丛最近的检查点开始</li>
</ul></li>
<li><strong>Redo 过程</strong>
<ul>
<li>从分析过程决定的位置开始，执行
redo，重复历史，将数据库恢复到发生崩溃前的状态</li>
</ul></li>
<li><strong>Undo 过程</strong>
<ul>
<li>回滚在发生崩溃时那些不完整的事务</li>
</ul></li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/09-2/image-20210721164653907.png" style="zoom:80%;"></p>
<h4 id="分析过程">分析过程</h4>
<ul>
<li>找到最后完整检查点日志记录，从该记录读入脏页表</li>
<li>从检查点继续向前扫描，每找到一个不在 undo-list
中的事务日志记录，就将其添加到 undo-list，每找到一个事务的 end
日志记录，就将其从 undo-list 中删除</li>
<li>只要发现一个更新页的日志记录，如果该页不在脏页表上，就将它添加进脏页表，并设置该页的
RecLSN 为该日志记录的 LSN</li>
<li>将要被 undo 的事务列表 undo-list
设置为检查点日志记录中的事务列表及其 LastLSN</li>
<li>将 RedoLSN 设置为脏页表中页的 RecLSN
的最小值，如果没有脏页，就将其设置为检查点日志记录的 LSN</li>
</ul>
<h4 id="redo-过程">Redo 过程</h4>
<ul>
<li>通过重演所有<strong>没有反映在磁盘页上的动作</strong>来重复历史</li>
<li>Redo 过程从 RedoLSN
开始向前扫描日志，该点之前的日志记录已经反映在磁盘数据库页上</li>
<li>只要找到一个 update 日志记录，它就执行如下动作：
<ul>
<li>如果该页不在脏页表中（说明更新已经写到磁盘上了），或者该 update
日志记录的 LSN 小于脏页表中该页的RecLSN，Redo过 程就跳过该日志记录</li>
<li>否则从磁盘调出该页，如果其 PageLSN 小于该日志记录的
LSN，重做该日志记录，修改 PageLSN 为该日志的 LSN</li>
</ul></li>
</ul>
<h4 id="undo-过程">Undo 过程</h4>
<ul>
<li><strong>Undo 过程反向扫描日志，取消所有 undo-list
中的事务</strong></li>
<li>如果找到一个 CLR，它用 UndoNextLSN
字段跳过一个已经回滚了的事务日志。否则，它用事务日志的 PrevLSN
字段查找下一个要被撤消的事务日志</li>
<li>每当一个 update 日志记录被用于撤消，Undo 过程产生一个包含 undo
执行动作的 CLR，并将 CLR 的 UndoNextLSN 设置为 update 日志记录的 PreLSN
值</li>
</ul>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.09.恢复控制</title>
    <url>/2021/06/13/DB/CLJ/09/</url>
    <content><![CDATA[<h1 id="恢复控制">恢复控制</h1>
<ul>
<li>目标
<ul>
<li>服务可用性
<ul>
<li>时间延迟</li>
</ul></li>
<li>数据可用性
<ul>
<li>数据一致性</li>
</ul></li>
</ul></li>
<li>可能的措施
<ul>
<li>备份</li>
<li>日志</li>
<li>把内存总的数据刷到稳定存储介质（磁盘等）上（ctrl+S）</li>
</ul></li>
</ul>
<h2 id="故障">故障</h2>
<h3 id="事务故障">事务故障</h3>
<ul>
<li>事务的运行没有到达预期的终点就被终止</li>
<li>影响范围只在这个事务上</li>
</ul>
<h4 id="非预期故障">非预期故障</h4>
<ul>
<li>不能由事务程序处理的（异常）</li>
<li>如运算溢出，发生死锁而被选中撤消该事务</li>
</ul>
<h4 id="可预期故障">可预期故障</h4>
<ul>
<li>应用程序可以发现的事务故障，并且应用程序可以让事务回滚</li>
<li>如转帐时发现帐面金额不足</li>
<li>写了异常处理，那么可以把非预期故障转变为可预期故障</li>
</ul>
<h3 id="系统故障">系统故障</h3>
<ul>
<li><strong>软故障</strong>（soft crash）</li>
<li>在硬件故障、软件错误的影响下，虽引起<strong>内存信息丢失</strong>，但未破坏外存中数据</li>
<li>如CPU故障、突然停电，DBMS、OS、应用程序等异常终止</li>
</ul>
<h3 id="介质故障">介质故障</h3>
<ul>
<li><strong>硬故障</strong>（hard crash）</li>
<li>又称<strong>磁盘故障</strong>，破坏<strong>外存上的数据库</strong>，并影响正在存取这部分数据的所有事务</li>
<li>如磁盘的磁头碰撞、瞬时的强磁场干扰</li>
<li>只能通过备份等方式恢复</li>
</ul>
<h3 id="恢复的定义">恢复的定义</h3>
<ul>
<li>恢复是把数据库从错误状态恢复到某一正确状态的功能，从而确保数据库的一致性</li>
<li>恢复的基本原理是<strong><span style="color:red">冗余</span></strong>，即数据库中任一部分的数据可以根据存储在系统别处的冗余数据来重建</li>
<li>冗余
<ul>
<li>备份（数据）</li>
<li>日志（事务活动）</li>
</ul></li>
</ul>
<h2 id="备份">备份</h2>
<h3 id="转储">转储</h3>
<ul>
<li>生成备份的过程：<strong>转储</strong>（dump）
<ul>
<li>将数据库复制到磁带或另一个磁盘上保存起来的过程</li>
<li>这些备用数据称为后备（后援）副本</li>
</ul></li>
</ul>
<h3 id="转储类型">转储类型</h3>
<ul>
<li>静态转储
<ul>
<li>转储期间不允许对数据库进行任何存取、修改活动</li>
<li><strong>转储期间不向外提供服务</strong></li>
</ul></li>
<li>动态转储
<ul>
<li>转储期间允许对数据库进行存取或修改</li>
<li><strong>转储期间数据块还对外提供服务</strong></li>
</ul></li>
<li>海量转储
<ul>
<li>每次转储<strong>全部数据库</strong></li>
</ul></li>
<li>增量转储
<ul>
<li>每次只转储上次转储后*<strong>更新过的数据</strong></li>
</ul></li>
</ul>
<h3 id="sql-server-数据库备份">SQL Server 数据库备份</h3>
<ul>
<li>完整的数据库备份</li>
<li>数据库备份创建备份完成时数据库内存在的数据的副本，通常按常规时间间隔调度</li>
<li>还原数据库备份将重新创建数据库和备份完成时数据库中存在的所有相关文件
<ul>
<li>但是，自创建备份后所做的任何数据库修改都将丢失</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE master</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> sp_addumpdevice <span class="string">&#x27;disk&#x27;</span>, <span class="string">&#x27;MyBKDB&#x27;</span>, DISK <span class="operator">=</span><span class="string">&#x27;c:\MyBKDB.dat&#x27;</span></span><br><span class="line"></span><br><span class="line">BACKUP DATABASE LJCHEN <span class="keyword">TO</span> MyBKDB</span><br><span class="line"></span><br><span class="line">RESTORE DATABASE LJCHEN <span class="keyword">FROM</span> MyBKDB</span><br></pre></td></tr></table></figure>
<h3 id="sql-server-差异数据库备份">SQL Server 差异数据库备份</h3>
<ul>
<li>差异数据库备份（DCM）</li>
<li>差异数据库备份只记录自上次数据库备份后发生更改的数据，比数据库备份小而且速度快</li>
<li>使用差异数据库备份将数据库还原到差异数据库备份完成时的那一点</li>
<li>初始得是一个全量的备份</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 全量备份 */</span></span><br><span class="line">BACKUP DATABASE LJCHEN <span class="keyword">TO</span> MyBKDB <span class="keyword">WITH</span> INIT</span><br><span class="line"><span class="comment">/* 增量备份*/</span></span><br><span class="line">BACKUP DATABASE LJCHEN <span class="keyword">TO</span> MyBKDB <span class="keyword">WITH</span> DIFFERENTIAL</span><br><span class="line"></span><br><span class="line">RESTORE DATABASE LJCHEN <span class="keyword">FROM</span> MyBKDB <span class="keyword">WITH</span> NORECOVERY</span><br><span class="line">RESTORE DATABASE LJCHEN <span class="keyword">FROM</span> MyBKDB <span class="keyword">WITH</span> FILE<span class="operator">=</span><span class="number">2</span>, RECOVERY</span><br></pre></td></tr></table></figure>
<ul>
<li>一个位图，每一个页一位，如果修改了则把这个页对应位图上的位置为 1
<ul>
<li>增量备份的时候把修改过的备份出去即可</li>
</ul></li>
</ul>
<h3 id="sql-server-事务日志备份">SQL Server 事务日志备份</h3>
<ul>
<li>事务日志是自上次备份事务日志后对数据库执行的所有事务的一系列记录，它可以将数据库恢复到特定的即时点或恢复到故障点</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">BACKUP DATABASE MyDB <span class="keyword">TO</span> MyDB_1 <span class="keyword">WITH</span> INIT</span><br><span class="line"></span><br><span class="line">BACKUP LOG MyDB <span class="keyword">TO</span> MyDB_log1</span><br><span class="line"></span><br><span class="line">BACKUP LOG MyDB <span class="keyword">TO</span> MyDB_log2 <span class="keyword">WITH</span> NO_TRUNCATE</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RESTORE DATABASE MyDB <span class="keyword">FROM</span> MyDB_1 <span class="keyword">WITH</span> NORECOVERY</span><br><span class="line"></span><br><span class="line">RESTORE LOG MyDB <span class="keyword">FROM</span> MyDB_log1 <span class="keyword">WITH</span> NORECOVERY</span><br><span class="line"></span><br><span class="line">RESTORE LOG MyDB <span class="keyword">FROM</span> MyDB_log2 <span class="keyword">WITH</span> RECOVERY</span><br></pre></td></tr></table></figure>
<ul>
<li>WITH NORECOVERY：<strong>重做所有日志记录</strong></li>
<li>WITH RECOVERY：<strong>回滚失败事务日志记录</strong></li>
</ul>
<h4 id="一个例子">一个例子</h4>
<ul>
<li>事务 T 从 A 帐户过户 50 到 B 帐户</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">read(A); A:<span class="operator">=</span>A<span class="number">-50</span>; write(A);</span><br><span class="line">read(B); B:<span class="operator">=</span>B<span class="operator">+</span><span class="number">50</span>; write(B);</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure>
<ul>
<li>由于某些原因，事务 T 的两个操作被写到两个日志文件
MyDB_log1、MyDB_log2 中了</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">MyDB_log1</span><br><span class="line">&lt;T,A,100,50&gt;</span><br><span class="line"></span><br><span class="line">MyDB_log2</span><br><span class="line">&lt;T,B,100,150&gt;</span><br><span class="line">commit</span><br></pre></td></tr></table></figure>
<ul>
<li>如下两种恢复方式的结果不同</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RESTORE LOG MyDB <span class="keyword">FROM</span> MyDB_log1 <span class="keyword">WITH</span> NORECOVERY</span><br><span class="line">RESTORE LOG MyDB <span class="keyword">FROM</span> MyDB_log2 <span class="keyword">WITH</span> RECOVERY</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A: 50, B: 150</span></span><br><span class="line"><span class="comment">正确的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RESTORE LOG MyDB <span class="keyword">FROM</span> MyDB_log1 <span class="keyword">WITH</span> RECOVERY</span><br><span class="line">RESTORE LOG MyDB <span class="keyword">FROM</span> MyDB_log2 <span class="keyword">WITH</span> RECOVERY</span><br><span class="line"></span><br><span class="line"><span class="comment">/* log1 中没有 commit, 认为是失败的事务, 被回滚 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A: 100, B: 150</span></span><br><span class="line"><span class="comment">错误的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>因此告诉我们，如果我们有多个日志备份文件
<ul>
<li>前面的文件应该都是 <code>WITH NORECORERY</code></li>
<li>只有最后一个日志文件是 <code>WITH RECOVERY</code></li>
</ul></li>
</ul>
<h3 id="sql-server-恢复模型">SQL Server 恢复模型</h3>
<ul>
<li>我们期望能够保留下来的工作越多，也就是希望数据库能够恢复到更近的一致性的状态
<ul>
<li>这与数据库系统平时付出的代价相关</li>
</ul></li>
</ul>
<h4 id="简单恢复">简单恢复</h4>
<ul>
<li>允许将数据库恢复到最新的备份
<ul>
<li>简单数据库备份，没有日志，只能恢复到最新的数据库备份那一刻的内容</li>
</ul></li>
<li>数据库备份 + 差异备份（可选）</li>
</ul>
<h4 id="完全恢复">完全恢复</h4>
<ul>
<li>允许将数据库恢复到故障点状态
<ul>
<li>完全恢复（恢复到尽可能近的状态），先通过数据库备份恢复，然后通过日志记录恢复</li>
</ul></li>
<li>数据库备份 + 差异备份（可选） + 事务日志备份</li>
</ul>
<h4 id="大容量日志记录恢复bcm">大容量日志记录恢复（BCM）</h4>
<ul>
<li>允许大容量日志记录操作（select into，bcp，bulk insert）
<ul>
<li>批量的修改会导致日志文件庞大，对性能造成影响</li>
<li>这种模式下，日志文件中只记录操作的帧，操作所影响的数据写到其他的数据文件中</li>
<li>BCM 位图实现，把影响的页面单独写出去，并在位图上做标记</li>
</ul></li>
<li>数据库备份 + 差异备份（可选） + 事务日志备份</li>
</ul>
<h4 id="切换恢复模型">切换恢复模型</h4>
<ul>
<li>可以将数据库从一个恢复模型切换到另一个恢复模型，以满足不断变化的业务要求</li>
<li>例如，如果系统需要完全的可恢复性，可以在装载和索引操作的过程中，将数据库的恢复模型更改到批量日志记录模型，然后再返回到完全恢复</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 切换恢复模型 */</span></span><br><span class="line"><span class="keyword">alter</span> database <span class="operator">&lt;</span>database_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">set</span> recovery[ <span class="keyword">FULL</span> <span class="operator">|</span> BULK_LOGGED <span class="operator">|</span> SIMPLE ]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看当前数据库所使用的恢复模型 */</span></span><br><span class="line"><span class="keyword">select</span> database propertyex(<span class="string">&#x27;&lt;database_name&gt;&#x27;</span>, <span class="string">&#x27;recovery&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="mysql-备份类型">MySQL 备份类型</h3>
<ul>
<li>备份内容
<ul>
<li>逻辑备份：从表的角度备份</li>
<li>裸文件备份：把磁盘上面的数据文件备份出去</li>
</ul></li>
<li>备份方法
<ul>
<li>热备(Hot Backup)：数据库保持业务工作的同时进行备份</li>
<li>冷备(Cold Backup)：数据库停下来备份</li>
<li>温备(Warm Backup)：只允许读操作下执行，不允许写操作执行</li>
</ul></li>
<li>备份数据库内容
<ul>
<li>完全备份</li>
<li>增量备份</li>
<li>日志备份</li>
</ul></li>
</ul>
<h3 id="mysql-备份工具">MySQL 备份工具</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump --databases db1 db2 db3 &gt; dump.sql</span><br><span class="line">mysqldump --no-data -databases db1 db2 &gt; structure.sql</span><br><span class="line">mysqldump <span class="built_in">test</span> t1 t3 t7 &gt; dump.sql</span><br><span class="line"><span class="built_in">source</span> dump.sql</span><br></pre></td></tr></table></figure>
<ul>
<li>这种方式同时可用于在不同的数据库之间交换内容</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 导出到文件 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">into</span> outfile <span class="string">&#x27;data.txt&#x27;</span></span><br><span class="line">fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">lines terminated <span class="keyword">by</span> <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line"><span class="keyword">from</span> my_table</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从文件中恢复 */</span></span><br><span class="line">load data infile <span class="string">&#x27;data.txt&#x27;</span></span><br><span class="line"><span class="keyword">into</span> <span class="keyword">table</span> my_table</span><br><span class="line">fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">lines terminated <span class="keyword">by</span> <span class="string">&#x27;\r\n&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="mysql-热备工具">MySQL 热备工具</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innobackupex --user=root --password=123456 --host=127.0.0.1 /backups/</span><br><span class="line"></span><br><span class="line">innobackupex --apply-log /backups</span><br><span class="line"></span><br><span class="line">innobackupex --copy-back /backups</span><br></pre></td></tr></table></figure>
<ul>
<li>在<strong>增量备份</strong>时，比较表空间中每个页的 LSN
是否大于上次备份时的 LSN，若是，则备份</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/09/image-20210613171041017.png"></p>
<h2 id="日志">日志</h2>
<ul>
<li>日志文件是<strong>以事务为单位</strong>用来记录数据库的每一次更新活动的文件，由系统自动记录
<ul>
<li>增删改，不记录查询</li>
</ul></li>
<li>日志内容包括
<ul>
<li>记录名、旧记录值、新记录值、事务标识符、操作标识符等</li>
</ul></li>
<li>内容如下
<ul>
<li>事务 Ti 开始时，写入日志：Tistart</li>
<li>事务 Ti 执行 write(X) 前，写入日志：&lt;Ti,X,V1,V2&gt;
<ul>
<li>V1 是 X 更新前的值，V2 是 X 更新后的值</li>
</ul></li>
<li>事务 Ti 结束后，写入日志：Ticommit</li>
</ul></li>
<li>日志记录的是值的变换，而不是逻辑的操作
<ul>
<li>记录的是物理值的话，不管重复多少次，结果中是一致的</li>
<li>如果记录具体的逻辑操作，重复多次的结果不一样
<ul>
<li>例如一个操作是-10，重复多次则会多次-10</li>
</ul></li>
</ul></li>
</ul>
<h3 id="事务分类">事务分类</h3>
<ul>
<li>基于日志记录对事务进行分类</li>
<li>圆满事务（成功了）
<ul>
<li>日志文件中记录了事务的 commit 标识</li>
</ul></li>
<li>夭折事务（失败的）
<ul>
<li>日志文件中只有事务的 begin transaction 标识，无 commit</li>
</ul></li>
</ul>
<h3 id="基本的恢复操作">基本的恢复操作</h3>
<ul>
<li>对圆满事务所做过的修改应执行 redo
操作，即重新执行该操作，修改对象被赋予<strong>新记录值</strong>
<ul>
<li>不管 redo 多少次，结果都是一样的（<span class="math inline">\(\mathrm{redo^2=redo}\)</span>）</li>
</ul></li>
<li>对夭折事务所做过的修改应执行undo操作，即撤消该操作，修改对象被赋予<strong>旧记录值</strong>
<ul>
<li><span class="math inline">\(\mathrm{undo^2=undo}\)</span></li>
</ul></li>
</ul>
<h3 id="事务的原语操作">事务的原语操作</h3>
<ul>
<li>input(X)：将包含数据库元素 X
的<strong>磁盘块</strong>拷贝到<strong>内存缓冲区</strong></li>
<li>read(X,t)：将<strong>内存缓冲区</strong>的数据库元素 X
拷贝到事务的<strong>局部变量</strong> t</li>
<li>write(X,t)：将<strong>局部变量</strong> t
的值拷贝到<strong>内存缓冲区</strong>中的数据库元素 X</li>
<li>output(X)：将包含 X
的<strong>缓冲区</strong>拷贝回<strong>磁盘</strong></li>
<li>发出者不同
<ul>
<li>read 和 write 由<strong>事务</strong>发出</li>
<li>input 和 output
由<strong>缓冲区管理器</strong>（或<strong>日志管理器</strong>）发出</li>
</ul></li>
</ul>
<h3 id="先写日志的原则wal">先写日志的原则(WAL)</h3>
<ul>
<li>保证原子性（<strong>all or not</strong>）
<ul>
<li>文件系统 xv6 的日志系统也是如此</li>
</ul></li>
<li>日志记录将要发生何种修改</li>
<li>写入 DB 表示实际发生何种修改</li>
<li>Write Ahead Log（WAL）
<ul>
<li>对于尚未提交的事务，在将DB缓冲区写到外存之前，必须先将日志缓冲区内容写到外存去</li>
</ul></li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/09/image-20210613172816406.png" style="zoom:67%;"></p>
<ul>
<li>如果先写
DB，则可能在写的中途发生系统崩溃，导致内存缓冲区内容丢失，而外存 DB
处于不一致状态，由于日志缓冲区内容已破坏，导致无法对 DB 恢复</li>
<li>如果先写数据库再写日志记录的话
<ul>
<li>假设这样的一种情况，日志记录还没写完，系统崩溃了</li>
<li>此时日志中只有 A 的记录</li>
<li>故障恢复的时候，由于缺少 commit，认为是夭折事务，执行 undo</li>
<li>此时 B 的结果没有修改回去，造成错误（不一致）</li>
</ul></li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/09/image-20210613221235500.png" style="zoom:67%;"></p>
<ul>
<li>先写日志则能够恢复到一致的状态
<ul>
<li>以下是写 B 日志的时候系统崩溃了的情况</li>
<li>此时 redo 操作能够撤销 A 的修改，虽然 B 没有修改，但是 redo
也不会将其改成错误数据</li>
</ul></li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/09/image-20210613221653647.png" style="zoom:67%;"></p>
<ul>
<li>日志写完了，但是磁盘没写完，此时系统崩溃了，通过 redo
操作实现一致</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/09/image-20210613221940870.png" style="zoom:67%;"></p>
<h3 id="写时机">写时机</h3>
<ul>
<li>日志缓冲区和数据库缓冲区的写时机不同</li>
<li><strong>同步（synchronous）写日志</strong>
<ul>
<li>只有事务的相关日志已经完全在磁盘上了，才会向进程发送该事务已提交的确认消息</li>
<li>事务提交驱动</li>
</ul></li>
<li><strong>异步（asynchronous）写缓冲区</strong>
<ul>
<li>只需要将数据页的写入操作投递给操作系统即可，不需要等待其完成</li>
<li>不是事务提交驱动的</li>
</ul></li>
</ul>
<h3 id="buffer-managerbm">Buffer Manager(BM)</h3>
<ul>
<li>不同策略（当然要求先写日志）
<ul>
<li>Steal policy
<ul>
<li>对内存页面的更改可以随意同步回硬盘而<strong>不需要等待事务提交</strong></li>
</ul></li>
<li>Force policy
<ul>
<li>事务在提交前，它所有更改的页面必须写回到硬盘</li>
</ul></li>
</ul></li>
<li>ARIES 的 BM 遵循 “Non-Force，Steal”</li>
<li>如果必须等待所有更改过页面的事务都提交了才同步这个内存页到磁盘会如何？
<ul>
<li>如果需要支持行锁，那么一个页面可能有多个行被不同的 Tx
更改，这个页面必须等待所有的 Tx 都 Commit，但是如果不断有新的 Tx
来更改这个页面，这个页面就迟迟无法同步回物理页面</li>
</ul></li>
</ul>
<h3 id="读取一个页面的过程">读取一个页面的过程</h3>
<ul>
<li>如果事务没结束，那么日志也不一定写回到磁盘</li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/09/image-20210613223550791.png" style="zoom:67%;"></p>
<h3 id="mysql-日志刷写时机">MySQL 日志刷写时机</h3>
<ul>
<li>在主线程<strong>每秒一次</strong>的循环中，将重做日志缓冲器的内容刷新到重做日志文件中，即便某个事务尚未提交</li>
<li>由参数 innodb_flush_log_at_trx_commit 控制
<ul>
<li>0 代表提交事务时，并不立即刷出日志，而是等待主线程每秒的刷新
<ul>
<li>1 秒之内失败的话，事务结果会丢失</li>
</ul></li>
<li>1 代表提交事务时，将重做日志同步写磁盘，也即伴有 fsync() 的调用
<ul>
<li>磁盘 IO 开销比较大</li>
</ul></li>
<li>2 代表提交事务时，将重做日志异步写磁盘，也即写入文件系统缓存中
<ul>
<li>可能操作系统没有把他落盘</li>
</ul></li>
</ul></li>
<li>有两个缓冲区
<ul>
<li>数据库缓冲区、操作系统缓冲区</li>
</ul></li>
</ul>
<p><img src="/2021/06/13/DB/CLJ/09/image-20210613225205691.png" style="zoom: 45%;"></p>
<h3 id="mysql-组提交">MySQL 组提交</h3>
<ul>
<li>磁盘 I/O 开销大</li>
<li>fsync 是昂贵的操作，MySQL 一次事务提交最多会导致 3 次 fsync</li>
<li>组提交通过将多个并发需要提交的事务共享一次 fsync
操作来进行数据的持久化</li>
<li>binlog_group_commit_sync_delay=N
<ul>
<li>在等待 N 微秒后，进行 binlog 刷盘操作</li>
</ul></li>
<li>binlog_group_commit_sync_no_delay_count=N
<ul>
<li>达到最大事务等待数量，开始 binlog 刷盘</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.10.数据库存储(2)</title>
    <url>/2021/07/21/DB/CLJ/10-1/</url>
    <content><![CDATA[<h1 id="数据库存储">数据库存储</h1>
<h2 id="缓冲区">缓冲区</h2>
<h3 id="缓冲区管理">缓冲区管理</h3>
<ul>
<li>为快速找到页面，内存页面地址被散列</li>
<li>dbid-fileno-pageno 标识（数据库ID, 文件号、页面号）的 hash 地址</li>
<li>当需要访问一个磁盘块时
<ul>
<li>如果该块已在缓冲区中，返回块在内存中的地址</li>
<li>如果块不在缓冲区中
<ul>
<li>缓冲区管理器为该块在缓冲区中分配空间，如果有必要，替换缓冲区中的其他块</li>
<li>如果被替换的块被修改过，则将其写回磁盘</li>
<li>将所需块调入缓冲区，返回其在缓冲区的地址</li>
</ul></li>
</ul></li>
</ul>
<h4 id="被钉住的块">被钉住的块</h4>
<ul>
<li>pinned blocks</li>
<li>不允许写回磁盘的块</li>
<li>当一个块上的<strong>更新正在进行</strong>时，不允许写回磁盘</li>
<li>可以钉住<strong>被频繁访问的小表</strong></li>
</ul>
<h4 id="块的强制刷出">块的强制刷出</h4>
<ul>
<li>forced output of blocks</li>
<li>先写日志原则，<strong>被更新的数据页刷出</strong>时，<strong>对应的日志记录</strong>被强制刷出</li>
<li><strong>生成检查点</strong>时，<strong>日志和数据缓冲区</strong>被强制刷出</li>
<li><strong>提交事务</strong>时，其<strong>日志记录</strong>被强制刷出</li>
</ul>
<h4 id="替换策略">替换策略</h4>
<ul>
<li><strong>LRU</strong>
<ul>
<li><strong>最近最少使用</strong></li>
<li>如果必须替换一个块，则替换最近最少使用的块</li>
</ul></li>
<li><strong>MRU</strong>
<ul>
<li><strong>最近最常使用</strong></li>
<li>如果必须替换一个块，则替换最近最常使用的块</li>
<li>适用于每个数据块只会被操作一次</li>
</ul></li>
</ul>
<h5 id="mru-在数据库缓冲区管理中的应用场景">MRU
在数据库缓冲区管理中的应用场景</h5>
<ul>
<li><span class="math inline">\(R\bowtie S\)</span></li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">对于 R 中的每条元组 tr</span><br><span class="line">    对于 S 中的每条元组 ts</span><br></pre></td></tr></table></figure>
<ul>
<li>一旦 R 中的一个元组处理完，就不会再使用它了，应该立即丢弃（toss
immediate）</li>
<li>当 S 中的一个元组被处理完，只有其他 S
中的元组都被处理完后才会再用到它，应该采用 MRU</li>
<li>例子：<span class="math inline">\(R\bowtie S\)</span>
<ul>
<li>R 两条记录 r1、r2，S 两条记录 s1、s2，缓存大小 3</li>
<li>使用 MRU，当读入 r2 的时候淘汰 r1</li>
</ul></li>
<li>实际数据库中使用的都是类似 LRU 的算法</li>
</ul>
<h3 id="sql-server-缓冲区">SQL Server 缓冲区</h3>
<ul>
<li>Lazywriter（缓冲池管理器）</li>
<li>使用<strong>时钟算法</strong></li>
<li>每个缓冲池有一个<strong>计数器</strong>，当有进程访问该缓冲池时，计数器加一</li>
<li>淘汰页面时，Lazywriter 扫描每个缓冲池
<ul>
<li>如果其计数器为 0，则释放该空间（如果发生修改，则写回磁盘）</li>
<li>如果计数器不为 0，则<strong>计数器减一</strong></li>
</ul></li>
</ul>
<h3 id="mysql-缓冲区管理">MySQL 缓冲区管理</h3>
<ul>
<li>链表组织</li>
<li><span class="math inline">\(\dfrac{3}{8}\)</span>
存储老的数据（old），<span class="math inline">\(\dfrac{5}{8}\)</span>
存储新的数据（young）</li>
<li><strong>读进来的新页面</strong>放在<strong>分界的地方</strong>
<ul>
<li>自然按照链表的顺序淘汰页面</li>
</ul></li>
<li>如果页面被访问到了，则将其放到新数据链表的头部</li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210721224733000.png" style="zoom: 50%;"></p>
<ul>
<li>如果页面是被 SQL
语句读取的，它会马上访问旧列表并将其推入<strong>新列表头部</strong></li>
<li>如果是预读读取的页面，则不会发生对旧列表的访问</li>
</ul>
<h3 id="mysql-double-write">MySQL double write</h3>
<ul>
<li>操作系统往磁盘写，最基本的单位是一个扇区</li>
<li>数据库页面可能由多个扇区构成，怎么保证操作系统把这些山区都写入磁盘？</li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210721225329292.png" style="zoom: 50%;"></p>
<ul>
<li>步骤
<ul>
<li>1：页数据先 memcopy 到 DWB 内存</li>
<li>2：DWB 内存先刷到 DWB 磁盘</li>
<li>3：DWB 内存再刷到数据磁盘</li>
</ul></li>
<li>实现全或无
<ul>
<li>一旦开始写磁盘，说明这些数据都已经写入到 DWB 中</li>
<li>如果写到 DWB 的过程中挂了的话，就全不写</li>
</ul></li>
</ul>
<h3 id="mysql-change-buffer">MySQL change buffer</h3>
<ul>
<li>如何把对二级索引的随机写改成批量写？
<ul>
<li>非聚簇索引在物理上是不连续的</li>
<li>聚簇索引在物理上是连续的</li>
</ul></li>
<li>这样对索引的连续写可能是对物理页的非连续写</li>
<li>先把对二级索引的更新缓存起来，凑齐到一部分之后一起更新（减少随机写）</li>
<li>无 change buffer</li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210721230244439.png" style="zoom:50%;"></p>
<ul>
<li>有 change buffer</li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210721230448689.png" style="zoom:50%;"></p>
<ul>
<li>具体实现如下图
<ul>
<li>读盘先在 change buffer 中找，找到则直接返回</li>
<li>系统在空闲时运行清除（purge）操作，将更新的索引页写入磁盘</li>
</ul></li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210721230544229.png" style="zoom: 80%;"></p>
<h4 id="多大缓冲区是合适的">多大缓冲区是合适的</h4>
<ul>
<li>缓冲区过大占用过多内存
<ul>
<li>保持数据在内存，减少磁盘I/O，增加内存代价</li>
</ul></li>
<li>若一个页面每秒被访问 n 次，将它驻留在内存节省 <span class="math inline">\(\mathrm{n*\dfrac{price\_per\_disk\_drive}{accesses\_per\_second\_per\_disk}}\)</span></li>
<li>保持一个页面在内存的代价 <span class="math inline">\(\mathrm{\dfrac{price\_per\_MB\_of\_memory}{pages\_per\_MB\_of\_memory}}\)</span></li>
<li>对比两个代价得出结果</li>
<li><strong>5-minute rule</strong>
<ul>
<li>如果一个<strong>被随机访问</strong>的页面的使用频率超过<strong>每 5
分钟一次</strong>，那么它应该被驻留在内存</li>
</ul></li>
<li><strong>1-minute rule</strong>
<ul>
<li>如果<strong>被顺序访问</strong>的页面的使用频率超过<strong>每 1
分钟一次</strong>，那么它应该被驻留在内存</li>
</ul></li>
<li>如果内存太小，不能满足 5 分钟规则的话，说明应该扩充内存</li>
</ul>
<h2 id="存储结构">存储结构</h2>
<h3 id="sql-server-数据库存储结构">SQL Server 数据库存储结构</h3>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210722103234256.png" style="zoom: 80%;"></p>
<h4 id="页面与区间">页面与区间</h4>
<ul>
<li>数据文件被划分成 8k 的页面</li>
<li>每个文件中的页面号<strong>都以 0
开始</strong>（文件内的逻辑页面号）</li>
<li>页面号的形式为 <strong>(file#:page#)</strong>，如(3:124)</li>
<li><strong>8 个连续页面</strong>构成一个<strong>区间</strong> ——
<strong>64k</strong>
<ul>
<li>总是从能被 8 整除的页面开始</li>
</ul></li>
<li><strong>存储分配总是按照区间为单位进行</strong>
<ul>
<li>对象每次增长1个区间</li>
</ul></li>
<li>I/O
可以按<strong>页面</strong>（8KB）或者<strong>区间</strong>（64KB）来进行</li>
</ul>
<h4 id="存储结构的几个基本问题">存储结构的几个基本问题</h4>
<ul>
<li>如何为对象分配空间？
<ul>
<li>GAM、SGAM、PFS</li>
</ul></li>
<li>如何找到对象占据的空间？
<ul>
<li>IAM</li>
</ul></li>
<li>行在页内是如何存储的？</li>
</ul>
<h4 id="gam">GAM</h4>
<ul>
<li>Global Allocation Map</li>
<li>全局分配位图</li>
<li><strong>记录文件当中哪些区间已经被分配的页面</strong>
<ul>
<li>可以看成是一个8000个字节的位图</li>
</ul></li>
<li><strong>每个位代表一个区间</strong>
<ul>
<li>位 0 代表区间 0，位 1 代表区间 8，位 2 代表区间 16</li>
<li>0：被使用；1：未被使用</li>
</ul></li>
<li>一个页面 8k 字节 = 64k 位
<ul>
<li>能够表达 64k 个区间（512k 个页面）</li>
<li>64k x 64k = 4G</li>
</ul></li>
<li>一个 GAM 表达不下就使用多个 GAM</li>
<li>第一个 GAM 位于文件的第三个页面（page2）
<ul>
<li>下一个GAM位于第 511232 个页面</li>
<li>具体计算方式涉及到具体放置内存的方式</li>
</ul></li>
<li>GAM 总是位于它所控制范围的第一个页面</li>
</ul>
<h4 id="sgam">SGAM</h4>
<ul>
<li>共享全局分配位图</li>
<li>结构与 GAM
相同，用于表示文件中<strong>哪些区间被作为共享区间分配</strong>并且仍然<strong>有空闲区间可供分配</strong></li>
<li>每一位代表一个区间
<ul>
<li>位 0 代表区间 0，位 1 代表区间 8，位 2 代表区间 16</li>
<li>0：区间要么不是共享区间，要么共享区间没有空闲页</li>
<li>1：区间是共享区间，并且至少有一个空闲页</li>
</ul></li>
<li>表达 4 GB 数据空间，与对应的 GAM 表达范围相同</li>
<li>如果文件大于 4GB，可以增加新的 SGAM 页</li>
<li>第一个SGAM位于文件的第四个页面（page3）
<ul>
<li>下一个 SGAM 位于第 511233 个页面</li>
</ul></li>
</ul>
<h4 id="gam-与-sgam">GAM 与 SGAM</h4>
<table>
<colgroup>
<col style="width: 53%">
<col style="width: 22%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Current Use of Extent</th>
<th style="text-align: center;">GAM Bit Setting</th>
<th style="text-align: center;">SGAM Bit Setting</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Free, not in use</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">Uniform extent, or full mixed
extent</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Mixed extent with free pages</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<ul>
<li>如果需要一个新的、完全没有使用的区间，可以从 GAM 中寻找位为 1
的区间</li>
<li>如果需要一个有空闲页的混合区间，可以寻找在 GAM 中位为
0、在SGAM中位为 1 的区间</li>
</ul>
<h4 id="pfs">PFS</h4>
<ul>
<li>空闲页空间</li>
<li>记录<strong>文件</strong>中<strong>每个页面</strong>是否已经被分配以及有多少空闲空间</li>
<li>每一个页面在 PFS 页中有一个字节对应</li>
<li>每个PFS覆盖8088个连续页面（64MB）</li>
<li>页面充满度：0，1-50%，51-80%，81-95%，96-100%</li>
<li>第一个 PFS 位于<strong>文件的第二个页面</strong>（page1），以后每
8088 都是一个 PSF 页</li>
</ul>
<h4 id="iam">IAM</h4>
<ul>
<li>索引分配位图</li>
<li>如何发现一个特定对象的区间或页面？</li>
<li>每个表 /
索引都至少有一个IAM，<strong>记录该对象拥有哪些区间</strong></li>
<li>IAM 覆盖的范围与 GAM 相同
<ul>
<li>如果位为 1，说明该<strong>区间</strong>被分配给该对象；如果位为
0，说明该区间未被分配给该对象</li>
<li>如 11000000，说明第一、二个区间被分配给该对象</li>
</ul></li>
<li>一个对象每占据文件的 4G 空间，就需要一个 IAM，对象的所有 IAM
构成一个<strong>双向链表</strong></li>
</ul>
<h4 id="基本页结构">基本页结构</h4>
<ul>
<li>所有页面包括<strong>页面头</strong>、<strong>页面体</strong>、<strong>页面槽</strong></li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210722112838687.png" style="zoom:80%;"></p>
<ul>
<li>页面槽记录每行在页面内的偏移，<strong>位于页面最后面</strong>
<ul>
<li>方便存储：数据是从空闲的地方往后加，页面槽是从后往前加</li>
</ul></li>
</ul>
<h5 id="页头字段含义">页头字段含义</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Field</th>
<th style="text-align: center;">What It Contains</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">pageID</td>
<td style="text-align: center;">数据库中该页的文件号和页号</td>
</tr>
<tr class="even">
<td style="text-align: center;">nextPage</td>
<td style="text-align: center;">在页链中该页的下一页的文件号和页号</td>
</tr>
<tr class="odd">
<td style="text-align: center;">prevPage</td>
<td style="text-align: center;">在页链中该页的上一页的文件号和页号</td>
</tr>
<tr class="even">
<td style="text-align: center;">objID</td>
<td style="text-align: center;">该页所属对象的ID</td>
</tr>
<tr class="odd">
<td style="text-align: center;">lsn</td>
<td style="text-align: center;">用于修改该页的日志序列号(LSN)</td>
</tr>
<tr class="even">
<td style="text-align: center;">slotCnt</td>
<td style="text-align: center;">该页上槽的总数</td>
</tr>
<tr class="odd">
<td style="text-align: center;">level</td>
<td style="text-align: center;">该页在索引中的级别（对于叶级别该值为0）</td>
</tr>
<tr class="even">
<td style="text-align: center;">indexId</td>
<td style="text-align: center;">该页的索引ID(对于数据页该值为0)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">freeData</td>
<td style="text-align: center;">该页上第一个空闲空间的字节偏移量</td>
</tr>
<tr class="even">
<td style="text-align: center;">pminlen</td>
<td style="text-align: center;">行的固定长部分的字节数</td>
</tr>
<tr class="odd">
<td style="text-align: center;">freeCnt</td>
<td style="text-align: center;">该页上空闲字节的数目</td>
</tr>
<tr class="even">
<td style="text-align: center;">reservedCnt</td>
<td style="text-align: center;">由所有事务保留的字节数</td>
</tr>
<tr class="odd">
<td style="text-align: center;">xactreserved</td>
<td style="text-align: center;">由最近启动的事务保留的字节数</td>
</tr>
<tr class="even">
<td style="text-align: center;">tornBits</td>
<td style="text-align: center;">每个扇区1位，用于监测使该页分裂的写</td>
</tr>
<tr class="odd">
<td style="text-align: center;">flagBits</td>
<td style="text-align: center;">一个两字节的位图，包含有关该页的额外信息</td>
</tr>
</tbody>
</table>
<h4 id="数据行结构">数据行结构</h4>
<ul>
<li>如何处理定长数据和<strong>变长数据</strong></li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210722113548472.png" style="zoom:80%;"></p>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210722113811375.png" style="zoom: 80%;"></p>
<ul>
<li>观察内部存储结构</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.partitions</span><br><span class="line"><span class="keyword">where</span> object_id <span class="operator">=</span> object_id(<span class="string">&#x27;Customer&#x27;</span>)</span><br><span class="line"><span class="comment">-- 得到 partition_id = 72057594057457664</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.system_internals_allocation_units</span><br><span class="line"><span class="keyword">where</span> container_id <span class="operator">=</span> <span class="number">72057594057457664</span></span><br><span class="line"><span class="comment">-- 得到 root_page = 0x1A5F00000100, 倒序为0x000100005F1A</span></span><br><span class="line"><span class="comment">-- 前两个字节为文件号，后四个字节为页面号，页面是(1,23071)</span></span><br><span class="line"></span><br><span class="line">dbcc traceon(<span class="number">3604</span>)</span><br><span class="line">dbcc page(<span class="string">&#x27;adventureworks2012&#x27;</span>, <span class="number">1</span>, <span class="number">23071</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">-- 输出 BUFFER, PAGEHEADER, DATA, OFFSETTABLE</span></span><br></pre></td></tr></table></figure>
<h3 id="mysql-数据库存储结构">MySQL 数据库存储结构</h3>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210722114105041.png"></p>
<ul>
<li>Segment：数据段，索引段，回滚段</li>
<li>Page：数据页、回滚页、系统页、事务页、插入缓冲位图页</li>
</ul>
<h4 id="文件结构">文件结构</h4>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210722114207144.png" style="zoom: 50%;"></p>
<ul>
<li>校验页的完整性
<ul>
<li>本页有多少条记录，第一条记录的地址，页目录中有多少
slot，最后插入记录的位置</li>
</ul></li>
</ul>
<h4 id="页结构">页结构</h4>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210722114401636.png" style="zoom:80%;"></p>
<h4 id="行结构">行结构</h4>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210722114602395.png" style="zoom:50%;"></p>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210722114625218.png" style="zoom:50%;"></p>
<ul>
<li>删除记录不是直接删除，而是做一个标记（delete_mask）</li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210722114444941.png" style="zoom: 40%;"></p>
<h5 id="行结构示例">行结构示例</h5>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210722114725025.png" style="zoom:50%;"></p>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210722114733862.png" style="zoom: 50%;"></p>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210722114755994.png" style="zoom: 60%;"></p>
<h5 id="行溢出数据">行溢出数据</h5>
<ul>
<li>某些行特别大</li>
<li>Dynamic 行格式完全放入溢出页</li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10-1/image-20210722114843730.png" style="zoom: 67%;"></p>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.10.数据库存储</title>
    <url>/2021/07/21/DB/CLJ/10/</url>
    <content><![CDATA[<h1 id="数据库存储">数据库存储</h1>
<h2 id="存储介质">存储介质</h2>
<h3 id="物理存储介质">物理存储介质</h3>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721165645564.png" style="zoom:80%;"></p>
<ul>
<li>根据读写性能调整数据库算法</li>
<li>缓存：<strong>局部性原理</strong></li>
<li>性能</li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721170151776.png" style="zoom:80%;"></p>
<ul>
<li>高速缓冲存储器（cache）
<ul>
<li>最快最昂贵的存储介质</li>
<li>很小，由操作系统管理</li>
</ul></li>
<li>主存储器（main memory）
<ul>
<li>存放可被处理的数据的存储介质</li>
<li>易失，相对整个数据库太小</li>
</ul></li>
<li>快闪存储器（flash memory）
<ul>
<li>读性能类似主存，写速度非常慢</li>
<li>电子可擦除可编程只读存储器 (Electrically Erasable Programmable
Read-Only Memory)</li>
</ul></li>
<li>磁盘存储器（Magnetic-disk storage）
<ul>
<li>直接读取设备，支持随机读取</li>
<li>非易失联机数据存储设备</li>
<li>访问数据时，磁盘 <span class="math inline">\(\to\)</span> 内存</li>
<li>修改后的数据，内存 <span class="math inline">\(\to\)</span>
磁盘</li>
</ul></li>
<li>光学存储器（Optical storage）
<ul>
<li>只读(CD-ROM)、一次写多次读(WORM)、多次写(CD-RW)</li>
</ul></li>
<li>磁带（tape）
<ul>
<li>顺序访问，归档存储，容量大，价格便宜</li>
</ul></li>
</ul>
<h3 id="磁盘">磁盘</h3>
<ul>
<li>磁盘物理结构</li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721170407711.png" style="zoom:80%;"></p>
<ul>
<li>盘片(platter)、磁道(track)、扇区(sector)、柱面(cylinder)、磁盘臂(diskarm)</li>
<li>读写头(read-write head)：反转磁性物质磁化方向</li>
<li>磁盘控制器(disk controller)：
<ul>
<li>接受读写扇区命令，定位读写头</li>
<li>向扇区写入数据时附加校验和(checksum)，读取时重新计算校验和</li>
</ul></li>
</ul>
<h4 id="磁盘性能度量">磁盘性能度量</h4>
<ul>
<li><strong>访问时间</strong>
<ul>
<li>从发出读写请求到数据开始传输之间的时间</li>
<li>先移动磁盘臂，定位到正确的磁道，然后旋转磁盘，直到指定扇区出现在读写头下方</li>
</ul></li>
<li><strong>寻道时间</strong>（seek time）
<ul>
<li>磁盘臂重定位时间，取决于目标磁道和磁盘臂当前距离，2~30毫秒。平均寻道时间是最大寻道时间的1/3</li>
</ul></li>
<li><strong>旋转等待时间</strong>（rotational latency tiime）
<ul>
<li>目标扇区旋转到读写头下面的时间，每转在4~11毫秒之间。平均旋转时间是旋转一周的1/2</li>
</ul></li>
<li><strong>数据传输率</strong>（data-transfer rate）
<ul>
<li>25~100兆/秒</li>
</ul></li>
</ul>
<h4 id="磁盘访问优化">磁盘访问优化</h4>
<ul>
<li><strong>磁盘块的大小</strong>
<ul>
<li>小，更多的磁盘传输次数</li>
<li>大，空间浪费</li>
</ul></li>
<li><strong>调度</strong>
<ul>
<li>块在一个柱面上，按块经过读写头的顺序访问</li>
<li>块在不同柱面上，按使磁盘臂移动距离最短的顺序访问</li>
<li>电梯算法</li>
</ul></li>
<li><strong>文件组织</strong>
<ul>
<li>按与预期数据访问方式最接近的方式组织磁盘块</li>
<li>碎片整理</li>
</ul></li>
<li><strong>日志磁盘</strong>
<ul>
<li><strong>顺序写</strong>，消除了寻道时间</li>
<li>检查点</li>
<li>顺序写：把物理上相邻的页面聚集大一起，一次性写入磁盘</li>
</ul></li>
</ul>
<h4 id="磁盘的顺序和随机访问对比">磁盘的顺序和随机访问对比</h4>
<ul>
<li>7200rpm 的希捷 SATA 硬盘顺序读写基本都能达到 300MB/s</li>
<li>随机读写 100IOPS，假设每次 IO 大小为 1KB，则随机读写数据带宽为
100KB/s</li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721171520371.png" style="zoom:150%;"></p>
<ul>
<li>不同介质的顺序和随机访问对比</li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721171621527.png" style="zoom:150%;"></p>
<ul>
<li><strong>尽可能顺序读！！！</strong></li>
</ul>
<h4 id="发掘磁盘顺序读的性能">发掘磁盘顺序读的性能</h4>
<h5 id="预读">预读</h5>
<ul>
<li>prefetch、read-ahead
<ul>
<li>将临近的数据读进来</li>
</ul></li>
<li>局部性原理</li>
<li>MySQL线性预读（linear read-ahead）：是否将下一个 extent 预读到
buffer pool 中
<ul>
<li>如果一个 extent 中被顺序读取的 page 超过或者等于该参数变量时，Innodb
将会异步将下一个 extent 读取到 bufferpool 中</li>
</ul></li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721171939746.png"></p>
<h3 id="lsm">LSM</h3>
<ul>
<li>The Log-Structured Merge-Tree（LSM-Tree）</li>
<li>假设要写入10000 个 随机 key
<ul>
<li>最快的磁盘写入方式是批量顺序写，但这样带来的问题是每次查询都需要遍历整个数据</li>
<li>如果想获得高磁盘读性能，就需要对数据像 B
树那样进行排序，但其写性能又太差</li>
<li>如何权衡？<span class="math inline">\(\to\)</span> LSM 树</li>
</ul></li>
<li>将 <span class="math inline">\(N\)</span>
个数据划分成多个小的有序结构，每 <span class="math inline">\(m\)</span>
个数据在内存里排序一次，这样就获得 <span class="math inline">\(\dfrac{N}{m}\)</span>
个有序结构；查询时从最新的一个有序结构里做二分查找，如果没找到就继续查找下一个有序结构
<ul>
<li>读取的时间复杂度是 <span class="math inline">\(\dfrac{N}{m}\log_{2}{M}\)</span></li>
</ul></li>
<li>LSM 把一棵大树拆分成 N
棵小树，随着小树越来越大，<strong>内存中的小树会 flush
到磁盘中</strong>，<strong>磁盘中的树定期做 merge
操作</strong>，合并成一棵大树，以优化读性能
<ul>
<li>内存中满了之后整体刷到磁盘上，这样是顺序写，而不是 B 树或者 B+
树的随机写</li>
</ul></li>
<li>将对数据的修改增量保持在内存中，达到指定的大小限制后再批量写入磁盘，所以写入性能大大提升</li>
<li>需要合并磁盘中历史数据和内存中最近修改操作</li>
<li><strong>读取时需要先看是否命中内存，否则需要访问较多的磁盘文件</strong></li>
<li>在合并过程中，并不会像 B+
树一样，在原数据的位置上修改，而是<strong>直接插入新的数据</strong>，从而避免了随机写</li>
<li>当磁盘中的小树<strong>合并</strong>成一个大树的时候，可以<strong>重新排好顺序</strong>，使得block连续，优化读性能</li>
<li>LSM-Tree
属于传输型，因为它会使用日志文件和一个内存存储结构把<strong>随机写操作转化为顺序写</strong></li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721173142744.png"></p>
<ul>
<li>对于删除操作，只需在 memtable 中插入一条数据当作标志，如
delKey:1933</li>
<li>当读操作读到 memtable 中这个标志时，就会知道这个 key 已被删除</li>
<li>把树刷到磁盘的时候，修改为 immutable，不允许修改</li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721173314280.png"></p>
<ul>
<li>怎么保证读到的数据是最新的？
<ul>
<li>如果一个数据多次更新，可能会存在其的多个副本</li>
<li>我们读的顺序是由新到旧的读，因此读到的总是最新的</li>
<li>小树合并成大树的时候可以把多个副本处理掉</li>
</ul></li>
</ul>
<h4 id="bloom-filter">bloom filter</h4>
<ul>
<li>对于不存在的数据，如何避免遍历所有集合？
<ul>
<li>如果使用 LSM 树的话，需要遍历所有树</li>
</ul></li>
<li>引入布隆过滤器，当它显示某 SSTable 中没有目标数据时，就跳过</li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721195735905.png" style="zoom: 80%;"></p>
<ul>
<li>使用多个哈希函数，都存在才表明这个元素存在</li>
<li>bloom filter
<ul>
<li>如果判定一个元素<strong>没有出现过</strong>，那么这个元素<strong>一定没有出现过</strong></li>
<li>如果判定一个元素<strong>出现过</strong>，那么这个元素<strong>可能出现过也可能没出现过</strong></li>
</ul></li>
</ul>
<h2 id="raid">RAID</h2>
<ul>
<li>Redundant Arrays of Inexpensive Disks</li>
<li>是一种利用大量廉价磁盘进行磁盘组织的技术</li>
<li>好处
<ul>
<li><strong>价格</strong>：大量廉价的磁盘比少量昂贵的大磁盘合算得多</li>
<li><strong>性能</strong>：大量磁盘可以提高数据的并行存取</li>
<li><strong>可靠性</strong>：冗余数据可以存放在多个磁盘上，因此一个磁盘的故障不会导致数据丢失</li>
</ul></li>
<li>过去 RAID 是大而昂贵的磁盘的替代方法，今天使用 RAID
是因为它的高可靠性和高数据传输率
<ul>
<li>Redundant Arrays of Independent Disks</li>
</ul></li>
</ul>
<h3 id="不同方式">不同方式</h3>
<h4 id="通过冗余提高可靠性">通过冗余提高可靠性</h4>
<ul>
<li>N
个磁盘组成的集合中某个磁盘发生故障的概率比特定的单个磁盘发生故障的概率高很多</li>
<li>假定单个磁盘的 MTTF 是100,000小时（约为11年），则由 100
个磁盘组成的阵列的MTTF是1000小时（约为41天）</li>
<li><strong>冗余</strong>（Redundancy）：存储额外的信息，以便当磁盘故障时能从中重建</li>
</ul>
<h4 id="镜像冗余">镜像冗余</h4>
<ul>
<li>一个逻辑磁盘由两个物理磁盘组成</li>
<li>写操作在每个磁盘上执行</li>
<li>如果其中一个发生故障，数据可以从另一个磁盘读出</li>
<li>只有第一个磁盘的故障尚未恢复，第二个磁盘也发生故障，这时才会发生数据丢失</li>
<li>假定一个磁盘的MTTF是 <span class="math inline">\(10^5\)</span>
小时，修复时间是 <span class="math inline">\(10\)</span>
小时，则镜像磁盘的MTTF是<span class="math inline">\((10^5)^2/(2*10)=500*10^6\)</span> 小时，约为 <span class="math inline">\(57000\)</span> 年</li>
</ul>
<h4 id="校验码冗余">校验码冗余</h4>
<ul>
<li>内存中每个字节都有一个<strong>奇偶校验位</strong>与之相连，它记录该字节中为
1 的比特位的总数是偶数(=0)还是奇数(=1)，如果字节中有一位被破坏，则字节的
ECC 与存储的 ECC 就不会相匹配</li>
<li>通过 ECC 可以<strong>检测</strong>到所有的 <strong>1位</strong>
错误</li>
</ul>
<h4 id="通过拆分提高并行">通过拆分提高并行</h4>
<ul>
<li>将数据拆分到多个磁盘上以提高传输率</li>
<li><strong>通过并行提高性能的两种途径</strong>
<ul>
<li>负载平衡多个小的存取操作（即页面存取），提高以提高这种存取操作的吞吐量</li>
<li>并行执行大的存取操作，以减少大的存取操作的响应时间</li>
</ul></li>
</ul>
<h4 id="两种不同的拆分方式">两种不同的拆分方式</h4>
<ul>
<li><strong>比特级拆分</strong>（Bit-level striping）
<ul>
<li>将每个字节按比特分开，存储到多个磁盘上</li>
<li>一个由 8 个磁盘组成的阵列，将每个字节的第 i 个比特位写到第 i
个磁盘上
<ul>
<li>其存取速度是单个磁盘的 8 倍</li>
</ul></li>
<li>对于由 4 个磁盘组成的阵列，将每个字节的第 i 个比特位和第 i+4
个比特位写到第i个磁盘上</li>
</ul></li>
<li><strong>块级拆分</strong>（Block-level striping）
<ul>
<li>对于由 n 个磁盘构成的阵列，文件的第i块存放在第 (i mod n)+1
个磁盘上</li>
</ul></li>
<li>比特级拆分 vs 块级拆分
<ul>
<li>位级拆分：响应时间（多个盘同时响应）</li>
<li>块级拆分：吞吐量（不同的读取操作读不同的块，这些块在不同磁盘上）</li>
</ul></li>
</ul>
<h3 id="raid-级别">RAID 级别</h3>
<h4 id="raid-0">RAID 0</h4>
<ul>
<li><strong>块级拆分</strong>且<strong>没有任何冗余</strong>的磁盘阵列</li>
<li>用于高性能访问且数据丢失不十分重要的应用场合</li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721201830020.png" style="zoom:80%;"></p>
<h4 id="raid-1">RAID 1</h4>
<ul>
<li>带<strong>块级拆分</strong>的<strong>磁盘镜像</strong></li>
<li><strong>提供最佳写性能</strong></li>
<li>一般用于类似于数据库系统中日志文件存储的应用场合</li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721201843784.png" style="zoom: 80%;"></p>
<h4 id="raid-10">RAID 10</h4>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721201710511.png" style="zoom: 80%;"></p>
<h4 id="raid-01">RAID 01</h4>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721201730225.png" style="zoom:80%;"></p>
<p>RAID 2</p>
<ul>
<li>汉明码</li>
<li>允许多个磁盘出错</li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10/RAID2.png" style="zoom:80%;"></p>
<h4 id="raid-3">RAID 3</h4>
<ul>
<li><strong>位</strong>交叉<strong>奇偶校验</strong></li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721201923429.png" style="zoom: 80%;"></p>
<ul>
<li>RAID 3 写操作更新校验盘的两种方式（例如写D2，生成 D2'）
<ul>
<li>根据 D1, D3, D2' 生成 D4：<strong>读D1,D3，写D2, D4</strong></li>
<li>根据 D2, D2' 生成 D4：<strong>读D2,D4，写D2,D4</strong>
<ul>
<li>多个数据盘优势大，跟数据盘个数无关</li>
</ul></li>
</ul></li>
<li>数据盘多的话，产生故障的几率大了，恢复过程变得耗时</li>
</ul>
<h4 id="raid-4">RAID 4</h4>
<ul>
<li><strong>块级拆分</strong>，在一个<strong>独立的磁盘</strong>上为其他
N 个磁盘上对应的块保留一个<strong>奇偶校验块</strong></li>
<li>读取一个块只访问一个磁盘，每个存取操作的传输率低但可以并行地执行多个读操作，从而产生较高的总
I/O 率</li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721202506338.png" style="zoom: 80%;"></p>
<ul>
<li>问题：负载不均衡
<ul>
<li>读数据盘的时候 D4（校验盘） 不工作</li>
<li>写数据盘的时候都得写 D4</li>
</ul></li>
</ul>
<h4 id="raid-5">RAID 5</h4>
<ul>
<li>基于 RAID 4，将数据和奇偶校验位分布到所有的 N 个磁盘上</li>
<li>奇偶校验块不能和这个块对应的数据存储在同一个磁盘上</li>
<li>RAID 5 所有磁盘都参与对读请求的服务，而 RAID 4
中奇偶校验磁盘不参与读操作</li>
<li>RAID5 包容 RAID
4，<strong>在相同成本下提供更好的读写性能</strong></li>
</ul>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721202831447.png" style="zoom:80%;"></p>
<h4 id="raid-50">RAID 50</h4>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721202856237.png"></p>
<h4 id="raid-6">RAID 6</h4>
<ul>
<li>P+Q：Reed-Solomon 码</li>
<li>允许多个盘出错，也能恢复</li>
</ul>
<h4 id="总结">总结</h4>
<p><img src="/2021/07/21/DB/CLJ/10/image-20210721203500063.png" style="zoom:80%;"></p>
<h4 id="比较">比较</h4>
<ul>
<li>RAID 1 vs RAID 5</li>
<li>为写 1 块数据，RAID5 需要 2 块读和 2 块写</li>
<li>如果应用需要每秒 r 次读，w 次写
<ul>
<li>RAID 1 要求每秒 r+2w 次 I/O 操作</li>
<li>RAID 5 要求每秒 r+4w 次 I/O 操作
<ul>
<li>写（4
I/O）：阅读待更新块、阅读奇偶校验块、更新块中的数据块、更新奇偶校验块</li>
</ul></li>
</ul></li>
<li>当<strong>写操作较少且数据非常大</strong>时，RAID 5 较优，否则 RAID
1 更佳</li>
</ul>
<h4 id="其他">其他</h4>
<ul>
<li>RAID 的 Write Back</li>
<li>插入 20 万条数据，每条数据放在单独一个事务中执行</li>
</ul>
<table>
<colgroup>
<col style="width: 89%">
<col style="width: 10%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">RAID卡设置</th>
<th style="text-align: center;">耗时</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Write Back</td>
<td style="text-align: center;">43 秒</td>
</tr>
<tr class="even">
<td style="text-align: center;">Write Through</td>
<td style="text-align: center;">31 分钟</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Write Through with
innodb_flush_log_at_trx_commit = 0（日志强制写回磁盘、内容不强制）</td>
<td style="text-align: center;">68 秒</td>
</tr>
</tbody>
</table>
<h2 id="section"></h2>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.10.数据库存储(3)</title>
    <url>/2021/07/22/DB/CLJ/10-2/</url>
    <content><![CDATA[<h1 id="数据库存储">数据库存储</h1>
<h2 id="索引">索引</h2>
<ul>
<li>索引类型
<ul>
<li><strong>顺序索引</strong>：基于值的顺序排序</li>
<li><strong>散列索引</strong>：基于将值平均分布到若干散列桶中</li>
</ul></li>
<li>索引评价指标
<ul>
<li>访问类型</li>
<li>访问时间</li>
<li>插入时间</li>
<li>删除时间</li>
<li>空间开销</li>
</ul></li>
<li>MySQL 索引</li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722115646764.png" style="zoom: 80%;"></p>
<h3 id="b树索引">B+树索引</h3>
<ul>
<li>树结点
<ul>
<li>Ki 是搜索码，Pi 是指针</li>
</ul></li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722115803243.png" style="zoom: 67%;"></p>
<ul>
<li>每个非叶结点有 <span class="math inline">\(\lceil\dfrac{n}{2}\rceil\)</span> 到 <span class="math inline">\(n\)</span> 个子女</li>
<li>n=3</li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722115943985.png" style="zoom:67%;"></p>
<h4 id="插入操作">插入操作</h4>
<ul>
<li>插入可能导致结点分裂</li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722120038047.png" style="zoom: 80%;"></p>
<h4 id="删除操作">删除操作</h4>
<ul>
<li>删除可能导致结点合并</li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722120155032.png" style="zoom: 67%;"></p>
<h4 id="b树-vs-二叉树">B+树 vs 二叉树</h4>
<ul>
<li>B+ 树胖而矮
<ul>
<li>假定树结点大小与磁盘块大小相等，为4k，n=100，有1百万个搜索码，<span class="math inline">\(\log_{50}(10^6)=4\)</span>，访问 4 个磁盘结点</li>
</ul></li>
<li>二叉树瘦而高
<ul>
<li><span class="math inline">\(\log_{2}(10^6)=20\)</span></li>
</ul></li>
<li>二叉树：内存数据库</li>
<li>B+树：外存索引</li>
</ul>
<h4 id="b树-vs-b树">B树 vs B+树</h4>
<h5 id="b-树">B 树</h5>
<ul>
<li>所有的 key 值分布在<strong>整个树</strong>中</li>
<li>所有的 key 值出现在<strong>一个结点</strong>中</li>
<li><strong>搜索可以在非叶结点处结束</strong></li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722121330812.png" style="zoom: 67%;"></p>
<h5 id="b-树-1">B+ 树</h5>
<ul>
<li>叶结点通过两个指针相互链接，<strong>顺序查询性能更高</strong></li>
<li>叶结点来存储数据，而其他结点用于索引</li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722121431617.png" style="zoom:67%;"></p>
<h5 id="对比">对比</h5>
<ul>
<li>B
树不管叶结点还是非叶结点都会保存数据，<strong>导致在非叶结点中能保存的指针数量变少(fan
out)</strong>，要保存大量数据，只能增加树的高度，使得 IO
操作变多，查询性能变低</li>
<li>B 树查询代价不固定，适合点查询</li>
<li>B+
树数据在叶结点上，叶子结点之间通过双向链表连接，有利于数据遍历</li>
</ul>
<h5 id="性能">性能</h5>
<ul>
<li>InnoDB 一棵 B+ 树可以存放多少行？</li>
<li>假定一个页 16K，一行 1k，一页存放 16 行</li>
<li>假定主码为 bigint，长度 8 字节，指针 6 字节，共 14
字节，一个页中能存放 16384/14=1170</li>
<li>一棵高度为 2 的 B+ 树，能存放 1170 x 16 = 18720
条这样的数据记录</li>
<li>一个高度为 3 的 B+ 树可以存放：1170 x 1170 x 16 = 21902400
条这样的记录</li>
</ul>
<h4 id="sql-server-数据查找">SQL Server 数据查找</h4>
<h5 id="堆上的表">堆上的表</h5>
<ul>
<li>无索引</li>
<li>通过 IAM</li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722122147024.png" style="zoom:80%;"></p>
<h5 id="聚簇索引">聚簇索引</h5>
<ul>
<li>物理相邻</li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722122235492.png" style="zoom:80%;"></p>
<h5 id="堆上的非聚簇索引">堆上的非聚簇索引</h5>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722122339863.png" style="zoom:80%;"></p>
<h5 id="聚簇索引表上的非聚簇索引">聚簇索引表上的非聚簇索引</h5>
<ul>
<li>需要从聚簇索引去找</li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722122417849.png" style="zoom:80%;"></p>
<h3 id="哈希索引">哈希索引</h3>
<ul>
<li>散列索引</li>
<li>桶（bucket）
<ul>
<li>存储一条或多条记录的存储单元</li>
</ul></li>
<li>散列（hash）
<ul>
<li>散列函数 h(K)=B</li>
<li>K 是搜索码，B 是桶地址</li>
</ul></li>
<li>桶溢出（bucket overflow）
<ul>
<li>桶不足（insufficient bucket）</li>
<li>偏斜（skew）</li>
</ul></li>
<li>散列函数
<ul>
<li>分布是均匀的，桶包含记录的个数是均匀的</li>
<li>分布是随机的，散列值不能与搜索码值呈现出相关性</li>
</ul></li>
<li>示意图</li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722122718846.png" style="zoom:67%;"></p>
<ul>
<li>开链（溢出链）</li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722122806181.png" style="zoom:67%;"></p>
<h4 id="mysql-中的散列索引">MySQL 中的散列索引</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> testtable(</span><br><span class="line">    fname <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    lname <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    key <span class="keyword">using</span> hash(fname)</span><br><span class="line">) ENGINE<span class="operator">=</span>MEMORY;</span><br></pre></td></tr></table></figure>
<ul>
<li>AHI：innodb_adaptive_hash_index</li>
<li>B+ 树索引的索引
<ul>
<li>当对某个页面访问次数满足一定条件时会将页面地址存于 Hash
表，下次查询时不需要 B+
树那样从根结点到叶子结点逐级查找，只需一次哈希算法即可立刻定位到相应的位置</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    email <span class="type">char</span>(<span class="number">100</span>),</span><br><span class="line">    email_hash <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> user_hash_insert</span><br><span class="line">before <span class="keyword">insert</span> <span class="keyword">on</span> <span class="string">&#x27;user&#x27;</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">set</span> new.email_hash<span class="operator">=</span>crc32(new.email)</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> email, email_hash <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">where</span> email_hash<span class="operator">=</span>CRC32(&quot;F2dgTSWRBXSZ1d3O@gmail.com&quot;)</span><br><span class="line">    <span class="keyword">and</span> email<span class="operator">=</span>&quot;F2dgTSWRBXSZ1d3O@gmail.com&quot;</span><br></pre></td></tr></table></figure>
<h3 id="位图索引">位图索引</h3>
<ul>
<li>针对一些特殊的列建立索引</li>
<li>列中的<strong>每一个值</strong>对应一个向量中的<strong>一位</strong></li>
<li>向量的长度对应与记录的条数</li>
<li><strong>不适合列中值的个数太多的情况</strong></li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722123316608.png" style="zoom: 67%;"></p>
<h4 id="基于位图索引回答查询">基于位图索引回答查询</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cust</span><br><span class="line"><span class="keyword">from</span> BaseTable</span><br><span class="line"><span class="keyword">Where</span> Region<span class="operator">=</span><span class="string">&#x27;Asia&#x27;</span> <span class="keyword">and</span> Type<span class="operator">=</span><span class="string">&#x27;Dealer&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>基于位图索引的话就是向量的<strong>与或非操作</strong>
<ul>
<li>BitMap for Region(Asia)：10100</li>
<li>BitMap for Type(Dealer)：01101</li>
<li>查询结果：向量与操作：00100</li>
</ul></li>
</ul>
<h4 id="位图索引与-b-树的比较">位图索引与 B 树的比较</h4>
<ul>
<li>位图索引适用于唯一值比较少的时候</li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722123632190.png"></p>
<h4 id="位图索引对分析查询的优势">位图索引对分析查询的优势</h4>
<ul>
<li>问题：在美国加州有多少男性未申请保险？</li>
<li>设表中有 10M 个记录，每个记录长 800 字节，每一页 16K 字节</li>
<li>传统全表扫描
<ul>
<li>则扫描此表共需 50 万次 I/O 操作</li>
</ul></li>
<li>位图位片索引是将属性列的域值按照某种方式进行垂直分割，然后以二进制位图的形式存储
<ul>
<li>对于 10M 个记录建立三列的位图索引共占（10Mbit*3列/8)
字节的空间，每页 16K，则这些索引仅占 235 页，因此存取这些索引只要 235 次
I/O 操作</li>
</ul></li>
</ul>
<h4 id="位片索引">位片索引</h4>
<ul>
<li>Bit-sliced Index</li>
<li>位片索引是将<strong>属性列的域值</strong>按照某种方式进行<strong>垂直分割</strong>，然后<strong>以二进制位图的形式存储</strong></li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722130746330.png" style="zoom:67%;"></p>
<h3 id="多维索引">多维索引</h3>
<h4 id="多属性查询">多属性查询</h4>
<ul>
<li>where 10&lt;A&lt;20 and 10&lt;B&lt;20</li>
<li>组合索引 idx1 on R(A, B) 或 idx2 on R(B, A)</li>
<li>单列索引 idx1 on R(A)，idx2 on R(B)
<ul>
<li>AB 存在相关性的时候，使用单列估计存在偏差</li>
<li>问题：对于查询结果的 Cardinality 估计偏差</li>
</ul></li>
</ul>
<h4 id="k-d-树">k-d 树</h4>
<ul>
<li>树顶层结点按一维划分，下一层按另一维划分，保持每侧各落入一半数据，直至结点数小于指定值</li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722131359686.png" style="zoom:50%;"></p>
<h4 id="四叉树">四叉树</h4>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722131422357.png" style="zoom:50%;"></p>
<h4 id="r-树">R 树</h4>
<ul>
<li>二维 B 树</li>
<li><strong>区域间有重叠</strong>
<ul>
<li>划分的时候尽可能减小重叠</li>
</ul></li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722131557310.png" style="zoom:80%;"></p>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722131605858.png" style="zoom:80%;"></p>
<h2 id="大数据存储">大数据存储</h2>
<h3 id="表分区">表分区</h3>
<h4 id="数据分区">数据分区</h4>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722131820957.png" style="zoom:67%;"></p>
<ul>
<li>使用分区的优点
<ul>
<li><strong>增强可用性</strong>：如果表的某个分区出现故障，表在其他分区的数据仍然可用</li>
<li><strong>维护方便</strong>：如果表的某个分区出现故障，需要修复数据，只修复该分区即可</li>
<li><strong>均衡I/O</strong>：可以把不同的分区映射到磁盘以平衡I/O，改善整个系统性能</li>
<li><strong>改善查询性能</strong>：对分区对象的查询可以仅搜索自己关心的分区，提高检索速度</li>
</ul></li>
</ul>
<h4 id="oracle">Oracle</h4>
<ul>
<li>Oracle 提供三种分区方法</li>
<li><strong>范围分区</strong>
<ul>
<li>根据某个属性值的范围，决定将该数据存储在哪个分区上</li>
</ul></li>
<li><strong>散列分区</strong>
<ul>
<li>通过分区编号将数据均匀散列到 I/O 设备上，使得这些分区大小一致</li>
</ul></li>
<li><strong>复合分区</strong>
<ul>
<li>先使用范围分区，然后在每个分区内再使用散列分区</li>
</ul></li>
</ul>
<h4 id="sql-server">SQL Server</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建分区函数</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">partition</span> <span class="keyword">function</span> customer_partfunc(<span class="type">int</span>)</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">range</span> <span class="keyword">right</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">values</span>(<span class="number">250000</span>,<span class="number">500000</span>,<span class="number">750000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建分区架构</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">partition</span> scheme customer_partscheme</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">partition</span> customer_partfunc</span><br><span class="line"><span class="keyword">to</span>(fg1,fg2,fg3,fg4)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对表进行分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> customers(</span><br><span class="line">    FirstName nvarchar(<span class="number">40</span>),</span><br><span class="line">    LastName nvarchar(<span class="number">40</span>),</span><br><span class="line">    CustomerNumber <span class="type">int</span>)</span><br><span class="line"><span class="keyword">on</span> customer_partscheme(CustomerNumber)</span><br></pre></td></tr></table></figure>
<h3 id="物化视图">物化视图</h3>
<ul>
<li><strong>视图的计算结果被实际存储起来</strong></li>
<li>物化视图可以看成是数据库的 <strong>cache</strong></li>
<li>查询物化视图比重新计算视图要快许多</li>
<li>需要进行物化视图与基本表之间的一致性维护</li>
<li>应用场合
<ul>
<li>任何需要快速访问派生数据、或视图的重新计算非常昂贵、或查询需要耗费非常高的
CPU 和磁盘吞吐量的应用场合，都可以使用物化视图来提高效率</li>
</ul></li>
<li>引入物化视图后的体系结构</li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722132737633.png"></p>
<h4 id="sql-server-1">SQL Server</h4>
<ul>
<li>索引视图</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 定义视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> iv_avg_grade(s#,avg_grade,cnts)</span><br><span class="line"><span class="keyword">with</span> schemabinding</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> s#,<span class="built_in">avg</span>(grade),number<span class="operator">=</span>count_big(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> dbo.SC</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s#</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 针对视图创建聚簇索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> clustered index idx_avg_grade</span><br><span class="line"><span class="keyword">on</span> iv_avg_grade(s#)</span><br></pre></td></tr></table></figure>
<h4 id="oracle-1">Oracle</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> materialized <span class="keyword">view</span> my_grade_aggs</span><br><span class="line">bulid immediate</span><br><span class="line">refresh <span class="keyword">on</span> <span class="keyword">commit</span></span><br><span class="line">enable query rewrite</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> s#, <span class="built_in">avg</span>(grade)</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s#</span><br></pre></td></tr></table></figure>
<h3 id="按列存储">按列存储</h3>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722133150398.png" style="zoom:80%;"></p>
<ul>
<li>按行：访问单条纪录块</li>
<li>按列：大规模处理数据快</li>
<li>按列存储适合数据仓库、大规模数据分析的场合</li>
</ul>
<h4 id="按列存储的优点">按列存储的优点</h4>
<ul>
<li><strong>提高带宽利用率</strong>
<ul>
<li>按列存储时，只有那些被查询访问的属性才会从磁盘读出；按行存储时，周围属性也被一并读出</li>
</ul></li>
<li><strong>提高数据压缩率</strong>
<ul>
<li>将同一个属性域的数据存储在一起，提高了局部性以及压缩比率</li>
<li>传输压缩数据同样减少了带宽</li>
</ul></li>
<li><strong>提高了 cache 局部性</strong>
<ul>
<li>cacheline 比一个元组属性要大，因此按行存储时 cacheline
可能会包含不相关的周边属性，浪费 cache 的空间，减少命中率</li>
</ul></li>
</ul>
<h4 id="按列存储的缺点">按列存储的缺点</h4>
<ul>
<li><strong>增加了磁盘寻道时间</strong>
<ul>
<li>如果需要并行读取多个列，在各个块读之间需要进行磁盘寻道</li>
</ul></li>
<li><strong>增加插入操作的代价</strong>
<ul>
<li>对于插入操作，按列存储的性能很差，因为对每条插入的元组都需要在磁盘的多个不同位置更新</li>
</ul></li>
<li><strong>增加重构元组的代价</strong>
<ul>
<li>按列存储如果想支持标准的关系数据库接口，就必须将多个列拼合起来，构成一条元组输出</li>
</ul></li>
</ul>
<h4 id="按列存储适合的场合">按列存储适合的场合</h4>
<ul>
<li>数据仓库
<ul>
<li>批量写、高带宽要求、查询计划经常是表扫描</li>
</ul></li>
<li>Semantic Web
<ul>
<li>RDF</li>
</ul></li>
<li>宽表
<ul>
<li>电子商务目录：包含2百万个零件，分成500个目录，每个目录包含4000个属性</li>
<li>稀疏列</li>
</ul></li>
</ul>
<h4 id="rdf">RDF</h4>
<ul>
<li>资源描述框架</li>
<li>三元组：&lt;标识名，属性名，属性值&gt;</li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722133911722.png"></p>
<ul>
<li>稀疏的时候，按列存储，效率高</li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722133949553.png"></p>
<h4 id="稀疏属性的存储">稀疏属性的存储</h4>
<h5 id="位置列表">位置列表</h5>
<ul>
<li>特别稀疏的时候直接存位置即可</li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722134037499.png"></p>
<h5 id="位串">位串</h5>
<ul>
<li>类似位图</li>
</ul>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722134122970.png"></p>
<h5 id="位置范围">位置范围</h5>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722134209891.png"></p>
<h5 id="比较">比较</h5>
<ul>
<li>对于位置列表方式，代价是每个非空值的 32
位额外开销。如果一个列的稀疏度是98%，每个空值的开销是0.65位</li>
<li>对于位串方式，位置表示的开销是列中的每个值（不管是否为空）都占用一个位。因此如果一个列的稀疏度是50%，每个空值的开销是
2 个位</li>
<li>对于位置范围方式，每个<strong>非连续非空值的位置</strong>表示开销是
64 位</li>
</ul>
<h3 id="blob-存储">BLOB 存储</h3>
<ul>
<li>直接存储在数据库内
<ul>
<li>varchar(max), varbinary(max)</li>
</ul></li>
<li>存储在文件系统中
<ul>
<li>数据库存储文件路径信息</li>
</ul></li>
<li>FileStream
<ul>
<li>逻辑上 BLOB 对象与结构化数据是一体的，物理上是分离的</li>
</ul></li>
</ul>
<h3 id="数据压缩">数据压缩</h3>
<p><img src="/2021/07/22/DB/CLJ/10-2/image-20210722134419297.png" style="zoom:80%;"></p>
<ul>
<li>MySQL 的 compressed 行结构，采用 zlib 压缩算法</li>
</ul>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论.陈立军.11.各种连接操作</title>
    <url>/2021/07/22/DB/CLJ/11/</url>
    <content><![CDATA[<h1 id="连接运算">连接运算</h1>
<h2 id="嵌套循环连接">嵌套循环连接</h2>
<p><img src="/2021/07/22/DB/CLJ/11/image-20210722134817685.png" style="zoom: 50%;"></p>
<ul>
<li>外关系、内关系</li>
<li>嵌套循环连接无需索引，可用于任何连接条件</li>
<li>两个规模不一的关系，谁作为外关系？
<ul>
<li><strong>在外层循环中使用较小的关系代价略小</strong></li>
</ul></li>
<li>如果其中一个关系的连接属性上存在索引，并且执行的是等值连接，则可以利用索引查找代替文件扫描</li>
<li>存在索引的关系是作为外关系还是内关系？</li>
</ul>
<h3 id="嵌套循环连接-1">嵌套循环连接</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">for each tuple tr in r do</span><br><span class="line">    begin</span><br><span class="line">        for each tuple ts in s do</span><br><span class="line">            begin</span><br><span class="line">                test pair(tr,ts) to see if they satisfy the join condition theta</span><br><span class="line">                if they do, add trxts to the result</span><br><span class="line">            end</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
<ul>
<li>优点
<ul>
<li>对参加运算的关系没有要求，甚至于一个关系的各个元组可以物理上不是相邻存储的</li>
<li>适合于任何连接条件</li>
</ul></li>
</ul>
<h3 id="代价分析">代价分析</h3>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1006067">来源</a></li>
<li>假设我们有 s 和 t 两张表，现在要做 JOIN
<ul>
<li>s 表的记录数设为 5000，占据的块数设为 100</li>
<li>t 表的记录数设为 10000，占据的块数设为 400</li>
</ul></li>
</ul>
<h4 id="嵌套循环连接-2">嵌套循环连接</h4>
<ul>
<li>以一张表的每一行记录，与另一张表的每一行记录比较</li>
<li>两层 for 循环</li>
<li>若从 s 表的每行记录出发，最坏情况下
<ul>
<li>块传输次数是 5000×400+100=2000100，搜索次数是 5000+100=5100</li>
</ul></li>
<li>若从 t 表的每行记录出发，最坏情况下
<ul>
<li>块传输次数是 10000×100+400=1000400，搜索次数是 10000+400=10400</li>
</ul></li>
</ul>
<h4 id="块嵌套循环连接">块嵌套循环连接</h4>
<ul>
<li>一个小小的优化思路：每次以块的方式处理关系</li>
<li>若从 s 表的每块出发，最坏情况下
<ul>
<li>块传输次数是 100×400+100=40100，搜索次数是 2×100=200</li>
</ul></li>
<li>若从 t 表的每块出发，最坏情况下
<ul>
<li>块传输次数是 400×100+400=40400，搜索次数是 2×400=800</li>
</ul></li>
</ul>
<h4 id="索引嵌套循环连接">索引嵌套循环连接</h4>
<ul>
<li>如果连接的字段上有 B+ 树索引，设每个节点有 20 个索引项，t 表记录数为
10000，那么树的高度就是4，回表假设再加一次磁盘IO，此时访问次数为100+5000×5=25100，每次访问都有一次搜索和一次块传输</li>
<li>咦，怎么用了索引反而代价更高了？大家注意下，这里只说了 t
表上有索引，如果 s
表上也有索引且有个选择操作的话，行数会大大减少。使用索引会比块嵌套要快得多得多</li>
</ul>
<h2 id="归并连接">归并连接</h2>
<ul>
<li>在当前 R 和 S 的前端查找连接属性的最小值</li>
<li>如果这个值在另一个关系的前部没有出现，那么就删除具有这个值的元组</li>
<li>否则，找出两个关系中的这个值的所有元组，进行连接，输出和这个值相关的所有得到的结果元组</li>
<li>如果一个关系在内存中已经没有要考虑的元组了，那么就重新装载为这个关系而设定的缓冲区</li>
</ul>
<h2 id="散列连接">散列连接</h2>
<ul>
<li>适用于<strong>自然连接</strong>和<strong>等值连接</strong></li>
<li>基本思想
<ul>
<li>将两个关系按连接属性值划分成有<strong>相同散列函数值</strong>的元组集合</li>
<li>关系 r 在一个散列划分中的元组只需要与关系 s
在对应的划分中的元组相比较</li>
<li>在 r 和 s 的每一对划分中进行索引嵌套循环连接（散列索引）</li>
</ul></li>
</ul>
<h2 id="各种连接策略比较">各种连接策略比较</h2>
<ul>
<li>如果一个连接输入很小（比如不到10行），而另一个连接输入很大而且已在其连接列上创建索引，则索引嵌套循环是最快的连接操作</li>
<li>如果两个连接输入很大，并已在二者连接列上排序（连接列上有索引），则合并连接是最快的连接操作</li>
<li>哈希连接可以处理很大的、未排序的非索引输入</li>
<li>如果两个连接输入都很大，而且这两个输入的大小差不多，则预先排序的合并连接提供的性能与哈希连接相似。然而，如果两个输入的大小相差很大，则哈希连接操作通常快得多</li>
<li><strong>合并连接和哈希连接只能用于等值连接</strong>，对于非等值连接，只能用嵌套循环连接</li>
</ul>
]]></content>
      <categories>
        <category>DB.CLJ</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 练习(SPJ 数据库)</title>
    <url>/2021/05/04/DB/MySQL/SQL-SPJ/</url>
    <content><![CDATA[<h1 id="sql-查询练习">SQL 查询练习</h1>
<h2 id="spj">SPJ</h2>
<blockquote>
<p>供应商数据库SPJ中有三张表： S(SNO, SNAME, STATUS, CITY) P(PNO, PNAME,
COLOR, WEIGHT, CITY) J(JNO, JNAME,CITY) SPJ(SNO, PNO, JNO, QTY,
PRICE)</p>
<p>S表示供应商，各属性依次为供应商号，供应商名，供应商状态值，供应商所在城市；
P表示零件，各属性依次为零件号，零件名，零件颜色，零件重量，零件存放的城市；
J表示工程，各属性依次为工程号，工程名，工程所在城市；
SPJ表示供货关系，各属性依次为供应商号，零件号，工程号，供货数量，单价。</p>
</blockquote>
<ul>
<li>求没有供应零件号为P1和P2两种零件的供应商姓名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> SNAME</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> SNO <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> SNO</span><br><span class="line">    <span class="keyword">from</span> SPJ</span><br><span class="line">    <span class="keyword">where</span> PNO <span class="operator">=</span> <span class="string">&#x27;P1&#x27;</span> <span class="keyword">or</span> PNO <span class="operator">=</span> <span class="string">&#x27;P2&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2 */</span></span><br><span class="line"><span class="keyword">select</span> SNAME</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> SNO <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> SNO</span><br><span class="line">    <span class="keyword">from</span> SPJ</span><br><span class="line">    <span class="keyword">where</span> PNO <span class="operator">=</span> <span class="string">&#x27;P1&#x27;</span> <span class="keyword">or</span> PNO <span class="operator">=</span> <span class="string">&#x27;P2&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>列出所有供应商的信息，包括供应商姓名、所供应的零件名（没有供应零件的供应商也要列出，最后结果中不要出现重复元组）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> S.SNAME, P.PNAME</span><br><span class="line"><span class="keyword">from</span> S,SPJ,P</span><br><span class="line"><span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br></pre></td></tr></table></figure>
<ul>
<li>求只向与自己位于不同城市的工程供应零件的供应商姓名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SNAME</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> SNAME <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> SNAME</span><br><span class="line">    <span class="keyword">from</span> S,SPJ,J</span><br><span class="line">    <span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.JNO <span class="operator">=</span> J.JNO <span class="keyword">and</span> S.CITY <span class="operator">=</span> J.CITY</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>求只向与自己位于不同城市的工程供应零件的供应商姓名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SNAME</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> SNAME <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> SNAME</span><br><span class="line">    <span class="keyword">from</span> S,SPJ,J</span><br><span class="line">    <span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.JNO <span class="operator">=</span> J.JNO <span class="keyword">and</span> S.CITY <span class="operator">!=</span> J.CITY</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>求供应了所有零件的供应商姓名
<ul>
<li><strong>不存在</strong>一个零件，所求的供应商<strong>没有</strong>供应</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SNAME</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> PNO <span class="comment">/* 使用了*则不可能使用索引 */</span></span><br><span class="line">    <span class="keyword">from</span> P</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">        <span class="keyword">select</span> SNO <span class="comment">/* 使用了*则不可能使用索引 */</span></span><br><span class="line">        <span class="keyword">from</span> SPJ</span><br><span class="line">        <span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>求供应了所有红色零件的供应商姓名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SNAME</span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> PNO</span><br><span class="line">    <span class="keyword">from</span> P</span><br><span class="line">    <span class="keyword">where</span> P.COLOR <span class="operator">=</span> <span class="string">&#x27;红色&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">        <span class="keyword">select</span> SNO</span><br><span class="line">        <span class="keyword">from</span> SPJ</span><br><span class="line">        <span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>列出每个城市的工程所使用的零件总的数量
<ul>
<li>left join：可能有 0 个</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> CITY, <span class="built_in">sum</span>(QTY)</span><br><span class="line"><span class="keyword">from</span> J <span class="keyword">left</span> <span class="keyword">join</span> SPJ <span class="keyword">on</span> J.JNO <span class="operator">=</span> SPJ.JNO</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> CITY</span><br></pre></td></tr></table></figure>
<ul>
<li>按零件数量总和的降序列出每项工程所使用的每种红色零件的总的金额（工程可以向不同的供应商购买同一零件，总金额＝单价*供货数量）。输出工程号、零件号、总金额</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SPJ.JNO, SPJ.PNO, <span class="built_in">sum</span>(QTY<span class="operator">*</span>PRICE)</span><br><span class="line"><span class="keyword">from</span> J,SPJ,P</span><br><span class="line"><span class="keyword">where</span> J.JNO <span class="operator">=</span> SPJ.JNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO <span class="keyword">and</span> P.COLOR <span class="operator">=</span> <span class="string">&#x27;红色&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> SPJ.JNO, SPJ.PNO</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(QTY) <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>求供应零件数量最多的供应商姓名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SNAME</span><br><span class="line"><span class="keyword">from</span> S,SPJ,P</span><br><span class="line"><span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> SPJ.SNO</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">sum</span>(QTY) <span class="operator">&gt;=</span> <span class="keyword">all</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">sum</span>(QTY)</span><br><span class="line">    <span class="keyword">from</span> S,SPJ,P</span><br><span class="line">    <span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> SPJ.SNO</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>求每个城市中供应零件数量最多的供应商姓名。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> S1.CITY, SNAME</span><br><span class="line"><span class="keyword">from</span> S S1,SPJ,P</span><br><span class="line"><span class="keyword">where</span> S1.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> SPJ.SNO, S1.CITY</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">sum</span>(QTY) <span class="operator">&gt;=</span> <span class="keyword">all</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">sum</span>(QTY)</span><br><span class="line">    <span class="keyword">from</span> S,SPJ,P</span><br><span class="line">    <span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO <span class="keyword">and</span> S.CITY <span class="operator">=</span> S1.CITY</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> SPJ.SNO</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>列出恰好供应了相同零件的供应商对。输出的时候，供应商对小号在前，相等不输出，要去重，都没有供应零件也算供应了相同零件。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> S1.SNAME, S2.SNAME</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="comment">/* 给每一个供应商组织一个供应零件的序列 */</span></span><br><span class="line">    <span class="keyword">select</span> S.SNAME, group_concat(<span class="keyword">distinct</span> P.PNO <span class="keyword">order</span> <span class="keyword">by</span> P.PNO) GC_PNO</span><br><span class="line">    <span class="keyword">from</span> S, SPJ, P</span><br><span class="line">    <span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> S.SNO</span><br><span class="line">) S1, (</span><br><span class="line">    <span class="keyword">select</span> S.SNAME, group_concat(<span class="keyword">distinct</span> P.PNO <span class="keyword">order</span> <span class="keyword">by</span> P.PNO) GC_PNO</span><br><span class="line">    <span class="keyword">from</span> S, SPJ, P</span><br><span class="line">    <span class="keyword">where</span> S.SNO <span class="operator">=</span> SPJ.SNO <span class="keyword">and</span> SPJ.PNO <span class="operator">=</span> P.PNO</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> S.SNO</span><br><span class="line">) S2</span><br><span class="line"><span class="comment">/* 使用小于号去重 */</span></span><br><span class="line"><span class="keyword">where</span> S1.GC_PNO <span class="operator">=</span> S2.GC_PNO <span class="keyword">and</span> S1.SNAME <span class="operator">&lt;</span> S2.SNAME</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB.MySQL</category>
      </categories>
      <tags>
        <tag>DB</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 练习(订单表数据库)</title>
    <url>/2021/05/04/DB/MySQL/SQL-adventureworks/</url>
    <content><![CDATA[<h1 id="sql-查询练习">SQL 查询练习</h1>
<h2 id="订单表">订单表</h2>
<blockquote>
<p>这是一个自行车制造和销售公司的数据库，该公司建立自己的销售网站，提供在线销售。
由于adventureworks数据库所含表的类型过多，这里只介绍题目中涉及到了表及字段。</p>
<p>关于该数据库可以参考：http://www.uml.org.cn/sjjm/201905103.asp</p>
<p>product(ProductID,Name,ProductModelID,ListPrice)
person(FirstName,MiddleName,LastName)
salesorderdetail(SalesOrderID,SalesOrderDetailID,OrderQty,ProductID,UnitPrice,UnitPriceDiscount,LineTotal)</p>
<p>product:产品ID,产品名字，产品类型ID(不同的产品ID可能具有相同的产品类型ID),产品标价
person:姓名
salesorderdetail:这笔订单的ID(不是主键，可能有ID相同的记录)，订单详细ID,订单涉及的产品数量，产品ID，单元价格，单元价格折扣，销售总额</p>
<p>注意：每个产品的没有打折之前的销售总额=OrderQty x
UnitPrice,打折之后的销售总额=OrderQty x UnitPrice x
UnitPriceDiscount</p>
<p>其他参考：<a href="/resources/DB/AdventureWorks.pdf">数据库说明</a></p>
<p>salesorderheader(SalesOrderID, RevisionNumber, OrderDate, DueDate,
ShipDate, Status, OnlineOrderFlag, SalesOrderNumber,
PurchaseOrderNumber, AccountNumber, CustomerID, SalesPersonID,
TerritoryID, BillToAddressID, ShipToAddressID, ShipMethodID,
CreditCardID, CreditCardApprovalCode, CurrencyRateID, SubTotal, TaxAmt,
Freight, TotalDue, Comment, rowguid, ModifiedDate)</p>
<p>address(AddressID, AddressLine1, AddressLine2, City, StateProvinceID,
PostalCode, SpatialLocation, rowguid, ModifiedDate)</p>
<p>businessentityaddress(BusinessEntityID, AddressID, AddressTypeID,
rowguid, ModifiedDate)</p>
</blockquote>
<ul>
<li>在Product表中查出所有产品信息，按产品名升序排列</li>
<li>输出格式：Name, ProductNumber, ListPrice</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Name, ProductNumber, ListPrice</span><br><span class="line"><span class="keyword">from</span> product</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Name <span class="keyword">asc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查出每种产品类型均价等于该类产品最高标价的产品类型号</li>
<li>涉及表：Product</li>
<li>输出格式为(ProductModelID)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ProductModelID</span><br><span class="line"><span class="keyword">from</span> product</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ProductModelID</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(ListPrice) <span class="operator">=</span> <span class="built_in">max</span>(ListPrice)</span><br></pre></td></tr></table></figure>
<ul>
<li>查出每个销售订单的销售总额</li>
<li>涉及表：SalesOrderDetail</li>
<li>输出格式为(SalesOrderID,total[=sum(LineTotal)])</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SalesOrderID, <span class="built_in">sum</span>(LineTotal) total</span><br><span class="line"><span class="keyword">from</span> salesorderdetail</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> SalesOrderID</span><br></pre></td></tr></table></figure>
<ul>
<li>查出标价大于1000的产品，求出这些产品的均价(按ProductModelID分组)</li>
<li>涉及表：Product</li>
<li>输出格式为(ProductModelID,avg_price[avg(ListPrice)])</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ProductModelID, <span class="built_in">avg</span>(ListPrice)</span><br><span class="line"><span class="keyword">from</span> product</span><br><span class="line"><span class="keyword">where</span> ListPrice <span class="operator">&gt;</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ProductModelID</span><br></pre></td></tr></table></figure>
<ul>
<li>查出总销量大于5的产品ID，并按总销量排序</li>
<li>涉及表：salesorderdetail</li>
<li>输出格式为(ProductID,count[=sum(OrderQty])</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ProductID, <span class="built_in">sum</span>(OrderQty) count</span><br><span class="line"><span class="keyword">from</span> salesorderdetail</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ProductID</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">sum</span>(OrderQty) <span class="operator">&gt;</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(OrderQty) <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查出所有商品的没有打折之前的销售额NonDiscountSales，打折之后的销售额Discounts，按ProductName逆序返回</li>
<li>输出格式为(ProductName,NonDiscountSales,Discounts)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Name, OrderQty<span class="operator">*</span>UnitPrice NonDiscountSales, OrderQty<span class="operator">*</span>UnitPrice<span class="operator">*</span>UnitPriceDiscount Discounts</span><br><span class="line"><span class="keyword">from</span> salesorderdetail s <span class="keyword">inner</span> <span class="keyword">join</span> product p <span class="keyword">on</span> s.ProductID <span class="operator">=</span> p.ProductID</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> p.Name <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查询所有名字以“Chain”开头的ProductID,Name</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ProductID, Name</span><br><span class="line"><span class="keyword">from</span> product</span><br><span class="line"><span class="keyword">where</span> Name <span class="keyword">like</span> <span class="string">&#x27;Chain%&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>从Person表中选出MiddleName中包含E或B字符的the business entity ID
number, first name, middle name, 和 last name</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> BusinessEntityID, FirstName, MiddleName, LastName</span><br><span class="line"><span class="keyword">from</span> person</span><br><span class="line"><span class="keyword">where</span> MiddleName regexp <span class="string">&#x27;.*[ebEB].*&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义每个员工参与的所有订单的总销售额(sum(LineTotal))作为员工的业绩</li>
<li>列出每个城市的业绩排名前三的员工</li>
<li>涉及表(salesorderheader,salesorderdetail,address,businessentityaddress)</li>
<li>输出格式为(city,SalesPersonID)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> TMP <span class="keyword">as</span>(</span><br><span class="line">    <span class="keyword">select</span> SalesPersonID, <span class="built_in">sum</span>(LineTotal) totalMoney, ad.City</span><br><span class="line">    <span class="keyword">from</span> salesorderheader sh</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> salesorderdetail sd</span><br><span class="line">    <span class="keyword">on</span> sd.SalesOrderID <span class="operator">=</span> sh.SalesOrderID <span class="keyword">and</span> <span class="keyword">not</span> isNULL(SalesPersonID)</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> businessentityaddress bea</span><br><span class="line">    <span class="keyword">on</span> sh.SalesPersonID <span class="operator">=</span> bea.BusinessEntityID</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> address ad</span><br><span class="line">    <span class="keyword">on</span> bea.AddressID <span class="operator">=</span> ad.AddressID</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> SalesPersonID, ad.City</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> City, SalesPersonID</span><br><span class="line"><span class="keyword">from</span> TMP</span><br><span class="line"><span class="keyword">where</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> TMP t1</span><br><span class="line">    <span class="keyword">where</span> t1.City <span class="operator">=</span> TMP.City <span class="keyword">and</span> t1.totalMoney <span class="operator">&gt;</span> TMP.totalMoney</span><br><span class="line">) <span class="operator">&lt;=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">and</span> <span class="keyword">not</span> isNull(City)</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">not</span> isNull(SalesPersonID)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> City <span class="keyword">asc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>找出交易过四次以上（不包括四次）的顾客，输出这些顾客对应的订单信息</li>
<li>涉及表(SalesOrderHeader)</li>
<li>输出格式为(CustomerID,SalesOrderID,OrderDate)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> TMP <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> CustomerID <span class="keyword">from</span> salesorderheader</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> CustomerID</span><br><span class="line">    <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> s.CustomerID CustomerID, s.SalesOrderID SalesOrderID, s.OrderDate OrderDate</span><br><span class="line"><span class="keyword">from</span> TMP <span class="keyword">inner</span> <span class="keyword">join</span> salesorderheader s <span class="keyword">on</span> TMP.CustomerID <span class="operator">=</span> s.CustomerID</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB.MySQL</category>
      </categories>
      <tags>
        <tag>DB</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 练习(员工数据库)</title>
    <url>/2021/05/04/DB/MySQL/SQL-employees/</url>
    <content><![CDATA[<h1 id="sql-查询练习">SQL 查询练习</h1>
<h2 id="员工数据库">员工数据库</h2>
<p><img src="/2021/05/04/DB/MySQL/SQL-employees/employees_details.png"></p>
<ul>
<li>查询每个部门的经理信息。输出格式为（部门名，经理姓，经理名），按部门名升序输出</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> D.dept_name, E.last_name, E.first_name</span><br><span class="line"><span class="keyword">from</span> (departments D <span class="keyword">left</span> <span class="keyword">join</span> dept_manager DM <span class="keyword">on</span> D.dept_no <span class="operator">=</span> DM.dept_no)</span><br><span class="line">                    <span class="keyword">left</span> <span class="keyword">join</span> employees E <span class="keyword">on</span> DM.emp_no <span class="operator">=</span> E.emp_no</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> D.dept_name <span class="keyword">asc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>找出那些至少拥有三个title并且至少在两个部门工作过的员工，要求按升序输出前十个员工号
<ul>
<li><strong>count 的时候需要去重</strong></li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> E.emp_no</span><br><span class="line"><span class="keyword">from</span> employees E <span class="keyword">inner</span> <span class="keyword">join</span> dept_emp DE <span class="keyword">on</span> E.emp_no <span class="operator">=</span> DE.emp_no</span><br><span class="line">                 <span class="keyword">inner</span> <span class="keyword">join</span> titles T <span class="keyword">on</span> E.emp_no <span class="operator">=</span> T.emp_no</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> E.emp_no</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> T.title) <span class="operator">&gt;=</span> <span class="number">3</span> <span class="keyword">and</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> DE.dept_no) <span class="operator">&gt;=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> E.emp_no <span class="keyword">asc</span></span><br><span class="line">limit <span class="number">10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>找出比其部门经理工资高的员工，要求输出列是（员工号，经理员工号），按员工号升序，员工号相同的按经理员工号升序，列出前十个。<strong>注意</strong>：有些员工会在多个部门任职，部门经理也会轮换，所以两者在同一部门工作的日期必须有交集。而任期内工资也可能是变化的，所以还必须考虑工资日期的交集。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> DE.emp_no, DM.emp_no</span><br><span class="line"><span class="keyword">from</span> (dept_emp DE <span class="keyword">inner</span> <span class="keyword">join</span> salaries S1 <span class="keyword">on</span>(</span><br><span class="line">    <span class="comment">/* 工资在部门任期之内 */</span></span><br><span class="line">    DE.emp_no <span class="operator">=</span> S1.emp_no</span><br><span class="line">    <span class="keyword">and</span> S1.from_date <span class="operator">&gt;=</span> DE.from_date</span><br><span class="line">    <span class="keyword">and</span> S1.to_date <span class="operator">&lt;=</span> DE.to_date</span><br><span class="line">)),</span><br><span class="line">(dept_manager DM <span class="keyword">inner</span> <span class="keyword">join</span> salaries S2 <span class="keyword">on</span>(</span><br><span class="line">    DM.emp_no <span class="operator">=</span> S2.emp_no</span><br><span class="line">    <span class="keyword">and</span> S2.from_date <span class="operator">&gt;=</span> DM.from_date</span><br><span class="line">    <span class="keyword">and</span> S2.to_date <span class="operator">&lt;=</span> DM.to_date</span><br><span class="line">))</span><br><span class="line"><span class="keyword">where</span> DM.dept_no <span class="operator">=</span> DE.dept_no        <span class="comment">/* 部门经理 */</span></span><br><span class="line">    <span class="keyword">and</span> S1.salary <span class="operator">&gt;</span> S2.salary        <span class="comment">/* 工资更高 */</span></span><br><span class="line">    <span class="comment">/* 工资时间交集 */</span></span><br><span class="line">    <span class="keyword">and</span> (S1.from_date <span class="operator">&lt;=</span> S2.to_date <span class="keyword">and</span> S2.from_date <span class="operator">&lt;=</span> S1.to_date)</span><br><span class="line">    <span class="comment">/* 工作时间交集 */</span></span><br><span class="line">    <span class="keyword">and</span> (DM.from_date <span class="operator">&lt;=</span> DE.to_date <span class="keyword">and</span> DE.from_date <span class="operator">&lt;=</span> DM.to_date)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> DE.emp_no <span class="keyword">asc</span>, DM.emp_no <span class="keyword">asc</span></span><br><span class="line">limit <span class="number">10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将每个部门的员工的姓串接在一列中，要求以逗号分隔，按姓升序排序，仅包括前5个员工。输出格式为（部门号，员工姓），按部门号升序输出。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> DE.dept_no, substring_index(</span><br><span class="line">    group_concat(E.last_name <span class="keyword">order</span> <span class="keyword">by</span> E.last_name <span class="keyword">asc</span> separator <span class="string">&#x27;,&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> dept_emp DE <span class="keyword">inner</span> <span class="keyword">join</span> employees E <span class="keyword">on</span> DE.emp_no <span class="operator">=</span> E.emp_no</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> DE.dept_no</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> DE.dept_no <span class="keyword">asc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>列出每个部门中的最高和最低工资的员工及其工资。输出格式为（部门号，最高工资员工号，最高工资，最低工资员工号，最低工资）。<strong>注意</strong>：员工某一时期的工资，日期范围要和在该部门任职日期范围有交集，才能算作该部门的工资</li>
<li>先找出最高工资，再找到人</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 超时了 */</span></span><br><span class="line"><span class="keyword">with</span> TMP <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> S.salary salary, E.emp_no emp_no, DE.dept_no dept_no</span><br><span class="line"><span class="keyword">from</span> dept_emp DE <span class="keyword">inner</span> <span class="keyword">join</span> employees E <span class="keyword">on</span> DE.emp_no <span class="operator">=</span> E.emp_no</span><br><span class="line">                 <span class="keyword">inner</span> <span class="keyword">join</span> salaries S <span class="keyword">on</span> (</span><br><span class="line">                     E.emp_no <span class="operator">=</span> S.emp_no <span class="keyword">and</span></span><br><span class="line">                     <span class="comment">/* 工资在部门任期之内 */</span></span><br><span class="line">                     S.from_date <span class="operator">&gt;=</span> DE.from_date <span class="keyword">and</span> S.to_date <span class="operator">&lt;=</span> DE.to_date</span><br><span class="line">                 )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> t_max.dept_no, t3.emp_no, max_salary, t4.emp_no, min_salary</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line"><span class="comment">/* 先求出最高工资 */</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> t1.dept_no dept_no, <span class="built_in">max</span>(t1.salary) max_salary</span><br><span class="line">    <span class="keyword">from</span> TMP t1</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> t1.dept_no</span><br><span class="line">) t_max</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line"><span class="comment">/* 最低工资 */</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> t2.dept_no dept_no, <span class="built_in">min</span>(t2.salary) min_salary</span><br><span class="line">    <span class="keyword">from</span> TMP t2</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> t2.dept_no</span><br><span class="line">) t_min</span><br><span class="line"><span class="keyword">on</span> t_max.dept_no <span class="operator">=</span> t_min.dept_no</span><br><span class="line"><span class="comment">/* 再连接 */</span></span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> TMP t3</span><br><span class="line"><span class="keyword">on</span> t3.dept_no <span class="operator">=</span> t_max.dept_no <span class="keyword">and</span> t3.salary <span class="operator">=</span> t_max.max_salary</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> TMP t4</span><br><span class="line"><span class="keyword">on</span> t4.dept_no <span class="operator">=</span> t_min.dept_no <span class="keyword">and</span> t4.salary <span class="operator">=</span> t_min.min_salary</span><br></pre></td></tr></table></figure>
<ul>
<li>最大最小同时求，这样就不会超时</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> TMP <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> S.salary salary, E.emp_no emp_no, DE.dept_no dept_no</span><br><span class="line"><span class="keyword">from</span> dept_emp DE <span class="keyword">inner</span> <span class="keyword">join</span> employees E <span class="keyword">on</span> DE.emp_no <span class="operator">=</span> E.emp_no</span><br><span class="line">                 <span class="keyword">inner</span> <span class="keyword">join</span> salaries S <span class="keyword">on</span> (</span><br><span class="line">                     E.emp_no <span class="operator">=</span> S.emp_no <span class="keyword">and</span></span><br><span class="line">                     <span class="comment">/* 工资在部门任期之内 */</span></span><br><span class="line">                     S.from_date <span class="operator">&gt;=</span> DE.from_date <span class="keyword">and</span> S.to_date <span class="operator">&lt;=</span> DE.to_date</span><br><span class="line">                 )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> t_m.dept_no, t3.emp_no, max_salary, t4.emp_no, min_salary</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line"><span class="comment">/* 先求出最高最低工资 */</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> t1.dept_no dept_no, <span class="built_in">max</span>(t1.salary) max_salary, <span class="built_in">min</span>(t1.salary) min_salary</span><br><span class="line">    <span class="keyword">from</span> TMP t1</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> t1.dept_no</span><br><span class="line">) t_m</span><br><span class="line"><span class="comment">/* 再连接 */</span></span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> TMP t3</span><br><span class="line"><span class="keyword">on</span> t3.dept_no <span class="operator">=</span> t_m.dept_no <span class="keyword">and</span> t3.salary <span class="operator">=</span> t_m.max_salary</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> TMP t4</span><br><span class="line"><span class="keyword">on</span> t4.dept_no <span class="operator">=</span> t_m.dept_no <span class="keyword">and</span> t4.salary <span class="operator">=</span> t_m.min_salary</span><br></pre></td></tr></table></figure>
<ul>
<li>查询最高工资所在的部门中的最低工资是多少？输出格式为（部门号，最高工资，最低工资），按部门号升序输出。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> TMP <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> S.salary salary, E.emp_no emp_no, DE.dept_no dept_no</span><br><span class="line"><span class="keyword">from</span> dept_emp DE <span class="keyword">inner</span> <span class="keyword">join</span> employees E <span class="keyword">on</span> DE.emp_no <span class="operator">=</span> E.emp_no</span><br><span class="line">                 <span class="keyword">inner</span> <span class="keyword">join</span> salaries S <span class="keyword">on</span> (</span><br><span class="line">                     E.emp_no <span class="operator">=</span> S.emp_no <span class="keyword">and</span></span><br><span class="line">                     <span class="comment">/* 工资在部门任期之内 */</span></span><br><span class="line">                     S.from_date <span class="operator">&gt;=</span> DE.from_date <span class="keyword">and</span> S.to_date <span class="operator">&lt;=</span> DE.to_date</span><br><span class="line">                 )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> t_m.dept_no, max_salary msalary, min_salary nsalary</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> t1.dept_no dept_no, <span class="built_in">max</span>(t1.salary) max_salary, <span class="built_in">min</span>(t1.salary) min_salary</span><br><span class="line">    <span class="keyword">from</span> TMP t1</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> t1.dept_no</span><br><span class="line">) t_m</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> max_salary <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>选做。比较男女职工的平均工资差异。一个人的生涯平均工资这样计算：先将某段时间内的年薪换算成日薪（统一用一年360天），再乘以在这个年薪水平下所工作的天数，得到收入，将所有不同时段的收入加起来，再除以总天数，这样就得到总平均日薪了，求所有男女员工的平均日薪也是类似做法。输出格式为（男职工平均日薪，女职工平均日薪，平均日薪差）。<strong>注意：</strong>to_date是'9999-01-01'的统一用最大的from_date+一年
代替，即'2003-08-01'</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* TODO */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>11027号员工有过三个不同的title， 将其按如下表格形式输出</li>
</ul>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 67%">
<col style="width: 11%">
<col style="width: 11%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">emp_no</th>
<th style="text-align: center;">tenure1</th>
<th style="text-align: center;">tenure2</th>
<th style="text-align: center;">tenure3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">11027</td>
<td style="text-align: center;">1986-05-07~1991-05-07Engineer</td>
<td style="text-align: center;">...</td>
<td style="text-align: center;">...</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* MySQL 字符串拼接不能直接用 +, 需要使用 concat(,) */</span></span><br><span class="line"><span class="keyword">select</span> emp_no,</span><br><span class="line">    concat(</span><br><span class="line">        DATE_FORMAT(T1.from_date,<span class="string">&#x27;%Y-%m-%d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;~&#x27;</span>,</span><br><span class="line">        DATE_FORMAT(T1.to_date,<span class="string">&#x27;%Y-%m-%d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;\n&#x27;</span>,</span><br><span class="line">        T1.title</span><br><span class="line">    ) tenure1,</span><br><span class="line">    concat(</span><br><span class="line">        DATE_FORMAT(T2.from_date,<span class="string">&#x27;%Y-%m-%d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;~&#x27;</span>,</span><br><span class="line">        DATE_FORMAT(T2.to_date,<span class="string">&#x27;%Y-%m-%d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;\n&#x27;</span>,</span><br><span class="line">        T2.title</span><br><span class="line">    ) tenure2,</span><br><span class="line">    concat(</span><br><span class="line">        DATE_FORMAT(T3.from_date,<span class="string">&#x27;%Y-%m-%d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;~&#x27;</span>,</span><br><span class="line">        DATE_FORMAT(T3.to_date,<span class="string">&#x27;%Y-%m-%d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;\n&#x27;</span>,</span><br><span class="line">        T3.title</span><br><span class="line">    ) tenure3</span><br><span class="line"><span class="keyword">from</span> titles T1 <span class="keyword">join</span> titles T2 <span class="keyword">using</span>(emp_no) <span class="keyword">join</span> titles T3 <span class="keyword">using</span>(emp_no)</span><br><span class="line"><span class="keyword">where</span> emp_no <span class="operator">=</span> <span class="number">11027</span> <span class="keyword">and</span> T1.from_date <span class="operator">&lt;</span> T2.from_date <span class="keyword">and</span> T2.from_date <span class="operator">&lt;</span> T3.from_date</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB.MySQL</category>
      </categories>
      <tags>
        <tag>DB</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 聚合成 json 格式化输出</title>
    <url>/2021/06/23/DB/MySQL/json_format/</url>
    <content><![CDATA[<h1 id="json-格式化输出">Json 格式化输出</h1>
<h2 id="mysql-实现">MySQL 实现</h2>
<ul>
<li>将我们的数据库按照 json 的格式，格式化输出</li>
<li>管理员模式开启 MySQL 服务</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 名字和安装时相关</span></span><br><span class="line">net <span class="built_in">start</span> MYSQL80</span><br></pre></td></tr></table></figure>
<ul>
<li>进入命令行模式</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 得输入密码</span></span><br><span class="line">mysql <span class="literal">-u</span> root <span class="literal">-p</span></span><br></pre></td></tr></table></figure>
<h3 id="建表">建表</h3>
<ul>
<li>新建数据库并使用</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database json_format;</span><br><span class="line">use json_format;</span><br></pre></td></tr></table></figure>
<ul>
<li>导入数据
<ul>
<li><a href="/resources/DB/code/elective_create_insert.sql">代码</a></li>
<li>一些修改
<ul>
<li>约束条件在插入数据之后</li>
<li>一些数据补全，缺省的补为 null</li>
<li>第 3 个约束条件笔误，最后面是 tno</li>
</ul></li>
</ul></li>
<li>查看有哪些表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/23/DB/MySQL/json_format/image-20210623161121083.png"></p>
<h3 id="输出为-json">输出为 json</h3>
<ul>
<li>新建一个表，用于输出结果</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu_info (</span><br><span class="line">    info json</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>原始数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/23/DB/MySQL/json_format/image-20210623161033888.png"></p>
<ul>
<li>如下指令可以生成除了课程之外的 json 数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> CONCAT(<span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;&quot;sno&quot;: &quot;&#x27;</span>, s.sno, <span class="string">&#x27;&quot;,&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;&quot;name&quot;: &quot;&#x27;</span>, s.sname, <span class="string">&#x27;&quot;,&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;&quot;course&quot;: &#x27;</span>, <span class="string">&#x27;[]&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;&#125;&#x27;</span>) info</span><br><span class="line"><span class="keyword">from</span> student s</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/23/DB/MySQL/json_format/image-20210623155952954.png"></p>
<ul>
<li>接着只需要生成课程数据即可</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    s.sno,</span><br><span class="line">    group_concat(</span><br><span class="line">        CONCAT(<span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;&quot;cname&quot;: &quot;&#x27;</span>, c.cname, <span class="string">&#x27;&quot;,&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;&quot;grade&quot;: &#x27;</span>, sc.grade,</span><br><span class="line">               <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">    ) course_info</span><br><span class="line"><span class="keyword">from</span> student s, sc, course c</span><br><span class="line"><span class="keyword">where</span> s.sno <span class="operator">=</span> sc.sno <span class="keyword">and</span> sc.cno <span class="operator">=</span> c.cno</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sno;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果如下</li>
</ul>
<figure>
<img src="/2021/06/23/DB/MySQL/json_format/image-20210623155429773.png" alt="image-20210623160857468">
<figcaption aria-hidden="true">image-20210623160857468</figcaption>
</figure>
<ul>
<li>接着我们把上面两个结合在一起即可</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 插入数据部分</span></span><br><span class="line"><span class="comment">-- insert stu_info</span></span><br><span class="line"><span class="keyword">select</span> CONCAT(<span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;&quot;sno&quot;: &quot;&#x27;</span>, s.sno, <span class="string">&#x27;&quot;,&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;&quot;name&quot;: &quot;&#x27;</span>, s.sname, <span class="string">&#x27;&quot;,&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;&quot;course&quot;: &#x27;</span>, <span class="string">&#x27;[&#x27;</span> , M.course_info, <span class="string">&#x27;]&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;&#125;&#x27;</span>) info</span><br><span class="line"><span class="keyword">from</span> student s, (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">    s.sno,</span><br><span class="line">    group_concat(</span><br><span class="line">        CONCAT(<span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;&quot;cname&quot;: &quot;&#x27;</span>, c.cname, <span class="string">&#x27;&quot;,&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;&quot;grade&quot;: &#x27;</span>, sc.grade,</span><br><span class="line">               <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">    ) course_info</span><br><span class="line">    <span class="keyword">from</span> student s, sc, course c</span><br><span class="line">    <span class="keyword">where</span> s.sno <span class="operator">=</span> sc.sno <span class="keyword">and</span> sc.cno <span class="operator">=</span> c.cno</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> sno</span><br><span class="line">) M</span><br><span class="line"><span class="keyword">where</span> s.sno <span class="operator">=</span> M.sno;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/23/DB/MySQL/json_format/image-20210623155754129.png"></p>
<ul>
<li>我们可以把上面的数据插入到一个表里，然后输出成 json 文件即可
<ul>
<li>上面代码取消第二行的注释即可</li>
</ul></li>
<li>输出结果
<ul>
<li>如下命令得开权限，否则会报错</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> CONCAT(</span><br><span class="line">    <span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;\&quot;students\&quot;: &#x27;</span>, <span class="string">&#x27;[&#x27;</span> , group_concat(info), <span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">) stu_infos</span><br><span class="line"><span class="keyword">from</span> stu_info</span><br><span class="line"><span class="keyword">into</span> outfile <span class="string">&#x27;D:MyTemp/stu_infos.json&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>会有字符串缺失的问题
<ul>
<li>可以修改最长字符串大小</li>
</ul></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置最长字符串大小</span></span><br><span class="line"><span class="keyword">set</span> SESSION group_concat_max_len<span class="operator">=</span><span class="number">10000</span>;</span><br><span class="line"><span class="comment">-- 查看最长字符串大小</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;group_concat_max_len&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以直接在外面执行命令，直接命令行
<ul>
<li><code>-N</code> 表示取消表头</li>
<li>另外一种解决方法是输出的时候，每行一条 json 数据</li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -N -h 127.0.0.1 -u root -p  --default-character-set=UTF8 -e &quot;set SESSION group_concat_max_len=10000; select CONCAT(&#x27;&#123;&#x27;, &#x27;\&quot;students\&quot;: &#x27;, &#x27;[&#x27; , group_concat(info), &#x27;]&#x27;, &#x27;&#125;&#x27;) stu_infos from stu_info&quot; json_format &gt; D:/MyTemp/stu_infos.json</span><br></pre></td></tr></table></figure>
<ul>
<li>结果如下</li>
</ul>
<p><img src="/2021/06/23/DB/MySQL/json_format/image-20210623165125466.png"></p>
<ul>
<li>格式化结果如下</li>
</ul>
<p><img src="/2021/06/23/DB/MySQL/json_format/image-20210623165357814.png"></p>
]]></content>
      <categories>
        <category>DB.MySQL</category>
      </categories>
      <tags>
        <tag>DB</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 的一些记录</title>
    <url>/2021/10/18/Kits/win/kits/</url>
    <content><![CDATA[<h1 id="windows-kits">windows kits</h1>
<h2 id="屏幕">1. 屏幕</h2>
<h3 id="设置熄屏而不睡眠">(1) 设置熄屏而不睡眠</h3>
<ul>
<li><strong>控制面板</strong>
<ul>
<li>控制面板</li>
<li>选择关闭显示器的时间</li>
</ul></li>
<li>设置<strong>关闭显示器</strong>时间为固定时长，使<strong>计算机进入睡眠状态</strong>时间为<strong>从不</strong>即可</li>
</ul>
<p><img src="/2021/10/18/Kits/win/kits/image-20211018141351993.png" style="zoom:80%;"></p>
<ul>
<li>设置里面也行（<strong>挠头</strong>）</li>
</ul>
<p><img src="/2021/10/18/Kits/win/kits/image-20211018151504541.png" style="zoom:80%;"></p>
<h2 id="快捷键">2. 快捷键</h2>
<ul>
<li>win + "PRT SCR SYS RQ"
<ul>
<li>截图保存到<strong>屏幕截图</strong>文件夹中</li>
</ul></li>
<li>ctrl + 左键双击
<ol start="2" type="1">
<li>新窗口打开</li>
</ol></li>
</ul>
<h2 id="cmd">3. cmd</h2>
<ul>
<li>批量修改文件后缀</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ren</span> *.jpg *.gif</span><br></pre></td></tr></table></figure>
<ul>
<li>打开当前文件夹</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="built_in">start</span> .</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="built_in">start</span> %<span class="built_in">cd</span>%</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">explorer .</span><br></pre></td></tr></table></figure>
<h2 id="壁纸">4. 壁纸</h2>
<ul>
<li>开机壁纸(其中AppData是隐藏文件夹</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">C:\Users\你的用户名\AppData\Local\Packages\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\LocalState\Assets</span><br></pre></td></tr></table></figure>
<h2 id="软件">5. 软件</h2>
<h3 id="obs">OBS</h3>
<ul>
<li>OBS 黑屏
<ul>
<li>系统 - 显示 - 图形设置 - 经典应用浏览 - 选择OBS
Studio（大约是\obs-studio\64bit ) - 选择<strong>节能</strong></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>win</category>
      </categories>
      <tags>
        <tag>Kits</tag>
        <tag>win</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 一些小软件</title>
    <url>/2021/10/12/Kits/win/software/</url>
    <content><![CDATA[<h1 id="windows-一些小软件">windows 一些小软件</h1>
<ul>
<li>有些软件可能不兼容屏幕缩放，需要修改下软件的兼容性设置
<ul>
<li>右键，兼容性，更改高 DPI 设置，替代高 DPI 缩放行为</li>
</ul></li>
</ul>
<h2 id="屏幕操作">1. 屏幕操作</h2>
<h3 id="faststone-capture">(1) FastStone Capture</h3>
<ul>
<li><a href="https://www.faststone.org/download.htm">官网</a></li>
<li>截图软件</li>
<li>激活可能需要序列号，网上可以白嫖</li>
</ul>
<p><img src="/2021/10/12/Kits/win/software/image-20211012223014283.png"></p>
<h3 id="colorpix">(2) ColorPix</h3>
<ul>
<li><a href="https://colorpix.en.softonic.com/">下载链接</a></li>
<li>取色软件</li>
<li>Chrome 浏览器自带取色功能（F12）</li>
</ul>
<p><img src="/2021/10/12/Kits/win/software/image-20211012223518620.png"></p>
<h3 id="qq">(3) QQ</h3>
<ul>
<li><a href="https://im.qq.com/index">官网</a></li>
<li>截图</li>
<li>OCR，图片文字提取</li>
</ul>
<h3 id="按键精灵">(4) 按键精灵</h3>
<ul>
<li><a href="http://www.anjian.com/">官网</a></li>
<li>简单的屏幕脚本语言，鼠标键盘模拟软件，能够做一些重复性工作</li>
</ul>
<h3 id="xlaunch">(5) XLaunch</h3>
<ul>
<li><a href="https://sourceforge.net/projects/xlauncher/">下载链接</a></li>
<li>windows 获取 WSL 的图形界面</li>
<li>WSL 需要设置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> DISPLAY=-1</span><br></pre></td></tr></table></figure>
<h3 id="deskpins">(6) DeskPins</h3>
<ul>
<li><a href="https://efotinis.neocities.org/deskpins/index.html">官网</a></li>
<li>能够将某个窗口置顶</li>
</ul>
<h3 id="screentogif">(7) ScreenToGif</h3>
<ul>
<li><a href="https://www.screentogif.com/">官网</a></li>
<li>录制屏幕转成 GIF</li>
</ul>
<h2 id="音视频图片处理">2. 音视频、图片处理</h2>
<h3 id="ffmpeg">(1) FFmpeg</h3>
<ul>
<li><a href="https://ffmpeg.org/">官网</a></li>
<li>音视频处理软件</li>
<li>命令行工具</li>
</ul>
<h4 id="ffplay">FFplay</h4>
<ul>
<li>播放视频</li>
</ul>
<h4 id="ffprobe">FFprobe</h4>
<ul>
<li>查看视频各种源信息</li>
</ul>
<h3 id="xnview">(2) XnView</h3>
<ul>
<li><a href="https://www.xnview.com/en/">官网</a></li>
<li>简单图像处理软件
<ul>
<li>批量图片转化</li>
<li>简单的 PS 操作</li>
</ul></li>
</ul>
<p><img src="/2021/10/12/Kits/win/software/image-20211012224331727.png" style="zoom:67%;"></p>
<h4 id="xnconvert">XnConvert</h4>
<ul>
<li>批量图片格式转换</li>
</ul>
<h3 id="mkvtoolnix">(3) MKVToolNix</h3>
<ul>
<li><a href="https://mkvtoolnix.download/downloads.html#windows">官网</a></li>
<li>视频处理软件
<ul>
<li>视频格式转换</li>
<li>视频切割</li>
</ul></li>
<li>mkv 文件处理
<ul>
<li>PR 不支持 mkv 视频直接导入，可以使用这个转换</li>
</ul></li>
</ul>
<p><img src="/2021/10/12/Kits/win/software/image-20211012224807067.png" style="zoom:67%;"></p>
<h3 id="potplayer">(4) PotPlayer</h3>
<ul>
<li><a href="https://download.cnet.com/PotPlayer-64-bit/3000-13632_4-76158571.html">下载链接</a></li>
<li>视频播放器</li>
</ul>
<h2 id="文本处理">3. 文本处理</h2>
<h3 id="typora">(1) Typora</h3>
<ul>
<li><a href="https://typora.io/">官网</a></li>
<li>markdown 编辑器</li>
</ul>
<h3 id="notepad">(2) notepad++</h3>
<ul>
<li><a href="https://notepad-plus-plus.org/downloads/">官网</a></li>
<li>简单的文本编辑器</li>
</ul>
<h2 id="文件处理">4. 文件处理</h2>
<h3 id="everything">(1) Everything</h3>
<ul>
<li><a href="https://www.voidtools.com/zh-cn/">官网</a></li>
<li>文件查找工具</li>
</ul>
<p><img src="/2021/10/12/Kits/win/software/image-20211012230056061.png" style="zoom:67%;"></p>
<h3 id="zip">(2) 7-Zip</h3>
<ul>
<li><a href="https://www.7-zip.org/">官网</a></li>
<li>文件压缩工具</li>
</ul>
<p><img src="/2021/10/12/Kits/win/software/image-20211012231215549.png" style="zoom:67%;"></p>
<h2 id="下载器">5. 下载器</h2>
<h3 id="磁力下载">(1) 磁力下载</h3>
<h4 id="utorrent">utorrent</h4>
<ul>
<li><a href="https://www.utorrent.com/">官网</a></li>
</ul>
<h4 id="qbittorrent">qbittorrent</h4>
<ul>
<li><a href="https://www.qbittorrent.org/download.php">官网</a></li>
</ul>
]]></content>
      <categories>
        <category>win</category>
      </categories>
      <tags>
        <tag>win</tag>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈与社会目录</title>
    <url>/2021/06/28/book/directory/BoYiYuSheHui/</url>
    <content><![CDATA[<h1 id="博弈与社会">博弈与社会</h1>
<h2 id="第一章-导论-个体理性与社会最优">第一章 导论
个体理性与社会最优</h2>
<h3 id="第一节-社会的基本问题">第一节 社会的基本问题</h3>
<h4 id="协调问题">1.1 协调问题</h4>
<h4 id="合作问题">1.2 合作问题</h4>
<h4 id="协调与合作交织">1.3 协调与合作交织</h4>
<h4 id="正式制度与非正式制度">1.4 正式制度与非正式制度</h4>
<h3 id="第二节-个体理性行为">第二节 个体理性行为</h3>
<h4 id="博弈论的方法论">2.1 博弈论的方法论</h4>
<h4 id="工具理性假设">2.2 工具理性假设</h4>
<h4 id="有限理性">2.3 有限理性</h4>
<h4 id="理性人假设的意义">2.4 理性人假设的意义</h4>
<h3 id="第三节-社会最优与帕累托标准">第三节 社会最优与帕累托标准</h3>
<h4 id="帕累托效率标准">3.1 帕累托效率标准</h4>
<h4 id="效率的卡尔多-希克斯标准">3.2 效率的卡尔多-希克斯标准</h4>
<h4 id="效率标准在法律上的应用">3.3 效率标准在法律上的应用</h4>
<h3 id="本章提要">本章提要</h3>
<h2 id="第二章-纳什均衡与囚徒困境博弈">第二章
纳什均衡与囚徒困境博弈</h2>
<h3 id="第一节-博弈论的基本概念">第一节 博弈论的基本概念</h3>
<h3 id="第二节-囚徒困境博弈">第二节 囚徒困境博弈</h3>
<h4 id="囚徒困境个人理性与集体理性的矛盾">2.1
囚徒困境：个人理性与集体理性的矛盾</h4>
<h4 id="囚徒困境举例">2.2 囚徒困境举例</h4>
<h4 id="囚徒困境的一般形式">2.3 囚徒困境的一般形式</h4>
<h3 id="第三节-理性化选择">第三节 理性化选择</h3>
<h4 id="理性人不选择坏战略">3.1 理性人不选择坏战略</h4>
<h4 id="理性作为共同知识">3.2 理性作为共同知识</h4>
<h3 id="第四节-纳什均衡与一致预期">第四节 纳什均衡与一致预期</h3>
<h4 id="纳什均衡">4.1 纳什均衡</h4>
<h4 id="应用举例寻租行为和产权制度">4.2
应用举例：寻租行为和产权制度</h4>
<h4 id="混合策略下的纳什均衡">4.3 混合策略下的纳什均衡</h4>
<h3 id="本章提要-1">本章提要</h3>
<h2 id="第三章-多重均衡与制度和文化">第三章 多重均衡与制度和文化</h2>
<h3 id="第一节-多重均衡问题">第一节 多重均衡问题</h3>
<h4 id="产品标准化问题">1.1 产品标准化问题</h4>
<h4 id="交通博弈">1.2 交通博弈</h4>
<h4 id="约会博弈">1.3 约会博弈</h4>
<h4 id="资源争夺博弈">1.4 资源争夺博弈</h4>
<h4 id="分蛋糕问题">1.5 分蛋糕问题</h4>
<h3 id="第二节-聚点均衡和均衡选择">第二节 聚点均衡和均衡选择</h3>
<h4 id="聚点均衡">2.1 聚点均衡</h4>
<h4 id="帕累托标准">2.2 帕累托标准</h4>
<h3 id="第三节-法律和社会规范的协调作用">第三节
法律和社会规范的协调作用</h3>
<h4 id="交通规则的演进">3.1 交通规则的演进</h4>
<h4 id="规则间的冲突和协调">3.2 规则间的冲突和协调</h4>
<h4 id="协调中的信息">3.3 协调中的信息</h4>
<h4 id="规则的正义性">3.4 规则的正义性</h4>
<h3 id="第四节-路径依赖的困惑">第四节 路径依赖的困惑</h3>
<h4 id="键盘的寓言">4.1 键盘的寓言</h4>
<h4 id="vhs的秘密">4.2 VHS的秘密</h4>
<h4 id="微软神话">4.3 微软神话</h4>
<h4 id="大学改革的童话">4.4 大学改革的童话</h4>
<h3 id="本章提要-2">本章提要</h3>
<h2 id="第四章-威胁与承诺">第四章 威胁与承诺</h2>
<h3 id="第一节-威胁的可信与不可信">第一节 威胁的可信与不可信</h3>
<h4 id="动态博弈的描述">1.1 动态博弈的描述</h4>
<h4 id="作为行动计划的战略">1.2 作为行动计划的战略</h4>
<h4 id="威胁的可信性">1.3 威胁的可信性</h4>
<h3 id="第二节-序贯理性">第二节 序贯理性</h3>
<h4 id="动态博弈中的理性要求">2.1 动态博弈中的理性要求</h4>
<h4 id="子博弈">2.2 子博弈</h4>
<h4 id="逆向归纳与理性共识">2.3 逆向归纳与理性共识</h4>
<h4 id="反事实悖论">2.4 反事实悖论</h4>
<h3 id="第三节-承诺行为">第三节 承诺行为</h3>
<h4 id="承诺的作用">3.1 承诺的作用</h4>
<h4 id="承诺的成本">3.2 承诺的成本</h4>
<h3 id="第四节-宪政与民主">第四节 宪政与民主</h3>
<h4 id="有限政府">4.1 有限政府</h4>
<h4 id="民主作为一种承诺">4.2 民主作为一种承诺</h4>
<h3 id="本章提要-3">本章提要</h3>
<h2 id="第五章-讨价还价与耐心">第五章 讨价还价与耐心</h2>
<h3 id="第一节-讨价还价问题">第一节 讨价还价问题</h3>
<h4 id="合作与冲突">1.1 合作与冲突</h4>
<h4 id="合作博弈与非合作博弈">1.2 合作博弈与非合作博弈</h4>
<h3 id="第二节-谈判砝码与谈判能力">第二节 谈判砝码与谈判能力</h3>
<h4 id="蛋糕的大小与分配">2.1 蛋糕的大小与分配</h4>
<h4 id="纳什谈判解">2.2 纳什谈判解</h4>
<h4 id="边际贡献与谈判能力">2.3 边际贡献与谈判能力</h4>
<h4 id="改变谈判砝码">2.4 改变谈判砝码</h4>
<h4 id="应用举例国有企业改制中的资产定价">2.5
应用举例：国有企业改制中的资产定价</h4>
<h3 id="第三节-轮流出价与耐心">第三节 轮流出价与耐心</h3>
<h4 id="有限次谈判与后动优势">3.1 有限次谈判与后动优势</h4>
<h4 id="无限期谈判与耐心">3.2 无限期谈判与耐心</h4>
<h4 id="耐心与公平">3.3 耐心与公平</h4>
<h4 id="谈判成本">3.4 谈判成本</h4>
<h4 id="谈判与信息">3.5 谈判与信息</h4>
<h3 id="第四节-谈判中的社会规范">第四节 谈判中的社会规范</h3>
<h4 id="最后通牒博弈">4.1 最后通牒博弈</h4>
<h4 id="社会规范">4.2 社会规范</h4>
<h3 id="本章提要-4">本章提要</h3>
<h2 id="第六章-重复博弈和合作行为">第六章 重复博弈和合作行为</h2>
<h3 id="第一节-走出囚徒困境">第一节 走出囚徒困境</h3>
<h4 id="重复博弈">1.1 重复博弈</h4>
<h4 id="战略空间">1.2 战略空间</h4>
<h4 id="合作的价值与耐心">1.3 合作的价值与耐心</h4>
<h3 id="第二节-合作与惩罚">第二节 合作与惩罚</h3>
<h4 id="针锋相对">2.1 针锋相对</h4>
<h4 id="永不原谅">2.2 永不原谅</h4>
<h4 id="信息与合作">2.3 信息与合作</h4>
<h4 id="胡萝卜加大棒">2.4 胡萝卜加大棒</h4>
<h4 id="皇帝女儿不愁嫁">2.5 皇帝女儿不愁嫁</h4>
<h4 id="过犹不及">2.6 过犹不及</h4>
<h3 id="第三节-大社会中的合作">第三节 大社会中的合作</h3>
<h4 id="多重关系下的合作">3.1 多重关系下的合作</h4>
<h4 id="长期参与人">3.2 长期参与人</h4>
<h4 id="和尚与庙">3.3 和尚与庙</h4>
<h4 id="联合抵制的社会规范">3.4 联合抵制的社会规范</h4>
<h4 id="敌友规则">3.5 敌友规则</h4>
<h4 id="连带责任">3.6 连带责任</h4>
<h3 id="本章提要-5">本章提要</h3>
<h2 id="第七章-不完全信息与声誉">第七章 不完全信息与声誉</h2>
<h3 id="第一节-连锁店悖论">第一节 连锁店悖论</h3>
<h4 id="连锁店悖论">1.1 连锁店悖论</h4>
<h4 id="奖惩与合作">1.2 奖惩与合作</h4>
<h3 id="第二节-信息不完全与声誉机制">第二节 信息不完全与声誉机制</h3>
<h4 id="单方信息不完全与声誉机制">2.1 单方信息不完全与声誉机制</h4>
<h4 id="双方信息不完全下的声誉机制">2.2 双方信息不完全下的声誉机制</h4>
<h3 id="第三节-声誉模型应用举例">第三节 声誉模型应用举例</h3>
<h4 id="解开连锁店悖论">3.1 解开连锁店悖论</h4>
<h4 id="大智若愚">3.2 大智若愚</h4>
<h4 id="政府的声誉">3.3 政府的声誉</h4>
<h4 id="刑不上大夫">3.4 “刑不上大夫”</h4>
<h3 id="第四节-声誉的积累">第四节 声誉的积累</h3>
<h4 id="贝叶斯法则">4.1 贝叶斯法则</h4>
<h4 id="假作真来真亦假">4.2 假作真来真亦假</h4>
<h4 id="大学的名声">4.3 大学的名声</h4>
<h3 id="本章提要-6">本章提要</h3>
<h2 id="第八章-逆向选择与品牌和政府管制">第八章
逆向选择与品牌和政府管制</h2>
<h3 id="第一节-非对称信息问题及其后果">第一节
非对称信息问题及其后果</h3>
<h4 id="非对称信息问题">1.1 非对称信息问题</h4>
<h4 id="逆向选择">1.2 逆向选择</h4>
<h4 id="金融市场中的逆向选择">1.3 金融市场中的逆向选择</h4>
<h4 id="生活中其他一些逆向选择现象">1.4 生活中其他一些逆向选择现象</h4>
<h3 id="第二节-非对称信息与品牌价值">第二节 非对称信息与品牌价值</h3>
<h4 id="解决非对称信息的市场机制">2.1 解决非对称信息的市场机制</h4>
<h4 id="行业与品牌价值">2.2 行业与品牌价值</h4>
<h4 id="技术进步与品牌">2.3 技术进步与品牌</h4>
<h4 id="收入水平与品牌价值">2.4 收入水平与品牌价值</h4>
<h3 id="第三节-非对称信息与政府管制">第三节 非对称信息与政府管制</h3>
<h4 id="解决非对称信息的非市场机制">3.1 解决非对称信息的非市场机制</h4>
<h4 id="政府管制与信誉">3.2 政府管制与信誉</h4>
<h3 id="本章提要-7">本章提要</h3>
<h2 id="第九章-信号传递与社会规范">第九章 信号传递与社会规范</h2>
<h3 id="第一节-信号传递机制">第一节 信号传递机制</h3>
<h4 id="学历与能力">1.1 学历与能力</h4>
<h4 id="信号传递的一般模型">1.2 信号传递的一般模型</h4>
<h3 id="第二节-经济和社会生活中的种种信号">第二节
经济和社会生活中的种种信号</h3>
<h4 id="广告的信号传递作用">2.1 广告的信号传递作用</h4>
<h4 id="资本市场中的信号传递">2.2 资本市场中的信号传递</h4>
<h4 id="资本雇佣劳动">2.3 资本雇佣劳动</h4>
<h4 id="生活中的信号传递">2.4 生活中的信号传递</h4>
<h3 id="第三节-社会规范的信号传递作用">第三节
社会规范的信号传递作用</h3>
<h4 id="如何理解送礼">3.1 如何理解送礼</h4>
<h4 id="婚姻契约">3.2 婚姻契约</h4>
<h4 id="浪费性消费">3.3 浪费性消费</h4>
<h4 id="礼仪和法律的作用">3.4 礼仪和法律的作用</h4>
<h4 id="信息不对称与观念变迁">3.5 信息不对称与观念变迁</h4>
<h3 id="本章提要-8">本章提要</h3>
<h2 id="第十章-机制设计与收入分配">第十章 机制设计与收入分配</h2>
<h3 id="第一节-机制设计理论">第一节 机制设计理论</h3>
<h4 id="如何让人说真话">1.1 如何让人说真话</h4>
<h4 id="混同均衡和分离均衡">1.2 混同均衡和分离均衡</h4>
<h4 id="部分保险与全额保险">1.3 部分保险与全额保险</h4>
<h3 id="第二节-价格歧视">第二节 价格歧视</h3>
<h4 id="卖方的无知">2.1 卖方的无知</h4>
<h4 id="两部收费制与信息租金">2.2 两部收费制与信息租金</h4>
<h4 id="穷人受罪与吓唬富人">2.3 穷人受罪与吓唬富人</h4>
<h3 id="第三节-拍卖机制设计和公共产品偏好">第三节
拍卖机制设计和公共产品偏好</h3>
<h4 id="四种基本拍卖方式">3.1 四种基本拍卖方式</h4>
<h4 id="说实话的拍卖机制">3.2 说实话的拍卖机制</h4>
<h4 id="公共产品的偏好显示">3.3 公共产品的偏好显示</h4>
<h3 id="第四节-平等与效率">第四节 平等与效率</h3>
<h4 id="平等与效率矛盾的根源">4.1 平等与效率矛盾的根源</h4>
<h4 id="莫里斯最优收入税理论">4.2 莫里斯最优收入税理论</h4>
<h4 id="国有企业高素质员工的流失">4.3 国有企业高素质员工的流失</h4>
<h3 id="第五节-大学教师的选拔机制">第五节 大学教师的选拔机制</h3>
<h4 id="鱼目混珠与自投罗网">5.1 鱼目混珠与自投罗网</h4>
<h4 id="解决武大郎开店问题">5.2 解决武大郎开店问题</h4>
<h3 id="本章提要-9">本章提要</h3>
<h2 id="第十一章-道德风险与腐败">第十一章 道德风险与腐败</h2>
<h3 id="第一节-从腐败谈起">第一节 从腐败谈起</h3>
<h3 id="第二节-委托-代理模型">第二节 委托-代理模型</h3>
<h4 id="利益冲突">2.1 利益冲突</h4>
<h4 id="信息不对称">2.2 信息不对称</h4>
<h4 id="风险态度">2.3 风险态度</h4>
<h4 id="有限责任">2.4 有限责任</h4>
<h3 id="第三节-激励机制的设计">第三节 激励机制的设计</h3>
<h4 id="激励与保险的冲突">3.1 激励与保险的冲突</h4>
<h4 id="激励的强度">3.2 激励的强度</h4>
<h4 id="相对绩效比较">3.3 相对绩效比较</h4>
<h4 id="论功行赏与任人唯贤">3.4 论功行赏与任人唯贤</h4>
<h4 id="大学教员的激励">3.5 大学教员的激励</h4>
<h3 id="第四节-政府官员的激励">第四节 政府官员的激励</h3>
<h4 id="难以监督的官员">4.1 难以监督的官员</h4>
<h4 id="腐败方程式">4.2 腐败方程式</h4>
<h4 id="腐败的蔓延">4.3 腐败的蔓延</h4>
<h4 id="腐败的治理">4.4 腐败的治理</h4>
<h3 id="本章提要-10">本章提要</h3>
<h2 id="第十二章-演化博弈与自发秩序">第十二章 演化博弈与自发秩序</h2>
<h3 id="第一节-演化博弈的基本要素">第一节 演化博弈的基本要素</h3>
<h4 id="从生物进化到社会演进">1.1 从生物进化到社会演进</h4>
<h4 id="演化稳定战略">1.2 演化稳定战略</h4>
<h4 id="生物进化与社会演化的不同">1.3 生物进化与社会演化的不同</h4>
<h4 id="单元均衡与多元均衡">1.4 单元均衡与多元均衡</h4>
<h3 id="第二节-演化博弈举例">第二节 演化博弈举例</h3>
<h4 id="协调博弈">2.1 协调博弈</h4>
<h4 id="婚姻博弈">2.2 婚姻博弈</h4>
<h4 id="鹰鸽博弈">2.3 鹰鸽博弈</h4>
<h3 id="第三节-囚徒困境与合作文化的演进">第三节
囚徒困境与合作文化的演进</h3>
<h4 id="针锋相对者生存">3.1 针锋相对者生存</h4>
<h4 id="弱稳定与强稳定">3.2 弱稳定与强稳定</h4>
<h4 id="合作文化的破坏">3.3 合作文化的破坏</h4>
<h3 id="第四节-自发秩序与产权制度的演化">第四节
自发秩序与产权制度的演化</h3>
<h4 id="自发秩序">4.1 自发秩序</h4>
<h4 id="产权博弈">4.2 产权博弈</h4>
<h4 id="惯例的出现">4.3 惯例的出现</h4>
<h4 id="从惯例到规范">4.4 从惯例到规范</h4>
<h3 id="本章提要-11">本章提要</h3>
<h2 id="第十三章-法律与社会规范">第十三章 法律与社会规范</h2>
<h3 id="第一节-法律的有效性">第一节 法律的有效性</h3>
<h3 id="第二节-法律与社会规范的不同">第二节 法律与社会规范的不同</h3>
<h3 id="第三节-法律和社会规范的基本功能">第三节
法律和社会规范的基本功能</h3>
<h4 id="三种社会规范">3.1 三种社会规范</h4>
<h4 id="作为激励机制的法律与社会规范">3.2
作为激励机制的法律与社会规范</h4>
<h4 id="作为协调预期的法律与社会规范">3.3
作为协调预期的法律与社会规范</h4>
<h4 id="作为信号传递机制的法律与社会规范">3.4
作为信号传递机制的法律与社会规范</h4>
<h3 id="第四节-社会规范的遵守与违反">第四节 社会规范的遵守与违反</h3>
<h4 id="人们为什么遵守社会规范">4.1 人们为什么遵守社会规范</h4>
<h4 id="人们为什么违反社会规范">4.2 人们为什么违反社会规范</h4>
<h4 id="二阶囚徒困境问题">4.3 二阶囚徒困境问题</h4>
<h3 id="第五节-社会规范和法律的社会条件">第五节
社会规范和法律的社会条件</h3>
<h4 id="影响法律和社会规范相对有效性的因素">5.1
影响法律和社会规范相对有效性的因素</h4>
<h4 id="法治国家和国家法治">5.2 法治国家和国家法治</h4>
<h3 id="本章提要-12">本章提要</h3>
<h2 id="第十四章-制度企业家与儒家社会规范">第十四章
制度企业家与儒家社会规范</h2>
<h3 id="第一节-制度企业家">第一节 制度企业家</h3>
<h4 id="游戏规则的创新者">1.1 游戏规则的创新者</h4>
<h4 id="风险与理念">1.2 风险与理念</h4>
<h3 id="第二节-轴心时代的制度企业家">第二节 轴心时代的制度企业家</h3>
<h4 id="为天下立道">2.1 为天下立道</h4>
<h4 id="人类的行为准则">2.2 人类的行为准则</h4>
<h4 id="成功者的轨迹">2.3 成功者的轨迹</h4>
<h3 id="第三节-儒家社会规范">第三节 儒家社会规范</h3>
<h4 id="作为社会规范和法律的混合体的礼">3.1
作为社会规范和法律的混合体的礼</h4>
<h4 id="协调预期与定分止争">3.2 协调预期与定分止争</h4>
<h4 id="君子与激励机制">3.3 君子与激励机制</h4>
<h4 id="儒家文化作为古代社会游戏规则的价值">3.4
儒家文化作为古代社会游戏规则的价值</h4>
<h4 id="古典儒家的法治精神与中国的未来">3.5
古典儒家的法治精神与中国的未来</h4>
<h3 id="本章提要-13">本章提要</h3>
]]></content>
      <categories>
        <category>book.directory</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>亲密关系目录</title>
    <url>/2021/11/04/book/directory/IntimateRelationships/</url>
    <content><![CDATA[<h1 id="说明">说明</h1>
<ul>
<li>书名：《亲密关系》第 6 版</li>
<li>作者：【美】罗曼·米勒
<ul>
<li>Rowland S.Miller</li>
</ul></li>
<li>译者：王伟平</li>
<li>审校：彭凯平</li>
<li>出版社：人民邮电出版社</li>
<li>版次：2015.06 第1版</li>
</ul>
<h1 id="亲密关系">亲密关系</h1>
<h2 id="第1章-人际关系的构成">第1章 人际关系的构成</h2>
<h3 id="亲密关系的性质和重要性">亲密关系的性质和重要性</h3>
<h4 id="亲密关系的性质">亲密关系的性质</h4>
<h4 id="归属需要">归属需要</h4>
<h3 id="文化的影响">文化的影响</h3>
<h4 id="亲密关系变化的根源">亲密关系变化的根源</h4>
<h3 id="个人经历的影响">个人经历的影响</h3>
<h3 id="个体差异的影响">个体差异的影响</h3>
<h4 id="性别差异">性别差异</h4>
<h4 id="性认同差异">性认同差异</h4>
<h4 id="人格">人格</h4>
<h4 id="自尊">自尊</h4>
<h3 id="人类本性的影响">人类本性的影响</h3>
<h3 id="人际互动的影响">人际互动的影响</h3>
<h3 id="人际关系的消极面">人际关系的消极面</h3>
<h3 id="请你思考">请你思考</h3>
<h2 id="第2章-研究方法">第2章 研究方法</h2>
<h3 id="关系科学研究简史">关系科学研究简史</h3>
<h3 id="问题的提出">问题的提出</h3>
<h3 id="参与者的选取">参与者的选取</h3>
<h3 id="研究的设计">研究的设计</h3>
<h4 id="相关设计">相关设计</h4>
<h4 id="实验设计">实验设计</h4>
<h4 id="发展性研究设计">发展性研究设计</h4>
<h3 id="场景的选择">场景的选择</h3>
<h3 id="数据的性质">数据的性质</h3>
<h4 id="自我报告">自我报告</h4>
<h4 id="观察法">观察法</h4>
<h4 id="生理测量">生理测量</h4>
<h4 id="档案材料">档案材料</h4>
<h3 id="研究应遵循的道德规范">研究应遵循的道德规范</h3>
<h3 id="结果的解释和整合">结果的解释和整合</h3>
<h3 id="最后要点">最后要点</h3>
<h3 id="请你思考-1">请你思考</h3>
<h2 id="第3章-吸引力">第3章 吸引力</h2>
<h3 id="吸引力的基础一种奖赏">吸引力的基础：一种奖赏</h3>
<h3 id="临近喜欢身边的人">临近：喜欢身边的人</h3>
<h4 id="方便远亲不如近邻">方便：远亲不如近邻</h4>
<h4 id="熟识重复接触">熟识：重复接触</h4>
<h4 id="临近的作用">临近的作用</h4>
<h3 id="长相吸引力喜欢那些可爱的人">长相吸引力：喜欢那些可爱的人</h3>
<h4 id="对美丽的偏见美的就是好的">对美丽的偏见：“美的就是好的”</h4>
<h4 id="吸引力的秘密">吸引力的秘密</h4>
<h4 id="长相吸引力的演化观">长相吸引力的演化观</h4>
<h4 id="文化也起作用">文化也起作用</h4>
<h4 id="长相的重要性">长相的重要性</h4>
<h4 id="美丽交织着的代价与收益">美丽：交织着的代价与收益</h4>
<h4 id="长相吸引力的匹配">长相吸引力的匹配</h4>
<h3 id="礼尚往来喜欢那些喜欢我们的人">礼尚往来：喜欢那些喜欢我们的人</h3>
<h3 id="相似性喜欢与我们相像的人">相似性：喜欢与我们相像的人</h3>
<h4 id="有吸引力的相像种类">有吸引力的相像种类</h4>
<h4 id="相异并不相吸">相异并不相吸</h4>
<h3 id="障碍得不到的就喜欢">障碍：得不到的就喜欢</h3>
<h3 id="男女两性期望的理想伴侣">男女两性期望的理想伴侣</h3>
<h3 id="请你思考-2">请你思考</h3>
<h2 id="第4章-社会认知">第4章 社会认知</h2>
<h3 id="第一印象及其影响">第一印象及其影响</h3>
<h3 id="知觉的力量">知觉的力量</h3>
<h4 id="伴侣的理想化">伴侣的理想化</h4>
<h4 id="归因过程">归因过程</h4>
<h4 id="记忆">记忆</h4>
<h4 id="关系信念">关系信念</h4>
<h4 id="期望">期望</h4>
<h4 id="自我知觉">自我知觉</h4>
<h3 id="印象管理">印象管理</h3>
<h4 id="印象管理策略">印象管理策略</h4>
<h4 id="亲密关系中的印象管理">亲密关系中的印象管理</h4>
<h3 id="我们了解伴侣的程度">我们了解伴侣的程度</h3>
<h4 id="了解">了解</h4>
<h4 id="动机">动机</h4>
<h4 id="伴侣的易理解性">伴侣的易理解性</h4>
<h4 id="知觉者的能力">知觉者的能力</h4>
<h4 id="危险的知觉">危险的知觉</h4>
<h4 id="知觉者的影响">知觉者的影响</h4>
<h4 id="小结">小结</h4>
<h3 id="请你思考-3">请你思考</h3>
<h2 id="第5章-沟通">第5章 沟通</h2>
<h3 id="非言语沟通">非言语沟通</h3>
<h4 id="非言语沟通的组成">非言语沟通的组成</h4>
<h4 id="非言语的敏感性">非言语的敏感性</h4>
<h3 id="言语沟通">言语沟通</h3>
<h4 id="自我表露">自我表露</h4>
<h4 id="言语沟通中的性别差异">言语沟通中的性别差异</h4>
<h3 id="沟通障碍及其应对">沟通障碍及其应对</h3>
<h4 id="沟通不良">沟通不良</h4>
<h4 id="精确表述">精确表述</h4>
<h4 id="积极倾听">积极倾听</h4>
<h4 id="守礼而镇定">守礼而镇定</h4>
<h4 id="尊重和确认的力量">尊重和确认的力量</h4>
<h3 id="请你思考-4">请你思考</h3>
<h2 id="第6章-相互依赖">第6章 相互依赖</h2>
<h3 id="社会交换">社会交换</h3>
<h4 id="奖赏和代价">奖赏和代价</h4>
<h4 id="人际关系的期望收益">人际关系的期望收益</h4>
<h4 id="人际关系的替代收益">人际关系的替代收益</h4>
<h4 id="人际关系的四种类型">人际关系的四种类型</h4>
<h4 id="与时俱变的比较水平">与时俱变的比较水平</h4>
<h3 id="亲密关系的经济论">亲密关系的经济论</h3>
<h4 id="奖赏的作用不同于代价">奖赏的作用不同于代价</h4>
<h4 id="与时俱变的奖赏和代价">与时俱变的奖赏和代价</h4>
<h3 id="亲密关系中的贪婪">亲密关系中的贪婪</h3>
<h4 id="相互依赖的实质">相互依赖的实质</h4>
<h4 id="交换关系与共有关系">交换关系与共有关系</h4>
<h4 id="公平关系">公平关系</h4>
<h4 id="小结-1">小结</h4>
<h3 id="承诺的本质">承诺的本质</h3>
<h4 id="承诺引起的后果">承诺引起的后果</h4>
<h3 id="请你思考-5">请你思考</h3>
<h2 id="第7章-友谊">第7章 友谊</h2>
<h3 id="友谊的本质">友谊的本质</h3>
<h4 id="友谊的属性">友谊的属性</h4>
<h4 id="友谊的规则">友谊的规则</h4>
<h3 id="友谊的毕生变化">友谊的毕生变化</h3>
<h4 id="童年期">童年期</h4>
<h4 id="青少年期">青少年期</h4>
<h4 id="成年早期">成年早期</h4>
<h4 id="中年期">中年期</h4>
<h4 id="老年期">老年期</h4>
<h3 id="友谊的差异">友谊的差异</h3>
<h4 id="同性友谊中的性别差异">同性友谊中的性别差异</h4>
<h4 id="友谊的个体差异">友谊的个体差异</h4>
<h3 id="友谊发展的障碍">友谊发展的障碍</h3>
<h4 id="羞怯">羞怯</h4>
<h4 id="孤独">孤独</h4>
<h3 id="请你思考-6">请你思考</h3>
<h2 id="第8章-爱情">第8章 爱情</h2>
<h3 id="爱情简史">爱情简史</h3>
<h3 id="爱情类型">爱情类型</h3>
<h4 id="爱情三角理论">爱情三角理论</h4>
<h4 id="浪漫狂热之爱">浪漫狂热之爱</h4>
<h4 id="相伴之爱">相伴之爱</h4>
<h4 id="同情之爱">同情之爱</h4>
<h4 id="爱恋风格">爱恋风格</h4>
<h3 id="爱情的个体和文化差异">爱情的个体和文化差异</h3>
<h4 id="文化">文化</h4>
<h4 id="依恋类型">依恋类型</h4>
<h4 id="年龄">年龄</h4>
<h4 id="性别">性别</h4>
<h3 id="爱情能持久吗">爱情能持久吗</h3>
<h4 id="浪漫爱情为何难以持久">浪漫爱情为何难以持久</h4>
<h4 id="爱情的未来怎样">爱情的未来怎样</h4>
<h3 id="请你思考-7">请你思考</h3>
<h2 id="第9章-性爱">第9章 性爱</h2>
<h3 id="性态度">性态度</h3>
<h4 id="对随意性行为的态度">对随意性行为的态度</h4>
<h4 id="对同性恋的态度">对同性恋的态度</h4>
<h4 id="性态度上的文化差异">性态度上的文化差异</h4>
<h3 id="性行为">性行为</h3>
<h4 id="第一次性行为">第一次性行为</h4>
<h4 id="忠诚关系中的性行为">忠诚关系中的性行为</h4>
<h4 id="不贞">不贞</h4>
<h4 id="性欲望">性欲望</h4>
<h4 id="安全而明智的性行为">安全而明智的性行为</h4>
<h3 id="性满足">性满足</h3>
<h4 id="性沟通">性沟通</h4>
<h4 id="性满足与关系满意度">性满足与关系满意度</h4>
<h3 id="性胁迫">性胁迫</h3>
<h3 id="请你思考-8">请你思考</h3>
<h2 id="第10章-压力与紧张">第10章 压力与紧张</h2>
<h3 id="感知到的关系价值">感知到的关系价值</h3>
<h3 id="感情创伤">感情创伤</h3>
<h3 id="伴侣排斥">伴侣排斥</h3>
<h3 id="嫉妒">嫉妒</h3>
<h4 id="嫉妒的两种类型">嫉妒的两种类型</h4>
<h4 id="容易嫉妒的人">容易嫉妒的人</h4>
<h4 id="让人嫉妒的人">让人嫉妒的人</h4>
<h4 id="让人嫉妒的事物">让人嫉妒的事物</h4>
<h4 id="对嫉妒的反应">对嫉妒的反应</h4>
<h4 id="积极有效地应对嫉妒">积极有效地应对嫉妒</h4>
<h3 id="欺骗和说谎">欺骗和说谎</h3>
<h4 id="亲密关系和普通关系中的说谎行为">亲密关系和普通关系中的说谎行为</h4>
<h4 id="谎言与说谎者">谎言与说谎者</h4>
<h4 id="对伴侣欺骗行为的觉察">对伴侣欺骗行为的觉察</h4>
<h3 id="背叛">背叛</h3>
<h4 id="背叛的个体差异">背叛的个体差异</h4>
<h4 id="背叛的两面性">背叛的两面性</h4>
<h4 id="应对背叛">应对背叛</h4>
<h3 id="宽恕">宽恕</h3>
<h3 id="请你思考-9">请你思考</h3>
<h2 id="第11章-冲突">第11章 冲突</h2>
<h3 id="冲突的性质">冲突的性质</h3>
<h4 id="冲突的定义">冲突的定义</h4>
<h4 id="冲突的频率">冲突的频率</h4>
<h3 id="冲突的过程">冲突的过程</h3>
<h4 id="激发事件">激发事件</h4>
<h4 id="归因">归因</h4>
<h4 id="介入和升级">介入和升级</h4>
<h4 id="要求退避模式">要求/退避模式</h4>
<h4 id="协商和顺应">协商和顺应</h4>
<h4 id="应对冲突四类夫妻">应对冲突：四类夫妻</h4>
<h3 id="冲突的结果">冲突的结果</h3>
<h4 id="冲突的结束">冲突的结束</h4>
<h4 id="冲突的益处">冲突的益处</h4>
<h3 id="请你思考-10">请你思考</h3>
<h2 id="第12章-权力和暴力">第12章 权力和暴力</h2>
<h3 id="权力和相互依赖">权力和相互依赖</h3>
<h4 id="权力的来源">权力的来源</h4>
<h4 id="资源的类型">资源的类型</h4>
<h4 id="男女两性和资源的控制">男女两性和资源的控制</h4>
<h4 id="权力的过程">权力的过程</h4>
<h4 id="权力的结果">权力的结果</h4>
<h4 id="权力的两面性">权力的两面性</h4>
<h3 id="亲密关系中的暴力">亲密关系中的暴力</h3>
<h4 id="暴力的普遍性">暴力的普遍性</h4>
<h4 id="伴侣暴力的种类">伴侣暴力的种类</h4>
<h4 id="亲密关系暴力中的性别差异">亲密关系暴力中的性别差异</h4>
<h4 id="暴力的相关因素">暴力的相关因素</h4>
<h4 id="暴力的基本原理">暴力的基本原理</h4>
<h4 id="受害者不离开的原因">受害者不离开的原因</h4>
<h3 id="请你思考-11">请你思考</h3>
<h2 id="第13章-亲密关系的解体与消亡">第13章 亲密关系的解体与消亡</h2>
<h3 id="离婚率的变化">离婚率的变化</h3>
<h4 id="离婚的普遍性">离婚的普遍性</h4>
<h4 id="离婚率增加的原因">离婚率增加的原因</h4>
<h3 id="离婚的征兆">离婚的征兆</h3>
<h4 id="障碍模型">障碍模型</h4>
<h4 id="脆弱应激适应模型">脆弱—应激—适应模型</h4>
<h4 id="亲密关系适应过程pair项目结果">亲密关系适应过程（PAIR）项目结果</h4>
<h4 id="婚姻早期岁月eym项目结果">婚姻早期岁月（EYM）项目结果</h4>
<h4 id="婚姻问题的个体知觉">婚姻问题的个体知觉</h4>
<h4 id="特定的离婚信号">特定的离婚信号</h4>
<h3 id="分手">分手</h3>
<h4 id="与婚前伴侣的分手">与婚前伴侣的分手</h4>
<h4 id="离婚的步骤">离婚的步骤</h4>
<h3 id="分手的后果">分手的后果</h3>
<h4 id="解体后的关系">解体后的关系</h4>
<h4 id="克服消极情绪">克服消极情绪</h4>
<h4 id="离婚不同于恋人分手">离婚不同于恋人分手</h4>
<h4 id="父母离异的孩子">父母离异的孩子</h4>
<h3 id="请你思考-12">请你思考</h3>
<h2 id="第14章-亲密关系的维持和修复">第14章 亲密关系的维持和修复</h2>
<h3 id="亲密关系的维持和提升">亲密关系的维持和提升</h3>
<h4 id="保持忠诚">保持忠诚</h4>
<h4 id="保持满足">保持满足</h4>
<h3 id="修复关系">修复关系</h3>
<h4 id="自我实践">自我实践</h4>
<h4 id="预防性维持">预防性维持</h4>
<h4 id="婚姻治疗">婚姻治疗</h4>
<h3 id="结语">结语</h3>
<h3 id="请你思考-13">请你思考</h3>
]]></content>
      <categories>
        <category>book.directory</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 远程连接</title>
    <url>/2022/10/21/Kits/win/win-RomoteConnection/</url>
    <content><![CDATA[<h1 id="远程连接">远程连接</h1>
<h2 id="说明">说明</h2>
<ul>
<li>这里的远程连接指的是 windows 自带的远程连接功能
<ul>
<li>直接在 windows 的搜索栏搜索远程连接就能找到</li>
</ul></li>
</ul>
<p><img src="/2022/10/21/Kits/win/win-RomoteConnection/search.png"></p>
<p><img src="/2022/10/21/Kits/win/win-RomoteConnection/settings.png"></p>
<h2 id="被连接">被连接</h2>
<ul>
<li>需要 <strong>windows 专业版</strong></li>
<li>设置中打开即可</li>
</ul>
<p><img src="/2022/10/21/Kits/win/win-RomoteConnection/open-function.png"></p>
<h2 id="连接不上">连接不上</h2>
<h3 id="情况1">情况1</h3>
<ul>
<li>被连接端是使用微软账号的</li>
<li>解决方案
<ul>
<li>被连接端使用微软账号登陆一次（注意不是
PIN，而是使用微软账号+密码）</li>
<li>连接端连接配置：微软账号+密码（注意不是昵称，而是账号）</li>
</ul></li>
</ul>
<h2 id="没有声音">没有声音</h2>
<ul>
<li>首先在连接的时候可以配置
<ul>
<li>显示选项 <span class="math inline">\(\to\)</span> 本地资源 <span class="math inline">\(\to\)</span> 远程音频 <span class="math inline">\(\to\)</span> 设置 <span class="math inline">\(\to\)</span> 在此计算机上播放</li>
</ul></li>
</ul>
<p><img src="/2022/10/21/Kits/win/win-RomoteConnection/settings.png"></p>
<ul>
<li>我遇到的问题：在远程调节音量大小的时候有噔噔噔的声音，但是播放音视频没有声音</li>
<li>解决方案
<ul>
<li>重启 Windows Audio 服务即可
<ul>
<li>搜索栏搜索<strong>计算机管理</strong>，找到重启</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/10/21/Kits/win/win-RomoteConnection/windows-audio.png"></p>
]]></content>
      <categories>
        <category>win</category>
      </categories>
      <tags>
        <tag>Kits</tag>
        <tag>win</tag>
      </tags>
  </entry>
  <entry>
    <title>必应有趣的壁纸</title>
    <url>/2021/11/18/images/bing/01/</url>
    <content><![CDATA[<h1 id="壁纸">壁纸</h1>
<ul>
<li>潘塔纳尔湿地的风信子金刚鹦鹉，巴西
<ul>
<li>© David Pattyn/Minden Pictures</li>
</ul></li>
</ul>
<p><img src="https://cn.bing.com/th?id=OHR.HyacinthMacaws_ZH-CN1191345036_1920x1080.jpg"></p>
<ul>
<li>圣诞主题的海滩小屋，英国伯恩茅斯
<ul>
<li>© Allouphoto/Alamy</li>
</ul></li>
</ul>
<p><img src="https://cn.bing.com/th?id=OHR.XmasBeachHuts_ZH-CN6195800613_1920x1080.jpg"></p>
<ul>
<li>育空地区的落基山羊，加拿大
<ul>
<li>© Mark Newman/Getty Images</li>
</ul></li>
</ul>
<p><img src="https://cn.bing.com//th?id=OHR.OreamnosAmericanus_ZH-CN6731612431_1920x1080.jpg"></p>
<ul>
<li>海岸旁的二见浦夫妇岩，日本三重县
<ul>
<li>© Marco Gaiotti/plainpicture</li>
</ul></li>
</ul>
<p><img src="https://cn.bing.com/th?id=OHR.MeotoIwa_ZH-CN3126370410_1920x1080.jpg"></p>
<ul>
<li>雷暴下的大峡谷国家公园，亚利桑那州
<ul>
<li>© spkeelin/Getty Images</li>
</ul></li>
</ul>
<p><img src="https://s.cn.bing.net/th?id=OHR.GCThunderstorm_ZH-CN7535350453_1920x1080.jpg"></p>
<ul>
<li>鸳鸯妈妈和小鸳鸯们，韩国
<ul>
<li>© VDCM image/Getty Images</li>
</ul></li>
</ul>
<p><img src="https://s.cn.bing.net/th?id=OHR.DuckHen_ZH-CN6493617016_1920x1080.jpg"></p>
<ul>
<li>一只马赛长颈鹿，肯尼亚马赛马拉国家保护区
<ul>
<li>© Andy Rouse/Minden Pictures</li>
</ul></li>
</ul>
<p><img src="https://s.cn.bing.net/th?id=OHR.MaasaiGiraffe_ZH-CN2960157829_1920x1080.jpg"></p>
]]></content>
      <categories>
        <category>images</category>
      </categories>
      <tags>
        <tag>images</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 知识点.01</title>
    <url>/2021/11/06/cpp/Kits/00/</url>
    <content><![CDATA[<h1 id="c-知识点">C++ 知识点</h1>
<h2 id="const-作用">const 作用</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示这个函数不会修改成员变量的值</span></span><br><span class="line"><span class="function">vec3 <span class="title">get_direction</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="智能指针">智能指针</h2>
<ul>
<li>智能指针：<code>shared_ptr</code>
<ul>
<li>自动释放内存</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">double</span>&gt; double_ptr = <span class="built_in">make_shared</span>&lt;<span class="type">double</span>&gt;(<span class="number">0.37</span>);</span><br><span class="line">shared_ptr&lt;vec3&gt;   vec3_ptr   = <span class="built_in">make_shared</span>&lt;vec3&gt;(<span class="number">1.414214</span>, <span class="number">2.718281</span>, <span class="number">1.618034</span>);</span><br><span class="line">shared_ptr&lt;sphere&gt; sphere_ptr = <span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="auto">auto</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> double_ptr = <span class="built_in">make_shared</span>&lt;<span class="type">double</span>&gt;(<span class="number">0.37</span>);</span><br></pre></td></tr></table></figure>
<h2 id="随机数">随机数</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;cstdlib&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个随机数 [0, 1)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="type">static</span> std::mt19937 generator;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">distribution</span>(generator);</span><br><span class="line">    <span class="comment">// return rand() / (RAND_MAX + 1.0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cmake">cmake</h2>
<ul>
<li>https://www.hahack.com/codes/cmake/<a href="https://www.hahack.com/codes/cmake/"></a></li>
</ul>
<h2 id="static">static</h2>
<ul>
<li>类的 static 成员函数
<ul>
<li>在另外文件中实现的时候不需要添加 <code>static</code>
<ul>
<li>如果类外定义函数时在函数名前加了
<code>static</code>，因为作用域的限制，就只能在当前文件里用</li>
<li>产生歧义</li>
</ul></li>
</ul></li>
</ul>
<h2 id="inline-static">inline + static</h2>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vec3.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vec3</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> vec3 <span class="title">random_in_unit_sphere</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vec3.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.hpp&quot;</span></span></span><br><span class="line"><span class="function">vec3 <span class="title">vec3::random_in_unit_sphere</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">vec3</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vec3 v;</span><br><span class="line">    v.<span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改">修改</h3>
<ul>
<li>修改 <code>vec3.cpp</code> 和 <code>vec3.hpp</code>
的声明和定义</li>
<li>错误1</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">In file included from main.cpp:3:</span><br><span class="line">vec3.hpp:5:18: warning: inline function ‘vec3 vec3::random_in_unit_sphere()’ used but never defined</span><br><span class="line">    5 |     inline  vec3 random_in_unit_sphere();</span><br><span class="line">      |                  ^~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">/usr/bin/ld: /tmp/cceorNNS.o: in function `main&#x27;:</span><br><span class="line">main.cpp:(.text+0x23): undefined reference to `vec3::random_in_unit_sphere()&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<ul>
<li>错误2</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: /tmp/cceorNNS.o: in function `main&#x27;:</span><br><span class="line">main.cpp:(.text+0x23): undefined reference to `vec3::random_in_unit_sphere()&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">vec3.hpp</th>
<th style="text-align: center;">vec3.cpp</th>
<th style="text-align: center;">result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">static</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">OK</td>
</tr>
<tr class="even">
<td style="text-align: center;">inline static</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">错误 1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">static</td>
<td style="text-align: center;">inline</td>
<td style="text-align: center;">错误 2</td>
</tr>
<tr class="even">
<td style="text-align: center;">inline static</td>
<td style="text-align: center;">inline</td>
<td style="text-align: center;">错误 1</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">OK</td>
</tr>
<tr class="even">
<td style="text-align: center;">inline</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">错误 1</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">inline</td>
<td style="text-align: center;">错误 2</td>
</tr>
<tr class="even">
<td style="text-align: center;">inline</td>
<td style="text-align: center;">inline</td>
<td style="text-align: center;">错误 1</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>inline 函数一般在头文件中声明并定义</strong></li>
</ul>
<h2 id="默认参数">默认参数</h2>
<ul>
<li>函数<strong>默认参数</strong>在<strong>声明</strong>的时候给定</li>
</ul>
<h2 id="虚函数">虚函数</h2>
<ul>
<li>派生类如果没有实现基函数的 <code>virtual</code>
函数，则多态时会调用基类的 <code>virtual</code> 函数</li>
<li><a href="/utils/show_code/index.html?cpp/2021/test_virtual.cpp">代码</a></li>
</ul>
]]></content>
      <categories>
        <category>C++.Kits</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.00.说明</title>
    <url>/2021/09/22/computation/pyr/00/</url>
    <content><![CDATA[<h1 id="计算方法b">计算方法B</h1>
<h2 id="说明">说明</h2>
<ul>
<li>课程名称：计算方法B</li>
<li>授课老师：裴玉茹</li>
<li>教材
<ul>
<li><a href="https://www.vitalsource.com/en-au/products/numerical-analysis-richard-l-burden-v9781305465350">Numerical
Analysis, Richard L. Burden, Cengage.</a></li>
<li><a href="https://book.douban.com/subject/26600495/">数值分析</a></li>
</ul></li>
</ul>
<h2 id="课程说明">课程说明</h2>
<h3 id="计算方法定义">计算方法定义</h3>
<ul>
<li>广义
<ul>
<li>一切用于数学问题的数值求解方法</li>
<li>算法algorithm</li>
</ul></li>
<li>狭义
<ul>
<li>数学问题在<strong>计算机上的近似数值求解</strong></li>
</ul></li>
</ul>
<h3 id="近代计算方法发展">近代计算方法发展</h3>
<ul>
<li>The Monte Carlo method (1946)</li>
<li>The simplex method for linear programming (1947)</li>
<li>Krylov subspace iteration methods (1950)</li>
<li>The decompositional approach to matrix computations (1951)</li>
<li>FORTRAN optimizing compiler (1957)</li>
<li>The QR algorithm (1959-61)</li>
<li>Quicksort (1962)</li>
<li>The fast Fourier transform (1965)</li>
<li>The integer relation detection algorithm (1977)</li>
<li>The fast multiple algorithm (1987)</li>
</ul>
<h3 id="课程内容">课程内容</h3>
<ul>
<li>非线性方程求解、迭代方法、特征值、插值与多项式近似、微分与积分、常微分方程、偏微分方程</li>
<li>精确解 <span class="math inline">\(\to\)</span> 近似解</li>
<li>数值求解 <span class="math inline">\(\to\)</span> 近似求解</li>
</ul>
<p><img src="/2021/09/22/computation/pyr/00/image-20210925165932443.png"></p>
<h3 id="数值计算实例">数值计算实例</h3>
<ul>
<li>非刚性变形</li>
<li>相似度</li>
<li>图像配准</li>
<li>三维重建</li>
<li>单视点三维重建</li>
<li>造型：曲线与曲面、多项式插值与近似</li>
<li>Forward Kinematics problem：正向运动学问题</li>
<li>Euler–Bernoulli model：欧拉-伯努利模型</li>
<li>GPS：全球定位系统</li>
<li>数控机床</li>
<li>桥梁</li>
<li>散热片</li>
</ul>
]]></content>
      <categories>
        <category>0</category>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.02.非线性方程迭代求解(2)</title>
    <url>/2021/10/02/computation/pyr/02-1/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 1 章（求解方程） + PPT（非线性方程迭代求解）</li>
</ul>
<h1 id="计算方法b">计算方法B</h1>
<h2 id="牛顿法">4. 牛顿法</h2>
<ul>
<li>牛顿——拉夫逊方法</li>
<li>给定初始估计 <span class="math inline">\(x_0\)</span>，画出函数
<span class="math inline">\(f\)</span> 在 <span class="math inline">\(x_0\)</span> 的切线，用切线来近似函数 <span class="math inline">\(f\)</span>，求出其与 <span class="math inline">\(x\)</span> 轴的交点作为 <span class="math inline">\(f\)</span> 的根</li>
</ul>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210927142236037.jpg" style="zoom:67%;"></p>
<ul>
<li><strong>算法流程</strong></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\begin{array}{c}
x_0=初始估计\\
x_{i+1}=x_{i}-\dfrac{f(x_i)}{f&#39;(x_i)}\\
\end{array}
\end{aligned}
\]</span></p>
<ul>
<li>推导
<ul>
<li>切线：<span class="math inline">\(y=f&#39;(x_i)(x-x_i)+f(x_i)\)</span></li>
<li>令 <span class="math inline">\(y=0\)</span> 即可</li>
</ul></li>
</ul>
<h3 id="二次收敛">二次收敛</h3>
<p><span class="math display">\[
M=\lim_{i\to\infty}\dfrac{e_{i+1}}{e^2_{i}}&lt;\infty
\]</span></p>
<ul>
<li><span id="newton"><strong>牛顿方法是二次收敛的</strong></span>
<ul>
<li>令 <span class="math inline">\(f\)</span> 是二阶连续可微函数，<span class="math inline">\(f(r)=0\)</span>，如果 <span class="math inline">\(f&#39;(r)\ne0\)</span>，则牛顿方法局部收敛到 <span class="math inline">\(r\)</span></li>
<li>第 <span class="math inline">\(i\)</span> 步的误差 <span class="math inline">\(e_i\)</span> 满足如下式子</li>
</ul></li>
</ul>
<p><span class="math display">\[
\lim_{i\to\infty}\dfrac{e_{i+1}}{e^2_{i}}=M=\dfrac{f&#39;&#39;(r)}{2f&#39;(r)}
\]</span></p>
<ul>
<li><strong>证明</strong>
<ul>
<li><strong>局部收敛</strong>：FPI 的特殊情况，可以计算得到 <span class="math inline">\(g&#39;(r)=0&lt;1\)</span></li>
<li><strong>二次收敛</strong>：<strong>泰勒展开</strong>，要求 <span class="math inline">\(f&#39;(r)\ne0\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\begin{array}{c}
0=f(r)=f(x_i)+(r-x_i)f&#39;(x_i)+\dfrac{(r-x_i)^2}{2}f&#39;&#39;(c)\\
x_{i}-\dfrac{f(x_i)}{f&#39;(x_i)}-r=\dfrac{(r-x_i)^2}{2f&#39;(x_i)}f&#39;&#39;(c)\\
e_{i+1}=\dfrac{e_i^2}{2f&#39;(x_i)}f&#39;&#39;(c)\\
\dfrac{e_{i+1}}{e^2_{i}}=\dfrac{f&#39;&#39;(c)}{2f&#39;(x_i)}\\
c\ 和\ x_i\ 都会收敛到\
r\Rightarrow\lim_{i\to\infty}\dfrac{e_{i+1}}{e^2_{i}}=\dfrac{f&#39;&#39;(r)}{2f&#39;(r)}\\
\end{array}
\end{aligned}
\]</span></p>
<ul>
<li>误差公式近似为 <span class="math inline">\(e_{i+1}\approx
Me^2_{i}\)</span></li>
</ul>
<h3 id="重根">重根</h3>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210928114840328.jpg" style="zoom:67%;"></p>
<ul>
<li>如果不满足 <span class="math inline">\(f&#39;(r)\ne0\)</span>，则收敛速度变为线性
<ul>
<li>例子：<span class="math inline">\(f(x)=x^{m}\)</span> 求根</li>
<li>牛顿公式：<span class="math inline">\(x_{i+1}=x_i-\dfrac{x^{m}_i}{mx^{m-1}_i}=\dfrac{m-1}{m}x_{i}\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210927153913039.jpg" style="zoom: 67%;"></p>
<h4 id="修正方法1">修正方法1</h4>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210927154343927.jpg" style="zoom:67%;"></p>
<h4 id="修正方法2">修正方法2</h4>
<p><span class="math display">\[
\mu(x)=\dfrac{f(x)}{f&#39;(x)}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\mu(x)=&amp;\dfrac{(x-p)^mq(x)}{m(x-p)^{m-1}q(x)+(x-p)^mq&#39;(x)}\\
=&amp;{\color{red}(x-p)}\dfrac{q(x)}{mq(x)+(x-p)q&#39;(x)}\\
\end{aligned}
\]</span></p>
<ul>
<li>发现 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(\mu\)</span> 的单根</li>
</ul>
<p><span class="math display">\[
\dfrac{q(p)}{mq(p)+(p-p)q&#39;(x)}=\dfrac{1}{m}\ne0
\]</span></p>
<ul>
<li>关于 <span class="math inline">\(\mu\)</span> 应用牛顿方法</li>
</ul>
<p><span class="math display">\[
g(x)=x-\dfrac{f(x)f&#39;(x)}{[f&#39;(x)]^2-f(x)f&#39;&#39;(x)}
\]</span></p>
<ul>
<li>在单根的情况下，修正牛顿方法和原始牛顿方法的收敛速度都快，但是需要更大的计算量</li>
</ul>
<h3 id="牛顿方法失效">牛顿方法失效</h3>
<ul>
<li>例子</li>
</ul>
<p><span class="math display">\[
f(x)=4x^4-6x^2-\dfrac{11}{4},x_0=\dfrac{1}{2}
\]</span></p>
<ul>
<li>只有在根近邻的初始估计才能收敛到根</li>
</ul>
<h2 id="不需要导数的根求解">5. 不需要导数的根求解</h2>
<ul>
<li>导数需要除以一个较小的值，这样可能会引入误差</li>
</ul>
<h3 id="割线方法">割线方法</h3>
<ul>
<li>使用差商来代替导数</li>
</ul>
<p><span class="math display">\[
\dfrac{f(x_i)-f(x_{i-1})}{x_i-x_{i-1}}
\]</span></p>
<p><span class="math display">\[
f&#39;(x_{i-1})=\lim_{x_{i}\to{x_{i-1}}}\dfrac{f(x_i)-f(x_{i-1})}{x_i-x_{i-1}}
\]</span></p>
<ul>
<li>算法流程</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\begin{array}{c}
x_0,x_1=初始估计\\
x_{i+1}=x_{i}-\dfrac{f(x_i)(x_i-x_{i-1})}{f(x_i)-f(x_{i-1})}\\
\end{array}
\end{aligned}
\]</span></p>
<ul>
<li>误差分析
<ul>
<li>第一个式子可以通过割线方法的递推式推导得到（右边通分，构造出 3
个误差项）</li>
<li>第二个式子将一般形式 <span class="math inline">\(e_{i+1}=Ce_{i}^k\)</span>
代入第一个式子解出来即可</li>
</ul></li>
</ul>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210927160440330.jpg" style="zoom:67%;"></p>
<ul>
<li><strong>超线性收敛</strong></li>
</ul>
<h3 id="割线方法的推广形式">割线方法的推广形式</h3>
<h4 id="试位方法">试位方法</h4>
<ul>
<li>Regula Falsi 方法</li>
<li>与<strong>二分法</strong>相似，但是其中的中点被割线和 <span class="math inline">\(x\)</span> 轴的交点代替</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\begin{array}{rl}
割线:&amp;y=\dfrac{f(a)-f(b)}{a-b}(x-a)+f(a)\\
令\ y=0:&amp;x=\dfrac{bf(a)-af(b)}{f(a)-f(b)}
\end{array}
\end{aligned}
\]</span></p>
<ul>
<li>算法流程</li>
</ul>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210927161920043.jpg" style="zoom:67%;"></p>
<ul>
<li>试位方法可能在某些例子中收敛的更慢</li>
<li><strong>不保证收敛</strong></li>
</ul>
<h4 id="muller-方法">Muller 方法</h4>
<ul>
<li>通过之前计算的 3 个点（<span class="math inline">\(x_0,x_1,x_2\)</span>），画出他们的抛物线 <span class="math inline">\(y=p(x)\)</span>，求出和 <span class="math inline">\(x\)</span> 轴的交点，作为接下来对 <span class="math inline">\(x\)</span> 的近似估计
<ul>
<li>如果有 2 个交点，选择离 <span class="math inline">\(x_2\)</span>
较近的点</li>
<li>如果有 0 个交点，出现复数解</li>
</ul></li>
</ul>
<h4 id="逆二次插值-iqi">逆二次插值 IQI</h4>
<ul>
<li>和 Muller 方法相同，但是使用的抛物线是 <span class="math inline">\(x=p(y)\)</span>，保证和 <span class="math inline">\(x\)</span> 轴只有一个交点</li>
</ul>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210927164249863.jpg" style="zoom:67%;"></p>
<ul>
<li>拉格朗日插值的一个例子</li>
<li>迭代更新的两种方法
<ul>
<li><span class="math inline">\(x_i,x_{i-1},x_{i-2}\)</span> 更新为
<span class="math inline">\(x_{i+1},x_i,x_{i-1}\)</span></li>
<li><span class="math inline">\(x_i,x_{i-1},x_{i-2}\)</span>
中去掉后向误差最大的那个，然后加上 <span class="math inline">\(x_{i+1}\)</span></li>
</ul></li>
<li>Muller 方法和逆二次插值 IQI
比割线方法收敛更快（<strong>更高阶的插值计算</strong>）</li>
</ul>
<h3 id="brent-方法">Brent 方法</h3>
<ul>
<li>混合迭代技术</li>
<li>兼具：二分法的保证收敛性质、更加复杂方法的快速收敛性质</li>
<li>Dekker 和 Van Wijingaarden 提出（20 世纪 60 年代）</li>
</ul>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210927165124959.jpg" style="zoom:67%;"></p>
<h2 id="ppt-补充">6. PPT 补充</h2>
<h3 id="不动点存在且唯一">不动点存在且唯一</h3>
<ul>
<li><strong>不是充要条件</strong></li>
<li>如果满足如下两个条件，则<strong>不动点存在且唯一</strong></li>
</ul>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210927171646046.jpg" style="zoom:67%;"></p>
<ul>
<li>条件：<strong>自身映射</strong>、<strong>连续</strong>、<strong>导数小于1</strong></li>
<li>证明
<ul>
<li>存在性：设函数 <span class="math inline">\(h(x)=g(x)-x=0\)</span>，要么端点成立，要么由介值定理存在一个数使其成立</li>
<li>唯一性：假设存在两个 <span class="math inline">\(p,q\)</span>，推出矛盾</li>
</ul></li>
</ul>
<p><span class="math display">\[
\vert{p-q}\vert=\vert{g(p)-g(q)}\vert=g&#39;(\xi)\vert{p-q}\vert&lt;\vert{p-q}\vert
\]</span></p>
<h3 id="不动点迭代收敛">不动点迭代收敛</h3>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210927172949309.jpg" style="zoom:67%;"></p>
<ul>
<li>条件：<strong>自身映射</strong>、<strong>连续</strong>、<strong>导数小于1</strong></li>
<li>证明：<strong>中值定理</strong></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\begin{array}{c}
\vert{p_{n}-p}\vert=\vert{g(p_{n-1})-g(p)}\vert=\vert{g&#39;(\xi)}\vert\vert{p_{n-1}-p}\vert\\
\vert{p_{n}-p}\vert\le k\vert{p_{n-1}-p}\vert\le\cdots\le
k^{n}\vert{p_0-p}\vert\\
\lim_{n\to\infty}\vert{p_{n}-p}\vert=\lim_{n\to\infty}k^n\vert{p_{0}-p}\vert=0\\
\end{array}
\end{aligned}
\]</span></p>
<h4 id="推论">推论</h4>
<ul>
<li>如果函数 <span class="math inline">\(g\)</span> 满足不动点定理,
则利用 <span class="math inline">\(p_n\)</span> 近似 <span class="math inline">\(p\)</span> 的误差界如下</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\begin{array}{c}
\vert{p_{n}-p}\vert\le k^{n}\max\{p_0-a,b-p_0\}\\
\vert{p_{n}-p}\vert\le \dfrac{k^{n}}{1-k}\vert{p_1-p_0}\vert\\
\end{array}
\end{aligned}
\]</span></p>
<ul>
<li>第一个式子显然</li>
<li>第二个式子</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\begin{array}{c}
\vert{p_{n+1}-p_{n}}\vert=\vert{g(p_{n})-g(p_{n-1})}\vert=\vert{g&#39;(\xi)}\vert\vert{p_{n}-p_{n-1}}\vert\le
k\vert{p_{n}-p_{n-1}}\vert\\
\vert{p_{n+1}-p_{n}}\vert\le k\vert{p_{n}-p_{n-1}}\vert\le\cdots\le
k^{n}\vert{p_1-p_0}\vert\\
\end{array}
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\begin{array}{rl}
\vert{p_{m}-p_{n}}\vert&amp;=\vert{p_{m}-p_{m-1}+p_{m-1}-\cdots-p_{n}}\vert\\
&amp;\le\vert{p_{m}-p_{m-1}}\vert+\vert{p_{m-1}-p_{m-2}}\vert\cdots\vert{p_{n+1}-p_{n}}\vert\\
&amp;=\vert{p_1-p_0}\vert(k^{m-1}+k^{m-2}+\cdots+k^{n})\\
&amp;=\vert{p_1-p_0}\vert k^{n}(k^{m-n-1}+\cdots+1)\\
\end{array}
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\begin{array}{rl}
\vert{p-p_{n}}\vert&amp;=\lim_{m\to\infty}\vert{p_m-p_n}\vert\\
&amp;\le\lim_{m\to\infty}\vert{p_1-p_0}\vert k^{n}(k^{m-n-1}+\cdots+1)\\
&amp;=\vert{p_1-p_0}\vert k^{n}\sum_{i=0}^{\infty}{k^i}\\
&amp;=\dfrac{k^{n}}{1-k}\vert{p_1-p_0}\vert\\
\end{array}
\end{aligned}
\]</span></p>
<h3 id="牛顿法-1">牛顿法</h3>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210928094753843.jpg" style="zoom:67%;"></p>
<ul>
<li>证明方法
<ul>
<li>自身映射，导数小于 1（连续）</li>
</ul></li>
<li>在满足假设条件的情况下，只要选择足够精确的初始近似，牛顿法就会收敛</li>
<li>缺点：需要知道 <span class="math inline">\(f\)</span>
在每个近似点的导数</li>
</ul>
<h3 id="迭代方法的误差">迭代方法的误差</h3>
<ul>
<li><strong>收敛速度</strong></li>
</ul>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210928105824087.jpg" style="zoom:67%;"></p>
<ul>
<li>总结</li>
</ul>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210928110000710.jpg" style="zoom:67%;"></p>
<h3 id="线性收敛">线性收敛</h3>
<ul>
<li>自身映射、连续、导数小于1</li>
</ul>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210928111249471.jpg" style="zoom:67%;"></p>
<h3 id="二阶收敛">二阶收敛</h3>
<ul>
<li>证明方法就是上面的牛顿方法<a href="#newton">证明</a></li>
</ul>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210928111530871.jpg" style="zoom:67%;"></p>
<ul>
<li>在有限的迭代后，二阶收敛所能达到的有效数字的位数<strong>远大于</strong>线性收敛所能达到的有效数字的位数</li>
<li>构造二阶收敛</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\begin{array}{cr}
g(x)=x-\phi(x)f(x)&amp;\\
0=g&#39;(p)=1-\phi&#39;(p)f(p)-\phi(p)f&#39;(p)=1-\phi(p)f&#39;(p),&amp;f(p)=0\\
\phi(x)=\dfrac{1}{f&#39;(x)}&amp;\\
p_{n+1}=p_{n}-\dfrac{f(p_{n})}{f&#39;(p_{n})}
\end{array}
\end{aligned}
\]</span></p>
<h3 id="高阶收敛">高阶收敛</h3>
<ul>
<li><strong>形式上看和泰勒展开一致</strong></li>
</ul>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210928112838271.jpg" style="zoom:67%;"></p>
<h3 id="加速收敛">加速收敛</h3>
<ul>
<li><span class="math inline">\(\mathrm{Aitken&#39;s}\
\Delta^2\)</span>方法</li>
<li>加速任何线性收敛的序列
<ul>
<li>引入了更多的计算达到<strong>超线性收敛</strong></li>
<li>每次根据之前的 3 个估计进行加速</li>
</ul></li>
</ul>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210928135724178.jpg" style="zoom:67%;"></p>
<ul>
<li><span class="math inline">\(n\)</span> 足够大的时候</li>
</ul>
<p><span class="math display">\[
\dfrac{p_{n+1}-p}{p_n-p}\approx\dfrac{p_{n+2}-p}{p_{n+1}-p}
\]</span></p>
<p><span class="math display">\[
p\approx
\dfrac{p_{n}p_{n+2}-p_{n+1}^2}{p_n-2p_{n+1}+p_{n+2}}=p_n-\dfrac{(p_{n+1}-p_{n})^2}{p_n-2p_{n+1}+p_{n+2}}
\]</span></p>
<p><span class="math display">\[
\hat{p}=p_n-\dfrac{(p_{n+1}-p_{n})^2}{p_n-2p_{n+1}+p_{n+2}}
\]</span></p>
<ul>
<li>考虑前向差分公式</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\begin{array}{c}
\Delta{p_i}=p_{i+1}-p_{i}\\
\Delta^k{p_i}=\Delta^{k-1}(\Delta{p_i})=\Delta^{k-1}{p_{i+1}}-\Delta^{k-1}{p_{i}}\\
\hat{p}=p_n-\dfrac{(\Delta{p_{n}})^2}{\Delta^2{p_{n}}}
\end{array}
\end{aligned}
\]</span></p>
<ul>
<li>每 3 个估计值更新一次
<ul>
<li><strong>超线性收敛</strong></li>
</ul></li>
</ul>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210928141816384.jpg" style="zoom:67%;"></p>
<ul>
<li>更新之后的值马上用来计算
<ul>
<li><strong>二阶收敛</strong></li>
</ul></li>
</ul>
<p><img src="/2021/10/02/computation/pyr/02-1/image-20210928142125048.jpg" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.02.非线性方程迭代求解</title>
    <url>/2021/09/26/computation/pyr/02/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 1 章（求解方程） + PPT（非线性方程迭代求解）</li>
</ul>
<h1 id="非线性方程迭代求解">非线性方程迭代求解</h1>
<ul>
<li>求解方程</li>
</ul>
<h2 id="二分法">1. 二分法</h2>
<ul>
<li>原理</li>
</ul>
<p><img src="/2021/09/26/computation/pyr/02/image-20210926170010282.jpg" style="zoom:67%;"></p>
<ul>
<li>算法流程</li>
</ul>
<p><img src="/2021/09/26/computation/pyr/02/image-20210926170146479.jpg" style="zoom: 67%;"></p>
<h3 id="速度与准确性">速度与准确性</h3>
<ul>
<li>初始区间 <span class="math inline">\([a,b]\)</span></li>
<li>最终选择区间的中点作为近似解</li>
<li><span class="math inline">\(n\)</span> 步二分法之后
<ul>
<li>求解误差 <span class="math inline">\(=\vert{x_c-r}\vert\le\dfrac{b-a}{2^{n+1}}\)</span>
<ul>
<li><strong>绝对误差界</strong></li>
</ul></li>
<li>函数计算次数：<span class="math inline">\(n+2\)</span></li>
</ul></li>
<li>和有效数字类似的定义
<ul>
<li><strong>定义</strong>：如果误差小于 <span class="math inline">\(0.5\times10^{-p}\)</span>，阶精确到小数点后 <span class="math inline">\(p\)</span> 位</li>
</ul></li>
</ul>
<h3 id="终止条件">终止条件</h3>
<ul>
<li>绝对误差小于容差</li>
<li>相对误差小于容差</li>
<li>后向误差小于容差</li>
</ul>
<h3 id="实际计算的问题">实际计算的问题</h3>
<h4 id="避免向上溢出">避免向上溢出</h4>
<ul>
<li>使用 <span class="math inline">\(p_{n}=a_n+\dfrac{b_n-a_n}{2}\)</span> 来代替 <span class="math inline">\(p_n=\dfrac{b_n+a_n}{2}\)</span></li>
</ul>
<h4 id="避免乘法运算">避免乘法运算</h4>
<ul>
<li>使用符号函数 <span class="math inline">\(\mathrm{sgn}\)</span></li>
<li>使用 <span class="math inline">\(\mathrm{sgn}(f(a_n))\cdot\mathrm{sgn}(f(p_n))&lt;0\)</span>
代替 <span class="math inline">\(f(a_n)\cdot f(b_n)&lt;0\)</span></li>
</ul>
<h2 id="不动点迭代">2. 不动点迭代</h2>
<ul>
<li>FPI：Fixed Point Iteration</li>
<li><strong>定义</strong>：当 <span class="math inline">\(g(r)=r\)</span>，实数 <span class="math inline">\(r\)</span> 是函数 <span class="math inline">\(g\)</span> 的不动点</li>
<li><span class="math inline">\(g(x)\)</span> 的不动点，同时也是 <span class="math inline">\(x=f(x)\)</span> 的解</li>
<li>不动点迭代：<span class="math inline">\(g(x)\)</span>
<ul>
<li><span class="math inline">\(x_0\)</span> = 初始估计</li>
<li><span class="math inline">\(x_{i+1}=g(x_i)\)</span></li>
</ul></li>
<li>无穷多步迭代之后，序列 <span class="math inline">\(\{x_i\}\)</span>
可能收敛，也可能发散</li>
<li>如果函数 <span class="math inline">\(g\)</span> 连续，而且 <span class="math inline">\(\{x_i\}\)</span> 收敛到 <span class="math inline">\(r\)</span>，则 <span class="math inline">\(r\)</span> 是函数 <span class="math inline">\(g\)</span> 对应的不动点</li>
</ul>
<p><span class="math display">\[
g(r)=g(\lim_{i\to\infty}{x_i})=\lim_{i\to\infty}g(x_i)=\lim_{i\to\infty}x_{i+1}=r
\]</span></p>
<h3 id="多种形式">多种形式</h3>
<ul>
<li><span class="math inline">\(x^3+x-1=0\)</span></li>
<li>可以使用如下的不动点迭代方式
<ul>
<li><span class="math inline">\(x=1-x^3=g_1(x)\)</span></li>
<li><span class="math inline">\(x=\sqrt[3]{1-x}=g_2(x)\)</span></li>
<li><span class="math inline">\(x=\dfrac{1+2x^3}{1+3x^2}=g_3(x)\)</span></li>
</ul></li>
<li>一些现象
<ul>
<li>起始点为 <span class="math inline">\(x_0=0.5\)</span> 时，<span class="math inline">\(g_1(x)\)</span> 未收敛，在 <span class="math inline">\(0,1\)</span> 两个数上跳跃</li>
<li>起始点为 <span class="math inline">\(x_0=0.5\)</span> 时，<span class="math inline">\(g_2(x)\)</span> 收敛了</li>
<li>起始点为 <span class="math inline">\(x_0=0.5\)</span> 时，<span class="math inline">\(g_3(x)\)</span> 收敛了，比 <span class="math inline">\(g_2(x)\)</span> 更快</li>
</ul></li>
<li><strong>cobweb 图</strong></li>
</ul>
<p><img src="/2021/09/26/computation/pyr/02/image-20210926201732414.jpg" style="zoom:67%;"></p>
<h3 id="线性收敛">线性收敛</h3>
<ul>
<li><strong>定义</strong>：令 <span class="math inline">\(e_i\)</span>
表示迭代过程中第 <span class="math inline">\(i\)</span>
步时的误差，如果有如下式子成立，该方法被称为满足<strong>线性收敛</strong>，收敛速度为
<span class="math inline">\(S\)</span></li>
</ul>
<p><span class="math display">\[
\lim_{i\to\infty}\dfrac{e_{i+1}}{e_{i}}=S
\]</span></p>
<h3 id="局部收敛">局部收敛</h3>
<ul>
<li><strong>定理</strong>
<ul>
<li>可导函数的导函数不存在第一类间断点，只可能存在第二类间断点</li>
</ul></li>
</ul>
<p><img src="/2021/09/26/computation/pyr/02/image-20210926204254017.jpg" style="zoom:67%;"></p>
<ul>
<li><strong>定义</strong>：如果一个迭代方法对于一个足够接近 <span class="math inline">\(r\)</span> 的初值能收敛到 <span class="math inline">\(r\)</span>，该迭代方法被称为<strong>局部收敛</strong>到
<span class="math inline">\(r\)</span>
<ul>
<li>如果存在近邻区间 <span class="math inline">\((r-\epsilon,r+\epsilon)\)</span>，其中 <span class="math inline">\(\epsilon&gt;0\)</span>，使得近邻区间种的所有初始估计都可以收敛到
<span class="math inline">\(r\)</span>，那么该方法局部收敛到 <span class="math inline">\(r\)</span></li>
<li>定理 1.6 的结论：当 <span class="math inline">\(\vert{g&#39;(r)}\vert&lt;1\)</span>
时不动点迭代局部收敛</li>
</ul></li>
<li>FPI 计算 <span class="math inline">\(\sqrt{2}\)</span></li>
</ul>
<p><span class="math display">\[
f(x)=\dfrac{x+\dfrac{2}{x}}{2}
\]</span></p>
<h3 id="终止条件-1">终止条件</h3>
<ul>
<li>无法通过<strong>初始值</strong>和<strong>迭代次数</strong>，预测达到给定<strong>容差</strong>所需要进行的<strong>步数</strong></li>
<li>绝对误差：<span class="math inline">\(\vert{x_{i+1}-x_{i}}\vert&lt;TOL\)</span></li>
<li>相对误差（要求解不在 0 附近）：<span class="math inline">\(\dfrac{\vert{x_{i+1}-x_{i}}\vert}{\vert{x_{i+1}}\vert}&lt;TOL\)</span></li>
<li>混合绝对/相对误差（可用于解在 0 附近）：<span class="math inline">\(\dfrac{\vert{x_{i+1}-x_{i}}\vert}{\max{(\vert{x_{i+1}}\vert},\theta)}\)</span></li>
<li>同时设置<strong>最大迭代步数</strong>，防止收敛失败</li>
</ul>
<h3 id="和二分法的对比">和二分法的对比</h3>
<ul>
<li>区别
<ul>
<li>二分法保证线性收敛</li>
<li>不动点迭代仅仅是局部收敛。当不动点迭代收敛时，其线性收敛</li>
</ul></li>
<li>相同
<ul>
<li>迭代的每一步都只需要进行一次函数求值</li>
</ul></li>
</ul>
<h2 id="精度的极限">3. 精度的极限</h2>
<ul>
<li>计算机的精度是有限的</li>
<li>二分法可能在中间的某一步停止，此时函数值可能不为
0，但是由于精度问题，计算计算出来的值未 0
<ul>
<li>这不是二分法的问题，而是计算机本身精度不够导致的</li>
</ul></li>
</ul>
<h3 id="前向误差与后向误差">前向误差与后向误差</h3>
<ul>
<li>假设 <span class="math inline">\(f\)</span> 是一个函数，<span class="math inline">\(r\)</span> 是一个根，即 <span class="math inline">\(f(r)=0\)</span>。假设 <span class="math inline">\(x_a\)</span> 时 <span class="math inline">\(r\)</span> 的近似值。对于根求解问题，近似 <span class="math inline">\(x_a\)</span> 的<strong>后向误差</strong>是 <span class="math inline">\(\vert{f(x_a)}\vert\)</span>，<strong>前向误差</strong>是
<span class="math inline">\(\vert{r-x_a}\vert\)</span></li>
<li>前向后向的解释</li>
</ul>
<p><img src="/2021/09/26/computation/pyr/02/image-20210926220533706.jpg" style="zoom:67%;"></p>
<ul>
<li><strong>重根</strong></li>
</ul>
<p><img src="/2021/09/26/computation/pyr/02/image-20210926220650895.jpg" style="zoom:67%;"></p>
<ul>
<li>在多根附近，函数变化十分缓慢，<strong>垂直方向的后向误差</strong>通常比<strong>水平方向的前向误差</strong>小得多</li>
</ul>
<h3 id="终止条件-2">终止条件</h3>
<ul>
<li>如何设定方程求解器的终止条件？
<ul>
<li><span class="math inline">\(\vert{x_a-r}\vert\)</span>
足够小（前向误差）</li>
<li><span class="math inline">\(\vert{f(x_a)}\vert\)</span>
足够小（后向误差）</li>
</ul></li>
<li>二分法两种误差都可观测
<ul>
<li>前向误差：可控，不会大于当前区间的一半</li>
<li>后向误差：可计算</li>
</ul></li>
<li>FPI：只能计算出后向误差</li>
<li>其他的终止条件：<strong>计算时间</strong></li>
</ul>
<h3 id="威尔金森多项式">威尔金森多项式</h3>
<ul>
<li>数值求解很难的单根例子</li>
</ul>
<p><span class="math display">\[
W(x)=(x-1)(x-2)\cdots(x-20)
\]</span></p>
<ul>
<li>展开后的形式很长 <span class="math inline">\(\dots\dots\)</span>
<ul>
<li>对展开的形式求根困难</li>
<li>求根过程中保存系数的很小误差会被放大，对结果产生很大影响</li>
</ul></li>
</ul>
<h3 id="根搜索的敏感性">根搜索的敏感性</h3>
<ul>
<li><strong>方程中小的求解误差造成求解根中的大误差</strong></li>
<li><strong>敏感性问题</strong>
<ul>
<li>在输入中是一个小误差，在这种情况下我们对问题进行求解，造成输出中的大问题</li>
</ul></li>
<li>通过<strong>误差放大因子</strong>和<strong>条件数</strong>定量描述</li>
<li>假定 <span class="math inline">\(f(x)=0\)</span> 的根为 <span class="math inline">\(x=r\)</span>，我们对输入做了一个小变化 <span class="math inline">\(\epsilon g(x)\)</span>（<span class="math inline">\(\epsilon\)</span> 可能很小），令 <span class="math inline">\(\Delta r\)</span>是对应根中的变化</li>
</ul>
<p><span class="math display">\[
f(r+\Delta r)+\epsilon g(r+\Delta r)=0
\]</span></p>
<ul>
<li>一阶泰勒展开</li>
</ul>
<p><span class="math display">\[
f(r)+(\Delta r)f&#39;(r)+\epsilon g(r)+\epsilon(\Delta
r)g&#39;(r)+O((\Delta r)^2)
\]</span></p>
<ul>
<li>忽略高阶项</li>
</ul>
<p><span class="math display">\[
(\Delta r)(\epsilon g&#39;(r)+f&#39;(r))\approx-f(r)-\epsilon
g(r)=-\epsilon g(r)
\]</span></p>
<ul>
<li>假定 <span class="math inline">\(\epsilon\)</span> 相对于 <span class="math inline">\(f&#39;(r)\)</span> 来说很小，而且 <span class="math inline">\(f&#39;(r)\ne0\)</span></li>
</ul>
<p><span class="math display">\[
\Delta r=\dfrac{-\epsilon g(r)}{\epsilon
g&#39;(r)+f&#39;(r)}\approx\dfrac{-\epsilon g(r)}{f&#39;(r)}
\]</span></p>
<h4 id="根的敏感性公式">根的敏感性公式</h4>
<ul>
<li>假定 <span class="math inline">\(r\)</span> 是 <span class="math inline">\(f(r)\)</span> 的根，并且 <span class="math inline">\(r+\Delta r\)</span> 是 <span class="math inline">\(f(x)+\epsilon g(x)\)</span> 的根，则当 <span class="math inline">\(\epsilon&lt;&lt;f&#39;(r)\)</span> 时</li>
</ul>
<p><span class="math display">\[
\Delta r\approx\dfrac{-\epsilon g(r)}{f&#39;(r)}
\]</span></p>
<h4 id="误差放大因子">误差放大因子</h4>
<ul>
<li>相对前向误差 / 相对后向误差</li>
<li>求根过程中的误差放大因子</li>
</ul>
<p><span class="math display">\[
\left\vert\dfrac{\dfrac{\Delta r}{r}}{\dfrac{\epsilon
g(r)}{g(r)}}\right\vert\approx\left\vert{\dfrac{\dfrac{-\epsilon
g(r)}{rf&#39;(r)}}{\epsilon}}\right\vert=\left\vert{\dfrac{g(r)}{rf&#39;(r)}}\right\vert
\]</span></p>
<h3 id="条件数">条件数</h3>
<ul>
<li>条件数：与算法无关，与问题本身有关</li>
<li>稳定：与算法相关，而不是问题本身</li>
</ul>
<p><img src="/2021/09/26/computation/pyr/02/image-20210926230401057.jpg" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.01.基础知识</title>
    <url>/2021/09/25/computation/pyr/01/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 0 章（基础知识） + PPT（误差）</li>
</ul>
<h1 id="基础知识">基础知识</h1>
<h2 id="多项式求值">1. 多项式求值</h2>
<ul>
<li><span class="math inline">\(x=\dfrac{1}{2},P(x)=2x^4+3x^3-3x^2+5x-1\)</span></li>
<li><strong>直接求值</strong>
<ul>
<li>乘法：10</li>
<li>加法：4</li>
</ul></li>
<li>计算 <span class="math inline">\((\dfrac{1}{2})^4\)</span>
保留中间结果
<ul>
<li>乘法：7（<span class="math inline">\(x^3,x^2\)</span>
不需要重复计算）</li>
<li>加法：4</li>
</ul></li>
<li><strong>嵌套乘法（霍纳方法）</strong>
<ul>
<li>乘法：4</li>
<li>加法：4</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
P(x)&amp;=2x^4+3x^3-3x^2+5x-1\\
&amp;=-1+5x-3x^2+3x^3+2x^4\\
&amp;=-1+x(5+x(-3+x(3+x(2)))
\end{aligned}
\]</span></p>
<ul>
<li>嵌套乘法能够通过 d 次乘法和 d 次加法计算 d 阶多项式的值</li>
<li><strong>科学计算方法的所有主题的特征</strong>
<ul>
<li>做简单计算的时候速度要快</li>
<li>由于简单计算可能会被进行多次，尽可能有效地进行简单计算非常重要</li>
<li>最好的计算方法可能不是显而易见的那种方法</li>
</ul></li>
<li>多项式的标准形式</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;c_1+c_2x+c_3x^2+c_4x^3+c_5x^4\\
=&amp;c_1+x(c_2+x(c_3+x(c_4+x(c_5))))\\
\end{aligned}
\]</span></p>
<ul>
<li>更加一般的形式
<ul>
<li>称 <span class="math inline">\(r_1,\cdots,r_4\)</span>
为<strong>基点</strong></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;c_1+c_2x+c_3x^2+c_4x^3+c_5x^4\\
=&amp;c_1+(x-r_1)(c_2+(x-r_2)(c_3+(x-r_3)(c_4+(x-r_4)(c_5))))\\
\end{aligned}
\]</span></p>
<h2 id="二进制数字">2. 二进制数字</h2>
<ul>
<li>进制转换
<ul>
<li>整数部分</li>
<li>小数部分</li>
</ul></li>
<li>2 进制转 10 进制无限循环小数示例</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
x&amp;=(0.\overline{1011})_2\Rightarrow2^4x=(1011.\overline{1011})_2\\
x&amp;=\dfrac{(1011)_2}{2^4-1}=\dfrac{11}{15}
\end{aligned}
\]</span></p>
<h2 id="实数的浮点表示">3. 实数的浮点表示</h2>
<ul>
<li>IEEE 标准</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">精度</th>
<th style="text-align: center;">符号 S</th>
<th style="text-align: center;">尾数 M</th>
<th style="text-align: center;">指数 E</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">单精度 32</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">23</td>
</tr>
<tr class="even">
<td style="text-align: center;">双精度 64</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">11</td>
<td style="text-align: center;">52</td>
</tr>
<tr class="odd">
<td style="text-align: center;">长双精度 80</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">15</td>
<td style="text-align: center;">64</td>
</tr>
</tbody>
</table>
<ul>
<li>数的分类
<ul>
<li><strong>规格化数</strong>：<span class="math inline">\(1.M\times2^{E-\mathrm{Bias}}\)</span>
<ul>
<li>指数不是全 0 或者全 1</li>
<li><span class="math inline">\(\mathrm{Bias}=2^{k-1}-1\)</span>
<ul>
<li><span class="math inline">\(\mathrm{Bias}\)</span>
称为<strong>指数偏差</strong></li>
</ul></li>
</ul></li>
<li><strong>非规格化数</strong>：<span class="math inline">\(0.M\times2^{1-Bias}\)</span>
<ul>
<li>指数全 0</li>
</ul></li>
<li><strong>无穷大</strong>：指数全 1，尾数全 0</li>
<li><strong>NaN</strong>：指数全 1，但是尾数不全为 0</li>
</ul></li>
</ul>
<h3 id="规格化数">规格化数</h3>
<ul>
<li>以 <strong>64 位双精度</strong> 为例</li>
<li>机器精度
<ul>
<li>1 和比 1 大的最小浮点数的距离</li>
<li><span class="math inline">\(\epsilon_{\mathrm{mach}}=2^{-52}\)</span></li>
</ul></li>
<li>舍入方式
<ul>
<li><strong>截断</strong></li>
<li><strong>四舍五入</strong></li>
<li>IEEE 舍入最近法则
<ul>
<li>规则
<ul>
<li>53 位为 1，进位</li>
<li>53 位为 0，舍去</li>
<li><strong>特殊情况</strong>：53 位之后全为 0
<ul>
<li>52 为 1 则进位，52 位为 0 则舍去</li>
</ul></li>
</ul></li>
<li>记作 <span class="math inline">\(\mathrm{fl}(x)\)</span></li>
</ul></li>
</ul></li>
<li><strong>舍入误差</strong>：<span class="math inline">\(\vert\mathrm{fl}(x)-x\vert\)</span></li>
<li>令 <span class="math inline">\(x_c\)</span> 是计算版本 <span class="math inline">\(x\)</span> 的精确度量
<ul>
<li><strong>绝对误差</strong>：<span class="math inline">\(\vert
x_c-x\vert\)</span></li>
<li><strong>相对误差</strong>：<span class="math inline">\(\dfrac{\vert
x_c-x\vert}{x}\)</span>
<ul>
<li>要求 <span class="math inline">\(x\)</span> 的度量存在，即 <span class="math inline">\(x\ne0\)</span></li>
</ul></li>
</ul></li>
<li><strong>相对舍入误差</strong></li>
</ul>
<p><span class="math display">\[
\dfrac{\vert\mathrm{fl}(x)-x\vert}{x}\le\dfrac{1}{2}\epsilon_{\mathrm{mach}}
\]</span></p>
<ul>
<li>理解如下结果</li>
</ul>
<p><img src="/2021/09/25/computation/pyr/01/image-20210926095158629.png"></p>
<h2 id="有效数字缺失">4. 有效数字缺失</h2>
<ul>
<li><strong>近似相等的两个数相减造成有效数字的位数减少</strong></li>
<li>123.4567 - 123.4566 = 0.0001
<ul>
<li>有效位数：(7) - (7) = (1)</li>
</ul></li>
<li>3 位小数的计算机上计算 <span class="math inline">\(\sqrt{9.01}-3\)</span>
<ul>
<li>3 位小数：中间计算的浮点数最多只能有 3
位尾数，有效数字位数肯定也小于 3</li>
<li><span class="math inline">\(\sqrt{9.01}\approx
3.0016662\approx3\)</span></li>
<li>结果为 0</li>
</ul></li>
<li><strong>共轭等式</strong></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\sqrt{9.01}-3&amp;=\dfrac{(\sqrt{9.01}-3)(\sqrt{9.01}+3)}{\sqrt{9.01}+3}\\
&amp;\\
&amp;=\dfrac{9.01-9}{\sqrt{9.01}+3}\\
&amp;\\
&amp;\approx\dfrac{0.01}{3+3}\\
&amp;\\
&amp;=\dfrac{0.01}{3+3}\\
&amp;\\
&amp;\approx1.67\times10^{-3}
\end{aligned}
\]</span></p>
<h3 id="三角函数">三角函数</h3>
<ul>
<li><strong>共轭方法</strong></li>
</ul>
<p><span class="math display">\[
\dfrac{1-\cos{x}}{\sin^2{x}}=\dfrac{(1-\cos{x})(1+\cos{x})}{\sin^2{x}(1+\cos{x})}=\dfrac{1}{1+\cos{x}}
\]</span></p>
<ul>
<li>测试</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">1</span>-<span class="title class_">Math</span>.<span class="title function_">cos</span>(x))/(<span class="title class_">Math</span>.<span class="title function_">sin</span>(x)*<span class="title class_">Math</span>.<span class="title function_">sin</span>(x)));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>/(<span class="number">1</span>+<span class="title class_">Math</span>.<span class="title function_">cos</span>(x)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test(1e-2)</span></span><br><span class="line"><span class="comment">// 0.5000125002084805</span></span><br><span class="line"><span class="comment">// 0.5000125002083363</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test(1e-5)</span></span><br><span class="line"><span class="comment">// 0.5000000413868522</span></span><br><span class="line"><span class="comment">// 0.5000000000125</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test(1e-10)</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0.5</span></span><br></pre></td></tr></table></figure>
<h3 id="求解一元二次不等式">求解一元二次不等式</h3>
<ul>
<li>求根公式如下，当 <span class="math inline">\(b^2-4ac\approx0\)</span> 时，某一个根分子出现
<span class="math inline">\(-b+b\)</span> 的情况</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
x=\dfrac{-b\pm\sqrt{b^2-4ac}}{2a}
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\(x^2+9^{12}x-3=0\)</span>
<ul>
<li>js 测试的结果</li>
</ul></li>
</ul>
<p><span class="math display">\[
x_1=\dfrac{-9^{12}-\sqrt{9^{24}-12}}{2}=-2.824\times10^{11}
\]</span></p>
<p><span class="math display">\[
x_2=\dfrac{-9^{12}+\sqrt{9^{24}-12}}{2}=0
\]</span></p>
<ul>
<li>如何减小这种误差：<strong>共轭方式</strong></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
x_2&amp;=\dfrac{-b+\sqrt{b^2-4ac}}{2a}\\
&amp;\\
&amp;=-\dfrac{(b-\sqrt{b^2-4ac})(b+\sqrt{b^2-4ac})}{2a(b+\sqrt{b^2-4ac})}\\
&amp;\\
&amp;=-\dfrac{4ac}{2a(b+\sqrt{b^2-4ac})}\\
&amp;\\
&amp;=-\dfrac{2c}{(b+\sqrt{b^2-4ac})}
\end{aligned}
\]</span></p>
<ul>
<li>看具体的 <strong>b 的正负性</strong>选择正确的表达式</li>
<li>或者利用韦达定理</li>
</ul>
<p><span class="math display">\[
x_1x_2=\dfrac{c}{a}
\]</span></p>
<h2 id="微积分">5. 微积分</h2>
<ul>
<li><strong>中值定理</strong> / <strong>介值定理</strong></li>
</ul>
<p><img src="/2021/09/25/computation/pyr/01/image-20210926103911119.jpg" style="zoom:67%;"></p>
<ul>
<li><strong>连续极限</strong></li>
</ul>
<p><img src="/2021/09/25/computation/pyr/01/image-20210926104921146.jpg" style="zoom:67%;"></p>
<ul>
<li><strong>均值定理</strong> / <strong>中值定理</strong></li>
</ul>
<p><img src="/2021/09/25/computation/pyr/01/image-20210926105532753.jpg" style="zoom:67%;"></p>
<ul>
<li><strong>罗尔定理</strong></li>
</ul>
<p><img src="/2021/09/25/computation/pyr/01/image-20210926105643430.jpg" style="zoom:67%;"></p>
<ul>
<li><strong>泰勒展开</strong>
<ul>
<li>用有限项求和来近似无穷级数</li>
<li>以 <span class="math inline">\(x_0\)</span> 为中心的函数 <span class="math inline">\(f\)</span> 的 <strong><span class="math inline">\(k\)</span> 阶泰勒多项式</strong> +
<strong>泰勒余项</strong>
<ul>
<li><strong>n 阶多项式近似</strong></li>
<li><strong>截断误差</strong></li>
</ul></li>
<li><span class="math inline">\(f(x)=P_k(x)+R_k(x)\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/09/25/computation/pyr/01/image-20210926105807974.jpg" style="zoom: 67%;"></p>
<ul>
<li><strong>均值定理的积分版本</strong></li>
</ul>
<p><img src="/2021/09/25/computation/pyr/01/image-20210926110911990.jpg" style="zoom:67%;"></p>
<ul>
<li><strong>推广罗尔定理</strong></li>
</ul>
<p><img src="/2021/09/25/computation/pyr/01/image-20210926111302385.jpg" style="zoom:67%;"></p>
<ul>
<li><strong>黎曼积分</strong></li>
</ul>
<p><img src="/2021/09/25/computation/pyr/01/image-20210926111448157.jpg" style="zoom:67%;"></p>
<ul>
<li><strong>极值定理</strong></li>
</ul>
<p><img src="/2021/09/25/computation/pyr/01/image-20210926111657727.jpg" style="zoom:67%;"></p>
<h2 id="误差10进制">6. 误差(10进制)</h2>
<ul>
<li>舍入与截断</li>
</ul>
<p><img src="/2021/09/25/computation/pyr/01/image-20210926112304493.jpg" style="zoom:67%;"></p>
<ul>
<li><span class="math inline">\(p^{\ast}\)</span> 是 <span class="math inline">\(p\)</span> 的一个近似，<span class="math inline">\(p=p^{\ast}\pm\epsilon^{\ast}\)</span>
<ul>
<li>绝对误差：<span class="math inline">\(\vert
p-p^{\ast}\vert\)</span></li>
<li>相对误差：<span class="math inline">\(\dfrac{\vert
p-p^{\ast}\vert}{\vert p\vert}\)</span></li>
<li>误差范围：<span class="math inline">\(\vert
e^{\ast}\vert\le\epsilon^{\ast}\)</span></li>
<li>有效数字：<span class="math inline">\(t\)</span>
为<strong>最大非负整数</strong>满足 <span class="math inline">\(\dfrac{\vert p-p^{\ast}\vert}{\vert
p\vert}&lt;5\times10^{-t}\)</span>
<ul>
<li>由于舍入引入的相对误差与有效数字的关系</li>
</ul></li>
</ul></li>
<li><strong>截断并不能保证 <span class="math inline">\(k\)</span>
位有效数字</strong></li>
</ul>
<p><img src="/2021/09/25/computation/pyr/01/image-20210926140712963.jpg" style="zoom:67%;"></p>
<ul>
<li>但是实际上，截断引入的相对误差可能比舍入引入的相对误差小
<ul>
<li><strong>上面都是小于号</strong>，一个范围估计</li>
</ul></li>
</ul>
<h3 id="产生误差的运算">产生误差的运算</h3>
<ul>
<li>相近数字相减</li>
<li>除以一个小数值的数</li>
</ul>
<h3 id="减小误差的方式">减小误差的方式</h3>
<ul>
<li>避免相近数字相减</li>
</ul>
<p><span class="math display">\[
\sqrt{x+\epsilon}-\sqrt{x}=\dfrac{\epsilon}{\sqrt{x+\epsilon}+\sqrt{x}}
\]</span></p>
<p><span class="math display">\[
\ln(x+\epsilon)-\ln(x)=\ln(1-\dfrac{\epsilon}{x})
\]</span></p>
<p><span class="math display">\[
1-\cos{x}=2\sin^2{\dfrac{x}{2}}\quad(x\to0)
\]</span></p>
<p><span class="math display">\[
e^x-1=x(1+\dfrac{1}{2}x+\dfrac{1}{6}x^2+\cdots)\quad(x\to0)
\]</span></p>
<ul>
<li>最小化计算的次数（嵌套乘法）
<ul>
<li>随着计算量的减少，累计误差降低</li>
</ul></li>
</ul>
<h3 id="舍入误差">舍入误差</h3>
<ul>
<li><span class="math inline">\(p^{\ast}=\pm0.a_1a_2\cdots
a_n\times10^m\)</span></li>
<li>有效数字：<span class="math inline">\(t\)</span>
为<strong>最大非负整数</strong>满足</li>
</ul>
<p><span class="math display">\[
\dfrac{\vert p-p^{\ast}\vert}{\vert p\vert}&lt;5\times10^{-t}
\]</span></p>
<ul>
<li><span class="math inline">\(\vert
p-p^{\ast}\vert\le0.5\times10^{m-t}\)</span>（<strong>比上面更强</strong>）</li>
</ul>
<p><span class="math display">\[
\begin{align}
\begin{array}{**llr**}
\vert p-p^{\ast}\vert&amp;\le5\times10^{-n-1}\times10^{m}&amp;\\
&amp;\le0.5\times10^{m-t}&amp;(t\le n)\\
\end{array}
\end{align}
\]</span></p>
<ul>
<li><span class="math inline">\(\epsilon_r^{\ast}\le\dfrac{1}{2a_1}\times10^{1-t}\)</span></li>
</ul>
<p><span class="math display">\[
\begin{align}
条件:&amp;\\
&amp;(1)\quad\vert p-p^{\ast}\vert\le0.5\times10^{m-t}\\
&amp;(2)\quad\vert p\vert\ge0.a_1\\
结论:&amp;\\
&amp; \epsilon_r^{\ast}=\dfrac{\vert p-p^{\ast}\vert}{\vert
p\vert}\le\dfrac{0.5\times10^{m-t}}{0.a_1\times10^{m}}=\dfrac{1}{2a_1}\times10^{1-t}
\end{align}
\]</span></p>
<ul>
<li>可能用上面的不同式子计算得到的有效数字位数不一样</li>
</ul>
<h2 id="算法与收敛性">7. 算法与收敛性</h2>
<h3 id="算法的标准稳定">算法的标准——稳定</h3>
<ul>
<li>稳定
<ul>
<li>初始数据中的<strong>微小变化</strong>会在最终结果中产生相应的<strong>小变化</strong></li>
</ul></li>
<li>条件稳定
<ul>
<li>仅对特定初值稳定</li>
</ul></li>
<li><strong>稳定性是算法的性质</strong>
<ul>
<li>稳定指的是针对<strong>算法</strong>引起的初始误差的放大，而不是<strong>问题</strong>本身</li>
<li>如果一个算法总是能以较小的后向误差提供近似解，则称为<strong>稳定算法</strong></li>
</ul></li>
</ul>
<h3 id="问题的条件">问题的条件</h3>
<ul>
<li>问题本身可能是有问题的，无论我们使用怎样的算法都没有用</li>
<li>由于<strong>理论问题本身固有的特性</strong>造成对初始误差的放大，与用于求解的<strong>特定算法</strong>无关</li>
<li>例子：蝴蝶效应、混沌现象、气象（洛仑兹方程）</li>
</ul>
<h3 id="算法的稳定性">算法的稳定性</h3>
<ul>
<li>指数增长的误差——不稳定</li>
<li>线性增长的误差——稳定</li>
</ul>
<p><img src="/2021/09/25/computation/pyr/01/image-20210926152758202.jpg" style="zoom: 67%;"></p>
<h4 id="例子">例子</h4>
<ul>
<li>求解</li>
</ul>
<p><span class="math display">\[
I_n=\dfrac{1}{e}\int_{0}^{1}x^ne^x\;\mathrm{d}x,\quad n=0,1,2,\cdots
\]</span></p>
<h5 id="迭代公式-1不稳定">迭代公式 1（不稳定）</h5>
<p><span class="math display">\[
I_n=1-nI_{n-1}
\]</span></p>
<ul>
<li>分部积分得到，首先计算 <span class="math inline">\(I_0\)</span>，之后迭代计算</li>
<li>误差推导</li>
</ul>
<p><span class="math display">\[
\vert{E_0}\vert=\vert{I_0-I_0^{\ast}}\vert
\]</span></p>
<p><span class="math display">\[
\vert{E_n}\vert=\vert{I_n-I_n^{\ast}}\vert=\vert{(1-nI_{n-1})-(1-nI_{n-1}^{\ast})}\vert=n\vert{E_{n-1}}\vert=\cdots=n!\vert{E_{0}}\vert
\]</span></p>
<h5 id="迭代公式-2稳定">迭代公式 2（稳定）</h5>
<p><span class="math display">\[
I_n=1-nI_{n-1}\Rightarrow I_{n-1}=\dfrac{1-I_{n}}{n}
\]</span></p>
<ul>
<li>首先计算得到 <span class="math inline">\(I_N^{\ast}\)</span></li>
</ul>
<p><span class="math display">\[
I_N\ge\dfrac{1}{e}\int_{0}^{1}x^Ne^0\;\mathrm{d}x=\dfrac{1}{e(N+1)}
\]</span></p>
<p><span class="math display">\[
I_N\le\dfrac{1}{e}\int_{0}^{1}x^Ne^1\;\mathrm{d}x=\dfrac{1}{N+1}
\]</span></p>
<p><span class="math display">\[
I_N^{\ast}=\dfrac{1}{2}(\dfrac{1}{e(N+1)}+\dfrac{1}{N+1})
\]</span></p>
<ul>
<li>误差推导</li>
</ul>
<p><span class="math display">\[
\vert{E_n}\vert=\dfrac{\vert{E_{n+1}}\vert}{n+1}=\cdots=\dfrac{\vert{E_{N}}\vert}{(n+1)\cdots{(N-1)}{N}}
\]</span></p>
<h3 id="收敛速度">收敛速度</h3>
<ul>
<li><strong>数列</strong></li>
</ul>
<p><img src="/2021/09/25/computation/pyr/01/image-20210926155941203.jpg" style="zoom:67%;"></p>
<ul>
<li><strong>函数</strong></li>
</ul>
<p><img src="/2021/09/25/computation/pyr/01/image-20210926160014211.jpg" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.03.方程组(2)</title>
    <url>/2021/10/10/computation/pyr/03-1/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 2 章（方程组） + PPT（非线性方程组迭代求解）</li>
</ul>
<h1 id="方程组">方程组</h1>
<h2 id="pa-lu-分解">4. PA-LU 分解</h2>
<ul>
<li>之前朴素高斯法的问题：<strong>0主元</strong> +
<strong>淹没</strong></li>
<li>改进策略：<strong>交换矩阵的行</strong>
<ul>
<li><strong>部分主元</strong></li>
</ul></li>
</ul>
<h3 id="部分主元">4.1 部分主元</h3>
<ul>
<li>我们进行对主元 <span class="math inline">\(a_{ii}\)</span>
的操作时， 在进行高斯消去之前，我们找到剩余行 <span class="math inline">\((i\le p\le n)\)</span> 中第 <span class="math inline">\(i\)</span> 列中的绝对值最大值 <span class="math inline">\(a_{pi}\)</span> ，将该行和第 <span class="math inline">\(i\)</span> 行进行交换，然后再进行高斯消去</li>
<li>此时保证每次进行操作的主元嗾使剩余行中的最大值，避免了上面的<strong>0主元</strong>和<strong>淹没</strong>问题
<ul>
<li><strong>淹没</strong>：保证所有乘子三维绝对值小于 1</li>
<li><strong>0主元</strong>：如果全为
0，则为奇异矩阵，高斯消去方法无法求解</li>
</ul></li>
</ul>
<h3 id="置换矩阵">4.2 置换矩阵</h3>
<ul>
<li>置换矩阵，每一行每一列有且仅有一个 1，其余全为 0</li>
<li><strong>置换矩阵左乘一个矩阵</strong></li>
</ul>
<p><img src="/2021/10/10/computation/pyr/03-1/image-20211011160752288.jpg" style="zoom: 67%;"></p>
<h3 id="palu-分解">4.3 PA=LU 分解</h3>
<h4 id="一个例子">一个例子</h4>
<p><img src="/2021/10/10/computation/pyr/03-1/image-20211012112409411.jpg" style="zoom:67%;"></p>
<h4 id="例子分析">例子分析</h4>
<ul>
<li>通过上面的例子，我们形式化的将 4 个矩阵，<span class="math inline">\(P,A,L,U\)</span>，形式化的定义出来，从而证明上面算法的正确性</li>
<li>下标从 <strong>1</strong> 开始</li>
<li>记针对主元 <span class="math inline">\(a_{ii}\)</span> 的换行操作为
<span class="math inline">\(P_{i}\)</span>，针对主元 <span class="math inline">\(a_{ii}\)</span> 消去第 <span class="math inline">\(j\)</span> 行的操作为 <span class="math inline">\(L_{ij}\)</span></li>
<li>根据上面的算法流程，可以得到如下一系列式子</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
L_{23}P_{2}L_{13}L_{12}P_{1}A=U\\
P=P_{2}P_{1}\\
\end{array}
\]</span></p>
<ul>
<li>对于矩阵 <span class="math inline">\(L\)</span>，他对于 <span class="math inline">\(I\)</span> 矩阵的影响如下
<ul>
<li>注意对于 <span class="math inline">\(L\)</span>
矩阵，左下角的矩阵中的值<strong>生成之后就不再改变</strong></li>
<li>这里用到了之前的<a href="/2021/10/02/computation/pyr/03/#事实3">定理</a></li>
</ul></li>
</ul>
<p><span class="math display">\[
LI=P_{2}\left(L_{12}^{-1}L_{13}^{-1}{\color{red}P_{1}}I{\color{red}P_{1}^{-1}}\right)P_{2}^{-1}L_{23}^{-1}
\]</span></p>
<ul>
<li>我们记 <span class="math inline">\(L_{13}^{-1}L_{12}^{-1}P_{1}IP_{1}^{-1}=L_{1}\)</span>，也就是经过对主元
<span class="math inline">\(a_{11}\)</span> 处理完之后的 <span class="math inline">\(L\)</span> 矩阵</li>
<li>分析 <span class="math inline">\(P_{1}L_{1}P_{1}^{-1}\)</span>
这一步的操作（以上面的例子为例）
<ul>
<li>我们在计算中做的操作实际上就是将矩阵 <span class="math inline">\(L_{1}\)</span> 左下角的部分第 <span class="math inline">\(2,3\)</span> 行做了交换</li>
<li>实际上的矩阵操作就是我们先将第 <span class="math inline">\(2,3\)</span> 行互换，然后再将第 <span class="math inline">\(2,3\)</span> 列互换
<ul>
<li><span class="math inline">\(P_{1}^{-1}=P_{1}\)</span>（这里的 <span class="math inline">\(P_{i}\)</span>
都是只对单位矩阵做一次行变换的结果）</li>
<li>左乘交换矩阵就是行变换、右乘交换矩阵就是列变换</li>
<li>注意我们在操作主元 <span class="math inline">\(a_{ii}\)</span>
时，第 <span class="math inline">\(i\)</span> 列（含 <span class="math inline">\(i\)</span>）之后的元素都还未处理，因此交换 <span class="math inline">\(i,j\)</span> 列影响的本质上只有两个 <span class="math inline">\(1\)</span></li>
</ul></li>
<li>实际效果如下</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 0 &amp; 0\\
\dfrac{1}{2} &amp; 1 &amp; 0\\
\dfrac{1}{4} &amp; 0 &amp; 1\\
\end{bmatrix}
\rightarrow
\begin{bmatrix}
1 &amp; 0 &amp; 0\\
\dfrac{1}{4} &amp; 1 &amp; 0\\
\dfrac{1}{2} &amp; 0 &amp; 1\\
\end{bmatrix}
\]</span></p>
<ul>
<li>我们验证</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
LU&amp;=P_{2}L_{12}^{-1}L_{13}^{-1}P_{1}IP_{1}^{-1}P_{2}^{-1}L_{23}^{-1}L_{23}P_{2}L_{13}L_{12}P_{1}A\\
&amp;=P_{2}P_{1}A\\
&amp;=PA
\end{aligned}
\]</span></p>
<ul>
<li>对于 <span class="math inline">\(n\times n\)</span>
的矩阵，我们有</li>
</ul>
<p><span class="math display">\[
L_i=
\left\{
\begin{array}{ll}
P_{i}L_{i-1}P_{i}^{-1}L_{i,i+1}\cdots L_{i,n}&amp;,i&gt;0\\
I&amp;,i=0
\end{array}
\right.
\]</span></p>
<p><span class="math display">\[
U_i=
\left\{
\begin{array}{ll}
L_{i,n}^{-1}\cdots L_{i,i+1}^{-1}P_{i}U_{i-1}&amp;,i&gt;0\\
A&amp;,i=0
\end{array}
\right.
\]</span></p>
<ul>
<li>于是有</li>
</ul>
<p><span class="math display">\[
L_iU_i=
\left\{
\begin{array}{ll}
P_{i}L_{i-1}P_{i}^{-1}L_{i,i+1}\cdots L_{i,n}L_{i,n}^{-1}\cdots
L_{i,i+1}^{-1}P_{i}U_{i-1}=P_{i}L_{i-1}U_{i-1}&amp;,i&gt;0\\
A&amp;,i=0
\end{array}
\right.
\]</span></p>
<ul>
<li>那么成立 <span class="math inline">\(PA=LU\)</span></li>
</ul>
<p><span class="math display">\[
LU=L_{n-1}U_{n-1}=P_{n-1}L_{n-2}U_{n-2}=\cdots=P_{n-1}\cdots P_{1}A=PA
\]</span></p>
<h2 id="迭代方法">5. 迭代方法</h2>
<h3 id="雅可比方法">5.1 雅可比方法</h3>
<ul>
<li>Jacobi 方法
<ul>
<li>求解第 <span class="math inline">\(i\)</span> 个方程得到第 <span class="math inline">\(i\)</span> 个未知量，然后使用不动点迭代方法</li>
</ul></li>
<li>对如下方程组使用雅可比方法</li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{c}
3u+v=5\\
u+2v=5\\
\end{array}
\right.
\Rightarrow
\left\{
\begin{array}{c}
u=\dfrac{5-v}{3}\\
v=\dfrac{5-u}{2}\\
\end{array}
\right.
\]</span></p>
<ul>
<li>根据初始估计进行迭代，<strong>收敛至正确结果</strong></li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
(u_0,v_0)=(0,0)\\
(u_1,v_1)=(\dfrac{5}{3},\dfrac{5}{2})\\
\cdots\\
(u_n,v_n)=(1,2)\\
\end{array}
\]</span></p>
<ul>
<li>换一种方法则<strong>发散</strong></li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{c}
v=5-3u\\
u=5-2v\\
\end{array}
\right.
\]</span></p>
<h4 id="严格对角占优矩阵">严格对角占优矩阵</h4>
<p><img src="/2021/10/10/computation/pyr/03-1/image-20211012143044542.jpg" style="zoom:67%;"></p>
<h5 id="定理-2.10">定理 2.10</h5>
<p><img src="/2021/10/10/computation/pyr/03-1/image-20211012144027335.jpg" style="zoom:67%;"></p>
<ul>
<li>注意这只是个<strong><span style="color:red">充分条件</span></strong></li>
</ul>
<h5 id="满秩证明">满秩证明</h5>
<ul>
<li>假设不满秩，则存在非零向量 <span class="math inline">\(x=(x_1,\cdots,x_n)^T\)</span> 使得 <span class="math inline">\(Ax=0\)</span> 成立</li>
<li>假设 <span class="math inline">\(\vert{x_k}\vert\ge\vert{x_i}\vert,\forall
i\)</span>，那么有 <span class="math inline">\(\vert{x_{k}}\vert\ge0\)</span></li>
<li>那么有</li>
</ul>
<p><span class="math display">\[
0=\sum_{j=1}^{n}a_{kj}x_{j}
\]</span></p>
<p><span class="math display">\[
\left\vert{\sum_{j\ne
k}a_{kj}x_{j}}\right\vert=\vert{-a_{kk}x_k}\vert=\vert{a_{kk}}\vert\vert{x_k}\vert&gt;{\sum_{j\ne
k}\vert{a_{kj}}\vert\vert{x_{j}}\vert}\ge\left\vert{\sum_{j\ne
k}a_{kj}x_{j}}\right\vert
\]</span></p>
<ul>
<li>矛盾，因此满秩</li>
</ul>
<h4 id="雅可比方法-1">雅可比方法</h4>
<ul>
<li><span class="math inline">\(A=L+D+U\)</span>
<ul>
<li>矩阵 = 下三角矩阵（对角线为 0） + 主对角线矩阵 +
上三角矩阵（对角线为 0）</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
Ax=b\\
(L+D+U)x=b\\
Dx=b-(L+U)x\\
x=D^{-1}\big(b-(L+U)x\big)
\end{array}
\]</span></p>
<ul>
<li>雅可比方法</li>
</ul>
<p><span class="math display">\[
\begin{array}{l}
x_0=初始估计\\
x_{k+1}=D^{-1}\big(b-(L+U)x_{k}\big)\\
\end{array}
\]</span></p>
<h3 id="高斯-赛德尔方法和-sor">5.2 高斯-赛德尔方法和 SOR</h3>
<h4 id="guass-seidel-方法">Guass-Seidel 方法</h4>
<ul>
<li>在雅可比方法的基础上，在第 <span class="math inline">\(k\)</span>
轮迭代的时候，如果某一个 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(x_k\)</span> 已经被计算出来，则使用 <span class="math inline">\(x_k\)</span> 进行迭代，而不是 <span class="math inline">\(x_{k-1}\)</span></li>
</ul>
<p><span class="math display">\[
\begin{array}{l}
x_0=初始估计\\
x_{k+1}=D^{-1}\big(b-Lx_{k+1}-Ux_{k}\big)\\
\end{array}
\]</span></p>
<ul>
<li>例子</li>
</ul>
<p><span class="math display">\[
\begin{bmatrix}
3 &amp; 1 &amp; -1\\
2 &amp; 4 &amp; 1\\
-1 &amp; 2 &amp; 5\\
\end{bmatrix}
\begin{bmatrix}
u\\
v\\
w\\
\end{bmatrix}
=
\begin{bmatrix}
4\\
1\\
1\\
\end{bmatrix}
\]</span></p>
<ul>
<li>高斯赛德尔迭代</li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{c}
u_{k+1}=\dfrac{4-v_{k}+w_{k}}{3}\\
v_{k+1}=\dfrac{1-2u_{k+1}-w_{k}}{4}\\
w_{k+1}=\dfrac{1+u_{k+1}-2v_{k+1}}{5}\\
\end{array}
\right.
\]</span></p>
<h4 id="sor">SOR</h4>
<ul>
<li>SOR：连续过松弛方法</li>
</ul>
<p><img src="/2021/10/10/computation/pyr/03-1/image-20211012151033877.jpg" style="zoom:67%;"></p>
<ul>
<li>上面的例子</li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{l}
u_{k+1}=(1-\omega)u_{k}+\omega\times\dfrac{4-v_{k}+w_{k}}{3}\\
v_{k+1}=(1-\omega)v_{k}+\omega\times\dfrac{1-2u_{k+1}-w_{k}}{4}\\
w_{k+1}=(1-\omega)w_{k}+\omega\times\dfrac{1+u_{k+1}-2v_{k+1}}{5}\\
\end{array}
\right.
\]</span></p>
<ul>
<li>也可以如此理解</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
Ax=b\\
\omega Ax=\omega b\\
\omega(L+D+U)x=\omega b\\
(\omega L+D)x=\omega b+(1-\omega)Dx-\omega Ux\\
x=(\omega L+D)^{-1}\big(\omega b+(1-\omega)Dx-\omega Ux\big)\\
x=(\omega L+D)^{-1}\big((1-\omega)Dx-\omega Ux\big)+\omega(\omega
L+D)^{-1}b\\
\end{array}
\]</span></p>
<ul>
<li>SOR</li>
</ul>
<p><span class="math display">\[
\begin{array}{l}
x_0=初始估计\\
x_{k+1}=(\omega L+D)^{-1}\big((1-\omega)D-\omega
U\big)x_{k}+\omega(\omega L+D)^{-1}b\\
\end{array}
\]</span></p>
<ul>
<li><span class="math inline">\(\omega=1\)</span>：高斯赛德尔方法</li>
<li><span class="math inline">\(\omega&lt;1\)</span>：连续欠松弛方法</li>
</ul>
<h3 id="迭代方法的收敛">5.3 迭代方法的收敛</h3>
<h4 id="谱半径">谱半径</h4>
<p><img src="/2021/10/10/computation/pyr/03-1/image-20211012153350640.jpg" style="zoom:67%;"></p>
<h4 id="雅可比方法的收敛性">雅可比方法的收敛性</h4>
<ul>
<li><a href="#定理%202.10">定理 2.10</a></li>
<li>雅可比方法</li>
</ul>
<p><span class="math display">\[
x_{k+1}=-D^{-1}(L+U)x_{k}+D^{-1}b\\
\]</span></p>
<ul>
<li><p>我们记 <span class="math inline">\(R=L+U\)</span>，则需要证明
<span class="math inline">\(\rho(D^{-1}R)&lt;1\)</span></p></li>
<li><p>我们取矩阵 <span class="math inline">\(D^{-1}R\)</span> 特征值
<span class="math inline">\(\lambda\)</span> 和其对应的特征向量 <span class="math inline">\(v\)</span>，让 <span class="math inline">\(v\)</span> 对其绝对值最大的元素归一化，使其满足
<span class="math inline">\(\Vert{v}\Vert_{\infty}=1\)</span></p>
<ul>
<li>不妨设 <span class="math inline">\(v_{m}=1\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
D^{-1}Rv=\lambda v\Leftrightarrow Rv=D\lambda v
\]</span></p>
<ul>
<li><span class="math inline">\(r_{mm}=0\)</span>（对角线元素全为 0）
<ul>
<li><span class="math inline">\(D\)</span> 是对角矩阵</li>
</ul></li>
</ul>
<p><span class="math display">\[
\left\vert{\sum_{i=1}^{n}r_{mi}v_i}\right\vert=\left\vert{\sum_{i\ne
m}r_{mi}v_i}\right\vert=\left\vert{\sum_{i=1}^{n}\lambda
d_{mi}v_{i}}\right\vert=\left\vert{\lambda
d_{mm}v_{m}}\right\vert=\vert{\lambda}\vert\vert{d_{mm}}\vert
\]</span></p>
<ul>
<li>那么有</li>
</ul>
<p><span class="math display">\[
\left\vert{\sum_{i\ne m}r_{mi}v_i}\right\vert&lt;\sum_{i\ne
m}\left\vert{r_{mi}v_i}\right\vert&lt;\sum_{i\ne
m}\left\vert{r_{mi}}\right\vert&lt;\vert{d_{mm}}\vert\Rightarrow\lambda&lt;1
\]</span></p>
<ul>
<li><strong>因此收敛</strong>，于是对应任意的 <span class="math inline">\(b\)</span>，<span class="math inline">\(Ax=b\)</span> 都有唯一解， <span class="math inline">\(A\)</span> 是非奇异矩阵</li>
</ul>
<h4 id="高斯赛德尔方法的收敛性">高斯赛德尔方法的收敛性</h4>
<p><img src="/2021/10/10/computation/pyr/03-1/image-20211012163214206.jpg" style="zoom:67%;"></p>
<ul>
<li>高斯赛德尔方法</li>
</ul>
<p><span class="math display">\[
x_{k+1}=-(L+D)^{-1}Ux_{k}-(L+D)^{-1}b
\]</span></p>
<ul>
<li>类似的</li>
</ul>
<p><span class="math display">\[
(L+D)^{-1}Uv=\lambda v\Leftrightarrow Uv=\lambda(L+D)v
\]</span></p>
<ul>
<li>第 <span class="math inline">\(m\)</span> 行</li>
</ul>
<p><span class="math display">\[
\left\vert{\sum_{i=1}^{n}a_{mi}v_i}\right\vert
=\left\vert{\sum_{i&gt;m}a_{mi}v_i}\right\vert
=\left\vert{\sum_{i\le m}\lambda a_{mi}v_i}\right\vert
\]</span></p>
<ul>
<li>于是有</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\vert{\lambda}\vert\sum_{i&gt;m}\vert{a_{mi}}\vert
&amp;&lt;\vert{\lambda}\vert
\left(\vert{a_{mm}}\vert-\sum_{i&lt;m}\vert{a_{mi}}\vert\right)
\le\vert{\lambda}\vert
\left(\vert{a_{mm}}\vert-\sum_{i&lt;m}\vert{a_{mi}v_i}\vert\right)\\
&amp;\le\vert{\lambda}\vert
\left\vert{a_{mm}}+\sum_{i&lt;m}{a_{mi}v_i}\right\vert
=\left\vert{\lambda}\sum_{i\le m}{a_{mi}v_i}\right\vert
=\left\vert{\sum_{i&gt;m}a_{mi}v_i}\right\vert\\
&amp;\le\left\vert{\sum_{i&gt;m}a_{mi}}\right\vert
\le\sum_{i&gt;m}\left\vert{a_{mi}}\right\vert
\end{aligned}
\]</span></p>
<ul>
<li>推出 <span class="math inline">\(\lambda&lt;1\)</span></li>
</ul>
<h3 id="稀疏矩阵计算">5.4 稀疏矩阵计算</h3>
<ul>
<li>迭代方法的好处
<ul>
<li>如果有近似解，则迭代方法可以更快
<ul>
<li><strong>修饰</strong>：利用之前相关问题得到近似解作为初始估计，进而求解</li>
</ul></li>
<li>稀疏矩阵求解
<ul>
<li>高斯消去的方法，很可能会将原来的稀疏矩阵进行填充，问题复杂化</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.03.方程组(3)</title>
    <url>/2021/10/14/computation/pyr/03-2/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 2 章（方程组） + PPT（非线性方程组迭代求解）</li>
</ul>
<h1 id="方程组">方程组</h1>
<h2 id="用于对称正定矩阵的方法">6. 用于对称正定矩阵的方法</h2>
<ul>
<li>楚列夫斯基（Cholesky） 分解</li>
</ul>
<h3 id="对称正定矩阵">6.1 对称正定矩阵</h3>
<h4 id="正定矩阵定义与性质">正定矩阵定义与性质</h4>
<ul>
<li>对称矩阵：<span class="math inline">\(A^{T}=A\)</span></li>
<li>正定矩阵：对任意的向量 <span class="math inline">\(x\ne0\)</span>，都有 <span class="math inline">\(x^{T}Ax&gt;0\)</span></li>
<li>对称正定矩阵是非奇异矩阵
<ul>
<li>不存在非零向量 <span class="math inline">\(x\)</span> 使得 <span class="math inline">\(Ax=0\)</span></li>
</ul></li>
<li><span class="math inline">\(A\)</span> 是正定矩阵 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(A\)</span> 的所有特征值为正数</li>
</ul>
<p><img src="/2021/10/14/computation/pyr/03-2/image-20211012180730784.jpg" style="zoom:67%;"></p>
<ul>
<li><span class="math inline">\(n\times n\)</span> 的对称正定矩阵 <span class="math inline">\(A\)</span>，<span class="math inline">\(n\times
m\)</span> 的满秩矩阵 <span class="math inline">\(X\)</span>（<span class="math inline">\(n\ge m\)</span>），则 <span class="math inline">\(X^{T}AX\)</span> 是 <span class="math inline">\(m\times m\)</span> 的对称正定矩阵
<ul>
<li>对称：<span class="math inline">\((X^{T}AX)^{T}=X^{T}AX\)</span></li>
<li>正定：非零 <span class="math inline">\(m\)</span> 维向量 <span class="math inline">\(v\)</span>，<span class="math inline">\(v^{T}(X^{T}AX)v=(Xv)^{T}A(Xv)\)</span>
<ul>
<li><span class="math inline">\(A\)</span> 是正定矩阵，如果 <span class="math inline">\(Xv\ne0\)</span> ，则 <span class="math inline">\(v^{T}(X^{T}AX)v&gt;0\)</span></li>
<li><span class="math inline">\(X\)</span> 满秩 <span class="math inline">\(\Rightarrow\)</span> 列向量线性无关 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(Xv=0\Leftrightarrow v=0\)</span>
<ul>
<li><span class="math inline">\(Xv\)</span> 是对 <span class="math inline">\(X\)</span> 列向量的线性组合</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="主子矩阵">主子矩阵</h4>
<p><img src="/2021/10/14/computation/pyr/03-2/image-20211012181936604.jpg" style="zoom:67%;"></p>
<ul>
<li><strong>任何对称正定矩阵的主子矩阵也是对称正定矩阵</strong></li>
<li>假设主子矩阵 <span class="math inline">\(M\)</span> 选中的是第 <span class="math inline">\(i_1,i_2,\cdots,i_k\)</span> 列，那么他选中的就是第
<span class="math inline">\(i_1,i_2,\cdots,i_k\)</span> 行</li>
<li>任意向量 <span class="math inline">\(v=(v_1,\cdots,v_k)^{T}\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
v^{T}Mv&amp;=\sum_{y=1}^{k}\sum_{x=1}^{k}v_xm_{x,y}v_y\\
&amp;=\sum_{y=1}^{k}\sum_{x=1}^{k}v_xa_{i_{x},i_{y}}v_y
\end{aligned}
\]</span></p>
<ul>
<li>构造向量 <span class="math inline">\(u\)</span>，满足如下结果</li>
</ul>
<p><span class="math display">\[
u_j=
\left\{
\begin{array}{ll}
v_k&amp;j=i_k\\
0&amp;else\\
\end{array}
\right.
\]</span></p>
<ul>
<li>那么有</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
u^{T}Au&amp;=\sum_{y=1}^{n}\sum_{x=1}^{n}u_xa_{x,y}u_y\\
&amp;=\sum_{y=1}^{k}\sum_{x=1}^{k}u_{i_x}a_{i_{x},i_{y}}u_{i_y}\\
&amp;=\sum_{y=1}^{k}\sum_{x=1}^{k}v_xa_{i_{x},i_{y}}v_y
\end{aligned}
\]</span></p>
<ul>
<li>所以</li>
</ul>
<p><span class="math display">\[
v^{T}Mv=u^{T}Au&gt;0
\]</span></p>
<h3 id="楚列斯基分解">6.2 楚列斯基分解</h3>
<ul>
<li>如果 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(n\times n\)</span> 对称正定矩阵，则存在 <span class="math inline">\(n\times n\)</span> 上三角阵 <span class="math inline">\(R\)</span>，满足 <span class="math inline">\(A=R^{T}R\)</span></li>
</ul>
<h4 id="归纳法证明">归纳法证明</h4>
<ul>
<li><span class="math inline">\(n=2\)</span> 时</li>
</ul>
<p><img src="/2021/10/14/computation/pyr/03-2/image-20211013162127721.jpg" style="zoom:67%;"></p>
<ul>
<li><span class="math inline">\(n\ge2\)</span></li>
</ul>
<p><img src="/2021/10/14/computation/pyr/03-2/image-20211013163050492.jpg" style="zoom:67%;"></p>
<h4 id="分解算法">分解算法</h4>
<ul>
<li>结果生成的矩阵为上三角矩阵 <span class="math inline">\(R\)</span></li>
</ul>
<p><img src="/2021/10/14/computation/pyr/03-2/image-20211013165447930.jpg" style="zoom:67%;"></p>
<h4 id="解方程">解方程</h4>
<ul>
<li><span class="math inline">\(Ax=b\)</span></li>
<li><span class="math inline">\(R^{T}Rx=b\)</span></li>
<li><span class="math inline">\(R^{T}y=b,Rx=y\)</span></li>
</ul>
<h3 id="共轭梯度方法">6.3 共轭梯度方法</h3>
<ul>
<li>向量内积是<strong>对称的</strong>、<strong>线性的</strong></li>
</ul>
<p><span class="math display">\[
(w,v)=(v,w)
\]</span></p>
<p><span class="math display">\[
(\alpha w+\beta v,u)=\alpha(w,u)+\beta(v,u)
\]</span></p>
<h4 id="a-内积与-a-共轭">A 内积与 A 共轭</h4>
<ul>
<li><strong>对称正定矩阵 A</strong> 的 <strong>A 内积</strong>和
<strong>A 共轭</strong></li>
</ul>
<p><img src="/2021/10/14/computation/pyr/03-2/image-20211013170221287.jpg" style="zoom:67%;"></p>
<ul>
<li>A 内积继承了矩阵 A 的线性、对称、正定性质</li>
<li>A 对称 <span class="math inline">\(\Rightarrow\)</span> A
内积对称</li>
</ul>
<p><span class="math display">\[
(v,w)_{A}=\big((v,w)_{A}\big)^{T}=(v^{T}Aw)^{T}=w^{T}A^{T}v=w^{T}Av=(w,v)_{A}
\]</span></p>
<h4 id="共轭梯度方法-1">共轭梯度方法</h4>
<ul>
<li><strong>直接方法</strong>，通过有限步得到解</li>
</ul>
<p><img src="/2021/10/14/computation/pyr/03-2/image-20211013182728104.jpg" style="zoom:67%;"></p>
<ul>
<li>每次更新 <span class="math inline">\(x_k,d_{k},r_{k}\)</span> 这 3
个向量
<ul>
<li><span class="math inline">\(x_{k}\)</span>：近似解</li>
<li><span class="math inline">\(r_{k}\)</span>：近似解 <span class="math inline">\(x_k\)</span> 的余项</li>
<li><span class="math inline">\(d_k\)</span>：搜索方向</li>
</ul></li>
<li><span class="math inline">\(\alpha_k,\beta_k\)</span>：<strong>实数</strong>，临时变量</li>
</ul>
<h4 id="算法解释">算法解释</h4>
<p><img src="/2021/10/14/computation/pyr/03-2/image-20211014103840510.jpg"></p>
<h4 id="定理与证明">定理与证明</h4>
<ul>
<li>注：<strong><span style="color:red">红框</span></strong>部分应该是
<span class="math inline">\(r_{k}^{T}Ad_{k}\)</span></li>
</ul>
<p><img src="/2021/10/14/computation/pyr/03-2/image-20211013191958227.jpg"></p>
<h4 id="对比">对比</h4>
<ul>
<li>共轭梯度方法计算代价大致在 <span class="math inline">\(n^3\)</span>，比高斯消去大</li>
<li>共轭梯度方法代码实现上比高斯消去更简单，没有一些边界需要处理</li>
<li>对于病态矩阵，共轭梯度方法比部分主元的高斯消去效果更差，可以通过<strong>预条件处理</strong>进行缓解</li>
<li>后向误差和余项的欧几里得长度，随着每一步下降，因而至少对于这种度量方式，<span class="math inline">\(Ax_i\)</span> 在每一步变得和 <span class="math inline">\(b\)</span> 越来越接近。因而通过检测 <span class="math inline">\(r_i\)</span>，可能得到一个足够好的 <span class="math inline">\(x\)</span>，并不必做完 <span class="math inline">\(n\)</span>
步，在这种情况下，共轭梯度方法和迭代方法没有区别。</li>
</ul>
<h3 id="预条件">6.4 预条件</h3>
<ul>
<li>思想：<strong>降低问题中的条件数</strong></li>
<li><span class="math inline">\(Ax=b\)</span> 的预条件形式 <span class="math inline">\(M^{-1}Ax=M^{-1}b\)</span></li>
<li>矩阵 <span class="math inline">\(M\)</span> 应该满足如下条件
<ul>
<li>足够接近 <span class="math inline">\(A\)</span></li>
<li>求逆足够简单</li>
</ul></li>
<li>这俩条件常常矛盾
<ul>
<li><span class="math inline">\(M=A\)</span> 时，方程变为 <span class="math inline">\(x=A^{-1}b\)</span>，条件数为 1，但是 <span class="math inline">\(A\)</span> 不容易求逆</li>
<li><span class="math inline">\(M=I\)</span> 是，方程变为 <span class="math inline">\(Ax=b\)</span>，不能降低条件数</li>
</ul></li>
</ul>
<h4 id="雅可比预条件子">雅可比预条件子</h4>
<ul>
<li><span class="math inline">\(D\)</span> 是 <span class="math inline">\(A\)</span> 的对角线矩阵</li>
<li><span class="math inline">\(D\)</span>
的逆矩阵也是对角线矩阵，刚好为 <span class="math inline">\(D\)</span>
中对应元素的倒数</li>
<li>在严格对角占优矩阵 <span class="math inline">\(A\)</span> 中，<span class="math inline">\(D\)</span> 与 <span class="math inline">\(A\)</span> 相似且容易求逆</li>
</ul>
<h4 id="预条件子的共轭梯度算法">预条件子的共轭梯度算法</h4>
<p><img src="/2021/10/14/computation/pyr/03-2/image-20211014103010791.jpg" style="zoom:67%;"></p>
<h5 id="说明">说明</h5>
<p><img src="/2021/10/14/computation/pyr/03-2/image-20211014110421508.jpg" style="zoom:67%;"></p>
<p><img src="/2021/10/14/computation/pyr/03-2/image-20211014105032696.jpg" style="zoom:67%;"></p>
<h4 id="高斯-塞德尔预条件子">高斯-塞德尔预条件子</h4>
<p><img src="/2021/10/14/computation/pyr/03-2/image-20211014110959349.jpg" style="zoom:67%;"></p>
<p><span class="math display">\[
\begin{aligned}
\begin{array}{c}
...
\end{array}
\end{aligned}
\]</span></p>
<h2 id="非线性方程组">7. 非线性方程组</h2>
<h3 id="多元牛顿方法">7.1 多元牛顿方法</h3>
<ul>
<li>多元非线性方程组</li>
</ul>
<p><span class="math display">\[
\left\{
\begin{array}{l}
f_{1}(u,v,w)=0\\
f_{2}(u,v,w)=0\\
f_{3}(u,v,w)=0\\
\end{array}
\right.
\]</span></p>
<ul>
<li>向量值函数</li>
</ul>
<p><span class="math display">\[
F(x)=(f_1,f_2,f_3)
\]</span></p>
<ul>
<li>多元非线性方程组转化为</li>
</ul>
<p><span class="math display">\[
F(x)=0,x=(u,v,w)
\]</span></p>
<ul>
<li>雅可比矩阵</li>
</ul>
<p><span class="math display">\[
DF(x)=\begin{pmatrix}
\dfrac{\partial{f_1}}{\partial{u}}&amp;\dfrac{\partial{f_1}}{\partial{v}}&amp;\dfrac{\partial{f_1}}{\partial{w}}\\
\dfrac{\partial{f_2}}{\partial{u}}&amp;\dfrac{\partial{f_2}}{\partial{v}}&amp;\dfrac{\partial{f_2}}{\partial{w}}\\
\dfrac{\partial{f_3}}{\partial{u}}&amp;\dfrac{\partial{f_3}}{\partial{v}}&amp;\dfrac{\partial{f_3}}{\partial{w}}\\
\end{pmatrix}
\]</span></p>
<ul>
<li><span class="math inline">\(F(x)\)</span> 在 <span class="math inline">\(x_0\)</span> 附近的泰勒展开
<ul>
<li>每一行对应一个多元函数的泰勒展开</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{align}
F(x)&amp;=F(x_0)+DF(x_0)(x-x_0)+O(x-x_0)^2\\
&amp;\approx F(x_0)+DF(x_0)(x-x_0)\\
\end{align}
\]</span></p>
<ul>
<li>多变量牛顿方法</li>
</ul>
<p><span class="math display">\[
0=F(r)=F(x_0)+DF(x_0)(r-x_0)
\]</span></p>
<h4 id="多变量牛顿方法">多变量牛顿方法</h4>
<p><span class="math display">\[
\begin{aligned}
\begin{array}{l}
x_0=初始估计向量\\
x_{k+1}=x_{k}-\big(DF(x_k)\big)^{-1}F(x_k)\\
\end{array}
\end{aligned}
\]</span></p>
<ul>
<li>利用高斯消去（<span class="math inline">\(\dfrac{n^2}{3}\)</span>）替代矩阵求逆（<span class="math inline">\(n^3\)</span>）</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
DF(x_k)s=-F(x_k)\\
x_{k+1}=x_{k}+s\\
\end{array}
\]</span></p>
<h3 id="broyden-方法">7.2 Broyden 方法</h3>
<ul>
<li>如果雅可比矩阵不好计算怎么办？
<ul>
<li><strong>得同时更新雅可比矩阵</strong></li>
</ul></li>
<li><strong><span style="color:red">看不懂了</span></strong></li>
</ul>
<p><img src="/2021/10/14/computation/pyr/03-2/image-20211014115632553.jpg" style="zoom:67%;"></p>
<ul>
<li>如果没有更好的选择，初始的雅可比矩阵可以使用单位阵</li>
</ul>
<h4 id="broyden-算法">Broyden 算法</h4>
<p><img src="/2021/10/14/computation/pyr/03-2/image-20211014115751474.jpg" style="zoom:67%;"></p>
<h4 id="broyden-算法-ii">Broyden 算法 II</h4>
<ul>
<li>避免矩阵求解步骤 <span class="math inline">\(A_i\delta_{i+1}=-F(x_i)\)</span></li>
<li>直接近似 <span class="math inline">\(DF\)</span> 的逆，而不是近似
<span class="math inline">\(DF\)</span></li>
<li>令 <span class="math inline">\(B_i=A_i^{-1}\)</span></li>
</ul>
<p><img src="/2021/10/14/computation/pyr/03-2/image-20211014120654109.jpg" style="zoom:67%;"></p>
<ul>
<li>算法</li>
</ul>
<p><img src="/2021/10/14/computation/pyr/03-2/image-20211014120719949.jpg" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.03.方程组(4)</title>
    <url>/2021/10/14/computation/pyr/03-3/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 2 章（方程组） + PPT（非线性方程组迭代求解）</li>
</ul>
<h1 id="非线性方程组迭代求解方法">非线性方程组迭代求解方法</h1>
<ul>
<li>PPT 补充</li>
</ul>
<h2 id="不动点迭代">1. 不动点迭代</h2>
<ul>
<li>一样的定义，<strong>多变量非线性方程组</strong></li>
</ul>
<p><span class="math display">\[
F(x)=0
\]</span></p>
<ul>
<li>不动点 <span class="math inline">\(p\)</span></li>
</ul>
<p><span class="math display">\[
p=G(p)
\]</span></p>
<ul>
<li>函数 <span class="math inline">\(g:\mathbb{R}^{n}\to{\mathbb{R}}\)</span>
定义在集合 <span class="math inline">\(D\in{\mathbb{R}^{n}}\)</span> 上,
当 <span class="math inline">\(p=G(p),p\in{D}\)</span> 为不动点.</li>
</ul>
<h3 id="函数连续">函数连续</h3>
<ul>
<li>函数 <span class="math inline">\(f:\mathbb{R}^{n}\to{\mathbb{R}}\)</span> 定义在
<span class="math inline">\(D\in{\mathbb{R}^{n}}\)</span> 上，如果函数
<span class="math inline">\(f\)</span> 的所有偏导数存在并且存在常数
<span class="math inline">\(\delta&gt;0,K&gt;0\)</span>，当 <span class="math inline">\(\Vert{x-x_0}\Vert&lt;\delta\)</span>，使得 <span class="math inline">\(\dfrac{\partial{f(x)}}{\partial{x_j}}\le{K},j=1,2,\cdots,n\)</span>
，则函数在 <span class="math inline">\(x_0\)</span> 连续</li>
</ul>
<h3 id="不动点定理">不动点定理</h3>
<ul>
<li>连续、自身映射、小于 <span class="math inline">\(\dfrac{1}{n}\)</span></li>
</ul>
<p><img src="/2021/10/14/computation/pyr/03-3/image-20211014225108596.png" style="zoom: 80%;"></p>
<ul>
<li><strong>充分不必要条件</strong></li>
</ul>
<h3 id="不动点迭代方法">不动点迭代方法</h3>
<h3 id="gauss-seidel-方法">Gauss-Seidel 方法</h3>
<ul>
<li>和之前相同，直接使用这一轮计算出来得到的值</li>
</ul>
<h2 id="牛顿法">2. 牛顿法</h2>
<ul>
<li>另外一种思路</li>
</ul>
<p><span class="math display">\[
G(x)=x-A(x)^{-1}F(x)
\]</span></p>
<ul>
<li><span class="math inline">\(B=A^{-1}\)</span></li>
</ul>
<p><span class="math display">\[
g_{i}(x)=x_i-\sum_{j=1}^{n}b_{ij}f_j(x)
\]</span></p>
<ul>
<li>导数为 0</li>
</ul>
<p><span class="math display">\[
\dfrac{\partial{g_{i}}}{\partial{x_k}}(x)=0
\]</span></p>
<ul>
<li>那么有如下式子
<ul>
<li><span class="math inline">\(f_{j}(x)=0\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/10/14/computation/pyr/03-3/image-20211014232137061.png" style="zoom: 80%;"></p>
<ul>
<li>可以得到 <span class="math inline">\(A=J(x)\)</span>
<ul>
<li><span class="math inline">\(J(x)\)</span>：雅可比矩阵（Jacobian）</li>
</ul></li>
</ul>
<p><img src="/2021/10/14/computation/pyr/03-3/image-20211014232502115.png" style="zoom: 80%;"></p>
<h3 id="牛顿方法的二阶收敛">牛顿方法的二阶收敛</h3>
<p><img src="/2021/10/14/computation/pyr/03-3/image-20211014232627252.png" style="zoom: 80%;"></p>
<ul>
<li>一旦获取在<strong>真实解附近</strong>的近似值，牛顿方法可以收敛极快</li>
</ul>
<h3 id="加速">加速</h3>
<ul>
<li>避免计算 <span class="math inline">\(J(x)^{-1}\)</span>：<strong>高斯消去替代</strong></li>
</ul>
<h2 id="拟牛顿方法">3. 拟牛顿方法</h2>
<h3 id="broyden-算法">Broyden 算法</h3>
<ul>
<li>利用每步中更新的近似矩阵替换牛顿方法中的雅各比矩阵</li>
<li><strong>超线性收敛</strong></li>
</ul>
<p><span class="math display">\[
\lim_{i\to\infty}\dfrac{\Vert{x^{(i+1)}-p}\Vert}{\Vert{x^{(i)}-p}\Vert}=0
\]</span></p>
<ul>
<li>使用差分方程近似偏导数
<ul>
<li><strong><span class="math inline">\(n^2\)</span>
次函数计算</strong></li>
</ul></li>
</ul>
<p><span class="math display">\[
\dfrac{\partial{f_j}}{\partial{x_k}}(x^{(i)})\approx\dfrac{f_j(x^{(i)}+e_{k}h)-f_j(x^{(i)})}{h}
\]</span></p>
<ul>
<li>其中</li>
</ul>
<p><span class="math display">\[
e_{k}=(0,0,\cdots,1,\cdots,0)
\]</span></p>
<h4 id="算法">算法</h4>
<p><img src="/2021/10/14/computation/pyr/03-3/image-20211015103052051.png" style="zoom:80%;"></p>
<ul>
<li>一个 <span class="math inline">\(n\)</span> 维向量的 <span class="math inline">\(v\)</span> 正交补向量一共有 <span class="math inline">\(n-1\)</span> 个
<ul>
<li>由 <span class="math inline">\(v\)</span> 可以生成 <span class="math inline">\(\mathbb{R}^n\)</span> 的一组正交基，剩下的 <span class="math inline">\(n-1\)</span> 个向量都和 <span class="math inline">\(v\)</span> 垂直</li>
</ul></li>
<li>那么此时我们有 <span class="math inline">\(n^2\)</span>
个方程，<strong>理论上</strong>可以解出 <span class="math inline">\(A_1\)</span>
<ul>
<li><span class="math inline">\(A_1(x^{(1)}-x^{(0)})=F(x^{(1)}-x^{(0)})\)</span>
中 <span class="math inline">\(n\)</span> 个</li>
<li><span class="math inline">\(\big(A_1-J(x^{(0)})\big)z=0\)</span> 中
<span class="math inline">\(n(n-1)\)</span> 个</li>
</ul></li>
<li><strong><span class="math inline">\(n\)</span>
次函数的函数计算</strong></li>
</ul>
<h4 id="与牛顿法的对比">与牛顿法的对比</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">Broyden</th>
<th style="text-align: center;">Newton</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">函数值计算次数</td>
<td style="text-align: center;"><span class="math inline">\(n\)</span></td>
<td style="text-align: center;"><span class="math inline">\(n^2+n\)</span><br>（雅可比矩阵 <span class="math inline">\(n\)</span> 次计算）</td>
</tr>
<tr class="even">
<td style="text-align: center;">解线性方程组</td>
<td style="text-align: center;"><span class="math inline">\(n^3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(n^3\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">超线性收敛</td>
<td style="text-align: center;">二次收敛</td>
</tr>
</tbody>
</table>
<h3 id="sherman-morrison-公式">Sherman-Morrison 公式</h3>
<ul>
<li>之前提到的 Broyden II 方法，直接更新 <span class="math inline">\(A^{-1}\)</span>，而不是 <span class="math inline">\(A\)</span></li>
</ul>
<h4 id="sherman-morrison-公式-1">Sherman-Morrison 公式</h4>
<ul>
<li>如果 <span class="math inline">\(A\)</span> 为非奇异矩阵，<span class="math inline">\(x\)</span> 与 <span class="math inline">\(y\)</span> 为向量, 则 <span class="math inline">\(A+xy^{t}\)</span> 为非奇异矩阵，如果 <span class="math inline">\(y^{t}A^{-1}x\ne-1\)</span> ，则</li>
</ul>
<p><span class="math display">\[
(A+xy^{t})^{-1}=A^{-1}-\dfrac{A^{-1}xy^{t}A^{-1}}{1+y^{t}A^{-1}x}
\]</span></p>
<ul>
<li>如此可以在迭代的过程中避免求逆</li>
</ul>
<p><img src="/2021/10/14/computation/pyr/03-3/image-20211015110203320.png" style="zoom: 50%;"></p>
<ul>
<li>Broyden 方法一般收敛更慢，但是计算相对简单</li>
</ul>
<h2 id="最速下降方法">4. 最速下降方法</h2>
<ul>
<li>将<strong>求非线性方程组的解</strong>转化为<strong>函数最小化</strong>问题</li>
</ul>
<h3 id="转化">转化</h3>
<ul>
<li>考虑非线性方程组</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
f_{1}(x_{1},x_{2},\cdots,x_{n})=0\\
f_{2}(x_{1},x_{2},\cdots,x_{n})=0\\
\cdots\\
f_{n}(x_{1},x_{2},\cdots,x_{n})=0\\
\end{array}
\]</span></p>
<ul>
<li>该非线性方程组的解 <span class="math inline">\(x=(x_{1},x_{2},\cdots,x_{n})^{t}\)</span>
，使得如下函数 <span class="math inline">\(g\)</span> 具有最小值</li>
</ul>
<p><span class="math display">\[
g(x_{1},x_{2},\cdots,x_{n})=\sum_{i=1}^{n}\big[f_{i}(x_{1},x_{2},\cdots,x_{n})\big]^{2}
\]</span></p>
<h3 id="算法流程">算法流程</h3>
<p><img src="/2021/10/14/computation/pyr/03-3/image-20211015111500233.png" style="zoom:80%;"></p>
<h3 id="定义">定义</h3>
<h4 id="梯度">梯度</h4>
<ul>
<li>函数 <span class="math inline">\(g:\mathbb{R}^{n}\to{\mathbb{R}}\)</span> , 在
<span class="math inline">\(x=(x_{1},x_{2},\cdots,x_{n})^{t}\)</span>
的梯度定义如下</li>
</ul>
<p><span class="math display">\[
\nabla{g(x)}=\left({\dfrac{\partial{g}}{\partial{x_1}}(x)},{\dfrac{\partial{g}}{\partial{x_2}}(x)},\cdots,{\dfrac{\partial{g}}{\partial{x_n}}(x)}\right)^{t}
\]</span></p>
<ul>
<li>当在 <span class="math inline">\(x\)</span> 点的梯度为 <span class="math inline">\(0\)</span> 向量时，多变量函数在 <span class="math inline">\(x\)</span> 点具有极小值</li>
</ul>
<h4 id="单位向量">单位向量</h4>
<ul>
<li>单位向量 <span class="math inline">\(v\)</span></li>
</ul>
<p><span class="math display">\[
\Vert{v}\Vert_2^2=\sum_{i=1}^{n}v_i^{2}=1
\]</span></p>
<h4 id="方向导数">方向导数</h4>
<ul>
<li><span class="math inline">\(D_{v}g(x)\)</span> 度量函数 <span class="math inline">\(g\)</span> 值在方向 <span class="math inline">\(v\)</span> 上的变化</li>
</ul>
<p><span class="math display">\[
D_{v}g(x)=\lim_{h\to0}\dfrac{1}{h}\left[g(x+hv)-g(x)\right]=v^{t}\cdot\nabla{g(x)}
\]</span></p>
<ul>
<li>函数 <span class="math inline">\(g\)</span>
的最速下降方向为负梯度方向 <span class="math inline">\(-\nabla{g(x)}\)</span></li>
</ul>
<h3 id="算法-1">算法</h3>
<ul>
<li><span class="math inline">\(x^{(1)}=x^{(0)}-\alpha\nabla{g(x)}\)</span></li>
<li>确定 <span class="math inline">\(\alpha\)</span> 使得如下函数 <span class="math inline">\(h\)</span> 最小化</li>
</ul>
<p><span class="math display">\[
h(\alpha)=g\left({x^{(0)}-\alpha\nabla{g(x^{(0)})}}\right)
\]</span></p>
<ul>
<li>如何选择 <span class="math inline">\(\alpha\)</span>
<ul>
<li>多项式近似原始复杂的函数函数，利用多项式极值代替函数极值</li>
</ul></li>
<li><span class="math inline">\(\alpha_1&lt;\alpha_2&lt;\alpha_3\)</span>，计算函数值
<span class="math inline">\(h(\alpha)\)</span>，估计多项式极值</li>
<li>构造二阶插值多项式 <span class="math inline">\(P(x)\)</span></li>
<li>确定 <span class="math inline">\(P(\hat{\alpha}),\hat{\alpha}\in[\alpha_1,\alpha_3]\)</span>，使得函数
<span class="math inline">\(h(\alpha)\)</span> 最小化</li>
<li><span class="math inline">\(x^{(1)}=x^{(0)}-\hat{\alpha}\nabla{g(x)}\)</span></li>
</ul>
<h4 id="如何选择这三个点">如何选择这三个点</h4>
<ul>
<li><span class="math inline">\(\alpha_1=0:h(\alpha_1)=h(0)=g(x^{(0)})\)</span></li>
<li>选定 <span class="math inline">\(\alpha_3\)</span> 满足 <span class="math inline">\(h(\alpha_3)&lt;h(\alpha_1)\)</span>
<ul>
<li>初始选择 <span class="math inline">\(\alpha_3=1\)</span></li>
<li>当 <span class="math inline">\(h(\alpha_3)&gt;h(\alpha_1)\)</span>，令 <span class="math inline">\(\alpha_3=2^{-k}\)</span>，直到 <span class="math inline">\(h(\alpha_3)&lt;h(\alpha_1)\)</span></li>
<li>因为是负梯度方向，一定能够取到满足上面的 <span class="math inline">\(\alpha_3\)</span></li>
</ul></li>
<li><span class="math inline">\(\alpha_2\)</span> 可以选择 <span class="math inline">\(\dfrac{\alpha_3}{2}\)</span></li>
<li>根据我们的选择，多项式 <span class="math inline">\(P\)</span>
的极值点可以出现在临界点或者区间的右端点</li>
</ul>
<h2 id="同伦和延拓方法">5. 同伦和延拓方法</h2>
<ul>
<li>考虑一组问题 <span class="math inline">\(G:[0,1]\)</span></li>
</ul>
<p><span class="math display">\[
G:[0,1]\times\mathbb{R}^{n}\to\mathbb{R}^{n}
\]</span></p>
<p><span class="math display">\[
G(\lambda,x)=\lambda{F(x)}+(1-\lambda)[F(x)-F(x{(0)})]=F(x)+(1-\lambda)F(x{(0)})
\]</span></p>
<ul>
<li><strong>同伦与延拓</strong></li>
</ul>
<p><img src="/2021/10/14/computation/pyr/03-3/image-20211015114551294.png" alt="image-20211015114551294" style="zoom:80%;"></p>
<h3 id="问题描述">问题描述</h3>
<ul>
<li>从 <span class="math inline">\(G(0, x)=0\)</span> 的已知解 <span class="math inline">\(x(0)\)</span>，求解函数 <span class="math inline">\(G (1,x)\)</span> 的根 <span class="math inline">\(x(1)=x^{\ast}\)</span>
<ul>
<li><span class="math inline">\(G(\lambda,x),\lambda\in[0,1]\)</span></li>
</ul></li>
<li>假设 <span class="math inline">\(x(\lambda)\)</span> 是 <span class="math inline">\(G(\lambda,x)=0\)</span> 的唯一解</li>
<li>如果函数 <span class="math inline">\(\lambda\to{x(\lambda)},G(\lambda,x)\)</span> 可微,
对 <span class="math inline">\(G(\lambda,x)=0\)</span> 关于 <span class="math inline">\(\lambda\)</span> 求导</li>
<li><span class="math inline">\(G(\lambda,x)\)</span> 对 <span class="math inline">\(\lambda\)</span> 求导</li>
</ul>
<p><span class="math display">\[
\dfrac{\partial{G(\lambda,x(\lambda))}}{\partial{\lambda}}
+\dfrac{\partial{G(\lambda,x(\lambda))}}{\partial{x}}x&#39;(\lambda)
=0
\]</span></p>
<ul>
<li>得到</li>
</ul>
<p><span class="math display">\[
x&#39;(\lambda)=-\left[{\dfrac{\partial{G(\lambda,x(\lambda))}}{\partial{x}}}\right]^{-1}\dfrac{\partial{G(\lambda,x(\lambda))}}{\partial{\lambda}}
\]</span></p>
<ul>
<li>转化为一个<strong>常微分方程的初值问题</strong>
<ul>
<li>初值 <span class="math inline">\(x(0)\)</span> 已知</li>
<li>知道 <span class="math inline">\(x&#39;(\lambda),\lambda\in[0,1]\)</span></li>
</ul></li>
</ul>
<h3 id="细节">细节</h3>
<p><span class="math display">\[
G(\lambda,x)=F(x)+(\lambda-1)F(x{(0)})
\]</span></p>
<ul>
<li>两个偏导数结果如下</li>
</ul>
<p><span class="math display">\[
\dfrac{\partial{G(\lambda,x(\lambda))}}{\partial{x}}
=\dfrac{\partial{F(x(\lambda))}}{\partial{x}}
=J(x(\lambda))
\]</span></p>
<p><img src="/2021/10/14/computation/pyr/03-3/image-20211015131703628.png" style="zoom:80%;">
<span class="math display">\[
\dfrac{\partial{G(\lambda,x(\lambda))}}{\partial{\lambda}}
=F(x(0))
\]</span></p>
<ul>
<li><strong>常微分方程的初值问题</strong></li>
</ul>
<p><span class="math display">\[
x&#39;(\lambda)={J\big(x(\lambda)\big)}^{-1}F(x(0)),\lambda\in[0,1]
\]</span></p>
<h3 id="完整描述">完整描述</h3>
<p><img src="/2021/10/14/computation/pyr/03-3/image-20211015133051150.png" style="zoom:80%;"></p>
<h3 id="解法">解法</h3>
<ul>
<li>Runge Kutta 方法等</li>
</ul>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.04.插值(2)</title>
    <url>/2021/10/24/computation/pyr/04-1/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 3 章（插值） + PPT（多项式插值）</li>
</ul>
<h1 id="插值">插值</h1>
<h2 id="三次样条">4. 三次样条</h2>
<ul>
<li>在多项式插值中，多项式给出的<strong>单一公式</strong>满足所有数据点</li>
<li>而样条则使用<strong>多个公式</strong>，其中每个都是低阶多项式，来通过所有数据点</li>
<li>线性样条：<strong>直接把相邻的点连起来</strong></li>
</ul>
<p><img src="/2021/10/24/computation/pyr/04-1/image-20211024185050466.jpg" style="zoom:80%;"></p>
<h3 id="样条的性质">4.1 样条的性质</h3>
<h4 id="三次样条-1">三次样条</h4>
<ul>
<li>给定 <span class="math inline">\(n\)</span> 个点，<span class="math inline">\((x_1,y_1),\cdots,(x_n,y_n)\)</span>，其中 <span class="math inline">\(x_i\)</span> 升序，通过点 <span class="math inline">\((x_1,y_1),\cdots,(x_n,y_n)\)</span>
的<strong>三次样条</strong> <span class="math inline">\(S(x)\)</span>
是一组三次多项式</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
S_1(x)=y_1+b_1(x-x_1)+c_1(x-x_1)^2+d_1(x-x_1)^3,x\in[x_1,x_2]\\
S_2(x)=y_2+b_2(x-x_2)+c_2(x-x_2)^2+d_2(x-x_2)^3,x\in[x_2,x_3]\\
\cdots\\
S_{n-1}(x)=y_{n-1}+b_{n-1}(x-x_{n-1})+c_{n-1}(x-x_{n-1})^{2}+d_{n-1}(x-x_{n-1})^3,x\in[x_{n-1},x_n]\\
\end{array}
\]</span></p>
<ul>
<li>要求具备如下性质</li>
</ul>
<p><span class="math display">\[
\begin{array}{l}
S_i(x_i)=y_i,S_i(x_{i+1})=y_{i+1},i=1,\cdots,n-1\\
S_{i-1}&#39;(x_i)=S_i&#39;(x_i),i=2,\cdots,n-1\\
S_{i-1}&#39;&#39;(x_i)=S_i&#39;&#39;(x_i),i=2,\cdots,n-1\\
\end{array}
\]</span></p>
<ul>
<li>连接点：<strong>连续</strong>、<strong>斜率相同</strong>、<strong>曲率相同</strong></li>
<li>求解参数
<ul>
<li>未知数：<span class="math inline">\(3(n-1)=3n-3\)</span></li>
<li>方程：<span class="math inline">\((n-1)+(n-2)+(n-2)=3n-5\)</span></li>
<li>因此存在<strong>无穷多</strong>的三次样条曲线</li>
</ul></li>
</ul>
<h4 id="自然样条">自然样条</h4>
<ul>
<li><span class="math inline">\(S&#39;&#39;(x_1)=S&#39;&#39;(x_n)=0\)</span></li>
<li>加上这个条件可以唯一解得三次样条
<ul>
<li><strong>自然三次样条</strong></li>
</ul></li>
<li>可以添加其他<strong>边界条件</strong>形成其他样条曲线</li>
</ul>
<p><img src="/2021/10/24/computation/pyr/04-1/image-20211024191107195.jpg" style="zoom:80%;"></p>
<ul>
<li>引入记号
<ul>
<li><span class="math inline">\(\delta_i=x_{i+1}-x_i\)</span></li>
<li><span class="math inline">\(\Delta_i=y_{i+1}-y_i\)</span></li>
</ul></li>
<li>引入额外未知变量 <span class="math inline">\(c_n=\dfrac{S_{n-1}&#39;&#39;(x_n)}{2}\)</span>
<ul>
<li>让下一行多了一个方程</li>
</ul></li>
<li>(3.21)</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
d_i=\dfrac{c_{i+1}-c_i}{3\delta_i}\\
i=1,\cdots,n-1\
\end{array}
\]</span></p>
<ul>
<li>(3.19)
<ul>
<li>代入 <span class="math inline">\(d_i\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
b_i=\dfrac{\Delta_i}{\delta_i}-c_i\delta_i-d_i\delta_i^2=\dfrac{\Delta_i}{\delta_i}-\dfrac{\delta_i}{3}(2c_i+c_{i+1})\\
i=1,\cdots,n-1\
\end{array}
\]</span></p>
<ul>
<li>(3.20)
<ul>
<li>代入 <span class="math inline">\(d_i,b_i\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
c_i\delta_i+c_{i+1}(2\delta_i+2\delta_{i+1})+c_{i+2}(2\delta_{i+1})=3\left(\dfrac{\Delta_{i+1}}{\delta_{i+1}}-\dfrac{\Delta_i}{\delta_i}\right)\\
i=1,\cdots,n-2
\end{array}
\]</span></p>
<ul>
<li>加上自然样条的限制
<ul>
<li><strong>严格对角占优，有唯一解</strong></li>
</ul></li>
</ul>
<p><img src="/2021/10/24/computation/pyr/04-1/image-20211024194454360.jpg"></p>
<ul>
<li>求解得到 <span class="math inline">\(c_i\)</span>，从而计算得到
<span class="math inline">\(b_i,d_i\)</span></li>
</ul>
<h4 id="自然三次样条">自然三次样条</h4>
<p><img src="/2021/10/24/computation/pyr/04-1/image-20211024194723847.jpg" style="zoom:80%;"></p>
<h4 id="不同边界条件">不同边界条件</h4>
<p><img src="/2021/10/24/computation/pyr/04-1/image-20211024194909058.jpg" style="zoom:80%;"></p>
<ul>
<li>不同效果如下</li>
</ul>
<p><img src="/2021/10/24/computation/pyr/04-1/image-20211024194945369.jpg" style="zoom:80%;"></p>
<h3 id="端点条件">4.2 端点条件</h3>
<h4 id="曲率调整三次样条">曲率调整三次样条</h4>
<ul>
<li>端点曲率是两个用户设定值，而不是 <span class="math inline">\(0\)</span></li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
S&#39;&#39;(x_1)=v_1\\
S&#39;&#39;(x_n)=v_2\\
\end{array}
\]</span></p>
<ul>
<li>矩阵中表现如下（还是严格对角占优）</li>
</ul>
<p><img src="/2021/10/24/computation/pyr/04-1/image-20211024195242297.jpg" style="zoom:80%;"></p>
<h4 id="钳制三次样条">钳制三次样条</h4>
<ul>
<li>端点的一阶导数为用户设定值</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
S&#39;(x_1)=v_1\\
S&#39;(x_n)=v_2\\
\end{array}
\]</span></p>
<ul>
<li>表示为</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
b_1=\dfrac{\Delta_1}{\delta_1}-\dfrac{\delta_1}{3}(2c_1+c_2)=v_1\\
b_{n-1}+2c_{n-1}\delta_{n-1}+3d_{n-1}\delta_{n-1}^2=v_2\\
\end{array}
\]</span></p>
<ul>
<li>转化为</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
c_1(2\delta_1)+c_2(\delta_1)=3(v_1-\dfrac{\Delta_1}{\delta_1})\\
c_{n-1}(\delta_{n-1})+c_n(2\delta_{n-1})=3(v_2-\dfrac{\Delta_{n-1}}{\delta_{n-1}})\\
\end{array}
\]</span></p>
<ul>
<li>矩阵中表现为（还是严格对角占优）</li>
</ul>
<p><img src="/2021/10/24/computation/pyr/04-1/image-20211024201111699.jpg" style="zoom:80%;"></p>
<h4 id="抛物线端点的三次样条">抛物线端点的三次样条</h4>
<ul>
<li><span class="math inline">\(d_1=d_n=0\)</span></li>
<li>让样条的起始和结束至多为 <span class="math inline">\(2\)</span>
阶</li>
<li>等价于：<span class="math inline">\(c_1=c_2,c_{n-1}=c_n\)</span></li>
<li>矩阵中表现为（<strong>不是严格对角占优</strong>）</li>
</ul>
<p><img src="/2021/10/24/computation/pyr/04-1/image-20211024202043627.jpg" style="zoom:80%;"></p>
<ul>
<li>通过变换我们发现还是具有唯一解
<ul>
<li>假设数据点的个数 <span class="math inline">\(n\ge3\)</span></li>
<li>通过用 <span class="math inline">\(c_2\)</span> 替换 <span class="math inline">\(c_1\)</span>，<span class="math inline">\(c_{n-1}\)</span> 替换 <span class="math inline">\(c_n\)</span>，我们发现矩阵方程简化为关于 <span class="math inline">\(c_2,\cdots,c_{n-2}\)</span> 的 <span class="math inline">\((n-2)\times(n-2)\)</span>
的<strong>严格对角占优矩阵</strong></li>
<li><strong>唯一解</strong></li>
</ul></li>
</ul>
<h4 id="非纽结三次样条">非纽结三次样条</h4>
<ul>
<li>起始（终止）曲线的两端三阶导数相同 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(d_1=d_2,d_{n-2}=d_{n-1}\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(S_1=S_2,S_{n-1}=S_{n-2}\)</span></li>
<li>式子</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
\dfrac{c_2-c_1}{\delta_1}=\dfrac{c_3-c_2}{\delta_2}\\
\dfrac{c_{n-2}-c_{n-1}}{\delta_{n-1}}=\dfrac{c_{n-1}-c_{n}}{\delta_{n}}\\
\end{array}
\]</span></p>
<p><span class="math display">\[
\begin{array}{c}
c_1(\delta_2)-c_2(\delta_1+\delta_2)+c_3(\delta_1)=0\\
c_{n-2}(\delta_{n-1})-c_{n-1}(\delta_{n-2}+\delta_{n-1})+c_{n}(\delta_{n-2})=0\\
\end{array}
\]</span></p>
<ul>
<li>矩阵中表现为</li>
</ul>
<p><img src="/2021/10/24/computation/pyr/04-1/image-20211024203724858.jpg" style="zoom:80%;"></p>
<h2 id="贝塞尔曲线">5. 贝塞尔曲线</h2>
<p><img src="/2021/10/24/computation/pyr/04-1/image-20211024203918076.jpg" style="zoom: 80%;"></p>
<ul>
<li>平面贝塞尔曲线由 <span class="math inline">\(4\)</span> 个点组成
<ul>
<li>起点 <span class="math inline">\((x_1,y_1)\)</span>，起点 <span class="math inline">\((x_4,y_4)\)</span></li>
<li>控制点 <span class="math inline">\((x_2,y_3),(x_3,y_3)\)</span></li>
<li>曲线以切线方向 <span class="math inline">\((x_2-x_1,y_2-y_1)\)</span> 离开 <span class="math inline">\((x_1,y_1)\)</span>，以切线方向 <span class="math inline">\((x_4-x_3,y_4-y_3)\)</span> 回到 <span class="math inline">\((x_4,y_4)\)</span></li>
</ul></li>
<li></li>
</ul>
<h4 id="贝塞尔曲线-1">贝塞尔曲线</h4>
<p><img src="/2021/10/24/computation/pyr/04-1/image-20211024204137544.jpg" style="zoom:80%;"></p>
<ul>
<li>性质</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
x(0)=x_1\\
x&#39;(0)=3(x_2-x_1)\\
x(1)=x_4\\
x&#39;(1)=3(x_4-x_3)\\
\end{array}
\]</span></p>
<ul>
<li>控制点与端点一致的时候，贝塞尔曲线退化为直线段</li>
<li>贝塞尔曲线的绘制
<ul>
<li>python 的 turtle 库实现
<ul>
<li><a href="/utils/show_code/index.html?computation/pyr/Bezier/Bezier.py">Bezier</a></li>
</ul></li>
<li>字体文件
<ul>
<li><a href="/resources/Code/computation/pyr/Bezier/f.txt">f</a></li>
<li><a href="/resources/Code/computation/pyr/Bezier/T.txt">T</a></li>
<li><a href="/resources/Code/computation/pyr/Bezier/5.txt">5</a></li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.04.插值(3)</title>
    <url>/2021/10/25/computation/pyr/04-2/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 3 章（插值） + PPT（多项式插值）</li>
</ul>
<h1 id="插值">插值</h1>
<ul>
<li>PPT 补充</li>
</ul>
<h2 id="多项式">1. 多项式</h2>
<h3 id="weierstrass-近似定理">Weierstrass 近似定理</h3>
<ul>
<li>假设函数 <span class="math inline">\(f\)</span> 是 <span class="math inline">\([a,b]\)</span> 区间上的连续函数，对于 <span class="math inline">\(\epsilon&gt;0\)</span>，存在<strong>多项式</strong>
<span class="math inline">\(P(x)\)</span> 使得对于 <span class="math inline">\([a,b]\)</span> 区间上任意的 <span class="math inline">\(x\)</span>，<span class="math inline">\(\vert{f(x)-p(x)}\vert&lt;\epsilon\)</span></li>
</ul>
<p><img src="/2021/10/25/computation/pyr/04-2/image-20211025160457597.png" style="zoom:80%;"></p>
<ul>
<li><strong>维尔斯特拉斯定理</strong>给出多项式的近似误差界</li>
<li>讨论了近似多项式的存在性</li>
</ul>
<h3 id="泰勒多项式">泰勒多项式</h3>
<ul>
<li>可以给出连续可导函数在<strong>某点附近</strong>的一个近似多项式
<ul>
<li>泰勒多项式与给定函数在<strong>某一特定点</strong>上尽可能一致，但它们仅在该点附近保证精度</li>
</ul></li>
</ul>
<p><span class="math display">\[
f(x)=\sum_{k=0}^{n}\dfrac{f^{(k)}(x_0)}{k!}(x-x_0)^k+\dfrac{f^{(n+1)}(\xi(x_0))}{(n+1)!}(x-x_0)^{n+1}
\]</span></p>
<ul>
<li>近似多项式 + 截断误差</li>
</ul>
<h2 id="拉格朗日多项式">2. 拉格朗日多项式</h2>
<h3 id="插值多项式">插值多项式</h3>
<ul>
<li>插值多项式具体形式见前面的 <a href="/2021/10/23/computation/pyr/04/">note</a></li>
<li>这里一共 <span class="math inline">\(n+1\)</span> 个点，<span class="math inline">\((x_i,f(x_i)),i=0,\cdots,n+1\)</span></li>
</ul>
<p><span class="math display">\[
p(x)=\sum_{k=1}^{n}f(x_k)L_{n,k}(x)
\]</span></p>
<h3 id="余项">余项</h3>
<p><span class="math display">\[
f(x)=p(x)+{\color{blue}\dfrac{f^{(n+1)}(\xi(x))}{(n+1)!}(x-x_0)(x-x_1)\cdots(x-x_n)}
\]</span></p>
<ul>
<li>证明：<a href="/2021/10/23/computation/pyr/04/">note</a></li>
<li>形式简单，实际操作计算困难，<span class="math inline">\(f^{(n+1)},\xi(x)\)</span></li>
<li><strong>内插</strong>与<strong>外推</strong>
<ul>
<li>从误差多项式看，内插比外推更准确</li>
</ul></li>
<li>一般来说，<strong>误差随着阶数的增加而减小</strong>，误差分布在所有给定节点上
<ul>
<li>分母：<span class="math inline">\((n+1)!\)</span></li>
</ul></li>
</ul>
<h3 id="荣格现象">荣格现象</h3>
<ul>
<li>插值次数越高，插值结果越偏离原函数的现象称为龙格现象</li>
<li>荣格函数 <span class="math inline">\(\dfrac{1}{1+25x^2}\)</span>
<ul>
<li>对于 <span class="math inline">\(n\)</span>
阶的插值多项式,在区间的端点附近出现了震荡</li>
<li><span style="color:red">原始函数f</span>，<span style="color:blue">5阶插值多项式</span>，<span style="color:#30ef3a">9阶插值多项式</span></li>
</ul></li>
</ul>
<p><img src="/2021/10/25/computation/pyr/04-2/image-20211025230832687.png" style="zoom: 80%;"></p>
<ul>
<li>原因：对于荣格函数，<strong>其高阶导数在区间端点数值急剧上升</strong></li>
</ul>
<h3 id="重用低阶拉格朗日多项式">重用低阶拉格朗日多项式</h3>
<ul>
<li><span class="math inline">\(k\)</span> - 点拉格朗日多项式
<ul>
<li><span class="math inline">\(k\)</span> 个整数 <span class="math inline">\(m_1,m_2,\cdots,m_k\)</span>，<span class="math inline">\(0\le m_i\le n\)</span></li>
<li><span class="math inline">\(P_{m_1,\cdots,m_k}(x)\)</span>
表示定义在 <span class="math inline">\(k\)</span> 点 <span class="math inline">\(x_{m_1},\cdots,x_{m_k}\)</span> 的多项式</li>
</ul></li>
<li><strong>使用低阶的拉格朗日多项式生成高阶的多项式</strong></li>
</ul>
<h4 id="递推公式nevilles-方法">递推公式：Neville's 方法</h4>
<ul>
<li>函数 <span class="math inline">\(f\)</span> 定义在 <span class="math inline">\(k+1\)</span> 个节点 <span class="math inline">\(x_0,\cdots,x_{k}\)</span> 上</li>
<li><span class="math inline">\(k\)</span> 阶拉格朗日多项式 <span class="math inline">\(P(x)\)</span></li>
<li><span class="math inline">\(i\ne j\)</span></li>
</ul>
<p><span class="math display">\[
P(x)=\dfrac{(x-x_j)P_{0,1,\cdots,j-1,j+1,\cdots,k}(x)-(x-x_i)P_{0,1,\cdots,i-1,i+1,\cdots,k}}{x_i-x_j}
\]</span></p>
<h4 id="递推公式证明">递推公式证明</h4>
<ul>
<li><span class="math inline">\(r\ne i,j\)</span></li>
</ul>
<p><span class="math display">\[
P(x_r)=\dfrac{f(x_r)(x_r-x_j)-f(x_r)(x_r-x_i)}{(x_i-x_j)}=f(x_r)
\]</span></p>
<ul>
<li><span class="math inline">\(r=i\)</span></li>
</ul>
<p><span class="math display">\[
P(x_r)=P(x_i)=\dfrac{(x_i-x_j)f(x_i)}{(x_i-x_j)}=f(x_i)
\]</span></p>
<ul>
<li><span class="math inline">\(r=j\)</span> 同理</li>
</ul>
<h4 id="使用递推公式">使用递推公式</h4>
<p><img src="/2021/10/25/computation/pyr/04-2/image-20211026100530498.png" style="zoom:80%;"></p>
<h2 id="牛顿差分多项式">3. 牛顿差分多项式</h2>
<h3 id="差商">差商</h3>
<ul>
<li>0 阶差商</li>
</ul>
<p><span class="math display">\[
f[x_i]=f(x_i)
\]</span></p>
<ul>
<li>1 阶差商</li>
</ul>
<p><span class="math display">\[
f[x_i,x_{i+1}]=\dfrac{f[x_{i+1}]-f[x_i]}{x_{i+1}-x_i}
\]</span></p>
<ul>
<li>2 阶差商</li>
</ul>
<p><span class="math display">\[
f[x_i,x_{i+1},x_{i+2}]=\dfrac{f[x_{i+1},x_{i+2}]-f[x_i,x_{i+1}]}{x_{i+2}-x_i}
\]</span></p>
<ul>
<li>k 阶差商</li>
</ul>
<p><span class="math display">\[
f[x_i,\cdots,x_{i+k}]=\dfrac{f[x_{i+1},\cdots,x_{i+k}]-f[x_i,\cdots,x_{i+k-1}]}{x_{i+k}-x_i}
\]</span></p>
<h3 id="n-阶牛顿前向差分多项式">n 阶牛顿前向差分多项式</h3>
<ul>
<li><span class="math inline">\(n+1\)</span> 点插值</li>
</ul>
<p><span class="math display">\[
P_n(x)=f[x_0]+\sum_{k=1}^{n}f[x_0,\cdots,x_k](x-x_0)\cdots(x-x_{k-1})
\]</span></p>
<h3 id="前向差分与后向差分">前向差分与后向差分</h3>
<ul>
<li>等间距公式</li>
</ul>
<p><span class="math display">\[
x_i=x_0+ih,\qquad(i=0,\cdots,n)
\]</span></p>
<ul>
<li>前向差分</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
\Delta{f_i}=f_{i+1}-f_i\\
\Delta^{k}{f_i}=\Delta^{k-1}(\Delta{f_i})=\Delta^{k-1}f_{i+1}-\Delta^{k-1}f_i
\end{array}
\]</span></p>
<ul>
<li>后向差分</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
\nabla{f_i}=f_{i+1}-f_i\\
\nabla^{k}{f_i}=\nabla^{k-1}(\nabla{f_i})=\nabla^{k-1}f_{i+1}-\nabla^{k-1}f_i
\end{array}
\]</span></p>
<h3 id="牛顿前向差分与后向差分">牛顿前向差分与后向差分</h3>
<h4 id="前向差分">前向差分</h4>
<ul>
<li>等间距</li>
</ul>
<p><span class="math display">\[
x_i=x_0+ih
\]</span></p>
<ul>
<li><span class="math inline">\(x\)</span> 的另一种表示</li>
</ul>
<p><span class="math display">\[
x=x_0+th
\]</span></p>
<ul>
<li>差分公式</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
P_n(x)&amp;=f[x_0]+\sum_{k=1}^{n}f[x_0,\cdots,x_k](x-x_0)\cdots(x-x_{k-1})\\
P_n(x)=P_n(x_0+th)&amp;=f[x_0]+\sum_{k=1}^{n}\dfrac{\Delta^{k}f(x_0)}{k!h^{k}}t(t-1)\cdots(t-k+1)h^{k}\\
&amp;=f[x_0]+\sum_{k=1}^{n}\dfrac{\Delta^{k}f(x_0)}{k!h^{k}}{t \choose
k}k!h^{k}\\
&amp;=f[x_0]+\sum_{k=1}^{n}{t \choose k}\Delta^{k}f(x_0)\\
&amp;=\sum_{k=0}^{n}{t \choose k}\Delta^{k}f(x_0)\\
\end{aligned}
\]</span></p>
<ul>
<li>误差</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
R_{n}(x)&amp;=\dfrac{f^{(n+1)}(\xi(x))}{(n+1)!}(x-x_0)(x-x_1)\cdots(x-x_n)\\
&amp;=\dfrac{f^{(n+1)}(\xi(x))}{(n+1)!}t(t-1)\cdots(t-n)h^{n+1},\quad\xi(x)\in[x_0,x_n]\\
\end{aligned}
\]</span></p>
<h4 id="后向差分">后向差分</h4>
<ul>
<li><p>类似的有如下式子</p></li>
<li><p>等间距</p></li>
</ul>
<p><span class="math display">\[
x_i=x_0+ih=x_n-(n-i)h
\]</span></p>
<ul>
<li><span class="math inline">\(x\)</span> 的另一种表示</li>
</ul>
<p><span class="math display">\[
x=x_n+th
\]</span></p>
<ul>
<li>差分公式</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
P_n(x)&amp;=f[x_n]+\sum_{k=1}^{n}f[x_{n},\cdots,x_{n-k}](x-x_{n})\cdots(x-x_{n-k+1})\\
P_n(x)=P_n(x_0+th)&amp;=f[x_n]+\sum_{k=1}^{n}\dfrac{\nabla^{k}f(x_0)}{k!h^{k}}t(t+1)\cdots(t+k-1)h^{k}\\
&amp;=f[x_n]+\sum_{k=1}^{n}\dfrac{\nabla^{k}f(x_0)}{k!h^{k}}(-1)^{k}(-t)(-t-1)\cdots(-t-k+1)h^{k}\\
&amp;=f[x_n]+\sum_{k=1}^{n}\dfrac{\nabla^{k}f(x_0)}{k!h^{k}}(-1)^{k}{-t
\choose k}k!h^{k}\\
&amp;=f[x_n]+\sum_{k=1}^{n}(-1)^{k}{-t \choose k}\nabla^{k}f(x_0)\\
&amp;=\sum_{k=0}^{n}(-1)^{k}{-t \choose k}\nabla^{k}f(x_0)\\
\end{aligned}
\]</span></p>
<ul>
<li>误差（一样）</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
R_{n}(x)&amp;=\dfrac{f^{(n+1)}(\xi(x))}{(n+1)!}(x-x_0)(x-x_1)\cdots(x-x_n)\\
&amp;=\dfrac{f^{(n+1)}(\xi(x))}{(n+1)!}t(t-1)\cdots(t-n)h^{n+1},\quad\xi(x)\in[x_0,x_n]\\
\end{aligned}
\]</span></p>
<h4 id="选择">选择</h4>
<ul>
<li>在计算机中存在机器精度的问题，针对不同位置的数据，我们会选择使用前向差分还是后向差分
<ul>
<li>估计数据离 <span class="math inline">\(x_0\)</span>
更近：前向差分</li>
<li>估计数据离 <span class="math inline">\(x_n\)</span>
更近：后向差分</li>
</ul></li>
</ul>
<h2 id="厄米特多项式">4. 厄米特多项式</h2>
<ul>
<li>厄米特插值多项式 <span class="math inline">\(\psi\)</span>
<ul>
<li>多项式与函数在 <span class="math inline">\(n+1\)</span>
个节点上一致</li>
<li>切线方向也一致</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
\psi(x_i)=f(x_i)\\
\psi&#39;(x_i)=f&#39;(x_i)\\
\end{array}
\]</span></p>
<h3 id="定理">定理</h3>
<ul>
<li>如果函数 <span class="math inline">\(f\)</span> 是连续函数 <span class="math inline">\(f\in C[a,b]\)</span>，<span class="math inline">\(x_1,\cdots,x_n\in[a,b]\)</span>，在节点 <span class="math inline">\(x_1,\cdots,x_n\)</span> 满足 <span class="math inline">\(f\)</span> 与 <span class="math inline">\(f&#39;\)</span> 的至多 <span class="math inline">\(2n+1\)</span> 阶厄米特多项式定义如下</li>
</ul>
<p><span class="math display">\[
H_{2n+1}(x)=\sum_{j=0}^{n}f(x_j)H_{n,j}(x)+\sum_{j=1}^{n}f&#39;(x_j)\hat{H}_{n,j}(x)
\]</span></p>
<ul>
<li>其中</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
H_{n,j}(x)=[1-2(x-x_j)L&#39;_{n,j}(x_j)]L^{2}_{n,j}(x)\\
\hat{H}_{n,j}(x)=(x-x_j)L^{2}_{n,j}(x)
\end{array}
\]</span></p>
<ul>
<li>若 <span class="math inline">\(f\in
C^{2n+2}[a,b]\)</span>，则余项</li>
</ul>
<p><span class="math display">\[
f(x)-H_{2n+1}(x)=\dfrac{(x-x_0)^2\cdots(x-x_n)^2}{(2n+2)!}f^{(2n+2)}(\xi)
\]</span></p>
<h3 id="定理证明">定理证明</h3>
<h4 id="值相等">值相等</h4>
<ul>
<li>对于 <span class="math inline">\(n\)</span> 阶拉格朗日多项式</li>
</ul>
<p><span class="math display">\[
L_{n,j}(x_i)=
\left\{\begin{array}{c}
0,&amp;\mathrm{if}\ i\ne j\\
1,&amp;\mathrm{if}\ i=j\\
\end{array}\right.
\]</span></p>
<ul>
<li>于是有</li>
</ul>
<p><span class="math display">\[
H_{n,j}(x_i)=
\left\{\begin{array}{c}
0,&amp;\mathrm{if}\ i\ne j\\
1,&amp;\mathrm{if}\ i=j\\
\end{array}\right.
\]</span></p>
<p><span class="math display">\[
\hat{H}_{n,j}(x_i)=
\left\{\begin{array}{c}
0,&amp;\mathrm{if}\ i\ne j\\
0,&amp;\mathrm{if}\ i=j\\
\end{array}\right.
\]</span></p>
<ul>
<li>那么我们能够得到</li>
</ul>
<p><span class="math display">\[
H_{2n+1}(x_i)=\sum_{j=0}^{n}f(x_j)H_{n,j}(x_i)+\sum_{j=1}^{n}f&#39;(x_j)\hat{H}_{n,j}(x_i)=f(x_i)
\]</span></p>
<h4 id="一阶导相等">一阶导相等</h4>
<ul>
<li>分析</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
H&#39;_{n,j}(x)=2[1-2(x-x_j)L&#39;_{n,j}(x_j)]L_{n,j}(x)L&#39;_{n,j}(x)-2L&#39;_{n,j}(x_j)L^2_{n,j}(x)\\
\hat{H}&#39;_{n,j}(x)=2(x-x_j)L_{n,j}(x)L&#39;_{n,j}(x)+L^2_{n,j}(x)\\
\end{array}
\]</span></p>
<ul>
<li>于是有</li>
</ul>
<p><span class="math display">\[
H&#39;_{n,j}(x_i)=
\left\{\begin{array}{c}
0,&amp;\mathrm{if}\ i\ne j\\
0,&amp;\mathrm{if}\ i=j\\
\end{array}\right.
\]</span></p>
<p><span class="math display">\[
\hat{H}_{n,j}(x_i)=
\left\{\begin{array}{c}
0,&amp;\mathrm{if}\ i\ne j\\
1,&amp;\mathrm{if}\ i=j\\
\end{array}\right.
\]</span></p>
<ul>
<li>得到</li>
</ul>
<p><span class="math display">\[
H&#39;_{2n+1}(x_i)=\sum_{j=0}^{n}f(x_j)H&#39;_{n,j}(x_i)+\sum_{j=1}^{n}f&#39;(x_j)\hat{H}&#39;_{n,j}(x_i)=f&#39;(x_i)
\]</span></p>
<h3 id="计算问题">计算问题</h3>
<ul>
<li>需要计算拉格朗日多项式及其导数</li>
<li>即便对于低阶厄米特多项式计算复杂</li>
</ul>
<h3 id="利用牛顿差分公式">利用牛顿差分公式</h3>
<ul>
<li>利用<strong>牛顿差分多项式</strong>计算厄米特多项式</li>
</ul>
<p><span class="math display">\[
H_{2n+1}(x)=f[z_0]+\sum_{k=1}^{n}f[z_0,\cdots,z_k](x-z_0)\cdots(x-z_{k-1})
\]</span></p>
<ul>
<li><span class="math inline">\(2n+2\)</span> 个节点</li>
</ul>
<p><span class="math display">\[
z_{2i}=z_{2i+1}=x_i
\]</span></p>
<ul>
<li>复制节点对应的一阶差商的定义</li>
</ul>
<p><span class="math display">\[
f[z_{2i},z_{2i+1}]=f&#39;(z_{2i})=f&#39;(x_i)
\]</span></p>
<h4 id="定理-1">定理</h4>
<ul>
<li>假设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(n\)</span> 阶连续函数 <span class="math inline">\(f\in C^{n}[a,b]\)</span>，<span class="math inline">\(x_0,\cdots,x_n\)</span> 是 <span class="math inline">\([a,b]\)</span> 区间中不同数，则 <span class="math inline">\([a,b]\)</span> 区间中存在 <span class="math inline">\(\xi\)</span> 使得</li>
</ul>
<p><span class="math display">\[
f[x_0,\cdots,x_n]=\dfrac{f^{n}(\xi)}{n!}
\]</span></p>
<ul>
<li>证明：<strong>推广罗尔定理</strong>
<ul>
<li><span class="math inline">\(g(x)=f(x)-P_n(x)\)</span> 有 <span class="math inline">\(n+1\)</span> 个过零点</li>
<li><span class="math inline">\(g^{(n)}(\xi)=f^{(n)}(\xi)-n!f[x_0,\cdots,x_n]\)</span></li>
</ul></li>
<li>于是我们可以得到复制节点的差商</li>
</ul>
<p><span class="math display">\[
f[z_{2i},z_{2i+1}]=f&#39;(\xi)=f&#39;(z_{2i})=f&#39;(x_i)
\]</span></p>
<h3 id="计算示例">计算示例</h3>
<p><img src="/2021/10/25/computation/pyr/04-2/image-20211026121102569.png" style="zoom:80%;"></p>
<h2 id="方法对比">5. 方法对比</h2>
<p><img src="/2021/10/25/computation/pyr/04-2/image-20211026121135092.png"></p>
<h2 id="三次样条插值">6. 三次样条插值</h2>
<ul>
<li>分段多项式插值</li>
</ul>
<h3 id="分段线性插值">分段线性插值</h3>
<ul>
<li><span class="math inline">\(C^{0}\)</span> 连续
<ul>
<li>缺乏在节点处对函数方向（高阶导数）的描述</li>
</ul></li>
</ul>
<h3 id="三次样条">三次样条</h3>
<ul>
<li>插值、连续、一阶导相等、二阶导相等</li>
<li>边界条件（两个选一个即可）
<ul>
<li>自由或自然边界条件：<span class="math inline">\(S&#39;&#39;(x_0)=S&#39;&#39;(x_n)=0\)</span></li>
<li>固支边界条件：<span class="math inline">\(S&#39;(x_0)=f&#39;(x_0),S&#39;(x_n)=f&#39;(x_n)\)</span></li>
</ul></li>
</ul>
<h3 id="对比">对比</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><span class="math inline">\(f\)</span></th>
<th style="text-align: center;"><span class="math inline">\(f&#39;\)</span></th>
<th style="text-align: center;"><span class="math inline">\(f&#39;&#39;\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">厄米特多项式 <span class="math inline">\(H(x)\)</span></td>
<td style="text-align: center;">相等</td>
<td style="text-align: center;">相等</td>
<td style="text-align: center;">未定义</td>
</tr>
<tr class="even">
<td style="text-align: center;">三阶样条多项式 <span class="math inline">\(S(x)\)</span></td>
<td style="text-align: center;">相等</td>
<td style="text-align: center;">连续</td>
<td style="text-align: center;">连续</td>
</tr>
</tbody>
</table>
<h3 id="自然三次样条">自然三次样条</h3>
<ul>
<li><span class="math inline">\(S&#39;&#39;(x_0)=S&#39;&#39;(x_n)=0\)</span></li>
<li><a href="/2021/10/24/computation/pyr/04-1/">note</a></li>
</ul>
<h3 id="固支三次样条">固支三次样条</h3>
<ul>
<li><span class="math inline">\(S&#39;(x_0)=f&#39;(x_0),S&#39;(x_n)=f&#39;(x_n)\)</span></li>
<li><a href="/2021/10/24/computation/pyr/04-1/">note</a>
<ul>
<li>钳制三次样条的特殊情况</li>
<li><span class="math inline">\(v_1=f&#39;(x_0),v_2=f&#39;(x_n)\)</span></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.03.方程组</title>
    <url>/2021/10/02/computation/pyr/03/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 2 章（方程组） + PPT（非线性方程组迭代求解）</li>
</ul>
<h1 id="方程组">方程组</h1>
<h2 id="高斯消去法">1. 高斯消去法</h2>
<h3 id="朴素的高斯消去法">1.1 朴素的高斯消去法</h3>
<ul>
<li>等价变化（行列式变换）
<ul>
<li>两个方程彼此交换位置</li>
<li>在一个方程上加上或者减去两外一个方程的倍数</li>
<li>对于一个方程乘上一个非零的常数</li>
</ul></li>
<li>步骤
<ul>
<li>化为上三角阵</li>
<li>回代（后向求解）</li>
</ul></li>
</ul>
<h3 id="操作次数">1.2 操作次数</h3>
<p><span class="math display">\[
1+2+\cdots+n=\dfrac{n(n+1)}{2}
\]</span></p>
<p><span class="math display">\[
1^2+2^2+\cdots+n^2=\dfrac{n(n+1)(2n+1)}{6}
\]</span></p>
<ul>
<li>输入的方程组（含有 n 个未知数的 n 个方程组）</li>
</ul>
<p><img src="/2021/10/02/computation/pyr/03/image-20211003163248736.jpg" style="zoom:67%;"></p>
<ul>
<li><p>把矩阵的下三角部分转化为全 0</p>
<ul>
<li>例如消去 <span class="math inline">\(a_{21}\)</span>，对第二列作如下操作</li>
</ul>
<p><span class="math display">\[
  a_{21}-\dfrac{a_{21}}{a_{11}}a_{11}
  \]</span></p>
<ul>
<li>对于这一行：1个除法 + n 个乘法 + n 个减法
<ul>
<li>第一列不用，但是 <span class="math inline">\(b_i\)</span>
也要做同样的计算</li>
</ul></li>
</ul></li>
<li><p><span class="math inline">\(a_{ii}\)</span>
会在分母中出现，被称为是<strong>主元</strong>，上面的操作要求 <span class="math inline">\(a_{ii}\)</span> 不为 0</p></li>
<li><p>我们可以计算得到消去这一步中的操作次数</p></li>
</ul>
<p><span class="math display">\[
\sum_{k=n}^{1}(2k+1)(k-1)=\dfrac{4n^3+3n^2-7n}{6}
\]</span></p>
<ul>
<li>此时方程转化为</li>
</ul>
<p><img src="/2021/10/02/computation/pyr/03/image-20211003164850752.jpg" style="zoom: 67%;"></p>
<ul>
<li>此时只需要从下到上一步步回代即可
<ul>
<li>1 除法、(n-i) 乘法、(n-i) 减法</li>
</ul></li>
</ul>
<p><span class="math display">\[
x_{i}=\dfrac{b_i-a_{i,i+1}x_{i+1}-\cdots-a_{i,n}x_{n}}{a_{ii}}
\]</span></p>
<ul>
<li>操作次数</li>
</ul>
<p><span class="math display">\[
\sum_{i=1}^{n}2(n-i)+1=\sum_{i=1}^{n}2(i-1)+1=n^2
\]</span></p>
<ul>
<li>高斯消去法时间复杂度：<span class="math inline">\(O(n^3)\)</span>
<ul>
<li>消去：<span class="math inline">\(O(n^3)\)</span></li>
<li>回代：<span class="math inline">\(O(n^2)\)</span></li>
</ul></li>
</ul>
<h2 id="lu-分解">2. LU 分解</h2>
<h3 id="高斯消去法的矩阵形式">2.1 高斯消去法的矩阵形式</h3>
<ul>
<li>Ax=B</li>
<li><strong>LU 分解是高斯消去法的矩阵形式</strong>
<ul>
<li>L：下三角矩阵</li>
<li>U：上三角矩阵</li>
</ul></li>
<li>如下几个事实支持 LU 分解</li>
</ul>
<h4 id="事实1">事实1</h4>
<ul>
<li>矩阵左乘相当于高斯消去法的变换</li>
</ul>
<p><img src="/2021/10/02/computation/pyr/03/image-20211003190022083.jpg" style="zoom:67%;"></p>
<p><img src="/2021/10/02/computation/pyr/03/image-20211003185208542.jpg" style="zoom:67%;"></p>
<h4 id="事实2">事实2</h4>
<ul>
<li>逆就是取反</li>
</ul>
<p><img src="/2021/10/02/computation/pyr/03/image-20211003185540307.jpg" style="zoom:67%;"></p>
<h4 id="事实3">事实3</h4>
<ul>
<li>相乘得到结果（注意<strong>顺序</strong>）</li>
</ul>
<p><img src="/2021/10/02/computation/pyr/03/image-20211003185647924.jpg" style="zoom:67%;"></p>
<h4 id="结论">结论</h4>
<ul>
<li>原来的矩阵通过高斯变换转化为上三角矩阵
<ul>
<li><span class="math inline">\(A\)</span> 通过若干 <span class="math inline">\(L_{ij}\)</span> 的变换得到 <span class="math inline">\(U\)</span></li>
</ul></li>
<li>将若干变换记作 <span class="math inline">\(L^{-1}\)</span></li>
<li><span class="math inline">\(L^{-1}A = U\Rightarrow
A=LU\)</span></li>
</ul>
<h3 id="使用-lu-分解回代">2.2 使用 LU 分解回代</h3>
<ul>
<li><span class="math inline">\(Ax=b\Rightarrow LUx=b\)</span></li>
<li>记 <span class="math inline">\(Ux=c\)</span>，有 <span class="math inline">\(Lc=b\)</span></li>
<li>回代过程如下
<ul>
<li>通过 <span class="math inline">\(Lc=b\)</span>，解出 <span class="math inline">\(c\)</span></li>
<li>通过 <span class="math inline">\(Ux=c\)</span>，解出 <span class="math inline">\(x\)</span></li>
</ul></li>
</ul>
<h3 id="lu-分解的复杂度">2.3 LU 分解的复杂度</h3>
<h4 id="lu-分解的好处">LU 分解的好处</h4>
<ul>
<li>如果对于一系列的方程组求解</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\begin{array}{c}
Ax=b_1\\
Ax=b_2\\
\cdots\\
Ax=b_k\\
\end{array}
\end{aligned}
\]</span></p>
<ul>
<li>对于原始的高斯消去法，每次都需要经过复杂的消去操作
<ul>
<li>复杂度约为：<span class="math inline">\(\dfrac{2kn^3}{3}\)</span></li>
</ul></li>
<li>但是对于 LU 分解方法，消去操作只需要做一次
<ul>
<li>复杂度约为：<span class="math inline">\(\dfrac{2n^3}{3}+2kn^2\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/10/02/computation/pyr/03/image-20211003192642407.jpg" style="zoom:67%;"></p>
<ul>
<li>并不是所有的矩阵都能进行 LU 分解</li>
</ul>
<h4 id="实际实现">实际实现</h4>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/343079701">知乎参考</a></li>
<li>注意一些性质
<ul>
<li>L 对角线为 1，下三角阵</li>
<li>R 上三角阵</li>
</ul></li>
</ul>
<p><span class="math display">\[
{A_{ij}}=
\left\{
\matrix{
\sum\limits_{k = 1}^i L_{ik}U_{kj} ,(i &lt; j)\\
\sum\limits_{k = 1}^j L_{ik}U_{kj} ,(i &gt; j)\\
\sum\limits_{k = 1}^i L_{ik}U_{kj} ,(i = j)\\
}\right.
\Rightarrow
\left\{
\matrix{
\sum\limits_{k = 1}^{i - 1} L_{ik}U_{kj}  + U_{ij} = A_{ij},(i \le j)\\
\sum\limits_{k = 1}^{j - 1} L_{ik}U_{kj}  + L_{ij}U_{jj} = A_{ij},(i
&gt; j)\\
}\right.
\]</span></p>
<p><span class="math display">\[
\Rightarrow
\left\{
\matrix{
U_{ij} = A_{ij} - \sum\limits_{k = 1}^{i - 1} L_{ik}U_{kj} ,(i \le j)\\
L_{ij} = \dfrac{A_{ij}-\sum\limits_{k = 1}^{j - 1}
L_{ik}U_{kj}}{U_{jj}},(i &gt; j)\\
}\right.
\]</span></p>
<ul>
<li>先计算 <span class="math inline">\(U_{ij}\)</span>，再计算 <span class="math inline">\(L_{ij}\)</span></li>
</ul>
<h2 id="误差来源">3. 误差来源</h2>
<ul>
<li><strong>病态矩阵</strong></li>
<li><strong>淹没</strong></li>
</ul>
<h3 id="误差放大和条件数">3.1 误差放大和条件数</h3>
<ul>
<li><strong>无穷范数</strong>
<ul>
<li>向量 <span class="math inline">\(x=(x_1,\cdots,x_n)\)</span>
的无穷范数为 <span class="math inline">\(\Vert{x}\Vert_{\infty}=\max\vert{x_i}\vert\)</span></li>
</ul></li>
<li><span class="math inline">\(x_a\)</span> 是线性方程组 <span class="math inline">\(Ax=b\)</span> 的近似解
<ul>
<li><strong>余项</strong>：<span class="math inline">\(r=b-Ax_a\)</span></li>
<li><strong>后向误差</strong>：<span class="math inline">\(\Vert{b-Ax_a}\Vert_{\infty}\)</span></li>
<li><strong>前向误差</strong>：<span class="math inline">\(\Vert{x-x_a}\Vert_{\infty}\)</span></li>
</ul></li>
<li>前向误差和后向误差可能有不同数量级
<ul>
<li>大的前向误差、小的后向误差</li>
</ul></li>
</ul>
<p><img src="/2021/10/02/computation/pyr/03/image-20211003230247314.jpg" style="zoom:67%;"></p>
<ul>
<li><strong>相对前向误差</strong></li>
</ul>
<p><span class="math display">\[
\dfrac{\Vert{x-x_a}\Vert_{\infty}}{\Vert{x}\Vert_{\infty}}
\]</span></p>
<ul>
<li><strong>相对后向误差</strong></li>
</ul>
<p><span class="math display">\[
\dfrac{\Vert{b-Ax_a}\Vert_{\infty}}{\Vert{b}\Vert_{\infty}}=\dfrac{\Vert{r}\Vert_{\infty}}{\Vert{b}\Vert_{\infty}}
\]</span></p>
<ul>
<li><strong>误差放大因子</strong></li>
</ul>
<p><span class="math display">\[
误差放大因子=\dfrac{相对前向误差}{相对后向误差}=\dfrac{\dfrac{\Vert{x-x_a}\Vert_{\infty}}{\Vert{x}\Vert_{\infty}}}{\dfrac{\Vert{r}\Vert_{\infty}}{\Vert{b}\Vert_{\infty}}}
\]</span></p>
<ul>
<li><strong>条件数</strong>
<ul>
<li>在预先定义的输入误差范围中最大的误差放大倍数</li>
</ul></li>
</ul>
<h4 id="条件数">条件数</h4>
<ul>
<li>方阵 A 的条件数 cond(A) 为求解 Ax=b 时，对于所有的右侧向量
b，可能出现的最大误差放大因子</li>
<li><strong>矩阵范数</strong>
<ul>
<li><span class="math inline">\(n\times n\)</span> 矩阵 A
的矩阵范数定义如下</li>
<li>每行元素绝对值之和的最大值</li>
</ul></li>
</ul>
<p><span class="math display">\[
\Vert{A}\Vert_{\infty}=\max_{i}\left(\sum_{j=1}^{n}\vert{a_{ij}}\vert\right)
\]</span></p>
<ul>
<li><span class="math inline">\(n\times n\)</span> 矩阵的 A
的条件数是（<strong>这里指的是算子范数</strong>）</li>
</ul>
<p><span class="math display">\[
\mathrm{cond}(A)=\Vert{A}\Vert\cdot\Vert{A^{-1}}\Vert
\]</span></p>
<ul>
<li><a href="#条件数证明">证明如下</a></li>
</ul>
<h5 id="精度丢失">精度丢失</h5>
<ul>
<li>相对后向误差不可能小于 <span class="math inline">\(\epsilon_{\mathrm{mach}}\)</span>，因此相对前向误差可能达到
<span class="math inline">\(\epsilon_{\mathrm{mach}}\cdot
\mathrm{cond}(A)\)</span> 这么大
<ul>
<li>也就是说如果我们 <span class="math inline">\(\mathrm{cond}(A)\approx{10^k}\)</span>，在计算
Ax=b 时可能丢掉 k 位数字精度</li>
</ul></li>
</ul>
<h4 id="向量范数">向量范数</h4>
<p><img src="/2021/10/02/computation/pyr/03/image-20211005134226581.jpg" style="zoom: 67%;"></p>
<h5 id="范数">1-范数</h5>
<ul>
<li>n 维向量的1-范数</li>
</ul>
<p><span class="math display">\[
\Vert{x}\Vert_{1}=\vert{x_1}\vert+\vert{x_2}\vert+\cdots+\vert{x_n}\vert
\]</span></p>
<ul>
<li><span class="math inline">\(n\times n\)</span> 矩阵 A 的 1-范数
<ul>
<li>最大绝对列和</li>
<li>列向量的 1-范数 的最大值</li>
</ul></li>
</ul>
<p><span class="math display">\[
\Vert{A}\Vert_{1}=\max_{j}\left(\sum_{i=1}^{n}\vert{a_{ij}}\vert\right)
\]</span></p>
<h4 id="算子范数">算子范数</h4>
<ul>
<li>矩阵范数使用特定的向量范数定义</li>
</ul>
<p><span class="math display">\[
\Vert{A}\Vert=\max\dfrac{\Vert{Ax}\Vert}{\Vert{x}\Vert}
\]</span></p>
<ul>
<li><strong>矩阵1-范数是向量1-范数的算子范数</strong></li>
</ul>
<h5 id="范数证明">1-范数证明</h5>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/30674132">参考资料</a></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
L&amp;=\max\dfrac{\Vert{Ax}\Vert_1}{\Vert{x}\Vert_1}\\
R&amp;=\max_{j}\left(\sum_{i=1}^{n}\vert{a_{ij}}\vert\right)\\
\end{aligned}
\]</span></p>
<ul>
<li>思路：<span class="math inline">\(L\le R,L\ge R\)</span></li>
</ul>
<h6 id="lle-r"><span class="math inline">\(L\le R\)</span></h6>
<p><span class="math display">\[
\begin{aligned}
{\Vert{Ax}\Vert_1}=&amp;\sum_{i=1}^{n}\left\vert\sum_{j=1}^{n}a_{ij}x_j\right\vert\\
\le&amp;\sum_{i=1}^{n}\sum_{j=1}^{n}\vert a_{ij}\vert\vert x_j\vert\\
=&amp;\sum_{j=1}^{n}\sum_{i=1}^{n}\vert a_{ij}\vert\vert x_j\vert\\
=&amp;\sum_{j=1}^{n}\left(\vert x_j\vert\sum_{i=1}^{n}\vert
a_{ij}\vert\right)\\
\le&amp;\sum_{j=1}^{n}\left(\vert x_j\vert\max_{j}{\sum_{i=1}^{n}\vert
a_{ij}\vert}\right)\\
=&amp;\max_{j}{\sum_{i=1}^{n}\vert a_{ij}\vert}\cdot\sum_{j=1}^{n}\vert
x_j\vert\\
=&amp;\max_{j}{\sum_{i=1}^{n}\vert a_{ij}\vert}\cdot\Vert{x}\Vert_1
\end{aligned}
\]</span></p>
<h6 id="lge-r-构造"><span class="math inline">\(L\ge R\)</span>
构造</h6>
<ul>
<li>构造 <span class="math inline">\(\lambda\)</span> 如下，<span class="math inline">\(\lambda=R\)</span></li>
</ul>
<p><span class="math display">\[
\lambda=\sum_{i=1}^{n}{\vert{a_{is}}\vert}=\max_{j}\sum_{i=1}^{n}{\vert{a_{ij}}\vert},1\le{s}\le{n}
\]</span></p>
<ul>
<li>记 <span class="math inline">\(A=\left(\alpha_1,\cdots,\alpha_n\right)\)</span></li>
<li>设 n 维向量 <span class="math inline">\(\epsilon_{s}\)</span>
如下，除了第 s 维为 1，其余都为 0</li>
</ul>
<p><span class="math display">\[
\epsilon_{s}={(0,0,\cdots,0,1,0,\cdots,0)}^{T}
\]</span></p>
<ul>
<li>那么有</li>
</ul>
<p><span class="math display">\[
{\Vert{A\epsilon_s}\Vert_1}={\Vert{\alpha_s}\Vert_1}=\lambda=\lambda\Vert{\epsilon_s}\Vert
\]</span></p>
<p><span class="math display">\[
\Rightarrow\dfrac{\Vert{A\epsilon_s}\Vert_1}{\Vert{\epsilon_s}\Vert_1}=\lambda
\]</span></p>
<ul>
<li>于是</li>
</ul>
<p><span class="math display">\[
L=\max\dfrac{\Vert{Ax}\Vert_1}{\Vert{x}\Vert_1}\ge\dfrac{\Vert{A\epsilon_s}\Vert_1}{\Vert{\epsilon_s}\Vert_1}=\lambda=R
\]</span></p>
<h5 id="无穷范数证明">无穷范数证明</h5>
<p><span class="math display">\[
\begin{aligned}
L&amp;=\max\dfrac{\Vert{Ax}\Vert_\infty}{\Vert{x}\Vert_\infty}\\
R&amp;=\max_{i}\left(\sum_{j=1}^{n}\vert{a_{ij}}\vert\right)\\
\end{aligned}
\]</span></p>
<h6 id="lle-r-1"><span class="math inline">\(L\le R\)</span></h6>
<p><span class="math display">\[
\begin{aligned}
{\Vert{Ax}\Vert_\infty}=&amp;\max_{i}\left\vert\sum_{j=1}^{n}a_{ij}x_j\right\vert\\
\le&amp;\max_{i}\sum_{j=1}^{n}\vert a_{ij}\vert\vert x_j\vert\\
\le&amp;\max_{i}\left(\sum_{j=1}^{n}\vert a_{ij}\vert\max_{k}{\vert
x_k\vert}\right)\\
\le&amp;\max_{k}{\vert x_k\vert}\cdot\max_{i}\left(\sum_{j=1}^{n}\vert
a_{ij}\vert\right)\\
=&amp;{\Vert{x}\Vert_\infty}\cdot\max_{i}\left(\sum_{j=1}^{n}\vert
a_{ij}\vert\right)\\
\end{aligned}
\]</span></p>
<h6 id="lge-r-构造-1"><span class="math inline">\(L\ge R\)</span>
构造</h6>
<ul>
<li><span class="math inline">\(e^{i\theta}=\cos\theta+i\sin\theta\)</span></li>
<li>设 <span class="math inline">\(\mu\)</span> 如下，<span class="math inline">\(\mu=R\)</span></li>
</ul>
<p><span class="math display">\[
\mu=\sum_{j=1}^{n}\vert{a_{sj}}\vert=\max_{i}\left(\sum_{j=1}^{n}\vert{a_{ij}}\vert\right)
\]</span></p>
<ul>
<li>记 <span class="math inline">\(A=\left(\alpha_1,\cdots,\alpha_n\right)\)</span></li>
<li>记 <span class="math inline">\(a_{ij}=\vert{a_{ij}}\vert
e^{i\theta_j}\)</span></li>
<li>设 n 维向量 <span class="math inline">\(z\)</span> 如下</li>
</ul>
<p><span class="math display">\[
z=(e^{-s\theta_1},\cdots,e^{-s\theta_n})\Rightarrow\Vert{z}\Vert_\infty=1
\]</span></p>
<ul>
<li>那么有
<ul>
<li><span class="math inline">\(\sum_{j=1}^{n}{\vert{a_{ij}}\vert}e^{i\theta_j}e^{-s\theta_j}\le\sum_{j=1}^{n}{\vert{a_{ij}}\vert}\le{\sum_{j=1}^{n}{\vert{a_{sj}}\vert}}\)</span>
<ul>
<li><span class="math inline">\(e^{i\theta_j}e^{-s\theta_j}\le1\)</span>，等号在
<span class="math inline">\(i=s\)</span> 的时候取到</li>
<li><span class="math inline">\({\sum_{j=1}^{n}{\vert{a_{ij}}\vert}}\le{\sum_{j=1}^{n}{\vert{a_{sj}}\vert}}\)</span>，等号在
<span class="math inline">\(i=s\)</span> 的时候取到</li>
</ul></li>
<li>同时，<span class="math inline">\(\sum_{j=1}^{n}{\vert{a_{ij}}\vert}e^{i\theta_j}e^{-s\theta_j}\ge-\sum_{j=1}^{n}{\vert{a_{ij}}\vert}\ge-{\sum_{j=1}^{n}{\vert{a_{sj}}\vert}}\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
{\Vert{Az}\Vert_\infty}=\max_{i}\left\vert{\sum_{j=1}^{n}{\vert{a_{ij}}\vert}e^{i\theta_j}e^{-s\theta_j}}\right\vert=\left\vert{\sum_{j=1}^{n}{\vert{a_{sj}}\vert}}\right\vert=\mu=\mu\Vert{z}\Vert_\infty
\]</span></p>
<p><span class="math display">\[
\Rightarrow\dfrac{\Vert{Az}\Vert_\infty}{\Vert{z}\Vert_\infty}=\mu
\]</span></p>
<ul>
<li>于是</li>
</ul>
<p><span class="math display">\[
L=\max\dfrac{\Vert{Ax}\Vert_\infty}{\Vert{x}\Vert_\infty}\ge\dfrac{\Vert{Az}\Vert_\infty}{\Vert{z}\Vert_\infty}=\mu=R
\]</span></p>
<h5 id="希尔伯特矩阵">希尔伯特矩阵</h5>
<p><span class="math display">\[
H_{ij}=\dfrac{1}{i+j-1}
\]</span></p>
<ul>
<li>希尔伯特矩阵的条件数很大</li>
<li>解线性方程组 <span class="math inline">\(Hx=b\)</span>
就是一个病态问题</li>
</ul>
<h5 id="定理">定理</h5>
<ul>
<li>由定义，有</li>
</ul>
<p><span class="math display">\[
{\Vert{Ax}\Vert}\le\Vert{A}\Vert\cdot{\Vert{x}\Vert}
\]</span></p>
<h4 id="条件数证明">条件数证明</h4>
<ul>
<li>由 <span class="math inline">\(A(x-x_a)=r\)</span>，可以得到 <span class="math inline">\(x-x_a=A^{-1}r\)</span>，于是有</li>
</ul>
<p><span class="math display">\[
\Vert{x-x_a}\Vert\le\Vert{A^{-1}}\Vert\cdot\Vert{r}\Vert
\]</span></p>
<ul>
<li>因为 <span class="math inline">\(Ax=b\)</span>，于是有</li>
</ul>
<p><span class="math display">\[
{\Vert{b}\Vert}\le\Vert{A}\Vert\cdot{\Vert{x}\Vert}
\]</span></p>
<p><span class="math display">\[
\Rightarrow\dfrac{1}{\Vert{A}\Vert}\cdot\dfrac{1}{\Vert{x}\Vert}\le\dfrac{1}{\Vert{b}\Vert}\
\]</span></p>
<ul>
<li>因此有</li>
</ul>
<p><span class="math display">\[
\dfrac{\Vert{x-x_a}\Vert}{\Vert{x}\Vert}\le\Vert{A^{-1}}\Vert\Vert{A}\Vert\cdot\dfrac{\Vert{r}\Vert}{\Vert{b}\Vert}
\]</span></p>
<ul>
<li>一般情况下可以取到等号，<strong>根据证明过程构造即可</strong></li>
</ul>
<h3 id="淹没-swamp">3.2 淹没 swamp</h3>
<ul>
<li>方程组</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\left\{
\begin{array}{rcrr}
10^{-20}x_1&amp;+&amp;x_2&amp;=1\\
x_1&amp;+&amp;2x_2&amp;=4
\end{array}
\right.
\end{aligned}
\]</span></p>
<ul>
<li>当<strong>乘子很大</strong>的时候，我们发现将第一行式子成大第二行上面的时候，第二行的式子会被淹没（swamp）
<ul>
<li>精度问题导致的</li>
</ul></li>
<li>因此我们可以通过交换两行顺序的方法，让乘子的绝对值小于
1，避免上述情况发生</li>
<li><strong>部分主元方法</strong></li>
</ul>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.04.插值</title>
    <url>/2021/10/23/computation/pyr/04/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 3 章（插值） + PPT（多项式插值）</li>
</ul>
<h1 id="插值">插值</h1>
<h2 id="数据和插值函数">1. 数据和插值函数</h2>
<ul>
<li>如果对于每个 <span class="math inline">\(1\le i\le n\)</span>，<span class="math inline">\(P(x_i)=y_i\)</span>，则称函数 <span class="math inline">\(y=P(x)\)</span> <strong>插值</strong>数据点 <span class="math inline">\((x_1,y_1),\cdots,(x_n,y_n)\)</span>
<ul>
<li>要求 <span class="math inline">\(P\)</span>
是函数，<strong>对数据点有限制</strong>
<ul>
<li>即要求不能存在两个数据点的 <span class="math inline">\(x\)</span>
值相同而 <span class="math inline">\(y\)</span> 值不同</li>
</ul></li>
</ul></li>
<li>为什么使用多项式进行插值</li>
</ul>
<p><img src="/2021/10/23/computation/pyr/04/image-20211023172124624.jpg" style="zoom:80%;"></p>
<h3 id="拉格朗日插值">1.1 拉格朗日插值</h3>
<ul>
<li><span class="math inline">\(3\)</span> 个数据点 <span class="math inline">\((x_1,y_1),(x_1,y_2,(x_3,y_3)\)</span>
的拉格朗日插值多项式如下</li>
</ul>
<p><span class="math display">\[
P_{2}(x)
=y_1\dfrac{(x-x_2)(x-x_3)}{(x_1-x_2)(x_1-x_3)}
+y_2\dfrac{(x-x_1)(x-x_3)}{(x_2-x_1)(x_2-x_3)}
+y_3\dfrac{(x-x_1)(x-x_2)}{(x_3-x_1)(x_3-x_2)}
\]</span></p>
<ul>
<li>容易验证经过 <span class="math inline">\(3\)</span> 个数据点</li>
<li>一般的，对于 <span class="math inline">\(n\)</span> 个数据点 <span class="math inline">\((x_1,y_1),\cdots,(x_n,y_n)\)</span>，插值多项式如下</li>
</ul>
<p><span class="math display">\[
P_{n-1}(x)=\sum_{i=1}^{n}y_iL_i(x)
\]</span></p>
<p><span class="math display">\[
L_k(x)=\prod_{i=1,i\ne{k}}^{n}\dfrac{(x-x_i)}{(x_k-x_i)}
\]</span></p>
<h4 id="多项式插值的主定理">多项式插值的主定理</h4>
<p><img src="/2021/10/23/computation/pyr/04/image-20211023232033281.jpg" style="zoom:80%;"></p>
<ul>
<li>存在性：拉格朗日插值多项式给出</li>
<li>唯一性：假设存在两个不同的痛的多项式 <span class="math inline">\(P(x),Q(x)\)</span>，证明 <span class="math inline">\(P(x)-Q(x)\equiv0\)</span>
<ul>
<li><span class="math inline">\(n\)</span> 阶多项式最多有 <span class="math inline">\(n\)</span> 个过零点</li>
</ul></li>
</ul>
<p><img src="/2021/10/23/computation/pyr/04/image-20211023232237258.jpg" style="zoom:80%;"></p>
<ul>
<li>多项式可能比 <span class="math inline">\(n-1\)</span> 阶更低
<ul>
<li>例如三个数据点，如果 <strong>3
点共线</strong>，那么插值函数退化为<strong>一条直线</strong></li>
</ul></li>
<li>拉格朗日很少用于计算，这是由于其他方法可以得到控制能力更强，同时计算代价更低的多项式
<ul>
<li><strong>本质上所有的插值多项式都和拉格朗日插值多项式相同，只是以不同的形式给出</strong></li>
</ul></li>
</ul>
<h3 id="牛顿差商">1.2 牛顿差商</h3>
<ul>
<li><span id="ChaFenDef">定义</span>
<ul>
<li><span class="math inline">\(f[{x_1}\cdots{x_n}]\)</span>
表示（唯一）多项式的 <span class="math inline">\(x^{n-1}\)</span>
项系数，该多项式插值 <span class="math inline">\((x,f(x_1)),\cdots,(x_n,f(x_n))\)</span>
<ul>
<li><strong>只表示最高次项的系数</strong></li>
</ul></li>
</ul></li>
</ul>
<h4 id="牛顿差商公式">牛顿差商公式</h4>
<p><span class="math display">\[
\begin{aligned}
P(x)&amp;=f[x_1]\\
&amp;+f[x_1x_2](x-x_1)\\
&amp;+f[x_1x_2x_3](x-x_1)(x-x_2)\\
&amp;+\cdots\\
&amp;+f[x_1\cdots{x_n}](x-x_1)\cdots(x-x_{n-1})
\end{aligned}
\]</span></p>
<ul>
<li>具体系数可以通过递归定义计算</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
f[x_k]&amp;=f(x_k)\\
f[x_kx_{k+1}]&amp;=\dfrac{f[x_{k+1}]-f[x_k]}{x_{k+1}-x_k}\\
f[x_kx_{k+1}x_{k+2}]&amp;=\dfrac{f[x_{k+1}x_{k+2}]-f[x_kx_{k+1}]}{x_{k+2}-x_k}\\
&amp;\cdots\\
\end{aligned}
\]</span></p>
<h4 id="插值证明">插值证明</h4>
<ul>
<li><a href="#牛顿插值多项式的证明">证明如下</a></li>
</ul>
<h4 id="系数计算">系数计算</h4>
<ul>
<li>从低阶差商开始计算</li>
</ul>
<p><img src="/2021/10/23/computation/pyr/04/image-20211024100909842.jpg" style="zoom:80%;"></p>
<ul>
<li>用表的形式计算</li>
</ul>
<p><img src="/2021/10/23/computation/pyr/04/image-20211024100945593.jpg" style="zoom:80%;"></p>
<h4 id="特点">特点</h4>
<ul>
<li>如果有新加入的点
<ul>
<li>拉格朗日插值多项式需要全部重新计算</li>
<li>牛顿插值多项式可以利用之前的计算值实时<strong>更新</strong></li>
</ul></li>
</ul>
<h3 id="经过-n-个点的-d-阶多项式有多少个">1.3 经过 <span class="math inline">\(n\)</span> 个点的 <span class="math inline">\(d\)</span> 阶多项式有多少个</h3>
<ul>
<li>经过 <span class="math inline">\(n\)</span> 个点的插值多项式为 <span class="math inline">\(r\)</span> 阶，其中 <span class="math inline">\(1\le{r}\le{n-1}\)</span>
<ul>
<li>如果 <span class="math inline">\(d&lt;r\)</span>：不存在这样的多项式</li>
<li>如果 <span class="math inline">\(d=r\)</span>：存在 <span class="math inline">\(1\)</span> 个这样的多项式</li>
<li>如果 <span class="math inline">\(d&gt;r\)</span>：存在无穷多个这样的多项式
<ul>
<li><span class="math inline">\(P_r(x)+c\prod_{i=1}^{n}(x-x_k)\)</span></li>
<li>可以通过控制后面多项式 <span class="math inline">\(x_i\)</span>
的个数，从而控制阶数</li>
</ul></li>
</ul></li>
</ul>
<h3 id="插值代码">1.4 插值代码</h3>
<h3 id="通过近似多项式表示函数">1.5 通过近似多项式表示函数</h3>
<ul>
<li>插值多项式是对实际函数 <span class="math inline">\(f(x)\)</span>
的一个<strong>压缩</strong>
<ul>
<li><strong>有损压缩</strong></li>
</ul></li>
<li>在给定的某个区间中进行取点，然后使用多项式插值
<ul>
<li>区间内可以得到较小的误差</li>
</ul></li>
</ul>
<h2 id="插值误差">2. 插值误差</h2>
<h3 id="插值误差公式">2.1 插值误差公式</h3>
<p><img src="/2021/10/23/computation/pyr/04/image-20211024112252814.jpg" style="zoom:80%;"></p>
<ul>
<li>通常误差公式很难计算，但是可以给出一个误差界</li>
<li>在区间的<strong>中部</strong>，插值误差可能会变得<strong>更小</strong></li>
</ul>
<h3 id="牛顿形式和误差公式的证明">2.2 牛顿形式和误差公式的证明</h3>
<ul>
<li>令 <span class="math inline">\(P(x)\)</span> 表示（唯一插值）<span class="math inline">\((x_1,f(x_1)),\cdots,(x_n,f(x_n))\)</span>的多项式
<ul>
<li>其中 <span class="math inline">\({\color{red}a_{n-1}=f[x_1\cdots
x_n]}\)</span> 表示 <span class="math inline">\({\color{red}n-1}\)</span> 阶的系数
<ul>
<li>仅仅是 <span class="math inline">\(n-1\)</span>
阶，其他不一定满足</li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
P(x)=a_0+a_1x+a_2x^2+\cdots a_{n-1}x^{n-1}
\]</span></p>
<ul>
<li><strong>事实1</strong>
<ul>
<li>由于插值多项式的唯一性，对于 <span class="math inline">\(x_i\)</span> 的任意排列 <span class="math inline">\(\sigma\)</span>，都有 <span class="math inline">\(f[x_1\cdots x_n]=f[\sigma(x_1)\cdots
\sigma(x_n)]\)</span></li>
</ul></li>
<li><strong>事实2</strong>
<ul>
<li><span class="math inline">\(P(x)\)</span>
可以表示为另外一种形式</li>
<li><span class="math inline">\(c_{n-1}=a_{n-1}\)</span>，然后从高阶到低阶一步一步确定剩下的系数
<span class="math inline">\(c_{n-1},\cdots,c_0\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
P(x)=c_0+c_1(x-x_1)+c_2(x-x_1)(x-x_2)+\cdots+\Big[c_{n-1}(x-x_1)(x-x_2)\cdots(x-x_{n-1})\Big]
\]</span></p>
<h4 id="牛顿插值多项式的证明">牛顿插值多项式的证明</h4>
<p><img src="/2021/10/23/computation/pyr/04/image-20211024113753422.jpg" style="zoom:80%;"></p>
<ul>
<li>证明思路：先证明<strong>事实2</strong>中的系数为 <span class="math inline">\(c_{i-1}=f[x_1\cdots x_{i}]\)</span>，然后证明
<span class="math inline">\(c_i\)</span> 的递推关系，<span class="math inline">\(f[x_1\cdots x_{i}]\)</span> 的<a href="#ChaFenDef">定义如上</a>
<ul>
<li>证明 <span class="math inline">\((a)\)</span>
<ul>
<li>先证明 <span class="math inline">\((a)\)</span> 中最高次项系数 <span class="math inline">\(c_{n-1}=f[x_1\cdots x_{n-1}]=a_{n-1}\)</span></li>
<li>这个本质上就已经证明了每一个系数就是 <span class="math inline">\(c_{k-1}=f[x_1\cdot x_{n}],k=1,\cdots,n\)</span>
<ul>
<li>对于 <span class="math inline">\(P(x_1),\cdots,P(x_k)\)</span>，只有前 <span class="math inline">\(k\)</span> 项非零，说明前 <span class="math inline">\(k\)</span> 项是 <span class="math inline">\(x_1,\cdots,x_{k}\)</span> 的插值多项式</li>
<li>插值多项式的唯一性</li>
</ul></li>
</ul></li>
<li>证明 <span class="math inline">\((b)\)</span>
<ul>
<li>证明系数递推的具体形式</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/10/23/computation/pyr/04/image-20211024114145504.jpg" style="zoom:80%;"></p>
<h4 id="插值误差证明">插值误差证明</h4>
<p><img src="/2021/10/23/computation/pyr/04/image-20211024144510467.jpg" style="zoom:80%;"></p>
<h3 id="龙格现象">2.3 龙格现象</h3>
<ul>
<li><span class="math inline">\(f(x)=\dfrac{1}{1+12x^2}\)</span> 在
<span class="math inline">\([-1,1]\)</span> 均匀分布点集的插值</li>
</ul>
<p><img src="/2021/10/23/computation/pyr/04/image-20211024152304868.jpg" style="zoom:80%;"></p>
<ul>
<li><span id="longge">龙格现象</span>：<strong>多项式在插值区间的端点附近扭动</strong></li>
<li>龙格现象的例子在数据点区间端点外有非常大的误差
<ul>
<li>解决方法：<strong>将一些插值点移动到区间的外面</strong>，在那里函数生成的点可以使拟合的效果更好</li>
</ul></li>
</ul>
<h2 id="切比雪夫插值">3. 切比雪夫插值</h2>
<ul>
<li>使用<strong>平均分布</strong>的点作为插值多项式的基点 <span class="math inline">\(x_i\)</span>
很普遍，在很多情况下，用于插值的数据点仅以这种形式存在，例如当数据由<strong>相同时间间隔分布的仪器读取的数据</strong>所组成时，在其他情况下，例如
sine
键问题中，我们可以在认为合适的地方自由选取基点，事实证明，<strong>基点间距选取的方式对于插值误差有很大的影响</strong>。</li>
<li><strong>切比雪夫插值是一种特定最优的点间距选取方式</strong></li>
</ul>
<h3 id="切比雪夫理论">3.1 切比雪夫理论</h3>
<ul>
<li>切比雪夫插值的动机：在插值区间上，提高对如下插值误差的最大值的控制</li>
</ul>
<p><span class="math display">\[
\dfrac{(x-x_1)\cdots(x-x_n)}{n!}f^{(n)}(c)
\]</span></p>
<ul>
<li>固定区间为 <span class="math inline">\([-1,1]\)</span></li>
</ul>
<h4 id="插值误差的最小最大问题">插值误差的最小最大问题</h4>
<ul>
<li>在区间 <span class="math inline">\([-1,1]\)</span> 内找到特定的
<span class="math inline">\(x_1,\cdots,x_n\)</span> 使得分子 <span class="math inline">\((x-x_1)\cdots(x-x_n)\)</span> 的最大值足够小</li>
</ul>
<p><img src="/2021/10/23/computation/pyr/04/image-20211024155500126.jpg" style="zoom:80%;"></p>
<h4 id="切比雪夫定理">切比雪夫定理</h4>
<p><img src="/2021/10/23/computation/pyr/04/image-20211024155655438.jpg" style="zoom:80%;"></p>
<ul>
<li><a href="#切比雪夫定理的证明">证明在下面</a></li>
</ul>
<h4 id="切比雪夫插值多项式">切比雪夫插值多项式</h4>
<ul>
<li>选择切比雪夫的根作为插值的基点，在区间 <span class="math inline">\([-1, 1]\)</span> 中尽可能均匀地分散了插值误差</li>
</ul>
<p><span class="math display">\[
x_i=\cos\dfrac{i\pi}{2n},\qquad i=1,\cdots,n
\]</span></p>
<ul>
<li>我们将使用切比雪夫根作为基点的插值多项式叫做<strong>切比雪夫插值多项式</strong></li>
</ul>
<h4 id="一个例子">一个例子</h4>
<ul>
<li><span class="math inline">\(f(x)=\dfrac{1}{12x^2+1}\)</span></li>
</ul>
<p><img src="/2021/10/23/computation/pyr/04/image-20211024160558513.jpg" style="zoom:80%;"></p>
<ul>
<li>和上面的<a href="#longge">均匀选取插值点</a>对比，龙格现象消失了</li>
</ul>
<h3 id="切比雪夫多项式">3.2 切比雪夫多项式</h3>
<ul>
<li><span class="math inline">\(n\)</span> 阶切比雪夫多项式</li>
</ul>
<p><span class="math display">\[
T_n(x)=\cos(n\arccos{x})
\]</span></p>
<ul>
<li>对于每个 <span class="math inline">\(n\)</span> 都是关于 <span class="math inline">\(x\)</span> 的多项式</li>
</ul>
<p><span class="math display">\[
\begin{array}{ll}
n=0:&amp;T_1(x)=1\\
n=1:&amp;T_2(x)=x\\
n=2:&amp;T_2(x)=2x^2-1\\
\end{array}
\]</span></p>
<ul>
<li>递推公式，记 <span class="math inline">\(y=\arccos{x}\Rightarrow
x=\cos{y}\)</span></li>
</ul>
<p><span class="math display">\[
T_{n+1}(x)=\cos(n+1)y=\cos{ny}\cos{y}-\sin{ny}\sin{y}
\]</span></p>
<p><span class="math display">\[
T_{n-1}(x)=\cos(n-1)y=\cos{ny}\cos{y}+\sin{ny}\sin{y}
\]</span></p>
<p><span class="math display">\[
T_{n+1}(x)+T_{n-1}(x)=2xT_{n}(x)
\]</span></p>
<ul>
<li>得到递推公式</li>
</ul>
<p><span class="math display">\[
T_{n+1}(x)=2xT_{n}(x)-T_{n-1}(x)
\]</span></p>
<h4 id="一些事实">一些事实</h4>
<ul>
<li>切比雪夫多项式 <span class="math inline">\(T_n\)</span> 确实都是关于
<span class="math inline">\(x\)</span> 的多项式</li>
</ul>
<p><img src="/2021/10/23/computation/pyr/04/image-20211024162112440.jpg" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(\deg(T_n)=n\)</span>，主导系数是 <span class="math inline">\(2^{n-1}\)</span>
<ul>
<li>deg：多项式最高次项的次数</li>
<li>主导系数：多项式最高次项的系数</li>
</ul></li>
<li><span class="math inline">\(T_n(1)=1,T_n(-1)=(-1)^{n}\)</span></li>
<li><span class="math inline">\(\vert{T_n(x)}\vert\le1,x\in[-1,1]\)</span>
<ul>
<li><span class="math inline">\(T_n(x)=\cos(ny)\)</span> 显然成立</li>
</ul></li>
<li><span class="math inline">\(T_n(x)\)</span> 的所有过零点都在 <span class="math inline">\([-1,1]\)</span> 之间</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\cos(n\arccos{x})=0\\
\Rightarrow&amp;n\arccos{x}=\mathrm{odd}\cdot\dfrac{\pi}{2}\\
\Rightarrow&amp;x=\cos{\left(\mathrm{odd}\cdot\dfrac{\pi}{2n}\right)}\\
\end{aligned}
\]</span></p>
<p><img src="/2021/10/23/computation/pyr/04/image-20211024164159998.jpg" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(T_n(x)\)</span> 在 <span class="math inline">\([-1,1]\)</span> 之间一共往返 <span class="math inline">\(n+1\)</span> 次，发生在 <span class="math inline">\(\cos{\dfrac{i\pi}{n}},i=0,\cdots,n\)</span></li>
<li>对于多项式 <span class="math inline">\(T_{n}(x)\)</span>
<ul>
<li><span class="math inline">\(\dfrac{T_n(x)}{2^{n-1}}\)</span>
为首一多项式（主导系数为 <span class="math inline">\(1\)</span>）</li>
<li><span class="math inline">\(x_i\)</span> 为切比雪夫不等式 <span class="math inline">\(T_n(x)\)</span> 的过零点，那么有</li>
</ul></li>
</ul>
<p><span class="math display">\[
\dfrac{T_n(x)}{2^{n-1}}=\prod_{i=1}^{n}(x-x_i)
\]</span></p>
<h4 id="切比雪夫定理的证明">切比雪夫定理的证明</h4>
<p><img src="/2021/10/23/computation/pyr/04/image-20211024165454359.jpg" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(\vert{t}\vert&lt;\dfrac{1}{2^{n-1}}\Rightarrow{t-(-\dfrac{1}{2^{n-1}})&gt;0,t-(\dfrac{1}{2^{n-1}})&lt;0}\)</span></li>
</ul>
<h3 id="区间的变化">3.3 区间的变化</h3>
<ul>
<li><span class="math inline">\([-1,1]\to[a,b]\)</span></li>
<li>相对位置不变：<strong>拉伸</strong> + <strong>平移</strong></li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
x_i=\cos{\left(\mathrm{odd}\cdot\dfrac{\pi}{2n}\right)}\\
\Rightarrow\\
x_i=\dfrac{b-a}{2}\cos{\left(\mathrm{odd}\cdot\dfrac{\pi}{2n}\right)}+\dfrac{a+b}{2}
\end{array}
\]</span></p>
<ul>
<li>上界发生变化：相当于对因子 <span class="math inline">\(x-x_i\)</span> 做了拉伸</li>
</ul>
<p><span class="math display">\[
\dfrac{1}{2^{n-1}}\Rightarrow\left(\dfrac{b-a}{2}\right)^{n}\dfrac{1}{2^{n-1}}
\]</span></p>
<ul>
<li>切比雪夫插值节点</li>
</ul>
<p><img src="/2021/10/23/computation/pyr/04/image-20211024171607603.jpg" style="zoom:80%;"></p>
<ul>
<li>切比雪夫多项式是将一般函数转化为少量浮点计算的一种好的方式
<ul>
<li>可以简化计算</li>
<li>容易得到误差上界，这个误差上界通常比均匀分布的插值的误差小，并且可以根据需要把它变得足够小</li>
</ul></li>
</ul>
<h4 id="cordic">CORDIC</h4>
<ul>
<li>CORDIC （坐标旋转数字计算机）算法
<ul>
<li>计算器中用于近似 <span class="math inline">\(\sin,\cos\)</span>
的算法</li>
<li>基于复数算术的迭代算法</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.05.最小二乘(2)</title>
    <url>/2021/10/29/computation/pyr/05-1/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 4 章（最小二乘） + PPT（最小二乘法）</li>
</ul>
<h1 id="最小二乘">最小二乘</h1>
<h2 id="广义最小余项gmres方法">4. 广义最小余项(GMRES)方法</h2>
<h3 id="krylov-方法">4.1 Krylov 方法</h3>
<ul>
<li>GMRES 属于 Krylov 方法
<ul>
<li>这些方法依赖精确的 Krylov 空间的计算</li>
<li>该空间是向量 <span class="math inline">\(\{r,Ar,\cdots,A^{k}r\}\)</span>
所张成的空间，<span class="math inline">\(r=b-A_0\)</span>
为初始估计的余项</li>
</ul></li>
<li>GMRES 的思想是在特殊矢量空间（即 Krylov 空间）中寻找初始估计的 <span class="math inline">\(x_0\)</span> 的改进</li>
</ul>
<h4 id="算法">算法</h4>
<ul>
<li><span class="math inline">\(A:n\times n,Q_k:n\times
k,H_k:(k+1)\times k\)</span></li>
<li><span class="math inline">\(k&lt;n\)</span></li>
</ul>
<p><img src="/2021/10/29/computation/pyr/05-1/image-20211029231029682.png" style="zoom:80%;"></p>
<ul>
<li>算法解释
<ul>
<li>Krylov 空间由余项 <span class="math inline">\(r\)</span>
和它与非奇异矩阵 <span class="math inline">\(A\)</span> 的积所张成</li>
<li>在该方法的第 <span class="math inline">\(k\)</span> 步，我们加入
<span class="math inline">\(A^{k}r\)</span> 以扩大 Krylov
空间，重新对基进行正交化，然后通过最小二乘获取改进并加到 <span class="math inline">\(x_0\)</span> 中</li>
</ul></li>
</ul>
<p><img src="/2021/10/29/computation/pyr/05-1/image-20211029231917572.jpg" style="zoom:80%;"></p>
<ul>
<li>具体步骤解释</li>
</ul>
<p><img src="/2021/10/29/computation/pyr/05-1/image-20211029233029937.jpg" style="zoom:80%;"></p>
<ul>
<li>代价最高的是最小二乘的计算，如果 <span class="math inline">\(h_{k+1,k}=0\)</span>，则变成精确求解</li>
</ul>
<h4 id="误差分析">误差分析</h4>
<ul>
<li>后向误差 <span class="math inline">\(\Vert{b-Ax_k}\Vert_2\)</span>
随着 <span class="math inline">\(k\)</span> 单调下降
<ul>
<li>由于最小二乘问题第 <span class="math inline">\(k\)</span> 步在 <span class="math inline">\(k\)</span> 维 Krylov 空间中最小化 <span class="math inline">\(\Vert{b-Ax_{add}}\Vert_2\)</span> 得到 <span class="math inline">\(x_{add}\)</span></li>
<li>当 GMRES 运行下去，Krylov 空间逐步变大，因而下一个近似不会变差</li>
</ul></li>
</ul>
<h4 id="实现的一些问题">实现的一些问题</h4>
<ul>
<li>最小二乘的步骤只有在需要求近似解 <span class="math inline">\(x_k\)</span>
的时候才需要用到，因此并不是每一次都需要求
<ul>
<li><span class="math inline">\(x_k\)</span> 只与之前的 <span class="math inline">\(x_0\)</span>相关</li>
</ul></li>
<li><strong>条件数</strong>影响问题求解的话，可以使用<strong>豪斯霍尔德正交变换</strong>替换<strong>格拉姆-施密特正交变换</strong></li>
<li>GMRES 的典型用途是用于大规模稀疏的 <span class="math inline">\(n\times n\)</span> 矩阵 <span class="math inline">\(A\)</span>
<ul>
<li>理论上，算法经过 <span class="math inline">\(n\)</span> 步终止，只要
<span class="math inline">\(A\)</span> 是非奇异矩阵就可以得到解 <span class="math inline">\(x\)</span></li>
<li>在大多数情况下，目标是仅仅运行 <span class="math inline">\(k\)</span> 步，<span class="math inline">\(k\)</span> 比 <span class="math inline">\(n\)</span> 要小得多</li>
<li>内存限制：矩阵 <span class="math inline">\(Q_k\)</span>
过大，限制步数 <span class="math inline">\(k\)</span></li>
</ul></li>
</ul>
<h4 id="重启-gmres">重启 GMRES</h4>
<ul>
<li>k 步迭代后没能足够趋近解，而继续操作可能收到内存限制（<span class="math inline">\(Q_k\)</span> 太大），重启算法</li>
<li><strong>让现在的 <span class="math inline">\(x_k\)</span> 作为 <span class="math inline">\(x_0\)</span> 重启算法</strong></li>
</ul>
<h3 id="预条件-gmres">4.2 预条件 GMRES</h3>
<ul>
<li>非对称线性方程组：<span class="math inline">\(Ax=b\)</span></li>
<li>加入预条件子：<span class="math inline">\(M^{-1}Ax=M^{-1}b\)</span></li>
</ul>
<h4 id="算法-1">算法</h4>
<p><img src="/2021/10/29/computation/pyr/05-1/image-20211030105912982.png" style="zoom:80%;"></p>
<ul>
<li>注意到这些步骤都不需要对 <span class="math inline">\(M^{-1}\)</span>
进行显式定义，<span class="math inline">\(M^{-1}\)</span>
可以通过回代完成，其中假设 <span class="math inline">\(M\)</span>
是一个简单或者分解的形式</li>
</ul>
<p><span class="math display">\[
x=M^{-1}y\Leftrightarrow y=Mx
\]</span></p>
<ul>
<li>实验</li>
</ul>
<p><img src="/2021/10/29/computation/pyr/05-1/image-20211030111452819.jpg" style="zoom:80%;"></p>
<h2 id="非线性最小二乘">5. 非线性最小二乘</h2>
<ul>
<li>线性方程组 <span class="math inline">\(Ax=b\)</span>
的最小二乘解求解方法
<ul>
<li>法线方程</li>
<li>QR 分解</li>
</ul></li>
<li>非线性方程组？<strong>高斯牛顿方法</strong>！</li>
</ul>
<h3 id="高斯牛顿方法">5.1 高斯牛顿方法</h3>
<ul>
<li><span class="math inline">\(m\)</span> 个方程，<span class="math inline">\(n\)</span> 个未知变量的方程组</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
r_1(x_1,\cdots,x_n)=0\\
\cdots\\
r_m(x_1,\cdots,x_n)=0\\
\end{array}
\]</span></p>
<ul>
<li>误差平方和
<ul>
<li><strong><span class="math inline">\(\dfrac{1}{2}\)</span>
是为了简化后面模型</strong></li>
</ul></li>
</ul>
<p><span class="math display">\[
E(x_1,\cdots,x_n)=\dfrac{1}{2}(r_1^2,\cdots,r_n^2)=\dfrac{1}{2}r^Tr
\]</span></p>
<ul>
<li>最小化 <span class="math inline">\(E\)</span>，让梯度 <span class="math inline">\(F(x)=\nabla{E(x)}=0\)</span></li>
</ul>
<p><span class="math display">\[
F(x)=\nabla\left(\dfrac{1}{2}r^{T}(x)r(x)\right)=r^{T}(x)Dr(x)
\]</span></p>
<ul>
<li>现在我们需要使用多变量的牛顿法求解非线性方程组 <span class="math inline">\(F^{T}(x)=0\)</span>
<ul>
<li><a href="/2021/10/14/computation/pyr/03-2/">note</a></li>
</ul></li>
</ul>
<p><span class="math display">\[
F^{T}=(Dr)^{T}r
\]</span></p>
<p><span class="math display">\[
D\big(F^{T}\big)=D\big((Dr)^{T}r\big)=(Dr)^{T}Dr+\sum_{i=1}^{m}r_iDc_i
\]</span></p>
<ul>
<li><strong><span class="math inline">\(D\)</span>
表示雅各比矩阵</strong></li>
</ul>
<p><span class="math display">\[
Dr=\begin{pmatrix}
\dfrac{\partial{r_1}}{\partial{x_1}}&amp;\cdots&amp;\dfrac{\partial{r_1}}{\partial{x_n}}\\
\vdots&amp;&amp;\vdots\\
\dfrac{\partial{r_n}}{\partial{x_1}}&amp;\cdots&amp;\dfrac{\partial{r_n}}{\partial{x_n}}\\
\end{pmatrix}
\]</span></p>
<ul>
<li><span class="math inline">\(c_i\)</span> 是 <span class="math inline">\(Dr\)</span> 的第 <span class="math inline">\(i\)</span> 列，<span class="math inline">\(Dc_i=Hr_i\)</span>，<strong><span class="math inline">\(H\)</span> 表示海森矩阵</strong></li>
</ul>
<p><span class="math display">\[
Hr_i=\begin{pmatrix}
\dfrac{\partial^2{r_i}}{\partial{x_1}\partial{x_1}}&amp;\cdots&amp;\dfrac{\partial^2{r_i}}{\partial{x_1}\partial{x_n}}\\
\vdots&amp;&amp;\vdots\\
\dfrac{\partial^2{r_i}}{\partial{x_n}\partial{x_1}}&amp;\cdots&amp;\dfrac{\partial^2{r_i}}{\partial{x_n}\partial{x_n}}\\
\end{pmatrix}
\]</span></p>
<ul>
<li>简化方法舍去 <span class="math inline">\(m\)</span> 步求和</li>
<li>本质上就是多便来给你牛顿法求解 <span class="math inline">\(F^{T}(x)=0\)</span></li>
</ul>
<p><img src="/2021/10/29/computation/pyr/05-1/image-20211030122056915.jpg" style="zoom:80%;"></p>
<h4 id="例题">例题</h4>
<ul>
<li>平面上 3 个圆，求交点</li>
</ul>
<h5 id="最小二乘高斯牛顿法">(1) 最小二乘：高斯牛顿法</h5>
<ul>
<li>定义误差项</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
r_1(x,y)=\sqrt{(x-x_1)^2+(y-y_1)^2}-R_1\\
r_2(x,y)=\sqrt{(x-x_2)^2+(y-y_2)^2}-R_2\\
r_3(x,y)=\sqrt{(x-x_3)^2+(y-y_3)^2}-R_3\\
\end{array}
\]</span></p>
<ul>
<li>应用上述算法</li>
</ul>
<p><img src="/2021/10/29/computation/pyr/05-1/image-20211030143944627.jpg" style="zoom:80%;"></p>
<h5 id="多变量牛顿方法">(2) 多变量牛顿方法</h5>
<ul>
<li>不直接去寻找交点，我们可以使用公共量扩大（或者缩小）圆的半径，直到它们具有一个公共的交点，这等价于求解系统</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
r_1(x,y,K)=\sqrt{(x-x_1)^2+(y-y_1)^2}-(R_1+K)=0\\
r_2(x,y,K)=\sqrt{(x-x_2)^2+(y-y_2)^2}-(R_2+K)=0\\
r_3(x,y,K)=\sqrt{(x-x_3)^2+(y-y_3)^2}-(R_3+K)=0\\
\end{array}
\]</span></p>
<ul>
<li>多变量牛顿方法求解</li>
</ul>
<h5 id="结合两种角度">(3) 结合两种角度</h5>
<ul>
<li>但是和上面不是一个题目了</li>
</ul>
<p><img src="/2021/10/29/computation/pyr/05-1/image-20211030144945340.jpg" style="zoom:80%;"></p>
<ul>
<li>高斯牛顿，最小二乘</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
r_1(x,y,K)=\sqrt{(x-x_1)^2+(y-y_1)^2}-K=0\\
r_2(x,y,K)=\sqrt{(x-x_2)^2+(y-y_2)^2}-K=0\\
r_3(x,y,K)=\sqrt{(x-x_3)^2+(y-y_3)^2}-K=0\\
r_4(x,y,K)=\sqrt{(x-x_4)^2+(y-y_4)^2}-K=0\\
\end{array}
\]</span></p>
<h3 id="具有非线性参数的模型">5.2 具有非线性参数的模型</h3>
<ul>
<li>例如：拟合函数 <span class="math inline">\(y_i=f_i(t)=c_1t_1^{c_2}\)</span></li>
<li><strong>无法写成矩阵形式</strong>，而使用线性化则破坏了原有的最小二乘的定义</li>
<li>可以使用高斯牛顿方法求解</li>
<li>问题：<strong>收敛问题</strong>
<ul>
<li>最小二乘问题中的非线性带来额外的挑战。法线方程以及 QR
方法只要系数矩阵 A 满秩都可以找到唯一解</li>
<li>而对于非线性问题的高斯-牛顿迭代可能收敛到多个极小平方误差中的一个，<strong>尽可能使用初始向量的合理近似</strong>，有助于收敛到绝对极小</li>
</ul></li>
</ul>
<h3 id="levenberg-marquardt-方法">5.3 Levenberg-Marquardt 方法</h3>
<ul>
<li>当最小二乘<strong>系数矩阵变为病态</strong>时将会面临挑战。例如使用法线方程最小二乘求解
<span class="math inline">\(Ax=b\)</span> 时会遇到大的误差，这是由于
<span class="math inline">\(A^TA\)</span> 具有大的条件数</li>
<li>对于非线性最小二乘问题，情况通常会变得更糟。很多定义得很好的模型得到了<strong>条件数很差的
<span class="math inline">\(Dr\)</span> 矩阵</strong>
<ul>
<li>Levenberg-Marquardt 方法使用 <strong>“正则化项”</strong>
部分修复这个问题
<ul>
<li>可以看做是混合高斯-牛顿以及最速下降方法</li>
</ul></li>
</ul></li>
<li><strong>Levenberg-Marquardt
方法是高斯牛顿方法的简单改进</strong></li>
</ul>
<p><img src="/2021/10/29/computation/pyr/05-1/image-20211030150538109.jpg" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(\lambda\ne0\)</span> 时，加强了矩阵
<span class="math inline">\(A^{T}A\)</span>
对角元素的作用，<strong>通常可以改善条件数</strong>
<ul>
<li>可以允许更宽的初始估计并实现收敛</li>
</ul></li>
<li>发展历程
<ul>
<li>这个方法最初由 Levenberg[1944] 提出，在高斯-牛顿方法的 <span class="math inline">\(A^TA\)</span> 加入 <span class="math inline">\(\lambda I\)</span>
以改进对应的条件。几年后，DuPont 的一位统计学家 D.
Marquardt，改进了Levenberg 的提议，将单位矩阵替换为 <span class="math inline">\(A^TA\)</span>
的对角线矩阵（Mar-quardt[1963]）</li>
</ul></li>
<li>系数 <span class="math inline">\(\lambda\)</span>
<ul>
<li>尽管为了简单，我们将 <span class="math inline">\(\lambda\)</span>
看做常数，但是该方法常常使用不同 <span class="math inline">\(\lambda\)</span>
以适应问题，一般的策略是在每个迭代步骤中，只要余下的平方误差和在每步中降低就使用因子10连续降低
<span class="math inline">\(\lambda\)</span>，如果误差升高，则拒绝当前步，并以因子10升高
<span class="math inline">\(\lambda\)</span></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.05.最小二乘(3)</title>
    <url>/2021/10/31/computation/pyr/05-2/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 4 章（最小二乘） + PPT（最小二乘法）</li>
</ul>
<h1 id="最小二乘">最小二乘</h1>
<ul>
<li>PPT 补充</li>
</ul>
<h2 id="拟合与插值">1. 拟合与插值</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">拟合</th>
<th style="text-align: center;">插值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">参数 <span class="math inline">\(a_1,\cdots,a_n(n&lt;m)\)</span></td>
<td style="text-align: center;">参数 <span class="math inline">\(a_1,\cdots,a_m\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(y_k(x_k)\approx y_k\)</span></td>
<td style="text-align: center;"><span class="math inline">\(y_k(x_k)=y_k\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">近似关系</td>
<td style="text-align: center;">精确通过</td>
</tr>
<tr class="even">
<td style="text-align: center;">简单函数</td>
<td style="text-align: center;">复杂函数</td>
</tr>
</tbody>
</table>
<h3 id="过拟合">过拟合</h3>
<ul>
<li>将具有 <span class="math inline">\(n\)</span> 个自由度的函数拟合到
<span class="math inline">\(n\)</span>
个数据点上，不会留下数据点上的误差</li>
</ul>
<p><img src="/2021/10/31/computation/pyr/05-2/image-20211031225245391.png" style="zoom: 33%;"></p>
<h2 id="最小二乘-1">2. 最小二乘</h2>
<ul>
<li>有解 or 无解</li>
</ul>
<p><img src="/2021/10/31/computation/pyr/05-2/image-20211031225516493.png" style="zoom:80%;"></p>
<ul>
<li>超定方程
<ul>
<li>可能是不相容的线性方程组</li>
</ul></li>
</ul>
<p><img src="/2021/10/31/computation/pyr/05-2/image-20211031225552181.png" style="zoom:80%;"></p>
<h3 id="法线方程">法线方程</h3>
<ul>
<li>余项范数 <span class="math inline">\(\Vert{b-Ax}\Vert_2\)</span>
的极小值满足法线方程 <span class="math inline">\(A^{T}Ax=A^{T}b\)</span></li>
</ul>
<p><span class="math display">\[
\Vert{b-Ax}\Vert_2^{2}=(b-Ax)^{T}(b-Ax)=b^{T}b-2x^{T}A^{T}b+x^{T}A^{T}Ax
\]</span></p>
<ul>
<li>极小值满足偏导数为 0</li>
</ul>
<p><span class="math display">\[
-2A^{T}b+2A^{T}Ax=0
\]</span></p>
<ul>
<li>法线方程</li>
</ul>
<p><span class="math display">\[
A^{T}Ax=A^{T}b
\]</span></p>
<h4 id="矩阵求导">矩阵求导</h4>
<ul>
<li><span class="math inline">\(\dfrac{\partial{Ax}}{\partial{x}}=A\)</span></li>
</ul>
<p><span class="math display">\[
\dfrac{\partial{y}}{\partial{x}}=\begin{pmatrix}
\dfrac{\partial{y_1}}{\partial{x_1}}&amp;\cdots&amp;\dfrac{\partial{y_1}}{\partial{x_n}}\\
\vdots&amp;&amp;\vdots\\
\dfrac{\partial{y_n}}{\partial{x_1}}&amp;\cdots&amp;\dfrac{\partial{y_n}}{\partial{x_n}}\\
\end{pmatrix}
\]</span></p>
<ul>
<li><span class="math inline">\(\dfrac{\partial{x^{T}A}}{\partial{x}}=A^{T}\)</span></li>
<li><span class="math inline">\(\dfrac{\partial{x^{T}b}}{\partial{x}}=\dfrac{\partial{b^{T}x}}{\partial{x}}=b\)</span></li>
<li><span class="math inline">\(\dfrac{\partial{x^{T}Ax}}{\partial{x}}=(A+A^{T})x\)</span></li>
</ul>
<p><span class="math display">\[
x^{T}Ax=\sum_{j=1}^{n}x_j\sum_{i=1}^{n}x_ia_{ij}=\sum_{j=1}^{n}\sum_{i=1}^{n}a_{ij}x_ix_j
\]</span></p>
<p><span class="math display">\[
\dfrac{\partial{y_i}}{\partial{x_j}}=(a_{ij}+a_{ji})x_i
\]</span></p>
<h2 id="离散最小二乘近似">3. 离散最小二乘近似</h2>
<ul>
<li>拟合数据点</li>
</ul>
<h3 id="不同误差度量">不同误差度量</h3>
<ul>
<li>最小最大：对最差的点给了最大的权重</li>
</ul>
<p><span class="math display">\[
\max_{1\le i\le m}\vert{P(x_i)-y_i}\vert
\]</span></p>
<ul>
<li>绝对偏差：<strong>没有给直线外点足够的权重</strong></li>
</ul>
<p><span class="math display">\[
\sum_{i=1}^{m}\vert{P(x_i)-y_i}\vert
\]</span></p>
<ul>
<li>最小二乘</li>
</ul>
<p><span class="math display">\[
\sum_{i=1}^{m}\Vert{P(x_i)-y_i}\Vert^{2}
\]</span></p>
<h3 id="直线拟合">直线拟合</h3>
<ul>
<li>最小二乘</li>
</ul>
<p><span class="math display">\[
E=\sum_{i=1}^{m}({y_i-(a_0+a_1x_i)})^{2}
\]</span></p>
<ul>
<li>极值定理，可以求得 <span class="math inline">\(a_0,a_1\)</span></li>
</ul>
<p><span class="math display">\[
\dfrac{\partial{E}}{\partial{a_0}}=0,\dfrac{\partial{E}}{\partial{a_1}}=0
\]</span></p>
<ul>
<li>解得</li>
</ul>
<p><span class="math display">\[
a_0=\dfrac
{\left(\sum_{i=1}^{m}x_i^2\right)\left(\sum_{i=1}^{m}y_i\right)-\left(\sum_{i=1}^{m}x_i\right)\left(\sum_{i=1}^{m}x_iy_i\right)}
{m\left(\sum_{i=1}^{m}x_i^2\right)-\left(\sum_{i=1}^{m}x_i\right)\left(\sum_{i=1}^{m}x_i\right)}
\]</span></p>
<p><span class="math display">\[
a_1=\dfrac
{m\left(\sum_{i=1}^{m}x_iy_i\right)-\left(\sum_{i=1}^{m}x_i\right)\left(\sum_{i=1}^{m}y_i\right)}
{m\left(\sum_{i=1}^{m}x_i^2\right)-\left(\sum_{i=1}^{m}x_i\right)\left(\sum_{i=1}^{m}x_i\right)}
\]</span></p>
<h3 id="多项式拟合">多项式拟合</h3>
<p><span class="math display">\[
p_n(x)=a_nx^n+\cdots+a_1x+a_0
\]</span></p>
<ul>
<li>最小二乘</li>
</ul>
<p><span class="math display">\[
E=\sum_{i=1}^{m}({y_i-p_n(x)})^{2}
\]</span></p>
<ul>
<li>极值定理</li>
</ul>
<p><span class="math display">\[
\dfrac{\partial{E}}{\partial{a_j}}=-2\sum_{i=1}^{m}(y_i-p_n(x_i))x_i^j=-2\sum_{i=1}^{m}y_ix_i^{j}+2\sum_{k=0}^{n}a_k\sum_{i=1}^{m}x_i^{k+j}
\]</span></p>
<p><span class="math display">\[
\sum_{k=0}^{n}a_k\sum_{i=1}^{m}x_{i}^{k+j}=\sum_{i=1}^{m}y_ix_{i}^{j},j=0,\cdots,n
\]</span></p>
<ul>
<li>得到一组方程组，当 <span class="math inline">\(x_i\)</span>
都不相同，方程组具有唯一解</li>
</ul>
<p><span class="math display">\[
\begin{align}
a_0\sum_{i=1}^{m}x_{i}^{1}+a_1\sum_{i=1}^{m}x_{i}^{1}+\cdots+a_n\sum_{i=1}^{m}x_{i}^{n}&amp;=\sum_{i=1}^{m}y_ix_{i}^{0}\\
&amp;\cdots\\
a_0\sum_{i=1}^{m}x_{i}^{n}+a_1\sum_{i=1}^{m}x_{i}^{n+1}+\cdots+a_n\sum_{i=1}^{m}x_{i}^{2n}&amp;=\sum_{i=1}^{m}y_ix_{i}^{n}\\
\end{align}
\]</span></p>
<h4 id="唯一解证明">唯一解证明</h4>
<ul>
<li>构造 <span class="math inline">\((n+1)\times(n+1)\)</span> 阶矩阵
<span class="math inline">\(A=(a_{ij})\)</span>，<span class="math inline">\(m&gt;n+1\)</span>
<ul>
<li>下标 1 开始</li>
</ul></li>
</ul>
<p><span class="math display">\[
a_{ij}=\sum_{k=1}^{m}x_{k}^{i+j-2}
\]</span></p>
<ul>
<li>构造 <span class="math inline">\((n+1)\)</span> 维向量 <span class="math inline">\(a\)</span> 如下</li>
</ul>
<p><span class="math display">\[
x=(a_0,\cdots,a_n)^{T}
\]</span></p>
<ul>
<li>构造 <span class="math inline">\((n+1)\)</span> 维向量 <span class="math inline">\(b\)</span> 如下</li>
</ul>
<p><span class="math display">\[
y=\left(\sum_{i=1}^{m}y_ix_i^0,\cdots,\sum_{i=1}^{m}y_ix_i^n\right)^{T}
\]</span></p>
<ul>
<li>法线方程转化为</li>
</ul>
<p><span class="math display">\[
Ax=y
\]</span></p>
<ul>
<li>相当于已知 <span class="math inline">\(A,y\)</span> 求解 <span class="math inline">\(x\)</span>，唯一解等价于证明 <span class="math inline">\(A\)</span> 是非奇异矩阵</li>
<li>假设 <span class="math inline">\(A\)</span> 是奇异矩阵，则存在向量
<span class="math inline">\(c\ne0\)</span> 使得 <span class="math inline">\(c^{T}A{c}=0\)</span>（<span class="math inline">\(A\)</span> 中向量不能张成 <span class="math inline">\(n+1\)</span> 维空间 ）</li>
<li>我们对 <span class="math inline">\(A\)</span> 做分解，令 <span class="math inline">\(m\times(n+1)\)</span> 阶 <span class="math inline">\(B=(b_{ij})\)</span></li>
</ul>
<p><span class="math display">\[
b_{ij}=x_{i}^{j-1}
\]</span></p>
<ul>
<li>我们可以得到 <span class="math inline">\(A=B^{T}B\)</span></li>
<li><span class="math inline">\(c^{T}Ac=c^{T}B^{T}Bc=(Bc)^T(Bc)=0\)</span></li>
<li>我们设 <span class="math inline">\(f(x)=c_0+c_1x+\cdots+c_nx^{n}\)</span></li>
</ul>
<p><span class="math display">\[
Bc=\Big(f(x_1),\cdots,f(x_m)\Big)^{T}
\]</span></p>
<p><span class="math display">\[
(Bc)^{t}(BC)=f^2(x_1)+\cdots+f^2(x_m)=0
\]</span></p>
<ul>
<li>于是我们得到 <span class="math inline">\(f(x)=0\)</span> 有 <span class="math inline">\(m\)</span> 个解 <span class="math inline">\(x_1,\cdots,x_m\)</span></li>
<li>而 <span class="math inline">\(f(x)\)</span> 的阶数为 <span class="math inline">\(n\)</span>，最多有 <span class="math inline">\(n\)</span> 个解，而 <span class="math inline">\(m&gt;n+1&gt;n\)</span>，推出矛盾</li>
<li>因此 <span class="math inline">\(A\)</span>
是非奇异矩阵，法线方程具有唯一解</li>
</ul>
<h3 id="非线性模型">非线性模型</h3>
<ul>
<li>指数模型：<strong>线性化</strong>
<ul>
<li><strong>两个模型求解一般不同</strong>：误差 / 损失函数不同</li>
</ul></li>
<li>模型函数、损失函数</li>
</ul>
<h2 id="连续最小二乘">4. 连续最小二乘</h2>
<h3 id="多项式模型">多项式模型</h3>
<ul>
<li><span class="math inline">\(n\)</span> 阶多项式近似</li>
</ul>
<p><span class="math display">\[
p_n(x)=a_nx^n+\cdots+a_1x+a_0
\]</span></p>
<ul>
<li>误差</li>
</ul>
<p><span class="math display">\[
E=\int_{a}^{b}(f(x)-p_n(x))^2\;\mathrm{d}x
\]</span></p>
<ul>
<li>极值定理</li>
</ul>
<p><span class="math display">\[
\dfrac{\partial{E}}{\partial{a_j}}=-2\int_{a}^{b}(f(x)-p_n(x))x^j\;\mathrm{d}x=-2\int_{a}^{b}f(x)x^{j}\;\mathrm{d}x+2\sum_{k=0}^{n}a_k\int_{a}^{b}x^{k+j}\;\mathrm{d}x=0
\]</span></p>
<p><span class="math display">\[
\sum_{k=0}^{n}a_k{\color{red}\int_{a}^{b}x^{k+j}\;\mathrm{d}x}=\int_{a}^{b}f(x)x^{j}\;\mathrm{d}x
\]</span></p>
<ul>
<li>其中红色部分</li>
</ul>
<p><span class="math display">\[
\int_{a}^{b}x^{k+j}\;\mathrm{d}x=\dfrac{b^{j+k+1}-a^{j+k+1}}{j+k+1}
\]</span></p>
<ul>
<li>求解 <span class="math inline">\(n+1\)</span> 个未知数 <span class="math inline">\(a_j\)</span></li>
<li>系数矩阵的条件数很大，病态矩阵</li>
<li>希尔伯特矩阵（Hilbert 矩阵）
<ul>
<li><span class="math inline">\(H=(h_{ij})=(\dfrac{1}{i+j-2})\)</span></li>
<li>条件数 <span class="math inline">\(cond(H_n)_{\infty}\to\infty\)</span></li>
</ul></li>
</ul>
<h3 id="线性无关">线性无关</h3>
<ul>
<li>如果 <span class="math inline">\(c_0\phi_0+\cdots+c_n\phi_n=0\)</span> 在 <span class="math inline">\([a,b]\)</span> 上恒成立能够推出 <span class="math inline">\(c_j=0,\forall j\)</span>，则函数 <span class="math inline">\(\phi_0,\cdots,\phi_n\)</span> 在区间 <span class="math inline">\([a,b]\)</span> 上<strong>线性无关</strong></li>
</ul>
<h4 id="多项式">多项式</h4>
<ul>
<li>如果 <span class="math inline">\(\phi_j\)</span> 是 <span class="math inline">\(j\)</span> 阶多项式，那么多项式 <span class="math inline">\(\{\phi_0,\cdots,\phi_n\}\)</span> 在区间 <span class="math inline">\([a,b]\)</span> 上线性无关</li>
<li>证明
<ul>
<li>从 <span class="math inline">\(\phi_n\)</span>
开始，因为只有这一个多项式含有 <span class="math inline">\(n\)</span>
次方项，于是 <span class="math inline">\(c_n=0\)</span></li>
<li>逐步向低阶，此时只有 <span class="math inline">\(\phi_{n-1}\)</span>
有 <span class="math inline">\(n-1\)</span> 次方项，于是 <span class="math inline">\(c_{n-1}=0\)</span></li>
<li>类似的，证明 <span class="math inline">\(c_j=0,\forall
j\)</span></li>
</ul></li>
<li><span class="math inline">\(\prod_n\)</span>：至多 <span class="math inline">\(n\)</span> 阶多项式集合
<ul>
<li><span class="math inline">\(\{\phi_0,\cdots,\phi_n\}\)</span> 是
<span class="math inline">\(\prod_n\)</span> 中的线性无关多项式集合，则
<span class="math inline">\(\prod_n\)</span> 中的任意多项式可以唯一写作
<span class="math inline">\(\{\phi_0,\cdots,\phi_n\}\)</span>
的线性组合</li>
</ul></li>
</ul>
<h3 id="权函数">权函数</h3>
<ul>
<li><span class="math inline">\(w(x)\)</span>：在区间 <span class="math inline">\(I\)</span> 中，<span class="math inline">\(w(x)\ge0\)</span>，在 <span class="math inline">\(I\)</span> 的任意子区间中 <span class="math inline">\(w(x)\ne0\)</span></li>
</ul>
<h3 id="多项式基函数组合模型"><strong>多</strong>项式基函数组合模型</h3>
<ul>
<li>修改 <span class="math inline">\(p_n(x)\)</span> 如下</li>
</ul>
<p><span class="math display">\[
p_n(x)=\sum_{k=0}^{n}a_k\phi_k(x)
\]</span></p>
<ul>
<li>误差</li>
</ul>
<p><span class="math display">\[
E=\int_{a}^{b}w(x)(f(x)-p_n(x))^2\;\mathrm{d}x
\]</span></p>
<ul>
<li>类似的，使用极值定理求解系数</li>
</ul>
<p><span class="math display">\[
\dfrac{\partial{E}}{\partial{a_j}}
=\int_{a}^{b}w(x)[f(x)-\sum_{k=0}^{n}a_k\phi_k(x)]\phi_j(x)\;\mathrm{d}x
=0
\]</span></p>
<p><span class="math display">\[
\int_{a}^{b}w(x)f(x)\phi_j(x)\;\mathrm{d}x=\sum_{k=0}^{n}a_k\int_{a}^{b}w(x)\phi_k(x)\phi_j(x)\;\mathrm{d}x
\]</span></p>
<h3 id="正交条件">正交条件</h3>
<ul>
<li>关于权函数 <span class="math inline">\(w\)</span>
的正交函数集合<span class="math inline">\(\{\phi_0,\cdots,\phi_n\}\)</span> 满足</li>
</ul>
<p><span class="math display">\[
\int_a^bw(x)\phi_i(x)\phi_j(x)=\left\{\begin{array}{rr}
0,&amp;j\ne i\\
\alpha_i,&amp;j=i
\end{array}\right.
\]</span></p>
<ul>
<li>单位正交集合：<span class="math inline">\(\alpha_i=0\)</span></li>
<li>最小二乘近似被简化</li>
</ul>
<p><span class="math display">\[
\int_{a}^{b}w(x)f(x)\phi_j(x)\;\mathrm{d}x=\sum_{k=0}^{n}a_k\int_{a}^{b}w(x)\phi_k(x)\phi_j(x)\;\mathrm{d}x=a_j\alpha_j
\]</span></p>
<p><span class="math display">\[
a_j=\dfrac{\int_{a}^{b}w(x)f(x)\phi_j(x)\;\mathrm{d}x}{\alpha_j}
=\dfrac{\int_{a}^{b}w(x)f(x)\phi_j(x)\;\mathrm{d}x}{\int_{a}^{b}w(x)\phi_j^2(x)\;\mathrm{d}x}
\]</span></p>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.05.最小二乘(4)</title>
    <url>/2021/11/01/computation/pyr/05-3/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 4 章（最小二乘） + PPT（最小二乘法）</li>
</ul>
<h1 id="最小二乘">最小二乘</h1>
<ul>
<li>PPT 补充</li>
</ul>
<h2 id="多项式近似">5. 多项式近似</h2>
<ul>
<li>如何构造正交多项式 <span class="math inline">\(\phi_0,\cdots,\phi_n\)</span></li>
</ul>
<h3 id="gram-schmidt-方法">(1) Gram-Schmidt 方法</h3>
<ul>
<li><span class="math inline">\(\phi_0=1\)</span></li>
<li><span class="math inline">\(\phi_1=x-B_1,B_1=\dfrac{\int_{a}^{b}xw(x)[\phi_0(x)]^2\;\mathrm{d}x}{\int_{a}^{b}w(x)[\phi_0(x)]^2\;\mathrm{d}x}\)</span></li>
<li><span class="math inline">\(k\ge2\)</span>
<ul>
<li><span class="math inline">\(\phi_k=(x-B_k)\phi_{k-1}-C_k\phi_{k-2}\)</span></li>
<li><span class="math inline">\(B_k=\dfrac{\int_{a}^{b}xw(x)[\phi_{k-1}(x)]^2\;\mathrm{d}x}{\int_{a}^{b}w(x)[\phi_{k-1}(x)]^2\;\mathrm{d}x}\)</span></li>
<li><span class="math inline">\(C_k=\dfrac{\int_{a}^{b}xw(x)\phi_{k-1}(x)\phi_{k-2}(x)\;\mathrm{d}x}{\int_{a}^{b}w(x)[\phi_{k-2}(x)]^2\;\mathrm{d}x}\)</span></li>
</ul></li>
</ul>
<h4 id="性质">性质</h4>
<ul>
<li>对于任意 <span class="math inline">\(n&gt;0\)</span>，利用
Gram-Schmidt 方法生成的多项式函数集合 <span class="math inline">\(\phi_0,\cdots,\phi_n\)</span> 在区间 <span class="math inline">\([a,b]\)</span> 上线性无关，而且对于任意的 <span class="math inline">\(k(k&lt;n)\)</span> 阶多项式，都有如下式子成立</li>
</ul>
<p><span class="math display">\[
\int_a^bw(x)\phi_nQ_k(x)\;\mathrm{d}x=0
\]</span></p>
<h5 id="证明">证明</h5>
<ul>
<li>线性无关：<span class="math inline">\(\phi_n\)</span> 为 <span class="math inline">\(n\)</span> 阶多项式即证</li>
<li>式子：<span class="math inline">\(Q_k=\sum_{j=0}^{k}a_j\phi_j\)</span></li>
</ul>
<h4 id="legendre-多项式">Legendre 多项式</h4>
<ul>
<li><span class="math inline">\([a,b]=[-1,1]\)</span></li>
<li><span class="math inline">\(w(x)=1\)</span></li>
<li><span class="math inline">\(\phi_0=1,\phi_1=x,\phi_2=x^2-\dfrac13,\cdots\)</span></li>
</ul>
<h3 id="车比雪夫多项式">(2) 车比雪夫多项式</h3>
<p><span class="math display">\[
T_n(x)=\cos(n\arccos{x})
\]</span></p>
<ul>
<li>Chebyshev 多项式
<ul>
<li><a href="/2021/10/23/computation/pyr/04/#切比雪夫多项式">具体性质</a></li>
</ul></li>
<li>在区间 <span class="math inline">\([-1,1]\)</span> 上关于 <span class="math inline">\(w(x)=\dfrac{1}{\sqrt{1-x^2}}\)</span> 正交</li>
</ul>
<h4 id="正交性">正交性</h4>
<ul>
<li><span class="math inline">\(n\ne m\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\int_{-1}^{1}\dfrac{\cos(n\arccos{x})\cos(m\arccos{x})}{\sqrt{1-x^2}}\;\mathrm{d}x\\
=&amp;\int_{0}^{\pi}\cos(n\arccos{x})\cos(m\arccos{x})\;\mathrm{d}(\arccos{x})\\
=&amp;\int_{0}^{\pi}\cos(n\theta)\cos(m\theta)\;\mathrm{d}\theta\\
=&amp;\int_{0}^{\pi}\dfrac{1}{2}(\cos{(n+m)\theta}+\cos(n-m)\theta)\;\mathrm{d}x\\
=&amp;0
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\(n=m\)</span></li>
</ul>
<p><span class="math display">\[
\dfrac{\pi}{2}
\]</span></p>
<h4 id="应用">应用</h4>
<ul>
<li>拉格朗日插值点</li>
<li>降低近似多项式的阶数</li>
</ul>
<h4 id="拉格朗日插值点">拉格朗日插值点</h4>
<ul>
<li><a href="/2021/10/23/computation/pyr/04/#切比雪夫插值">具体性质</a></li>
</ul>
<h4 id="降低多项式的阶">降低多项式的阶</h4>
<ul>
<li>利用至多 <span class="math inline">\(n-1\)</span> 阶多项式，近似区间
<span class="math inline">\([−1,1]\)</span> 上的任意 <span class="math inline">\(n\)</span> 阶多项式</li>
</ul>
<p><span class="math display">\[
\max_{x\in[-1,1]}\left\vert{\dfrac{1}{a_n}\Big(p_n(x)-p_{n-1}(x)\Big)}\right\vert\ge\dfrac{1}{2^{n-1}}
\]</span></p>
<ul>
<li>利用切比雪夫插值的性质，令 <span class="math inline">\(p_n(x)-p_{n-1}(x)=a_n\tilde{T}_n\)</span>，此时取到等号</li>
</ul>
<h3 id="比较">(3) 比较</h3>
<p><img src="/2021/11/01/computation/pyr/05-3/image-20211101153658545.png" style="zoom:80%;"></p>
<h2 id="有理函数近似">6. 有理函数近似</h2>
<ul>
<li>多项式近似
<ul>
<li>可以在闭合区间中以任意精度近似函数</li>
<li>数值计算简单
<ul>
<li>导数、积分、函数求值</li>
</ul></li>
<li><strong>可能发生震荡</strong></li>
</ul></li>
<li><span class="math inline">\(N\)</span> 阶有理函数 <span class="math inline">\(r(x)=\dfrac{p(x)}{q(x)}\)</span>
<ul>
<li><span class="math inline">\(\deg(p(x))+\deg(q(x))=N\)</span></li>
</ul></li>
<li>在有理函数中,如果 <span class="math inline">\(p(x),q(x)\)</span>
具有相近的阶数，则函数近似一般比多项式要好</li>
<li>有理函数近似能够将误差均匀分布在整个区间中</li>
</ul>
<h3 id="pade-近似">Pade 近似</h3>
<p><span class="math display">\[
r(x)=\dfrac{p(x)}{q(x)}=\dfrac{\sum_{i=0}^{n}p(x)}{\sum_{i=1}^{m}q(x)}
\]</span></p>
<ul>
<li>一共 <span class="math inline">\(N+1\)</span> 个参数</li>
<li>假设 <span class="math inline">\(f(x)=\sum_{i=0}^{\infty}a_ix^i\)</span>
<ul>
<li><span class="math inline">\(q_0=1\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
f(x)-r(x)=\dfrac{f(x)\sum_{i=0}^{m}q_ix^i-\sum_{i=0}^{n}p_ix^i}{\sum_{i=0}^{m}q_ix^i}
\]</span></p>
<ul>
<li>选择参数，使得 <span class="math inline">\(f^{(k)}(0)-r^{(k)}(0)=0,k=0,\cdots,N\)</span>
<ul>
<li><span class="math inline">\(x=0\)</span> 是 <span class="math inline">\(N+1\)</span> 重根</li>
<li>因此没有小于等于 <span class="math inline">\(N\)</span> 阶的项</li>
<li><span class="math inline">\(\sum_{i=0}^{k}a_iq_{k-i}=p_k,k=0,\cdots,N\)</span>
<ul>
<li><span class="math inline">\(N+1\)</span>个线性方程，<span class="math inline">\(N+1\)</span> 个未知量</li>
<li>初始条件
<ul>
<li><span class="math inline">\(p_{n+1}=\cdots=p_{N}=0\)</span></li>
<li><span class="math inline">\(q_{m+1}=\cdots=q_{N}=0\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="三角多项式">7. 三角多项式</h2>
<ul>
<li><span class="math inline">\([-\pi,\pi]\)</span></li>
<li><span class="math inline">\(w(x)=1\)</span></li>
<li><span class="math inline">\(\phi_i\)</span> 正交，<span class="math inline">\(i=0,\cdots,2n-1\)</span></li>
</ul>
<p><span class="math display">\[
\phi_0=\dfrac{1}{2}
\]</span></p>
<p><span class="math display">\[
\phi_k=\cos{kx},k=1,\cdots,n
\]</span></p>
<p><span class="math display">\[
\phi_{n+k}=\sin{kx},k=1,\cdots,n-1
\]</span></p>
<ul>
<li><strong>傅里叶变换</strong></li>
</ul>
<p><span class="math display">\[
S_n(x)=\dfrac{1}{2}a_0+a_n\cos{nx}+\sum_{i=1}^{n-1}(a_k\cos{kx}+b_k\sin{kx})
\]</span></p>
<h3 id="离散形式">离散形式</h3>
<ul>
<li><span class="math inline">\(2m\)</span> 对数据，<span class="math inline">\(\{(x_j,y_j)\}_{j=0}^{2m-1}\)</span>
<ul>
<li><span class="math inline">\(x_j=-\pi+\dfrac{j}{m}\pi\)</span></li>
</ul></li>
<li>误差最小化：最小二乘</li>
</ul>
<p><span class="math display">\[
E=\sum_{j=0}^{2m-1}(y_i-S_n(x_j))^2
\]</span></p>
<h3 id="性质-1">性质</h3>
<ul>
<li>若 <span class="math inline">\(r\)</span> 不是 <span class="math inline">\(2m\)</span> 的倍数，则有</li>
</ul>
<p><span class="math display">\[
\sum_{j=1}^{2m-1}\cos{rx_j}=0,\sum_{j=1}^{2m-1}\sin{rx_j}=0
\]</span></p>
<ul>
<li>若 <span class="math inline">\(r\)</span> 不是 <span class="math inline">\(m\)</span> 的倍数，则有</li>
</ul>
<p><span class="math display">\[
\sum_{j=1}^{2m-1}\cos^2{rx_j}=m,\sum_{j=1}^{2m-1}\sin^2{rx_j}=m
\]</span></p>
<ul>
<li>证明：欧拉公式</li>
</ul>
<p><span class="math display">\[
e^{iz}=\cos{z}+\sin{z}
\]</span></p>
<p><img src="/2021/11/01/computation/pyr/05-3/image-20211101165149785.png" style="zoom:80%;"></p>
<p><img src="/2021/11/01/computation/pyr/05-3/image-20211101165323503.png" style="zoom:80%;"></p>
<h3 id="正交性-1">正交性</h3>
<p><img src="/2021/11/01/computation/pyr/05-3/image-20211101165930289.png" style="zoom:80%;"></p>
<h3 id="最小二乘误差">最小二乘误差</h3>
<p><span class="math display">\[
E=\sum_{j=0}^{2m-1}(y_i-S_n(x_j))^2
\]</span></p>
<ul>
<li>偏导数为 0
<ul>
<li>只剩下蓝色部分，其余都为 0</li>
</ul></li>
</ul>
<p><img src="/2021/11/01/computation/pyr/05-3/image-20211101170048337.png" style="zoom:80%;"></p>
<ul>
<li>于是我们能够得到 <span class="math inline">\(a_k,b_k\)</span>
的表达式</li>
</ul>
<p><img src="/2021/11/01/computation/pyr/05-3/image-20211101170141190.png" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.05.最小二乘</title>
    <url>/2021/10/28/computation/pyr/05/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 4 章（最小二乘） + PPT（最小二乘法）</li>
</ul>
<h1 id="最小二乘">最小二乘</h1>
<h2 id="最小二乘法线方程">1. 最小二乘法线方程</h2>
<ul>
<li>动机
<ul>
<li><span class="math inline">\(Ax=b\)</span> 解不存在</li>
<li>存在不一致的方程</li>
<li>方程个数大于未知数个数
<ul>
<li><strong>超定方程</strong></li>
</ul></li>
</ul></li>
<li><span class="math inline">\(\to\)</span> 使用最小二乘</li>
</ul>
<h3 id="不一致的方程组">1.1 不一致的方程组</h3>
<p><span class="math display">\[
\left\{
\begin{array}{c}
x_1+x_2=2\\
x_1-x_2=1\\
x_1+x_2=3\\
\end{array}
\right.
\]</span></p>
<ul>
<li>显然上面方程组是无解的 <span class="math inline">\(\to\)</span>
<strong>不一致的</strong></li>
<li><strong>最小二乘</strong>
<ul>
<li>与解最相似的向量 <span class="math inline">\(x\)</span></li>
<li><strong>欧式距离相近</strong></li>
</ul></li>
<li>上面的方程等价于求向量 <span class="math inline">\(x\)</span>
满足</li>
</ul>
<p><span class="math display">\[
{x_1}\begin{bmatrix}1\\1\\1\\\end{bmatrix}
+{x_2}\begin{bmatrix}1\\-1\\1\\\end{bmatrix}
=\begin{bmatrix}2\\1\\3\\\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
\begin{array}{c}
{x_1}v_1+{x_2}v_2=b\\
[v_1,v_2][x_1,x_2]^{T}=b\Leftrightarrow Ax=b\\
\end{array}
\]</span></p>
<ul>
<li>三个向量共面才有解</li>
<li><strong>最小二乘</strong>：
<ul>
<li><span class="math inline">\(b\)</span> 在 <span class="math inline">\(v_1,v_2\)</span> 张成平面的投影记作 <span class="math inline">\(b&#39;\)</span></li>
<li>近似解 <span class="math inline">\(\bar{x}\)</span> 满足：<span class="math inline">\(v_1\bar{x}_1+v_2\bar{x}_2=b&#39;\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/10/28/computation/pyr/05/image-20211028102307218.jpg"></p>
<ul>
<li>近似解满足
<ul>
<li>向量 <span class="math inline">\(b-A\bar{x}\)</span> 和平面 <span class="math inline">\(\{Ax|x\in\mathbb{R}^{n}\}\)</span> 垂直</li>
</ul></li>
<li><strong>转置</strong>
<ul>
<li><span class="math inline">\((A+B)^{T}=A^{T}+B^{T}\)</span></li>
<li><span class="math inline">\((AB)^{T}=B^{T}A^{T}\)</span></li>
</ul></li>
<li><strong>正交</strong>
<ul>
<li>最小二乘基于正交，从一点到一个平面的最短距离，由一个到平面的正交线段表示，法线方程可以确定该线段，这表示<strong>最小二乘的误差</strong></li>
</ul></li>
<li>向量垂直（正交）：内积为 0</li>
<li>那么我们可以得到近似解的性质
<ul>
<li>对于任意 <span class="math inline">\(x\in\mathbb{R}^{n}\)</span>，有
<span class="math inline">\((Ax)^{T}(b-A\bar{x})=0\)</span> 成立</li>
</ul></li>
</ul>
<p><span class="math display">\[
x^{T}A^{T}(b-A\bar{x})=0,\forall x\in\mathbb{R}^n
\]</span></p>
<ul>
<li>那么我们得到，<span class="math inline">\(n\)</span> 维向量 <span class="math inline">\(A^{T}(b-A\bar{x})\)</span> 和任意 <span class="math inline">\(n\)</span> 维向量垂直（包括自身），于是有</li>
</ul>
<p><span class="math display">\[
A^{T}(b-A\bar{x})=0
\]</span></p>
<ul>
<li>最小二乘的解满足如下方程（也被称为<strong>法线方程</strong>）</li>
</ul>
<p><span class="math display">\[
A^{T}A\bar{x}=A^{T}b
\]</span></p>
<ul>
<li>最小二乘的解能够最小化余项 <span class="math inline">\(r=b-Ax\)</span> 的欧式长度</li>
</ul>
<h4 id="余项表示">余项表示</h4>
<ul>
<li>欧式长度（2 范数）</li>
</ul>
<p><span class="math display">\[
\Vert{r}\Vert_{2}=\sqrt{r_1^2+\cdots+r_{n}^2}
\]</span></p>
<ul>
<li>平方误差</li>
</ul>
<p><span class="math display">\[
SE=\Vert{r}\Vert_2^2
\]</span></p>
<ul>
<li>平均平方根误差</li>
</ul>
<p><span class="math display">\[
RMSE=\sqrt{\frac{SE}{m}}
\]</span></p>
<ul>
<li><strong>是等价度量</strong></li>
</ul>
<h3 id="数据的拟合模型">1.2 数据的拟合模型</h3>
<h4 id="最小二乘数据拟合">最小二乘数据拟合</h4>
<p><img src="/2021/10/28/computation/pyr/05/image-20211028104804297.jpg"></p>
<ul>
<li>最小二乘是<strong>数据压缩</strong>的经典例子</li>
<li><strong>条件数</strong></li>
</ul>
<p><img src="/2021/10/28/computation/pyr/05/image-20211028105417091.jpg"></p>
<ul>
<li>用 Eigen 库写了一下，感觉确实有些难顶，基本不是正常值
<ul>
<li><a href="/utils/show_code/index.html?computation/pyr/05/AtAx=Aty.cc">c++代码</a></li>
</ul></li>
</ul>
<h2 id="模型概述">2. 模型概述</h2>
<ul>
<li>数据建模包含不同的模型
<ul>
<li>底层物理规律</li>
<li>经验公式</li>
<li>...</li>
</ul></li>
</ul>
<h3 id="周期数据">2.1 周期数据</h3>
<ul>
<li><strong>周期数据使用周期模型</strong></li>
<li>一日气温变化</li>
</ul>
<p><span class="math display">\[
u=c_1+c_2\cos(2\pi t)+c_2\sin(2\pi t),\qquad
t=\dfrac{24小时表示的时间}{24}
\]</span></p>
<ul>
<li>对于特定的基函数， 最小二乘问题可以大大简化
<ul>
<li><strong>上述选择方式使得法线方程已经是对角线形式</strong></li>
</ul></li>
<li>可以增加阶数，添加项 <span class="math inline">\(c_3\cos(4\pi
t)\)</span></li>
</ul>
<h3 id="数据线性化">2.2 数据线性化</h3>
<h4 id="指数模型">指数模型</h4>
<p><span class="math display">\[
y=c_1e^{c_2t}
\]</span></p>
<ul>
<li>非线性模型：系数不是线性的
<ul>
<li>方法1：非线性最小二乘问题</li>
<li>方法2：“线性化”</li>
</ul></li>
<li>线性化</li>
</ul>
<p><span class="math display">\[
\ln{y}=\ln{c_1}+c_2t=k+c_2t
\]</span></p>
<ul>
<li>求出 <span class="math inline">\(k,c_2\)</span> 之后在求得 <span class="math inline">\(c_1,c_2\)</span></li>
</ul>
<h5 id="评价标准改变">评价标准改变</h5>
<ul>
<li><strong>实际上改变了评价标准</strong></li>
<li>原来的评价标准：最小化如下式子</li>
</ul>
<p><span class="math display">\[
\sum_{i=1}^{n}(c_1e^{c_2t_i}-y_i)^2
\]</span></p>
<ul>
<li>线性化之后的评价标准：最小化如下式子</li>
</ul>
<p><span class="math display">\[
\sum_{i=1}^{n}(\ln{c_1}+c_2t_i-\ln{y_i})^2
\]</span></p>
<ul>
<li>具体使用哪一种形式，需要用户确定更需要最小化哪种误差，是原始意义的误差</li>
</ul>
<h4 id="幂法则模型">幂法则模型</h4>
<p><span class="math display">\[
y=c_1t^{c_2}
\]</span></p>
<ul>
<li>线性化</li>
</ul>
<p><span class="math display">\[
\ln{y}=\ln{c_1}+c_2\ln{t}=k+c_2\ln{t_2}
\]</span></p>
<ul>
<li>实际例子
<ul>
<li><strong>半衰期</strong>：<span class="math inline">\(y=c_1te^{c_2t}\Rightarrow
\ln{y}-\ln{t}=\ln{c_1}+c_2t\)</span></li>
</ul></li>
</ul>
<h2 id="qr-分解">3. QR 分解</h2>
<h3 id="格拉姆-施密特正交与最小二乘">3.1
格拉姆-施密特正交与最小二乘</h3>
<ul>
<li><strong>格拉姆-施密特方法</strong>是对<strong>一组向量正交化</strong>
<ul>
<li>给定一组输人的 <span class="math inline">\(m\)</span>
维向量，目的是找出正交坐标系统，获取由这些向量张成的空间，</li>
<li>更精确地讲，给定 <span class="math inline">\(n\)</span>
个线性无关的输人向量，该方法计算 <span class="math inline">\(n\)</span>
个彼此垂直的单位向量，张成和输入向量相同的子空间，单位长度由欧几里得（即
2 范数）进行定义</li>
</ul></li>
<li>输入为 <span class="math inline">\(\mathbb{R}^m\)</span> 中的 <span class="math inline">\(n\)</span> 个线性无关向量 <span class="math inline">\(A_1,\cdots,A_n\)</span>（<span class="math inline">\(n\le m\)</span>）</li>
</ul>
<h4 id="思路">思路</h4>
<ul>
<li>定义问题为 <span class="math inline">\(P(n)\)</span></li>
<li>去除其中的一个向量 <span class="math inline">\(A_1\)</span>，作为最后生成的正交向量组中的一个向量</li>
<li>剩余向量做如下操作：<span class="math inline">\(A_i=A_i-(A_i\cdot
\dfrac{A_1}{\Vert{A_1}\Vert})\dfrac{A_1}{\Vert{A_1}\Vert}\)</span>
<ul>
<li>减去 <span class="math inline">\(A_1\)</span> 方向上的分量</li>
</ul></li>
<li>此时剩余的向量与 <span class="math inline">\(A_1\)</span>
都垂直，问题转化为剩余向量的 <span class="math inline">\(P(n-1)\)</span>
问题</li>
</ul>
<h4 id="算法流程">算法流程</h4>
<ul>
<li>初始化</li>
</ul>
<p><span class="math display">\[
y_1=A_1,q_1=\dfrac{y_1}{\Vert{y_1}\Vert_2}
\]</span></p>
<ul>
<li>第 <span class="math inline">\(2\)</span> 个向量</li>
</ul>
<p><span class="math display">\[
y_2=A_2-q_1(q_1^{T}A_2),q_2=\dfrac{y_2}{\Vert{y_2}\Vert_2}
\]</span></p>
<ul>
<li><span class="math inline">\(\cdots\)</span></li>
<li>第 <span class="math inline">\(i\)</span> 个向量
<ul>
<li>第二数学归纳法可以证明 <span class="math inline">\(q_i\)</span>
和之前的向量 <span class="math inline">\(q_j/y_j\)</span> 正交</li>
</ul></li>
</ul>
<p><span class="math display">\[
y_i=A_i-q_1(q_1^{T}A_i)-\cdots-q_{i-1}(q_{i-1}^{T}A_{i}),q_i=\dfrac{y_i}{\Vert{y_i}\Vert_2}
\]</span></p>
<ul>
<li><span class="math inline">\(\cdots\)</span></li>
<li>第 <span class="math inline">\(n\)</span> 个向量</li>
</ul>
<h4 id="矩阵形式">矩阵形式</h4>
<ul>
<li>矩阵 <span class="math inline">\(R\)</span></li>
<li><span class="math inline">\(r_{ii}=\Vert{y_i}\Vert_2\)</span></li>
<li><span class="math inline">\(r_{i,j}=q_i^{T}A_j,(i\le
j)\)</span></li>
<li><span class="math inline">\(r_{i,j}=0,(i&gt;j)\)</span></li>
<li>我们能够得到如下式子
<ul>
<li><span class="math inline">\(A_j\)</span>
在各个正交向量上的投影之和</li>
</ul></li>
</ul>
<p><span class="math display">\[
A_j=r_{1,j}q_1+\cdots+r_{j-1,j}q_{j-1}+r_{j,j}q_j
\]</span></p>
<ul>
<li>矩阵形式如下</li>
</ul>
<p><span class="math display">\[
\begin{pmatrix}A_1\cdots A_n\end{pmatrix}
=\begin{pmatrix}q_1\cdots q_n\end{pmatrix}R
=\begin{pmatrix}q_1\cdots q_n\end{pmatrix}
\begin{bmatrix}
r_{11}&amp;r_{12}&amp;\cdots&amp;r_{1n}\\
&amp;r_{22}&amp;\cdots&amp;r_{2n}\\
&amp;&amp;\ddots&amp;\vdots\\
&amp;&amp;&amp;r_{nn}
\end{bmatrix}
\]</span></p>
<ul>
<li>简记为 <span class="math inline">\(A=QR\)</span>，称为<strong>消减
QR 分解</strong></li>
<li>如果 <span class="math inline">\(A_j\)</span>
线性无关，则主对角元全都非零</li>
<li>如果 <span class="math inline">\(A_j\)</span> 在 <span class="math inline">\(A_1,\cdots,A_{j-1}\)</span> 章程的线性空间中，那么
<span class="math inline">\(r_{jj}=0\)</span></li>
<li>如上的方法，我们称为是<strong>经典的格拉姆-施密特正交算法</strong></li>
<li>总结</li>
</ul>
<p><img src="/2021/10/28/computation/pyr/05/image-20211028205445591.jpg" style="zoom:80%;"></p>
<h4 id="qr-分解的应用">QR 分解的应用</h4>
<ul>
<li>求解 <span class="math inline">\(n\)</span> 个方程 <span class="math inline">\(n\)</span> 个未知数的系统 <span class="math inline">\(Ax=b\)</span></li>
<li>最小二乘</li>
<li>特征值计算</li>
</ul>
<h5 id="求解方程">求解方程</h5>
<ul>
<li>假设 <span class="math inline">\(A\)</span> 是非奇异矩阵
<ul>
<li><span class="math inline">\(Ax=b\Rightarrow QRx=b\Rightarrow
Rx=Q^{T}b\)</span>
<ul>
<li><span class="math inline">\(Q\)</span> 是正交矩阵，<span class="math inline">\(Q^{T}=Q^{-1}\)</span></li>
<li><span class="math inline">\(R\)</span> 是上三角矩阵</li>
</ul></li>
<li>复杂度约为 <span class="math inline">\(LU\)</span> 的 3 倍
<ul>
<li>大概：<span class="math inline">\(n^3\)</span> 乘法 + <span class="math inline">\(n^3\)</span> 加法
<ul>
<li><strong><span style="color:red">感觉次数不太对，好像没把归一化的次数算上</span></strong></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h5 id="最小二乘-1">最小二乘</h5>
<ul>
<li><strong><span style="color:red">正交变换不改变向量的 2
范数</span></strong></li>
</ul>
<p><span class="math display">\[
\Vert{Ax}\Vert_2=(Ax)^{T}(Ax)=x^{T}A^{T}Ax=x^{T}(A^{T}A)x=x^{T}x=\Vert{x}\Vert_2
\]</span></p>
<ul>
<li>那么我们可以推导得到，如果 <span class="math inline">\(A\)</span>
是正交矩阵，<span class="math inline">\(\Vert{AB}\Vert_2=\Vert{B}\Vert_2\)</span></li>
</ul>
<p><span class="math display">\[
\Vert{AB}\Vert_2=\max_{\Vert{x}\Vert_2\ne0}\dfrac{\Vert{ABx}\Vert_2}{\Vert{x}\Vert_2}=\max_{\Vert{x}\Vert_2\ne0}\dfrac{\Vert{Bx}\Vert_2}{\Vert{x}\Vert_2}=\Vert{B}\Vert_2
\]</span></p>
<ul>
<li><span class="math inline">\(A\)</span> 为 <span class="math inline">\(m\times n\)</span> 矩阵（<span class="math inline">\(m\ge n\)</span>）</li>
</ul>
<p><span class="math display">\[
\Vert{Ax-b}\Vert_2=\Vert{QRx-b}\Vert_2=\Vert{Rx-Q^{T}b}\Vert_2=\Vert{Rx-d}\Vert_2=\Vert{e}\Vert_2
\]</span></p>
<ul>
<li>假定 <span class="math inline">\(r_{ii}\ne0\)</span>，<span class="math inline">\(A\)</span> 满秩，那么有如下矩阵形式</li>
</ul>
<p><img src="/2021/10/28/computation/pyr/05/image-20211028203026101.jpg" style="zoom:80%;"></p>
<ul>
<li>于是最小二乘误差：</li>
</ul>
<p><span class="math display">\[
\Vert{e}\Vert_2=\sqrt{\sum_{i=n+1}^{m}d_{n+1}^{2}}
\]</span></p>
<ul>
<li>方程的最小二乘解：通过方程组回代即可计算得到 <span class="math inline">\(x\)</span></li>
</ul>
<h3 id="改进的格拉姆-施密特正交">3.2 改进的格拉姆-施密特正交</h3>
<ul>
<li>微小改进可以在<strong>机器计算中改进精度</strong>，与原始方法在数学上等价</li>
</ul>
<p><img src="/2021/10/28/computation/pyr/05/image-20211028205243563.jpg" style="zoom:80%;"></p>
<ul>
<li>因为在第 <span class="math inline">\(i\)</span> 步的时候，<span class="math inline">\(A_j\)</span> 中已经不含有 <span class="math inline">\(q_1,\cdots,q_{i-1}\)</span>
的成分了（都已经减去了），因此只需要做余项的投影</li>
<li>更加稳定
<ul>
<li>直观上讲，减少了 <span class="math inline">\(q_1,\cdots,q_{i-1}\)</span>
成分计算带来的误差</li>
</ul></li>
</ul>
<h3 id="豪斯霍尔德反射子">3.3 豪斯霍尔德反射子</h3>
<ul>
<li>相较改进的格拉姆-施密特正交化方法
<ul>
<li>更少的计算</li>
<li>舍入误差的角度而言，更加稳定</li>
</ul></li>
<li>豪斯霍尔德反射子是<strong>正交矩阵</strong>，通过 <span class="math inline">\(m-1\)</span> 维平面反射 <span class="math inline">\(m\)</span> 维向量
<ul>
<li>每个向量乘上矩阵之后，<strong>长度不变</strong></li>
</ul></li>
<li>给定一个向量 <span class="math inline">\(x\)</span>，我们要重新找出一个相同长度的向量 <span class="math inline">\(w\)</span>，计算豪斯霍尔德反射得出矩阵 <span class="math inline">\(H\)</span> 满足 <span class="math inline">\(Hx=w\)</span></li>
<li>原始方法
<ul>
<li>画出 <span class="math inline">\(m-1\)</span> 维平面二分 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(w\)</span>，并连接他们的向量垂直，并且通过该平面反射所有向量</li>
</ul></li>
</ul>
<p><img src="/2021/10/28/computation/pyr/05/image-20211029094432803.jpg" style="zoom:80%;"></p>
<h4 id="投影矩阵">投影矩阵</h4>
<ul>
<li><span class="math inline">\(\Vert{x}\Vert_2=\Vert{w}\Vert_2\Rightarrow(w-x)^{T}(w+x)=0\)</span>
<ul>
<li><strong>正交</strong></li>
</ul></li>
<li>定义 <span class="math inline">\(v=w-x\)</span>，<strong>投影矩阵</strong> <span class="math inline">\(P=\dfrac{vv^{T}}{v^{T}v}\)</span></li>
<li><strong>投影矩阵</strong>满足 <span class="math inline">\(P^{2}=P\)</span></li>
</ul>
<p><span class="math display">\[
P^{2}=\dfrac{vv^{T}vv^{T}}{(v^{T}v)^2}=\dfrac{v(v^{T}v)v^{T}}{(v^{T}v)^2}=\dfrac{(v^{T}v)vv^{T}}{(v^{T}v)^2}=\dfrac{vv^{T}}{v^{T}v}=P
\]</span></p>
<ul>
<li>上述 <span class="math inline">\(P\)</span>
<ul>
<li><strong>对称投影矩阵</strong>
<ul>
<li>证明 <span class="math inline">\(P^{T}=P\)</span> 即可</li>
</ul></li>
<li><span class="math inline">\(Pv=v\)</span></li>
<li>对于任意向量 <span class="math inline">\(u\)</span>，<span class="math inline">\(Pu\)</span> 是 <span class="math inline">\(u\)</span> 在 <span class="math inline">\(v\)</span> 上的投影
<ul>
<li>投影定义即证</li>
</ul></li>
</ul></li>
</ul>
<h4 id="豪斯霍尔德反射子-1">豪斯霍尔德反射子</h4>
<ul>
<li>如上图，<span class="math inline">\(x-2Px=w\)</span></li>
<li>定义 <span class="math inline">\(H=I-2P\)</span>
<ul>
<li><span class="math inline">\(Pv=v\)</span></li>
<li><span class="math inline">\(v^{T}(x+v)=(x-v)^{T}(x+v)=0\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
Hx&amp;=Ix-2Px=x-2Px\\
&amp;=w-v-\dfrac{2vv^{T}x}{v^{T}v}\\
&amp;=w-Pv-\dfrac{2vv^{T}x}{v^{T}v}\\
&amp;=w-\dfrac{vv^{T}v+vv^{T}x+vv^{T}(w-v)}{v^{T}v}\\
&amp;=w-\dfrac{vv^{T}(x+v)}{v^{T}v}\\
&amp;=w-\dfrac{vv^{T}(x+v)}{v^{T}v}\\
&amp;=w\\
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\(H\)</span>
即为<strong>豪斯霍尔德反射子</strong></li>
<li><span class="math inline">\(H\)</span> 是对称的
<ul>
<li><span class="math inline">\(I,P\)</span> 都是对称的</li>
</ul></li>
<li><span class="math inline">\(H\)</span> 是正交的</li>
</ul>
<p><span class="math display">\[
H^{T}H=HH=(I-2P)(I-2P)=I-4P+4P^2=I
\]</span></p>
<h4 id="qr-分解-1">QR 分解</h4>
<p><img src="/2021/10/28/computation/pyr/05/image-20211029102418740.jpg" style="zoom:80%;"></p>
<ul>
<li>计算代价，<span class="math inline">\(n\times n\)</span> 矩阵
<ul>
<li>乘法：<span class="math inline">\(\dfrac{2}{3}n^{3}\)</span></li>
<li>加法：<span class="math inline">\(\dfrac{2}{3}n^{3}\)</span></li>
<li><strong><span style="color:red">怎么算出来的，这么低？没搞懂</span></strong></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.06.线性方程组(2)</title>
    <url>/2021/11/02/computation/pyr/06-1/</url>
    <content><![CDATA[<ul>
<li>PPT（线性方程组）</li>
</ul>
<h1 id="线性方程组">线性方程组</h1>
<h2 id="迭代求解">4. 迭代求解</h2>
<h3 id="矩阵收敛">(1) 矩阵收敛</h3>
<ul>
<li><span class="math inline">\(n\times n\)</span> 矩阵收敛：<span class="math inline">\(\lim_{k\to\infty}(A^{k})_{ij}=0\)</span></li>
</ul>
<h4 id="等价命题">等价命题</h4>
<ul>
<li>如下命题等价
<ul>
<li><span class="math inline">\(A\)</span> 是收敛矩阵</li>
<li>对任意自然范数，<span class="math inline">\(\lim_{n\to\infty}\Vert{A^{n}}\Vert=0\)</span></li>
<li><span class="math inline">\(\rho(A)&lt;1\)</span></li>
<li><span class="math inline">\(\lim_{n\to\infty}A^{n}x=0\)</span></li>
</ul></li>
</ul>
<h4 id="例子">例子</h4>
<ul>
<li>收敛矩阵</li>
</ul>
<p><span class="math display">\[
A=\begin{pmatrix}
\dfrac{1}{2}&amp;0\\
\dfrac{1}{4}&amp;\dfrac{1}{2}\\
\end{pmatrix},
A^{k}=\begin{pmatrix}
\dfrac{1}{2^{k}}&amp;0\\
\dfrac{k}{2^{k+1}}&amp;\dfrac{1}{2^{k}}\\
\end{pmatrix}
\]</span></p>
<h3 id="线性方程组不动点迭代">(2) 线性方程组不动点迭代</h3>
<ul>
<li><span class="math inline">\(Ax=b\)</span> 构造不动点迭代函数 <span class="math inline">\(x=Tx+c\)</span></li>
</ul>
<h4 id="雅各比迭代方法">雅各比迭代方法</h4>
<ul>
<li>之前的笔记：<a href="/2021/10/10/computation/pyr/03-1/#雅可比方法">Jacobi</a></li>
</ul>
<p><span class="math display">\[
x_{k+1}=-D^{-1}(L+U)x_{k}+D^{-1}b
\]</span></p>
<h4 id="高斯塞德尔方法">高斯塞德尔方法</h4>
<ul>
<li>之前的笔记：<a href="/2021/10/10/computation/pyr/03-1/#guass-seidel-方法">Guass-Seidel</a></li>
</ul>
<p><span class="math display">\[
x_{k+1}=-D^{-1}Lx_{k+1}-D^{-1}Ux_{k}+D^{-1}b
\]</span></p>
<p><span class="math display">\[
x_{k+1}=-(D+L)^{-1}Ux_{k}+(D+L)^{-1}b
\]</span></p>
<h3 id="迭代方法的收敛性">(3) 迭代方法的收敛性</h3>
<h4 id="谱半径定理">谱半径定理</h4>
<p><img src="/2021/11/02/computation/pyr/06-1/image-20211102181328666.png" style="zoom:80%;"></p>
<ul>
<li>证明</li>
</ul>
<p><img src="/2021/11/02/computation/pyr/06-1/image-20211102181618617.png" style="zoom:80%;"></p>
<h4 id="收敛定理">收敛定理</h4>
<p><img src="/2021/11/02/computation/pyr/06-1/image-20211102182213175.png" style="zoom:80%;"></p>
<ul>
<li>充分性</li>
</ul>
<p><img src="/2021/11/02/computation/pyr/06-1/image-20211102182323008.png" style="zoom:80%;"></p>
<ul>
<li>必要性：通过证明 <span class="math inline">\(A\)</span>
是收敛矩阵得到 <span class="math inline">\(\rho(A)&lt;1\)</span></li>
</ul>
<p><img src="/2021/11/02/computation/pyr/06-1/image-20211102182354622.png" style="zoom:80%;"></p>
<h4 id="误差界">误差界</h4>
<p><img src="/2021/11/02/computation/pyr/06-1/image-20211102224538239.png" style="zoom:80%;"></p>
<ul>
<li>证明方法和单变量迭代类似</li>
</ul>
<p><img src="/2021/11/02/computation/pyr/06-1/image-20211102224855257.png" style="zoom:80%;"></p>
<h3 id="收敛性证明">(4) 收敛性证明</h3>
<h4 id="雅各比方法高斯塞德尔方法">雅各比方法、高斯塞德尔方法</h4>
<p><img src="/2021/11/02/computation/pyr/06-1/image-20211102225034498.png" style="zoom:80%;"></p>
<ul>
<li>证明：<a href="/2021/10/10/computation/pyr/03-1/#迭代方法的收敛">note</a>
<ul>
<li>使用严格对角占优的条件证明谱半径小于 1</li>
</ul></li>
</ul>
<h3 id="迭代方法比较">(5) 迭代方法比较</h3>
<h4 id="stein-rosenberg-定理">Stein Rosenberg 定理</h4>
<ul>
<li>如果 <span class="math inline">\(a_{ij}\le0,i\ne
j,a_{ii}&gt;0,i=1,\cdots,n\)</span>，则如下命题仅有一项成立
<ul>
<li><span class="math inline">\(0\le\rho(T_g)\le\rho(T_j)&lt;1\)</span></li>
<li><span class="math inline">\(1\le\rho(T_j)\le\rho(T_g)\)</span></li>
<li><span class="math inline">\(0=\rho(T_g)=\rho(T_j)\)</span>
<ul>
<li>收敛</li>
</ul></li>
<li><span class="math inline">\(1=\rho(T_g)=\rho(T_j)\)</span>
<ul>
<li>不收敛：误差很难降低</li>
</ul></li>
</ul></li>
<li><strong>谱半径越小收敛越快</strong>
<ul>
<li>一个方法收敛，两种方法都收敛，Gauss-Seidel 方法收敛更快</li>
<li>一个方法发散，二者皆发散.，高斯赛德尔方法发散更快</li>
</ul></li>
</ul>
<h3 id="松弛方法">(6) 松弛方法</h3>
<ul>
<li><a href="/2021/10/10/computation/pyr/03-1/#SOR">SOR</a></li>
<li>下面的定义和书上是一致的，<span class="math inline">\(r_i\)</span>
里面包含了 <span class="math inline">\(i=j\)</span> 的一项</li>
</ul>
<p><img src="/2021/11/02/computation/pyr/06-1/image-20211102231549351.png" alt="image-20211102231549351" style="zoom:80%;"></p>
<ul>
<li><strong>对于特定的正数 <span class="math inline">\(w\)</span> ,
可以减少残差向量的范数，获得更快的收敛速度</strong>
<ul>
<li><span class="math inline">\(0&lt;w&lt;1\)</span>：欠松弛
<ul>
<li>使得 GS 下某些不收敛线性方程组收敛</li>
</ul></li>
<li><span class="math inline">\(w=1\)</span>：Gauss-Seidel</li>
<li><span class="math inline">\(w&gt;1\)</span>：过松弛（SOR）
<ul>
<li>使得 GS 下某些收敛线性方程组收敛更快</li>
</ul></li>
</ul></li>
</ul>
<h4 id="kahan-定理">Kahan 定理</h4>
<ul>
<li>对于 SOR 方法，如果 <span class="math inline">\(a_{ii}\ne0,i=1,\cdots,n\)</span>，则 <span class="math inline">\(\rho(T_w)\ge\vert{w-1}\vert\)</span></li>
</ul>
<h5 id="证明">证明</h5>
<ul>
<li>化成 <span class="math inline">\(x=Tx+c\)</span> 的形式</li>
</ul>
<p><span class="math display">\[
x_{k+1}=(\omega L+D)^{-1}\big((1-\omega)D-\omega
U\big)x_{k}+\omega(\omega L+D)^{-1}b
\]</span></p>
<ul>
<li>记 <span class="math inline">\(H=(\omega
L+D)^{-1}\big((1-\omega)D-\omega U\big)\)</span></li>
</ul>
<p><img src="/2021/11/02/computation/pyr/06-1/image-20211102233453123.png" style="zoom:80%;"></p>
<h5 id="推论">推论</h5>
<ul>
<li>SOR 方法收敛的<strong>必要条件</strong>是 <span class="math inline">\(\vert{w-1}\vert&lt;1\)</span>，即 <span class="math inline">\(0&lt;w&lt;2\)</span></li>
</ul>
<h4 id="ostrowski-reich-定理">Ostrowski-Reich 定理</h4>
<ul>
<li>如果 <span class="math inline">\(A\)</span>
是<strong>正定矩阵</strong>且 <span class="math inline">\(0&lt;w&lt;2\)</span>，则 SOR
方法对于任意初始近似向量 <span class="math inline">\(x_0\)</span> 收敛
<ul>
<li><strong>正定：定义中包括共轭对称</strong></li>
</ul></li>
</ul>
<h5 id="证明-1">证明</h5>
<ul>
<li>思路：证明 <span class="math inline">\(\vert\lambda\vert&lt;1\Leftrightarrow{\lambda}^2&lt;1\)</span></li>
</ul>
<p><img src="/2021/11/02/computation/pyr/06-1/image-20211103203646622.png" style="zoom:80%;"></p>
<p><img src="/2021/11/02/computation/pyr/06-1/image-20211103204627130.png" style="zoom:80%;"></p>
<h4 id="最优-w">最优 w</h4>
<ul>
<li>如果 <span class="math inline">\(A\)</span>
是<strong>正定三对角线矩阵</strong>，则 <span class="math inline">\(\rho(T_g)=\rho^{2}(T_j)&lt;1\)</span>，SOR方法
<span class="math inline">\(\rho(T)=w-1\)</span>，最优的 <span class="math inline">\(w\)</span> 值为</li>
</ul>
<p><span class="math display">\[
w=\dfrac{2}{1-\sqrt{1-\rho^{2}(T_j)}}
\]</span></p>
<ul>
<li>三对角线矩阵：只有<strong>对角线</strong>和<strong>与其相邻的两条对角线</strong>有非零元素</li>
</ul>
<h3 id="误差分析">(7) 误差分析</h3>
<ul>
<li><a href="/2021/10/02/computation/pyr/03/#误差放大和条件数">note</a></li>
<li>误差界
<ul>
<li><a href="/2021/10/02/computation/pyr/03/#条件数证明">证明</a></li>
</ul></li>
</ul>
<p><span class="math display">\[
\dfrac{\Vert{x-x_a}\Vert}{\Vert{x}\Vert}\le\Vert{A^{-1}}\Vert\Vert{A}\Vert\cdot\dfrac{\Vert{r}\Vert}{\Vert{b}\Vert}
\]</span></p>
<ul>
<li>条件数</li>
</ul>
<p><span class="math display">\[
K(A)=\mathrm{cond}(A)=\Vert{A^{-1}}\Vert\Vert{A}\Vert
\]</span></p>
<ul>
<li>病态与良态
<ul>
<li>当 <span class="math inline">\(K(A)\)</span> 接近 <span class="math inline">\(1\)</span> 时，矩阵 <span class="math inline">\(A\)</span> 是良态矩阵</li>
<li>当 <span class="math inline">\(K(A)\)</span> 显著大于 <span class="math inline">\(1\)</span> 时，矩阵是病态的</li>
</ul></li>
<li>病态矩阵示例
<ul>
<li>希尔伯特矩阵：<span class="math inline">\((H_{n})_{ij}=\dfrac{1}{i+j-1}\)</span></li>
</ul></li>
</ul>
<h4 id="条件数近似">条件数近似</h4>
<h5 id="近似方法-1">近似方法 1</h5>
<ul>
<li><span class="math inline">\(t\)</span> 位算术，残差向量 <span class="math inline">\(r\)</span> 的近似值为 <span class="math inline">\(\Vert{r}\Vert\approx10^{-t}\Vert{A}\Vert\Vert{x}\Vert\)</span></li>
<li>那么条件数的近似值 <span class="math inline">\(K(A)=\dfrac{\Vert{\tilde{y}}\Vert}{\Vert{\tilde{x}}\Vert}10^{t}\)</span>，其中
<span class="math inline">\(\Vert{\tilde{y}}\Vert=A^{-1}r\)</span></li>
</ul>
<p><img src="/2021/11/02/computation/pyr/06-1/image-20211104093206306.png" style="zoom:80%;"></p>
<h5 id="迭代算法的优化">迭代算法的优化</h5>
<ul>
<li>一般来说， <span class="math inline">\(\tilde{x}+\tilde{y}\)</span>
比 <span class="math inline">\(\tilde{x}\)</span> 更精确</li>
<li>步骤</li>
</ul>
<p><img src="/2021/11/02/computation/pyr/06-1/image-20211104094321121.png" style="zoom:80%;"></p>
<h4 id="范数">2 范数</h4>
<p><span class="math display">\[
K(A)_2=\sqrt{\dfrac{\lambda_{max}(A^{T}T)}{\lambda_{min}(A^{T}T)}}
\]</span></p>
<ul>
<li><span class="math inline">\(Ax_1=\lambda_1 x_1\)</span> 那么则有
<span class="math inline">\(A^{-1}x=\dfrac{1}{\lambda_1}x_1\)</span></li>
</ul>
<h4 id="不等式">不等式</h4>
<p><img src="/2021/11/02/computation/pyr/06-1/image-20211104101733732.png" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.06.线性方程组(3)</title>
    <url>/2021/11/04/computation/pyr/06-2/</url>
    <content><![CDATA[<ul>
<li>PPT（线性方程组）</li>
</ul>
<h1 id="线性方程组">线性方程组</h1>
<h2 id="共轭梯度方法">5. 共轭梯度方法</h2>
<ul>
<li>共轭梯度方法
<ul>
<li>求解 <span class="math inline">\(n\times n\)</span>
<strong>正定线性方程组</strong>迭代方法</li>
<li><span class="math inline">\(n\)</span>
步求解线性方程组（直接方法）</li>
<li><span class="math inline">\(x=x+tv\)</span>
<ul>
<li><strong>共轭梯度方向</strong></li>
</ul></li>
<li>对矩阵进行预处理，只需大约 <span class="math inline">\(n\)</span>
步收敛</li>
</ul></li>
<li>示意图
<ul>
<li>绿色：梯度下降</li>
<li>红色：共轭梯度下降</li>
</ul></li>
</ul>
<p><img src="/2021/11/04/computation/pyr/06-2/220px-Conjugate_gradient.illustration.svg.png" alt="img" style="zoom:80%;"></p>
<h3 id="预备知识">(1) 预备知识</h3>
<h4 id="定理-1">定理 1</h4>
<ul>
<li>向量 <span class="math inline">\(x^{\ast}\)</span>
是<strong>正定线性方程组</strong> <span class="math inline">\(Ax=b\)</span> 的解当且仅当 <span class="math inline">\(x^{\ast}\)</span> 最小化函数
$g(x)=x,Ax,-2x,b$</li>
<li>证明思路：<span class="math inline">\(g(x+tv)\)</span> ，偏导为 0
时的 <span class="math inline">\(x\)</span> 条件</li>
</ul>
<p><img src="/2021/11/04/computation/pyr/06-2/image-20211104103400622.png" style="zoom:80%;"></p>
<h4 id="算法">算法</h4>
<ul>
<li>迭代算法如下</li>
<li>找到某个方向 <span class="math inline">\(v^{(k)}\)</span>
，然后最小化这个函数（求出 <span class="math inline">\(t_k\)</span>
）</li>
</ul>
<p><img src="/2021/11/04/computation/pyr/06-2/image-20211104104059128.png" style="zoom:80%;"></p>
<ul>
<li>如何确定 <span class="math inline">\(v^{(k)}\)</span></li>
</ul>
<h3 id="最速下降">(2) 最速下降</h3>
<ul>
<li>每次的方向规定为<strong>负梯度方向</strong>
<ul>
<li>最速下降方法对非线性方程组和优化问题有很好的应用</li>
<li>但由于收敛速度慢，不适用于线性方程组</li>
</ul></li>
<li>算法步骤</li>
</ul>
<p><img src="/2021/11/04/computation/pyr/06-2/image-20211104104444104.png" style="zoom:80%;"></p>
<h3 id="共轭梯度下降">(3) 共轭梯度下降</h3>
<ul>
<li><a href="/2021/10/14/computation/pyr/03-2/#共轭梯度方法">note</a></li>
<li>正定矩阵 <span class="math inline">\(A\)</span>
<ul>
<li><strong><span class="math inline">\(A-\)</span>正交条件</strong></li>
</ul></li>
</ul>
<p><span class="math display">\[
\langle v^{(i)},Av^{(j)}\rangle=0,i\ne j
\]</span></p>
<h4 id="定理-1-1">定理 1</h4>
<ul>
<li>共轭梯度方法定理</li>
</ul>
<p><img src="/2021/11/04/computation/pyr/06-2/image-20211111114315086.png" style="zoom:80%;"></p>
<h5 id="证明">证明</h5>
<ul>
<li>直接展开证明即可</li>
</ul>
<p><img src="/2021/11/04/computation/pyr/06-2/image-20211111114728754.png" style="zoom:80%;"></p>
<ul>
<li>第 3 行到第 4 行：代入第 2 行的结果，利用 <strong><span class="math inline">\(A-\)</span>正交性</strong></li>
<li>第 12 行：紫色部分全为 0</li>
</ul>
<h4 id="定理-2">定理 2</h4>
<ul>
<li>共轭方向法的剩余向量 <span class="math inline">\(r^{(k)}\)</span>
满足 <span class="math inline">\(\langle
r^{(k)},v^{(j)}\rangle=0\)</span>，<span class="math inline">\(j=1,\cdots,k\)</span></li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
r^{(k)}=b-Ax^{(k)}\\
r^{(k+1)}=r^{(k)}-t_{k+1}Av^{(k+1)}\\
\end{array}
\]</span></p>
<h5 id="证明-1">证明</h5>
<p><img src="/2021/11/04/computation/pyr/06-2/image-20211111120726356.png" style="zoom:80%;"></p>
<ul>
<li>初始方向是余项方向：<span class="math inline">\(v^{(1)}=r^{(0)}\)</span></li>
</ul>
<h4 id="定理-3">定理 3</h4>
<ul>
<li>共轭方法中的余项 <span class="math inline">\(r^{(k)}\)</span> 满足
<span class="math inline">\(\langle
r^{(k)},r^{(j)}\rangle=0\)</span>，<span class="math inline">\(j=1,\cdots,k-1\)</span></li>
</ul>
<h5 id="证明-2">证明</h5>
<ul>
<li>如何确定搜索方向 <span class="math inline">\(v^{(k)}\)</span>，由如下式子决定（<span class="math inline">\(s_{k-1}\)</span> 用于调整至 <span class="math inline">\(A-\)</span>正交条件）</li>
</ul>
<p><span class="math display">\[
v^{(k)}=r^{(k-1)}+s_{k-1}v^{(k-1)}
\]</span></p>
<ul>
<li>证明</li>
</ul>
<p><img src="/2021/11/04/computation/pyr/06-2/image-20211111121505054.png" style="zoom:80%;"></p>
<p><img src="/2021/11/04/computation/pyr/06-2/image-20211111121526538.png" style="zoom:80%;"></p>
<h4 id="共轭梯度算法如下">共轭梯度算法如下</h4>
<p><img src="/2021/11/04/computation/pyr/06-2/image-20211111122423493.png" style="zoom:80%;"></p>
<p><img src="/2021/11/04/computation/pyr/06-2/image-20211111122442531.png" style="zoom:80%;"></p>
<p><img src="/2021/11/04/computation/pyr/06-2/image-20211111122458046.png" style="zoom:80%;"></p>
<h5 id="正交集证明">正交集证明</h5>
<ul>
<li>为什么 <span class="math inline">\(v^{(k)}\)</span> 和 <span class="math inline">\(v^{(k-1)}\)</span> 正交就可以推导得到正交集</li>
<li><span class="math inline">\(j&lt;k-1\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\langle Av^{(k)},v^{(j)}\rangle&amp;=\langle
Ar^{(k-1)},v^{(j)}\rangle+s_{k-1}\langle Av^{(k-1)},v^{(j)}\rangle\\
&amp;=\langle Ar^{(k-1)},v^{(j)}\rangle\\
\end{aligned}
\]</span></p>
<ul>
<li>而根据如下式子，根据 <span class="math inline">\(A\)</span>
正定，证毕</li>
</ul>
<p><span class="math display">\[
\langle r^{(k-1)},Av^{(j)}\rangle=\langle
r^{(k-1)},\dfrac{r^{(j-1)}-r^{(j)}}{t^{(j)}}\rangle=0
\]</span></p>
<ul>
<li><span class="math inline">\(r^{(k-1)}\)</span> 和 <span class="math inline">\(r^{(j-1)},r^{(j)}\)</span> 正交，用到归纳 <span class="math inline">\(\{v^{(1)},\cdots,v^{(k-1)}\}\)</span>
为正交集</li>
</ul>
<h3 id="预条件共轭梯度法">(4) 预条件共轭梯度法</h3>
<ul>
<li><a href="/2021/10/14/computation/pyr/03-2/#预条件">note</a></li>
<li>降低 <span class="math inline">\(A\)</span> 条件数</li>
<li>选择一个非奇异条件矩阵 <span class="math inline">\(C\)</span>，使
<span class="math inline">\(\tilde{A}=C^{-1}A(C^{-1})^{T}\)</span>
条件更好</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
\tilde{A}=C^{-1}A(C^{-1})^{T}\\
\tilde{A}\tilde{x}=\tilde{b}\\
记号:\tilde{x}=C^{T}x,\tilde{b}=C^{-1}\tilde{b}\\
A\tilde{x}=C^{-1}Ax=C^{-1}b\\
\end{array}
\]</span></p>
<ul>
<li><span class="math inline">\(C^{-1}Ax=C^{-1}b\)</span></li>
<li>具体算法：根据上面的算法求解 <span class="math inline">\(\tilde{A}\tilde{x}=\tilde{b}\)</span>，过程中转化到解
<span class="math inline">\(x\)</span></li>
</ul>
<p><img src="/2021/11/04/computation/pyr/06-2/image-20211111235859520.png" style="zoom:80%;"></p>
<p><img src="/2021/11/04/computation/pyr/06-2/image-20211112000033176.png" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.06.线性方程组</title>
    <url>/2021/11/01/computation/pyr/06/</url>
    <content><![CDATA[<ul>
<li>PPT（线性方程组）</li>
</ul>
<h1 id="线性方程组">线性方程组</h1>
<ul>
<li>向量范数、矩阵范数、算子范数（诱导范数 / 自然范数）
<ul>
<li><a href="/2021/10/02/computation/pyr/03/#误差放大和条件数">note</a></li>
</ul></li>
</ul>
<h2 id="向量范数">1. 向量范数</h2>
<h3 id="定义">定义</h3>
<ul>
<li>3 个条件
<ul>
<li>正定性、齐次性、三角不等式</li>
</ul></li>
</ul>
<p><img src="/2021/11/01/computation/pyr/06/image-20211102122013795.png" style="zoom:80%;"></p>
<h3 id="欧式范数">欧式范数</h3>
<p><span class="math display">\[
\Vert{x}\Vert_1=\sum_{i=1}^{n}{\vert{x_i}\vert}
\]</span></p>
<p><span class="math display">\[
\Vert{x}\Vert_2=\sqrt{\sum_{i=1}^{n}{\vert{x_i}\vert^2}}
\]</span></p>
<p><span class="math display">\[
\Vert{x}\Vert_2=\left(\sum_{i=1}^{n}{\vert{x_i}\vert^p}\right)^{\dfrac{1}{p}}
\]</span></p>
<p><span class="math display">\[
\Vert{x}\Vert_\infty=\max_{1\le i\le n}{\vert{x_i}\vert}
\]</span></p>
<ul>
<li>示意图
<ul>
<li>这也说明了 <span class="math inline">\(\Vert{x}\Vert_{a}\le\Vert{x}\Vert_{b}(a&gt;b\in\mathbb{N})\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/11/01/computation/pyr/06/image-20211102141259066.png" style="zoom:80%;"></p>
<ul>
<li>2范数图示</li>
</ul>
<p><img src="/2021/11/01/computation/pyr/06/image-20211101171403171.png" style="zoom:80%;"></p>
<ul>
<li>无穷范数图示</li>
</ul>
<p><img src="/2021/11/01/computation/pyr/06/image-20211101171441938.png" style="zoom:80%;"></p>
<h3 id="柯西不等式">柯西不等式</h3>
<ul>
<li><p>Cauchy-Buniakowsky-Schwarz 不等式</p></li>
<li><p><span class="math inline">\(x=(x_1,\cdots,x_n)^{T},y=(y_1,\cdots,y_n)^{T}\)</span>，则有如下式子成立</p></li>
</ul>
<p><span class="math display">\[
x^{T}y=\sum_{i=1}^{n}x_iy_i\le\sum_{i=1}^{n}x_i^2\sum_{i=1}^{n}y_i^2=\Vert{x}\Vert_2\cdot\Vert{y}\Vert_2
\]</span></p>
<ul>
<li>证明
<ul>
<li>构造如下不等式，展开然后令 <span class="math inline">\(\lambda=\dfrac{\Vert{x}\Vert_2}{\Vert{y}\Vert_2}\)</span>
即可</li>
</ul></li>
</ul>
<p><span class="math display">\[
\Vert{x-\lambda y}\Vert_2\ge0
\]</span></p>
<h3 id="关于范数收敛">关于范数收敛</h3>
<p><img src="/2021/11/01/computation/pyr/06/image-20211101181114497.png" style="zoom:80%;"></p>
<h4 id="定理与证明">定理与证明</h4>
<p><img src="/2021/11/01/computation/pyr/06/image-20211101181531998.png" style="zoom:80%;"></p>
<ul>
<li>证明</li>
</ul>
<p><img src="/2021/11/01/computation/pyr/06/image-20211101181553656.png" style="zoom:80%;"></p>
<p><img src="/2021/11/01/computation/pyr/06/image-20211101181620780.png" style="zoom:80%;"></p>
<h3 id="范数之间的关系">范数之间的关系</h3>
<p><span class="math display">\[
\Vert{x}\Vert_\infty\le\Vert{x}\Vert_2\le\sqrt{n}\Vert{x}\Vert_\infty
\]</span></p>
<ul>
<li>图示</li>
</ul>
<p><img src="/2021/11/01/computation/pyr/06/image-20211101182033436.png" style="zoom:80%;"></p>
<h4 id="证明">证明</h4>
<p><span class="math display">\[
j=\mathop{\arg\max}_{1\le i\le n}\vert{x_i}\vert
\]</span></p>
<ul>
<li><span class="math inline">\(\Vert{x}\Vert_\infty\le\Vert{x}\Vert_2\)</span></li>
</ul>
<p><span class="math display">\[
\Vert{x}\Vert_\infty^2=\left(\max_{1\le i\le
n}\vert{x_i}\vert\right)^2=x_j^2\le\sum_{i=1}^{n}x_i^2\le\Vert{x}\Vert_2^2
\]</span></p>
<ul>
<li><span class="math inline">\(\Vert{x}\Vert_2\le\sqrt{n}\Vert{x}\Vert_\infty\)</span></li>
</ul>
<p><span class="math display">\[
\Vert{x}\Vert_2^2=\sum_{i=1}^{n}x_i^2\le\sum_{i=1}^{n}x_j^2=nx_j^2=n\Vert{x}\Vert_\infty^2
\]</span></p>
<h3 id="收敛等价">收敛等价</h3>
<p><img src="/2021/11/01/computation/pyr/06/image-20211101182932685.png" style="zoom:80%;"></p>
<ul>
<li>说明了对于两个范数 <span class="math inline">\(\Vert{x}\Vert_a,\Vert{x}\Vert_b\)</span>，存在
<span class="math inline">\(m,n\)</span> 使得 <span class="math inline">\(m\Vert{x}\Vert_b\le\Vert{x}\Vert_a\le
n\Vert{x}\Vert_b\)</span> 成立</li>
</ul>
<h2 id="矩阵范数">2. 矩阵范数</h2>
<ul>
<li>4 个条件</li>
</ul>
<p><img src="/2021/11/01/computation/pyr/06/image-20211101183648070.png" style="zoom:80%;"></p>
<h3 id="矩阵范数的自然范数定义">矩阵范数的自然范数定义</h3>
<p><span class="math display">\[
\Vert{A}\Vert=\max_{\Vert{x}\Vert=1}\Vert{Ax}\Vert=\max_{\Vert{x}\Vert\ne0}\dfrac{\Vert{Ax}\Vert}{\Vert{x}\Vert}
\]</span></p>
<ul>
<li>推论：对于任意向量 <span class="math inline">\(\Vert{x}\Vert\ne0\)</span>，矩阵 <span class="math inline">\(A\)</span> 及其自然范数 <span class="math inline">\(\Vert{A}\Vert\)</span>，有如下式子成立
<ul>
<li>定义即证</li>
</ul></li>
</ul>
<p><span class="math display">\[
\Vert{A}\Vert\Vert{x}\Vert\ge\Vert{Ax}\Vert
\]</span></p>
<ul>
<li>推论：<span class="math inline">\(\Vert{AB}\Vert\le\Vert{A}\Vert\Vert{B}\Vert\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\Vert{AB}\Vert&amp;=\max_{\Vert{x}\Vert=1}\Vert{ABx}\Vert\\
&amp;=\max_{\Vert{x}\Vert=1}\Vert{A(Bx)}\Vert\\
&amp;\le\max_{\Vert{x}\Vert=1}\Vert{A}\Vert\Vert{Bx}\Vert\\
&amp;=\Vert{A}\Vert\max_{\Vert{x}\Vert=1}\Vert{Bx}\Vert\\
&amp;=\Vert{A}\Vert\Vert{B}\Vert\\
\end{aligned}
\]</span></p>
<ul>
<li>矩阵范数表示在矩阵 <span class="math inline">\(A\)</span>
的作用下<strong>向量长度的最大拉伸</strong></li>
</ul>
<h4 id="范数">1 范数</h4>
<p><span class="math display">\[
\Vert{A}\Vert_{1}=\max_{j}\left(\sum_{i=1}^{n}\vert{a_{ij}}\vert\right)
\]</span></p>
<ul>
<li><span class="math inline">\(\Vert{A}\Vert_{1}\)</span> 是自然范数
<ul>
<li><a href="/2021/10/02/computation/pyr/03/#算子范数">证明</a></li>
</ul></li>
</ul>
<h4 id="无穷范数">无穷范数</h4>
<p><span class="math display">\[
\Vert{A}\Vert_{\infty}=\max_{i}\left(\sum_{j=1}^{n}\vert{a_{ij}}\vert\right)
\]</span></p>
<ul>
<li><span class="math inline">\(\Vert{A}\Vert_{\infty}\)</span>
是自然范数
<ul>
<li><a href="/2021/10/02/computation/pyr/03/#算子范数">证明</a></li>
</ul></li>
</ul>
<h5 id="补充">补充</h5>
<ul>
<li>和书上不一样的证明方式，证明如下部分的时候</li>
</ul>
<p><span class="math display">\[
\Vert{A}\Vert_{\infty}\ge\max_{i}\left(\sum_{j=1}^{n}\vert{a_{ij}}\vert\right)
\]</span></p>
<ul>
<li>只需要构造一个向量 <span class="math inline">\(x\)</span>，满足如上式子即可</li>
<li>令 <span class="math inline">\(p\)</span> 为满足如下式子的整数</li>
</ul>
<p><span class="math display">\[
\mu=\sum_{j=1}^{n}\vert{a_{pj}}\vert=\max_{i}\left(\sum_{j=1}^{n}\vert{a_{ij}}\vert\right)
\]</span></p>
<ul>
<li>构造 <span class="math inline">\(x\)</span> 如下</li>
</ul>
<p><span class="math display">\[
x_j=\left\{\begin{array}{ll}
1,&amp;\mathrm{if}\;a_{pj}\ge0\\
-1,&amp;\mathrm{if}\;a_{pj}&lt;0\\
\end{array}\right.
\]</span></p>
<ul>
<li>那么有 <span class="math inline">\(\Vert{x}\Vert_{\infty}=1,a_{pj}x_j=\vert{a_{pj}}\vert_{\infty}\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\Vert{Ax}\Vert_{\infty}&amp;=\max_{1\le i\le
n}\left\vert{\sum_{j=1}^{n}a_{ij}x_j}\right\vert\\
&amp;\ge\left\vert{\sum_{j=1}^{n}a_{pj}x_j}\right\vert\\
&amp;=\sum_{j=1}^{n}\left\vert{a_{pj}}\right\vert\\
&amp;=\max_{i}\left(\sum_{j=1}^{n}\vert{a_{ij}}\vert\right)
\end{aligned}
\]</span></p>
<h4 id="范数-谱范数">2 范数 / 谱范数</h4>
<ul>
<li><span class="math inline">\(A\)</span> 的谱范数定义为 <span class="math inline">\(A^HA\)</span> 的最大特征值的平方根</li>
</ul>
<p><span class="math display">\[
\Vert{A}\Vert_{2}=\sqrt{\lambda_{max}(A^HA)}
\]</span></p>
<ul>
<li><span class="math inline">\(A^{H}\)</span> 表示矩阵 <span class="math inline">\(A\)</span> 的共轭转置，如果是实矩阵，等价为 <span class="math inline">\(A^{T}\)</span></li>
<li><span class="math inline">\(\Vert{A}\Vert_{2}\)</span> 是自然范数
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/30674132">参考资料</a></li>
</ul></li>
</ul>
<h5 id="证明-1">证明</h5>
<ul>
<li>以下只在<strong>实数域</strong>内证明
<ul>
<li>复数域同理</li>
</ul></li>
<li><span class="math inline">\(A^{T}A\)</span> 半正定，因此 <span class="math inline">\(A^{T}A\)</span> 的特征值都为非负数</li>
</ul>
<p><span class="math display">\[
x^{T}A^{T}Ax=(Ax)^{T}(Ax)=\Vert{Ax}\Vert_2^{2}\ge0
\]</span></p>
<ul>
<li>记矩阵 <span class="math inline">\(A^{T}A\)</span> 的特征值为 <span class="math inline">\(\lambda_1\ge\lambda_2\ge\cdots\ge\lambda_n\ge0\)</span>，对应的单位特征向量为
<span class="math inline">\(x_1,\cdots,x_n\)</span>
<ul>
<li><strong>零特征值则对应一个与之前向量都正交的单位向量</strong></li>
</ul></li>
<li>对于任意的单位向量 <span class="math inline">\(u\in\mathbb{R}^{n}\)</span>，其可以表示为</li>
</ul>
<p><span class="math display">\[
u=a_1x_1+\cdots+a_nx_n
\]</span></p>
<ul>
<li>可以得到</li>
</ul>
<p><span class="math display">\[
u^{T}u=a_1^2+\cdots+a_n^2=1
\]</span></p>
<p><span class="math display">\[
A^TAu=a_1\lambda_1x_1+\cdots+a_n\lambda_nx_n
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\Vert{Au}\Vert_2^2&amp;=u^TA^TAu\\
&amp;=u^T(a_1\lambda_1x_1+\cdots+a_n\lambda_nx_n)\\
&amp;=\lambda_1a_1^2+\cdots+\lambda_na_n^2\\
&amp;\le\lambda_1(a_1^2+\cdots+a_n^2)\\
&amp;=\lambda_1\\
\end{aligned}
\]</span></p>
<ul>
<li>所以我们得到</li>
</ul>
<p><span class="math display">\[
\\\max_{\Vert{x}\Vert_2=1}\Vert{Ax}\Vert_2\le\sqrt{\lambda_1}
\]</span></p>
<ul>
<li>同时我们有</li>
</ul>
<p><span class="math display">\[
\Vert{Ax_1}\Vert_2^2=x_1^TA^TAx_1=x_1^T\lambda_1x_1=\lambda_1
\]</span></p>
<ul>
<li>所以</li>
</ul>
<p><span class="math display">\[
\max_{\Vert{x}\Vert_2=1}\Vert{Ax}\Vert_2\ge\Vert{Ax_1}\Vert_2=\sqrt{\lambda_1}
\]</span></p>
<ul>
<li>因此</li>
</ul>
<p><span class="math display">\[
\max_{\Vert{x}\Vert_2=1}\Vert{Ax}\Vert_2=\sqrt{\lambda_1}
\]</span></p>
<h3 id="f-范数">F 范数</h3>
<ul>
<li>Frobenius 范数</li>
</ul>
<p><span class="math display">\[
\Vert{A}\Vert_{F}=\sqrt{\sum_{i=1}^{n}\sum_{j=1}^{n}\vert{a_{ij}}\vert^{2}}=\sqrt{\mathrm{tr}(A^{T}A)}
\]</span></p>
<h4 id="性质-1">性质 1</h4>
<p><span class="math display">\[
\Vert{A}\Vert_{2}\le\Vert{A}\Vert_{F}\le\sqrt{n}\Vert{A}\Vert_{2}
\]</span></p>
<ul>
<li>证明：<strong>矩阵的迹等于矩阵所有特征值的和</strong></li>
</ul>
<h4 id="性质-2">性质 2</h4>
<p><span class="math display">\[
\Vert{Ax}\Vert_{2}\le\Vert{A}\Vert_{F}\Vert{x}\Vert_{2}
\]</span></p>
<ul>
<li>证明（柯西不等式）</li>
</ul>
<p><img src="/2021/11/01/computation/pyr/06/image-20211102163239545.png" style="zoom:80%;"></p>
<h4 id="f-范数不是自然范数">F 范数不是自然范数</h4>
<ul>
<li>考虑单位矩阵</li>
</ul>
<p><span class="math display">\[
\Vert{I}\Vert_{F}=\sqrt{n}\ne\max_{\Vert{x}\Vert\ne0}\dfrac{\Vert{Ix}\Vert}{\Vert{x}\Vert}=1
\]</span></p>
<h2 id="特征值与特征向量">3. 特征值与特征向量</h2>
<h3 id="特征值">特征值</h3>
<ul>
<li>特征值 <span class="math inline">\(\lambda\)</span></li>
</ul>
<p><span class="math display">\[
\det(A-\lambda I)=0
\]</span></p>
<h3 id="特征向量">特征向量</h3>
<ul>
<li>特征向量 <span class="math inline">\(x\)</span></li>
</ul>
<p><span class="math display">\[
Ax=\lambda x
\]</span></p>
<h3 id="行列式">行列式</h3>
<ul>
<li>矩阵的行列式所有特征值的积
<ul>
<li><span class="math inline">\(\det(\lambda
I-A)=(\lambda-\lambda_1)\cdots(\lambda-\lambda_n)\)</span></li>
<li>令 <span class="math inline">\(\lambda=0\)</span> 即证</li>
</ul></li>
</ul>
<p><span class="math display">\[
\det(A)=\prod_{i=1}^{n}\lambda_i
\]</span></p>
<h3 id="迹">迹</h3>
<ul>
<li>矩阵的迹等于所有特征值的和
<ul>
<li>两种方式展开 <span class="math inline">\(\det(\lambda I-A)\)</span>
，<span class="math inline">\(n-1\)</span> 次项的系数相等
<ul>
<li>特征值为根、硬展开</li>
<li>硬展开降阶的时候，非对角线展开最多只有 <span class="math inline">\(n-2\)</span> 次项</li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
\mathrm{tr}(A)=\sum_{i=1}^{n}a_{ii}=\sum_{i=1}^{n}\lambda_{i}
\]</span></p>
<h3 id="幂乘性质">幂乘性质</h3>
<ul>
<li><span class="math inline">\(A^k\)</span> 的特征值为 <span class="math inline">\(\lambda_1^k,\cdots,\lambda_n^k\)</span></li>
<li>如果矩阵 <span class="math inline">\(A\)</span> 等于共轭转置矩阵
<span class="math inline">\(A^{H}\)</span>，即<strong>厄米特矩阵</strong>，则所有特征值都是实数</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
(Ax)^{H}=(\lambda x)^{H}\Rightarrow x^{H}A^{H}=\bar{\lambda}x^{H}\\
x^{H}A^{H}x=\bar{\lambda}x^{H}x\\
0=x^{H}A^{H}x-x^{H}Ax=(\lambda-\bar{\lambda})x^{H}x\\
\bar{\lambda}=\lambda\\
\end{array}
\]</span></p>
<h3 id="谱半径">谱半径</h3>
<p><span class="math display">\[
\rho(A)=\max_{1\le i\le n}\vert{\lambda_i}\vert
\]</span></p>
<ul>
<li>2范数定义</li>
</ul>
<p><span class="math display">\[
\Vert{A}\Vert_2=\sqrt{\rho(A^{T}A)}
\]</span></p>
<ul>
<li>对任意自然范数</li>
</ul>
<p><span class="math display">\[
\rho(A)\le\Vert{A}\Vert
\]</span></p>
<ul>
<li>证明
<ul>
<li>取特征值对应的单位特征向量</li>
</ul></li>
</ul>
<p><span class="math display">\[
\vert{\lambda}\vert=\vert{\lambda}\vert\Vert{x}\Vert=\Vert{\lambda
x}\Vert=\Vert{Ax}\Vert\le\Vert{A}\Vert
\]</span></p>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.07.特征值与奇异值(2)</title>
    <url>/2021/11/13/computation/pyr/07-1/</url>
    <content><![CDATA[<ul>
<li>PPT（特征值）</li>
</ul>
<h1 id="特征值与奇异值">特征值与奇异值</h1>
<ul>
<li>特征值：Eigenvalue</li>
<li>特征向量：Eigenvector</li>
</ul>
<h2 id="定理">1. 定理</h2>
<h3 id="相似矩阵">相似矩阵</h3>
<ul>
<li>若存在非奇异矩阵 <span class="math inline">\(S\)</span>，满足 <span class="math inline">\(A=S^{-1}BS\)</span>，则称矩阵 <span class="math inline">\(A\)</span> 与矩阵 <span class="math inline">\(B\)</span> 为<strong>相似矩阵</strong></li>
<li>相似矩阵特征值相等
<ul>
<li>假定 <span class="math inline">\(x\ne0\)</span></li>
<li>那么有 <span class="math inline">\(S^{-1}BSx=Ax=\lambda
x\)</span></li>
<li><span class="math inline">\(BSx=SAx=\lambda Sx\)</span></li>
<li>于是 <span class="math inline">\(\lambda\)</span> 是矩阵 <span class="math inline">\(B\)</span> 的特征值，<span class="math inline">\(Sx\)</span> 是对应的特征向量</li>
</ul></li>
</ul>
<h3 id="schur-定理">Schur 定理</h3>
<ul>
<li><span class="math inline">\(A\)</span> 为任意矩阵，存在非奇异矩阵
<span class="math inline">\(U\)</span> 使得 <span class="math inline">\(T=U^{-1}AU\)</span>，其中 <span class="math inline">\(T\)</span>
为<strong>上三角矩阵</strong>，<strong>对角线元素</strong>为矩阵 <span class="math inline">\(A\)</span> 的<strong>特征值</strong></li>
</ul>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211114185219902.png" alt="image-20211114185219902" style="zoom:80%;"></p>
<ul>
<li>如果 <span class="math inline">\(A\)</span>
是对称矩阵，则存在正交矩阵 <span class="math inline">\(Q\)</span> 使得
<span class="math inline">\(D=Q^{-1}AQ=Q^{T}AQ\)</span>，其中 <span class="math inline">\(D\)</span>
为<strong>对角线矩阵</strong>，<strong>对角线元素</strong>为矩阵 <span class="math inline">\(A\)</span> 的<strong>特征值</strong></li>
</ul>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211114185412845.png" style="zoom:80%;"></p>
<ul>
<li>如果 <span class="math inline">\(\Vert{Ux}\Vert_2=\Vert{x}\Vert_2\)</span>，<span class="math inline">\(U\)</span> 为酉矩阵，具有保范性质
<ul>
<li><strong>正交矩阵是酉矩阵</strong></li>
</ul></li>
</ul>
<h3 id="jacobi-方法">Jacobi 方法</h3>
<ul>
<li>用于求解<strong>实对称矩阵</strong>的特征值</li>
<li>通过<span id="rot">旋转矩阵</span>，构造相似矩阵
<ul>
<li>如下是 <span class="math inline">\({\color{red}Q^{T}}\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211114191016152.png" style="zoom:80%;"></p>
<ul>
<li>旋转矩阵 <span class="math inline">\(Q\)</span>：第 <span class="math inline">\(i,j\)</span> 行出现和单位矩阵不一样的元素（<span class="math inline">\(\cos\theta,\sin\theta\)</span>）</li>
<li>记 <span class="math inline">\(B=Q^{-1}AQ\)</span>，我们会发现 <span class="math inline">\(B\)</span> 只有第 <span class="math inline">\(i,j\)</span> 行和第 <span class="math inline">\(i,j\)</span> 列和 <span class="math inline">\(A\)</span> 不一样</li>
</ul>
<p><span class="math display">\[
\left[\begin{matrix} b_{ii} &amp; b_{ij} \\ b_{ji} &amp; b_{jj} \\
\end{matrix}\right]=\left[\begin{matrix} c &amp; -s \\ s&amp; c \\
\end{matrix}\right]^T \left[\begin{matrix} a_{ii} &amp; a_{ij} \\ a_{ji}
&amp; a_{jj} \\ \end{matrix}\right] \left[\begin{matrix} c &amp; -s \\
s&amp; c \\ \end{matrix}\right]
\]</span></p>
<p><span class="math display">\[
\left[\begin{matrix} b_{ii} &amp; 0 \\ 0 &amp; b_{jj} \\
\end{matrix}\right]=\left[\begin{matrix} a_{ii}c^2+a_{jj}s^2+2csa_{ij}
&amp; cs(a_{jj}-a_{ii})+a_{ij}(c^2-s^2) \\ cs(a_{jj}-a_{ii}) +
a_{ij}(c^2-s^2) &amp; a_{jj}c^2+a_{ii}s^2-2csa_{ij} \end{matrix}\right]
\]</span></p>
<ul>
<li>整个矩阵结果如下</li>
</ul>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211114192652584.png" style="zoom:80%;"></p>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211114192945461.png" style="zoom:80%;"></p>
<ul>
<li>思路：不断地消去非对角线元素
<ul>
<li>正交变换 <span class="math inline">\(F\)</span> 范数不变</li>
<li>上述变换后，<strong>对角线上的元素平方和变大了，非对角线上元素的平方和变小了</strong></li>
<li>经过有限次变换，能够求得特征值</li>
</ul></li>
</ul>
<h3 id="推论">推论</h3>
<ul>
<li>如果矩阵 <span class="math inline">\(A\)</span> 为对称矩阵，其 <span class="math inline">\(n\)</span>
个特征向量构成<strong>单位正交集</strong>，矩阵 <span class="math inline">\(A\)</span> 的特征值为<strong>实数</strong></li>
</ul>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211114194619280.png" style="zoom:80%;"></p>
<h3 id="正定性与特征值">正定性与特征值</h3>
<ul>
<li>对称矩阵 <span class="math inline">\(A\)</span>
为正定矩阵当且仅当矩阵 <span class="math inline">\(A\)</span>
的所有特征值都是<strong>正数</strong>
<ul>
<li>利用特征向量正交、线性即证</li>
</ul></li>
<li>证明</li>
</ul>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211114194840860.png" style="zoom:80%;"></p>
<h3 id="gerschgorin-圆盘定理">Gerschgorin 圆盘定理</h3>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211114200108752.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(k\)</span>
个圆的并集指的是原本就相交形成的连通区域</li>
<li>证明</li>
</ul>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211114200725079.png" style="zoom: 80%;"></p>
<h2 id="幂方法">2. 幂方法</h2>
<ul>
<li><a href="/2021/11/12/computation/pyr/07/">note</a></li>
<li>占优特征值
<ul>
<li><span class="math inline">\(\lambda_1=\lambda_2=\cdots=\lambda_k\)</span></li>
<li><span class="math inline">\(\lambda_1=-\lambda_2\)</span>
<ul>
<li>无法确定正负</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211114201323419.png" style="zoom:80%;"></p>
<h3 id="逆幂方法">逆幂方法</h3>
<ul>
<li><span class="math inline">\((A-qI)^{-1}x\)</span> 使用幂方法
<ul>
<li><span class="math inline">\(q\)</span> 的选择决定了收敛速度</li>
<li><span class="math inline">\(q\)</span> 与特征值 <span class="math inline">\(\lambda_k\)</span> 越接近，收敛越快</li>
</ul></li>
</ul>
<h2 id="收缩方法">3. 收缩方法</h2>
<ul>
<li>在计算了主特征值的近似值后，可以通过紧缩获得矩阵其它特征值</li>
</ul>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211114223656274.png" style="zoom:80%;"></p>
<h3 id="wielandt-收缩">Wielandt 收缩</h3>
<ul>
<li>构造一个新的矩阵 <span class="math inline">\(B\)</span>，其特征值除了占优特征值之外与 <span class="math inline">\(A\)</span> 相同，其中占优特征值被替换为 0
<ul>
<li>只有占有特征值与 <span class="math inline">\(A\)</span> 不同</li>
</ul></li>
</ul>
<h4 id="定理-1">定理</h4>
<ul>
<li>假设 <span class="math inline">\(\lambda_1,\cdots,\lambda_n\)</span>
是 <span class="math inline">\(A\)</span> 的特征值，其特征向量 <span class="math inline">\(v^{(1)},\cdots,v^{(n)}\)</span>，且 <span class="math inline">\(\lambda_1\)</span> 的重数为 1</li>
<li>设 <span class="math inline">\(x\)</span> 为向量满足 <span class="math inline">\(x^{T}v^{(1)}=1\)</span>，则矩阵 <span class="math inline">\(B=A-\lambda_1v^{(1)}x^{T}\)</span>
<ul>
<li><span class="math inline">\(B\)</span> 的特征值为 <span class="math inline">\(0,\lambda_2,\cdots,\lambda_n\)</span>，特征向量为
<span class="math inline">\(v^{(1)},w^{(1)}\cdots,w^{(n)}\)</span></li>
<li><span class="math inline">\(v^{(i)}=(\lambda_i-\lambda_1)w^{(i)}+\lambda_1x^{T}w^{(i)}v^{(1)}\)</span></li>
</ul></li>
</ul>
<h4 id="算法细节">算法细节</h4>
<ul>
<li>如何构造 <span class="math inline">\(x\)</span></li>
</ul>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211114230455940.png" style="zoom:80%;"></p>
<ul>
<li>发现矩阵 <span class="math inline">\(B=A-\lambda_1v^{(1)}x^{T}\)</span> 的第 <span class="math inline">\(i\)</span> 行全为 0
<ul>
<li>代入即得</li>
</ul></li>
<li><span class="math inline">\(Bw=\lambda w\)</span>
<ul>
<li>因此，<span class="math inline">\(w\)</span> 的第 <span class="math inline">\(i\)</span> 个分量是 0，所以 <span class="math inline">\(B\)</span> 的第 <span class="math inline">\(i\)</span> 列对解没有贡献，去掉第 <span class="math inline">\(i\)</span> 行和第 <span class="math inline">\(i\)</span> 列得到 <span class="math inline">\((n-1)\times(n-1)\)</span> 矩阵 <span class="math inline">\(B&#39;\)</span>
<ul>
<li>行列式展开的角度也行</li>
</ul></li>
</ul></li>
<li>对 <span class="math inline">\(B&#39;\)</span> 应用幂方法，得到
<span class="math inline">\(\lambda_2\)</span> 与 <span class="math inline">\(w&#39;^{(2)}\)</span>， 并插入 0 得到 <span class="math inline">\(w^{(2)}\)</span></li>
<li>问题：<strong>易受舍入误差影响</strong></li>
</ul>
<h3 id="householder-变换">Householder 变换</h3>
<ul>
<li><span class="math inline">\(P=I-2ww^{T}\)</span>，其中 <span class="math inline">\(w^{T}w=1,w\in\mathbb{R}^{n}\)</span>
<ul>
<li><span class="math inline">\(P\)</span>
是<strong>对称正交</strong>矩阵</li>
</ul></li>
</ul>
<h4 id="目标">目标</h4>
<ul>
<li>利用 Householder 方法计算对称<strong>三对角线矩阵</strong> <span class="math inline">\(B\)</span>，其与给定的<strong>对称矩阵</strong>
<span class="math inline">\(A\)</span> 相似
<ul>
<li>和<a href="/2021/11/12/computation/pyr/07/#上海森伯格形式">这部分</a>有些接近</li>
</ul></li>
</ul>
<h4 id="步骤">步骤</h4>
<ul>
<li>定义矩阵变换 <span class="math inline">\(P^{(1)}\)</span> 满足 <span class="math inline">\(A^{(2)}=P^{(1)}AP^{(1)}\)</span>
<ul>
<li>显然 <span class="math inline">\(P^{(2)}\)</span> 是对称矩阵，<span class="math inline">\(P^{(1)},A\)</span> 都是对称矩阵</li>
</ul></li>
<li>试图在变换后保证
<ul>
<li><span class="math inline">\(a_{11}^{(2)}=a_{11}\)</span>
<ul>
<li><span class="math inline">\(w_1=0\)</span> 即可</li>
</ul></li>
<li><span class="math inline">\(a_{j1}^{(2)}=0,(j=3,\cdots,n)\)</span></li>
</ul></li>
<li>也就是说，利用 HouseHolder 变换将 <span class="math inline">\((a_{21},a_{31},\cdots,a_{n1})^{T}\)</span> 转换为
<span class="math inline">\((\alpha,0,\cdots,0)^{T}\)</span></li>
</ul>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211115154049207.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(\hat{w}^{T}\hat{y}\)</span> 是 <span class="math inline">\(1\times1\)</span> 的，因此可以提前</li>
</ul>
<h5 id="求解参数">求解参数</h5>
<ul>
<li>计算具体的 <span class="math inline">\(\alpha\)</span> 值</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
(\alpha,0,\cdots,0)=(a_{21}-rw_2,a_{31}-rw_3,\cdots,a_{n1}-rw_n)\\
其中\ r=\hat{w}^{T}\hat{y}\\
\end{array}
\]</span></p>
<p><span class="math display">\[
\begin{array}{c}
\alpha=a_{21}-rw_2\\
a_{i1}-rw_i=0,i=3,\cdots,n\\
\end{array}
\]</span></p>
<ul>
<li>对 <span class="math inline">\(2rw_i\)</span> 平方求和</li>
</ul>
<p><span class="math display">\[
4r^2\sum_{j=2}^{n}w_j^2=(a_{21}-\alpha)^{2}+\sum_{j=3}^{n}a_{j1}^{2}
\]</span></p>
<ul>
<li>左边：<span class="math inline">\(4r^{2}(1-w_{1}^{2})=4r^{2}\)</span></li>
</ul>
<p><span class="math display">\[
4r^{2}=-2\alpha a_{21}+\alpha^{2}+\sum_{j=2}^{n}a_{j1}^{2}
\]</span></p>
<ul>
<li>再由 <span class="math inline">\(P\)</span> 的正交性</li>
</ul>
<p><span class="math display">\[
\alpha^{2}=(\hat{P}\hat{y})^{T}(\hat{P}\hat{y})=\hat{y}^{T}\hat{P}^{T}\hat{P}\hat{y}=\hat{y}^{T}\hat{y}=\sum_{j=2}^{n}a_{j1}^{2}
\]</span></p>
<ul>
<li>结合上面两个式子，得到</li>
</ul>
<p><span class="math display">\[
2r^{2}=-\alpha a_{21}+\sum_{j=2}^{n}a_{j1}^{2}=-\alpha a_{21}+\alpha^{2}
\]</span></p>
<ul>
<li>可以求解得到 <span class="math inline">\(\alpha,w\)</span></li>
</ul>
<p><span class="math display">\[
\alpha=-\mathrm{sgn}(a_{21})\sqrt{\sum_{j=2}^{n}a_{j1}^{2}}
\]</span></p>
<p><span class="math display">\[
2r^{2}=-\alpha a_{21}+\alpha^{2}
\]</span></p>
<p><span class="math display">\[
\begin{array}{c}
w_2=\dfrac{a_{21}-\alpha}{2r}\\
w_i=\dfrac{a_{i1}}{2r},i=3,\cdots,n
\end{array}
\]</span></p>
<ul>
<li>之后的步骤类似前面的，<strong>收缩方法</strong></li>
</ul>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211115160803192.png" style="zoom:80%;"></p>
<h2 id="qr-迭代">4. QR 迭代</h2>
<ul>
<li>QR 方法
<ul>
<li>同时确定对称矩阵所有特征值的矩阵约化方法</li>
<li>QR 方法可以生成一组矩阵 <span class="math inline">\(A=A^{(1)},A^{(2)},\cdots,A^{(n)}\)</span></li>
<li><span class="math inline">\(A^{(1)}=A\)</span> 分解为矩阵乘积 <span class="math inline">\(A^{(1)}=Q^{(1)}R^{(1)}\)</span>
<ul>
<li><span class="math inline">\(Q^{(1)}\)</span> 为正交矩阵</li>
<li><span class="math inline">\(R^{(1)}\)</span> 为上三角矩阵</li>
</ul></li>
<li><span class="math inline">\(A^{(2)}\)</span> 定义为 <span class="math inline">\(A^{(2)}=R^{(1)}Q^{(1)}\)</span></li>
<li>接着继续对 <span class="math inline">\(A^{(2)}\)</span> 进行 QR
分解</li>
<li>可以得到 <span class="math inline">\(A^{(i+1)}=(Q^{(i)})^{T}A^{(i)}Q^{(i)}\)</span>
<ul>
<li><strong>相似变换，特征值不变</strong></li>
</ul></li>
</ul></li>
<li><span class="math inline">\(A^{(i+1)}\)</span> 与 <span class="math inline">\(A^{(i)}\)</span> 具有相同的特征值，<span class="math inline">\(A^{(i+1)}\)</span>
变为对角线矩阵，其对角线上值为矩阵 <span class="math inline">\(A\)</span> 的特征值</li>
</ul>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211115163329723.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(Q^{\infty}\)</span> 与 <span class="math inline">\(A^{\infty}\)</span> 的特征向量相同
<ul>
<li><span class="math inline">\(AB=BA\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(A\)</span> 与 <span class="math inline">\(B\)</span> 具有相同的特征向量</li>
</ul></li>
<li>由于 <span class="math inline">\(Q^{\infty}\)</span>
是正交矩阵，<span class="math inline">\(Q^{\infty}\)</span> 的特征值为
<span class="math inline">\(\pm1\)</span></li>
<li>假设 <span class="math inline">\(A^{\infty}x=\lambda
x\)</span>，则有</li>
</ul>
<p><span class="math display">\[
\lambda x=A^{\infty}x=Q^{\infty}R^{\infty}x=R^{\infty}Q^{\infty}x=\pm
R^{\infty}x
\]</span></p>
<ul>
<li>得出结论
<ul>
<li><span class="math inline">\(A^{\infty}\)</span> 的特征值与 <span class="math inline">\(A\)</span> 的特征值相同</li>
<li>与 <span class="math inline">\(R^{\infty}\)</span> 的特征值相同，即
<span class="math inline">\(R^{\infty}\)</span>
的对角线元素（<strong>可能会差符号</strong>）</li>
<li>与 <span class="math inline">\(Q^{\infty}\)</span>
的特征向量相同</li>
</ul></li>
</ul>
<h3 id="构造-qr">构造 QR</h3>
<ul>
<li>考虑<strong>旋转矩阵</strong>
<ul>
<li>旋转矩阵为正交矩阵
<ul>
<li><span class="math inline">\(p_{ii}=p_{jj}=\cos\theta,p_{ji}=-p_{ij}=\sin\theta\)</span></li>
</ul></li>
</ul></li>
</ul>
<h4 id="三对角线稀疏矩阵">三对角线稀疏矩阵</h4>
<ul>
<li><strong>矩阵 <span class="math inline">\(A\)</span>
为三对角线矩阵</strong> ，对其使用旋转矩阵进行 QR 分解
<ul>
<li>让对角线以下元素变成 0</li>
<li>(1,3) 可能变为非零向量，(1,4)、(1,n) 为 0</li>
</ul></li>
</ul>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211115164955375.png" style="zoom:80%;"></p>
<ul>
<li>算法流程</li>
</ul>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211115165216990.png" style="zoom:80%;"></p>
<ul>
<li>矩阵 <span class="math inline">\(A\)</span>
三对角线最上面一条对角线不一定需要和最下面相同，不需要为 <span class="math inline">\(b_n\)</span></li>
<li><strong>接着使用上面的方法进行迭代</strong></li>
<li><span class="math inline">\(A^{(2)}\)</span> 对角线以外的项比 <span class="math inline">\(A^{(1)}\)</span> 的相应项小，<span class="math inline">\(A^{(1)}\)</span> 更接近对角矩阵</li>
<li>为什么 <span class="math inline">\(A^{(2)}\)</span> 还是三对角线矩阵
？
<ul>
<li><span class="math inline">\(A^{(2)}=(Q^{(1)})^{T}A^{(1)}Q^{(1)}\)</span></li>
<li>因为旋转矩阵只会影响行列 <span class="math inline">\(i,j\)</span></li>
<li><a href="#rot">note</a></li>
</ul></li>
<li>收敛速度
<ul>
<li>对于特征值<span class="math inline">\(\vert\lambda_1\vert&gt;\vert\lambda_2\vert&gt;\cdots&gt;\vert\lambda_n\vert\)</span></li>
<li><span class="math inline">\(A^{(i+1)}\)</span> 的元素 <span class="math inline">\(b_{j+1}^{(i+1)}\)</span> 收敛到 0 的速度依赖于比值
<span class="math inline">\(\dfrac{\vert{\lambda_{j+1}}\vert}{\vert{\lambda_{j}}\vert}\)</span>，接近于
1 的时候收敛速度较慢</li>
</ul></li>
</ul>
<h4 id="平移方法三对角线">平移方法（三对角线）</h4>
<p><img src="/2021/11/13/computation/pyr/07-1/image-20211115170945528.png" style="zoom:80%;"></p>
<ul>
<li>当 <span class="math inline">\(b_n^{(i+1)}\)</span> 足够小，假设
<span class="math inline">\(\lambda_n\approx a_n^{(i+1)}\)</span></li>
<li>删除矩阵的第 n 行与第 n 列，计算 <span class="math inline">\(\lambda_{n-1}\)</span></li>
<li>收敛速度依赖于 <span class="math inline">\(\dfrac{\vert{\lambda_{j+1}-s}\vert}{\vert{\lambda_{j}-s}\vert}\)</span>
, 一般为<strong>三阶收敛速度</strong> 平移需要加回到特征值</li>
</ul>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.07.特征值与奇异值(3)</title>
    <url>/2021/11/15/computation/pyr/07-2/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 12 章（特征值与奇异值） + PPT（特征值）</li>
</ul>
<h1 id="特征值与奇异值">特征值与奇异值</h1>
<h2 id="奇异值分解">3. 奇异值分解</h2>
<h2 id="svd-的应用">4. SVD 的应用</h2>
]]></content>
      <categories>
        <category>computation.pyr</category>
        <category>TODO</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.07.特征值与奇异值</title>
    <url>/2021/11/12/computation/pyr/07/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 12 章（特征值与奇异值） + PPT（特征值）</li>
</ul>
<h1 id="特征值与奇异值">特征值与奇异值</h1>
<ul>
<li>求解矩阵 <span class="math inline">\(A\)</span> 的特征值</li>
</ul>
<p><span class="math display">\[
\det(\lambda I-A)=0
\]</span></p>
<h2 id="幂迭代方法">1. 幂迭代方法</h2>
<ul>
<li><strong>一次求出一个特征值</strong></li>
</ul>
<h3 id="幂迭代">1.1 幂迭代</h3>
<ul>
<li>幂迭代的动机：<strong>与矩阵相乘可以将向量推向主特征向量的方向</strong></li>
</ul>
<h4 id="占优特征值">占优特征值</h4>
<ul>
<li>令 <span class="math inline">\(A\)</span> 是一个 <span class="math inline">\(m\times m\)</span> 矩阵，<span class="math inline">\(A\)</span>
的<strong>占优特征值</strong>是量级比矩阵 <span class="math inline">\(A\)</span> 所有其他特征值都大的特征值 <span class="math inline">\(\lambda\)</span>
<ul>
<li>如果这样的特征值存在，与 <span class="math inline">\(\lambda\)</span>
相关的特征向量被称为<strong>占优特征向量</strong></li>
</ul></li>
<li><strong>绝对值最大的特征值</strong></li>
<li><strong>对于任意的初始向量，<span class="math inline">\(A^{n}x\)</span> 会趋近于占优特征向量</strong>
<ul>
<li><span class="math inline">\(x\)</span> 可以由特征向量线性表出</li>
<li><span class="math inline">\(A^{n}x\)</span>
会被<strong>占优特征向量</strong>占优</li>
<li>计算过程中，每一步都进行归一化，可以不让数字失去控制
<ul>
<li><strong>这不影响占优</strong>，对所有向量都是一个等比例的操作</li>
</ul></li>
</ul></li>
</ul>
<h4 id="瑞利商">瑞利商</h4>
<ul>
<li>Rayleigh</li>
<li>最小二乘
<ul>
<li>特征值方程：<span class="math inline">\(x\lambda=Ax\)</span>
<ul>
<li>其中，<span class="math inline">\(x\)</span> 是特征向量的近似</li>
</ul></li>
<li>法线方程：<span class="math inline">\(x^{T}x\lambda=x^{T}Ax\Rightarrow\lambda=\dfrac{x^{T}Ax}{x^{T}x}\)</span>
<ul>
<li><span class="math inline">\(Ax=b\Rightarrow
A^{T}Ax=A^{T}b\)</span></li>
</ul></li>
</ul></li>
<li><strong>瑞利商是在最小二乘意义下的最优特征值近似</strong></li>
</ul>
<h4 id="幂迭代算法">幂迭代算法</h4>
<p><span class="math display">\[
\begin{array}{l}
给定初始向量\ x_0\\
\begin{array}{rl}
\mathrm{for}&amp;j=1,2,3,\cdots\\
&amp;u_{j-1}=\dfrac{x_{j-1}}{\Vert{x_{j-1}}\Vert_2}\\
&amp;x_j=Au_{j-1}\\
&amp;\lambda_j=u_{j-1}^{T}Au_{j-1}=u_{j-1}^{T}x_{j}\\
\mathrm{end}\\
\end{array}\\
u_{j}=\dfrac{x_{j}}{\Vert{x_{j}}\Vert_2}\\
\end{array}
\]</span></p>
<h3 id="幂迭代的收敛">1.2 幂迭代的收敛</h3>
<p><img src="/2021/11/12/computation/pyr/07/image-20211112160811435.jpg" style="zoom:80%;"></p>
<ul>
<li><strong>线性收敛</strong></li>
<li>收敛常数 <span class="math inline">\(\left\vert\dfrac{\lambda_2}{\lambda_1}\right\vert\)</span></li>
</ul>
<h4 id="证明">证明</h4>
<ul>
<li>线性表出</li>
</ul>
<p><img src="/2021/11/12/computation/pyr/07/image-20211112161201834.jpg" style="zoom:80%;"></p>
<h3 id="幂迭代的逆">1.3 幂迭代的逆</h3>
<ul>
<li>幂迭代算法可以用于求解<strong>绝对值最大的特征值</strong></li>
<li>虽然可以通过每次减去最大特征值对应特征向量，来实现求解次大特征值，从而求解所有特征值</li>
<li>但是由于<strong>累计误差</strong>的存在，之后求解得到的特征值不可靠</li>
<li>幂迭代用于矩阵的<strong>逆矩阵</strong>，则可以求解<strong>绝对值最小的特征值</strong></li>
</ul>
<h4 id="引理">引理</h4>
<p><img src="/2021/11/12/computation/pyr/07/image-20211112161725277.jpg" style="zoom:80%;"></p>
<ul>
<li>证明</li>
</ul>
<p><span class="math display">\[
\begin{array}{rl}
Av_1=\lambda_1v_1&amp;\Rightarrow v_1=A^{-1}\lambda_1v_1\\
&amp;\Rightarrow A^{-1}v_1=\lambda_1^{-1}v_1\\
Av_1=\lambda_1v_1&amp;\Rightarrow
(A-sI)v_1=Av_1-sv_1=(\lambda_1-s)v_1&amp;\\
\end{array}
\]</span></p>
<ul>
<li><strong>求逆</strong>等价于<strong>高斯消去</strong></li>
</ul>
<p><span class="math display">\[
x_{k+1}=A^{-1}x_k\Longleftrightarrow Ax_{k+1}=x_k
\]</span></p>
<ul>
<li>加上转移矩阵，如果我们知道特征值的近似，可以求出这个特征值
<ul>
<li>离这个特征值最近（最小）</li>
</ul></li>
</ul>
<h4 id="逆向幂迭代算法">逆向幂迭代算法</h4>
<p><span class="math display">\[
\begin{array}{l}
给定初始向量\ x_0,平移\ s\\
\begin{array}{rl}
\mathrm{for}&amp;j=1,2,3,\cdots\\
&amp;u_{j-1}=\dfrac{x_{j-1}}{\Vert{x_{j-1}}\Vert_2}\\
&amp;求解\ (A-sI)x_j=u_{j-1}\\
&amp;\lambda_j=u_{j-1}^{T}(A-sI)^{-1}u_{j-1}=u_{j-1}^{T}x_{j}\\
\mathrm{end}\\
\end{array}\\
u_{j}=\dfrac{x_{j}}{\Vert{x_{j}}\Vert_2}\\
\end{array}
\]</span></p>
<h3 id="瑞利商迭代rqi">1.4 瑞利商迭代(RQI)</h3>
<ul>
<li>在逆向幂迭代算法中，同时更新近似的特征值 <span class="math inline">\(s\to \lambda_{j-1}\)</span></li>
</ul>
<h4 id="瑞利商算法">瑞利商算法</h4>
<ul>
<li>求得的特征值就是原始矩阵 <span class="math inline">\(A\)</span>
的占优特征值
<ul>
<li>依赖于：<strong>逆矩阵、转移矩阵的特征向量和原始矩阵相同</strong></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{array}{l}
给定初始向量\ x_0\\
\begin{array}{rl}
\mathrm{for}&amp;j=1,2,3,\cdots\\
&amp;u_{j-1}=\dfrac{x_{j-1}}{\Vert{x_{j-1}}\Vert_2}\\
&amp;\lambda_j=u_{j-1}^{T}Au_{j-1}\\
&amp;求解\ (A-\lambda_{j}I)x_j=u_{j-1}\\
\mathrm{end}\\
\end{array}\\
u_{j}=\dfrac{x_{j}}{\Vert{x_{j}}\Vert_2}\\
\end{array}
\]</span></p>
<h3 id="总结">1.5 总结</h3>
<ul>
<li>收敛速度
<ul>
<li>逆向幂迭代线性收敛</li>
<li>瑞利商迭代则二次收敛到单特征值（非重复），如果矩阵对称则可以得到三次收敛</li>
</ul></li>
<li>收敛后矩阵 <span class="math inline">\(A-\lambda_{j-1}I\)</span>
为奇异矩阵，不能继续迭代
<ul>
<li>因而可以通过误差测试使得在这种情况出现之前终止迭代（<strong>提前结束</strong>）</li>
</ul></li>
<li>RQI 复杂度提高了
<ul>
<li><span class="math inline">\(Ax=b\)</span> 中如果 <span class="math inline">\(A\)</span> 不改变，则只需要一次 LU 分解，参考 <a href="/2021/10/02/computation/pyr/03/#lu-分解的好处">note</a>
<ul>
<li>逆向幂迭代仅仅需要一次 LU 分解</li>
<li>但是对于 RQI，每步还需要一次分解，这是由于平移量的改变</li>
</ul></li>
</ul></li>
</ul>
<h2 id="qr-方法">2. QR 方法</h2>
<ul>
<li><strong>一次求出所有特征值</strong></li>
</ul>
<h3 id="同时迭代">2.1 同时迭代</h3>
<ul>
<li><strong>对称矩阵</strong></li>
<li><strong>对称矩阵</strong>的特征值为实数，其特征向量构成 <span class="math inline">\(\mathbb{R}^{m}\)</span> 空间的一组单位正交基</li>
<li>思路：<strong>初始给定一组正交基，同时幂迭代，得到最终的特征向量</strong></li>
<li>但是幂迭代会让任意向量趋向占优特征向量
<ul>
<li>每次迭代结束对其正交化</li>
<li>假设 <span class="math inline">\(\lambda_1\)</span> 准确找到，那么
<span class="math inline">\(Av_2\)</span>
向量最终会趋向于次优特征向量（<strong>因为没有占优特征向量的成分</strong>）</li>
</ul></li>
</ul>
<h4 id="一个例子">一个例子</h4>
<ul>
<li>初始正交基为<strong>初等基向量</strong></li>
<li><a href="https://banbao991.github.io/2021/10/28/computation/pyr/05/#qr-%E5%88%86%E8%A7%A3">QR
分解</a></li>
</ul>
<p><img src="/2021/11/12/computation/pyr/07/image-20211112182101285.jpg" style="zoom:80%;"></p>
<p><img src="/2021/11/12/computation/pyr/07/image-20211112182520024.jpg" style="zoom:80%;"></p>
<h4 id="算法">算法</h4>
<p><span class="math display">\[
\begin{array}{rll}
设&amp; \overline{Q}_0=I&amp;\\
\mathrm{for}&amp;j=1,2,3,\cdots&amp;\\
&amp;A\overline{Q}_j=\overline{Q}_{j+1}R_{j+1}&amp;(QR分解)\\
\mathrm{end}&amp;&amp;\\
\end{array}\\
\]</span></p>
<ul>
<li>在第 <span class="math inline">\(j\)</span> 步中，<span class="math inline">\(\overline{Q}_j\)</span> 的列就是 <span class="math inline">\(A\)</span>
的<strong>特征向量的近似</strong>，对角线元素 <span class="math inline">\(r_{ii}\)</span>
是<strong>近似的特征值</strong></li>
</ul>
<h4 id="无移动的-qr-算法">无移动的 QR 算法</h4>
<ul>
<li>原始迭代：<span class="math inline">\(\overline{Q}_0=I\)</span>
<ul>
<li>12.7</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
A\overline{Q}_0=\overline{Q}_1R_1\\
A\overline{Q}_1=\overline{Q}_2R_2\\
A\overline{Q}_2=\overline{Q}_3R_3\\
\cdots\
\end{array}
\]</span></p>
<ul>
<li>相似的迭代：<span class="math inline">\(Q_0=I\)</span>（<strong>无移动的 QR
算法</strong>）
<ul>
<li>12.8</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
A_0\equiv AQ_0=Q_1R_1&#39;\\
A_1\equiv R_1&#39;Q_1=Q_2R_2&#39;\\
A_2\equiv R_2&#39;Q_2=Q_3R_3&#39;\\
\cdots\
\end{array}
\]</span></p>
<ul>
<li>区别：用 <span class="math inline">\({\color{red}R_i&#39;}Q_i\)</span> 代替 <span class="math inline">\({\color{red}A}Q_i\)</span></li>
</ul>
<p><img src="/2021/11/12/computation/pyr/07/image-20211112230208575.jpg" style="zoom:80%;"></p>
<ul>
<li>因此输出的特征向量矩阵为 <span class="math inline">\(\overline{Q}_j=Q_1\cdots Q_{j-1}\)</span></li>
<li><span id="ac1">定理</span></li>
</ul>
<p><img src="/2021/11/12/computation/pyr/07/image-20211112231434978.jpg" style="zoom:80%;"></p>
<ul>
<li><strong>对称条件</strong></li>
</ul>
<h3 id="实数舒尔形式和-qr-算法">2.2 实数舒尔形式和 QR 算法</h3>
<ul>
<li>QR 算法找到矩阵 A
的特征值的方式是寻找相似矩阵，该相似矩阵对应的特征值更明显
<ul>
<li><strong>相似矩阵具有相同的特征值，但是不一定有相同的特征向量</strong></li>
</ul></li>
<li><strong>一个例子是实数舒尔形式</strong></li>
</ul>
<h4 id="实数舒尔形式">实数舒尔形式</h4>
<p><img src="/2021/11/12/computation/pyr/07/image-20211113112819206.jpg" style="zoom:80%;"></p>
<h5 id="定理">定理</h5>
<ul>
<li>令 <span class="math inline">\(A\)</span>
是<strong>实数</strong>元素的方阵，则存在<strong>正交矩阵 <span class="math inline">\(Q\)</span></strong> 以及<strong>实数舒尔形式的矩阵
<span class="math inline">\(T\)</span></strong>，满足 <span class="math inline">\(A=Q^TTQ\)</span></li>
</ul>
<h4 id="平移版本">平移版本</h4>
<ul>
<li>一步迭代：先平移，完成 QR 分解之后平移回来</li>
</ul>
<p><span class="math display">\[
\begin{array}{rl}
A_0-sI&amp;=Q_1R_1\\
A_1&amp;=R_1Q_1+sI\\
\end{array}
\]</span></p>
<ul>
<li>注意到</li>
</ul>
<p><span class="math display">\[
A_1-sI=R_1Q_1=Q_1^{T}(A_0-sI)Q_1=Q_1^{T}A_0Q_1-sI
\]</span></p>
<ul>
<li>于是重复上述步骤，我们能够得到一系列和 <span class="math inline">\(A_0\)</span> 相似的矩阵 <span class="math inline">\(A_k\)</span></li>
<li><strong>最优的平移</strong></li>
</ul>
<p><img src="/2021/11/12/computation/pyr/07/image-20211113131524167.jpg" style="zoom:80%;"></p>
<ul>
<li>算法如下</li>
</ul>
<p><img src="/2021/11/12/computation/pyr/07/image-20211113132517051.jpg" style="zoom:80%;"></p>
<ul>
<li>该算法基于<a href="#ac1">上面的定理</a>，如下情况会出问题
<ul>
<li><strong>复数特征值</strong></li>
<li><strong>相同量级的实数特征值</strong></li>
</ul></li>
</ul>
<h4 id="复数特征值">复数特征值</h4>
<ul>
<li>为了计算<strong>复数特征值</strong>，我们需要允许对角线上有 <span class="math inline">\(2\times 2\)</span> 的块
<ul>
<li>如果在指定次数的迭代后无法得到特征值，则收缩 <span class="math inline">\(2\times 2\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/11/12/computation/pyr/07/image-20211113133203701.jpg" style="zoom:80%;"></p>
<ul>
<li>对于重复的复数特征值，无法解决，例如</li>
</ul>
<p><img src="/2021/11/12/computation/pyr/07/image-20211113133539855.jpg" style="zoom:80%;"></p>
<h3 id="上海森伯格形式">2.3 上海森伯格形式</h3>
<p><img src="/2021/11/12/computation/pyr/07/image-20211113133752055.jpg" style="zoom:80%;"></p>
<ul>
<li>如果首先将 <span class="math inline">\(A\)</span>
变换为上海森伯格形式，QR 算法的效率可以大大提高</li>
<li>这种思想是在 QR 迭代之前应用相似变换，在 <span class="math inline">\(A\)</span> 中放置尽可能多的
0，而同时保持特征值</li>
<li>此外，上海森伯格形式将消去我们已经推导的 QR
算法形式中最后的难点，<strong>可以收敛到重复的复数特征值</strong>，这是通过保证
QR 迭代总能收敛到 <span class="math inline">\(1\times1\)</span> 或者
<span class="math inline">\(2\times2\)</span> 的块</li>
</ul>
<h4 id="定理-1">定理</h4>
<ul>
<li>令 <span class="math inline">\(A\)</span>
是<strong>实数</strong>元素的方阵，则存在<strong>正交矩阵 <span class="math inline">\(Q\)</span></strong>
以及<strong>上海森伯格形式的矩阵 <span class="math inline">\(B\)</span></strong>，满足 <span class="math inline">\(A=Q^TBQ\)</span></li>
<li><a href="/2021/10/28/computation/pyr/05/#豪斯霍尔德反射子">豪斯霍尔德反射子</a></li>
</ul>
<h4 id="算法-1">算法</h4>
<p><img src="/2021/11/12/computation/pyr/07/image-20211113163149134.jpg" style="zoom:80%;"></p>
<ul>
<li>MATLAB 算法
<ul>
<li><span class="math inline">\(H=I-2P\)</span>：查看之前的<a href="/2021/10/28/computation/pyr/05/#豪斯霍尔德反射子">笔记</a></li>
</ul></li>
</ul>
<p><img src="/2021/11/12/computation/pyr/07/image-20211113164658972.jpg" style="zoom:80%;"></p>
<ul>
<li>上海森伯格形式对于特征值计算的优势
<ul>
<li>仅有 <span class="math inline">\(2\times2\)</span> 的块可以出现在 QR
算法中的对角线上</li>
<li>这避免了前面章节中<strong>重复的复数特征值</strong>所带来的计算困难</li>
</ul></li>
</ul>
<h3 id="总结-1">2.4 总结</h3>
<ul>
<li>利用相似矩阵有相同的特征值，构造特征值更明显的相似矩阵</li>
<li><strong><span style="color:red">问题</span></strong>
<ul>
<li>没太懂上海森伯格形式为啥解决了重复复数特征值的问题</li>
<li>怎么解决重复的实数特征值问题的</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.08.数值微分与积分(2)</title>
    <url>/2021/11/30/computation/pyr/08-1/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 5 章（数值微分与积分） +
PPT（数值微分与积分方法）</li>
</ul>
<h1 id="数值微分与积分方法">数值微分与积分方法</h1>
<h2 id="数值积分的牛顿-科特斯公式">2. 数值积分的牛顿-科特斯公式</h2>
<ul>
<li>定义在 <span class="math inline">\([a,b]\)</span> 上的函数 <span class="math inline">\(f\)</span> 的积分，可以通过以下两种方式求解
<ul>
<li>取区间中的一些点，使用插值多项式近似
<ul>
<li>牛顿-科特斯方法（Newton-Cotes）</li>
</ul></li>
<li>取区间中的一些点，使用最小二乘多项式近似
<ul>
<li>高斯积分</li>
</ul></li>
</ul></li>
<li>基础积分</li>
</ul>
<p><img src="/2021/11/30/computation/pyr/08-1/image-20211130163933541.png" style="zoom:80%;"></p>
<ul>
<li>插值 <span class="math inline">\((0,0),(h,1)\)</span> 的直线</li>
</ul>
<p><span class="math display">\[
\int_{0}^{h}\dfrac{x}{h}\mathrm{d}x=\dfrac{h}{2}
\]</span></p>
<ul>
<li>插值 <span class="math inline">\((-h,0),(0,1),(h,0)\)</span>
的抛物线 <span class="math inline">\(P(x)\)</span></li>
</ul>
<p><span class="math display">\[
\int_{-h}^{h}P(x)\mathrm{d}x=\int_{0}^{h}\left(-\dfrac{x^2}{h^2}+1\right)\mathrm{d}x=\dfrac{4h}{3}
\]</span></p>
<ul>
<li>插值 <span class="math inline">\((-h,1),(0,0),(h,0)\)</span>
的抛物线 <span class="math inline">\(P(x)\)</span></li>
</ul>
<p><span class="math display">\[
\int_{-h}^{h}P(x)\mathrm{d}x=\int_{0}^{h}\left(\dfrac{1}{2h^2}x(x-h)\right)\mathrm{d}x=\dfrac{h}{3}
\]</span></p>
<h3 id="梯形法则">2.1 梯形法则</h3>
<ul>
<li><span class="math inline">\(f(x)\)</span> 是定义在 <span class="math inline">\([x_0,x_1]\)</span> 上的具有连续二阶导数的函数</li>
<li>利用通过点 <span class="math inline">\((x_0,y_0=f(x_0)),(x_1,y_1=f(x_1))\)</span>
的插值多项式进行近似</li>
<li>一阶多项式插值
<ul>
<li>拉格朗日插值多项式形式</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
f(x)&amp;=y_0\dfrac{x-x_1}{x_0-x_1}+y_1\dfrac{x-x_0}{x_1-x_0}+\dfrac{(x-x_0)(x-x_1)}{2!}f&#39;&#39;(c_x)\\
&amp;=P(x)+E(x)\\
\end{aligned}
\]</span></p>
<ul>
<li>近似积分：<span class="math inline">\(h=x_1-x_0\)</span></li>
</ul>
<p><span class="math display">\[
\int_{x_0}^{x_1}P(x)\mathrm{d}x=y_0\dfrac{h}{2}+y_1\dfrac{h}{2}
=\dfrac{(y_0+y_1)h}{2}
\]</span></p>
<p><span class="math display">\[
\int_{x_0}^{x_1}E(x)\mathrm{d}x=-\dfrac{h^3}{12}f&#39;&#39;(c)
\]</span></p>
<ul>
<li>梯形法则如下</li>
</ul>
<p><img src="/2021/11/30/computation/pyr/08-1/image-20211130180755593.png" style="zoom:80%;"></p>
<h3 id="辛普森法则">2.2 辛普森法则</h3>
<ul>
<li>和梯形法则相比，利用抛物线（二阶多项式）拟合函数，其他和梯形法则相同</li>
<li>辛普森法则</li>
</ul>
<p><img src="/2021/11/30/computation/pyr/08-1/image-20211130181009244.png" style="zoom:80%;"></p>
<ul>
<li>过程如下</li>
</ul>
<p><img src="/2021/11/30/computation/pyr/08-1/image-20211130181059370.png" style="zoom:80%;"></p>
<p><img src="/2021/11/30/computation/pyr/08-1/image-20211130181120671.png" style="zoom:80%;"></p>
<p><img src="/2021/11/30/computation/pyr/08-1/image-20211130181313198.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(E(x)\)</span> 通过泰勒展开证明</li>
</ul>
<p><img src="/2021/11/30/computation/pyr/08-1/image-20211201160437825.png" style="zoom:80%;"></p>
<p><img src="/2021/11/30/computation/pyr/08-1/image-20211201160634778.png" style="zoom:80%;"></p>
<h4 id="精度">精度</h4>
<ul>
<li>数值积分方法的<strong>精度</strong>是最大的整数 <span class="math inline">\(k\)</span>，使用该积分方法可以得到所有 <span class="math inline">\(k\)</span>
阶或者更低阶多项式积分的<strong>精确值</strong></li>
</ul>
<h5 id="误差表明精度">误差表明精度</h5>
<ul>
<li>梯形法则：<span class="math inline">\(-\dfrac{h^3}{12}f&#39;&#39;(c_x)\)</span>
<ul>
<li>精度为 <span class="math inline">\(1\)</span></li>
</ul></li>
<li>辛普森法则：<span class="math inline">\(\dfrac{h^5}{90}f^{(4)}(c)\)</span>
<ul>
<li>精度为 <span class="math inline">\(3\)</span></li>
<li>和直觉不太符合，<strong>下面一个定理能够加深理解</strong></li>
<li><strong>几何解释</strong>
<ul>
<li>抛物线和三次样条在三个等间距点上相交，并在相同区间的积分和三次样条的积分一致</li>
</ul></li>
</ul></li>
</ul>
<h5 id="辛普森法则的一个定理">辛普森法则的一个定理</h5>
<ul>
<li><span class="math inline">\(P_3(x)\)</span> 是一个三阶多项式，<span class="math inline">\(P_2(x)\)</span> 是在 <span class="math inline">\(-h,0,h\)</span> 三个点的插值多项式，那么有</li>
</ul>
<p><span class="math display">\[
\int_{-h}^{h}P_3(x)\mathrm{d}x=\int_{-h}^{h}P_2(x)\mathrm{d}x
\]</span></p>
<ul>
<li>证明：强行展开即得</li>
<li>设 <span class="math inline">\(P_3(x)\)</span> 如下</li>
</ul>
<p><span class="math display">\[
P_3(x)=ax^3+bx^2+cx+d
\]</span></p>
<ul>
<li>推导得到 <span class="math inline">\(P_2(x)\)</span> 如下</li>
</ul>
<p><span class="math display">\[
P_2(x)=(bx^2+cx+d)+(ah^2x)
\]</span></p>
<ul>
<li>积分相等（奇数次项积分为 0）</li>
</ul>
<h4 id="辛普森-38-公式">辛普森 3/8 公式</h4>
<ul>
<li>3 阶牛顿-科特斯公式</li>
</ul>
<p><span class="math display">\[
\int_{x_0}^{x_3}f(x)\mathrm{d}x\approx\dfrac{3h}{8}(y_0+3y_1+3y_2+y_3)
\]</span></p>
<ul>
<li>验证：只需要测试一系列单项式即可</li>
</ul>
<p><span class="math display">\[
1,x,x^2,x^3
\]</span></p>
<ul>
<li>例如 <span class="math inline">\(x^3\)</span></li>
</ul>
<p><span class="math display">\[
\int_{x_0}^{x_3}x^3\mathrm{d}x=\dfrac{(x_0+3h)^{4}-x_0^4}{4}=\dfrac{3h}{4}(4x_0^{3}+18hx_0^{2}+36h^{2}x_0+27h^{3})
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;\dfrac{3h}{8}(y_0+3y_1+3y_2+y_3)\\
=&amp;\dfrac{3h}{8}(x_0^3+3(x_0+h)^3+3(x_0+2h)^3+(x_0+3h)^3))\\
=&amp;\dfrac{3h}{8}(8x_0^{3}+36hx_0^{2}+72h^2x_0+54h^3)\\
=&amp;\dfrac{3h}{4}(4x_0^{3}+18hx_0^{2}+36h^{2}x_0+27h^{3})
\end{aligned}
\]</span></p>
<ul>
<li>梯形法则和辛普森法则都是 “闭合”
牛顿-科斯特公式的例子，需要对<strong>区间端点求值</strong></li>
<li>“开” 牛顿-科斯特公式对区间端点难以求值的情况很有用</li>
</ul>
<h3 id="复合牛顿-科特斯公式">2.3 复合牛顿-科特斯公式</h3>
<ul>
<li><strong>复合数值积分</strong>
<ul>
<li>积分在区间的所有子区间上具有<strong>可加性</strong></li>
<li>把整个区间变为很多小区间再计算积分，在每个小区间上使用法则，然后再求和</li>
</ul></li>
</ul>
<p><img src="/2021/11/30/computation/pyr/08-1/image-20211130233000433.png" style="zoom:80%;"></p>
<h4 id="复合梯形法则">复合梯形法则</h4>
<ul>
<li>等长划分某个区间 <span class="math inline">\([a,b]\)</span></li>
</ul>
<p><span class="math display">\[
x_i=x_{i-1}+h,h=\frac{b-a}{m}
\]</span></p>
<p><span class="math display">\[
a=x_0&lt;x_1&lt;\cdots&lt;x_{m-1}&lt;x_m=b
\]</span></p>
<ul>
<li>每个子区间使用梯形法则近似</li>
</ul>
<p><span class="math display">\[
\int_{x_{i}}^{x_{i+1}}f(x)\mathrm{d}x=\dfrac{h}{2}(f(x_{i})+f(x_{i+1}))-\dfrac{h^3}{12}f&#39;&#39;(c_i)
\]</span></p>
<ul>
<li>整个区间</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\int_{a}^{b}f(x)\mathrm{d}x
&amp;=\sum_{i=0}^{m-1}\left(\dfrac{h}{2}(f(x_{i})+f(x_{i+1}))-\dfrac{h^3}{12}f&#39;&#39;(c_i)\right)\\
&amp;=\dfrac{h}{2}\left(f(a)+f(b)+2\sum_{i=1}^{m-1}f(x_{i})\right)-\sum_{i=0}^{m-1}\dfrac{h^3}{12}f&#39;&#39;(c_i)\\
&amp;=\dfrac{h}{2}\left(f(a)+f(b)+2\sum_{i=1}^{m-1}f(x_{i})\right)-\dfrac{mh^3}{12}f&#39;&#39;(c)\\
\end{aligned}
\]</span></p>
<ul>
<li>因此复合梯形法则如下</li>
</ul>
<p><img src="/2021/11/30/computation/pyr/08-1/image-20211201094908432.png" style="zoom:80%;"></p>
<h4 id="复合辛普森法则">复合辛普森法则</h4>
<ul>
<li><span class="math inline">\([a,b]\)</span> 划分为 <span class="math inline">\(2m\)</span> 个区间</li>
</ul>
<p><span class="math display">\[
x_i=x_{i-1}+h,h=\frac{b-a}{2m}
\]</span></p>
<p><span class="math display">\[
a=x_0&lt;x_1&lt;\cdots&lt;x_{2m-1}&lt;x_{2m}=b
\]</span></p>
<ul>
<li>同理我们得到</li>
</ul>
<p><img src="/2021/11/30/computation/pyr/08-1/image-20211201095937551.png" style="zoom:80%;"></p>
<h3 id="开牛顿-科特斯方法">2.4 开牛顿-科特斯方法</h3>
<ul>
<li>适用于<strong>区间端点的函数值不容易获得</strong>的时候</li>
</ul>
<h4 id="中点法则">中点法则</h4>
<ul>
<li>函数 <span class="math inline">\(f\)</span> 的二阶导 <span class="math inline">\(f&#39;&#39;(x)\)</span> 在区间 <span class="math inline">\([a,b]\)</span> 上连续</li>
</ul>
<p><span class="math display">\[
\int_{x_0}^{x_1}f(x)\mathrm{d}x=hf(w)+\frac{h^3}{24}f&#39;&#39;(c)
\]</span></p>
<p><span class="math display">\[
h=x_1-x_0,w=x_0+\dfrac{h}{2}
\]</span></p>
<ul>
<li>证明：在区间中点进行一阶泰勒展开</li>
</ul>
<p><img src="/2021/11/30/computation/pyr/08-1/image-20211201101904409.png" style="zoom:80%;"></p>
<ul>
<li>中点法则相较于梯形法则而言
<ul>
<li><strong>函数计算次数变为一半</strong></li>
<li><strong>误差界变为一半</strong></li>
</ul></li>
</ul>
<h4 id="复合中点法则">复合中点法则</h4>
<p><img src="/2021/11/30/computation/pyr/08-1/image-20211201102140837.png" style="zoom:80%;"></p>
<h4 id="阶精度">3 阶精度</h4>
<p><img src="/2021/11/30/computation/pyr/08-1/image-20211201102321004.png" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.08.数值微分与积分(3)</title>
    <url>/2021/12/01/computation/pyr/08-2/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 5 章（数值微分与积分） +
PPT（数值微分与积分方法）</li>
</ul>
<h1 id="数值微分与积分方法">数值微分与积分方法</h1>
<h2 id="龙贝格积分">3. 龙贝格积分</h2>
<ul>
<li>为了提高求定积分的精度，我们可以通过<strong>添加数据</strong>进行扩展</li>
<li><strong>龙贝格积分是对复合梯形法则应用外推的结果</strong>
<ul>
<li><strong>理查德森外推</strong></li>
</ul></li>
<li>梯形法则的特殊性，误差没有奇数阶的导数，一次利用外推能够<strong>提高两阶精度</strong>
<ul>
<li>抵消了</li>
</ul></li>
<li>梯形法则误差</li>
</ul>
<p><span class="math display">\[
\int_{a}^{b}f(x)\mathrm{d}x
=\dfrac{h}{2}\left(y_0+y_m+2\sum_{i=1}^{m-1}y_{i}\right)+c_2h^2+c_4h^4+\cdots\\
\]</span></p>
<h3 id="描述">描述</h3>
<ul>
<li>需要近似的积分：<span class="math inline">\(M=\int_{a}^{b}f(x)\mathrm{d}x\)</span></li>
<li>近似公式 <span class="math inline">\(R_{j,1}\)</span> 表示使用步长为
<span class="math inline">\(h_j\)</span> 的复合梯形法则，<span class="math inline">\(h_j\)</span> 定义如下</li>
</ul>
<p><span class="math display">\[
h_j=\dfrac{b-a}{2^{j-1}}
\]</span></p>
<h3 id="梯形法则">梯形法则</h3>
<ul>
<li>给出复合梯形法则的递推形式</li>
<li>原始梯形法则</li>
</ul>
<p><span class="math display">\[
R_{1,1}=\dfrac{h_1}{2}(f(a)+f(b))
\]</span></p>
<ul>
<li>区间分为等长两段，使用<strong>复合梯形法则</strong></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
R_{2,1}
&amp;=\dfrac{h_2}{2}\left(f(a)+f(b)+2f(\dfrac{a+b}{2})\right)\\
&amp;=\dfrac{1}{2}R_{1,1}+h_2f(\dfrac{a+b}{2})
\end{aligned}
\]</span></p>
<ul>
<li>归纳证明</li>
</ul>
<p><span class="math display">\[
R_{j,1}=\dfrac{1}{2}R_{j-1,1}+h_j\sum_{i=1}^{2^{j-2}}f(a+(2i-1)h_j)
\]</span></p>
<h4 id="证明">证明</h4>
<ul>
<li>将两个小区间合并为一个大区间</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
R_{j+1,1}
&amp;=\dfrac{1}{2}h_{j+1}\sum_{i=1}^{2^{j}}\left(f(a+(i-1)h_{j+1})+f(a+ih_{j+1})\right)\\
&amp;=\dfrac{1}{4}h_{j}\left(
\sum_{i=1}^{2^{j-1}}\left(f(a+2(i-1)h_{j+1})+f(a+2ih_{j+1})+2f(a+(2i-1)h_{j+1})\right)
\right)\\
&amp;=\dfrac{1}{4}h_{j}\left(
\sum_{i=1}^{2^{j-1}}\left(f(a+(i-1)h_{j})+f(a+ih_{j})+2f(a+(2i-1)h_{j+1})\right)
\right)\\
&amp;=\dfrac{1}{2}R_{j,1}
+\dfrac{1}{4}h_{j}\left(
\sum_{i=1}^{2^{j-1}}\left(2f(a+(2i-1)h_{j+1})\right)
\right)\\
&amp;=\dfrac{1}{2}R_{j,1}
+h_{j+1}\left(
\sum_{i=1}^{2^{j-1}}\left(f(a+(2i-1)h_{j+1})\right)
\right)\\
\end{aligned}
\]</span></p>
<h3 id="外推">外推</h3>
<ul>
<li>第 2 列是第 1 列的外推</li>
<li>第 3 列是第 2 列的外推</li>
<li><strong><span class="math inline">\(R_{i,j}\)</span> 是对 <span class="math inline">\(R_{i-1,j-1}\)</span> 外推的结果</strong></li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-2/image-20211201130103933.png" style="zoom:80%;"></p>
<ul>
<li>根据理查德森外推的形式</li>
</ul>
<p><span class="math display">\[
Q\approx\dfrac{2^{n}F(h/2)-F(h)}{2^n-1}\\
\]</span></p>
<ul>
<li>梯形法则精度是 1，是 2 阶近似</li>
</ul>
<p><span class="math display">\[
R_{2,2}=\dfrac{2^2R_{2,1}-R_{1,1}}{2^2-1}=\dfrac{4^1R_{2,1}-R_{1,1}}{4^1-1}
\]</span></p>
<p><span class="math display">\[
R_{3,3}=\dfrac{2^4R_{3,2}-R_{2,2}}{2^4-1}=\dfrac{4^2R_{2,1}-R_{1,1}}{4^2-1}\\
\]</span></p>
<ul>
<li>一般化</li>
</ul>
<p><span class="math display">\[
R_{j,k}=\dfrac{4^{k-1}R_{j,k-1}-R_{j-1,k-1}}{4^{k-1}-1}
\]</span></p>
<ul>
<li><strong>外推结果 <span class="math inline">\(R_{j,2}\)</span>
是辛普森法则</strong>
<ul>
<li>精度为 3，是 4 阶近似</li>
<li>可以看看 <span class="math inline">\(R_{2,2}\)</span>
既是辛普森法则，也是 <span class="math inline">\(R_{1,1}\)</span>
外推的结果</li>
</ul></li>
<li>最佳近似 <span class="math inline">\(R_{j,j}\)</span>
<ul>
<li>何时停止，<span class="math inline">\(R_{j,j}\)</span> 和 <span class="math inline">\(R_{j-1,j-1}\)</span> 的差距小于指定值</li>
</ul></li>
</ul>
<h3 id="算法">算法</h3>
<p><img src="/2021/12/01/computation/pyr/08-2/image-20211201131741534.png" style="zoom:80%;"></p>
<h2 id="自适应积分">4. 自适应积分</h2>
<ul>
<li>固定步长的问题
<ul>
<li>小步长对应更小的截断误差，对于给定容差我们可以通过误差公式确定步长
<span class="math inline">\(h\)</span>
<ul>
<li>但是公式中可能包含高阶导数，高阶导数可能无法计算，导致无法确定步长</li>
</ul></li>
<li>函数变化有的地方很缓，不需要很高的精度，有些地方变化陡，需要较高的精度
<ul>
<li>不同地方精度需求不一致</li>
</ul></li>
</ul></li>
<li><strong>自适应步长</strong></li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-2/image-20211201132744786.png" style="zoom:80%;"></p>
<h3 id="思路">思路</h3>
<ul>
<li>我们对当前区间使用梯形法则近似，然后进一步缩短步长，使用两个梯形近似</li>
<li>计算这两次计算的误差之差，判断是否可以接受</li>
<li>如果可以接受，则结束；如果不能接受，则进一步细分</li>
</ul>
<h3 id="推导">推导</h3>
<ul>
<li>3倍标准</li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-2/image-20211201133145294.png" style="zoom:80%;"></p>
<ul>
<li>定理 5.1：<strong>加权中值</strong></li>
</ul>
<h3 id="算法-1">算法</h3>
<p><img src="/2021/12/01/computation/pyr/08-2/image-20211201133041970.png" style="zoom:80%;"></p>
<h3 id="高阶自适应积分">高阶自适应积分</h3>
<ul>
<li>辛普森法则替换梯形法则</li>
<li>15 倍误差</li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-2/image-20211201134013850.png" style="zoom:80%;"></p>
<h2 id="高斯积分">5. 高斯积分</h2>
<ul>
<li><span class="math inline">\(n\)</span> 阶的牛顿-科特斯公式的精度为
<span class="math inline">\(n\)</span>（<span class="math inline">\(n\)</span> 为奇数）和 <span class="math inline">\(n+1\)</span>（<span class="math inline">\(n\)</span> 为偶数）
<ul>
<li>但是这是均匀分布节点的情况下</li>
</ul></li>
<li>调整节点的位置，用于提高精度</li>
<li>高斯积分精度：<span class="math inline">\(2n+1\)</span></li>
</ul>
<h3 id="正交多项式">正交多项式</h3>
<ul>
<li><p><span class="math inline">\(\int_{a}^{b}p_{i}(x)p_{j}(x)\mathrm{d}x\)</span></p></li>
<li><p><strong>多项式基</strong></p>
<ul>
<li>正交 <span class="math inline">\(\to\)</span>
<strong>线性无关</strong></li>
</ul></li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-2/image-20211201140424043.png" style="zoom:80%;"></p>
<ul>
<li><strong>多项式正交集合根定理</strong></li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-2/image-20211201140655432.png" style="zoom:80%;"></p>
<h3 id="勒让德多项式">勒让德多项式</h3>
<p><span class="math display">\[
p_i(x)=\dfrac{1}{2^{i}i!}\dfrac{\mathrm{d}^{i}}{\mathrm{d}x^{i}}[(x^{2}-1)^{i}]
\]</span></p>
<ul>
<li><span class="math inline">\(p_{i}(x),0\le i\le n\)</span> 在区间
<span class="math inline">\([-1,1]\)</span> 上正交</li>
<li>证明：<strong>暴算</strong></li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-2/image-20211201141121376.png" style="zoom:80%;"></p>
<h3 id="高斯积分-1">高斯积分</h3>
<ul>
<li>高斯积分把节点放置在勒让德多项式的根的位置上</li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-2/image-20211201141914338.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(L_i(x)\)</span>
是<strong>拉格朗日插值多项式</strong></li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-2/image-20211201145224192.png" style="zoom:80%;"></p>
<h3 id="高斯积分的精度">高斯积分的精度</h3>
<ul>
<li><span class="math inline">\(2n-1\)</span></li>
</ul>
<h4 id="证明-1">证明</h4>
<ul>
<li>高斯积分的函数记作 <span class="math inline">\(f(x)\)</span></li>
<li>设 <span class="math inline">\(P(x)\)</span> 为至多 <span class="math inline">\(2n-1\)</span>
阶的多项式，那么使用多项式长除法表示</li>
</ul>
<p><span class="math display">\[
P(x)=S(x)p_n(x)+R(x)
\]</span></p>
<ul>
<li><span class="math inline">\(p_n(x)\)</span> 为 <span class="math inline">\(n\)</span> 阶<strong>勒让德多项式</strong>，<span class="math inline">\(S(x)\)</span> 和 <span class="math inline">\(R(x)\)</span> 均为小于 <span class="math inline">\(n\)</span> 阶的多项式</li>
<li>设插值点为 <span class="math inline">\(x_i(1\le i\le
n)\)</span>，那么有 <span class="math inline">\(p_n(x_i)=0\)</span></li>
<li><span class="math inline">\(P(x_i)=S(x_i)p_n(x_i)+R(x_i)=R(x_i)\)</span></li>
<li>因此高斯积分的插值多项式插值了 <span class="math inline">\(R(x)\)</span>
<ul>
<li><strong>其实 <span class="math inline">\(f(x)\)</span> 就是 <span class="math inline">\(R(x)\)</span></strong></li>
</ul></li>
</ul>
<p><span class="math display">\[
\int_{-1}^{1}f(x)\mathrm{d}x=\int_{-1}^{1}R(x)\mathrm{d}x
\]</span></p>
<ul>
<li><span class="math inline">\(S(x)\)</span> 可以表示为 <span class="math inline">\(n-1\)</span>
阶勒让德多项式集合的线性组合，由正交性</li>
</ul>
<p><span class="math display">\[
\int_{-1}^{1}S(x)p_n(x)\mathrm{d}x=0
\]</span></p>
<ul>
<li>那么</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\int_{-1}^{1}P(x)\mathrm{d}x
&amp;=\int_{-1}^{1}S(x)p_n(x)\mathrm{d}x+\int_{-1}^{1}R(x)\mathrm{d}x\\
&amp;=\int_{-1}^{1}R(x)\mathrm{d}x\\
&amp;=\int_{-1}^{1}f(x)\mathrm{d}x
\end{aligned}
\]</span></p>
<h3 id="区间变换">区间变换</h3>
<ul>
<li>一般问题积分区间为 <span class="math inline">\([a,b]\)</span>，需要变换到 <span class="math inline">\([-1,1]\)</span></li>
</ul>
<p><span class="math display">\[
\int_{a}^{b}f(x)\mathrm{d}x=\int_{-1}^{1}f(\dfrac{(b-a)t+b+a}{2})\dfrac{b-a}{2}\mathrm{d}t
\]</span></p>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.08.数值微分与积分</title>
    <url>/2021/11/30/computation/pyr/08/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 5 章（数值微分与积分） +
PPT（数值微分与积分方法）</li>
</ul>
<h1 id="数值微分与积分方法">数值微分与积分方法</h1>
<ul>
<li>如何计算函数的微分和积分？
<ul>
<li><strong>符号计算</strong>、<strong>数值计算</strong></li>
</ul></li>
<li>如果函数是初等函数，则可以通过符号计算的到结果</li>
<li>如果函数表现为采集到的离散点，只能通过数值计算的方法
<ul>
<li>无法显式表达为初等函数</li>
</ul></li>
</ul>
<h2 id="数值微分">1. 数值微分</h2>
<h3 id="有限差分公式">1.1 有限差分公式</h3>
<ul>
<li>如果极限存在，则导数定义如下</li>
</ul>
<p><span class="math display">\[
f&#39;(x)=\lim_{h\to0}\dfrac{f(x+h)-f(x)}{h}
\]</span></p>
<ul>
<li>利用泰勒展开进行近似</li>
</ul>
<h4 id="二点前向差分公式">二点前向差分公式</h4>
<ul>
<li>泰勒展开一阶形式</li>
</ul>
<p><span class="math display">\[
f(x+h)=f(x)+hf&#39;(x)+\dfrac{h^2}{2}f&#39;&#39;(c),\quad
c\in[x,x+h]
\]</span></p>
<ul>
<li>二点前向差分公式</li>
</ul>
<p><span class="math display">\[
f&#39;(x)=\dfrac{f(x+h)-f(x)}{h}-\dfrac{h}{2}f&#39;&#39;(c),\quad
c\in[x,x+h]
\]</span></p>
<ul>
<li>近似公式，舍去部分作为<strong>截断误差</strong></li>
</ul>
<p><span class="math display">\[
f&#39;(x)\approx\dfrac{f(x+h)-f(x)}{h}
\]</span></p>
<ul>
<li>截断误差 <span class="math inline">\(O(h)\)</span>
<ul>
<li>可以通过<strong>缩短步长 <span class="math inline">\(h\)</span></strong>
来<strong>减小误差</strong></li>
<li>一阶近似</li>
</ul></li>
<li>截断误差 <span class="math inline">\(O(h^n)\)</span>：<span class="math inline">\(n\)</span> 阶近似</li>
</ul>
<h4 id="三点中心差分公式">三点中心差分公式</h4>
<ul>
<li>泰勒展开二阶形式</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
f(x+h)=f(x)+hf&#39;(x)+\dfrac{h^2}{2}f&#39;&#39;(x)+\dfrac{h^3}{6}f^{(3)}(c_1),\quad
c_1\in[x,x+h]\\
f(x-h)=f(x)-hf&#39;(x)+\dfrac{h^2}{2}f&#39;&#39;(x)-\dfrac{h^3}{6}f^{(3)}(c_2),\quad
c_2\in[x,x+h]
\end{aligned}
\]</span></p>
<ul>
<li>近似公式</li>
</ul>
<p><span class="math display">\[
f&#39;(x)=\dfrac{f(x+h)-f(x-h)}{2h}-\dfrac{h^2}{12}\left(f^{(3)}(c_1)+f^{(3)}(c_2)\right)
\]</span></p>
<ul>
<li>根据推广中值定理</li>
</ul>
<p><img src="/2021/11/30/computation/pyr/08/image-20211130142851163.png" style="zoom:80%;"></p>
<ul>
<li>近似公式进一步可以写作</li>
</ul>
<p><span class="math display">\[
f&#39;(x)=\dfrac{f(x+h)-f(x-h)}{2h}-\dfrac{h^2}{6}f^{(3)}(c),
\quad c\in[x-h,x+h]
\]</span></p>
<ul>
<li>上述式子被称为<strong>三点中心差分公式</strong></li>
</ul>
<h4 id="二阶导数的三点中心差分形式">二阶导数的三点中心差分形式</h4>
<ul>
<li>高阶导数的差分形式也可以通过类似方法获得</li>
<li>泰勒展开的三阶形式</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
f(x+h)=f(x)+hf&#39;(x)+\dfrac{h^2}{2}f&#39;&#39;(x)+\dfrac{h^3}{6}f^{(3)}(x)+\dfrac{h^{4}}{24}f^{(4)}(c_1),\quad
c_1\in[x,x+h]\\
f(x-h)=f(x)-hf&#39;(x)+\dfrac{h^2}{2}f&#39;&#39;(x)-\dfrac{h^3}{6}f^{(3)}(x)+\dfrac{h^{4}}{24}f^{(4)}(c_2),\quad
c_2\in[x,x+h]
\end{aligned}
\]</span></p>
<ul>
<li><strong>二阶导数的三点中心差分形式</strong></li>
</ul>
<p><span class="math display">\[
f&#39;&#39;(x)=\dfrac{f(x+h)+f(x-h)-2f(x)}{h^2}-\dfrac{h^2}{12}f^{(4)}(c),\quad
c\in[c-h,c+h]
\]</span></p>
<h3 id="舍入误差">1.2 舍入误差</h3>
<ul>
<li><span class="math inline">\(h\)</span>
越小，截断误差越小，但是同时会引入更大的<strong>舍入误差</strong>
<ul>
<li><strong>机器精度</strong>的原因</li>
<li>两个相近的数相减会导致有效数字丢失、除以一个小数会放大误差</li>
</ul></li>
</ul>
<h4 id="误差分析">误差分析</h4>
<ul>
<li>将 <span class="math inline">\(f(x+h)\)</span> 的浮点输入记作 <span class="math inline">\(\hat{f}(x+h)\)</span>，误差近似和<strong>机器误差</strong>相等</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
\hat{f}(x+h)=f(x+h)+\epsilon_1\\
\hat{f}(x-h)=f(x-h)+\epsilon_2\\
\vert\epsilon_1\vert,\vert\epsilon_2\vert\approx\vert\epsilon_{\mathrm{mach}}\vert
\end{array}
\]</span></p>
<ul>
<li>三点中心差分</li>
</ul>
<p><img src="/2021/11/30/computation/pyr/08/image-20211130151726985.png" style="zoom:80%;"></p>
<ul>
<li>两部分误差：截断误差 + 舍入误差</li>
<li>舍入误差</li>
</ul>
<p><span class="math display">\[
\left\vert\dfrac{\epsilon_2-\epsilon_1}{2h}\right\vert\le
\dfrac{\epsilon_{\mathrm{mach}}}{h}
\]</span></p>
<ul>
<li>整体误差</li>
</ul>
<p><span class="math display">\[
E(h)=\dfrac{h^2}{6}f^{(3)}(c)+\dfrac{\epsilon_{\mathrm{mach}}}{h}
\]</span></p>
<ul>
<li>给出最恰当的步长 <span class="math inline">\(h\)</span>，<span class="math inline">\(E&#39;(h)=0\)</span>
<ul>
<li><span class="math inline">\(M=f^{(3)}(c)\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
h=\sqrt[3]{\dfrac{3\epsilon_{\mathrm{mach}}}{M}}
\]</span></p>
<ul>
<li>可以分析得到步长和误差的关系</li>
</ul>
<h3 id="外推">1.3 外推</h3>
<ul>
<li><span class="math inline">\(n\)</span> 阶公式 <span class="math inline">\(F(h)\)</span> 近似一个给定量 <span class="math inline">\(Q\)</span>，<span class="math inline">\(n\)</span>
阶含义如下</li>
</ul>
<p><span class="math display">\[
Q\approx F(h)+Kh^n
\]</span></p>
<ul>
<li>例如上面的三点公式</li>
<li>可以通过代数变换的到更高阶的外推
<ul>
<li><strong>理查德森外推</strong></li>
</ul></li>
</ul>
<p><span class="math display">\[
Q-F(\dfrac{h}{2})\approx K\dfrac{h^n}{2^{n}}\approx\dfrac{Q-F(h)}{2^n{}}
\]</span></p>
<p><span class="math display">\[
Q\approx\dfrac{2^{n}F(h/2)-F(h)}{2^n-1}
\]</span></p>
<ul>
<li>上述式子给出对 <span class="math inline">\(Q\)</span>
更高阶的近似</li>
</ul>
<p><img src="/2021/11/30/computation/pyr/08/image-20211130154538957.png" style="zoom:80%;"></p>
<ul>
<li>应用理查德森外推公式，我们可以得到二阶中心差分的更高阶近似</li>
</ul>
<p><img src="/2021/11/30/computation/pyr/08/image-20211130154805445.png" style="zoom:80%;"></p>
<ul>
<li>这也被称为是<strong>五点中心差分公式</strong>
<ul>
<li>上面的讨论论证了这至少是<strong>三阶</strong>的公式</li>
<li>实际上是<strong>四阶</strong>的公式
<ul>
<li>消去了三阶误差项</li>
<li>将 <span class="math inline">\(f(x+h)\)</span>
展开来为<strong>四阶形式</strong>，推导即证</li>
</ul></li>
</ul></li>
<li>二阶导数的三点中心差分形式</li>
</ul>
<p><img src="/2021/11/30/computation/pyr/08/image-20211130155658306.png" style="zoom:80%;"></p>
<ul>
<li>证明</li>
</ul>
<p><span class="math display">\[
f&#39;&#39;(x)=\dfrac{f(x+h)+f(x-h)-2f(x)}{h^2}-\dfrac{h^2}{12}f^{(4)}(x)-\dfrac{h^4}{360}f^{(6)}(c)
\]</span></p>
<p><span class="math display">\[
E_2(x)=\dfrac{h^2}{12}f^{(4)}(x)+\dfrac{h^4}{360}f^{(6)}(c)
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
E_4(x)
&amp;=\dfrac{
4\left(\dfrac{h^2}{12\times2^2}f^{(4)}(x)+\dfrac{h^4}{360\times2^4}f^{(6)}(c_1)\right)
-
\left(\dfrac{h^2}{12}f^{(4)}(x)+\dfrac{h^4}{360}f^{(6)}(c_2)\right)
}{3}\\
&amp;=\dfrac{
4\left(\dfrac{h^4}{360\times2^4}f^{(6)}(c_1)\right)
-
\left(\dfrac{h^4}{360}f^{(6)}(c_2)\right)
}{3}\\
&amp;\approx O(h^4)
\end{aligned}
\]</span></p>
<h3 id="符号微分与积分">1.4 符号微分与积分</h3>
<ul>
<li>Matlab 中集成了这个功能</li>
</ul>
<p><img src="/2021/11/30/computation/pyr/08/image-20211130162555214.png" style="zoom:80%;"></p>
<ul>
<li>好强，牛逼</li>
</ul>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.08.数值微分与积分(4)</title>
    <url>/2021/12/01/computation/pyr/08-3/</url>
    <content><![CDATA[<ul>
<li>PPT（数值微分与积分方法）</li>
</ul>
<h1 id="数值微分与积分方法">数值微分与积分方法</h1>
<h2 id="数值微分">1. 数值微分</h2>
<h3 id="插值多项式">插值多项式</h3>
<ul>
<li>思想：利用<strong>拉格朗日插值多项式</strong>计算函数导数
<ul>
<li>多项式的导数函数依然是多项式
<ul>
<li>计算简单</li>
</ul></li>
<li>截断误差构成导数计算的误差
<ul>
<li>方便估计误差</li>
</ul></li>
</ul></li>
<li><span class="math inline">\(n+1\)</span> 点插值多项式</li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201150550339.png" style="zoom:80%;"></p>
<ul>
<li></li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201150708495.png" style="zoom:80%;"></p>
<h3 id="前向差分公式">前向差分公式</h3>
<ul>
<li>利用泰勒展开的多项式进行近似，忽略高阶项（<strong>截断误差</strong>）</li>
</ul>
<p><span class="math display">\[
f&#39;(x)=\dfrac{f(x+h)-f(x)}{h}-\dfrac{h}{2}f&#39;&#39;(c),\quad
c\in[x,x+h]
\]</span></p>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201151405262.png" style="zoom: 80%;"></p>
<ul>
<li>截断误差：<span class="math inline">\(\dfrac{h}{2}f&#39;&#39;(c)\)</span></li>
<li>舍入误差：<span class="math inline">\(\dfrac{2\epsilon}{h}\)</span></li>
</ul>
<h3 id="三点公式">三点公式</h3>
<ul>
<li>二阶拉格朗日多项式</li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201151927923.png" style="zoom:80%;"></p>
<h4 id="等间距取点">等间距取点</h4>
<p><span class="math display">\[
x_2=x_1+h=x_0+2h
\]</span></p>
<ul>
<li><span class="math inline">\(x_j=x_0\)</span></li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201152203027.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(x_j=x_1\)</span>（<strong>三点中心差分</strong>）</li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201152237687.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(x_j=x_2\)</span></li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201153829649.png" style="zoom:80%;"></p>
<h3 id="舍入误差与截断误差">舍入误差与截断误差</h3>
<ul>
<li>步长设置</li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201154130454.png" style="zoom:80%;"></p>
<h3 id="五点公式">五点公式</h3>
<ul>
<li>可以利用三点公式外推得到</li>
<li>也可以利用泰勒展开得到</li>
<li>泰勒展开
<ul>
<li>先消去偶数次高阶导</li>
<li>再消去 3 阶导（<span class="math inline">\(h\to2h\)</span>）</li>
</ul></li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201154257743.png" style="zoom:80%;"></p>
<ul>
<li>五点公式</li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201154346788.png" style="zoom:80%;"></p>
<h3 id="高阶导数计算">高阶导数计算</h3>
<ul>
<li>泰勒展开</li>
</ul>
<p><span class="math display">\[
f&#39;&#39;(x)=\dfrac{f(x+h)+f(x-h)-2f(x)}{h^2}-\dfrac{h^2}{12}f^{(4)}(c),\quad
c\in[c-h,c+h]
\]</span></p>
<h3 id="richardson-外推">Richardson 外推</h3>
<ul>
<li>（理查德森）外推</li>
<li><strong>使用低阶公式生成高阶公式</strong></li>
<li>思路：消去误差最低阶的项</li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201155559055.png" alt="image-20211201155559055" style="zoom:80%;"></p>
<ul>
<li>可以进一步外推</li>
</ul>
<h2 id="数值积分">2. 数值积分</h2>
<ul>
<li>思路与之前一致
<ul>
<li>利用拉格朗日插值多项式计算函数积分
<ul>
<li>多项式的积分函数依然是多项式</li>
<li>多项式截断误差构成积分计算的截断误差</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201155800451.png" style="zoom:80%;"></p>
<h3 id="梯形法则">梯形法则</h3>
<ul>
<li>一阶多项式插值</li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201160111282.png" style="zoom:80%;"></p>
<h3 id="simpson-法则">Simpson 法则</h3>
<ul>
<li>二阶多项式插值</li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201160141279.png" style="zoom:80%;"></p>
<h3 id="newton-cotes-系数">Newton-Cotes 系数</h3>
<ul>
<li>就是从拉格朗日插值多项式推导</li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201160841971.png" style="zoom:80%;"></p>
<h3 id="代数精度">代数精度</h3>
<ul>
<li>闭合牛顿-科特斯的代数精度<strong>定理</strong></li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201161130238.png" style="zoom:80%;"></p>
<h3 id="复合数值积分">复合数值积分</h3>
<ul>
<li>复合梯形、复合辛普森</li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201161458935.png" style="zoom:80%;"></p>
<h4 id="复合梯形">复合梯形</h4>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201161615564.png" style="zoom:80%;"></p>
<ul>
<li>舍入误差：<span class="math inline">\((b-a)\epsilon\)</span></li>
</ul>
<h4 id="复合辛普森">复合辛普森</h4>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201161553794.png" style="zoom:80%;"></p>
<ul>
<li>舍入误差：<span class="math inline">\((b-a)\epsilon\)</span></li>
</ul>
<h4 id="复合中点">复合中点</h4>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201161719276.png" style="zoom:80%;"></p>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201162143860.png" style="zoom:80%;"></p>
<ul>
<li>舍入误差：<span class="math inline">\((b-a)\epsilon\)</span></li>
</ul>
<h2 id="romberg-积分">3. Romberg 积分</h2>
<ul>
<li>龙贝格积分</li>
<li>复合梯形法则 + 理查德森外推</li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201162409346.png" style="zoom:80%;"></p>
<h2 id="自适应积分">4. 自适应积分</h2>
<ul>
<li>动态步长</li>
</ul>
<h2 id="高斯积分">5. 高斯积分</h2>
<ul>
<li>将<strong>均匀的节点放置</strong>修改为<strong>勒让德多项式的根</strong>的位置</li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201162605532.png" style="zoom:80%;"></p>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201162613209.png" style="zoom:80%;"></p>
<ul>
<li>代数精度：<span class="math inline">\(2n-1\)</span></li>
<li>待定系数法找到节点放置位置</li>
</ul>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201162818556.png" style="zoom:80%;"></p>
<h3 id="勒让德多项式定理">勒让德多项式定理</h3>
<p><img src="/2021/12/01/computation/pyr/08-3/image-20211201162908117.png" style="zoom:80%;"></p>
<h4 id="证明">证明</h4>
<ul>
<li>分类：<span class="math inline">\(p(x)\)</span> 阶数</li>
<li><span class="math inline">\(\deg(p)&lt;n\)</span>
<ul>
<li>插值，直接成立，代入相等</li>
</ul></li>
<li><span class="math inline">\(n\le\deg(p)\le2n\)</span>
<ul>
<li>长除法</li>
</ul></li>
</ul>
<p><span class="math display">\[
p(x)=Q(x)P_n(x)+R(x)
\]</span></p>
<p><span class="math display">\[
\int_{-1}^{1}p(x)\mathrm{d}x=\int_{-1}^{1}R(x)\mathrm{d}x=\sum_{i=1}^{n}c_iR(x_i)=\sum_{i=1}^{n}c_ip(x_i)
\]</span></p>
<h3 id="区间变换">区间变换</h3>
<ul>
<li><span class="math inline">\([a,b]\to[-1,1]\)</span></li>
</ul>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.09.常微分方程(2)</title>
    <url>/2021/12/28/computation/pyr/09-1/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 6 章（常微分方程） + PPT（常微分方程）</li>
</ul>
<h1 id="常微分方程">常微分方程</h1>
<h2 id="常微分方程组">3. 常微分方程组</h2>
<ul>
<li>两个物理系统：<strong>钟摆</strong>、<strong>轨道力学</strong>
<ul>
<li>对于这两个系统的仿真促使了大量 ODE 求解器的开发</li>
</ul></li>
<li>微分方程的阶：出现在方程中最高阶的导数</li>
<li>初值问题中，每一个变量都需要有他自己的初值</li>
<li>一个二元微分方程组的欧拉方法求解
<ul>
<li>确定两个变量的步长（可以都为 <span class="math inline">\(h\)</span>）</li>
<li>根据 <span class="math inline">\(w_{i,1},w_{i,2}\)</span>
通过和之前一样的欧拉方法求解 <span class="math inline">\(w_{i+1,1},w_{i+1,2}\)</span></li>
</ul></li>
</ul>
<h3 id="高阶方程">3.1 高阶方程</h3>
<ul>
<li><strong>单个的高阶微分方程可以转化为一个方程组</strong></li>
<li>原始高阶方程</li>
</ul>
<p><span class="math display">\[
y^{(n)}=f(t,y,y&#39;,\cdots,y^{(n-1)})
\]</span></p>
<ul>
<li>重新定义变量</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
y_1&amp;=y\\
y_2&amp;=y&#39;\\
&amp;\cdots\\
y_n&amp;=y^{(n-1)}\\
\end{aligned}
\]</span></p>
<ul>
<li>此时原始的常微分方程转化为 <span class="math inline">\(1\)</span>
阶</li>
</ul>
<p><span class="math display">\[
y^{(n)}=f(t,y_1,y_2,\cdots,y_n)
\]</span></p>
<ul>
<li>此时可以使用之前的方法求解
<ul>
<li>欧拉方法、显式梯形方法等</li>
</ul></li>
<li>由于可以将<strong>高阶方程</strong>转化为<strong>一阶方程组</strong>，我们将仅仅关注一阶方程组</li>
<li>同时<strong>高阶方程组</strong>也可以相同的方式转化为<strong>一阶方程组</strong></li>
</ul>
<h3 id="计算机仿真钟摆">3.2 计算机仿真：钟摆</h3>
<p><img src="/2021/12/28/computation/pyr/09-1/image-20211228113327116.png" style="zoom:80%;"></p>
<h4 id="无衰减钟摆">无衰减钟摆</h4>
<ul>
<li>无摩擦的运动方程</li>
</ul>
<p><span class="math display">\[
mly&#39;&#39;=F=-mg\sin{y}
\]</span></p>
<ul>
<li>化简得到</li>
</ul>
<p><span class="math display">\[
y&#39;&#39;=-\dfrac{g}{l}\sin{y}
\]</span></p>
<ul>
<li>初始条件：初始角度 <span class="math inline">\(y(0)\)</span>，初始角速度 <span class="math inline">\(y&#39;(0)\)</span></li>
<li>转化为一阶方程组：<span class="math inline">\(y_1=y,y_2=y&#39;\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
y_1&#39;&amp;=y_2\\
y_2&#39;&amp;=-\dfrac{g}{l}\sin{y_1}\\
\end{aligned}
\]</span></p>
<ul>
<li>书中有 matlab 仿真的动画代码
<ul>
<li><span class="math inline">\(g=9.81\)</span></li>
</ul></li>
<li><strong>欧拉方法效果不佳</strong>，显式梯形方法就相对不错</li>
</ul>
<h4 id="衰减钟摆">衰减钟摆</h4>
<p><span class="math display">\[
\begin{aligned}
y_1&#39;&amp;=y_2\\
y_2&#39;&amp;=-\dfrac{g}{l}\sin{y_1}-dy_2\\
\end{aligned}
\]</span></p>
<ul>
<li>衰减系数 <span class="math inline">\(d&gt;0\)</span>，最终稳定于
<span class="math inline">\(y_1=y_2=0\)</span></li>
</ul>
<h4 id="受力衰减钟摆">受力衰减钟摆</h4>
<p><span class="math display">\[
\begin{aligned}
y_1&#39;&amp;=y_2\\
y_2&#39;&amp;=-\dfrac{g}{l}\sin{y_1}-dy_2+A\sin{t}\\
\end{aligned}
\]</span></p>
<ul>
<li>当添加力后，大量的动态行为都变成可能</li>
<li>对于微分方程的<strong>二维自治系统</strong>（右边与 <span class="math inline">\(t\)</span> 无关），Poincare-Bendixson
定理（来自微分方程理论）指出轨迹都将趋向于<strong>规律运动</strong>
<ul>
<li>钟摆最下位置的稳定平衡</li>
<li>像钟摆永远来回摆动的稳定周期循环
<ul>
<li><span class="math inline">\(d=1,A=10\)</span></li>
</ul></li>
</ul></li>
<li>附加的力使得系统非自治（可重写为三维的自治系统，但不是二维的自治系统），因而允许第三种类型的轨迹，即<strong>混乱轨迹</strong>
<ul>
<li><span class="math inline">\(d=1,A=15\)</span></li>
</ul></li>
</ul>
<h4 id="双钟摆">双钟摆</h4>
<ul>
<li>双钟摆由两个简单钟摆组成，其中一个钟摆挂在另外一个钟摆上</li>
<li>如果 <span class="math inline">\(y_1\)</span> 和 <span class="math inline">\(y_3\)</span>
是两个钟摆相对于垂直方向的角度，微分方程系统如下</li>
</ul>
<p><img src="/2021/12/28/computation/pyr/09-1/image-20211228115628604.png"></p>
<ul>
<li><span class="math inline">\(l_1=l_2=1\)</span></li>
<li><span class="math inline">\(d\)</span>​ 表示旋转轴的摩擦</li>
<li><span class="math inline">\(d=0\)</span>
时，对于许多初始条件，双钟摆都表现为<strong>持续的非周期运动</strong></li>
</ul>
<h3 id="计算机仿真轨道力学">3.3 计算机仿真：轨道力学</h3>
<ul>
<li>万有引力</li>
</ul>
<p><span class="math display">\[
F=\dfrac{gm_1m_2}{r^2}
\]</span></p>
<h4 id="单体问题">单体问题</h4>
<ul>
<li>在<strong>单体问题</strong>中，一个物体相对于另外一个物体的作用力被认为可忽略（<strong>一种简化</strong>）
<ul>
<li>小卫星绕着大行星转动的情况下，我们可以忽略卫星对于行星的力，因而行星可认为是固定的</li>
</ul></li>
</ul>
<h5 id="模拟">模拟</h5>
<ul>
<li>大物体：<span class="math inline">\((0,0)\)</span>，小物体：<span class="math inline">\((x,y)\)</span></li>
<li>力的方向向量</li>
</ul>
<p><span class="math display">\[
\left(-\dfrac{x}{\sqrt{x^2+y^2}},-\dfrac{y}{\sqrt{x^2+y^2}}\right)
\]</span></p>
<ul>
<li>得到二阶方程组如下</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
m_1x&#39;&#39;&amp;=-\dfrac{x}{\sqrt{x^2+y^2}}\times\dfrac{gm_1m_2}{x^2+y^2}=-\dfrac{gm_1m_2x}{(x^2+y^2)^{3/2}}\\
m_1y&#39;&#39;&amp;=-\dfrac{y}{\sqrt{x^2+y^2}}\times\dfrac{gm_1m_2}{x^2+y^2}=-\dfrac{gm_1m_2y}{(x^2+y^2)^{3/2}}\\
\end{aligned}
\]</span></p>
<ul>
<li>转化为一阶方程组</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
x&#39;&amp;=v_x\\
v_x&#39;&amp;=-\dfrac{gm_2x}{(x^2+y^2)^{3/2}}\\
y&#39;&amp;=v_y\\
v_y&#39;&amp;=-\dfrac{gm_2y}{(x^2+y^2)^{3/2}}\\
\end{aligned}
\]</span></p>
<ul>
<li><strong>单体问题的解一定是圆锥曲线（椭圆、抛物线、双曲线）</strong></li>
<li>单体问题是虚构的，由于它忽略了卫星对于（非常大的）的行星的力，包含后者得到的两个物体的运动被称为<strong>二体问题</strong></li>
</ul>
<h4 id="三体问题">三体问题</h4>
<ul>
<li>三个物体在重力的作用下交互运动，被称为<strong>三体问题</strong></li>
<li>即使所有的运动都被局限在平面（<strong>受限三体问题</strong>），从本质上也可能难以预测长期的轨迹</li>
<li>非预测性来自于<strong>对初值条件的敏感依赖</strong></li>
<li>受限三体问题没一个物体都有 4 个方程
<ul>
<li>例如物体 1 的方程如下</li>
</ul></li>
</ul>
<p><img src="/2021/12/28/computation/pyr/09-1/image-20211228134315472.png" style="zoom:80%;"></p>
<h2 id="龙格-库塔方法和应用">4. 龙格-库塔方法和应用</h2>
<ul>
<li><strong>龙格-库塔方法</strong>是一组 ODE
求解器，包含欧拉和梯形方法，以及更加复杂的高阶方法</li>
</ul>
<h3 id="龙格-库塔家族">4.1 龙格-库塔家族</h3>
<h4 id="中点方法">中点方法</h4>
<p><span class="math display">\[
\begin{aligned}
w_0&amp;=y_0\\
w_{i+1}&amp;=w_i+hf\left(t_i+\dfrac{h}{2},w_i+\dfrac{h}{2}f(t_i,w_i)\right)
\end{aligned}
\]</span></p>
<h5 id="局部截断误差">局部截断误差</h5>
<ul>
<li>泰勒展开</li>
</ul>
<p><span class="math display">\[
y_{i+1}
=y(t_i)+hf(t_i,y_i)+\dfrac{h^2}{2}\left(\dfrac{\partial{f}}{\partial{t}}(t_i,y_i)+\dfrac{\partial{f}}{\partial{y}}(t_i,y_i)f(t_i,y_i)\right)+\dfrac{h^3}{6}y&#39;&#39;&#39;(c)
\]</span></p>
<ul>
<li>中点方法，二维泰勒展开</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
w_{i+1}&amp;=w_i+hf\left(t_i+\dfrac{h}{2},y_i+\dfrac{h}{2}f(t_i,y_i)\right)\\
&amp;=w_i+h\left(f(t_i,y_i)+\dfrac{h}{2}\dfrac{\partial{f}}{\partial{t}}(t_i,y_i)+\dfrac{h}{2}f(t_i,y_i)\dfrac{\partial{f}}{\partial{y}}(t_i,y_i)+O(h^2)\right)\\
\end{aligned}
\]</span></p>
<ul>
<li>对比，得到局部截断误差</li>
</ul>
<p><span class="math display">\[
e_{i+1}=y_{i+1}-w_{i+1}=O(h^3)
\]</span></p>
<ul>
<li>中点方法是 <span class="math inline">\(2\)</span> 阶方法</li>
</ul>
<h4 id="rk2">RK2</h4>
<ul>
<li>右侧的每个函数的求值被称为方法的<strong>阶段</strong>（stage）</li>
<li>梯形方法和中点方法都是<strong>二阶段</strong>的<strong>二阶龙格-库塔方法</strong>家族中的成员（RK2）</li>
<li>RK2 的一般形式如下（<span class="math inline">\(\alpha\ne0\)</span>）</li>
</ul>
<p><span class="math display">\[
w_{i+1}=w_i+h(1-\dfrac{1}{2\alpha})f(t_i,w_i)+h\dfrac{1}{2\alpha}f(t_i+\alpha
h,w_i+\alpha hf(t_i,w_i))
\]</span></p>
<ul>
<li>显式梯形方法：<span class="math inline">\(\alpha=1\)</span></li>
<li>中点方法：<span class="math inline">\(\alpha=\dfrac{1}{2}\)</span></li>
</ul>
<p><img src="/2021/12/28/computation/pyr/09-1/image-20211228141122239.png" style="zoom:80%;"></p>
<h5 id="局部截断误差-1">局部截断误差</h5>
<ul>
<li>泰勒展开</li>
</ul>
<p><span class="math display">\[
y_{i+1}
=y(t_i)+hf(t_i,y_i)+\dfrac{h^2}{2}\left(\dfrac{\partial{f}}{\partial{t}}(t_i,y_i)+\dfrac{\partial{f}}{\partial{y}}(t_i,y_i)f(t_i,y_i)\right)+\dfrac{h^3}{6}y&#39;&#39;&#39;(c)
\]</span></p>
<ul>
<li>中点方法，二维泰勒展开</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
w_{i+1}&amp;=w_i+h(1-\dfrac{1}{2\alpha})f(t_i,w_i)+h\dfrac{1}{2\alpha}f(t_i+\alpha
h,w_i+\alpha hf(t_i,w_i))\\
&amp;=w_i+h\left(f(t_i,y_i)+\dfrac{1}{2\alpha}\left(
\alpha h\dfrac{\partial{f}}{\partial{t}}(t_i,y_i)+\alpha
hf(t_i,y_i)\dfrac{\partial{f}}{\partial{y}}(t_i,y_i)+O(h^2)
\right)\right)\\
&amp;=w_i+h\left(f(t_i,y_i)+\dfrac{h}{2}\left(
\dfrac{\partial{f}}{\partial{t}}(t_i,y_i)+f(t_i,y_i)\dfrac{\partial{f}}{\partial{y}}(t_i,y_i)
\right)\right)+O(h^3)\\
\end{aligned}
\]</span></p>
<ul>
<li>局部截断误差</li>
</ul>
<p><span class="math display">\[
e_{i+1}=y_{i+1}-w_{i+1}=O(h^3)
\]</span></p>
<h4 id="rk4">RK4</h4>
<ul>
<li>一种常见的<strong>龙格-库塔方法</strong></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
w_{i+1}&amp;=w_i+\dfrac{h}{6}(s_1+2s_2+2s_3+s_4)\\
s_1&amp;=f(t_i,w_i)\\
s_2&amp;=f(t_i+\dfrac{h}{2},w_i+\dfrac{h}{2}s_1)\\
s_3&amp;=f(t_i+\dfrac{h}{2},w_i+\dfrac{h}{2}s_2)\\
s_4&amp;=f(t_i+h,w_i+hs_3)\\
\end{aligned}
\]</span></p>
<ul>
<li>证明类似
<ul>
<li>泰勒展开，但是很复杂</li>
<li>方法是 4 阶的，所以局部截断误差是 5 阶的，展开得展开麻了</li>
</ul></li>
<li>简单、容易编程实现</li>
<li>这是单步方法，仅需要一个初始条件</li>
<li>作为 4 阶方法，比欧拉方法或者梯形方法要精确得多</li>
</ul>
<h3 id="计算机仿真hodgkin-huxley-神经元">4.2 计算机仿真：Hodgkin-Huxley
神经元</h3>
<p><img src="/2021/12/28/computation/pyr/09-1/image-20211228151044937.png" style="zoom:80%;"></p>
<h3 id="计算机仿真lorenz-方程">4.3 计算机仿真：Lorenz 方程</h3>
<ul>
<li>气象学</li>
</ul>
<p><img src="/2021/12/28/computation/pyr/09-1/image-20211228151314827.png" style="zoom:80%;"></p>
<ul>
<li>对于初值极度敏感：<strong>混沌现象</strong></li>
</ul>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.09.常微分方程(3)</title>
    <url>/2021/12/28/computation/pyr/09-2/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 6 章（常微分方程） + PPT（常微分方程）</li>
</ul>
<h1 id="常微分方程">常微分方程</h1>
<h2 id="可变步长方法">5. 可变步长方法</h2>
<ul>
<li>最常见的是使用两个不同阶的方法，称为嵌入对（embedded pair）</li>
</ul>
<h3 id="龙格-库塔嵌入对">5.1 龙格-库塔嵌入对</h3>
<ul>
<li>可变步长方法的关键思想是<strong>检测当前步生成的误差</strong></li>
<li>思路：用户设置的容差需要在当前步满足
<ul>
<li>如果超出容差，则拒绝误差，并且将步长减小</li>
<li>如果满足容差，则接受，并选择下一步适合的步长
<ul>
<li>例如如果误差小于容差的 <span class="math inline">\(\dfrac{1}{10}\)</span>，则在接受本步之后加大步长</li>
</ul></li>
</ul></li>
<li>容差设置
<ul>
<li>绝对误差：<span class="math inline">\(e_i\)</span></li>
<li>相对误差：<span class="math inline">\(\dfrac{e_i}{w_i}\)</span></li>
<li>混合方式：<span class="math inline">\(\dfrac{e_i}{\max\{w_i,\theta\}}\)</span>
<ul>
<li>避免过小的 <span class="math inline">\(w_i\)</span></li>
</ul></li>
</ul></li>
<li>改变步长最简单的方式：<span class="math inline">\(\dfrac{h}{2},2h\)</span></li>
<li>选择合适步长的方式和求解器相关</li>
<li><span class="math inline">\(p\)</span> 阶求解器，局部截断误差 <span class="math inline">\(O(h^{p+1})\)</span></li>
<li>设 <span class="math inline">\(T\)</span> 为每步中用户允许的相对容差
<ul>
<li>要求 <span class="math inline">\(\dfrac{e_i}{w_i}&lt;T\)</span></li>
</ul></li>
</ul>
<h4 id="减小步长">减小步长</h4>
<ul>
<li>满足的条件下，如何选择下一步步长？
<ul>
<li>这里使用相对误差，可以修改为混合误差表示</li>
</ul></li>
<li>假设存在常数 <span class="math inline">\(c\)</span> 满足下式</li>
</ul>
<p><span class="math display">\[
e_i\approx ch^{p+1}
\]</span></p>
<ul>
<li>满足条件的最优步长</li>
</ul>
<p><span class="math display">\[
T\vert{w_i}\vert=ch^{p+1}
\]</span></p>
<ul>
<li>解得
<ul>
<li><span class="math inline">\(0.8\)</span>
表示我们使用更保守的方法</li>
</ul></li>
</ul>
<p><span class="math display">\[
h_{\ast}={\color{red}0.8}\left(\dfrac{T\vert{w_i}\vert}{e_i}\right)^{1/(p+1)}h_i
\]</span></p>
<h4 id="增大步长">增大步长</h4>
<ul>
<li>不满足容差要求则反复测试，增大步长（例如 <span class="math inline">\(2h\)</span> ），直至满足容差要求</li>
</ul>
<h4 id="龙格-库塔嵌入对-1">龙格-库塔嵌入对</h4>
<ul>
<li>在运行当前求解器的同时，运行更高阶的求解器
<ul>
<li>当前估计：<span class="math inline">\(w_{i+1}\)</span></li>
<li>更高阶的估计：<span class="math inline">\(z_{i+1}\)</span></li>
<li><span class="math inline">\(e_{i+1}=\vert{z_{i+1}-w_{i+1}}\vert\)</span>
用于估计从 <span class="math inline">\(t_i\)</span> 步到 <span class="math inline">\(t_{i+1}\)</span> 步的误差</li>
</ul></li>
<li>如何降低计算代价：<strong>共享必要的计算</strong></li>
</ul>
<h4 id="rk-23">RK 2/3</h4>
<p><img src="/2021/12/28/computation/pyr/09-2/image-20211228162218673.png"></p>
<ul>
<li>尽管步长策略对于 <span class="math inline">\(w_{i+1}\)</span>
可行，但是使用更高阶的 <span class="math inline">\(z_{i+1}\)</span>
继续做这步会更有意义，因为已经得到了这个高阶估计，这被称为<strong>局部外推</strong></li>
</ul>
<h4 id="bogacki-shampine-23-嵌入对">Bogacki-Shampine 2/3 嵌入对</h4>
<p><img src="/2021/12/28/computation/pyr/09-2/image-20211228163320198.png" style="zoom:80%;"></p>
<h3 id="阶方法">5.2 4/5 阶方法</h3>
<h4 id="rkf-45">RKF 4/5</h4>
<p><img src="/2021/12/28/computation/pyr/09-2/image-20211228163818624.png" style="zoom:80%;"></p>
<h4 id="dormand-prince-45">Dormand-Prince 4/5</h4>
<p><img src="/2021/12/28/computation/pyr/09-2/image-20211228164502930.png" style="zoom:80%;"></p>
<h4 id="刚性方程">刚性方程</h4>
<ul>
<li><span id="s1">stiff</span></li>
<li>虽然似乎可变步长的龙格-库塔方法是 ode
求解器中最好的一个，但是仍然有几类方程它们也不能很好处理</li>
</ul>
<p><img src="/2021/12/28/computation/pyr/09-2/image-20211228165210526.png" style="zoom:80%;"></p>
<p><img src="/2021/12/28/computation/pyr/09-2/image-20211228165333375.png" style="zoom:80%;"></p>
<ul>
<li>使用 ode23 步数更少</li>
</ul>
<h2 id="隐式方法与刚性方程">6. 隐式方法与刚性方程</h2>
<ul>
<li>显式方法：新的近似 <span class="math inline">\(w_{i+1}\)</span>
有一个由已知数据表示的显式公式</li>
<li>某些问题是用显示方法求解效果很差
<ul>
<li>例如<a href="#s1">上面的问题</a>，复杂的可变步长的求解器一直在正确解周围过调</li>
<li><strong>原因</strong>：在正确解附近 <span class="math inline">\(h\)</span>
区间的起点和终点<strong>斜率变化剧烈</strong></li>
</ul></li>
</ul>
<h3 id="隐式方法与刚性方程-1">6.1隐式方法与刚性方程</h3>
<h4 id="刚性现象">刚性现象</h4>
<p><img src="/2021/12/28/computation/pyr/09-2/image-20211228170640681.png" style="zoom:80%;"></p>
<ul>
<li><p>还是上面的例子：<span class="math inline">\(f(t,y)=10(1-y)\)</span></p></li>
<li><p>欧拉方法</p></li>
</ul>
<p><span class="math display">\[
w_{i+1}=w_i+h10(1-w_i)=w_i(1-10h)+10h
\]</span></p>
<ul>
<li>看成是不动点迭代方法，如果斜率小于 <span class="math inline">\(1\)</span>，就能收敛
<ul>
<li><span class="math inline">\(0&lt;h&lt;0.2\)</span></li>
</ul></li>
<li>因此调整步长大于 <span class="math inline">\(0.2\)</span>
的时候，很快的从正确解附近离开了
，这是因为在正确解的附近，斜率变化太快导致的</li>
<li><strong>刚性方程</strong>
<ul>
<li>具有这种性质的微分方程，即吸引解被附近的更快变化的解所包围，被称为刚性方程</li>
<li><strong>这通常是系统具有多时间尺度的标志</strong></li>
<li>定量地讲，这对应微分方程右侧函数 <span class="math inline">\(f\)</span> 对于 <span class="math inline">\(y\)</span> 的线性部分，这部分很大并且是负的
<ul>
<li>对于方程组，这对应很大并且负的线性部分的特征值</li>
</ul></li>
<li>这个定义是相对的，但这是刚性的本质，即越负，步长就必须越小以避免过调
<ul>
<li>解释了<a href="#s1">上面的例子</a></li>
</ul></li>
</ul></li>
</ul>
<h4 id="后向欧拉方法">后向欧拉方法</h4>
<p><span class="math display">\[
\begin{aligned}
w_0&amp;=y_0\\
w_{i+1}&amp;=w_i+hf(t_{i+1},w_{i+1})\\
\end{aligned}
\]</span></p>
<ul>
<li>不同于欧拉方法使用步长区间左侧的斜率，后向欧拉则穿过区间使用<strong>右侧的斜率</strong></li>
<li>是<strong>隐式方法</strong></li>
<li>对于<a href="#s1">上面的例子</a>，我们能够很快的得到表达式
<ul>
<li>因为是线性的</li>
</ul></li>
</ul>
<p><span class="math display">\[
w_{i+1}=w_i+10h(1-w_{i+1})\Longrightarrow w_{i+1}=\dfrac{w_i+10h}{1+10h}
\]</span></p>
<ul>
<li>但是对于一般的例子，我们很难很快求得隐式方法的解析式，需要采用间接的方式</li>
</ul>
<h5 id="后向欧拉方法求解的例子">后向欧拉方法求解的例子</h5>
<ul>
<li>IVP 如下</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
y&#39;&amp;=y+8y-9y^3\\
y(0)&amp;=\dfrac{1}{2}\\
t&amp;\in[0,3]\\
\end{aligned}
\]</span></p>
<ul>
<li>平衡解：<span class="math inline">\(y=1\)</span>（令 <span class="math inline">\(y&#39;=0\)</span>）
<ul>
<li>偏导数为 <span class="math inline">\(-10\)</span></li>
<li>刚性问题
<ul>
<li>欧拉方法 + 带有上界的 <span class="math inline">\(h\)</span></li>
<li>后向欧拉方法</li>
</ul></li>
</ul></li>
<li>后向欧拉方法迭代公式</li>
</ul>
<p><span class="math display">\[
w_{i+1}=w_i+h(w_{i+1}+8w_{i+1}^2-9w_{i+1}^3)
\]</span></p>
<ul>
<li>重写</li>
</ul>
<p><span class="math display">\[
z=w_i+h(z+8z^2-9z^3)
\]</span></p>
<ul>
<li>牛顿法迭代求解（看成不动点迭代问题）
<ul>
<li>初始估计
<ul>
<li>前面近似的 <span class="math inline">\(w_i\)</span></li>
<li>欧拉方法得到的 <span class="math inline">\(w_{i+1}\)</span>
<ul>
<li>对于刚性问题而言并不是一个好的初始估计</li>
</ul></li>
</ul></li>
</ul></li>
<li>牛顿迭代公式</li>
</ul>
<p><span class="math display">\[
z_{new}=z-\dfrac{9hz^3-8hz^2+(1-h)z-w_i}{27hz^2-16hz+1-h}
\]</span></p>
<ul>
<li>对于每一个欧拉后向步，都需要使用牛顿法迭代求解</li>
</ul>
<h5 id="评价">评价</h5>
<ul>
<li>被称为刚性求解器的方法，诸如后向欧拉方法，允许在<strong>相对较大的步长</strong>中具有足够的误差控制，以及更好的效率</li>
</ul>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.09.常微分方程(4)</title>
    <url>/2021/12/28/computation/pyr/09-3/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 6 章（常微分方程） + PPT（常微分方程）</li>
</ul>
<h1 id="常微分方程">常微分方程</h1>
<h2 id="多步方法">7. 多步方法</h2>
<ul>
<li>单步方法：使用 <span class="math inline">\(w_i\)</span>
的知识计算得到 <span class="math inline">\(w_{i+1}\)</span></li>
<li>多步方法：使用 <span class="math inline">\(w_i\)</span>
以及其他的值（<span class="math inline">\(w_{i-1},\cdots\)</span>）计算得到 <span class="math inline">\(w_{i+1}\)</span>
<ul>
<li>能够达到和单步方法相同的精度</li>
<li>将复杂的计算转化为之前己经计算过的值的插值</li>
</ul></li>
</ul>
<h3 id="构造多步方法">7.1 构造多步方法</h3>
<h4 id="adam-bashforth-两步方法">Adam-Bashforth 两步方法</h4>
<p><span class="math display">\[
w_{i+1}=w_i+h\left(\dfrac{3}{2}f(t_i,w_i)-\dfrac{1}{2}f(t_{i-1},w_{i-1})\right)
\]</span></p>
<ul>
<li>之前的二阶求解方法需要计算<strong>两次</strong>函数值，Adam-Bathforth
方法只需要计算<strong>一次</strong></li>
<li>初始的时候，需要先使用单步方法计算得到 <span class="math inline">\(w_1\)</span>，才能够开始使用该算法</li>
<li>一般的 <span class="math inline">\(s\)</span> 步方法的形式</li>
</ul>
<p><span class="math display">\[
w_{i}=a_1w_i+\cdots+a_sw_{i-s+1}+h[b_0f(t_{i+1},w_{i+1})+\cdots
b_sf(t_{i-s+1},w_{i-s+1})]
\]</span></p>
<ul>
<li><span class="math inline">\(b_0=0\)</span>：显式方法</li>
<li>如何构造多步方法？
<ul>
<li><strong>泰勒展开</strong></li>
</ul></li>
</ul>
<h4 id="二步方法的构造">二步方法的构造</h4>
<p><span class="math display">\[
w_{i+1}=a_1w_i+a_2w_{i-1}+h[b_0f(t_{i+1},w_{i+1})+b_1f(t_{i},w_{i})+b_2f(t_{i-1},w_{i-1})]
\]</span></p>
<ul>
<li>假设前面的 <span class="math inline">\(w_i\)</span> 都正确，<span class="math inline">\(y&#39;=f_i=f(t_i,w_i)\)</span>，泰勒展开如下</li>
</ul>
<p><img src="/2021/12/28/computation/pyr/09-3/image-20211228215118631.png" style="zoom: 80%;"></p>
<h3 id="显式多步方法">7.2 显式多步方法</h3>
<ul>
<li><span class="math inline">\(b_0=0\)</span></li>
<li>二阶方法</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
a_1+a_2&amp;=1\\
-a_2+b_1+b_2&amp;=1\\
a_2-2b_2&amp;=1\\
\end{aligned}
\]</span></p>
<ul>
<li>因此有无穷个二阶方法</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
a_2&amp;=1-a_1\\
b_1&amp;=2-\dfrac{1}{2}a_1\\
b_2&amp;=-\dfrac{a_1}{2}\\
\end{aligned}
\]</span></p>
<ul>
<li>局部截断误差：</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
e_{i+1}&amp;=y_{i+1}-w_{i+1}\\
&amp;=\left(1+a_2-3b_2\right)\dfrac{h^3}{6}y_i&#39;&#39;&#39;+O(h^4)\\
&amp;=\left(4+a_1\right)\dfrac{h^3}{12}y_i&#39;&#39;&#39;+O(h^4)\\
\end{aligned}
\]</span></p>
<h4 id="构造二阶显式方法">构造二阶显式方法</h4>
<h5 id="a_11"><span class="math inline">\(a_1=1\)</span></h5>
<ul>
<li>二阶的 Adam-Bathforth 方法</li>
<li>局部截断误差</li>
</ul>
<p><span class="math display">\[
\dfrac{5h^3}{12}y_i&#39;&#39;&#39;+O(h^4)\\
\]</span></p>
<h5 id="a_1dfrac12"><span class="math inline">\(a_1=\dfrac{1}{2}\)</span></h5>
<ul>
<li>算法</li>
</ul>
<p><span class="math display">\[
w_{i+1}=\dfrac{1}{2}w_i+\dfrac{1}{2}w_{i-1}+h\left(\dfrac{7}{4}f_i-\dfrac{1}{4}f_{i-1}\right)
\]</span></p>
<ul>
<li>局部截断误差</li>
</ul>
<p><span class="math display">\[
\dfrac{3h^3}{8}y_i&#39;&#39;&#39;+O(h^4)
\]</span></p>
<h5 id="a_1-1"><span class="math inline">\(a_1=-1\)</span></h5>
<ul>
<li>算法</li>
</ul>
<p><span class="math display">\[
w_{i+1}=-w_i+2w_{i-1}+h\left(\dfrac{5}{2}f_i+\dfrac{1}{2}f_{i-1}\right)
\]</span></p>
<ul>
<li>局部截断误差</li>
</ul>
<p><span class="math display">\[
\dfrac{h^3}{4}y_i&#39;&#39;&#39;+O(h^4)
\]</span></p>
<h5 id="稳定性问题">稳定性问题</h5>
<ul>
<li><span class="math inline">\(a_1=1\)</span>，<span class="math inline">\(a_1=-1\)</span></li>
</ul>
<p><img src="/2021/12/28/computation/pyr/09-3/image-20211228221124369.png" style="zoom:80%;"></p>
<ul>
<li>一个例子</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
y&#39;&amp;=0\\
y(0)&amp;=0\\
t&amp;\in[0,1]\\
\end{aligned}
\]</span></p>
<ul>
<li>使用 <span class="math inline">\(a_1=-1\)</span> 进行迭代</li>
</ul>
<p><span class="math display">\[
w_{i+1}=-w_i+2w_{i-1}
\]</span></p>
<ul>
<li>显然 <span class="math inline">\(y=0\)</span>
是一个根，但是还有其他根
<ul>
<li><span class="math inline">\(w_i=c\lambda^i\)</span> 代入</li>
</ul></li>
</ul>
<p><span class="math display">\[
c\lambda^{i-1}(\lambda-1)(\lambda+2)=0
\]</span></p>
<ul>
<li>此时 <span class="math inline">\(\lambda_2=-2\)</span>
这个根导致了不稳定，小的舍入误差/截断误差，会被无限放大，<strong>计算出错</strong></li>
<li>因此稳定的要求就是特征多项式的根的绝对值的界为 <span class="math inline">\(1\)</span></li>
</ul>
<h4 id="稳定性">稳定性</h4>
<p><img src="/2021/12/28/computation/pyr/09-3/image-20211228222215860.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(a_1=0\)</span>，此时</li>
</ul>
<p><span class="math display">\[
w_{i+1}=w_{i-1}+2hf_i
\]</span></p>
<ul>
<li>弱稳定，<span class="math inline">\(\lambda=\pm1\)</span></li>
<li>对比图</li>
</ul>
<p><img src="/2021/12/28/computation/pyr/09-3/image-20211228224935646.png" style="zoom:80%;"></p>
<h4 id="收敛性">收敛性</h4>
<p><img src="/2021/12/28/computation/pyr/09-3/image-20211228225203296.png" style="zoom:80%;"></p>
<ul>
<li>特征多项式的一个根必须为 1（<span class="math inline">\(\sum{a_i}=1\)</span>）
<ul>
<li>Adams- Bashforth方法属于其他根都是 0 的情况，因此，Adams-Bashforth
更高阶方法被认为是最稳定的两步方法</li>
</ul></li>
</ul>
<h4 id="高阶-adam-bathforth">高阶 Adam-Bathforth</h4>
<p><img src="/2021/12/28/computation/pyr/09-3/image-20211228230140114.png" style="zoom:80%;"></p>
<ul>
<li>推导方法和之前完全一致</li>
</ul>
<h3 id="隐式多步方法">7.3 隐式多步方法</h3>
<ul>
<li><span class="math inline">\(b_0\ne0\)</span></li>
</ul>
<h4 id="隐式梯形方法">隐式梯形方法</h4>
<ul>
<li>二阶
<ul>
<li>证明的话和上面类似</li>
<li>验证的话带入验证即可</li>
</ul></li>
</ul>
<p><span class="math display">\[
w_{i+1}=w_i+\dfrac{h}{2}(f_{i+1}+f_i)
\]</span></p>
<ul>
<li>也被称为是 <strong>Adam-Moulton 单步方法</strong></li>
</ul>
<h4 id="adam-moulton-两步方法">Adam-Moulton 两步方法</h4>
<ul>
<li>三阶</li>
</ul>
<p><span class="math display">\[
w_{i+1}=w_i+\dfrac{h}{12}(5f_{i+1}+8f_i-f_{i-1})
\]</span></p>
<ul>
<li>由于引入了新的变量，可以多带一个方程，精度升了一阶</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
a_1+a_2&amp;=1\\
-a_2+b_0+b_1+b_2&amp;=1\\
a_2+2b_0-2b_2&amp;=1\\
-a_2+3b_0+3b_2&amp;=1\\
\end{aligned}
\]</span></p>
<ul>
<li>化简</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
a_2&amp;=1-a_1\\
b_0&amp;=\dfrac{1}{3}+\dfrac{1}{12}a_1\\
b_1&amp;=\dfrac{4}{3}-\dfrac{2}{3}a_1\\
b_2&amp;=\dfrac{1}{3}+\dfrac{5}{12}a_1\\
\end{aligned}
\]</span></p>
<ul>
<li>令 <span class="math inline">\(a_1=1\)</span> 即可</li>
<li>局部截断误差</li>
</ul>
<p><span class="math display">\[
y_{i+1}-w_{i+1}=-\dfrac{a_1}{24}h^4y_i^{(4)}+O(h^5)
\]</span></p>
<ul>
<li><strong>强稳定</strong></li>
</ul>
<h4 id="隐式方法评价">隐式方法评价</h4>
<ul>
<li>好处
<ul>
<li>仅仅使用前面的两步，就可以得到稳定的三阶隐式方法
<ul>
<li>多引入了一个变量，可以允许多一个方程（高一阶）</li>
</ul></li>
<li>隐式方法对应的局部截断误差更小</li>
</ul></li>
<li>问题
<ul>
<li>需要额外处理计算隐式部分</li>
</ul></li>
<li>因此，隐式方法通常用于 <strong>“预测-矫正”</strong> 对中的矫正
<ul>
<li>同时使用相同阶的隐式和显式方法</li>
<li>每步是显式方法的预测和隐式方法的矫正的组合，其中隐式方法使用预测的
<span class="math inline">\(w_{i+1}\)</span> 来计算 <span class="math inline">\(f_{i+1}\)</span></li>
<li>预测-矫正方法大约使用<strong>两倍的计算代价</strong>
<ul>
<li>这是由于在预测和矫正过程中都需要对微分方程右侧的函数 <span class="math inline">\(f\)</span> 进行求值</li>
</ul></li>
<li>通常获取的<strong>精度和稳定性</strong>使得这个代价完全值得</li>
</ul></li>
<li>例子（二阶）
<ul>
<li>Adam-Bathforth 两步显式方法做作为预测</li>
<li>Adam-Moulton 单步方法作为矫正</li>
</ul></li>
</ul>
<h4 id="milne-simpson-方法">Milne-Simpson 方法</h4>
<ul>
<li><span class="math inline">\(a_1=0\)</span>，此时为 <span class="math inline">\(4\)</span> 阶方法</li>
</ul>
<p><span class="math display">\[
w_{i+1}=w_i+\dfrac{h}{3}(f_{i+1}+4f_i+f_{i-1})
\]</span></p>
<ul>
<li><strong>弱稳定</strong></li>
</ul>
<h4 id="ode-与数值积分">ODE 与数值积分</h4>
<p><span class="math display">\[
y(t_{i+1})-y(t_i)=\int_{t_i}^{t_{i+1}}f(t,y)\;\mathrm{d}t
\]</span></p>
<ul>
<li>梯形法则</li>
</ul>
<p><span class="math display">\[
y(t_{i+1})-y(t_i)=\dfrac{2}{h}(f_{i+1}+f_i)+O(h^2)
\]</span></p>
<ul>
<li>Simpson 法则</li>
</ul>
<p><span class="math display">\[
w_{i+1}=w_i+\dfrac{h}{3}(f_{i+1}+4f_i+f_{i-1})+O(h^4)
\]</span></p>
<h4 id="高阶-adam-moulton-方法">高阶 Adam-Moulton 方法</h4>
<p><img src="/2021/12/28/computation/pyr/09-3/image-20211228233507843.png" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.09.常微分方程</title>
    <url>/2021/12/07/computation/pyr/09/</url>
    <content><![CDATA[<ul>
<li>数值分析课本第 6 章（常微分方程） + PPT（常微分方程）</li>
</ul>
<h1 id="常微分方程">常微分方程</h1>
<ul>
<li>微分方程是包含导数的方程</li>
</ul>
<p><span class="math display">\[
y&#39;(t)=f(t,y(t))
\]</span></p>
<h2 id="初值问题">1. 初值问题</h2>
<h3 id="logistic-方程">1.0 logistic 方程</h3>
<ul>
<li>逻辑斯蒂方程（logistic）</li>
</ul>
<p><span class="math display">\[
y&#39;=cy(1-y)
\]</span></p>
<ul>
<li>常微分方程一般具有无穷多的解</li>
<li>通过定义<strong>初始条件</strong>，我们可以找出无穷多解中我们感兴趣的那个</li>
<li>一阶常微分方程的初值问题由<strong>两部分</strong>组成
<ul>
<li>方程</li>
<li>在指定区间 <span class="math inline">\([a,b]\)</span>
上的<strong>初值条件</strong></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
y&#39;=f(t,y)\\
y(a)=y_a\\
t\in[a,b]
\end{array}
\]</span></p>
<ul>
<li><strong>自主的方程</strong>
<ul>
<li><span class="math inline">\(f(t,y)\)</span> 与 <span class="math inline">\(t\)</span> 无关</li>
</ul></li>
<li>将微分方程当作<strong>斜率场</strong>（<strong>方向场</strong>）</li>
</ul>
<p><img src="/2021/12/07/computation/pyr/09/image-20211207155731927.png" style="zoom:80%;"></p>
<ul>
<li>当 <span class="math inline">\(y_0\ne1\)</span>
时，上述初值问题的解为</li>
</ul>
<p><span class="math display">\[
y=1-\dfrac{1}{1+\dfrac{y_0}{1-y_0}e^{ct}}
\]</span></p>
<ul>
<li><span class="math inline">\(y_0=1\Longrightarrow y=1\)</span></li>
</ul>
<h3 id="欧拉方法">1.1 欧拉方法</h3>
<ul>
<li>在一般的情况中，微分方程<strong>没有显式的解公式</strong></li>
</ul>
<h4 id="几何求解方式">几何求解方式</h4>
<ul>
<li>流程
<ul>
<li>画出斜率图</li>
<li><strong>通过跟随箭头计算 “求解” 微分方程</strong></li>
</ul></li>
<li><strong>有误差</strong>
<ul>
<li>如果正确的解斜率变化缓慢，则这样的解法是一个比较好的近似</li>
</ul></li>
<li>这便是<strong>欧拉方法</strong></li>
</ul>
<h4 id="欧拉方法-1">欧拉方法</h4>
<p><span class="math display">\[
\begin{aligned}
w_0&amp;=y_0\\
w_{i+1}&amp;=w_i+hf(t_i,w_i)
\end{aligned}
\]</span></p>
<ul>
<li>其中 <span class="math inline">\(h\)</span> 表示步长</li>
<li>随着步长的减小，<strong>截断误差</strong>在变小</li>
</ul>
<h4 id="欧拉方法收敛性">欧拉方法收敛性</h4>
<p><span class="math display">\[
\begin{array}{c}
y&#39;=cy\\
y(0)=y_0\\
t\in[0,1]
\end{array}
\]</span></p>
<ul>
<li>欧拉方法，对于固定的 <span class="math inline">\(t\in(0,1]\)</span>
设步长 <span class="math inline">\(h\)</span> 为 <span class="math inline">\(\dfrac{t}{n}\)</span></li>
</ul>
<p><span class="math display">\[
w_n=(1+hc)^{n}y_0
\]</span></p>
<ul>
<li><span class="math inline">\(n\to\infty\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\lim_{n\to\infty}w_n
&amp;=\lim_{n\to\infty}(1+\dfrac{tc}{n})^{n}y_0\\
&amp;=\lim_{n&#39;\to\infty}(1+\dfrac{1}{n&#39;})^{ctn&#39;}y_0\\
&amp;=e^{ct}y_0
\end{aligned}
\]</span></p>
<ul>
<li>精确解可以通过<strong>分离变量</strong>求解，和上面相同</li>
<li><span class="math inline">\(n\to\infty\)</span>
时，<strong>上述初值问题使用欧拉方法能够得到精确解</strong></li>
</ul>
<h3 id="解的存在性唯一性连续性">1.2 解的存在性、唯一性、连续性</h3>
<h4 id="利普希茨连续">利普希茨连续</h4>
<p><img src="/2021/12/07/computation/pyr/09/image-20211207162739657.png" style="zoom:80%;"></p>
<ul>
<li>利普希茨连续<strong>一定连续</strong>（<strong>定义可证</strong>），但是<strong>不一定可微</strong></li>
<li>更一般的，条件中的矩形可以是<strong>凸集</strong></li>
</ul>
<p><img src="/2021/12/07/computation/pyr/09/image-20211207170159674.png" style="zoom:80%;"></p>
<ul>
<li>如果函数 <span class="math inline">\(f\)</span> 对 <span class="math inline">\(y\)</span>
<strong>连续可微</strong>，则利普希茨常数可以取在这个矩形（<strong>凸集</strong>）中如下式子的最大值</li>
</ul>
<p><span class="math display">\[
\left\vert\dfrac{\partial{f}}{\partial{y}}(t,c)\right\vert
\]</span></p>
<ul>
<li>由均值定理保证</li>
</ul>
<p><span class="math display">\[
\dfrac{f(t,y_1)-f(t,y_2)}{y_1-y_2}=\dfrac{\partial{f}}{\partial{y}}(t,c)
\]</span></p>
<h4 id="存在性和唯一性">存在性和唯一性</h4>
<ul>
<li><strong>利普希茨连续假设</strong>保证初值问题的解的<strong>存在性</strong>和<strong>唯一性</strong></li>
</ul>
<p><img src="/2021/12/07/computation/pyr/09/image-20211207170738095.png" style="zoom:80%;"></p>
<ul>
<li>注意<strong><span style="color:red">不能保证</span></strong>在整个区间上都是有解的
<ul>
<li>一个简单的原因是解可能超出了 <span class="math inline">\(y\)</span>
的满足利普希茨常数有效的范围 <span class="math inline">\([\alpha,\beta]\)</span>
<ul>
<li>在 <span class="math inline">\(y\)</span>
方向上超出了凸集的范围</li>
</ul></li>
</ul></li>
<li>定理证明
<ul>
<li>G Birkhoff and G Rota [1989] Ordinary Differential Equations, 4th
ed. John Wiley &amp; Sons, New York.</li>
</ul></li>
</ul>
<h4 id="误差放大">误差放大</h4>
<ul>
<li><span id="s1">误差界</span></li>
</ul>
<p><img src="/2021/12/07/computation/pyr/09/image-20211227125945085.png" style="zoom:80%;"></p>
<h5 id="证明-1">证明 (1)</h5>
<ul>
<li><span class="math inline">\(Y(a)=Z(a)\)</span>
时，由唯一解定理，<span class="math inline">\(Y(t)=Z(t)\)</span>
成立</li>
</ul>
<h5 id="证明-2">证明 (2)</h5>
<ul>
<li><span class="math inline">\(Y(a)\ne Z(a)\)</span> 时，此时不妨假设
<span class="math inline">\(Y(t)\ne Z(t),\forall
t\in[a,b]\)</span>，否则在相等的点转化为上面的形式</li>
<li>令 <span class="math inline">\(u(t)=Y(t)-Z(t)\)</span>，此时 <span class="math inline">\(u(t)\)</span>
恒正或者恒负，定理只使用绝对值，不妨假设 <span class="math inline">\(u(t)&gt;0\)</span></li>
<li><strong>利普希茨条件</strong></li>
</ul>
<p><span class="math display">\[
u&#39;(t)=f(t,Y(t))-f(t,Z(t))\le L\vert{Y(t)-Z(t)}\vert=Lu(t)
\]</span></p>
<ul>
<li>于是</li>
</ul>
<p><span class="math display">\[
(\ln{u})&#39;=\dfrac{u&#39;}{u}\le L
\]</span></p>
<ul>
<li>均值定理</li>
</ul>
<p><span class="math display">\[
\dfrac{\ln{u(t)}-\ln{u(a)}}{t-a}=(\ln{u(\xi)})&#39;\le L
\]</span></p>
<ul>
<li>转化即得</li>
</ul>
<p><span class="math display">\[
u(t)\le u(a)e^{L(t-a)}
\]</span></p>
<ul>
<li>证毕</li>
</ul>
<h3 id="一阶线性方程">1.3 一阶线性方程</h3>
<ul>
<li>右侧是关于 <span class="math inline">\(y\)</span> 的线性函数</li>
<li>考虑初值问题</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
y&#39;=g(t)y+h(t)\\
y(a)=y_a\\
t\in[a,b]
\end{array}
\]</span></p>
<ul>
<li>如果 <span class="math inline">\(g(t)\)</span> 在区间 <span class="math inline">\([a,b]\)</span>
上连续，则唯一解存在（都取最大值即可）
<ul>
<li>利普希茨常数</li>
</ul></li>
</ul>
<p><span class="math display">\[
L=\max_{[a,b]}g(t)
\]</span></p>
<h4 id="显式求解">显式求解</h4>
<p>要求积分因子 <span class="math inline">\(e^{-\int{g(t)\;\mathrm{d}t}}\)</span> 能够显示表示
<span class="math display">\[
\begin{aligned}
(y&#39;-g(t)y)e^{-\int{g(t)\;\mathrm{d}t}}&amp;=h(t)e^{-\int{g(t)\;\mathrm{d}t}}\\
(ye^{-\int{g(t)\;\mathrm{d}t}})&#39;&amp;=h(t)e^{-\int{g(t)\;\mathrm{d}t}}\\
ye^{-\int{g(t)\;\mathrm{d}t}}&amp;=\int{h(t)e^{-\int{g(t)\;\mathrm{d}t}}}\\
\end{aligned}
\]</span></p>
<ul>
<li>于是</li>
</ul>
<p><span class="math display">\[
y=e^{\int{g(t)\;\mathrm{d}t}}\int{h(t)e^{-\int{g(t)\;\mathrm{d}t}}}
\]</span></p>
<h2 id="ivp-求解器的分析">2. IVP 求解器的分析</h2>
<ul>
<li>IVP（initial value problem）：初值问题</li>
</ul>
<h3 id="局部与全局误差">2.1 局部与全局误差</h3>
<ul>
<li>初值问题</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
y&#39;=f(t,y)\\
y(a)=y_a\\
t\in[a,b]
\end{array}
\]</span></p>
<ul>
<li>一步求解器（如<strong>欧拉方法</strong>）</li>
</ul>
<p><img src="/2021/12/07/computation/pyr/09/image-20211227140521564.png" style="zoom:80%;"></p>
<ul>
<li><strong>单步初值问题</strong></li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
y&#39;=f(t,y)\\
y(t_i)=w_i\\
t\in[t_i,t_{i+1}]
\end{array}
\]</span></p>
<ul>
<li>使用 <span class="math inline">\(z\)</span>
表示单步初值问题的精确解</li>
<li><strong>全局截断误差</strong>：<span class="math inline">\(g_i=\vert{w_i-y_i}\vert\)</span>
<ul>
<li>累计误差</li>
</ul></li>
<li><strong>局部截断误差</strong>：<span class="math inline">\(e_i=\vert{w_i-z(t_i)}\vert\)</span>
<ul>
<li>单步误差</li>
</ul></li>
<li>注意：<strong>全局截断误差不是简单的局部截断误差求和</strong></li>
</ul>
<h4 id="欧拉方法的局部截断误差">欧拉方法的局部截断误差</h4>
<ul>
<li><span class="math inline">\(t_{i+1}=t_i+h\)</span></li>
<li>泰勒展开</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
y(t_i+h)&amp;=y(t_i)+hy&#39;(t_i)+\dfrac{h^2}{2}y&#39;&#39;(c)\\
&amp;=w_i+hf(t_i,w_i)+\dfrac{h^2}{2}y&#39;&#39;(c)\\
\end{aligned}
\]</span></p>
<ul>
<li>欧拉方法</li>
</ul>
<p><span class="math display">\[
w_{i+1}=w_i+hf(t_i,w_i)
\]</span></p>
<ul>
<li>局部截断误差</li>
</ul>
<p><span class="math display">\[
e_{i+1}=\dfrac{h^2}{2}\vert{y&#39;&#39;(c)}\vert
\]</span></p>
<ul>
<li>假设 <span class="math inline">\(y&#39;&#39;\)</span> 在区间 <span class="math inline">\([a,b]\)</span> 的上界为 <span class="math inline">\(M\)</span>，于是欧拉方法的局部截断误差的上界如下</li>
</ul>
<p><span class="math display">\[
e_i\le\dfrac{Mh^2}{2}
\]</span></p>
<h4 id="全局截断误差">全局截断误差</h4>
<ul>
<li>假设步长不变，都为 <span class="math inline">\(h\)</span></li>
<li>初始条件，<span class="math inline">\(y(a)=y_a\)</span></li>
<li>初始全局截断误差：<span class="math inline">\(g_0=0\)</span></li>
<li>第一步
<ul>
<li>没有之前的累计误差</li>
</ul></li>
</ul>
<p><span class="math display">\[
g_1=e_1=\vert{w_1-y_1}\vert
\]</span></p>
<ul>
<li>第二步
<ul>
<li>需要考虑累计误差</li>
<li>第二部分的误差由上面的<a href="#s1">定理</a>给出</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
g_2&amp;=\vert{w_2-y_2}\vert=\vert{w_2-z(t_2)+z(t_2)-y_2}\vert\\
&amp;\le\vert{w_2-z(t_2)}\vert+\vert{z(t_2)-y_2}\vert\\
&amp;=e_2+e^{Lh}g_1\\
&amp;=e_2+e^{Lh}e_1\\
\end{aligned}
\]</span></p>
<ul>
<li>第 <span class="math inline">\(i\)</span> 步</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
g_i&amp;\le e_i+e^{Lh}g_{i-1}\\
&amp;\le\cdots\\
&amp;\le e_i+e^{Lh}e_{i-1}+e^{2Lh}e_{i-2}+\cdots+e^{(i-1)Lh}e_1
\end{aligned}
\]</span></p>
<ul>
<li>于是我们得到了一个全局截断误差的上界估计</li>
<li>一般的我们如果假设 <span class="math inline">\(e_i\le
Ch^{k+1}\)</span>，于是全局截断误差如下</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
g_i&amp;\le\dfrac{Ch^{k+1}(e^{iLh}-1)}{e^{Lh}-1}\\
&amp;\le\dfrac{Ch^{k+1}(e^{iLh}-1)}{Lh}\\
&amp;=\dfrac{Ch^{k}(e^{iLh}-1)}{L}\\
\end{aligned}
\]</span></p>
<ul>
<li>例如，欧拉方法的全局截断误差
<ul>
<li><span class="math inline">\(C=\dfrac{M}{2},k=1\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
g_i\le\dfrac{Ch^{k}(e^{iLh}-1)}{L}=\dfrac{Mh(e^{iLh}-1)}{2L}
\]</span></p>
<h5 id="定理描述">定理描述</h5>
<p><img src="/2021/12/07/computation/pyr/09/image-20211227144216828.png" style="zoom:80%;"></p>
<ul>
<li>如果当 <span class="math inline">\(h\to0\)</span> 的时候，<span class="math inline">\(g_i\to0\)</span>，则称上述求解器为 <span class="math inline">\(k\)</span> 阶方法</li>
</ul>
<h5 id="欧拉方法的收敛性">欧拉方法的收敛性</h5>
<p><img src="/2021/12/07/computation/pyr/09/image-20211227144549105.png" style="zoom:80%;"></p>
<ul>
<li>欧拉方法是 <strong>1 阶方法</strong>
<ul>
<li>欧拉方法构造简单，但是阶数低，近似程度不够</li>
<li>优化：<strong>提高阶数</strong></li>
</ul></li>
</ul>
<h3 id="显式梯形方法">2.2 显式梯形方法</h3>
<p><span class="math display">\[
\begin{aligned}
w_0&amp;=y_0\\
w_{i+1}&amp;=w_i+h\dfrac{f(t_i,w_i)+f(t_i+h,w_i+hf(t_i,w_i))}{2}
\end{aligned}
\]</span></p>
<ul>
<li>直观上讲
<ul>
<li>欧拉方法离散步的斜率从区间 <span class="math inline">\([t_i,t_{i+1}]\)</span>
的<strong>左端点</strong></li>
<li>显式梯形方法离散步的斜率是区间 <span class="math inline">\([t_i.t_{i+1}]\)</span>
的<strong>左右端点均值</strong></li>
</ul></li>
<li><strong>显式方法</strong>：右端点的属性可以通过现有的值计算</li>
<li><strong>梯形方法</strong>：如果 <span class="math inline">\(f(t,y)\)</span> 和 <span class="math inline">\(y\)</span> 无关，那么便是梯形公式</li>
<li>也被称为
<ul>
<li><strong>改进的欧拉方法</strong></li>
<li><strong>Heun 方法</strong></li>
</ul></li>
</ul>
<h4 id="局部截断误差">局部截断误差</h4>
<ul>
<li>对微分方程 <span class="math inline">\(y&#39;=f(t,y)\)</span> 两边对
<span class="math inline">\(t\)</span> 求偏导</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
y&#39;&#39;(t)
&amp;=\dfrac{\partial{f}}{\partial{t}}(t,y)+\dfrac{\partial{f}}{\partial{y}}(t,y)y&#39;(t)\\
&amp;=\dfrac{\partial{f}}{\partial{t}}(t,y)+\dfrac{\partial{f}}{\partial{y}}(t,y)f(t,y)\\
\end{aligned}
\]</span></p>
<ul>
<li>泰勒展开</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
y_{i+1}
&amp;=y(t_i+h)\\
&amp;=y(t_i)+hy&#39;(t_i)+\dfrac{h^2}{2}y&#39;&#39;(t_i)+\dfrac{h^3}{6}y&#39;&#39;(c)\\
&amp;=y(t_i)+hy&#39;(t_i)+\dfrac{h^2}{2}\left(\dfrac{\partial{f}}{\partial{t}}(t_i,y_i)+\dfrac{\partial{f}}{\partial{y}}(t_i,y_i)f(t_i,y_i)\right)+\dfrac{h^3}{6}y&#39;&#39;&#39;(c)\\
\end{aligned}
\]</span></p>
<ul>
<li>显式梯形方法（二维泰勒展开）</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;f(t_i+h,y_i+hf(t_i,y_i))\\
=&amp;f(t_i,y_i)+h\dfrac{\partial{f}}{\partial{t}}(t_i,y_i)+hf(t_i,y_i)\dfrac{\partial{f}}{\partial{y}}(t_i,y_i)+O(h^2)\\
\end{aligned}
\]</span></p>
<ul>
<li>于是改写</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
w_{i+1}
&amp;=y_i+h\dfrac{f(t_i,y_i)+f(t_i+h,y_i+hf(t_i,y_i))}{2}\\
&amp;=y_i+hf(t_i,y_i)+\dfrac{h^2}{2}\left(\dfrac{\partial{f}}{\partial{t}}(t_i,y_i)+f(t_i,y_i)\dfrac{\partial{f}}{\partial{y}}(t_i,y_i)\right)+O(h^3)\\
\end{aligned}
\]</span></p>
<ul>
<li>于是得到局部截断误差</li>
</ul>
<p><span class="math display">\[
e_{i+1}=y_{i+1}-w_{i+1}=O(h^3)
\]</span></p>
<ul>
<li>显式梯形方法是 <span class="math inline">\(2\)</span> 阶方法</li>
<li><strong>复杂度讨论</strong>
<ul>
<li>显示梯形方法：更高阶，计算函数的次数变成了 2 倍</li>
<li>如何比较：<strong>相同计算代价下比较</strong></li>
<li>欧拉方法步长缩短一半，此时计算代价相同，但是此时全局误差只是变成了
<span class="math inline">\(\dfrac{1}{2}\)</span>，阶数没有改变，因此显式梯形方法更好</li>
</ul></li>
</ul>
<h3 id="泰勒方法">2.3 泰勒方法</h3>
<ul>
<li><strong>所有阶数的方法都存在</strong></li>
<li><span class="math inline">\(k\)</span> 阶泰勒方法</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
w_0&amp;=y_0\\
w_{i+1}&amp;=w_i+h{f(t_i,w_i)}+\dfrac{h^2}{2}f&#39;(t_i,w_i)+\dfrac{h^3}{6}f&#39;&#39;(t_i,w_i)+\cdots+\dfrac{h^k}{k!}f^{(k-1)}(t_i,w_i)
\end{aligned}
\]</span></p>
<p><span class="math display">\[
f&#39;(t,y)=f_t(t,y)+f_y(t,y)y&#39;(t)=f_t(t,y)+f_y(t,y)f(t,y)
\]</span></p>
<ul>
<li><p>很容易得到，局部截断误差为 <span class="math inline">\(O(h^{k+1})\)</span>，因此是 <span class="math inline">\(k\)</span> 阶方法</p></li>
<li><p><strong>一阶泰勒方法就是欧拉方法</strong></p></li>
</ul>
<h4 id="二阶泰勒方法">二阶泰勒方法</h4>
<p><span class="math display">\[
\begin{aligned}
w_{i+1}&amp;=w_i+h{f(t_i,w_i)}+\dfrac{h^2}{2}f&#39;(t_i,w_i)\\
&amp;=w_i+h{f(t_i,w_i)}+\dfrac{h^2}{2}(f_{t}(t_i,y_i)+f_y(t_i,y_i)f(t_i,y_i))\\
\end{aligned}
\]</span></p>
<ul>
<li>概念上，泰勒方法告诉我们任何阶的ODE方法都存在
<ul>
<li>但是，该方法由于计算公式中出现的函数 <span class="math inline">\(f\)</span> 的偏导数，本身的性能也有损失</li>
<li>由于可以推出相同阶但是不需要计算偏导数的方法，泰勒方法仅仅用于特定的用途</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 的一些记录</title>
    <url>/2021/10/16/csharp/Kits/kits/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1001663016">中国大学慕课</a></li>
</ul>
<h1 id="csharp">CSharp</h1>
<h2 id="form">1. Form</h2>
<ul>
<li>设置 Form 大小不可变</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.MaximizeBox = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">this</span>.FormBorderStyle =</span><br><span class="line">    System.Windows.Forms.FormBorderStyle.FixedSingle;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取 Form 内部区域大小</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.ClientSize.Width;</span><br><span class="line"><span class="keyword">this</span>.ClientSize.Height;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>csharp.kits</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法B.裴玉茹.09.常微分方程(5)</title>
    <url>/2021/12/29/computation/pyr/09-4/</url>
    <content><![CDATA[<ul>
<li>PPT（常微分方程）</li>
</ul>
<h1 id="常微分方程">常微分方程</h1>
<ul>
<li><strong><span style="color:red">这里的局部截断误差都使用 PPT
的定义好了（需要除以步长 <span class="math inline">\(h\)</span>
）</span></strong></li>
</ul>
<h2 id="引子">1. 引子</h2>
<h3 id="神经-ode">神经 ODE</h3>
<ul>
<li>残差网络跳连</li>
</ul>
<p><span class="math display">\[
h_{l+1}=h_{l}+\textrm{NNetwork}(h_l)
\]</span></p>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229113335987.png" style="zoom: 67%;"></p>
<ul>
<li>ODE 前向欧拉方法</li>
</ul>
<p><span class="math display">\[
h_{N}=h_{N-1}+\Delta tg((N-1)\Delta t,h_{N-1})
\]</span></p>
<ul>
<li>神经 ODE
<ul>
<li>把跳连使用 ODE 替换</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
h_{t+1}&amp;=h_{t}+f(h_t,\theta_t)\\
\dfrac{\mathrm{d}h(t)}{\mathrm{d}t}&amp;=f(h(t),t,\theta)
\end{aligned}
\]</span></p>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229113620302.png" style="zoom: 33%;"></p>
<h2 id="常微分方程初值问题">2. 常微分方程初值问题</h2>
<ul>
<li>IVP：initial value problem</li>
</ul>
<h3 id="利普希茨条件">利普希茨条件</h3>
<ul>
<li>Lipschitz 条件</li>
<li>凸集</li>
<li>初值问题的唯一解定理
<ul>
<li>利普希茨连续条件</li>
</ul></li>
</ul>
<h3 id="恰定问题">恰定问题</h3>
<ul>
<li><p>well-posed</p></li>
<li><p>如果初值问题 <span class="math inline">\(\dfrac{\mathrm{d}y}{\mathrm{d}t}=f(t,y),t\in[a,b],y(a)=\alpha\)</span>
满足如下两个条件，则是一个<strong>恰定问题</strong></p></li>
<li><ol type="1">
<li>存在唯一解 <span class="math inline">\(y(t)\)</span></li>
</ol></li>
<li><ol start="2" type="1">
<li>对于任意 <span class="math inline">\(\epsilon\)</span>，存在正常数
<span class="math inline">\(\vert\epsilon_0\vert&lt;\epsilon\)</span>，满足
<span class="math inline">\(\delta(t)\le\epsilon\)</span>，在 <span class="math inline">\([a,b]\)</span> 上连续，有如下问题的唯一解 <span class="math inline">\(z(t)\)</span> <span class="math display">\[
  \dfrac{\mathrm{d}z}{\mathrm{d}t}=f(t,z)+\delta(t),t\in[a,b],z(a)=\alpha+\epsilon_0
  \]</span></li>
</ol>
<ul>
<li>存在 <span class="math inline">\(k&gt;0\)</span>，<span class="math inline">\(\vert{z(t)-y(t)}\vert&lt;k\epsilon\)</span>，<span class="math inline">\(t\in[a,b]\)</span></li>
</ul></li>
<li><p>条件 (2)
的含义就是，初始值有误差，计算有误差，结果的误差不至于太大（<strong>线性</strong>）</p></li>
</ul>
<h2 id="欧拉方法">3. 欧拉方法</h2>
<p><span class="math display">\[
\begin{aligned}
w_0&amp;=\alpha\\
w_{i+1}&amp;=w_i+hf(t_i,w_i),\quad i\in\N\\
\end{aligned}
\]</span></p>
<ul>
<li>二阶</li>
<li>示例图</li>
</ul>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229121240514.png" style="zoom:80%;"></p>
<h3 id="误差证明">误差证明</h3>
<ul>
<li>教材上的证明是通过局部截断误差来得到全局截断误差</li>
<li>PPT 上的方法如下</li>
</ul>
<h4 id="引理1">引理1</h4>
<p><span class="math display">\[
\forall x\ge-1,\forall m&gt;0\Longrightarrow0\le(1+x)^m\le e^{mx}
\]</span></p>
<ul>
<li>泰勒展开</li>
</ul>
<p><span class="math display">\[
\begin{array}{c}
e^{x}=1+x+\dfrac{1}{2}x^2e^{\xi}\ge1+x\ge0\\
(e^x)^{m}\ge(x+1)^{m}\ge0\\
\end{array}
\]</span></p>
<h4 id="引理2">引理2</h4>
<ul>
<li>正实数 <span class="math inline">\(s,t\)</span>，序列 <span class="math inline">\(\{a_i\}_{i=0}^{k}\)</span> 满足 <span class="math inline">\(a_0\ge-\dfrac{t}{s}\)</span>，<span class="math inline">\(a_{i+1}\le (1+s)a_i+t\)</span>，则有</li>
</ul>
<p><span class="math display">\[
a_{i+1}\le e^{(i+1)s}(a_0+\dfrac{t}{s})-\dfrac{t}{s}
\]</span></p>
<ul>
<li>一步步代入即可证明</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
a_{i+1}&amp;\le(1+s)a_i+t\\
&amp;\le(1+s)^2a_{i-1}+t(1+(1+s))\\
&amp;\cdots\\
&amp;\le(1+s)^{i+1}a_0+t\dfrac{(1+s)^{i+1}-1}{s}\\
&amp;=(1+s)^{i+1}\left(a_0+\dfrac{t}{s}\right)-\dfrac{t}{s}\\
&amp;\le e^{(i+1)s}(a_0+\dfrac{t}{s})-\dfrac{t}{s}
\end{aligned}
\]</span></p>
<h4 id="欧拉方法误差界">欧拉方法误差界</h4>
<ul>
<li>利普希茨常数 <span class="math inline">\(L\)</span>，<span class="math inline">\(\vert{y&#39;&#39;}\vert\le M\)</span></li>
</ul>
<p><span class="math display">\[
\vert{y(t_i)-w_i}\vert\le\dfrac{hM}{2L}(e^{(t_i-a)L}-1)
\]</span></p>
<ul>
<li>泰勒展开</li>
</ul>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229141715650.png" style="zoom:80%;"></p>
<ul>
<li>使用引理 2 即可</li>
</ul>
<h3 id="确定步长">确定步长</h3>
<ul>
<li>综合考虑<strong>截断误差</strong>与<strong>舍入误差</strong>
<ul>
<li>认为 <span class="math inline">\(\delta_i&lt;\delta\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229143313448.png" style="zoom:80%;"></p>
<h2 id="高阶泰勒方法">4. 高阶泰勒方法</h2>
<ul>
<li><span class="math inline">\(n\)</span> 阶泰勒方法，把 <span class="math inline">\(y\)</span> 展开到 <span class="math inline">\(n\)</span> 阶，误差为 <span class="math inline">\(n+1\)</span> 阶
<ul>
<li>即 <span class="math inline">\(f(t,y)\)</span> 展开到 <span class="math inline">\(n-1\)</span> 阶</li>
</ul></li>
<li>定义如下</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
w_0&amp;\approx{\alpha}\\
w_{i+1}&amp;=w_i+hT^{(n)}(t_i,w_i)
\end{aligned}
\]</span></p>
<ul>
<li>其中 <span class="math inline">\(T^{(n)}(t,y)\)</span> 定义如下</li>
</ul>
<p><span class="math display">\[
T^{(n)}(t,y)=f(t,y)+\dfrac{h}{2}f&#39;(t,y)+\dfrac{h^2}{6}f&#39;&#39;(t,y)+\cdots+\dfrac{h^{n-1}}{n!}f^{n-1}(t,y)
\]</span></p>
<ul>
<li>带入上面的式子，可以发现其实就是把 <span class="math inline">\(y(t_{i+1})\)</span> 在 <span class="math inline">\(t_i\)</span> 处进行了 <span class="math inline">\(n\)</span> 阶泰勒展开</li>
</ul>
<h3 id="局部截断误差书本">局部截断误差(书本)</h3>
<ul>
<li>书上的定义</li>
<li><span class="math inline">\(n\)</span> 阶泰勒公式
<ul>
<li><span class="math inline">\(n\)</span> 阶 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(n+1\)</span> 阶局部截断误差 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(n\)</span> 阶全局误差</li>
</ul></li>
</ul>
<h3 id="局部截断误差ppt">局部截断误差(PPT)</h3>
<p><span class="math display">\[
\begin{aligned}
w_0&amp;\approx{\alpha}\\
w_{i+1}&amp;=w_i+h\phi(t_i,w_i)
\end{aligned}
\]</span></p>
<ul>
<li>按照 PPT 上的定义，局部截断误差定义如下
<ul>
<li>和书上相比除了一个 <span class="math inline">\(h\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\tau_{i+1}(h)=\dfrac{y_{i+1}-(y_i+h\phi(t_i,w_i))}{h}=\dfrac{y_{i+1}-y_i}{h}-\phi(t_i,w_i)
\]</span></p>
<ul>
<li>如此定义的话
<ul>
<li><span class="math inline">\(n\)</span> 阶 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(n\)</span> 阶局部误差 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(n\)</span> 阶全局误差</li>
</ul></li>
</ul>
<h2 id="插值">5. 插值</h2>
<ul>
<li>除了等间距格点上的函数值，其它位置的函数值如何计算？
<ul>
<li><strong>插值</strong></li>
</ul></li>
<li>线性插值、Hermit 插值</li>
</ul>
<h2 id="runge-kutta方法">6. Runge-Kutta方法</h2>
<ul>
<li>具有高阶泰勒方法的局部截断误差</li>
<li>无需计算函数 <span class="math inline">\(f(t,y)\)</span> 的导数</li>
</ul>
<h3 id="二维泰勒展开">二维泰勒展开</h3>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229151615517.png" style="zoom:80%;"></p>
<h3 id="rk2">RK2</h3>
<ul>
<li><strong>如何构造 k 阶龙格库塔方法？</strong></li>
<li>例如 RK2，局部截断误差 <span class="math inline">\(O(h^2)\)</span>
<ul>
<li>PPT 定义（除以 <span class="math inline">\(h\)</span> 后）</li>
</ul></li>
<li>但是外面会乘一个 <span class="math inline">\(h\)</span>，只需要将
<span class="math inline">\(f(t,y)\)</span> 二阶展开
<ul>
<li>因为是对<strong>斜率</strong>进行估计</li>
</ul></li>
<li>引入如下函数，使其与二阶泰勒公式 <span class="math inline">\(T^{2}(t,y)\)</span> 一致</li>
</ul>
<p><span class="math display">\[
a_1f(t+\alpha_1,y+\beta_1)
\]</span></p>
<ul>
<li><strong>对应项系数相等</strong></li>
</ul>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229152423255.png" style="zoom:80%;"></p>
<h3 id="rk3">RK3</h3>
<ul>
<li><span class="math inline">\(T^{3}(t,y)\)</span> 展开</li>
</ul>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229152650899.png" style="zoom:80%;"></p>
<ul>
<li>改进欧拉方法</li>
</ul>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229152810254.png" style="zoom:80%;"></p>
<ul>
<li>Heun 方法</li>
</ul>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229152839469.png" style="zoom:80%;"></p>
<h3 id="rk4">RK4</h3>
<h3 id="同伦与延拓方法">同伦与延拓方法</h3>
<ul>
<li>求解方程组的解转化为 ODE 的初值问题
<ul>
<li><a href="/2021/10/14/computation/pyr/03-3/#同伦和延拓方法">问题描述</a></li>
</ul></li>
</ul>
<h3 id="龙格库塔方法">龙格库塔方法</h3>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229153548975.png" style="zoom:80%;"></p>
<ul>
<li>计算代价包含每步中<strong>函数值的计算</strong></li>
</ul>
<h2 id="可变步长方法">7. 可变步长方法</h2>
<h3 id="runge-kutta-fehlberg-方法">Runge-Kutta-Fehlberg 方法</h3>
<ul>
<li>利用 <span class="math inline">\((n+1)\)</span>
阶方法作为真值评估误差</li>
<li>记号</li>
</ul>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229154501024.png" style="zoom:80%;"></p>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229154524400.png" style="zoom:80%;"></p>
<ul>
<li>估计局部截断误差，认为 <span class="math inline">\(w_i=y(t_i)=\tilde{w}_i\)</span></li>
</ul>
<p><span class="math display">\[
\tau_{i+1}(h)=\dfrac{y(t_{i+1})-y(t_{i})}{h}-\phi(t_i,y(t_i),h)=\dfrac{y(t_{i+1})-w_{i+1}}{h}
\]</span></p>
<p><span class="math display">\[
\tilde{\tau}_{i+1}(h)=\dfrac{y(t_{i+1})-\tilde{w}_{i+1}}{h}
\]</span></p>
<ul>
<li>估计误差
<ul>
<li><span class="math inline">\(q\)</span>
为步长修正系数（要求如何选择步长）</li>
<li>这里使用绝对误差 <span class="math inline">\(\epsilon\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229155046061.png" style="zoom:80%;"></p>
<ul>
<li>对比
<ul>
<li>RK 4/5：共需要10（4+6）次函数值计算</li>
<li>RKF 4/5：共需要 6 次函数值计算</li>
</ul></li>
</ul>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229155405389.png" style="zoom:80%;"></p>
<ul>
<li>修正步长
<ul>
<li><span class="math inline">\(q&lt;1\)</span>：说明需要减小步长，之前的计算超出了要求的误差界
<ul>
<li>因此需要拒绝 <span class="math inline">\(h\)</span>，加大步长值重新计算</li>
</ul></li>
<li><span class="math inline">\(q\ge1\)</span>：接受当前步的计算，为下一步设置合适的
<span class="math inline">\(h\)</span></li>
</ul></li>
</ul>
<h2 id="多步方法">8. 多步方法</h2>
<ul>
<li>显式方法、隐式方法
<ul>
<li><span class="math inline">\(b_m{\buildrel\rm{?}\over=}0\)</span>（PPT
定义和书上顺序反一下）</li>
</ul></li>
</ul>
<h3 id="插值多项式近似">插值多项式近似</h3>
<p><span class="math display">\[
y(t_{i+1})-y(t_i)=\int_{t_i}^{t_{i+1}}f(t,y)\;\mathrm{d}t\approx\int_{t_i}^{t_{i+1}}P(y)\;\mathrm{d}t
\]</span></p>
<h3 id="构造多步方法">构造多步方法</h3>
<ul>
<li><a href="/2021/12/28/computation/pyr/09-3/#构造多步方法">构造多步方法</a></li>
</ul>
<h3 id="adams-方法">Adams 方法</h3>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229160935687.png" style="zoom:80%;"></p>
<h3 id="后向欧拉方法">后向欧拉方法</h3>
<ul>
<li>隐式方法</li>
</ul>
<h3 id="预测矫正方法">预测矫正方法</h3>
<ul>
<li>考虑四阶方法
<ul>
<li>利用四阶单步法计算起始值 <span class="math inline">\(w_0,w_1,w_2,w_3\)</span></li>
<li>利用四步显式 Adams-Bashforth 方法计算 <span class="math inline">\(w_4\)</span></li>
<li>利用三步隐式 Adams-Moulton 方法进行矫正</li>
</ul></li>
</ul>
<h3 id="可变步长多步方法">可变步长多步方法</h3>
<ul>
<li>预测、矫正、根据矫正的误差选择新的步长</li>
</ul>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229161535317.png" style="zoom:80%;"></p>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229161833977.png" style="zoom:80%;"></p>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229162024095.png" style="zoom:80%;"></p>
<h3 id="外推方法">外推方法</h3>
<ul>
<li>外推方法引入更多函数计算改进近似精度
<ul>
<li><strong>消去低阶项</strong></li>
</ul></li>
<li>例子如下</li>
</ul>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229162903958.png" style="zoom:80%;"></p>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229162916621.png" style="zoom:80%;"></p>
<h3 id="稳定性">稳定性</h3>
<ul>
<li>相容一致（consistent）
<ul>
<li>局部截断误差至少一阶</li>
</ul></li>
</ul>
<p><span class="math display">\[
\lim_{h\to0}\max_{1\le i\le N}\vert{\tau_i(h)}\vert=0
\]</span></p>
<ul>
<li>收敛</li>
</ul>
<p><span class="math display">\[
\lim_{h\to0}\max_{1\le i\le N}\vert{w_i-y(t_i)}\vert=0
\]</span></p>
<h4 id="单步方法">单步方法</h4>
<ul>
<li><strong>相容一致只需要证明红框内部分即可</strong></li>
</ul>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229163609387.png" style="zoom:80%;"></p>
<h4 id="多步方法-1">多步方法</h4>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229164141975.png" style="zoom:80%;"></p>
<ul>
<li>在如下两个假设之下定义收敛、一致</li>
</ul>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229164223445.png" style="zoom:80%;"></p>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229164237101.png" style="zoom:80%;"></p>
<ul>
<li>多步方法特征多项式</li>
</ul>
<p><img src="/2021/12/29/computation/pyr/09-4/image-20211229164513529.png" style="zoom:80%;"></p>
<ul>
<li><strong>根条件</strong>
<ul>
<li><span class="math inline">\(\lambda_i\le1\)</span>，所有绝对值为 1
的根都是单根</li>
</ul></li>
<li>多步方法稳定当且仅当其满足根条件</li>
<li>如果方法与微分方程相容一致，则该方法稳定当且仅当其收敛</li>
<li>稳定性
<ul>
<li>强稳定（满足根条件，绝对值为 1 的根只有 1）</li>
<li>弱稳定（满足根条件，，绝对值为 1 的根不止一个）</li>
<li>不稳定（不满足根条件）</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>computation.pyr</category>
      </categories>
      <tags>
        <tag>computation</tag>
      </tags>
  </entry>
  <entry>
    <title>C#程序设计.唐大仕.00.说明</title>
    <url>/2021/09/16/csharp/tds/00/</url>
    <content><![CDATA[<h1 id="说明">说明</h1>
<ul>
<li>课程名称：C#程序设计</li>
<li>授课老师：<a href="http://www.dstang.com/books_dstang/">唐大仕</a></li>
<li>课程链接：<a href="https://www.icourse163.org/learn/PKU-1001663016">中国大学慕课</a></li>
</ul>
<h2 id="环境">环境</h2>
<ul>
<li>VS2017</li>
<li>Net 4.6.1</li>
</ul>
]]></content>
      <categories>
        <category>0</category>
        <category>csharp.tds</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#程序设计.唐大仕.01.C#程序设计简介</title>
    <url>/2021/09/16/csharp/tds/01/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1001663016">中国大学慕课</a></li>
</ul>
<h1 id="c-程序设计简介">C# 程序设计简介</h1>
<h2 id="c-语言简介">C# 语言简介</h2>
<ul>
<li>历史
<ul>
<li>C（60年代） -&gt; C++（面向对象，内容多，复杂） -&gt; Java（1995）
-&gt; C#（2001/2002）</li>
<li>Java：C++--</li>
</ul></li>
<li>面向对象</li>
<li>简单，安全</li>
<li>与 Web/Mobile 的紧密结合</li>
<li>C#之父 —— Anders Hejlsberg
<ul>
<li>pascal 的发明者之一</li>
</ul></li>
<li>C# 为了对抗 Java 而推出的</li>
</ul>
<h2 id="net">.NET</h2>
<p><img src="/2021/09/16/csharp/tds/01/image-20210916225916542.png" style="zoom: 67%;"></p>
<ul>
<li>通用的编程模型</li>
<li>包括客户端、服务器和应用服务</li>
<li>开发工具</li>
</ul>
<h3 id="历程">历程</h3>
<p><img src="/2021/09/16/csharp/tds/01/image-20210916230059078.png" style="zoom: 67%;"></p>
<h3 id="跨平台">跨平台</h3>
<ul>
<li>现在推出的 .NET Core 是其跨平台的版本
<ul>
<li>https://dotnet.github.io/</li>
<li>微软开布的跨平台的开源系统</li>
<li>可运行于 linux 及 mac 平台上</li>
<li>类库大部分是兼容的</li>
<li>开源的 mono 项目可以有 gui 界面
<ul>
<li>https://www.mono-project.com/</li>
</ul></li>
</ul></li>
<li>另外 ，还有用 C# 开发跨平台的手机程序
<ul>
<li>Xamarin</li>
</ul></li>
<li>.Net 5 整合了 .net standard, .net core, mono 等
<ul>
<li>即将发布</li>
</ul></li>
</ul>
<h3 id="net-5">.NET 5</h3>
<p><img src="/2021/09/16/csharp/tds/01/image-20210916230334101.png" style="zoom: 67%;"></p>
<h3 id="net-版本">.NET 版本</h3>
<p><img src="/2021/09/16/csharp/tds/01/image-20210916230418590.png" style="zoom: 67%;"></p>
<ul>
<li><a href="https://baike.baidu.com/view/1312598.htm">dotnet framework
版本历史</a></li>
</ul>
<h3 id="架构语言工具">架构、语言、工具</h3>
<p><img src="/2021/09/16/csharp/tds/01/image-20210916230505038.png" style="zoom: 67%;"></p>
<h3 id="统一的编程-apinet-framework-类">统一的编程 API：NET Framework
类</h3>
<p><img src="/2021/09/16/csharp/tds/01/image-20210916230547254.png" style="zoom:67%;"></p>
<h3 id="net-主要特性">.NET 主要特性</h3>
<ul>
<li>简单的开发和部署</li>
<li>统一的编程模型</li>
<li>提供健壮、安全的执行环境</li>
<li>支持多种编程语言</li>
<li>丰富的类库支持</li>
</ul>
<h2 id="公共语言运行时-clr">公共语言运行时（ CLR ）</h2>
<ul>
<li>common language runtime</li>
<li>设计目标
<ul>
<li>简化开发：安全性、内存管理</li>
<li>简化应用程序部署</li>
<li>基类库</li>
<li>支持多种语言</li>
</ul></li>
<li>相当于 Java 中的虚拟机</li>
</ul>
<h3 id="编译和执行">编译和执行</h3>
<p><img src="/2021/09/16/csharp/tds/01/image-20210916230840853.png" style="zoom:67%;"></p>
<ul>
<li>.exe 文件中不是 CPU
指令，而是中间代码，在执行的时候即时编译成本机代码执行
<ul>
<li>IL 指令（ Intermediate Language) CIL MSIL</li>
<li>元信息</li>
</ul></li>
<li>反编译的工具
<ul>
<li>ildasm.exe 或用 ILSpy</li>
<li>C:FilesSDKs.1A.1 Tools<br>
</li>
</ul></li>
</ul>
<h2 id="学习网站">学习网站</h2>
<ul>
<li><p><a href="https://msdn.microsoft.com/">https://msdn.microsoft.com</a></p></li>
<li><p><a href="https://www.cnblogs.com/">https://www.cnblogs.com</a>
(中文，强烈推荐)</p></li>
<li><p><a href="https://www.codeplex.com/">https://www.codeplex.com</a>
(源码，强烈推荐)</p></li>
<li><p><a href="https://www.codeproject.com/">https://www.codeproject.com</a>
(英文，强烈推荐)</p></li>
<li><p>https://code.msdn.microsoft.com/ (推荐)</p></li>
<li><p><a href="https://www.asp.net/">https://www.asp.net</a></p></li>
<li><p><a href="https://www.gotdotnet.com/">https://www.gotdotnet.com</a></p></li>
<li><p><a href="https://www.windowsforms.com/">https://www.windowsforms.com</a></p></li>
<li><p><a href="https://www.c-sharpcorner.com/">https://www.c-sharpcorner.com</a></p></li>
<li><p><a href="www.microsoft.com/chain/msdn">www.microsoft.com/chain/msdn</a></p></li>
<li><p>Framework 文档</p>
<ul>
<li><a href="http://msdn.microsoft.com/zh-cn/library/">http://msdn.microsoft.com/zh-cn/library/</a></li>
<li>或者：<a href="http://msdn.microsoft.com">http://msdn.microsoft.com</a>
<ul>
<li>文档--&gt;.NET开发--&gt;。Net
framework4.5--&gt;.NetFramework类库</li>
</ul></li>
<li>或者： <a href="http://msdn.microsoft.com/zh-cn/library/gg145045(v=vs.110).aspx">http://msdn.microsoft.com/zh-cn/library/gg145045(v=vs.110).aspx</a></li>
</ul></li>
<li><p>基本库的源程序</p>
<ul>
<li><a href="http://referencesource.microsoft.com">http://referencesource.microsoft.com</a></li>
</ul></li>
</ul>
<h2 id="c-快速入门">C# 快速入门</h2>
<ul>
<li>windows 窗体程序</li>
<li>Shift+F7：界面设计</li>
<li>修改属性：属性窗口</li>
<li>添加事件：属性窗口中的 “闪电” 标志</li>
</ul>
<p><img src="/2021/09/16/csharp/tds/01/image-20210919165407523.png" style="zoom:67%;"></p>
<ul>
<li><p>保存</p>
<ul>
<li>程序文件 .cs</li>
<li>工程文件 .csproj</li>
<li>解决方案 .sln</li>
</ul></li>
<li><p>对象</p>
<ul>
<li>属性 property</li>
<li>方法 method</li>
<li>事件 event</li>
</ul>
<p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.button1.Click += <span class="keyword">new</span> System.EventHandler(<span class="keyword">this</span>.button1_Click);</span><br><span class="line"><span class="comment">// 或简写如下</span></span><br><span class="line"><span class="keyword">this</span>.button1.Click += <span class="keyword">this</span>.button1_Click;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Timer 控件可以设置自动触发事件</p></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用(导入)</span></span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="comment">// 命名空间(为了我们的类和别人的不重名)</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">xxxxxx</span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 继承（用冒号表示）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">System.Windows.Forms.Form</span></span><br></pre></td></tr></table></figure>
<ul>
<li>自动生成的代码
<ul>
<li>对象的生成(new)</li>
<li>事件的注册(+=)</li>
</ul></li>
<li>如果设置了控件的 autosize 属性为 true，那么 size 属性失效</li>
</ul>
<h2 id="基本应用类型">基本应用类型</h2>
<h3 id="常见应用程序类型">常见应用程序类型</h3>
<ul>
<li>控制台程序</li>
<li>Windows 应用程序
<ul>
<li>WPF 程序</li>
</ul></li>
<li>Web 应用程序
<ul>
<li>Mobile 应用程序</li>
</ul></li>
</ul>
<h3 id="控制台程序">控制台程序</h3>
<ul>
<li>helloworld.cs</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类定义
<ul>
<li>程序的基本组成部分是类(class)，如本例中的HelloWorld类。</li>
</ul></li>
<li>Main() 方法
<ul>
<li>程序的入口是Main()方法。它有固定的书写格式：
<ul>
<li>public static void Main(string [] args) {}</li>
<li>可以没有 public，可以没有 string [] args</li>
</ul></li>
</ul></li>
<li><code>ctrl + F5</code> 能够让程序运行完停一会</li>
</ul>
<h3 id="windows-应用程序">Windows 应用程序</h3>
<ul>
<li>又被称为是 WinForm 应用</li>
<li>可视化的设计窗体</li>
<li>事件驱动的编程机制</li>
</ul>
<h3 id="wpf-程序">WPF 程序</h3>
<ul>
<li>Windows Presentation Foundation</li>
<li>在 Windows 上运行</li>
<li>使用 XML（xmal）来定义界面</li>
</ul>
<h3 id="web-应用程序">Web 应用程序</h3>
<ul>
<li>在.NET中也称 ASP.NET 应用程序
<ul>
<li>Active Server Page</li>
</ul></li>
<li>应用程序在服务器上运行，客户端使用浏器（如IE）来进行输入输出</li>
<li>使用 html/css 来定义界面</li>
<li>这种方式称为 B/S（Browser/Server）方式</li>
<li>与传统的 C/S（Client/Server）相区别</li>
<li>B/S 应用程序在使用、部署上有独特的优势</li>
</ul>
<h3 id="mobile-应用程序">Mobile 应用程序</h3>
<ul>
<li>又称 Windows Phone 程序</li>
<li>运行于手机、PDA 等移动设备</li>
<li>大部分类是与 windows 兼容的，但功能有裁减</li>
<li>另外，Xamarin 可以开发跨平台的手机应用
<ul>
<li>(win phone, android, iphone)</li>
</ul></li>
</ul>
<h3 id="比较">比较</h3>
<p><img src="/2021/09/16/csharp/tds/01/image-20210921152946420.png" style="zoom: 67%;"></p>
<p><img src="/2021/09/16/csharp/tds/01/image-20210921153058369.png" style="zoom:67%;"></p>
<h2 id="程序中的输入与输出">程序中的输入与输出</h2>
<h3 id="winform">WinForm</h3>
<ul>
<li>直接使用控件实现</li>
<li>在 win10 中，默认缩放为 125%，winform 的 .exe 文件会有放大模糊的问题
<ul>
<li>可以对 bin/Debug/xxx.exe 进行如下设置</li>
<li>属性 -&gt; 兼容性 -&gt; 更改高 DPI 设置 -&gt; 替代高 DPI
缩放行为，缩放执行：应用程序</li>
</ul></li>
</ul>
<p><img src="/2021/09/16/csharp/tds/01/image-20210919212415520.png" style="zoom:67%;"></p>
<h3 id="控制台应用程序">控制台应用程序</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">string</span> s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            Console.Write(<span class="string">&quot;Please input a line: &quot;</span>);</span><br><span class="line">            s = Console.ReadLine();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;You have entered: &#123;0&#125;&quot;</span>, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开发工具">开发工具</h2>
<h3 id="一些开发工具">一些开发工具</h3>
<p><img src="/2021/09/16/csharp/tds/01/image-20210919213120184.png" style="zoom:80%;"></p>
<ul>
<li><a href="https://visualstudio.microsoft.com/zh-hans/downloads/">Visual
Studio</a></li>
<li><a href="https://www.editplus.com/">EditPlus</a></li>
<li><a href="http://www.icsharpcode.net/">SharpDeveloper</a></li>
<li><a href="http://www.sliver.com/dotnet/SnippetCompiler/">SnippetCompiler</a></li>
<li>Linux：<a href="https://www.mono-project.com/">Mono</a></li>
</ul>
<h3 id="editplus-配置">EditPlus 配置</h3>
<h4 id="设定语法加亮文件">设定语法加亮文件</h4>
<ul>
<li>Tools|Preferences|Settings &amp; Syntax|Add</li>
<li>描述填 csharp, 文件扩展名 cs;aspx</li>
<li>选择语法加亮文件 csharp.stx</li>
</ul>
<h4 id="配置编译工具">配置编译工具</h4>
<ul>
<li>Tools | Config User Tools | Add</li>
<li>MenuText 填：Compile C#(编译C#)</li>
<li>Command 选：D:.NET.0.50727.exe</li>
<li>Argument 填：/unsafe $(FileName</li>
<li>InitDir 填：$(FileDir)</li>
<li>打勾：Capture Output</li>
</ul>
<h4 id="配置运行工具">配置运行工具</h4>
<ul>
<li>Tools | Config User Tools | Add</li>
<li>MenuText 填：Run C#(运行C#)</li>
<li>Command 填：cmd /c</li>
<li>Argument 填：$(FileNameNoExt).exe</li>
<li>InitDir 填：$(FileDir)</li>
<li>不打勾：Capture Output</li>
</ul>
<h3 id="notepadd">notepadd++</h3>
<ul>
<li>NppExec 插件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 编译</span></span><br><span class="line">cmd /K <span class="built_in">cd</span> /d $(CURRENT_DIRECTORY) &amp; <span class="string">&quot;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\MSBuild\15.0\Bin\Roslyn\csc.exe&quot;</span> /unsafe <span class="string">&quot;<span class="subst">$(NAME_PART)</span>&quot;</span>.cs &amp; <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 运行</span></span><br><span class="line">cmd /K <span class="built_in">cd</span> /d $(CURRENT_DIRECTORY) &amp; <span class="string">&quot;<span class="subst">$(NAME_PART)</span>&quot;</span>.exe &amp; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<h2 id="命令行">命令行</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 编译</span></span></span><br><span class="line">csc.exe /unsafe xxx.cs</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># (1)</span></span></span><br><span class="line">csc xxxx.cs</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># (2)</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 其中 /r:引用类库 /t:表示目标类型(还可以为library)</span></span></span><br><span class="line">csc /r:System.Data.dll /t:exe /out:xxxx.exe xxxx.cs</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 运行</span></span></span><br><span class="line">xxx.exe</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>csharp.tds</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#程序设计.唐大仕.02.C#语言基础</title>
    <url>/2021/09/20/csharp/tds/02/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1001663016">中国大学慕课</a></li>
</ul>
<h1 id="c-语言基础数据运算流程控制数组">C#
语言基础——数据运算、流程控制、数组</h1>
<h2 id="一.-数据类型变量与常量">一. 数据类型、变量与常量</h2>
<h3 id="变量与常量">1. 变量与常量</h3>
<ul>
<li>程序的基本任务是：<strong>对数据进行处理</strong></li>
<li>变量与常量
<ul>
<li>变量（variable）是值可以改变，本质上是内存的空间，用来存储信息</li>
<li>常量的值是固定的，直接写出来的，称字面常量（literal）</li>
</ul></li>
<li>变量（identifier，标识符）命名规范
<ul>
<li>不能是C#关键字</li>
<li>由字母、数字、下划线构成</li>
<li>第一个字符必须是字母或下划线</li>
<li>不要太长，一般不超过31个字符为宜</li>
<li>变量名最好不要与库函数名、类名相同。</li>
</ul></li>
<li><strong>C# 是大小写敏感的</strong></li>
</ul>
<h3 id="数据类型">2. 数据类型</h3>
<ul>
<li><strong>数据类型</strong>：本质上是数据的存储方式及其能参与的运算的抽象</li>
</ul>
<p><img src="/2021/09/20/csharp/tds/02/image-20210920163137240.png"></p>
<ul>
<li><p>C# 的数据类型分两大类</p>
<ul>
<li>值类型（Value Type）
<ul>
<li>int, double, <strong>Point</strong>, <strong>Size</strong>,
<strong>DateTime</strong></li>
</ul></li>
<li>引用类型（Reference Type）
<ul>
<li>Button, Label, Book, Person</li>
</ul></li>
</ul></li>
<li><p>它们都是类型</p>
<ul>
<li>任何变量都有类型</li>
</ul>
<p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a= <span class="number">5</span>;</span><br><span class="line">DateTime t = <span class="keyword">new</span> DateTime(<span class="number">2020</span>, <span class="number">12</span>, <span class="number">31</span>);</span><br><span class="line">Button btn= <span class="keyword">new</span> Button();</span><br><span class="line"><span class="built_in">double</span>.Parse();</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>它们都是 Object</strong></p>
<ul>
<li>它们都能.ToString()</li>
</ul>
<p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Label1.Text = age.ToString();</span><br></pre></td></tr></table></figure></p>
<ul>
<li>都能用于字符串的连接（+）</li>
</ul></li>
</ul>
<h4 id="等价类型">等价类型</h4>
<ul>
<li>每种简单数据类型都有一个关键词
<ul>
<li>int 相当于 System.Int32</li>
<li>double 相当于 System.Double</li>
<li>bool 相当于 System.Boolean</li>
<li>string 相当于 System.String
<ul>
<li><strong>如果 using System，则 string 相当于 String</strong></li>
</ul></li>
</ul></li>
</ul>
<h4 id="简单类型">简单类型</h4>
<h5 id="整数类型">整数类型</h5>
<ul>
<li>有符号 sbyte (1)，short (2)，int (4)，long (8)
<ul>
<li>如 87L，0x1F （<strong>没有八进制写法</strong>）</li>
</ul></li>
<li>无符号 <strong>byte</strong>，ushort，uint，ulong，
<ul>
<li>如 87UL</li>
</ul></li>
</ul>
<h5 id="字符类型">字符类型</h5>
<ul>
<li>char (2)
<ul>
<li>Unicode 表示</li>
<li>如 'a'，'0B1' 表示 Unicode ''（回车）</li>
</ul></li>
</ul>
<h5 id="实数类型">实数类型</h5>
<ul>
<li>float (4)
<ul>
<li>如3.14F</li>
</ul></li>
<li>double (8)
<ul>
<li>如 3.14，1.5E-3，3.14D （后面这个D可以省略）</li>
</ul></li>
</ul>
<h5 id="十进制类型">十进制类型</h5>
<ul>
<li><p>Decimal</p>
<ul>
<li>如 120.50M</li>
</ul></li>
</ul>
<h5 id="布尔类型">布尔类型</h5>
<ul>
<li>bool
<ul>
<li>如 true false（小写）</li>
<li><strong>不能用 0 或 1 代替</strong></li>
</ul></li>
</ul>
<h4 id="转义符">转义符</h4>
<ul>
<li>转义字符含义
<ul>
<li><code>\uxxxx</code>：1到4位十六进制数所表示的字符(xxxx)</li>
<li><code>\'</code>：单引号字符</li>
<li><code>\"</code>：双引号字符</li>
<li><code>\\</code>：反斜杠字符</li>
<li><code>\r</code>：回车（return）</li>
<li><code>\n</code>：换行（new line）</li>
<li><code>\f</code>：走纸换页</li>
<li><code>\t</code>：横向跳格</li>
<li><code>\b</code>：退格</li>
</ul></li>
</ul>
<h4 id="字符串类型">字符串类型</h4>
<ul>
<li>String</li>
<li>是<strong>引用类型</strong>，<strong>但对字符串常量有特殊处理</strong></li>
<li>字符串前可使用 @
<ul>
<li>可以不进行 <code>\</code> 转义</li>
<li>可以换行</li>
<li>双引号则用两个双引号表示一个双引号</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;abcd1234&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">@&quot;abcd</span></span><br><span class="line"><span class="string">Pqrst&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">@&quot;c:\windows\system32\aaa.txt&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="注意">注意</h4>
<ul>
<li><p>针对 C++ 程序员</p>
<ul>
<li><strong>引用类型与值类型是由其类型定义的，而不是由其使用决定的</strong></li>
<li>如 C++ 中</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line">Book b;</span><br><span class="line">Book * b;</span><br><span class="line">Book &amp;b;</span><br><span class="line">Book *&amp; b;</span><br></pre></td></tr></table></figure></p></li>
<li><p>针对 JavaScript 程序员</p>
<ul>
<li>类型是严格的 TextBox1.Text = a.ToString();</li>
</ul></li>
<li><p>针对 VB 程序员</p>
<ul>
<li>int 为 32 位长</li>
<li>字符（char）与字符串（string）不同</li>
</ul></li>
</ul>
<h4 id="c-新版本中的特殊类型">C# 新版本中的特殊类型</h4>
<ul>
<li><p>推断类型（C# 3.0）</p>
<p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>与 javascript
中不同，<strong>其类型由编译器推断，在编译时就确定了的</strong></li>
</ul></li>
<li><p>Nullable 类型（C# 3.0）</p>
<ul>
<li>可以有值，也可以没值</li>
<li>一般主要用于数据库</li>
</ul>
<p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>? a = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">if</span>(a.HasValue) &#123;&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Dynamic（C# 4.0）</p>
<ul>
<li>由DLR 支持</li>
<li><strong>编译时不检查，运行时才确定，主要用于与 COM
组件或其他语言交互</strong></li>
</ul>
<p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> x = <span class="keyword">new</span> Cell();</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="二.-运算符与表达式">二. 运算符与表达式</h2>
<h3 id="运算符">1. 运算符</h3>
<ul>
<li>和 C++ 相似</li>
</ul>
<h4 id="算术运算符">算术运算符</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">+, -, *, /, %, ++, --</span><br></pre></td></tr></table></figure>
<h4 id="关系运算符">关系运算符</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&gt;, &lt;, &gt;=, &lt;=, ==, !=</span><br></pre></td></tr></table></figure>
<h4 id="逻辑运算符">逻辑运算符</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">!, &amp; , | , ^ , &amp;&amp;, ||</span><br></pre></td></tr></table></figure>
<h4 id="位运算符">位运算符</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&amp;, |, ^, ~ , &gt;&gt;, &lt;&lt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&amp;&amp;</code>, <code>||</code>
是短路（short-circuit）运算符</li>
</ul>
<h4 id="赋值运算符">赋值运算符</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">=</span><br></pre></td></tr></table></figure>
<h4 id="扩展赋值运算符">扩展赋值运算符</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">+=, -=, *=, /=</span><br></pre></td></tr></table></figure>
<h4 id="字符串连接运算符">字符串连接运算符</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">+</span><br></pre></td></tr></table></figure>
<ul>
<li><code>+</code>
运算符两侧的操作数中只要有一个是字符串（String）类型，系统会自动将另一个操作数转换为字符串然后再进行连接</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">strings = <span class="string">&quot;hello,&quot;</span> + <span class="number">300</span> + <span class="number">5</span> + <span class="string">&quot;号&quot;</span>;</span><br><span class="line"><span class="comment">// hello,3005号</span></span><br></pre></td></tr></table></figure>
<h3 id="表达式">2. 表达式</h3>
<ul>
<li>表达式是符合一定语法规则的运算符和操作数的序列</li>
<li><strong>三目运算</strong></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">m = a &gt; b ? a : b;</span><br></pre></td></tr></table></figure>
<h4 id="表达式的类型和值">表达式的类型和值</h4>
<ul>
<li>对表达式中操作数进行运算得到的结果称为表达式的值</li>
<li>表达式的值的数据类型即为表达式的类型</li>
</ul>
<h4 id="赋值时的类型转换">赋值时的类型转换</h4>
<ul>
<li>当 <code>=</code>
两侧的数据类型不一致时，可以适用默认类型转换或强制类型转换（casting）原则进行处理</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">long</span> l= <span class="number">100</span>;</span><br><span class="line"><span class="built_in">int</span> i= (<span class="built_in">int</span>)l;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特例</strong>：可以将整型常量直接赋值给 byte、short、char
等类型变量，而不需要进行强制类型转换，<strong>只要不超出其表数范围</strong>
<ul>
<li>编译器在编译的时候可以识别出来常量</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">byte</span> b = <span class="number">12</span>;   <span class="comment">//合法</span></span><br><span class="line"><span class="built_in">byte</span> b = <span class="number">4096</span>; <span class="comment">//非法</span></span><br></pre></td></tr></table></figure>
<h4 id="表达式中的类型转换">表达式中的类型转换</h4>
<ul>
<li>当有不同种类的混合运算时:
<ul>
<li>int -&gt; long -&gt; float -&gt; double</li>
</ul></li>
<li>另外，注意<strong>整型提升</strong>
<ul>
<li><strong>所有的 byte、short、char 等转为 int</strong></li>
<li>只要参与运算就转成 int</li>
<li><strong>byte + byte 也会转化为 int 之后再进行相加</strong></li>
</ul></li>
</ul>
<h4 id="类型转换函数">类型转换函数</h4>
<ul>
<li>字符串转成数值</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span>.Parse(s);</span><br><span class="line"><span class="built_in">int</span>.Parse(s);</span><br></pre></td></tr></table></figure>
<ul>
<li>数字转成字符串</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="number">10.</span>ToString();</span><br><span class="line"><span class="string">&quot;&quot;</span> + <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 Convert</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Convert.ToInt32(textbox1.Text)</span><br><span class="line">Convert.ToDouble(<span class="string">&quot;123.45&quot;</span>)</span><br><span class="line">Convert.ToDateTime(<span class="string">&quot;2009-10-01 14:00&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="运算符优先级与结合性">运算符优先级与结合性</h4>
<ul>
<li>单目 &gt; 算术 &gt; 关系 &gt; 逻辑 &gt; 三目 &gt; 赋值</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Separator</th>
<th style="text-align: left;">. ( ) { } ; ,</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Associative</strong></td>
<td style="text-align: left;"><strong>Operators</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;">R to L</td>
<td style="text-align: left;">++ --~ ! (data type)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">L to R</td>
<td style="text-align: left;">* / %</td>
</tr>
<tr class="even">
<td style="text-align: left;">L to R</td>
<td style="text-align: left;">+ -</td>
</tr>
<tr class="odd">
<td style="text-align: left;">L to R</td>
<td style="text-align: left;">&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>
</tr>
<tr class="even">
<td style="text-align: left;">L to R</td>
<td style="text-align: left;">&lt; &gt; &lt;= &gt;= instanceof</td>
</tr>
<tr class="odd">
<td style="text-align: left;">L to R</td>
<td style="text-align: left;">== !=</td>
</tr>
<tr class="even">
<td style="text-align: left;">L to R</td>
<td style="text-align: left;">&amp;</td>
</tr>
<tr class="odd">
<td style="text-align: left;">L to R</td>
<td style="text-align: left;">^</td>
</tr>
<tr class="even">
<td style="text-align: left;">L to R</td>
<td style="text-align: left;"><span class="math inline">\(|\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">L to R</td>
<td style="text-align: left;">&amp;&amp;</td>
</tr>
<tr class="even">
<td style="text-align: left;">L to R</td>
<td style="text-align: left;"><span class="math inline">\(||\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">R to L</td>
<td style="text-align: left;">?:</td>
</tr>
<tr class="even">
<td style="text-align: left;">R to L</td>
<td style="text-align: left;">= *= /= %= += -= &lt;&lt;= &gt;&gt;=
&amp;= ^=</td>
</tr>
</tbody>
</table>
<h2 id="三.-流程控制语句">三. 流程控制语句</h2>
<ul>
<li>结构化程序设计的三种基本流程
<ul>
<li><strong>顺序</strong>、<strong>分支</strong>、<strong>循环</strong></li>
</ul></li>
</ul>
<p><img src="/2021/09/20/csharp/tds/02/image-20210920200609472.png" style="zoom:67%;"></p>
<h3 id="简单语句">简单语句</h3>
<ul>
<li>最简单的语句：<strong>方法调用语句</strong>及<strong>赋值语句</strong>
<ul>
<li>后面有个分号</li>
</ul></li>
<li><strong>没有表达式语句一说</strong>
<ul>
<li>2+3; 不能成为一个语句</li>
<li><strong>编译报错</strong></li>
</ul></li>
</ul>
<h3 id="分支语句">分支语句</h3>
<ul>
<li><code>if-else</code> 语句</li>
<li><code>switch</code> 语句
<ul>
<li>case 变量：整型、枚举、字符串</li>
<li>不能随便贯穿，<strong>必须有 break</strong>
<ul>
<li>除非几个 case 连起来，中间没有别的语句</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译错误</span></span><br><span class="line"><span class="keyword">switch</span>(s)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">// break;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="literal">default</span>:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line"><span class="keyword">switch</span>(s)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// break;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="literal">default</span>:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环语句">循环语句</h3>
<ul>
<li>循环语句功能
<ul>
<li>句的在循环条件满足的情况下，反复执行特定代码</li>
</ul></li>
<li>循环五要素
<ul>
<li>初始化部分（init_statement）</li>
<li>循环条件部分（test_exp）</li>
<li>循环体部分（body_statement）</li>
<li>迭代部分（alter_statement）我称为“循环改变”</li>
<li>”结束后处理”</li>
</ul></li>
<li>for 循环、while 循环、do-while 循环</li>
</ul>
<p><img src="/2021/09/20/csharp/tds/02/image-20210921103344494.png" style="zoom:67%;"></p>
<ul>
<li>跳转语句
<ul>
<li>break</li>
<li>continue</li>
<li>goto
<ul>
<li>可以从内层跳到外层</li>
<li>标号的写法：标识符加个冒号(:)</li>
</ul></li>
<li>try-catch</li>
</ul></li>
</ul>
<h2 id="四.-数组">四. 数组</h2>
<ul>
<li>数组是多个相同类型数据的组合</li>
<li>数组属<strong>引用类型</strong></li>
</ul>
<h3 id="一维数组声明">一维数组声明</h3>
<ul>
<li>一维数组的声明方式</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] a1; <span class="comment">// 注意方括号写到变量名的前面</span></span><br><span class="line"><span class="built_in">double</span> []b;</span><br><span class="line">Mydate []c;</span><br></pre></td></tr></table></figure>
<ul>
<li>C# 语言中声明数组时不能指定其长度(数组中元素的个数)
<ul>
<li><strong>因为是引用类型</strong></li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a[<span class="number">5</span>]; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure>
<h3 id="数组初始化">数组初始化</h3>
<h4 id="动态初始化">动态初始化</h4>
<ul>
<li>数组定义与为数组元素分配空间并赋值的操作分开进行</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] a = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">MyDate[] dates;</span><br><span class="line">dates = <span class="keyword">new</span> MyDate[<span class="number">3</span>];</span><br><span class="line">dates[<span class="number">0</span>] = <span class="keyword">new</span> MyDate(<span class="number">22</span>, <span class="number">7</span>, <span class="number">1964</span>);</span><br><span class="line">dates[<span class="number">1</span>] = <span class="keyword">new</span> MyDate(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2000</span>);</span><br><span class="line">dates[<span class="number">2</span>] = <span class="keyword">new</span> MyDate(<span class="number">22</span>, <span class="number">12</span>, <span class="number">1964</span>);</span><br></pre></td></tr></table></figure>
<h4 id="数组初始化-1">数组初始化</h4>
<ul>
<li>在定义数组的同时就为数组元素分配空间并赋值。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] a = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] a = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>,&#125;;  <span class="comment">// 最后可以多一个逗号</span></span><br><span class="line"><span class="built_in">int</span>[] a = <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">MyDate[] dates= &#123;</span><br><span class="line">    <span class="keyword">new</span> MyDate(<span class="number">22</span>, <span class="number">7</span>, <span class="number">1964</span>),</span><br><span class="line">    <span class="keyword">new</span> MyDate(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2000</span>),</span><br><span class="line">    <span class="keyword">new</span> MyDate(<span class="number">22</span>, <span class="number">12</span>, <span class="number">1964</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="数组元素的默认初始化">数组元素的默认初始化</h3>
<ul>
<li>数组是引用类型，<strong>它的元素相当于类的成员变量</strong></li>
<li>因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被<strong>隐式初始化</strong>
<ul>
<li><strong>数值类型是 0，引用类型是 null</strong></li>
</ul></li>
</ul>
<h3 id="数组元素的引用方式">数组元素的引用方式</h3>
<ul>
<li>index为数组元素下标，可以是整型常量或整型表达式</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">a[<span class="number">3</span>], b[i], c[<span class="number">6</span>*i];</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>数组元素下标从 0 开始</strong>
<ul>
<li>长度为n的数组合法下标取值范围：0 ~ n-1</li>
</ul></li>
<li><strong>每个数组都有一个属性 Length 指明它的长度</strong></li>
</ul>
<h3 id="foreach-语句">foreach 语句</h3>
<ul>
<li>foreach 是<strong>只读式</strong>的遍历</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] ages = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">foreach</span>( intage inages ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="array.copy">Array.Copy()</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源数组</span></span><br><span class="line"><span class="built_in">int</span>[] source = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="comment">//目的数组</span></span><br><span class="line"><span class="built_in">int</span>[] dest = &#123; <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制源数组中从下标 0 开始的 source.length 个元素到</span></span><br><span class="line"><span class="comment">// 目的数组，从下标 0 的位置开始存储。</span></span><br><span class="line">Array.Copy(source, <span class="number">0</span>, dest, <span class="number">0</span>, source.Length);</span><br></pre></td></tr></table></figure>
<h3 id="多维数组">多维数组</h3>
<ul>
<li>二维数组举例</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[,] a = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">Button[,] buttons = <span class="keyword">new</span> Button[<span class="number">4</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>可以用 a.GetLength(0) , a.GetLength(1)
来获得<strong>各个维度的长度</strong></li>
</ul>
<h3 id="交错数组">交错数组</h3>
<ul>
<li>C#中交错数组是数组的数组</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[][] t = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][];</span><br><span class="line">t[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line">t[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>];</span><br><span class="line">t[<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>C#
<strong>中多维数组的声明和初始化应按从高维到低维的顺序进行</strong></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> t1[][] = <span class="keyword">new</span> <span class="built_in">int</span>[][<span class="number">4</span>]; <span class="comment">// 非法, 这与C++是不一样的</span></span><br></pre></td></tr></table></figure>
<h2 id="五.-其他">五. 其他</h2>
<h3 id="屏保程序">屏保程序</h3>
<ul>
<li>放到文件夹 <code>C:\windows\system32\</code> 下，修改文件名为
<code>xxx.scr</code></li>
</ul>
<h3 id="匈牙利命名法">匈牙利命名法</h3>
<ul>
<li>lbl（label）、btn（button）、txt（textBox）、lst（listBox）、frm（form）</li>
<li><strong>修改 Name 属性修改名字</strong></li>
</ul>
<h3 id="事件的-sender">事件的 sender</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按钮点击事件处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">btn_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">    Button btn = sender <span class="keyword">as</span> Button; <span class="comment">// 当前点中的按钮</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>csharp.tds</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#程序设计.唐大仕.03.面向对象的C#语言(2)</title>
    <url>/2021/10/02/csharp/tds/03-1/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1001663016">中国大学慕课</a></li>
</ul>
<h1 id="面向对象的c语言">面向对象的C#语言</h1>
<h2 id="修饰符">4. 修饰符</h2>
<h3 id="访问控制符">访问控制符</h3>
<table>
<colgroup>
<col style="width: 14%">
<col style="width: 9%">
<col style="width: 18%">
<col style="width: 19%">
<col style="width: 18%">
<col style="width: 19%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">访问控制符</th>
<th style="text-align: center;">同类中</th>
<th style="text-align: center;">相同程序集的<br>子类</th>
<th style="text-align: center;">相同程序集的<br>非子类</th>
<th style="text-align: center;">不同程序集的<br>子类</th>
<th style="text-align: center;">不同程序集的<br>非子类</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">public</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">protected internal</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">protected</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">internal</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">private</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<ul>
<li>protected 保证子类（逻辑），internal 保证相同程序集（物理）</li>
<li>程序集：项目编译成同一个 exe 和 dll
文件，这一组文件称为一个程序集</li>
</ul>
<h3 id="static">static</h3>
<ul>
<li>static的字段、方法、属性是属于整个类的</li>
<li>static 方法中，不能访问实例变量
<ul>
<li>例如不能使用 this</li>
</ul></li>
<li>调用 static 方法时，<strong>直接用类名访问</strong></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>static 变量可以用来表示<strong>全局变量</strong>
<ul>
<li>定义一个类，里面的所有变量都是 static 的，当作全局变量使用</li>
</ul></li>
<li>在 c#2.0 中，类名也可以用 static 来修饰
<ul>
<li>称为 static 类</li>
<li>所有字段、方法都是 static 的</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StaticClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> A;</span><br><span class="line">    <span class="comment">// public int B; // error CS0708: &quot;StaticClass.B&quot;: 不能在静态类中声明实例成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="static-构造方法">static 构造方法</h3>
<ul>
<li>static 构造方法只会调用一次，但其调用时间是不确定的</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> TotalNum;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Person</span>()</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Person: static constructor&quot;</span>);</span><br><span class="line">        TotalNum = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Person: constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">Person: static constructor</span></span><br><span class="line"><span class="comment">Person: constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="const-与-readonly">const 与 readonly</h3>
<ul>
<li>const 相当于静态常量
<ul>
<li>Math.PI</li>
</ul></li>
<li>readonly 相当于不可改量，只能赋一次值
<ul>
<li>String.Empty</li>
<li>在构造方法中赋值，或者在声明时就赋值</li>
</ul></li>
<li>const 只能用于基本类型及 string</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="comment">// const Person p2 = p1; // error CS0133: 指派给 &quot;p2&quot; 的表达式必须是常量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">string</span> s1 = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">        <span class="comment">// s1 = &quot;s&quot;; //  error CS0131: 赋值号左边必须是变量、属性或索引器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>readonly 只能修饰字段，而 const 还可以修饰局部变量</li>
</ul>
<h3 id="sealed-和-abstract">sealed 和 abstract</h3>
<ul>
<li>sealed类，不可继承(也有利于编译优化)
<ul>
<li>如 String Console Math Convert Graphics Font</li>
</ul></li>
<li>abstract类，不可实例化（new）
<ul>
<li>如 Array, RandomNumberGenerator</li>
<li>abstract 的方法体，不用{}，用;
<ul>
<li>abstract 类型 方法名(参数列表);</li>
<li>abstract 类型 属性名{get;set;}</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过编译</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractClass</span>()</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;AbstractClass: constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun1</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口">5. 接口</h2>
<ul>
<li>接口实际上是一个约定
<ul>
<li>如：ICloneable、IComparable</li>
</ul></li>
<li>接口是抽象成员的集合
<ul>
<li>ICloneable 含有方法 clone()</li>
<li>IComparable 含有方法 compare()</li>
</ul></li>
<li><strong>接口是一个引用类型，比抽象类更抽象</strong></li>
</ul>
<h3 id="接口能够帮助实现多重继承">接口能够帮助实现多重继承</h3>
<ul>
<li>例子</li>
</ul>
<p><img src="/2021/10/02/csharp/tds/03-1/image-20211002130915314.jpg" style="zoom:67%;"></p>
<h3 id="接口的用处">接口的用处</h3>
<ul>
<li>实现不相关类的相同行为
<ul>
<li>不需要考虑这些类之间的层次关系</li>
</ul></li>
<li>通过接口可以了解对象的交互界面，而不需了解对象所对应的类</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">String</span> :</span><br><span class="line"><span class="title">IComparable</span>, <span class="title">ICloneable</span>, <span class="title">IConvertible</span>, <span class="title">IEnumerable</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义一个接口">定义一个接口</h3>
<ul>
<li>所有的接口都是 public、abstract 的，但是不需要显式声明
<ul>
<li><strong>不能显式写出来</strong></li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStringList</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>;</span><br><span class="line">    <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index] &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现接口">实现接口</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 : [父类, ] 接口, 接口, ..., 接口 &#123;</span><br><span class="line">    <span class="comment">// 实现接口的方法</span></span><br><span class="line">    <span class="keyword">public</span> 方法 () &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="显式接口成员实现">显式接口成员实现</h3>
<ul>
<li>在实现多个接口时，如果不同的接口有同名的方法，</li>
<li>为了消除歧义，<strong>需要在方法名前写接口名</strong></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> IWindow.Close () &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用时，<strong>只能用接口调用</strong>（强制类型转换）</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">((IWindow)f).Close();</span><br></pre></td></tr></table></figure>
<ul>
<li>例子</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">InterfaceExplicitImpl</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        FileViewer f = <span class="keyword">new</span> FileViewer();</span><br><span class="line">        f.Test();</span><br><span class="line">        ((IWindow)f).Close();</span><br><span class="line">        IWindow w = <span class="keyword">new</span> FileViewer();</span><br><span class="line">        w.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IWindow</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Close</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IFileHandler</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Close</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">FileViewer</span> : <span class="title">IWindow</span>, <span class="title">IFileHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> IWindow.Close () &#123;</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Window Closed&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> IFileHandler.Close() &#123;</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;File Closed&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span> &#123;</span><br><span class="line">        ((IWindow)<span class="keyword">this</span>).Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构及枚举">6. 结构及枚举</h2>
<h3 id="结构-struct">结构 struct</h3>
<ul>
<li>结构常用来表示较简单的多个分量（字段）</li>
<li>Point、Color、Size、DateTime、Int32</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Int32 :</span><br><span class="line">IComparable, IFormattable, IConvertible,</span><br><span class="line">IComparable&lt;<span class="built_in">int</span>&gt;, IEquatable&lt;<span class="built_in">int</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>可以有方法、属性等其他成员</strong></li>
</ul>
<h3 id="结构的例子">结构的例子</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Point &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">R</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.Sqrt(x*x+y*y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构和类的区别">结构和类的区别</h3>
<ul>
<li><strong>struct 是值类型</strong>
<ul>
<li>结构<strong>不能包含无参数构造方法</strong></li>
<li>每个字段在定义时，不能给初始值</li>
<li>构造方法中，必须对每个字段进行赋值</li>
</ul></li>
<li>struct 是 sealed 的，不能被继承</li>
<li>实例化时，使用
new，<strong>但与引用型变量的内存是不同的</strong></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point(<span class="number">100</span>,<span class="number">80</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>值类型变量在赋值时，实行的是字段的 copy</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> MPoint &#123;</span><br><span class="line">    <span class="comment">// public double x = 1.0, y = 1.0;</span></span><br><span class="line">    <span class="comment">// error CS0573: &quot;MPoint&quot;: 结构中不能实例属性或字段初始值设定项</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error CS0568: 结构不能包含显式的无参数构造函数</span></span><br><span class="line">    <span class="comment">// public MPoint() &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MPoint</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.x = x;</span><br><span class="line">         <span class="comment">// 如果注释掉上面一行的赋值语句则报错</span></span><br><span class="line">         <span class="comment">// error CS0171: 在控制返回调用方之前，字段&quot;MPoint.x&quot;必须完全赋值</span></span><br><span class="line">         <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口列表中的类型 &quot;MPoint&quot; 不是接口</span></span><br><span class="line"><span class="comment">// error CS0527: struct MMPoint : MPoint &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">AA</span> &#123;&#125;</span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line"><span class="keyword">struct</span> MMM : AA &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestStruct</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        MPoint p1 = <span class="keyword">new</span> MPoint(<span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        MPoint p2 = p1;</span><br><span class="line">        p1.x = <span class="number">2.0</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;p1.x: &quot;</span> + p1.x);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;p2.x: &quot;</span> + p2.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">p1.x: 2</span></span><br><span class="line"><span class="comment">p2.x: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="枚举-enum">枚举 enum</h3>
<ul>
<li>枚举实际上是有意义的整数
<ul>
<li>FontStyle、GraphicsUnit、KnownColor、DockStyle、DialogResult</li>
</ul></li>
<li>例子</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> MColor &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green = <span class="number">1</span>,</span><br><span class="line">    Blue = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestStruct</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        Console.WriteLine(MColor.Red);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">Red</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用法</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">MColor c = MColor.Red;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较</span></span><br><span class="line"><span class="keyword">if</span>(c == MColor.Red) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择</span></span><br><span class="line"><span class="keyword">switch</span>(c) &#123;</span><br><span class="line">    <span class="keyword">case</span> MColor.Red:</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>与字符串的转化</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> MColor &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green = <span class="number">1</span>,</span><br><span class="line">    Blue = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestStruct</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        MColor c = MColor.Red;</span><br><span class="line">        Console.WriteLine(c.ToString());</span><br><span class="line">        Console.WriteLine(</span><br><span class="line">            (MColor) Enum.Parse(<span class="keyword">typeof</span>(MColor), <span class="string">&quot;Red&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">Red</span></span><br><span class="line"><span class="comment">Red</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="结构和枚举比较">结构和枚举比较</h3>
<ul>
<li>结构主要用来表示多个分量</li>
<li>枚举主要用来表示<strong>符号化的常量</strong></li>
<li>它们都是<strong>值类型</strong></li>
</ul>
<h2 id="面向对象编程">7. 面向对象编程</h2>
<ul>
<li>Object Oriented 方法的三大特点
<ul>
<li><strong>继承 inheritance</strong>
<ul>
<li>子类继承父类的成员，还可增加、调用、隐藏</li>
<li>提高软件模块的可重用性和可扩充性</li>
</ul></li>
<li><strong>封装 encapsulation</strong>
<ul>
<li>使用接口，而不关心具体的类</li>
<li>使用属性，而将字段设为private</li>
</ul></li>
<li><strong>多态 polymorphism</strong>
<ul>
<li>相同的方法，不同的参数</li>
<li>自动调用子类相应的方法（虚方法调用，以后讲）</li>
</ul></li>
</ul></li>
</ul>
<h2 id="uml-类图">8. UML 类图</h2>
<ul>
<li>UML，统一建模语言</li>
<li>有类图、状态图、时序图等多种图形</li>
<li><a href="http://www.uml.org.cn/">http://www.uml.org.cn/</a></li>
</ul>
<h3 id="vs-中的类关系图">VS 中的类关系图</h3>
<ul>
<li>在项目上，点右键，”查看类关系图“</li>
<li>添加新项，其他项，类关系图
<ul>
<li>然后将相应的类文件拖动到该 “类关系图” 中</li>
</ul></li>
<li>UML 工具
<ul>
<li>IBM Rational XDE for .NET</li>
<li>Borland Together</li>
<li>Microsoft Visio</li>
</ul></li>
<li>正向工程，由UML图自动产生代码</li>
<li>反向工程，由代码自动产生UML图</li>
</ul>
<h2 id="编程规范">9. 编程规范</h2>
<ul>
<li>数字要有意义，不能天上掉下来</li>
<li>常用手段
<ul>
<li>使用变量 delta = 100</li>
<li>使用常量 const int MAX_LEN = 1000</li>
<li>使用系统常量 Math.PI</li>
<li>使用枚举</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>csharp.tds</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#程序设计.唐大仕.03.面向对象的C#语言</title>
    <url>/2021/09/30/csharp/tds/03/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1001663016">中国大学慕课</a></li>
</ul>
<h1 id="面向对象的c语言">面向对象的C#语言</h1>
<h2 id="类字段方法">1. 类、字段、方法</h2>
<ul>
<li>类（class）最基本的要素
<ul>
<li>字段（field）：变量</li>
<li>方法（method）： 函数</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello! My name is &quot;</span> + name );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetInfo</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Name: &quot;</span> + name + <span class="string">&quot;, Age: &quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造方法">构造方法</h3>
<ul>
<li>构造方法（constructor）</li>
<li>构造方法的主要作用是完成对象的初始化工作
<ul>
<li>构造方法的方法名与类名相同</li>
<li>构造方法没有返回类型，也不能写 void</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> n, <span class="built_in">int</span> a</span>)</span>&#123;</span><br><span class="line">        name = n; age = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认（default）构造方法
<ul>
<li>如果用户<strong>没有定义任何构造方法</strong>，则系统会自动产生一个</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>构造方法不能显式地直接调用，而是用 new 来调用</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Liming&quot;</span>, <span class="number">20</span> );</span><br></pre></td></tr></table></figure>
<h3 id="析构方法">析构方法</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">    ~Person() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>由于 C# 自动进行对象的释放，所以用户一般不定义析构方法</li>
</ul>
<h3 id="方法的重载">方法的重载</h3>
<ul>
<li>overloading</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hello! My name is &quot;</span> + name );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"> Person another </span>)</span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hello,&quot;</span> + another.name</span><br><span class="line">                      + <span class="string">&quot;! My name is &quot;</span> + name );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>系统通过方法签名来区分</li>
<li>方法签名：<strong>方法名</strong>及<strong>参数个数及类型</strong>构成（参数名不算）</li>
</ul>
<h3 id="this">this</h3>
<ul>
<li><p>this指这个对象本身</p></li>
<li><p>常用于</p>
<ul>
<li>访问这个对象的字段及方法
<ul>
<li>用于 VS 自动补全</li>
</ul></li>
<li>区分字段与局部变量</li>
</ul>
<p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age, <span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>用于构造方法调用另一个构造方法，<strong>注意其位置</strong></li>
</ul>
<p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span>() : <span class="title">this</span>(<span class="params"> <span class="number">0</span>, <span class="string">&quot;&quot;</span> </span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 构造方法的其他语句;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="应用实例银行系统">应用实例：银行系统</h3>
<ul>
<li>可在 vs 中，添加 “ 类关系图 ”（类图）</li>
</ul>
<p><img src="/2021/09/30/csharp/tds/03/image-20210930183705246.png"></p>
<h2 id="属性索引">2. 属性、索引</h2>
<h3 id="属性">属性</h3>
<h4 id="使用属性">使用属性</h4>
<ul>
<li>button1.Text = "说你好";
<ul>
<li>含义相当于button1.SetText( “说你好”);</li>
</ul></li>
<li>string s = button1.Text;
<ul>
<li>含义相当于 s = button1.GetText();</li>
</ul></li>
</ul>
<h4 id="定义属性">定义属性</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        _name = <span class="keyword">value</span>; <span class="comment">// value 关键字, 便是传进来的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>C#3 之后可以简写</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">set</span>; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure>
<h5 id="一个例子">一个例子</h5>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123;</span><br><span class="line">        <span class="keyword">set</span>; <span class="keyword">get</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">xxx</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xxx</span>()</span> &#123;</span><br><span class="line">        Person a = <span class="keyword">new</span> Person();</span><br><span class="line">        a.Name = <span class="string">&quot;banbao&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>编译器</strong>对于上面的属性生成如下方法
<ul>
<li>可以通过反汇编看到生成的方法</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_Name</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">get_Name</span>()</span>;</span><br></pre></td></tr></table></figure>
<h4 id="属性和字段的对比">属性和字段的对比</h4>
<ul>
<li><strong>属性实际上是方法</strong></li>
</ul>
<h4 id="属性的优点">属性的优点</h4>
<ul>
<li><p>可以只读或只写</p>
<ul>
<li>只读：只有 get，没有 set</li>
</ul>
<p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>只写：只有 set，没有 get</li>
</ul></li>
<li><p>可以进行有效性检查</p></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> _name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Name can not be an empty string!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _name = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以是计算得到的数据</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Info&#123;</span><br><span class="line">    <span class="keyword">get</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Name :&quot;</span> + Name + <span class="string">&quot;,Age :&quot;</span> + Age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以定义抽象属性</li>
</ul>
<h3 id="索引">索引</h3>
<ul>
<li>string s="abcde";</li>
<li>求出第0个字符：s[0]
<ul>
<li>含义上相当于 s.Get(0)</li>
</ul></li>
</ul>
<h4 id="定义索引">定义索引</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">修饰符 类型名 <span class="keyword">this</span> [参数列表] &#123;</span><br><span class="line">    <span class="keyword">set</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">get</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用索引">使用索引</h4>
<ul>
<li><strong>对象名[参数]</strong></li>
<li><strong>编译器</strong>自动产生两个方法，以供调用</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">get_Item</span>(<span class="params">P</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_Item</span>(<span class="params">P, T <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="课程示例">课程示例</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">IndexerRecord</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>[] data = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>[] keys = &#123;</span><br><span class="line">        <span class="string">&quot;Author&quot;</span>, <span class="string">&quot;Publisher&quot;</span>, <span class="string">&quot;Title&quot;</span>, <span class="string">&quot;Subject&quot;</span>, <span class="string">&quot;ISBN&quot;</span>, <span class="string">&quot;Comments&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 定义索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> idx] &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx &gt;= <span class="number">0</span> &amp;&amp; idx &lt; data.Length) data[idx] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx &gt;= <span class="number">0</span> &amp;&amp; idx &lt; data.Length) <span class="keyword">return</span> data[idx];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两种方式访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">string</span> key] &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="built_in">int</span> idx = FindKey(key);</span><br><span class="line">            <span class="keyword">this</span>[idx] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>[FindKey(key)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">FindKey</span>(<span class="params"><span class="built_in">string</span> key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; keys.Length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (keys[i] == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        IndexerRecord <span class="keyword">record</span> = <span class="keyword">new</span> IndexerRecord();</span><br><span class="line">        <span class="comment">// 使用索引</span></span><br><span class="line">        <span class="keyword">record</span>[0] = <span class="string">&quot;马克-吐温&quot;</span>;</span><br><span class="line">        <span class="keyword">record</span>[1] = <span class="string">&quot;Crox出版公司&quot;</span>;</span><br><span class="line">        <span class="keyword">record</span>[2] = <span class="string">&quot;汤姆-索亚历险记&quot;</span>;</span><br><span class="line">        Console.WriteLine(<span class="keyword">record</span>[&quot;<span class="title">Title</span>&quot;]);</span><br><span class="line">        Console.WriteLine(<span class="keyword">record</span>[&quot;<span class="title">Author</span>&quot;]);</span><br><span class="line">        Console.WriteLine(<span class="keyword">record</span>[&quot;<span class="title">Publisher</span>&quot;]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性和索引">属性和索引</h3>
<table>
<colgroup>
<col style="width: 37%">
<col style="width: 62%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">属性</th>
<th style="text-align: center;">索引器</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">通过名称标识</td>
<td style="text-align: center;">通过参数列表进行标识</td>
</tr>
<tr class="even">
<td style="text-align: center;">通过简单名称来访问</td>
<td style="text-align: center;">通过 [] 运算符来访问</td>
</tr>
<tr class="odd">
<td style="text-align: center;">可以用 static 修饰</td>
<td style="text-align: center;">不能用 static 修饰</td>
</tr>
<tr class="even">
<td style="text-align: center;">属性的 get 访问器没有参数</td>
<td style="text-align: center;">索引的 get
访问器具有与索引相同的参数</td>
</tr>
<tr class="odd">
<td style="text-align: center;">属性的 set 访问器包含隐式 value
参数</td>
<td style="text-align: center;">除了 value 参数外，<br>索引的 set
访问器还具有与索引相同的参数列表</td>
</tr>
</tbody>
</table>
<h2 id="类的继承">3. 类的继承</h2>
<ul>
<li>窗体程序</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">System.Windows.Forms.Form</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>继承使用 <code>:</code> 表示</li>
<li>子类 subclass、父类 baseclass</li>
<li>C# 中采用<strong>单继承</strong></li>
<li>所有的类都是通过直接或间接地继承 object（即System.Object）得到的
<ul>
<li>如果一个类明显显式声明继承自哪一个类，系统认为其继承于 object</li>
<li>默认有 <code>ToString()</code> 等方法</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SubClass</span> : <span class="title">BaseClass</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类自动地从父类那里继承所有的字段、方法、属性、索引器等成员作为自己的成员</li>
<li>除了继承父类的成员外，子类还可以
<ul>
<li><strong>添加新的成员</strong></li>
<li><strong>隐藏或修改父类的成员</strong></li>
</ul></li>
</ul>
<h3 id="字段的继承添加与隐藏">字段的继承、添加与隐藏</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span> : <span class="title">A</span> &#123;</span><br><span class="line">    <span class="comment">// 继承字段 a</span></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">public</span> <span class="built_in">int</span> b; <span class="comment">// 隐藏</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> c; <span class="comment">// 添加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法的继承添加">方法的继承、添加</h3>
<ul>
<li>方法的继承（自动）</li>
<li>方法的添加（多定义一些方法）</li>
</ul>
<h4 id="与父类同名的方法">与父类同名的方法</h4>
<ul>
<li>一是定义同名、但参数列表（签名）与父类不同的方法，这称为对父类方法的重载（<strong>Overloading</strong>）</li>
<li>二是定义同名且参数列表也与父类相同的方法，这称为新增加一种方法 ，用
<strong>new</strong> 表示</li>
<li>三是定义同名且参数列表也与父类相同的方法，而且父类的方法用了
abstract 或 virtual 进行了修饰，子类的同名方法用了 overridnewe
进行了修饰，这称为虚方法的覆盖（<strong>Overriding</strong>）</li>
</ul>
<h4 id="base-关键字">base 关键字</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> A;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span>(<span class="params"><span class="built_in">int</span> A</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Base: constructor!&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.A = A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Base: Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="title">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> B;</span><br><span class="line">    <span class="comment">// 通过 base 关键字调用父类构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Derived</span>(<span class="params"><span class="built_in">int</span> A, <span class="built_in">int</span> B</span>): <span class="title">base</span>(<span class="params">A</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Derived: constructor!&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.B = B;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new 关键字表示隐藏(否则会报警告)</span></span><br><span class="line">    <span class="keyword">new</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.SayHello(); <span class="comment">// 通过 base 关键字调用父类方法</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Derived: Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        Derived d = <span class="keyword">new</span> Derived(<span class="number">0</span> ,<span class="number">0</span>);</span><br><span class="line">        d.SayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">Base: constructor!</span></span><br><span class="line"><span class="comment">Derived: constructor!</span></span><br><span class="line"><span class="comment">Base: Hello!</span></span><br><span class="line"><span class="comment">Derived: Hello!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="父类与子类的转换">父类与子类的转换</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Student();</span><br><span class="line">Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">statement A;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述 <code>statement A</code> 分别为如下语句</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">p1 = s1; <span class="comment">// 可以, 因为 Person 类型的变量可以引用 Student 对象</span></span><br><span class="line"></span><br><span class="line">s2 = p1; <span class="comment">// 不行, 因为会产生编译错误</span></span><br><span class="line"></span><br><span class="line">s2 = (Student) p1;  <span class="comment">// 编译时可以通过, 运行时则会出现类型不能转换的异常</span></span><br><span class="line"></span><br><span class="line">s2 = (Student) p2;  <span class="comment">// 正确，因为 p2 引用的正好是 Student 对象实例</span></span><br></pre></td></tr></table></figure>
<h4 id="as-运算符">as 运算符</h4>
<ul>
<li>如果不能转换，则值为null</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Student s3 = p1 <span class="keyword">as</span> Student;  <span class="comment">// 结果 s3 为 null</span></span><br><span class="line">Student s4 = p2 <span class="keyword">as</span> Student;  <span class="comment">// s4 被赋值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>与强制类型转换的差别
<ul>
<li>as 只能针对<strong>引用型变量</strong></li>
<li><strong>如果不能转换，as 运算不会引起异常，只是值为
null</strong></li>
</ul></li>
</ul>
<h4 id="is-运算符">is 运算符</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p <span class="keyword">is</span> Person) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断一个对象是不是某个类(及其子类)的实例</li>
</ul>
<h4 id="typeof-运算符">typeof 运算符</h4>
<ul>
<li>变量则使用 <code>GetType()</code></li>
<li>类型则使用 <code>typeof()</code></li>
<li>返回类型为 <code>System.Type</code></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Base</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="title">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        Derived d1 = <span class="keyword">new</span> Derived();</span><br><span class="line">        <span class="comment">// Derived d2 = new Base(); // 编译错误</span></span><br><span class="line">        Base b1 = <span class="keyword">new</span> Derived();</span><br><span class="line">        Base b2 = <span class="keyword">new</span> Base();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;d1: &quot;</span> + d1.GetType());</span><br><span class="line">        <span class="comment">// Console.WriteLine(&quot;d2: &quot; + d2.GetType());</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;b1: &quot;</span> + b1.GetType());</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;b2: &quot;</span> + b2.GetType());</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="keyword">typeof</span>(Base));</span><br><span class="line">        Console.WriteLine(<span class="keyword">typeof</span>(Derived));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">d1: Derived</span></span><br><span class="line"><span class="comment">b1: Derived</span></span><br><span class="line"><span class="comment">b2: Base</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Base</span></span><br><span class="line"><span class="comment">Derived</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="属性索引的继承">属性、索引的继承</h3>
<ul>
<li>属性、索引也是可以继承的</li>
</ul>
]]></content>
      <categories>
        <category>csharp.tds</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#程序设计.唐大仕.04.C#高级语言特性</title>
    <url>/2021/10/07/csharp/tds/04/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1001663016">中国大学慕课</a></li>
</ul>
<h1 id="c高级语言特性">C#高级语言特性</h1>
<h2 id="委托">1. 委托</h2>
<ul>
<li>delegate</li>
<li>大致上：委托 <span class="math inline">\(\approx\)</span>
函数指针</li>
</ul>
<h3 id="委托是对函数原型的包装">委托是对函数原型的包装</h3>
<ul>
<li>委托的声明</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">double</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">double</span> x</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>委托的实例化</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以是对象的某个方法, 也可以是类的某个静态方法</span></span><br><span class="line">MyDelegate d2 = <span class="keyword">new</span> MyDelegate(obj.myMethod);</span><br></pre></td></tr></table></figure>
<ul>
<li>委托的调用
<ul>
<li>委托变量名(参数列表)</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">d2(<span class="number">8.9</span>);</span><br></pre></td></tr></table></figure>
<h3 id="一个例子">一个例子</h3>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/04/DelegateIntegral.cs">完整代码</a></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个委托</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">double</span> <span class="title">Fun</span>(<span class="params"><span class="built_in">double</span> x</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DelegateIntegral</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 类的静态方法</span></span><br><span class="line">        Fun fun = <span class="keyword">new</span> Fun(Math.Sin);</span><br><span class="line">        <span class="built_in">double</span> d = Integral(fun, <span class="number">0</span>, Math.PI / <span class="number">2</span>, <span class="number">1e-4</span>);</span><br><span class="line">        Console.WriteLine(d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法</span></span><br><span class="line">        Fun fun2 = <span class="keyword">new</span> Fun(Linear);</span><br><span class="line">        <span class="built_in">double</span> d2 = Integral(fun2, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1e-3</span>);</span><br><span class="line">        Console.WriteLine(d2);</span><br><span class="line"></span><br><span class="line">        Rnd rnd = <span class="keyword">new</span> Rnd();</span><br><span class="line">        <span class="comment">// 类的方法</span></span><br><span class="line">        <span class="built_in">double</span> d3 = Integral(<span class="keyword">new</span> Fun(rnd.Num), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0.01</span>);</span><br><span class="line">        Console.WriteLine(d3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Linear</span>(<span class="params"><span class="built_in">double</span> a</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Rnd</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Num</span>(<span class="params"><span class="built_in">double</span> x</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> r.NextDouble();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 积分计算</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Integral</span>(<span class="params">Fun f, <span class="built_in">double</span> a, <span class="built_in">double</span> b, <span class="built_in">double</span> eps</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        fa = f(a); <span class="comment">// 使用委托</span></span><br><span class="line">        fb = f(b);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>C# 4 以上版本定义了很多的委托</li>
<li>例如</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有返回值, 封装的委托从 0 个参数到 16 个参数</span></span><br><span class="line"><span class="built_in">delegate</span> <span class="keyword">void</span> System.Action();</span><br><span class="line"><span class="built_in">delegate</span> <span class="keyword">void</span> System.Action&lt;<span class="keyword">in</span> T&gt; (T obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有返回值, 封装的委托从 0 个参数到 16 个参数</span></span><br><span class="line"><span class="built_in">delegate</span> TResult System.Func&lt;<span class="keyword">in</span> T, <span class="keyword">out</span> TResult&gt;(T arg);</span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以对上面的例子做如下修改
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/04/DelegateIntegral_func.cs">完整代码</a></li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">    Func&lt;<span class="built_in">double</span>, <span class="built_in">double</span>&gt; fun = <span class="keyword">new</span> Func&lt;<span class="built_in">double</span>, <span class="built_in">double</span>&gt;(Math.Sin);</span><br><span class="line">    <span class="built_in">double</span> d = Integral(fun, <span class="number">0</span>, Math.PI / <span class="number">2</span>, <span class="number">1e-4</span>);</span><br><span class="line">    Console.WriteLine(d);</span><br><span class="line"></span><br><span class="line">    Func&lt;<span class="built_in">double</span>, <span class="built_in">double</span>&gt; fun2 = <span class="keyword">new</span> Func&lt;<span class="built_in">double</span>, <span class="built_in">double</span>&gt;(Linear);</span><br><span class="line">    <span class="built_in">double</span> d2 = Integral(fun2, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1e-3</span>);</span><br><span class="line">    Console.WriteLine(d2);</span><br><span class="line"></span><br><span class="line">    Rnd rnd = <span class="keyword">new</span> Rnd();</span><br><span class="line">    <span class="built_in">double</span> d3 = Integral(<span class="keyword">new</span> Func&lt;<span class="built_in">double</span>, <span class="built_in">double</span>&gt;(rnd.Num), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0.01</span>);</span><br><span class="line">    Console.WriteLine(d3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Integral</span>(<span class="params">Func&lt;<span class="built_in">double</span>, <span class="built_in">double</span>&gt; f, <span class="built_in">double</span> a, <span class="built_in">double</span> b, <span class="built_in">double</span> eps</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="委托的合并">委托的合并</h3>
<ul>
<li>委托的合并----多播MultiCastDelegate
<ul>
<li>一个委托实例中可以 “包含” 多个函数</li>
<li>调用委托，就是调用其中多个函数</li>
<li><strong>多个函数间的先后顺序是没有意义的</strong></li>
<li>返回值也就没有太多意义</li>
</ul></li>
<li>运算符：<code>+</code>
、<code>-</code>、<code>+=</code>、<code>-=</code>
<ul>
<li>动态地增减其中的函数</li>
<li>提高了程序的灵活性</li>
</ul></li>
<li><a href="/utils/show_code/index.html?csharp/tds/04/DelegateMultiTest.cs">例子</a></li>
</ul>
<h3 id="委托的转换与相等">委托的转换与相等</h3>
<ul>
<li><p>委托的转换</p>
<ul>
<li>按声明的名称判断</li>
<li>以下两个不能互相转换或加减</li>
</ul>
<p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">D</span>(<span class="params"><span class="built_in">int</span> a</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">E</span>(<span class="params"><span class="built_in">int</span> a</span>)</span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>委托的相等</p>
<ul>
<li>按内容（即其中“包含的函数”）来判断</li>
<li>有点点像两个<strong>字符串</strong>的 “相等” 与否的判断</li>
</ul></li>
<li><p>一些测试</p></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">D cd1 = <span class="keyword">new</span> D(C.M1);</span><br><span class="line">D cd2 = <span class="keyword">new</span> D(C.M1);</span><br><span class="line">D cd3 = <span class="literal">null</span>;</span><br><span class="line">cd3 += <span class="keyword">new</span> D(C.M1);</span><br><span class="line">D cd4 = <span class="keyword">new</span> D(C.M1) + <span class="keyword">new</span> D(C.M1);</span><br><span class="line">E cd5 = <span class="keyword">new</span> E(C.M1);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(cd1.Equals(cd2)); <span class="comment">// True</span></span><br><span class="line">Console.WriteLine(cd1.Equals(cd3)); <span class="comment">// True</span></span><br><span class="line">Console.WriteLine(cd1.Equals(cd4)); <span class="comment">// False</span></span><br><span class="line">Console.WriteLine(cd1.Equals(cd5)); <span class="comment">// False</span></span><br><span class="line"></span><br><span class="line">D cd6 = <span class="keyword">new</span> D(C.M1) + <span class="keyword">new</span> D(C.M2);</span><br><span class="line">D cd7 = <span class="keyword">new</span> D(C.M2) + <span class="keyword">new</span> D(C.M1);</span><br><span class="line">Console.WriteLine(cd6.Equals(cd7)); <span class="comment">// False</span></span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<ul>
<li>委托相当于函数指针</li>
<li>但它类型更安全，是<strong>引用类型</strong></li>
<li>且功能更强大，有<strong>多播功能</strong></li>
</ul>
<h2 id="事件">2. 事件</h2>
<ul>
<li>大致上：事件 <span class="math inline">\(\approx\)</span>
回调函数</li>
</ul>
<h3 id="gui-中的事件">GUI 中的事件</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.button1.Click += <span class="keyword">new</span> System.EventHandler(<span class="keyword">this</span>.button1_Click);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义事件">自定义事件</h3>
<ul>
<li>事件的声明</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> 委托名 事件名;</span><br></pre></td></tr></table></figure>
<ul>
<li>事件的注册与移除
<ul>
<li>事件名 <code>+=</code> 或 <code>-=</code>
<ul>
<li><strong>在事件所在类的外面，只能用以上两个运算符</strong></li>
</ul></li>
</ul></li>
<li>事件的发生(激发)
<ul>
<li>事件名(参数列表)</li>
<li>相当于回调所注册的函数</li>
</ul></li>
</ul>
<h3 id="实例">实例</h3>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/04/EventWhenDownload.cs">事件爬虫的例子</a></li>
</ul>
<h3 id="定义及使用事件的-6-步曲">定义及使用事件的 6 步曲</h3>
<ul>
<li>声明事件参数类： <code>class xxxEventArgs&#123;&#125;</code></li>
<li>声明委托：<code>delegate void xxxEventHandler(obj, args)</code></li>
<li>定义事件：<code>public event 类型 名称</code></li>
<li>发生事件：<code>事件名(参数)</code></li>
<li>定义一个方法： <code>void 方法名(obj, args)</code></li>
<li>注册事件：<code>xxx.事件+= new 委托(方法名)</code></li>
</ul>
<h3 id="事件与委托的关系">事件与委托的关系</h3>
<ul>
<li><p>事件有点像委托类型的实例</p>
<ul>
<li>事件一定有相关的委托类型</li>
<li>与委托实例一样，事件也“包含”多个函数</li>
<li>事件的运算受更多限制（在类外只能用 <code>+=</code> 或
<code>-=</code>）</li>
</ul></li>
<li><p>事件比委托实例更复杂</p>
<ul>
<li>可以定义事件存取器</li>
</ul>
<p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">event</span> 委托类型名 事件名 &#123;</span><br><span class="line">    <span class="keyword">add</span>&#123;e += <span class="keyword">value</span>; &#125;</span><br><span class="line">    <span class="keyword">remove</span>&#123; e -= <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="事件总结">事件总结</h3>
<ul>
<li>事件是一种消息机制</li>
<li>事件源调用事件，别的类注册事件</li>
<li>事件的类型是一个委托</li>
</ul>
<h2 id="lambda-表达式">3. lambda 表达式</h2>
<ul>
<li>C# 语言新特性
<ul>
<li>C#2.0 引入泛型</li>
<li>C#3.0 引入 Lambda 及 Linq</li>
<li>C#4.0 更多的动态特性 dynmaic</li>
</ul></li>
</ul>
<h3 id="泛型">泛型</h3>
<ul>
<li>Generic</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;Book&gt; books = <span class="keyword">new</span> List&lt;Book&gt;();</span><br><span class="line">Book book = books[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以前要用强制类型转换</span></span><br><span class="line">ArrayList books = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Book book = (Book)books[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h3 id="匿名方法">匿名方法</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delegate</span>(参数)&#123; 方法体; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以当一个匿名方法</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(<span class="built_in">delegate</span>()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)).Start();</span><br></pre></td></tr></table></figure>
<ul>
<li>可以被隐式转换为一个兼容的委托类型
<ul>
<li>省略 <code>ThreadStart</code></li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="built_in">delegate</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;).Start();</span><br></pre></td></tr></table></figure>
<h3 id="lambda-表达式-1">lambda 表达式</h3>
<ul>
<li>相当于匿名方法的简写
<ul>
<li>省略 delegate，甚至省略参数类型</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">(参数) =&gt; &#123; 语句或表达式; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>例子</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()=&gt;&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;).Start();</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">button1.Click += (sender,e) =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="lambda-表达式-vs-匿名方法">lambda 表达式 vs 匿名方法</h3>
<ul>
<li>lambda 表达式比匿名函数简单</li>
<li>匿名函数多一个功能：
<ul>
<li>不写 <code>(参数)</code> 的匿名函数，可以转成任意多个参数的委托</li>
</ul></li>
</ul>
<h3 id="linq">Linq</h3>
<ul>
<li>LINQ：Language Integrated Query</li>
<li><a href="/utils/show_code/index.html?csharp/tds/04/LinqTest.cs">完整例子</a></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;Program&gt; programs = <span class="keyword">new</span> List&lt;Program&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    programs.Add(<span class="keyword">new</span> Program());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Linq</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">from</span> p <span class="keyword">in</span> programs</span><br><span class="line">    <span class="keyword">where</span> p.RunTime &lt; <span class="number">50</span></span><br><span class="line">    <span class="keyword">orderby</span> p.Name</span><br><span class="line">    <span class="keyword">select</span> p.Name;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    Console.WriteLine(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 表达式</span></span><br><span class="line"><span class="keyword">var</span> b = programs</span><br><span class="line">    .Where(p =&gt; p.RunTime &lt; <span class="number">50</span>)</span><br><span class="line">    .OrderBy(p =&gt; p.Name)</span><br><span class="line">    .Select(p =&gt; p.Name);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    Console.WriteLine(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1">总结</h3>
<ul>
<li>匿名函数使用 <code>delegate</code></li>
<li>Lambda表达式使用 <code>=&gt;</code></li>
<li>Linq 使用 <code>from</code>, <code>where</code>,
<code>select</code></li>
<li><a href="/utils/show_code/index.html?csharp/tds/04/Test05.cs">对比代码</a></li>
</ul>
<h2 id="运算符重载">4. 运算符重载</h2>
<ul>
<li>运算符重载有一些限制
<ul>
<li>如成对(true/false)，如类型要求，如有的不能重载</li>
</ul></li>
<li>运算符的声明</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一元运算符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 类型 <span class="keyword">operator</span> 一元运算符(类型 参数名)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元运算符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 类型 <span class="keyword">operator</span> 二元运算符(类型 参数名, 类型 参数名) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型转换运算符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> 类型 (类型 参数名) &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> 类型 (类型 参数名) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/04/Complex.cs">复数的例子</a></li>
<li><a href="/utils/show_code/index.html?csharp/tds/04/Digit.cs">数码数字的例子</a></li>
</ul>
<h2 id="异常处理">5. 异常处理</h2>
<h3 id="异常">异常</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Eception e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不管是否有异常，都会执行到 <code>finally</code>
<ul>
<li>即使在 <code>try</code> 中 <code>return</code> 了，也会执行
<code>finally</code></li>
<li><a href="/utils/show_code/index.html?csharp/tds/04/TestFinally.cs">代码</a></li>
</ul></li>
<li><code>System.Exception</code> 类</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Exception</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Exception</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性</span></span><br><span class="line">Message;</span><br><span class="line">StackTrace;</span><br></pre></td></tr></table></figure>
<h3 id="系统内部异常类">系统内部异常类</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">System.OutOfMemoryException</span><br><span class="line">System.StackOverflowException</span><br><span class="line">System.NullReferenceException</span><br><span class="line">System.TypeInitializationException</span><br><span class="line">System.InvalidCastException</span><br><span class="line">System.ArrayTypeMismatchException</span><br><span class="line">System.IndexOutOfRangeException</span><br><span class="line">System.MulticastNotSupportedException</span><br><span class="line">System.ArithmeticException</span><br><span class="line">System.DivideByZeroException</span><br><span class="line">System.OverflowException</span><br></pre></td></tr></table></figure>
<h3 id="捕获和处理异常">捕获和处理异常</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(AException e1)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(BException e2)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(更一般的Exception e)&#123;</span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>catch&#123;&#125;</code> 表示捕获所有种类的异常</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抛出异常">抛出异常</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(xxxxxx) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SomeException(信息);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义异常类">自定义异常类</h3>
<ul>
<li>从 <code>Exception</code> 或 <code>ApplicationException</code>
继承</li>
<li>重抛异常</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>异常链接</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Excepiton(<span class="string">&quot;msg&quot;</span>, e);</span><br></pre></td></tr></table></figure>
<ul>
<li>这里 e 称为内部异常</li>
<li>InnerException 属性</li>
<li>使得外部能进一步知道内部的异常原因</li>
</ul>
<h3 id="算术溢出与-checked">算术溢出与 checked</h3>
<ul>
<li>对溢出进行检查
<ul>
<li>对整个程序 csc /checked</li>
<li>对部分程序
<ul>
<li>针对表达式： checked(表达式) 及 uncheckd(表达式)</li>
<li>针对块语句： checked{...} 及 uncheckd{...}</li>
</ul></li>
<li>对溢出异常进行捕获
<ul>
<li>try{ ... } catch( OverflowException e ) { ... }</li>
</ul></li>
</ul></li>
</ul>
<h2 id="attribute">6. Attribute</h2>
<ul>
<li>用在类上</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">ComVisible(true)</span>]</span><br><span class="line">[<span class="meta">DefaultMember(<span class="string">&quot;Chars&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">String</span> : <span class="title">IComparable</span>, <span class="title">ICloneable</span>,</span><br><span class="line"><span class="title">IConvertible</span>, <span class="title">IEnumerable</span>, <span class="title">IComparable</span>&lt;<span class="title">String</span>&gt;,</span><br><span class="line"><span class="title">IEnumerable</span>&lt;<span class="title">char</span>&gt;, <span class="title">IEquatable</span>&lt;<span class="title">String</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用在方法上的</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">SecuritySafeCritical</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span>(<span class="params"><span class="built_in">char</span>[] <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">STAThread</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Attribute
是与类、结构、方法等元素相关的额外信息，是对元信息的扩展</li>
<li>通过Attribute可以使程序、甚至语言本身的功能得到增强</li>
</ul>
<h3 id="使用系统定义的-attribute">使用系统定义的 Attribute</h3>
<ul>
<li>使用 Attribute 的一般方式
<ul>
<li>在程序集、类、域、方法等前面用[]表示</li>
<li>可以省略“Attribute”几个字母，只写xxxxx</li>
<li>可以带参数
<ul>
<li>位置参数 （相当于构造方法带的参数）</li>
<li>命名参数（域名或属性名=值）</li>
</ul></li>
</ul></li>
<li>示例
<ul>
<li>在Main()方法使用[STAThread]</li>
<li>在结构上、枚举上使用：StructLayout，Flag</li>
<li>在程序集级别应用Attribute
<ul>
<li>[assembly: AssemblyCompany("")]</li>
</ul></li>
</ul></li>
</ul>
<h3 id="自定义attribute">自定义Attribute</h3>
<ul>
<li>声明 Attribute 类
<ul>
<li>从 System.Attribute 继承而来</li>
<li>名字要用 xxxxAttribute</li>
</ul></li>
<li>使用 Attribute 类
<ul>
<li>在类及成员上面使用方括号</li>
<li><strong>可以省略后缀 Attribute</strong></li>
</ul></li>
<li><strong>通过反射访问属性</strong></li>
<li><a href="/utils/show_code/index.html?csharp/tds/04/TestAttribute.cs">实例</a></li>
</ul>
<h2 id="c-语言中的其他成分">7. C# 语言中的其他成分</h2>
<h3 id="编译预处理">编译预处理</h3>
<ul>
<li>标识符声明</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个标识符</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消定义一个标识符。</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>条件处理</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span>, #<span class="keyword">elif</span>, #<span class="keyword">else</span>, #<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>信息报告</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">error</span>, #<span class="keyword">warning</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>行号标记</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">line</span> 行号 &quot;文件名&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="unsafe-及指针">unsafe 及指针</h3>
<ul>
<li>unsafe
<ul>
<li>用于修饰类、方法等</li>
</ul></li>
<li>fixed 及指针
<ul>
<li>fixed(类型 * 指针名 = 表达式) 语句</li>
</ul></li>
<li>sizeof运算符
<ul>
<li>sizeof(简单或结构类型名)</li>
</ul></li>
<li>stackalloc
<ul>
<li>在栈上分配的内存，而不是在堆上，因此不会担心内存被垃圾回收器自动回收。</li>
</ul></li>
<li>示例代码</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">FileStream</span>: <span class="title">Stream</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> handle;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">dllimport(<span class="string">&quot;kernel32&quot;</span>, SetLastError=true)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">unsafe</span> <span class="built_in">bool</span> <span class="title">ReadFile</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> hFile, <span class="keyword">void</span>* lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> nBytesToRead, <span class="built_in">int</span>* nBytesRead, Overlapped* lpOverlapped</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">unsafe</span> <span class="built_in">int</span> <span class="title">Read</span>(<span class="params"><span class="built_in">byte</span>[] buffer, <span class="built_in">int</span> index, <span class="built_in">int</span> count</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">fixed</span> (<span class="built_in">byte</span>* p = buffer) &#123;</span><br><span class="line">            ReadFile(handle, p + index, count, &amp;n, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/04/UnsafeCopy.cs">UnsafeCopy.cs</a>
<ul>
<li>unsafe 关键字需要在编译的时候加上 <code>/unsafe</code></li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译时需要: /unsafe</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsafe</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">IntToString</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">char</span>* buffer = <span class="keyword">stackalloc</span> <span class="built_in">char</span>[<span class="number">16</span>];</span><br><span class="line">        <span class="built_in">char</span>* p = buffer + <span class="number">16</span>;</span><br><span class="line">        <span class="built_in">int</span> n = <span class="keyword">value</span> &gt;= <span class="number">0</span> ? <span class="keyword">value</span> : -<span class="keyword">value</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            *--p = (<span class="built_in">char</span>)(n % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (n != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> &lt; <span class="number">0</span>) *--p = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">string</span>(p, <span class="number">0</span>, (<span class="built_in">int</span>)(buffer + <span class="number">16</span> - p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        Console.WriteLine(IntToString(<span class="number">12345</span>));</span><br><span class="line">        Console.WriteLine(IntToString(<span class="number">-999</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他关键字">其他关键字</h3>
<ul>
<li>lock
<ul>
<li>多线程程序中，lock可以将某个对象加锁</li>
</ul></li>
<li>volatile
<ul>
<li>随时可能被程序以外的其他因素所修改</li>
<li>域被 volatile 修饰时，会阻止编译器对它的优化</li>
</ul></li>
</ul>
<h2 id="程序的组织">8. 程序的组织</h2>
<ul>
<li>名字空间：程序的逻辑组织</li>
<li>嵌套类型：类中嵌套类型</li>
<li>程序集：程序的物理组织</li>
</ul>
<h3 id="名字空间">名字空间</h3>
<ul>
<li><p>名字空间的概念</p>
<ul>
<li>逻辑划分；避免名字冲突</li>
</ul></li>
<li><p>名字空间的声明</p>
<ul>
<li>可嵌套</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">xxx.xxxx</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>名字空间的导入</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> xxx.xxxx;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用别名</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> 别名 = 名字空间或类名;</span><br></pre></td></tr></table></figure>
<h3 id="嵌套类型">嵌套类型</h3>
<ul>
<li>嵌套类型的概念</li>
<li>类型中的类型</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">struct</span> C &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> A.B.C();</span><br></pre></td></tr></table></figure>
<ul>
<li>嵌套类型的可访问性
<ul>
<li>受各个层次的限制</li>
</ul></li>
</ul>
<h3 id="程序集">程序集</h3>
<ul>
<li>模块（module）
<ul>
<li>程序集（assembly）</li>
<li>exe、dll</li>
</ul></li>
<li>VS 生成一个程序集
<ul>
<li>新建项目的时候指定为<strong>类库</strong></li>
</ul></li>
<li>在 VS 上引用程序集
<ul>
<li>在项目上点右键，添加引用</li>
</ul></li>
</ul>
<h3 id="编译示例">编译示例</h3>
<p><img src="/2021/10/07/csharp/tds/04/image-20211010122605122.png" style="zoom:67%;"></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">csc /target:mod /out:Add.mod Add.cs</span><br><span class="line"></span><br><span class="line">csc /target:mod /out:Multi.mod Multi.cs</span><br><span class="line"></span><br><span class="line">al /target:library /out:MyLibrary.dll Add.mod Multi.mod</span><br><span class="line"></span><br><span class="line">csc /target:exe /out:MyClient.exe /reference:MyLibrary.dll MyClient.cs</span><br></pre></td></tr></table></figure>
<h2 id="语法总结">9. 语法总结</h2>
<h3 id="类型声明">类型声明</h3>
<ul>
<li>类型声明是 C#
程序的主体，它可以位于名字空间中，也可以是嵌套的类型</li>
<li>类型声明包括以下几种：
<ul>
<li>类 class</li>
<li>结构 struct</li>
<li>接口 interface</li>
<li>枚举 enum</li>
<li>委托 delegate</li>
</ul></li>
</ul>
<h3 id="类的成员">类的成员</h3>
<ul>
<li>常数（const）
<ul>
<li>它代表了与类相关的常数数据</li>
</ul></li>
<li>域（field）
<ul>
<li>它是类中的变量</li>
</ul></li>
<li>方法（method）
<ul>
<li>它实现了可以被类实现的计算和行为</li>
</ul></li>
<li>属性（property）
<ul>
<li>它定义了命名的属性和与对这个属性进行读写的相关行为</li>
</ul></li>
<li>事件（event）
<ul>
<li>它定义了由类产生的通知</li>
</ul></li>
<li>索引（indexer）
<ul>
<li>它允许类的实例通过与数组相同的方法来索引</li>
</ul></li>
<li>运算符（operator）
<ul>
<li>它定义了可以被应用于类的实例上的表达式运算符</li>
</ul></li>
<li>实例构造函数（instance constructor）
<ul>
<li>它执行需要对类的实例进行初始化的动作</li>
</ul></li>
<li>析构函数（destructor）
<ul>
<li>类的实例被清除时实现的动作（结构不能有析构函数）</li>
</ul></li>
<li>静态构造函数（static constructor）
<ul>
<li>它执行对类本身进行初始化的动作</li>
</ul></li>
<li>类型（type）
<ul>
<li>它代表位于类中的类型</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>csharp.tds</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#程序设计.唐大仕.06.文件与流</title>
    <url>/2021/10/18/csharp/tds/06/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1001663016">中国大学慕课</a></li>
</ul>
<h1 id="文件与流">文件与流</h1>
<h2 id="io及流">1. IO及流</h2>
<h3 id="system.io">System.IO</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br></pre></td></tr></table></figure>
<ul>
<li>提供了许多用于文件和数据流进行读写操作的类</li>
</ul>
<h3 id="流的分类">流的分类</h3>
<ul>
<li>Stream 类
<ul>
<li>按存取位置分
<ul>
<li>FileStream、MemoryStream、BufferedStream</li>
</ul></li>
</ul></li>
<li>读写类
<ul>
<li>BinaryReader、BinaryWriter</li>
<li>TextReader、TextWriter
<ul>
<li>StreamReader、StreamWriter</li>
<li>StringReader、StringWriter</li>
</ul></li>
</ul></li>
<li>示例</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">FileStream fs = <span class="keyword">new</span> FileStream(<span class="string">@&quot;c:\foo.txt&quot;</span>, FileMode.Create);</span><br><span class="line">StreamWriter writer = <span class="keyword">new</span> StreamWriter(fs);</span><br></pre></td></tr></table></figure>
<h3 id="system.io-的常用类">System.IO 的常用类</h3>
<p><img src="/2021/10/18/csharp/tds/06/image-20211018222939087.png" style="zoom:80%;"></p>
<h2 id="文件及目录">2. 文件及目录</h2>
<h3 id="文件和文件夹管理">文件和文件夹管理</h3>
<ul>
<li>对文件和文件夹操作的类</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">类</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">FileInfo</td>
<td style="text-align: center;">具体的文件</td>
</tr>
<tr class="even">
<td style="text-align: center;">File</td>
<td style="text-align: center;">提供 static 方法</td>
</tr>
<tr class="odd">
<td style="text-align: center;">DirectoryInfo</td>
<td style="text-align: center;">具体的文件夹</td>
</tr>
<tr class="even">
<td style="text-align: center;">Directory</td>
<td style="text-align: center;">提供 static 方法</td>
</tr>
<tr class="odd">
<td style="text-align: center;">FileSystemInfo</td>
<td style="text-align: center;">FileInfo 及 DirectoryInfo 的父类</td>
</tr>
<tr class="even">
<td style="text-align: center;">Path</td>
<td style="text-align: center;">文件路径类</td>
</tr>
</tbody>
</table>
<h3 id="文件及文件夹的信息">文件及文件夹的信息</h3>
<ul>
<li>FileInfo 对象可以获取<strong>文件</strong>大小等各种信息</li>
<li>DirectoryInfo 对象可以获取<strong>文件夹</strong>大小等各种信息</li>
</ul>
<h3 id="fileinfo">FileInfo</h3>
<ul>
<li>建立对象</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> FileInfo(<span class="string">&quot;文件物理路径&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>常用属性</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">属性</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Name</td>
<td style="text-align: center;">文件名称</td>
</tr>
<tr class="even">
<td style="text-align: center;">Extension</td>
<td style="text-align: center;">文件扩展名</td>
</tr>
<tr class="odd">
<td style="text-align: center;">FullName</td>
<td style="text-align: center;">文件完全路径（物理路径）</td>
</tr>
<tr class="even">
<td style="text-align: center;">Length</td>
<td style="text-align: center;">文件大小，单位为字节</td>
</tr>
<tr class="odd">
<td style="text-align: center;">CreationTime</td>
<td style="text-align: center;">文件创建时间</td>
</tr>
<tr class="even">
<td style="text-align: center;">LastAccessTime</td>
<td style="text-align: center;">文件上次访问时间</td>
</tr>
<tr class="odd">
<td style="text-align: center;">LastWriteTime</td>
<td style="text-align: center;">文件上次修改时间</td>
</tr>
<tr class="even">
<td style="text-align: center;">DirectoryName</td>
<td style="text-align: center;">所在文件夹</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Attributes</td>
<td style="text-align: center;">文件属性，如只读、隐藏等</td>
</tr>
</tbody>
</table>
<h3 id="directoryinfo">DirectoryInfo</h3>
<ul>
<li>建立该对象</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> DirectoryInfo(文件物理路径);</span><br></pre></td></tr></table></figure>
<ul>
<li>常用属性</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">属性</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Name</td>
<td style="text-align: center;">文件夹名称</td>
</tr>
<tr class="even">
<td style="text-align: center;">FullName</td>
<td style="text-align: center;">文件夹完全路径（物理路径）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">CreationTime</td>
<td style="text-align: center;">文件夹创建时间</td>
</tr>
<tr class="even">
<td style="text-align: center;">LastAccessTime</td>
<td style="text-align: center;">文件夹上次访问时间</td>
</tr>
<tr class="odd">
<td style="text-align: center;">LastWriteTime</td>
<td style="text-align: center;">文件夹上次修改时间</td>
</tr>
<tr class="even">
<td style="text-align: center;">Parent</td>
<td style="text-align: center;">父文件夹</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Root</td>
<td style="text-align: center;">所在根目录</td>
</tr>
</tbody>
</table>
<h3 id="文件操作">文件操作</h3>
<ul>
<li>File 类的 static 方法</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">File.Create(filePath);</span><br><span class="line">File.Copy(filePath1,filePath2);</span><br><span class="line">File.Move(filePath1,filePath2);</span><br><span class="line">File.Delete(filePath);</span><br><span class="line">File.Exists(filePath);</span><br><span class="line">File.CreateText(filePath);</span><br></pre></td></tr></table></figure>
<ul>
<li>Directory 的 static 方法</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Directory.CreateDirectory(DirPath);</span><br><span class="line">Directory.Move(DirPath1,DirPath2);</span><br><span class="line">Directory.Delete(DirPath);</span><br><span class="line">Directory.Exists(DirPath);</span><br><span class="line">Directory.GetDirectories(DirPath);</span><br><span class="line">Directory.GetFiles(DirPath);</span><br></pre></td></tr></table></figure>
<h3 id="子文件">子文件</h3>
<ul>
<li>显示指定文件夹下的子文件夹和子文件</li>
<li>Directory
<ul>
<li>GetDirectories 和 GetFiles的 static 方法</li>
</ul></li>
<li>DirectoryInfo
<ul>
<li>GetDirectories 和 GetFiles实例方法</li>
<li>这两个方法分别返回 DirectoryInfo 对象数组和 FileInfo 对象数组</li>
</ul></li>
</ul>
<h3 id="path">Path</h3>
<ul>
<li>方法</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ChangeExtension</span>(<span class="params"><span class="built_in">string</span> path, <span class="built_in">string</span> extension</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Combine</span>(<span class="params"><span class="built_in">string</span> path1, <span class="built_in">string</span> path2, <span class="built_in">string</span> path3</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Combine</span>(<span class="params"><span class="built_in">string</span> path1, <span class="built_in">string</span> path2</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Combine</span>(<span class="params"><span class="built_in">string</span> path1, <span class="built_in">string</span> path2, <span class="built_in">string</span> path3, <span class="built_in">string</span> path4</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Combine</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] paths</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetDirectoryName</span>(<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetExtension</span>(<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetFileName</span>(<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetFileNameWithoutExtension</span>(<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetFullPath</span>(<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">char</span>[] <span class="title">GetInvalidFileNameChars</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">char</span>[] <span class="title">GetInvalidPathChars</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetPathRoot</span>(<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetRandomFileName</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetTempFileName</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetTempPath</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">HasExtension</span>(<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsPathRooted</span>(<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="示例递归查看所有文件">示例：递归查看所有文件</h3>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/06/ListAllFiles.cs">ListAllFiles.cs</a></li>
</ul>
<h3 id="文件监视器">文件监视器</h3>
<ul>
<li>很有趣的功能</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Watcher</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">string</span> path = <span class="string">@&quot;D:\Code\C_plus_plus\&quot;</span>;</span><br><span class="line">        FileSystemWatcher watcher = <span class="keyword">new</span> FileSystemWatcher();</span><br><span class="line">        watcher.Path = path;</span><br><span class="line">        watcher.Filter = <span class="string">&quot;*.cpp&quot;</span>;</span><br><span class="line">        watcher.NotifyFilter = NotifyFilters.LastAccess |</span><br><span class="line">            NotifyFilters.LastWrite | NotifyFilters.FileName |</span><br><span class="line">            NotifyFilters.DirectoryName;</span><br><span class="line">        <span class="comment">// 事件处理函数</span></span><br><span class="line">        watcher.Changed += <span class="keyword">new</span> FileSystemEventHandler(OnChanged);</span><br><span class="line">        watcher.Created += <span class="keyword">new</span> FileSystemEventHandler(OnChanged);</span><br><span class="line">        watcher.Deleted += <span class="keyword">new</span> FileSystemEventHandler(OnChanged);</span><br><span class="line">        watcher.Renamed += <span class="keyword">new</span> RenamedEventHandler(OnRenamed);</span><br><span class="line">        <span class="comment">// 开始监视</span></span><br><span class="line">        watcher.EnableRaisingEvents = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 等用户输入 q 才结束程序</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Press&#x27;q&#x27; to quit the sample.&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (Console.Read() != <span class="string">&#x27;q&#x27;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 事件处理函数.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnChanged</span>(<span class="params"><span class="built_in">object</span> source, FileSystemEventArgs e</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 显示哪些文件做了何种修改</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;File: &quot;</span> + e.FullPath + <span class="string">&quot; &quot;</span> + e.ChangeType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnRenamed</span>(<span class="params"><span class="built_in">object</span> source, RenamedEventArgs e</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 显示被更改的文件名</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;File: &#123;0&#125; renamed to &#123;1&#125;&quot;</span>, e.OldFullPath, e.FullPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件内容处理">3. 文件内容处理</h2>
<h3 id="文本文件的操作">文本文件的操作</h3>
<ul>
<li>StreamReader、StreamWriter</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> StreamReader(<span class="string">&quot;文件路径&quot;</span>, FileEncode);</span><br><span class="line">ReadLine();</span><br><span class="line">ReadToEnd();</span><br><span class="line">Read();</span><br><span class="line">Peek();</span><br><span class="line">Close();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> StreamWriter(<span class="string">&quot;文件路径&quot;</span>, FileMode, FileEncode)</span><br><span class="line">WriteLine();</span><br><span class="line">Write();</span><br><span class="line">Flush();</span><br><span class="line">Close();</span><br></pre></td></tr></table></figure>
<h3 id="二进制文件的操作">二进制文件的操作</h3>
<ul>
<li>FileStream</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> FileStream(<span class="string">&quot;文件路径&quot;</span>, FileMode, FileAccess);</span><br><span class="line">Seek();</span><br><span class="line">Read();</span><br></pre></td></tr></table></figure>
<h3 id="示例代码">示例代码</h3>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/06/Logger.cs">Logger</a></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> fname = LogFile;</span><br><span class="line">    StreamWriter writer =</span><br><span class="line">        <span class="keyword">new</span> StreamWriter(fname, <span class="literal">true</span>, System.Text.Encoding.Default);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    writer.Close();</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用 FileStream 构造 StreamReader</span></span><br><span class="line">FileStream fin = <span class="keyword">new</span> FileStream(infname, FileMode.Open, FileAccess.Read);</span><br><span class="line">FileStream fout = <span class="keyword">new</span> FileStream(outfname, FileMode.Create, FileAccess.Write);</span><br><span class="line"></span><br><span class="line">StreamReader brin = <span class="keyword">new</span> StreamReader(fin, System.Text.Encoding.Default);</span><br><span class="line">StreamWriter brout = <span class="keyword">new</span> StreamWriter(fout, System.Text.Encoding.Default);</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/06/BmpFileReader.cs">BmpFileReader</a>
<ul>
<li>读取二进制文件</li>
<li>里面有 24 位位图的格式</li>
</ul></li>
</ul>
<h3 id="序列化与反序列化">序列化与反序列化</h3>
<ul>
<li>在对象上使用 [Serializble]</li>
<li>使用 BinaryFormatter 或 XmlSerializer 进行序列化</li>
<li><a href="/utils/show_code/index.html?csharp/tds/06/SerializationTest.cs">SerializationTest</a>
<ul>
<li>BinaryFormatter</li>
</ul></li>
</ul>
<h2 id="注册表操作">4. 注册表操作</h2>
<h3 id="什么是注册表">什么是注册表</h3>
<ul>
<li>存放计算机运行方式的配置信息的树状表</li>
<li>其中包括 Windows
操作系统配置信息、应用程序配置信息、专用用户设备配置信息、环境配置信息等</li>
</ul>
<h3 id="打开注册表">打开注册表</h3>
<ul>
<li>命令行</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">regedit</span><br></pre></td></tr></table></figure>
<h3 id="编程相关类">编程相关类</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.Win32;</span><br></pre></td></tr></table></figure>
<ul>
<li>Registry、RegistryKey
<ul>
<li>它们都是 sealed 类，即不能被继承</li>
</ul></li>
<li><a href="/utils/show_code/index.html?csharp/tds/06/RegistryUtil.cs">编程实例</a></li>
</ul>
]]></content>
      <categories>
        <category>csharp.tds</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#程序设计.唐大仕.06.Windows窗体与控件</title>
    <url>/2021/11/04/csharp/tds/07/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1001663016">中国大学慕课</a></li>
</ul>
<h1 id="windows-窗体与控件">Windows 窗体与控件</h1>
<h2 id="布局与事件处理">1. 布局与事件处理</h2>
<ul>
<li>基本问题：界面的布局、事件的处理</li>
</ul>
<h3 id="界面布局">界面布局</h3>
<ul>
<li>添加控件</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">控件.Controls.Add(...);</span><br><span class="line">控件.Controls.AddRange(...);</span><br></pre></td></tr></table></figure>
<ul>
<li>设置位置
<ul>
<li>绝对布局
<ul>
<li><strong>Location</strong>——以像素为单位，设置控件的 X 坐标和 Y
坐标</li>
<li><strong>Size</strong>——以像素为单位，设置控件的宽度和高度</li>
</ul></li>
<li>相对布局
<ul>
<li><strong>Anchor</strong>——把控件附着在窗体的一个或多个边框上</li>
<li><strong>Dock</strong>——把控件和窗体的一个或多个边框连接起来</li>
</ul></li>
</ul></li>
<li>示例</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.btn1.Anchor =</span><br><span class="line">    System.Windows.Forms.AnchorStyles.Left</span><br><span class="line">    | System.Windows.Forms.AnchorStyles.Top;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.btn2.Dock =</span><br></pre></td></tr></table></figure>
<h3 id="事件">事件</h3>
<ul>
<li><p>低级事件与高级事件</p>
<ul>
<li>KeyDown/KeyUp <span class="math inline">\(\to\)</span>
KeyPressed</li>
<li>TextChange</li>
</ul></li>
<li><p>事件及其注册</p>
<ul>
<li>事件/委托/事件参数</li>
</ul>
<p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">btn.Click+=<span class="keyword">new</span> EventHandler(btn_Clicked);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">btn_Cliked</span>(<span class="params"><span class="built_in">object</span> sender, EventArgse </span>)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>使用匿名函数及Lambda表达式</li>
</ul></li>
</ul>
<h3 id="示例">示例</h3>
<ul>
<li><a href="/resources/Code/csharp/tds/07/My_Explorer.zip">FileExplorer.zip</a>
<ul>
<li>TreeView + Splitter + ListView</li>
</ul></li>
</ul>
<p><img src="/2021/11/04/csharp/tds/07/image-20211104115157131.png" style="zoom:80%;"></p>
<h2 id="常用控件">2. 常用控件</h2>
<ul>
<li>控件 Control 类
<ul>
<li>Windows 中控件都是 <code>System.Windows.Forms.Control</code>
的子类</li>
<li>实现了 <code>IDisposable</code> 等接口</li>
</ul></li>
<li>控件与组件
<ul>
<li>控件：在界面中显示</li>
<li>组件：功能与界面相关，但是不在界面中显示</li>
</ul></li>
</ul>
<h3 id="常用属性">常用属性</h3>
<ul>
<li><p>外观</p>
<ul>
<li>Size（大小），Width（宽度），Height（高度）</li>
<li>Location（位置），Left，Right，Top，Bottom</li>
<li>Font（字体），ForeColor（前景色），BackColor（背景色）</li>
</ul></li>
<li><p>状态</p>
<ul>
<li><p>Visible（可见），Enabled（使能）</p></li>
<li><p>Text（文本），BackgroundImage（背景图片）</p></li>
<li><p>Tag（标记数据，类型为 object 任意类型）</p></li>
</ul></li>
</ul>
<h3 id="常用事件">常用事件</h3>
<ul>
<li>KeyXXXX 键盘事件
<ul>
<li>KeyDown、KeyUp、KeyPress</li>
</ul></li>
<li>MouseXXX 鼠标事件
<ul>
<li>MouseDown、MouseUp、MouseMove、MouseEnter、MouseHover、MouseLeave</li>
</ul></li>
<li>Click/DoubleClick 事件</li>
<li>GotFocus 事件</li>
<li>TextChange 事件</li>
</ul>
<h3 id="常用控件-1">常用控件</h3>
<ul>
<li><p>标签 Label</p></li>
<li><p>链接标签 LinkedLabel</p></li>
<li><p>文本框 TextBox</p>
<ul>
<li>PasswordChar 可使之成为密码框</li>
<li>MultiLine 多行文本</li>
<li>ScrollBars 滚动条</li>
<li>ReadOnly 只读</li>
</ul></li>
<li><p>按钮 Button</p></li>
<li><p>复选框 CheckBox</p></li>
<li><p>单选框 RadioButton</p>
<ul>
<li>Checked属性</li>
<li>容器，如 GroupBox</li>
</ul></li>
<li><p>列表框 ListBox</p>
<ul>
<li>复选列表框</li>
<li>Xxxx.Items. Add(..)</li>
</ul></li>
<li><p>组合框 ComboBox</p></li>
<li><p>数字框 NumbericUpDown</p>
<ul>
<li>Value属性</li>
</ul></li>
<li><p>日期时间框 DateTimePicker</p>
<ul>
<li>Value属性</li>
<li>Format 及 CustomFormat 属性 "yy-MM-dd"</li>
</ul></li>
<li><p>掩码文本框 MaskedTextBox</p>
<ul>
<li><strong>满足一定条件的文本框</strong></li>
<li>Mask属性</li>
</ul></li>
<li><p>进度条 ProgressBar</p>
<ul>
<li>Maximum（最大值）、Minimum（最小值）</li>
<li>Step（步进值）</li>
<li>Value（当前值）</li>
</ul></li>
<li><p>PictureBox 图片框</p>
<ul>
<li>Image 属性</li>
<li>SizeMode 属性：拉伸、重复</li>
</ul></li>
<li><p>RichTextBox 富文本框</p>
<p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">.Select(start,len);</span><br><span class="line">.SelectText=<span class="string">&quot;...&quot;</span>;</span><br><span class="line">.SelectionColor/Font;</span><br></pre></td></tr></table></figure></p></li>
<li><p>WebBrowser 网页浏览器</p>
<ul>
<li>可以浏览网页、flash 文件、动画、多媒体等</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Navigate(<span class="string">&quot;http://www.dstang.com&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>TreeView、ListView
<ul>
<li><a href="/resources/Code/csharp/tds/07/My_Explorer.zip">FileExplorer.zip</a></li>
</ul></li>
</ul>
<h3 id="容器控件">容器控件</h3>
<ul>
<li>流式布局面板 FlowLayoutPanel</li>
<li>成组框 GroupBox</li>
<li>面板 Panel</li>
<li>分隔容器 SplitContainer</li>
<li>选项卡 TabControl</li>
<li>表格布局面板 TableLayoutPanel</li>
</ul>
<h2 id="窗体">3. 窗体</h2>
<ul>
<li>Form 类是 Control 类的子类</li>
<li>特殊的属性
<ul>
<li>边框、标题栏、启始位置、窗体是否最大化等</li>
</ul></li>
</ul>
<h3 id="多窗体">多窗体</h3>
<ul>
<li>打开与关闭
<ul>
<li>Show()</li>
<li>ShowDialog()
<ul>
<li>对话框</li>
</ul></li>
<li>事件：closing、closed
<ul>
<li>可以设置参数 e.Cancel 取消关闭</li>
</ul></li>
</ul></li>
<li>交互信息
<ul>
<li>Static 变量</li>
<li>通过<strong>构造函数</strong>或<strong>属性</strong>传递变量</li>
</ul></li>
</ul>
<h2 id="菜单工具栏对话框">4. 菜单、工具栏、对话框</h2>
<ul>
<li>Windows 应用程序的菜单（Menu）控件分为三个种类
<ul>
<li>MainMenu、ContextMenu、MenuItem</li>
</ul></li>
<li>工具栏（ToolBar）可以说是工具栏按钮（ToolBarButton）的集合控件，它将常用的按钮以图标的形式集中表现
<ul>
<li>状态栏也是窗口应用程序中很重要的脚色。在状态栏上一般通知用户目前的时间、打开哪个文件等。</li>
</ul></li>
<li>对话框
<ul>
<li>OpenFileDialog</li>
<li>SaveFileDialog</li>
<li>FolderBrowserDialog</li>
<li>ColorDialog</li>
<li>FontDialog</li>
</ul></li>
<li>SDI 及 MDI 应用程序
<ul>
<li>单文档界面 （SDI）</li>
<li>多文档界面 （MDI）应用程序</li>
</ul></li>
<li>示例代码
<ul>
<li><a href="/resources/Code/csharp/tds/07/FileExplorer.zip">FileExplorer.zip</a></li>
</ul></li>
</ul>
<h2 id="用户控件">5. 用户控件</h2>
<ul>
<li>用户控件：多个控件组合</li>
<li>自动在工具箱中，可拖放到窗体上</li>
<li><strong>处理 Paint</strong>
<ul>
<li>重载</li>
</ul></li>
<li>对外公开属性、方法、事件</li>
<li>自定义控件示例
<ul>
<li><a href="/resources/Code/csharp/tds/07/SevenSegment.zip">SevenSegment.zip</a></li>
</ul></li>
</ul>
<p><img src="/2021/11/04/csharp/tds/07/image-20211104220502101.png" style="zoom:80%;"></p>
<h3 id="继承控件">继承控件</h3>
<ul>
<li>继承</li>
<li>处理Paint</li>
<li>为控件添加设计支持</li>
</ul>
<h2 id="类设计器">6. 类设计器</h2>
<ul>
<li>VS 社区版没有类设计器的功能，需要自己安装</li>
<li>安装
<ul>
<li>工具 <span class="math inline">\(\to\)</span> 获取工具和功能 <span class="math inline">\(\to\)</span> vs installer <span class="math inline">\(\to\)</span> 单个组件 <span class="math inline">\(\to\)</span> 类设计器</li>
</ul></li>
<li>使用
<ul>
<li>右键 <span class="math inline">\(\to\)</span> 查看类图</li>
</ul></li>
</ul>
<p><img src="/2021/11/04/csharp/tds/07/image-20211104221859874.png" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>csharp.tds</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#程序设计.唐大仕.08.绘图及图像</title>
    <url>/2021/11/04/csharp/tds/08/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1001663016">中国大学慕课</a></li>
</ul>
<h1 id="绘图及图像">绘图及图像</h1>
<h2 id="gdi及其基本类">1. GDI+及其基本类</h2>
<ul>
<li>GDI：Graphics Device Interface</li>
<li>GDI+：GDI的改进
<ul>
<li>是 .NET 框架结构的重要组成部分</li>
<li>和 GDI
一样它提供对<strong>二维图形图像</strong>和<strong>文字排版处理</strong>的支持</li>
</ul></li>
</ul>
<h3 id="使用示例">使用示例</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Graphics g = <span class="keyword">this</span>.CreateGraphics();</span><br><span class="line">Pen pen = <span class="keyword">new</span> Pen(Color.Red, <span class="number">2</span>);</span><br><span class="line">Brush brush = <span class="keyword">new</span> SolidBrush(Color.Blue);</span><br><span class="line">Font font = <span class="keyword">new</span> Font(<span class="string">&quot;宋体&quot;</span>, <span class="number">24</span>);</span><br><span class="line">Rectangle rect = <span class="keyword">new</span> Rectangle(<span class="number">20</span>,<span class="number">120</span>,<span class="number">100</span>,<span class="number">160</span>);</span><br><span class="line"></span><br><span class="line">g.DrawLine(pen, <span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">g.DrawRectangle(pen, rect);</span><br><span class="line">g.DrawString(<span class="string">&quot;GDI+图形编程&quot;</span>, font, brush, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">brush.Dispose();</span><br><span class="line">font.Dispose();</span><br><span class="line">pen.Dispose();</span><br><span class="line">g.Dispose();</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/04/csharp/tds/08/image-20211104230409377.png" style="zoom:80%;"></p>
<ul>
<li>Pen：画边框</li>
<li>Brush：填充</li>
</ul>
<h3 id="net-对-gdi-的封装">.NET 对 GDI+ 的封装</h3>
<p><img src="/2021/11/04/csharp/tds/08/image-20211106151639966.png" style="zoom:80%;"></p>
<h3 id="坐标系统">坐标系统</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">o---------------&gt; x</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">v</span><br><span class="line"></span><br><span class="line">y</span><br></pre></td></tr></table></figure>
<h3 id="system.drawing-中常用的结构">System.Drawing 中常用的结构</h3>
<h4 id="color">Color</h4>
<ul>
<li>Color 封装了对颜色的定义</li>
<li>该结构中封装了数百个分别对应与标准调色板色彩的静态成员
<ul>
<li>Color.Red：红色</li>
<li>Color.Purple：紫色</li>
</ul></li>
<li>有用的静态方法
<ul>
<li>FromArgb：通过三原色构建 Color 对象</li>
<li>FromKnownColor：通过已知颜色构建 Color 对象</li>
<li>FromName：通过颜色名称来构建 Color 对象</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Color temp1 = Color.Black;</span><br><span class="line">Color temp2 = Color.FromArgb(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">Color temp3 = Color.FromName(<span class="string">&quot;Black&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="size-和-sizef">Size 和 SizeF</h4>
<ul>
<li>表示绘制平面上的一个尺寸
<ul>
<li>Size：整数</li>
<li>SizeF：浮点数</li>
</ul></li>
<li>属性
<ul>
<li>Width：表示宽度值</li>
<li>Height：表示高度值</li>
</ul></li>
<li>重载了<strong>加、减、比较、赋值操作</strong></li>
</ul>
<h4 id="point-和-pointf">Point 和 PointF</h4>
<ul>
<li>表示绘制平面上点的坐标，一个为整数，另外一个为浮点数</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Point pt = <span class="keyword">new</span> Point(<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">Point pt = <span class="keyword">new</span> Point(<span class="keyword">new</span> Size(<span class="number">10</span>,<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>重载了加、减、比较、赋值操作</li>
</ul>
<h4 id="rectangle-和-rectanglef">Rectangle 和 RectangleF</h4>
<ul>
<li>表示绘制平面上的一个矩形区域</li>
<li>属性</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">属性</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Bottom</td>
<td style="text-align: center;">矩形底部的纵坐标</td>
</tr>
<tr class="even">
<td style="text-align: center;">Top</td>
<td style="text-align: center;">矩形顶部的纵坐标</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Left</td>
<td style="text-align: center;">矩形坐部的横坐标</td>
</tr>
<tr class="even">
<td style="text-align: center;">Right</td>
<td style="text-align: center;">矩形右部的横坐标</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Height</td>
<td style="text-align: center;">矩形的高度</td>
</tr>
<tr class="even">
<td style="text-align: center;">Width</td>
<td style="text-align: center;">矩形的宽度</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Size</td>
<td style="text-align: center;">矩形的尺寸</td>
</tr>
<tr class="even">
<td style="text-align: center;">IsEmpty</td>
<td style="text-align: center;">矩形是否为空（高度和宽度是否都是0）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">X</td>
<td style="text-align: center;">矩形左上角的横坐标</td>
</tr>
<tr class="even">
<td style="text-align: center;">Y</td>
<td style="text-align: center;">矩形左上角的纵坐标</td>
</tr>
</tbody>
</table>
<h2 id="graphics-对象及绘图方法">2. Graphics 对象及绘图方法</h2>
<h3 id="graphics-对象">Graphics 对象</h3>
<h4 id="得到-graphics-对象">得到 Graphics 对象</h4>
<ul>
<li>OnPaint 事件中使用</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">Protected <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPaint</span>(<span class="params">PaintEventArgse</span>)</span>&#123;</span><br><span class="line">    Graphics g = e.Graphics;</span><br><span class="line">    <span class="comment">// 这里的 Graphics 对象不是我们的创建的</span></span><br><span class="line">    <span class="comment">// 我们不要去 dispose 它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在其他情况使用</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Graphics g = <span class="keyword">this</span>.CreateGraphics();</span><br><span class="line"><span class="comment">// 需要 dispose</span></span><br></pre></td></tr></table></figure>
<h4 id="关于-graphics-的释放">关于 Graphics 的释放</h4>
<ul>
<li><p>对于 CreateGraphics() 得到的 Graphics 对象</p>
<ul>
<li>系统会自动释放，也可以显式地释放</li>
</ul>
<p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">g.Dispose();</span><br></pre></td></tr></table></figure></p>
<ul>
<li>也可以使用 using 的写法</li>
</ul>
<p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span>(Graphics g = <span class="keyword">this</span>.CreateGraphics()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这种写法相当于</li>
</ul>
<p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    g.Dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="graphics-对象绘图方法">Graphics 对象绘图方法</h4>
<ul>
<li>Draw：绘制边框</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">属性</th>
<th style="text-align: left;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">DrawArc</td>
<td style="text-align: left;">绘制圆弧</td>
</tr>
<tr class="even">
<td style="text-align: left;">DrawBezier</td>
<td style="text-align: left;">绘制贝塞尔曲线</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DrawBeziers</td>
<td style="text-align: left;">绘制贝塞尔曲线组</td>
</tr>
<tr class="even">
<td style="text-align: left;">DrawClosedCurve</td>
<td style="text-align: left;">绘制封闭曲线</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DrawCurve</td>
<td style="text-align: left;">绘制曲线</td>
</tr>
<tr class="even">
<td style="text-align: left;">DrawEllipse</td>
<td style="text-align: left;">绘制椭圆</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DrawIcon</td>
<td style="text-align: left;">绘制图标</td>
</tr>
<tr class="even">
<td style="text-align: left;">DrawIconUnstretched</td>
<td style="text-align: left;">无缩放绘制图标</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DrawImage</td>
<td style="text-align: left;">绘制图像</td>
</tr>
<tr class="even">
<td style="text-align: left;">DrawImageUnscaled</td>
<td style="text-align: left;">无缩放绘制图像</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DrawLine</td>
<td style="text-align: left;">绘制直线</td>
</tr>
<tr class="even">
<td style="text-align: left;">DrawLines</td>
<td style="text-align: left;">绘制直线组</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DrawPath</td>
<td style="text-align: left;">绘制 GraphicsPath 对象</td>
</tr>
<tr class="even">
<td style="text-align: left;">DrawPie</td>
<td style="text-align: left;">绘制圆饼</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DrawPolygon</td>
<td style="text-align: left;">绘制多边形</td>
</tr>
<tr class="even">
<td style="text-align: left;">DrawRectangle</td>
<td style="text-align: left;">绘制矩形</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DrawRectangles</td>
<td style="text-align: left;">绘制矩形组</td>
</tr>
<tr class="even">
<td style="text-align: left;">DrawString</td>
<td style="text-align: left;">绘制文本</td>
</tr>
</tbody>
</table>
<ul>
<li>Fill：填充</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">FillClosedCurve</td>
<td>绘制实心封闭曲线</td>
</tr>
<tr class="even">
<td style="text-align: left;">FillEllipe</td>
<td>封闭实心椭圆</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FillPath</td>
<td>GraphicsPath 对象</td>
</tr>
<tr class="even">
<td style="text-align: left;">FillPie</td>
<td>绘制实心圆饼</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FillPolygon</td>
<td>绘制实心多边形</td>
</tr>
<tr class="even">
<td style="text-align: left;">FillRectangle</td>
<td>绘制实心矩形</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FillRectangles</td>
<td>绘制实心矩形组</td>
</tr>
<tr class="even">
<td style="text-align: left;">FillRegion</td>
<td>绘制实心 Region 对象</td>
</tr>
</tbody>
</table>
<h3 id="pen-对象">Pen 对象</h3>
<ul>
<li>System.Drawing 名称空间中</li>
<li>用来指定图形的轮廓，如<strong>颜色</strong>和<strong>宽度</strong>等</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 画笔创建</span></span><br><span class="line">Pen pen= <span class="keyword">new</span> Pen(Color.Blue, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Pens 类，直接用系统定义好的 Pen</span></span><br><span class="line">Pen p = Pens.Red;</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">属性</th>
<th style="text-align: left;">描述</th>
<th style="text-align: left;">取值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Alignment</td>
<td style="text-align: left;">指定相对于理论上、零宽度的线条的 Pen
对象的对齐方式</td>
<td style="text-align: left;">PenAlignment.Center：位于所绘制线条的中央
<br>PenAlignment.Insert：位于所绘制线条的嵌入内部
<br>PenAlignment.Left：位于所绘制线条的左侧
<br>PenAlignment.OutSet：位于所绘制线条的嵌入外部
<br>PenAlignment.Right：位于所绘制线条的右侧 <br></td>
</tr>
<tr class="even">
<td style="text-align: left;">DashStyle</td>
<td style="text-align: left;">绘制线条的虚线类型</td>
<td style="text-align: left;">DashStyle.Custom：用户自定义<br>DashStyle.Dash：线段<br>DashStyle.DashDot：线段和点<br>DashStyle.DashDotDot：线段、点和点<br>DashStyle.Dot：点<br>DashStyle.Solid：实线</td>
</tr>
<tr class="odd">
<td style="text-align: left;">StartCap<br>EndCap</td>
<td style="text-align: left;">绘制线条的起点和终点类型 LineCap</td>
<td style="text-align: left;">LAnchorMask
用于检查线帽是否为锚头帽的掩码<br>ArrowAnchor 箭头状锚头帽<br>Custom
自定义线帽<br>DiamondAnchor 菱形锚头帽<br>Flat 平线帽<br>NoAnchor
没有锚<br>Round 圆线帽<br>RoundAnchor 圆锚头帽<br>Square
方线帽<br>SquareAnchor 方锚头帽<br>Triangle 三角线帽</td>
</tr>
</tbody>
</table>
<h3 id="brush-对象">Brush 对象</h3>
<ul>
<li>Brush 是一个<strong>抽象类</strong>，不能被直接 new 实例化</li>
<li>它有５个派生类，分别实行不同类型的画刷
<ul>
<li>SolidBrush：实心画刷（最简单）</li>
<li>HatchBrush：带阴影线的画刷</li>
<li>LinearGradientBrush：填充颜色线性渐变的画刷</li>
<li>PathGradientBrush：填充颜色沿路径渐变的画刷</li>
<li>TextureBrush：使用图像进行填充的画刷</li>
</ul></li>
<li>使用 Brushes 类
<ul>
<li>Brushes.Red</li>
</ul></li>
</ul>
<h3 id="文本绘制">文本绘制</h3>
<ul>
<li>Font 类
<ul>
<li>FontFamiliy、字体大小、字体风格（Bold、Italic、Regular、Strikeout、Underline）</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Font myFont = <span class="keyword">new</span> Font(<span class="string">&quot;宋体&quot;</span>, <span class="number">16</span>, FontStyle.Bold|FontStyle.Italic);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>DrawString()</code> 函数各种重载</li>
</ul>
<h3 id="transform">Transform</h3>
<ul>
<li>3x3 矩阵</li>
</ul>
<h3 id="示例代码片段">示例代码片段</h3>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/08/Pen.cs">Pen</a></li>
<li><a href="/utils/show_code/index.html?csharp/tds/08/FontFamily.cs">显示不同字体</a></li>
<li><a href="/utils/show_code/index.html?csharp/tds/08/Brush.cs">Brush</a></li>
<li><a href="/utils/show_code/index.html?csharp/tds/08/Test1.cs">图形绘制</a></li>
<li><a href="/utils/show_code/index.html?csharp/tds/08/Font.cs">Path
的效果</a></li>
</ul>
<h3 id="绘制应用">绘制应用</h3>
<ul>
<li>绘制函数图</li>
<li><a href="/resources/Code/csharp/tds/08/MOOC.zip">慕课展示代码</a></li>
</ul>
<h3 id="一些笔记">一些笔记</h3>
<ul>
<li>在图片上绘制文字得一种方法</li>
<li>将图片复制到剪切板</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Graphics g = Graphics.FromImage(image);</span><br><span class="line">Font font = <span class="keyword">new</span> System.Drawing.Font(<span class="string">&quot;微软雅黑&quot;</span>, <span class="number">12</span>, (System.Drawing.FontStyle.Bold));</span><br><span class="line">LinearGradientBrush brush = <span class="keyword">new</span> LinearGradientBrush(</span><br><span class="line">    <span class="keyword">new</span> Rectangle(<span class="number">0</span>, <span class="number">0</span>, image.Width, image.Height),</span><br><span class="line">    Color.White,</span><br><span class="line">    Color.FromArgb(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>),</span><br><span class="line">    <span class="number">1.2f</span>,</span><br><span class="line">    <span class="literal">true</span>);</span><br><span class="line">g.DrawString(textBox1.Text, font, brush, <span class="number">100</span>, <span class="number">184</span>);</span><br><span class="line">g.DrawString(textBox2.Text, font, brush, <span class="number">100</span>, <span class="number">417</span>);</span><br><span class="line">g.DrawString(textBox3.Text, font, brush, <span class="number">100</span>, <span class="number">650</span>);</span><br><span class="line">g.Dispose();</span><br><span class="line">pictureBox1.Image = image;</span><br><span class="line"><span class="comment">// 将图片复制到剪切板</span></span><br><span class="line">Clipboard.SetDataObject(pictureBox1.Image);</span><br></pre></td></tr></table></figure>
<ul>
<li>屏保程序编程方式
<ul>
<li>LuminousClock.sln</li>
</ul></li>
</ul>
<h2 id="控件与绘图">3. 控件与绘图</h2>
<h3 id="控件重绘">控件重绘</h3>
<ul>
<li>paint 事件发生情况
<ul>
<li>窗体 A 覆盖了窗体 B，当窗体 A 移开的时候，窗体 B 得 paint
事件会被触发</li>
</ul></li>
<li>强制程序进行重绘</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使控件的特定区域无效并向控件发送绘制消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Invalidate</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Invalidate</span>(<span class="params">Rectangle</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使控件重绘其工作区内的无效区域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于 this.Invalidate(true); this.Update();</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Refresh</span>()</span>;</span><br></pre></td></tr></table></figure>
<h3 id="双缓冲技术">双缓冲技术</h3>
<ul>
<li>Double Buffer</li>
<li>预先在内存中绘制好图像，然后再一次性绘制到屏幕上</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 在内存中建立一块虚拟画布</span></span><br><span class="line">Bitmap bmp = <span class="keyword">new</span> Bitmap(<span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.获取这块内存画布的 Graphics 引用</span></span><br><span class="line">Graphics g = Graphics.FromImage(bmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 在这块内存画布上绘图</span></span><br><span class="line">g.FillEllipse(brush, i* <span class="number">10</span>, j * <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 将内存画布画到窗口中</span></span><br><span class="line"><span class="keyword">this</span>.CreateGraphics().DrawImage(bmp, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>直接设置控件的 DoubleBuffered 属性为 true</strong></li>
</ul>
<h2 id="bitmap-类及图像处理">4. Bitmap 类及图像处理</h2>
<ul>
<li>GDI+ 中对图像处理提供了以下支持：
<ul>
<li>支持 BMP、GIF、JPEG、PNG、TIFF、ICON 等等广泛格式的图像文件</li>
<li>提供了用于多种光栅图像格式进行编码和解码的公共接口</li>
<li>支持为图像格式添加动态格式</li>
<li>支持对图像的像素进行多种处理，包括亮度、对比度、颜色平衡、模糊、消弱等</li>
<li>支持对图像进行旋转、剪切等操作</li>
</ul></li>
<li>主要通过 Image类 实现</li>
</ul>
<h3 id="bitmap类">Bitmap类</h3>
<ul>
<li><strong>Image 是抽象类</strong>，Bitmap 从 Image 派生</li>
<li>可以处理 BMP、JPEG、GIF、PNG 等格式</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Bitmap bt1 = <span class="keyword">new</span> Bitmap(<span class="string">&quot;c:\\1.bmp&quot;</span>);</span><br><span class="line">Bitmap bt2 = <span class="keyword">new</span> Bitmap(bt1, <span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line">Bitmap bt3;</span><br><span class="line">bt3.FromFile(<span class="string">&quot;文件名称&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/08/ThumbnailTest.cs">生成略缩图的代码</a></li>
<li><a href="https://www.getpaint.net/">图像处理小软件</a></li>
</ul>
<h4 id="针对图像像素的处理">针对图像像素的处理</h4>
<ul>
<li>图像文件bmp的格式</li>
<li>慢速方法</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">bitmap.GetPixel(x,y);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用指针（快）
<ul>
<li>因为使用了unsafe，所以编译的时候需要设置 “允许不安全的代码”
<ul>
<li><code>/unsafe</code></li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">bitmapData = bitmap.LockBits(</span><br><span class="line">    bounds, ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);</span><br><span class="line"><span class="comment">// 起始位置</span></span><br><span class="line">pBase = (Byte*)bitmapData.Scan0.ToPointer();</span><br><span class="line"><span class="comment">// 任意位置</span></span><br><span class="line"><span class="comment">// stride: 一行的像素点占据的字节数</span></span><br><span class="line">(PixelData*)(pBase + y * stride + x * <span class="keyword">sizeof</span>(PixelData));</span><br></pre></td></tr></table></figure>
<h3 id="图像处理">图像处理</h3>
<ul>
<li>滤镜</li>
<li><a href="/resources/Code/csharp/tds/08/ImageProcessor.zip">简单图像处理</a></li>
<li><a href="/resources/Code/csharp/tds/08/CSharpFilters_src6.rar">复杂图像处理</a></li>
</ul>
]]></content>
      <categories>
        <category>csharp.tds</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#程序设计.唐大仕.09.文本处理及正则表达式</title>
    <url>/2021/11/08/csharp/tds/09/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1001663016">中国大学慕课</a></li>
</ul>
<h1 id="文本处理及正则表达式">文本处理及正则表达式</h1>
<h2 id="基于文本的应用">1. 基于文本的应用</h2>
<h3 id="控制台应用程序">控制台应用程序</h3>
<ul>
<li>Main() 函数的参数——命令行参数
<ul>
<li>可以带 string[] 参数</li>
<li>可以有返回值 (int)，也可以为 void</li>
</ul></li>
</ul>
<h3 id="environment-类">Environment 类</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">CommandLine</span><br><span class="line">CommandLineArgs</span><br><span class="line">MachineName</span><br><span class="line">OSVersion</span><br><span class="line">UserDomainName</span><br><span class="line">UserName</span><br><span class="line">GetEnvironmentVariables</span><br><span class="line">CurrentDirectory</span><br><span class="line">SystemDirectory</span><br><span class="line">GetFolderPath(Environment.SpecialFolder.System)</span><br></pre></td></tr></table></figure>
<h2 id="文本处理常用的几个类">2. 文本处理常用的几个类</h2>
<ul>
<li>Console 类</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Write</span><br><span class="line">WriteLine</span><br><span class="line">ReadLine</span><br></pre></td></tr></table></figure>
<ul>
<li>String 类</li>
<li>StringBuilder 类</li>
<li>System.Text.Encoding 类</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">.Default</span><br><span class="line">.UTF8</span><br><span class="line">.GetEncoding</span><br><span class="line">.GetBytes(str)</span><br><span class="line">.GetString(byte[])</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式">3. 正则表达式</h2>
<ul>
<li>Regular Expression</li>
<li>用来表示匹配某类文本</li>
</ul>
<h3 id="要素">要素</h3>
<h4 id="字符">字符</h4>
<ul>
<li><code>ab</code>，<code>\t</code>，<code>\[</code>，<code>\u0020</code>，<code>\x20</code></li>
<li><code>[a-zA-z]</code> 即 <code>\w</code></li>
<li><code>[0-9]</code> 即 <code>\d</code></li>
<li><code>[^0-9]</code> 即 <code>\D</code></li>
<li><code>\s</code> 即空白</li>
<li><code>\S</code> 即非空白</li>
<li><code>.</code> 表任意</li>
</ul>
<h4 id="次数">次数</h4>
<ul>
<li><code>&#123;2,6&#125;</code></li>
<li><code>*</code> 即 <code>&#123;0,&#125;</code></li>
<li><code>+</code> 即 <code>&#123;1,&#125;</code></li>
<li><code>?</code> 即 <code>&#123;0,1&#125;</code></li>
<li><code>*?</code>，<code>+?</code>，<code>??</code> 表示 lazy 匹配
<ul>
<li>匹配上一个就结束</li>
<li>正常为 greedy 匹配，尽可能匹配上更多的字符</li>
</ul></li>
</ul>
<h4 id="功能符">功能符</h4>
<ul>
<li><code>|</code> 表示或者</li>
<li><code>()</code> 表示成组</li>
<li><code>(?&lt;名称&gt;xxxxxxxx)</code> 表示对分组进行命名
<ul>
<li>在替换时, 使用 <code>$&#123;名称&#125;</code></li>
<li>若不命名，则为 <code>$1</code>、<code>$2</code>
等等，<code>$0</code> 表示整个匹配</li>
</ul></li>
<li><code>(?i:xxxxxxxxx)</code> 表示选项（i 表示忽略大小写）
<ul>
<li>MulitLine
<ul>
<li><code>^</code>、<code>$</code> 的含义变为整个文本的首尾</li>
</ul></li>
<li>SingleLine
<ul>
<li>影响 <code>.</code> 的含义，不匹配 <code>\r\n</code></li>
</ul></li>
</ul></li>
<li>预编译</li>
</ul>
<h4 id="位置限定">位置限定</h4>
<ul>
<li><code>^</code> （首）</li>
<li><code>$</code> （尾）</li>
<li><code>\b</code> 单词边界</li>
<li><code>\B</code> 非单词边界</li>
</ul>
<h3 id="正则表达式工具">正则表达式工具</h3>
<ul>
<li><a href="/resources/Code/csharp/tds/09/Expresso.zip">Exprsso</a></li>
</ul>
<h3 id="正则表达式类">正则表达式类</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br></pre></td></tr></table></figure>
<ul>
<li>Static方法</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Regex.IsMatch( s, pattern );</span><br></pre></td></tr></table></figure>
<ul>
<li>Regex 对象</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">IsMatch(s);</span><br><span class="line">Match(s);</span><br><span class="line">Matches(s);</span><br><span class="line">Replace(s, r);</span><br></pre></td></tr></table></figure>
<ul>
<li>Match 对象</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Groups;        <span class="comment">// 各组</span></span><br><span class="line">Value;         <span class="comment">// 原串</span></span><br><span class="line">Result(xxxxx); <span class="comment">// 替换</span></span><br></pre></td></tr></table></figure>
<h3 id="代码示例">代码示例</h3>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/09/Regex1.cs">Regex1</a></li>
<li><a href="/utils/show_code/index.html?csharp/tds/09/Regex2.cs">Regex2</a></li>
<li><a href="/resources/Code/csharp/tds/09/lrcPlayer.zip">音乐播放器</a>
<ul>
<li>工具箱 <span class="math inline">\(\to\)</span> 常规（右键） <span class="math inline">\(\to\)</span> 通用 windows 组件 <span class="math inline">\(\to\)</span>
<code>AxWMPLib.AxWindowsMediaPlayer</code></li>
</ul></li>
</ul>
<p><img src="/2021/11/08/csharp/tds/09/image-20211108155019582.png" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>csharp.tds</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#程序设计.唐大仕.10.网络信息获取及 xml 处理</title>
    <url>/2021/11/18/csharp/tds/10/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1001663016">中国大学慕课</a></li>
</ul>
<h1 id="第10章-网络信息获取及-xml-处理">第10章 网络信息获取及 xml
处理</h1>
<h2 id="网络信息获取">1. 网络信息获取</h2>
<h3 id="网络信息浏览">网络信息浏览</h3>
<ul>
<li>一些概念
<ul>
<li>HTTP 协议</li>
<li>客户端与服务端</li>
<li>Request 与 Response</li>
<li>Stream</li>
<li>Get（显式写在网址后面）与 Post</li>
<li>cookie（浏览器记录的一些关于该服务器的信息）</li>
</ul></li>
</ul>
<h3 id="网络流传输查看工具">网络流传输查看工具</h3>
<ul>
<li><a href="http://www.fiddler2.com/">Fiddler2</a>、NetworkMoniter、Visual
Sniffer、httpwatch、WireShark</li>
<li>Chrome（F12 <span class="math inline">\(\to\)</span>
Network）、FireFox（安装 FireBug）</li>
</ul>
<h3 id="system.web">System.Web</h3>
<ul>
<li>提供支持浏览器/服务器通讯的类和接口
<ul>
<li>提供有关当前 HTTP 请求的大量信息的 Request 类</li>
<li>管理 HTTP 到客户端的输出的 Response 类</li>
<li>以及提供对服务器端实用工具和进程的访问的 HttpServerUtility 对象</li>
<li>还包括用于Cookie操作、文件传输、异常信息和输出缓存控制的类</li>
</ul></li>
<li>类</li>
</ul>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 80%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">类</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Cookie</td>
<td style="text-align: center;">提供对cookie（一种网络服务器传递给浏览器的信息）进行管理的一套方法和属性</td>
</tr>
<tr class="even">
<td style="text-align: center;">Dns</td>
<td style="text-align: center;">提供简单的域名协议功能</td>
</tr>
<tr class="odd">
<td style="text-align: center;">EndPoint</td>
<td style="text-align: center;">表示网络地址的抽象类</td>
</tr>
<tr class="even">
<td style="text-align: center;">FileWebRequest</td>
<td style="text-align: center;">与 <code>file://</code> 开头的 URl
地址进行交互，以访问本地文件</td>
</tr>
<tr class="odd">
<td style="text-align: center;">FileWebResponse</td>
<td style="text-align: center;">通过 <code>file://</code> URI
地址提供对文件系统的只读访问</td>
</tr>
<tr class="even">
<td style="text-align: center;">HttpWebRequest</td>
<td style="text-align: center;">授权客户向 HTTP 服务器发送请求</td>
</tr>
<tr class="odd">
<td style="text-align: center;">HttpWebResponse</td>
<td style="text-align: center;">授权客户接收 HTTP 服务器的回答信息</td>
</tr>
<tr class="even">
<td style="text-align: center;">IPAddress</td>
<td style="text-align: center;">表示一个 IP 地址</td>
</tr>
<tr class="odd">
<td style="text-align: center;">IPEndPoint</td>
<td style="text-align: center;">表示一个IP终端（IP地址加端口号）</td>
</tr>
<tr class="even">
<td style="text-align: center;">IPHostEntry</td>
<td style="text-align: center;">与带有一组别名和匹配 IP 地址的 DNS
登录建立连接</td>
</tr>
<tr class="odd">
<td style="text-align: center;">WebClient</td>
<td style="text-align: center;">提供向 URL 传送数据和从 URI
接收数据的通用方法</td>
</tr>
<tr class="even">
<td style="text-align: center;">WebException</td>
<td style="text-align: center;">使用网络访问时产生的异常</td>
</tr>
</tbody>
</table>
<h4 id="webclient-类">WebClient 类</h4>
<ul>
<li><strong>DownloadData</strong>、<strong>DownloadFile</strong></li>
<li>DownloadString</li>
<li>UploadData、UploadFile</li>
<li>OpenRead、OpenWrite</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> url= <span class="string">@&quot;http://www.baidu.com&quot;</span>;</span><br><span class="line">WebClientclient = <span class="keyword">new</span> WebClient();</span><br><span class="line"><span class="built_in">byte</span>[] pageData = client.DownloadData(url);</span><br><span class="line"><span class="built_in">string</span> pageHtml = Encoding.Default.GetString(pageData);</span><br><span class="line">Console.WriteLine(pageHtml);</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">WebRequestmyRequest = WebRequest.Create(<span class="string">&quot;http://www.contoso.com&quot;</span>);</span><br><span class="line">WebResponsemyResponse = myRequest.GetResponse();</span><br><span class="line">Stream requestStream = myRequest.GetRequestStream()</span><br><span class="line">Stream receiveStream = myWebResponse.GetResponseStream();</span><br></pre></td></tr></table></figure>
<h3 id="注意点">注意点</h3>
<ul>
<li>Credentials：主要指用户名、密码等</li>
<li>Header：头部信息</li>
<li>Cookie：Cookie信息</li>
<li>User-Agent：用户代理（浏览器）</li>
<li>Refer：由哪个页面进行的访问</li>
</ul>
<h3 id="代码示例">代码示例</h3>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/10/DownloadStringTest.cs">示例
1</a>
<ul>
<li>下载网页，以字符串的形式输出</li>
</ul></li>
<li><a href="/utils/show_code/index.html?csharp/tds/10/DownloadStringTest2.cs">示例
2</a>
<ul>
<li><strong>从底层开始编写</strong>，下载网页，以字符串的形式输出</li>
</ul></li>
<li><a href="/utils/show_code/index.html?csharp/tds/10/DownloadImages.cs">下载图片</a></li>
</ul>
<h2 id="xml-处理">2. xml 处理</h2>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/10/BookList.xml">xml
例子</a></li>
</ul>
<h3 id="xml-内容">xml 内容</h3>
<ul>
<li>声明</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>实体</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!Entity ...&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>元素</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>属性</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">title</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注释</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- some comments --&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>特殊字符</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&amp;      &amp;amp;</span><br><span class="line">&lt;      &amp;lt;</span><br><span class="line">&gt;      &amp;gt;</span><br><span class="line">&quot;      &amp;quot;</span><br><span class="line">&#x27;      &amp;apos;</span><br></pre></td></tr></table></figure>
<h3 id="处理方式">处理方式</h3>
<ul>
<li>DOM
<ul>
<li>文档对象模型（Document Object Model）</li>
<li>将整个文档读入内存，建立树状结构</li>
</ul></li>
<li>SAX
<ul>
<li>XML 解析简单的 API（Simple API for XML）</li>
<li>边读边处理</li>
</ul></li>
</ul>
<h3 id="xml-类">XML 类</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.XML;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>XmlDocument</p>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/10/XmlDocumentTest.cs">使用示例</a>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/10/BookList.xml">xml
文件</a></li>
</ul></li>
</ul></li>
<li><p>XmlNode</p>
<ul>
<li>XmlDocument, XmlElement</li>
<li>XmlAttribute, XmlEntity</li>
</ul></li>
<li><p>XmlNode 的操作</p>
<ul>
<li>查询：Xpath</li>
<li>增加：AppendChild, PrependChild, InsertBefore, InsertAfter</li>
<li>删改：RemoveChild, ReplaceChild, RemoveAll</li>
</ul></li>
<li><p>XMlTextReader、XmlTextWriter</p>
<ul>
<li>XmlTextReader
<ul>
<li>对 XML 数据进行快速、非缓存、只进访问的读取器</li>
<li><a href="/utils/show_code/index.html?csharp/tds/10/XmlTextReaderTest.cs">代码示例</a>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/10/items.xml">xml
文件</a></li>
</ul></li>
</ul></li>
<li>XmlTextWriter
<ul>
<li>使用较少，因为可以使用 StringBuilder 很方便的自己拼出来</li>
<li><a href="/utils/show_code/index.html?csharp/tds/10/XmlTextReaderTest.cs">代码示例</a>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/10/sampledata.xml">xml
文件</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="xpath">3. Xpath</h2>
<ul>
<li>类似于文件路径，是 xml 中的从根节点到子结点路径的查询</li>
<li>元素
<ul>
<li>Axes（路径）
<ul>
<li><code>/</code>：当前目录下</li>
<li><code>//</code>：递归</li>
</ul></li>
<li>第几个子结点 <code>[1]</code></li>
<li>属性：<code>@</code></li>
<li>条件:<code>[]</code></li>
<li>例子
<ul>
<li><code>/books/book/@title</code></li>
<li><code>//price</code></li>
<li><code>para[@type=" warning"][5]</code></li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">XmlDocument doc = <span class="keyword">new</span> XmlDocument();</span><br><span class="line">doc.LoadXml( strXml );</span><br><span class="line">XmlElement root = doc.DocumentElement;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 xpath 进行查找</span></span><br><span class="line">XmlNodeList nodes = root.SelectNodes( strXPath );</span><br><span class="line">XmlNode node = root.SelectSingleNode( strXPath );</span><br></pre></td></tr></table></figure>
<h3 id="xslt">xslt</h3>
<ul>
<li>根据 xslt 将 xml 转化为 html</li>
<li><a href="/utils/show_code/index.html?csharp/tds/10/XsltTest/XsltTest.cs">代码示例</a>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/10/XsltTest/BookList.xml">xml
文件</a></li>
<li><a href="/resources/Code/csharp/tds/10/XsltTest/BookList.xslt">BookList.xslt</a></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>csharp.tds</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#程序设计.唐大仕.11.多线程与异步编程</title>
    <url>/2021/11/29/csharp/tds/11/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1001663016">中国大学慕课</a></li>
</ul>
<h1 id="多线程与异步编程">多线程与异步编程</h1>
<h2 id="线程及其创建">1. 线程及其创建</h2>
<ul>
<li>进程 Process</li>
<li>线程 Thread
<ul>
<li>线程中的指令：一个方法（委托）</li>
<li>线程中的数据：相关的对象</li>
<li>具体调度由操作系统和 .net 环境负责</li>
</ul></li>
<li>.net</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Threading.Thread;</span><br></pre></td></tr></table></figure>
<h3 id="属性">属性</h3>
<table>
<colgroup>
<col style="width: 21%">
<col style="width: 78%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Property</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">CurrentPrincipal</td>
<td style="text-align: center;">获取或者设定线程的当前<strong>安全性</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">CurrentThread</td>
<td style="text-align: center;">获得对当前正在运行的线程的一个引用（static属性）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">IsAlive</td>
<td style="text-align: center;">如果线程<strong>已经被启动</strong>并且尚<strong>在生命周期内</strong>，则返回
True</td>
</tr>
<tr class="even">
<td style="text-align: center;">IsBackground</td>
<td style="text-align: center;">如果目标线程是在<strong>后台执行</strong>的，则为此属性赋值为
True</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Name</td>
<td style="text-align: center;">获取或者设定这个线程的名字</td>
</tr>
<tr class="even">
<td style="text-align: center;">Priority</td>
<td style="text-align: center;">获取或者设定这个线程的优先级</td>
</tr>
<tr class="odd">
<td style="text-align: center;">ThreadState</td>
<td style="text-align: center;">获得线程的当前状态</td>
</tr>
</tbody>
</table>
<h3 id="方法">方法</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Method</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Abort</td>
<td style="text-align: center;">撤消这个线程</td>
</tr>
<tr class="even">
<td style="text-align: center;">Interrupt</td>
<td style="text-align: center;">如果线程处于 WaitSleepJoin
状态，则中断它</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Join</td>
<td style="text-align: center;">等待一个线程的结束</td>
</tr>
<tr class="even">
<td style="text-align: center;">Resume</td>
<td style="text-align: center;">将被挂起的线程重新开始</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Sleep</td>
<td style="text-align: center;">让线程休眠一定时间</td>
</tr>
<tr class="even">
<td style="text-align: center;">Start</td>
<td style="text-align: center;">启动一个线程</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Suspend</td>
<td style="text-align: center;">挂起一个线程</td>
</tr>
</tbody>
</table>
<h3 id="创建线程">创建线程</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(obj.fun()));</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">thread.Start();</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/11/ThreadTest.cs">代码示例</a></li>
</ul>
<h3 id="线程的停止">线程的停止</h3>
<ul>
<li>线程函数会一直执行下去，直至它结束</li>
<li>Abort() 终止</li>
<li>Suspend() 挂起
<ul>
<li>Resume() 恢复</li>
</ul></li>
<li>Sleep(毫秒数)</li>
</ul>
<h3 id="线程的状态">线程的状态</h3>
<ul>
<li>ThreadState 枚举类</li>
</ul>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">成员</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Aborted</td>
<td style="text-align: center;">线程已经被中断并且被撤销</td>
</tr>
<tr class="even">
<td style="text-align: center;">AbortRequested</td>
<td style="text-align: center;">线程正在被请求中断</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Background</td>
<td style="text-align: center;">线程充当后台线程的角色，并且正在执行</td>
</tr>
<tr class="even">
<td style="text-align: center;">Running</td>
<td style="text-align: center;">线程正在运行</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Stopped</td>
<td style="text-align: center;">线程停止运行（这个状态只限于内部使用）</td>
</tr>
<tr class="even">
<td style="text-align: center;">StopRequested</td>
<td style="text-align: center;">线程正在被要求停止（这个状态只限于内部使用）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Suspended</td>
<td style="text-align: center;">线程已经被挂起</td>
</tr>
<tr class="even">
<td style="text-align: center;">SuspendRequested</td>
<td style="text-align: center;">线程已经被要求挂起</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Unstarted</td>
<td style="text-align: center;">线程还没有被启动</td>
</tr>
<tr class="even">
<td style="text-align: center;">WaitSleepJoin</td>
<td style="text-align: center;">线程在一次 Wait()、Sleep() 以及 Join()
调用中被锁定</td>
</tr>
</tbody>
</table>
<h3 id="线程优先级">线程优先级</h3>
<ul>
<li>ThreadPriority 枚举类</li>
<li>Highest、AboveNormal、Normal、BelowNormal、Lowest</li>
<li><strong>正常为 Normal</strong></li>
</ul>
<h3 id="代码示例">代码示例</h3>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/11/ThreadDraw3.cs">多线程绘图</a></li>
</ul>
<h2 id="线程同步控制">2. 线程同步控制</h2>
<h3 id="join-方法">Join() 方法</h3>
<ul>
<li>单独的执行线程合并成一个线程</li>
<li>等待该线程执行结束，再进一步往下执行</li>
</ul>
<h3 id="lock-语句与-monitor-类">Lock 语句与 Monitor 类</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lock</span>( <span class="comment">/* 对象或者表达式 */</span> )&#123;</span><br><span class="line">    <span class="comment">// statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>lock 的内部实现</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">System.Threading.Monitor.Enter(<span class="comment">/* 对象或表达式 */</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// statement</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.Threading.Monitor.Exit(<span class="comment">/* 对象或表达式 */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用于同步控制的类">用于同步控制的类</h3>
<table>
<colgroup>
<col style="width: 21%">
<col style="width: 78%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">类</th>
<th style="text-align: center;">用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">AutoResetEvent</td>
<td style="text-align: center;">等待句柄，用于通知一个或多个等待线程发生了一个事件<br>AutoResetEvent在等待线程被释放后自动将状态更改为已发出信号</td>
</tr>
<tr class="even">
<td style="text-align: center;">Interlocked</td>
<td style="text-align: center;">为多个线程共享的变量提供原子操作</td>
</tr>
<tr class="odd">
<td style="text-align: center;">ManualResetEvent</td>
<td style="text-align: center;">等待句柄，用于通知一个或多个等待线程发生了一个事件<br>手动重置事件的状态将保持为已发出信号，直至
Reset
方法将其设置为未发出信号状态<br>同样，该状态将保持为未发出信号，直至
Set
方法将其设置为已发出信号状态<br>当对象的状态为已发出信号时，任意数量的等待线程（即通过调用一个等待函数开始对指定事件对象执行等待操作的线程）都可以被释放</td>
</tr>
<tr class="even">
<td style="text-align: center;">Monitor</td>
<td style="text-align: center;">提供同步访问对象的机制</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Mutex</td>
<td style="text-align: center;">等待句柄，可用于进程间同步</td>
</tr>
<tr class="even">
<td style="text-align: center;">ReaderWriterLock</td>
<td style="text-align: center;">定义用于实现单个写入者和多个读取者的锁定</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Timer</td>
<td style="text-align: center;">提供按指定间隔运行任务的机制</td>
</tr>
<tr class="even">
<td style="text-align: center;">WaitHandle</td>
<td style="text-align: center;">封装操作系统特有的、等待对共享资源进行独占访问的对象</td>
</tr>
</tbody>
</table>
<h2 id="线程池及其他线程类">3. 线程池及其他线程类</h2>
<h3 id="threadpool">Threadpool</h3>
<ul>
<li>Threadpool.QueueUserWorkItem()等方法来提交相应的任务</li>
<li>QueueUserWorkItem(WaitCallback, object)</li>
<li>QueueUserWorkItem(WaitCallback) 其中public delegate void
WaitCallback( object state );</li>
</ul>
<h3 id="timer">Timer</h3>
<ul>
<li>System.Threading.Timer</li>
<li>构造方法</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    TimerCallback callback, //执行的任务</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">object</span> state,           // 数据</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">int</span> dueTime,            // 启动前的延时</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">int</span> period              // 任务之间的间隔</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TimerCallback</span>(<span class="params"><span class="built_in">object</span> state</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="线程在集合中使用">4. 线程在集合中使用</h2>
<ul>
<li>IsSynchoronized 属性用于判断是否为同步版本</li>
<li>SyncRoot 属性提供了集合自己的同步版本</li>
<li>Array，ArrayList，SortedList，Hashtable 等，都可以使用
Synchronized() 方法获取一个线程安全的包装对象</li>
<li><a href="/utils/show_code/index.html?csharp/tds/11/SynchronizedCollection.cs">代码示例</a></li>
</ul>
<h2 id="线程在-window-界面中使用">5. 线程在 Window 界面中使用</h2>
<ul>
<li>BeginInvoke</li>
<li>界面的主线程</li>
<li><strong>对界面的更新只能使用主线程</strong></li>
<li>其他线程则可以这样</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.InvokeRequired)&#123;</span><br><span class="line">    <span class="comment">// 显示到界面上</span></span><br><span class="line">    <span class="keyword">this</span>.BeginInvoke(<span class="keyword">new</span> AddMsg(<span class="keyword">this</span>.AddMsgFun), <span class="keyword">new</span> <span class="built_in">object</span>[]&#123;msg&#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.AddMsgFun( msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 BackgroundWorker 组件
<ul>
<li>DoWork 事件</li>
<li>RunWorkerAsync 方法</li>
</ul></li>
</ul>
<h2 id="并行编程">6. 并行编程</h2>
<h3 id="并行任务库-tpl">并行任务库 TPL</h3>
<p><img src="/2021/11/29/csharp/tds/11/image-20211129152758576.png" style="zoom: 80%;"></p>
<ul>
<li>并行任务库（TPL，Task Parallel Library）</li>
<li>最重要的是 Task 类、Parallel 类</li>
<li>Task 类，是利用线程池来进行任务的执行
<ul>
<li>比直接用 ThreadPool 更优化，而且编程更方便</li>
</ul></li>
<li>Parallel 类，是并行执行任务类的实用类
<ul>
<li>好处是可以隐式地使用 Task，更方便</li>
</ul></li>
</ul>
<h3 id="task-类">Task 类</h3>
<ul>
<li>使用 Task.Run 方法来得到 Task 的实例</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Task&lt;<span class="built_in">double</span>&gt; task = Task.Run( ()=&gt;SomeFun() );</span><br><span class="line"><span class="built_in">double</span> result = task.Result; <span class="comment">// 等待直到获得结果</span></span><br><span class="line"></span><br><span class="line">Task.WaitAll( task 数组);</span><br><span class="line">task.ContinueWith(另一个task);</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/11/Task1.cs">代码示例</a></li>
</ul>
<h4 id="task-中的异常">Task 中的异常</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Task.WaitAll(task1,task2,task3);</span><br><span class="line">    <span class="comment">// 合并的异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (AggregateException ex) &#123;</span><br><span class="line">    <span class="keyword">foreach</span>(Exception inner <span class="keyword">in</span> ex.InnerExceptions) &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Exceptiontype&#123;0&#125; from&#123;1&#125;&quot;</span>,inner.GetType(),inner.Source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="parallel-类">Parallel 类</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Parallel.Invoke( Action[] actions); <span class="comment">// 并行执行多个任务，直到完成</span></span><br><span class="line"></span><br><span class="line">Parallel.For(<span class="number">0</span>, <span class="number">100</span>, i =&gt; &#123;<span class="comment">/* ... */</span>&#125; );</span><br><span class="line">Parallel.ForEach( list, item =&gt; &#123; <span class="comment">/* ... */</span>&#125; );</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/11/MatrixMultiply.cs">矩阵乘法</a></li>
<li><a href="/utils/show_code/index.html?csharp/tds/11/Parallel1.cs">代码示例</a>
<ul>
<li>Break()</li>
</ul></li>
</ul>
<h3 id="并行-linq">并行 Linq</h3>
<ul>
<li>PLinq
<ul>
<li>AsParallel() 即可</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> query2 = (<span class="keyword">from</span> n <span class="keyword">in</span> dic.Values.AsParallel()</span><br><span class="line">              <span class="keyword">where</span> n.Age &gt; <span class="number">20</span> &amp;&amp; n.Age &lt; <span class="number">25</span></span><br><span class="line">              <span class="keyword">select</span> n).ToList();</span><br></pre></td></tr></table></figure>
<h2 id="异步编程">7. 异步编程</h2>
<ul>
<li>异步 asynchronize</li>
<li>主要解决的事情是
<ul>
<li>等待一些耗时的任务（特别是文件、网络操作）而<strong>不阻塞当前任务</strong></li>
<li>异步编程提高响应能力（特别是 UI）</li>
</ul></li>
<li>开始一个任务后，让任务在另一个线程中执行，本线程可以继续执行别的事情，然后等待那个任务执行完毕</li>
</ul>
<h3 id="传统方法">传统方法</h3>
<ul>
<li>使用委托的 BeginInvoke 及 EndInvoke
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/11/Asyn1.cs">代码示例</a></li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">PrintDelegate printDelegate = Print;</span><br><span class="line">IAsyncResult result = printDelegate.BeginInvoke(<span class="string">&quot;Hello World.&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;主线程继续执行...&quot;</span>);</span><br><span class="line"><span class="comment">// 当使用BeginInvoke异步调用方法时，如果方法未执行完，EndInvoke方法就会一直阻塞，直到被调用的方法执行完毕</span></span><br><span class="line"><span class="built_in">int</span> n = printDelegate.EndInvoke(result);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用回调
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/11/Asyn2.cs">代码示例</a></li>
<li>回调函数可能在主线程执行，也有可能为了节省开销在子线程执行</li>
</ul></li>
</ul>
<h3 id="c-5.0-新方法">C# 5.0 新方法</h3>
<ul>
<li>新增 await 及 async 两个关键词
<ul>
<li>await 表示等待任务的执行</li>
<li>async 修饰一个方法，表示其中有 await 语句</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用Task表示要执行任务</span></span><br><span class="line">Task&lt;<span class="built_in">double</span>&gt;FacAsync(<span class="built_in">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">return</span> Task&lt;<span class="built_in">double</span>&gt;.Run( ()=&gt;&#123;</span><br><span class="line">        <span class="built_in">double</span> s = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123; s = s*i; &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">double</span> result = <span class="keyword">await</span> FacAsync(<span class="number">10</span>);<span class="comment">// 调用异步方法</span></span><br><span class="line">    Console.WriteLine( result); <span class="comment">//异步方法执行完后才执行此句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> result = <span class="keyword">await</span> FacAsync(<span class="number">10</span>); <span class="comment">//此处会开新线程处理然后方法马上返回</span></span><br><span class="line"><span class="comment">//这之后的所有代码都会被封装成委托，在任务完成时调用</span></span><br><span class="line">Console.WriteLine( result);</span><br></pre></td></tr></table></figure>
<ul>
<li>它解决了传统方法中 “异步任务与回调方法分开写”
的问题，相当于如下代码</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">System.Runtime.CompilerServices.TaskAwaiter&lt;<span class="built_in">double</span>&gt;awaiter =</span><br><span class="line">    FacAsync(<span class="number">10</span>).GetAwaiter();</span><br><span class="line">awaiter.OnCompleted(()=&gt;&#123;</span><br><span class="line">    doubleresult=awaiter.GetResult();</span><br><span class="line">    Console.WriteLine( result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="winform">WinForm</h4>
<ul>
<li>当异步执行完成后，使用<strong>界面线程来执行回调</strong>，所以写起来更简洁</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">asyncprivate <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgse</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> content = awaitAccessTheWebAsync(url);</span><br><span class="line">    <span class="keyword">this</span>.textBox2.Text = content; <span class="comment">//编译器让这句在界面线程上执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异步的流">异步的流</h4>
<p><img src="/2021/11/29/csharp/tds/11/navigation-trace-async-program.png"></p>
<ul>
<li>与上面的 HttpClient 相似，Stream等类也提供了异步方法</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> myStream.WriteAsync(<span class="comment">/**/</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>这比传统的 BeginWrite() + 回调函数 + EndWrite() 要方便很多</li>
<li>也可以这样</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Task task= myStream.WriteAsync(); <span class="comment">// 异步</span></span><br><span class="line">DoIndependentWork(); <span class="comment">// 做其他事</span></span><br><span class="line"><span class="keyword">await</span> task; <span class="comment">// 等待异步执行完毕</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>csharp.tds</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#程序设计.唐大仕.12.访问数据库</title>
    <url>/2021/12/06/csharp/tds/12/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1001663016">中国大学慕课</a></li>
</ul>
<h1 id="访问数据库">访问数据库</h1>
<ul>
<li><a href="/categories/DB-CLJ/">数据库知识</a></li>
</ul>
<h2 id="数据库基本知识">数据库基本知识</h2>
<ul>
<li>数据库 DataBase</li>
<li>数据库管理系统 DBMS
<ul>
<li>常见 DBMS：Oracle、MS SQL Server</li>
</ul></li>
<li>数据库系统的优点
<ul>
<li>共享性、独立性、完整性和冗余数据少</li>
</ul></li>
<li>管理功能
<ul>
<li>数据定义/操纵/完整/安全/并发</li>
</ul></li>
</ul>
<h3 id="常用-dbms">常用 DBMS</h3>
<ul>
<li>微软
<ul>
<li>MS SQL Server</li>
<li>MS Access（小型桌面数据库）</li>
</ul></li>
<li>其他
<ul>
<li>Oracle</li>
<li>MySQL</li>
</ul></li>
</ul>
<h3 id="关系型数据库">关系型数据库</h3>
<ul>
<li>关系型数据库（RDBMS）</li>
<li>以<strong>二维表</strong>的形式组织数据</li>
<li>表 DataTable</li>
<li>行 DataRow（记录 Record）</li>
<li>列 DataColumn（字段 Field）</li>
<li><strong>主键</strong>：primary key</li>
</ul>
<h3 id="数据库表的设计">数据库表的设计</h3>
<ul>
<li><a href="/categories/DB-CLJ/">数据库知识</a></li>
</ul>
<h3 id="实体关系图">实体关系图</h3>
<ul>
<li>E-R 图</li>
<li>实体——关系图</li>
<li>Entity-Relation</li>
</ul>
<p><img src="/2021/12/06/csharp/tds/12/image-20211206230817459.png" style="zoom:80%;"></p>
<h3 id="使用数据库">使用数据库</h3>
<ul>
<li>可视化界面
<ul>
<li>navicat（MySQL）</li>
</ul></li>
<li>SQL 语句
<ul>
<li>增、删、查、改</li>
</ul></li>
</ul>
<h3 id="sql">SQL</h3>
<ul>
<li>SQL （Structured Query
Language），即<strong>结构化查询语言</strong></li>
<li>是数据库的标准操作语言</li>
<li>SQL包含数据定义、查询操纵和控制等多种功能</li>
<li>最常用的语句就是：<strong>增删改查</strong></li>
<li>英文中叫 <strong>CRUD</strong>
<ul>
<li>Create</li>
<li>Retrieve</li>
<li>Update</li>
<li>Delelte</li>
</ul></li>
<li>一些示例
<ul>
<li><a href="/categories/DB-MySQL/">MySQL</a></li>
<li><a href="/categories/DB-SQLServer/">SQL Server</a></li>
</ul></li>
</ul>
<h4 id="sql-编程">SQL 编程</h4>
<ul>
<li>Client/Server 模式 (客户/服务模式)
<ul>
<li>数据库提供服务，称为 Server</li>
<li>程序是客户端，称为 Client</li>
<li>客户端通过 SQL 命令来向服务端发出请求</li>
</ul></li>
<li>编程的任务
<ul>
<li>通过用户界面获取参数，并形成 SQL 语句</li>
<li>建立与数据库的连接</li>
<li>向数据库管理系统发出命令（SQL）</li>
<li>从数据库得到数据并显示到用户界面</li>
</ul></li>
</ul>
<h2 id="ado.net">ADO.NET</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Data;</span><br></pre></td></tr></table></figure>
<ul>
<li>这种访问数据库的技术叫 ADO.NET</li>
<li>ADO.NET 实现数据库的访问
<ul>
<li>提供标准的 CRUD 接口</li>
<li>对不同的数据库提供<strong>统一的访问接口</strong></li>
</ul></li>
<li>发展历程
<ul>
<li>ODBC（Open Database Connection）</li>
<li>DAO（Data Access Object）</li>
<li>ADO（ActiveX Data Object）</li>
<li>ADO.NET</li>
</ul></li>
</ul>
<h3 id="数据访问层">数据访问层</h3>
<p><img src="/2021/12/06/csharp/tds/12/image-20211206232436950.png" style="zoom:80%;"></p>
<h3 id="重要对象">重要对象</h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">对象</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Connection</td>
<td style="text-align: center;">建立与特定数据源的连接</td>
</tr>
<tr class="even">
<td style="text-align: center;">Command</td>
<td style="text-align: center;">对数据源执行命令。<br>公开
Parameters，<br>并且可以从Connection在 Transaction 的范围内执行</td>
</tr>
<tr class="odd">
<td style="text-align: center;">DataReader</td>
<td style="text-align: center;">从数据源中读取只进且只读的数据流</td>
</tr>
<tr class="even">
<td style="text-align: center;">DataAdapter</td>
<td style="text-align: center;">用数据源填充
DataSet，并解析更新<br>保证内存中的数据和数据库中的数据是一致的</td>
</tr>
</tbody>
</table>
<h3 id="供应程序-provider">供应程序 Provider</h3>
<ul>
<li>Provider 是一些托管的应用程序集
<ul>
<li>包含了对特定数据元的访问代码</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SqlServer</span></span><br><span class="line"><span class="keyword">using</span> System.Data.SqlClient;</span><br><span class="line"><span class="comment">// Access</span></span><br><span class="line"><span class="keyword">using</span> System.Data.OleDb;</span><br><span class="line"><span class="comment">// ODBC</span></span><br><span class="line"><span class="keyword">using</span> System.Data.Odbc;</span><br><span class="line"><span class="comment">// Oracle</span></span><br><span class="line"><span class="keyword">using</span> System.Data.OracleClient;</span><br></pre></td></tr></table></figure>
<ul>
<li>不同 Provide下面类的命名可能不太一样
<ul>
<li>Adapter 为例</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SqlServer</span></span><br><span class="line">System.Data.sqlClient.SqlDataAdapter da1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Access</span></span><br><span class="line">System.Data.OleDb.OleDbDataAdapter da2;</span><br></pre></td></tr></table></figure>
<h3 id="ado.net-体系结构">ADO.NET 体系结构</h3>
<p><img src="/2021/12/06/csharp/tds/12/image-20211206233530327.png" style="zoom:80%;"></p>
<ul>
<li>内存中的数据很容易和 XML 互相转化</li>
</ul>
<p><img src="/2021/12/06/csharp/tds/12/image-20211206233648486.png" style="zoom:80%;"></p>
<h2 id="数据库访问方法">数据库访问方法</h2>
<ul>
<li>方式 1: DataAdapter 及 DataSet
<ul>
<li>适合于 “离线” 处理
<ul>
<li>把数据库整个抽取到内存中</li>
</ul></li>
<li>自动建立 Command 对象</li>
</ul></li>
<li>方式 2：DataReader
<ul>
<li>适合于<strong>只读数据</strong>，效率较高</li>
</ul></li>
<li>它们都要使用 Connection 及 Command</li>
<li>不同的数据库有不同的命名空间，如下以 SqlServer 为例</li>
</ul>
<h3 id="connection-对象">Connection 对象</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Data;</span><br><span class="line"><span class="keyword">using</span> System.Data.SqlClient;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> connString = <span class="string">&quot;server=localhost;database=pubs;uid=sa;pwd=aaa&quot;</span>;</span><br><span class="line">SqlConnection Conn = <span class="keyword">new</span> SqlConnection(connString);</span><br></pre></td></tr></table></figure>
<ul>
<li>SqlConnection
<ul>
<li>Open() 方法
<ul>
<li>SQL Provider 使用它来与 SQL Server 数据库进行连接</li>
</ul></li>
<li>ConnectionString 属性
<ul>
<li>指定连接字符串参数</li>
</ul></li>
</ul></li>
</ul>
<h4 id="连接字符串">连接字符串</h4>
<ul>
<li>不同数据库的 connection string 写法也会有所区别</li>
<li>SqlServer <span class="math inline">\(\to\)</span> SqlServer
Provider</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">data source=MyServer;</span><br><span class="line">initial catalog=MyDataBase;</span><br><span class="line">user id=MyUser;</span><br><span class="line">password=MyPassword</span><br></pre></td></tr></table></figure>
<ul>
<li>早期的 Access 数据库 mdb 文件或 Excel 文件 <span class="math inline">\(\to\)</span> Microsoft.Jet.OLEDB.4.0</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Provider=Microsoft.Jet.OLEDB.4.0;</span><br><span class="line">Password=&quot;xxx&quot;;</span><br><span class="line">User ID= Admin;</span><br><span class="line">Data Source=D:\CsExample\ch10\BIBLIO.MDB</span><br></pre></td></tr></table></figure>
<ul>
<li>新版的 Access 数据库 accdb 文件或 Excel 文件 <span class="math inline">\(\to\)</span> Microsoft.ACE.OLEDB.12.0</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Provider=Microsoft.ACE.OLEDB.12.0;</span><br><span class="line">Data Source=c:\myFile.xIxs;</span><br><span class="line">Excel 12.0 Xml;</span><br><span class="line">HDR=YES;</span><br></pre></td></tr></table></figure>
<ul>
<li>Oracle <span class="math inline">\(\to\)</span> Oracle Provider</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Provider=MSDAORA;</span><br><span class="line">DataSource=oracle db;</span><br><span class="line">User ID=scott;</span><br><span class="line">Password=tiger;</span><br></pre></td></tr></table></figure>
<ul>
<li>Mysql <span class="math inline">\(\to\)</span> MySql.Data.dll</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Data Source=&#x27;localhost&#x27;;</span><br><span class="line">Database=&#x27;wp&#x27;;</span><br><span class="line">User Id=&#x27;root&#x27;;</span><br><span class="line">Password=&#x27;root&#x27;;</span><br><span class="line">charset=&#x27;utf8;</span><br><span class="line">pooling=true;</span><br></pre></td></tr></table></figure>
<h3 id="command-对象">Command 对象</h3>
<ul>
<li>建立数据连接以后，可以利用 Command 对象来执行命令并从数据源返回结果
<ul>
<li>ExecuteReader()
<ul>
<li>得到 Reader 对象，单向只读</li>
</ul></li>
<li>ExecuteScalar()
<ul>
<li>得到<strong>单一的量</strong>，如 sum、avg 等的结果</li>
</ul></li>
<li>ExecuteNonQuery()
<ul>
<li>执行非查询性的命令（如Update/Delete/Insert）</li>
<li>返回的是它<strong>所影响的记录数</strong></li>
</ul></li>
</ul></li>
</ul>
<h4 id="使用参数">使用参数</h4>
<ul>
<li>使用参数</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">cmd.CommandText =</span><br><span class="line">    <span class="string">&quot;INSERT INTO Nations(CName, EName, FName) VALUES(@CName, @EName, @FName)&quot;</span>;</span><br><span class="line">cmd.Connection = <span class="keyword">this</span>.sqlConnection1;</span><br><span class="line">cmd.Parameters.Add(<span class="string">&quot;@CName&quot;</span>, SqlDbType.VarChar, <span class="number">60</span>).Value =<span class="string">&quot;aaaaaa&quot;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>拼字符串</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">cmd.CommandText = <span class="string">&quot;Insert into Nataions(CName) Values(&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;)&quot;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用参数比直接用字符串相加更安全，更清晰
<ul>
<li>sql 注入攻击</li>
</ul></li>
</ul>
<h3 id="command-和-datareader">Command 和 DataReader</h3>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/12/OleDbTest.cs">OleDb
示例</a></li>
</ul>
<h3 id="dataadapter-和-dataset">DataAdapter 和 DataSet</h3>
<ul>
<li>流程
<ul>
<li>使用 DataAdapter 来填充 DataSet</li>
<li>取得 DataSet 中的数据</li>
<li>修改 DataSet 中的数据</li>
<li>添加和删除行</li>
<li>在 DataTable 中查找数据</li>
<li>接受和拒绝更改</li>
<li>保存对 DataSet 的改变返回数据库</li>
</ul></li>
<li>可以自动产生 Command</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">OleDbCommandBuilder cmdbld</span><br><span class="line">    = <span class="keyword">new</span> OleDbCommandBuilder(daAdapter);</span><br></pre></td></tr></table></figure>
<ul>
<li>DataSet 对象模型</li>
</ul>
<p><img src="/2021/12/06/csharp/tds/12/image-20211207111935628.png" style="zoom:80%;"></p>
<ul>
<li>DataSet 和 XML 互相转化</li>
<li><a href="/utils/show_code/index.html?csharp/tds/12/OleDbTest2.cs">OleDb
示例</a></li>
</ul>
<h2 id="应用程序">应用程序</h2>
<h3 id="界面及数据绑定">界面及数据绑定</h3>
<ul>
<li>DataGridView 控件</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">DataGridView a = <span class="keyword">new</span> DataGridView();</span><br><span class="line">a.DataSource = myDataTable;</span><br></pre></td></tr></table></figure>
<h3 id="自定义工具类">自定义工具类</h3>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/12/AccessDB.cs">AccessDB</a></li>
<li><a href="/utils/show_code/index.html?csharp/tds/12/SqlServerDB.cs">SqlServerDB</a></li>
<li><a href="/resources/Code/csharp/tds/12/CrudDemo.rar">工程</a></li>
</ul>
<h3 id="酒店管理系统">酒店管理系统</h3>
<ul>
<li>分层架构
<ul>
<li>UI：用户界面层（user graphical interface）</li>
<li>BLL：业务逻辑层（business logic layer）</li>
<li>DAL：数据访问层（data access layer）</li>
<li>Model：数据模型</li>
</ul></li>
<li>ORMapping（Object-Relation Mapping）
<ul>
<li>对象 - 关系（数据库表）映射</li>
</ul></li>
<li><a href="/resources/Code/csharp/tds/12/RestaurantMIS-OLEDB.12.0.rar">代码</a></li>
</ul>
<h3 id="sqlite">Sqlite</h3>
<ul>
<li>Sqlite是一个小型的数据库，一个文件就可以包含库的内容，现在用得越来越多。在C#中使用也很方便。
<ul>
<li>使用Sqlite，需要安装System.Data.SQLite.Core</li>
<li>在visual
studio中，工具--NuGet包管理器--管理解决方案的NuGet程序包--浏览</li>
<li>搜索Sqlite就可以看见System.Data.SQLite.Core，然后选安装(安装时，项目名要打勾）</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>csharp.tds</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#程序设计.唐大仕.13.深入理解C#语言</title>
    <url>/2021/12/26/csharp/tds/13/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1001663016">中国大学慕课</a></li>
</ul>
<p>[TOC]</p>
<h1 id="深入理解-c-语言">深入理解 C# 语言</h1>
<h2 id="类型与转换">1. 类型与转换</h2>
<ul>
<li>数据类型</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">值类型</th>
<th style="text-align: center;">引用类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">存储位置</td>
<td style="text-align: center;">栈</td>
<td style="text-align: center;">堆</td>
</tr>
<tr class="even">
<td style="text-align: center;">默认值</td>
<td style="text-align: center;">Zeored</td>
<td style="text-align: center;">null</td>
</tr>
<tr class="odd">
<td style="text-align: center;">等号操作</td>
<td style="text-align: center;">所有值复制</td>
<td style="text-align: center;">指向同一个对象</td>
</tr>
</tbody>
</table>
<ul>
<li>值类型的转换
<ul>
<li>数字类型之间可以互相转化</li>
<li>隐式转换</li>
<li>显式转换（强制类型转换）</li>
<li><strong>整型提升</strong></li>
</ul></li>
<li><strong>枚举类型</strong>与数字类型之间可以显式转换（<strong>强制类型转换</strong>）</li>
<li>结构类型之间不能转换</li>
<li>引用类型转换
<ul>
<li>子类转父类（隐式）</li>
<li>父类转子类（显式）
<ul>
<li>可能成功、可能异常</li>
</ul></li>
</ul></li>
<li><code>as</code>
<ul>
<li>失败则等于 null（而不是抛异常）</li>
</ul></li>
<li>引用类型与值类型的转换
<ul>
<li>boxing、unboxing
<ul>
<li>存储位置出现改变</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/12/26/csharp/tds/13/image-20211226134249692.png" style="zoom:80%;"></p>
<h2 id="变量及其传递">2. 变量及其传递</h2>
<h3 id="域变量及局部变量">域变量及局部变量</h3>
<ul>
<li>类 static 变量
<ul>
<li>相当于类中的<strong>全局变量</strong></li>
</ul></li>
<li>域变量
<ul>
<li>相当于<strong>对象中的变量</strong></li>
</ul></li>
<li>局部变量
<ul>
<li>在函数体及其 <code>&#123;&#125;</code> 中，在栈中分配，自动消失</li>
<li><strong>域变量自动有初值，局部变量则不</strong></li>
</ul></li>
</ul>
<h3 id="按值传送的参数">按值传送的参数</h3>
<ul>
<li>按值传送
<ul>
<li>要注意值类型与引用类型</li>
</ul></li>
</ul>
<h3 id="ref-参数及-out-参数">ref 参数及 out 参数</h3>
<ul>
<li><strong>效果相当于 C++ 的引用</strong></li>
<li>ref 参数在<strong>传之间必须先赋值</strong></li>
<li>out 参数在函数中必须<strong>赋值后才能返回</strong></li>
<li><strong>表达式及对象的属性不能作 ref 及 out 参数</strong></li>
</ul>
<h3 id="params-参数">params 参数</h3>
<ul>
<li>数组参数（相当于VB的可变参数）</li>
<li>参数必须放在<strong>最后</strong></li>
<li>调用：
<ul>
<li>可用<strong>数组</strong>，也可用<strong>多个参数</strong></li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="built_in">double</span> <span class="title">Multi</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">double</span>[] nums</span>)</span>;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">Multi();</span><br><span class="line">Multi(<span class="number">27</span>);</span><br><span class="line">Multi(<span class="number">3.14</span>, <span class="number">0.9</span>, <span class="number">0.9</span>);</span><br><span class="line">Multi(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">Multi(<span class="keyword">new</span> <span class="built_in">double</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="默认参数">默认参数</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZoomIn</span>(<span class="params"> Point p, <span class="built_in">double</span> k = <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多态与虚方法调用">3. 多态与虚方法调用</h2>
<ul>
<li>多态（Polymorphism）</li>
</ul>
<h3 id="多态定义">多态定义</h3>
<ul>
<li>在面向对象的系统中，多态性是一个非常重要的概念，它允许客户对一个对象进行操作，<strong>由对象来完成一系列的动作，具体实现哪个动作、如何实现由系统负责解释</strong></li>
<li>在C#中，多态性的定义是，同一操作作用于不同的类的实例，不同的类将进行不同的解释，最后产生不同的执行结果
<ul>
<li>C#支持两种类型的多态性。</li>
</ul></li>
</ul>
<h3 id="两种多态">两种多态</h3>
<ul>
<li><strong>编译时</strong>的多态性
<ul>
<li>编译时的多态是通过<strong>重载</strong>来实现的</li>
<li>对于非虚的成员来说，系统在编译时，根据传递的参数、返回的类型等信息决定实现何种操作</li>
</ul></li>
<li><strong>运行时</strong>的多态性
<ul>
<li>运行时的多态性是指直到系统运行时，才根据实际情况决定实现何种操作</li>
<li>C#中，运行时的多态性通过<strong>虚成员</strong>实现</li>
</ul></li>
<li>好处
<ul>
<li>编译时的多态性提供了运行速度快的特点</li>
<li>而运行时的多态性则带来了高度灵活和抽象的特点</li>
</ul></li>
</ul>
<h3 id="上溯造型与虚方法调用">上溯造型与虚方法调用</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span>()</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Shape Drawing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">draw</span>()</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Draw Circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>virtual、override</li>
</ul>
<h3 id="语法">语法</h3>
<ul>
<li>必须有 <code>virtual</code> 或 <code>abstract</code> 或
<code>override</code> 所修饰</li>
<li>虚方法不能省略访问控制符
<ul>
<li>不能是 private 的，不能是 static 的</li>
<li>因为它们应该可以被子类所覆盖。</li>
</ul></li>
<li>子类中要覆盖父类的虚方法，必须用 override
<ul>
<li>否则认为是新（new）的一个方法，并隐藏了父类的方法，不会实行虚方法调用</li>
<li>覆盖和被覆盖的方法必须有相同的<strong>可访问性</strong>和相同的<strong>返回类型</strong></li>
</ul></li>
<li>重要例子
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/13/OverrideTest1.cs">ex1</a>、<a href="/utils/show_code/index.html?csharp/tds/13/OverrideTest2.cs">ex2</a>、<a href="/utils/show_code/index.html?csharp/tds/13/OverrideTest3.cs">ex3</a>、<a href="/utils/show_code/index.html?csharp/tds/13/OverrideTest4.cs">ex4</a>、<a href="/utils/show_code/index.html?csharp/tds/13/OverrideTest5.cs">ex5</a></li>
</ul></li>
</ul>
<h3 id="虚方法与非虚方法">虚方法与非虚方法</h3>
<ul>
<li>虚方法调用的方法是由<strong>对象实例的类型</strong>所决定</li>
<li>非虚方法调用的方法是由<strong>所声明的对象变量</strong>来决定的</li>
</ul>
<h3 id="最可派生的方法">最可派生的方法</h3>
<ul>
<li>继承链中既有 override 也有 new</li>
<li><a href="/utils/show_code/index.html?csharp/tds/13/VirtualComplex.cs">示例</a></li>
</ul>
<h2 id="动态类型确定">4. 动态类型确定</h2>
<h3 id="is-运算符">is 运算符</h3>
<ul>
<li>用于判断运行时对象的类型</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj <span class="keyword">is</span> TypeA) &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="和">== 和 !=</h3>
<ul>
<li>值类型相等</li>
<li>引用类型的相等
<ul>
<li>是判断是否是同一对象</li>
<li>除非重载了 == 及 != 操作</li>
<li><strong>对于 string 等类型，已经进行了重载</strong></li>
<li><strong>对于两个 boxing 的对象，== 总是 false</strong></li>
</ul></li>
</ul>
<h3 id="得到类型信息">得到类型信息</h3>
<ul>
<li><strong>typeof 运算符</strong>
<ul>
<li><code>typeof(System.Console)</code></li>
</ul></li>
<li><code>对象.GetType()</code></li>
<li><code>Type.GetType(string 类名)</code></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TypeGetType</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">double</span> d = <span class="number">1.0</span>;</span><br><span class="line">        Type[] t = &#123;</span><br><span class="line">            <span class="keyword">typeof</span>(<span class="built_in">int</span>),</span><br><span class="line">            <span class="keyword">typeof</span>(System.Int32),</span><br><span class="line">            <span class="keyword">typeof</span>(<span class="built_in">string</span>),</span><br><span class="line">            <span class="keyword">typeof</span>(<span class="built_in">double</span>[]),</span><br><span class="line">            x.GetType(),</span><br><span class="line">            (x+d).GetType(),</span><br><span class="line">            Type.GetType( <span class="string">&quot;System.Console&quot;</span> ),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获得这个类型的其他元信息
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/13/TypeGetMembers.cs">示例</a></li>
</ul></li>
</ul>
<h3 id="反射">反射</h3>
<ul>
<li>可以从 <code>exe</code> 文件中获取信息
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/13/ReflectionTest.cs">示例</a></li>
</ul></li>
</ul>
<h2 id="对象构造与析构">5. 对象构造与析构</h2>
<h3 id="构造方法">构造方法</h3>
<ul>
<li>构造方法的初始化部分，使用 <code>this</code> 及 <code>base</code>
<ul>
<li>调用本类或父类的构造方法</li>
<li>不用 <code>this</code> 且不用 <code>base</code>，则会自动认为
<code>base()</code>
<ul>
<li>这样的写法要求基类必须有默认构造方法</li>
</ul></li>
</ul></li>
</ul>
<h4 id="域的初始化">域的初始化</h4>
<ul>
<li>域的初始化中不能引用 this</li>
<li>在 base 被调用之前不能引用 this</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span>()</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span>(<span class="params"><span class="built_in">int</span> i</span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span> : <span class="title">A</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">M</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> y = x+M(); <span class="comment">//Error</span></span><br><span class="line">    B():<span class="keyword">base</span>(x) &#123;&#125; <span class="comment">//Error</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// t.cs(12,13): error CS0236: 字段初始值设定项无法引用非静态字段、方法或属性“B.x”</span></span><br><span class="line"><span class="comment">// t.cs(12,15): error CS0236: 字段初始值设定项无法引用非静态字段、方法或属性“B.M()”</span></span><br><span class="line"><span class="comment">// t.cs(13,14): error CS0120: 对象引用对于非静态的字段、方法或属性“B.x”是必需的</span></span><br></pre></td></tr></table></figure>
<h4 id="构造顺序">构造顺序</h4>
<ul>
<li>执行过程（Java 2/3 相反）
<ul>
<li>若有 this，转向之</li>
<li>执行域的初始化</li>
<li>转到 base</li>
<li>执行方法体</li>
</ul></li>
<li>应避免在构造方法中调用任何虚方法</li>
<li><a href="/utils/show_code/index.html?csharp/tds/13/ConstructorExecution.cs">示例</a></li>
</ul>
<h3 id="静态构造方法">静态构造方法</h3>
<ul>
<li>静态构造方法总是在该类的<strong>所有静态域初始化之后</strong>执行</li>
<li>静态构造方法总是在<strong>该类被使用（如访问静态域、生成实例）之前完成</strong></li>
<li>静态构造方法<strong>最多被执行一次</strong></li>
<li>静态构造方法的执行顺序的不确定性，所以在使用构造方法时应谨慎</li>
<li>应尽量避免在静态初始化或静态域中出现循环引用的情况</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> a = b + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> b = a + <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;a=&#123;0&#125;,b=&#123;1&#125;&quot;</span>,a,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a=1,b=2</span></span><br></pre></td></tr></table></figure>
<h3 id="析构方法">析构方法</h3>
<ul>
<li><code>~类名()&#123;&#125;</code>
<ul>
<li>析构方法会自动调用父类的析构方法</li>
</ul></li>
<li>编译器生成的构造方法名字为 <code>ctor()</code></li>
<li>生成的析构方法名字为 <code>Finalize()</code></li>
<li><strong>不能显式</strong>地调用析构方法</li>
</ul>
<h3 id="自动垃圾回收">自动垃圾回收</h3>
<ul>
<li>垃圾回收（garbage collection）</li>
<li>自动回收</li>
<li><strong>强制回收</strong></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">System.GC.Collect(); <span class="comment">// 告诉系统建议回收</span></span><br></pre></td></tr></table></figure>
<h3 id="显式资源管理">显式资源管理</h3>
<ul>
<li>实现 <code>IDisposable</code> 接口</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">System</span> &#123;</span><br><span class="line">    [<span class="meta">System.Runtime.InteropServices.ComVisible(true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDisposable</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Dispose</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="using-语句">using 语句</h4>
<ul>
<li>如下两种方式等价</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">R r1 = <span class="keyword">new</span> R();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    r1.F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (r1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        ((IDisposable)r1).Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (R r1 = <span class="keyword">new</span> R())&#123;</span><br><span class="line">    r1.F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="c-语言新特性">6. C# 语言新特性</h2>
<ul>
<li>2.0 引入泛型</li>
<li>3.0 引入Lambda及Linq</li>
<li>4.0 引入动态特性dynamic</li>
<li>5.0 引入并行及异步async/await及Task</li>
<li>6.0 改进编译，属性初始化</li>
</ul>
<h3 id="section">2.0</h3>
<ul>
<li>泛型 <code>List&lt;T&gt;</code></li>
<li>泛型 delegate
<ul>
<li><code>Predicate&lt;T&gt;</code></li>
<li><code>Comparison&lt;T&gt;</code></li>
<li><code>Converter&lt;TInput,TOutput&gt;</code></li>
<li><code>EventHandler&lt;TEventArgs&gt;</code></li>
</ul></li>
<li>匿名方法
<ul>
<li>delegate(参数) { 方法体 }</li>
</ul></li>
</ul>
<h3 id="section-1">3.0</h3>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/samples/dotnet/try-samples/101-linq-samples/">Linq
示例</a></li>
<li><strong>扩展方法</strong>，用于给一个类新添加方法
<ul>
<li><strong>牛逼啊</strong>，这个给控件扩展放啊实在太棒了，可惜写大作业之前不知道</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">T</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsLonger</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> str, <span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str!=<span class="literal">null</span> &amp;&amp; str.Length&gt; n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        Console.Write(s.IsLonger(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="section-2">4.0</h3>
<ul>
<li>dynamic
<ul>
<li>可以动态表示任意对象，在编译时不进行语法检查</li>
<li>主要用于 COM 组件的操作</li>
</ul></li>
</ul>
<h3 id="section-3">5.0</h3>
<ul>
<li>Task</li>
<li>await/async</li>
<li>PLinq</li>
<li>Parallel</li>
</ul>
<h3 id="section-4">6.0</h3>
<ul>
<li>初始化更方便</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">T</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">    &#125; = <span class="string">&quot;Mr.&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> intAge =&gt; <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">intAdd</span>(<span class="params">inta, intb</span>)</span> =&gt; a+b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun</span>(<span class="params"> <span class="built_in">string</span> s </span>)</span> =&gt; Console.Write(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>csharp.tds</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#程序设计.唐大仕.期中.语法小结</title>
    <url>/2021/11/05/csharp/tds/mid/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1001663016">中国大学慕课</a></li>
</ul>
<h1 id="语法小结">语法小结</h1>
<h2 id="思维导图">思维导图</h2>
<p><img src="/2021/11/05/csharp/tds/mid/CSharp-Grammar-Summary.png"></p>
<h2 id="关键字">关键字</h2>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 93%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">选项</th>
<th style="text-align: left;">内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: left;">表示是子类可见的</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: left;">表示同程序集中可见</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: left;">表示属性或方法足属于整个类的，而不是实例的</td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: left;">表示它是一个常量</td>
</tr>
<tr class="odd">
<td style="text-align: center;">E</td>
<td style="text-align: left;">表示它是抽象的方法或属性，它应该被子类来实现</td>
</tr>
<tr class="even">
<td style="text-align: center;">F</td>
<td style="text-align: left;">表示该方法是虚的，即可以被子类重写的</td>
</tr>
<tr class="odd">
<td style="text-align: center;">G</td>
<td style="text-align: left;">表示该方法是重写（覆盖）父类的方法</td>
</tr>
<tr class="even">
<td style="text-align: center;">H</td>
<td style="text-align: left;">表示该类不能被能承</td>
</tr>
<tr class="odd">
<td style="text-align: center;">I</td>
<td style="text-align: left;">表示它是一个只读的变量它只能赋一次值，
要么在声明时赋值，要么在构造方法中赋值</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 13%">
<col style="width: 6%">
<col style="width: 24%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 18%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">关键字</th>
<th style="text-align: center;">含义</th>
<th style="text-align: center;">修饰类</th>
<th style="text-align: center;">修饰方法</th>
<th style="text-align: center;">修饰字段</th>
<th style="text-align: center;">修饰局部变量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">abstract</td>
<td style="text-align: center;">E</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">const</td>
<td style="text-align: center;">D</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">internal</td>
<td style="text-align: center;">B</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">override</td>
<td style="text-align: center;">G</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">protected</td>
<td style="text-align: center;">A</td>
<td style="text-align: center;"><span class="math inline">\({\color{red}X}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">readonly</td>
<td style="text-align: center;">I</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">sealed</td>
<td style="text-align: center;">H</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">static</td>
<td style="text-align: center;">C</td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">virtual</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(\checkmark\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h2 id="语法要素">语法要素</h2>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 93%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">选项</th>
<th style="text-align: left;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: left;">相当于定义一个函数原型，
但是有多播的功能，也就是说它可以“内含” 多个函数</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: left;">相当于一个变量的 setter 及
getter，但是可以进行有效性的检查或其他功能</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: left;">相当于一个没有名字的函数，使用方括号来调用，一般用于求集合中的一个元素</td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: left;">相当于一个 inline
的函数，这个函数定义的同时就使用了，它没有名字</td>
</tr>
<tr class="odd">
<td style="text-align: center;">E</td>
<td style="text-align: left;">相当于一个纯的抽象类，由一系列的抽象方法构成，每个成员都是
public abtract 的</td>
</tr>
<tr class="even">
<td style="text-align: center;">F</td>
<td style="text-align: left;">相当于一个值类型（ValueType）化的类它存在于
“这里”，而不是一个引用</td>
</tr>
<tr class="odd">
<td style="text-align: center;">G</td>
<td style="text-align: left;">相当于一个成员变量，它的类型是
delegate，但是在外面只能 <code>+=</code> 及
<code>-=</code>，在内部才能用圆括号 <code>()</code> 去调用</td>
</tr>
<tr class="even">
<td style="text-align: center;">H</td>
<td style="text-align: left;">一种特殊的方法，它的作用是初始化一个对象，它在调用时，前面要加个
new</td>
</tr>
<tr class="odd">
<td style="text-align: center;">I</td>
<td style="text-align: left;">相当于一个事物的几种可能情况，虽然在内部是用整数表示，但程序员可以用符号来表示</td>
</tr>
<tr class="even">
<td style="text-align: center;">J</td>
<td style="text-align: left;">在类、方法或参数等元素上面附加一点信息，仅供编译器或调用者通过反射等方法来使用</td>
</tr>
<tr class="odd">
<td style="text-align: center;">K</td>
<td style="text-align: left;">是匿名方法的一种简写，它用
<code>=&gt;</code> 来表示</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 18%">
<col style="width: 13%">
<col style="width: 4%">
<col style="width: 63%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">关键字</th>
<th style="text-align: center;">中文</th>
<th style="text-align: center;">含义</th>
<th style="text-align: center;">例子</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">property</td>
<td style="text-align: center;">属性</td>
<td style="text-align: center;">B</td>
<td style="text-align: center;">int a{get;set;}</td>
</tr>
<tr class="even">
<td style="text-align: center;">constructor</td>
<td style="text-align: center;">构造方法</td>
<td style="text-align: center;">H</td>
<td style="text-align: center;">B b = new B();</td>
</tr>
<tr class="odd">
<td style="text-align: center;">event</td>
<td style="text-align: center;">事件</td>
<td style="text-align: center;">G</td>
<td style="text-align: center;">class xxArgs {}<br>delegate void
xxHandler(object sender, xxArgs e);<br>public event xxHandler
xxHappend;<br>xxHanpend(this, e);<br>xx.xxHappend += (obj, e) =&gt;
{}</td>
</tr>
<tr class="even">
<td style="text-align: center;">index</td>
<td style="text-align: center;">索引</td>
<td style="text-align: center;">C</td>
<td style="text-align: center;">public int this[int idx] { set{}get{}
}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">attribute</td>
<td style="text-align: center;">特性</td>
<td style="text-align: center;">J</td>
<td style="text-align: center;">[Serializable] class Book {}</td>
</tr>
<tr class="even">
<td style="text-align: center;">struct</td>
<td style="text-align: center;">结构</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">struct STest { int a; int b; }</td>
</tr>
<tr class="odd">
<td style="text-align: center;">enum</td>
<td style="text-align: center;">枚举</td>
<td style="text-align: center;">I</td>
<td style="text-align: center;">enum ETest { A,B,C }</td>
</tr>
<tr class="even">
<td style="text-align: center;">interface</td>
<td style="text-align: center;">接口</td>
<td style="text-align: center;">E</td>
<td style="text-align: center;">interface ITest{}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">delegate</td>
<td style="text-align: center;">委托</td>
<td style="text-align: center;">A</td>
<td style="text-align: center;">private delegate void
DTest();<br>private void test1(DTest f) { f(); }<br>private void
fun1() {}<br>private void ff() { test1(fun1); }</td>
</tr>
<tr class="even">
<td style="text-align: center;">anonymous method</td>
<td style="text-align: center;">匿名方法</td>
<td style="text-align: center;">D</td>
<td style="text-align: center;">xx.xxHappend += delegate(object obj,
xxArgs e) {}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">lambda expression</td>
<td style="text-align: center;">lambda 表达式</td>
<td style="text-align: center;">D,K</td>
<td style="text-align: center;">xx.xxHappend += (obj,e) =&gt;{}</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>csharp.tds</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#程序设计.唐大仕.05.基础类及常用算法</title>
    <url>/2021/10/15/csharp/tds/05/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1001663016">中国大学慕课</a></li>
</ul>
<h1 id="基础类及常用算法">基础类及常用算法</h1>
<h2 id="dotnet-基本类库">1. DotNet 基本类库</h2>
<ul>
<li>统一的编程 API：NET Framework 类库</li>
</ul>
<p><img src="/2021/10/15/csharp/tds/05/image-20211016150748013.png" style="zoom:150%;"></p>
<ul>
<li>具体</li>
</ul>
<p><img src="/2021/10/15/csharp/tds/05/image-20211016151043014.png" style="zoom: 67%;"></p>
<h2 id="类型转换">2. 类型转换</h2>
<h3 id="任何事物都是对象">任何事物都是对象</h3>
<ul>
<li>任何事物都是 object 类的子类</li>
<li>一个函数如果需要object参数，则可以代入任意参数</li>
<li>任何对象都有以下方法</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">ToString();</span><br><span class="line">Equals();</span><br><span class="line">GetType();</span><br><span class="line">GetHashCode();</span><br><span class="line"><span class="comment">// MemberwiseClone(); // 没找到?</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<ul>
<li>常量也是对象</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="number">3.</span>ToString();</span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.Length;</span><br></pre></td></tr></table></figure>
<h3 id="表达式中的类型转换">表达式中的类型转换</h3>
<ul>
<li>当有不同种类的混合运算时:
<ul>
<li>int <span class="math inline">\(\to\)</span> long <span class="math inline">\(\to\)</span> float <span class="math inline">\(\to\)</span> double</li>
</ul></li>
</ul>
<h4 id="整型提升">整型提升</h4>
<ul>
<li>在计算的时候，所有的 byte、short、char 等转为 int</li>
</ul>
<h4 id="强制类型转换">强制类型转换</h4>
<ul>
<li>在表达式前面用（类型）来表示</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">int</span> b = (<span class="built_in">int</span>)a;</span><br><span class="line"><span class="built_in">float</span> c = (<span class="built_in">float</span>)(d+<span class="number">1.25</span>);</span><br></pre></td></tr></table></figure>
<h3 id="类型转换函数">类型转换函数</h3>
<ul>
<li><code>System.Convert</code> 类有以下 static 方法
<ul>
<li>每个函数有对应参数类型的各种重载函数</li>
</ul></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">ToInt16();</span><br><span class="line">ToInt32();</span><br><span class="line">ToInt64();</span><br><span class="line">ToSbyte();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>会抛出异常</strong></li>
</ul>
<p><img src="/2021/10/15/csharp/tds/05/image-20211016154344194.png" style="zoom: 80%;"></p>
<h3 id="基本类型">基本类型</h3>
<h4 id="关键字含有等价的类">关键字含有等价的类</h4>
<ul>
<li>int：System.Int32</li>
</ul>
<p><img src="/2021/10/15/csharp/tds/05/image-20211016155125985.png" style="zoom:80%;"></p>
<h4 id="静态属性或方法">静态属性或方法</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">0</span>;</span><br><span class="line">a = <span class="built_in">int</span>.MaxValue;</span><br><span class="line">a = <span class="built_in">int</span>.MinValue;</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> b = <span class="number">0.0</span>;</span><br><span class="line">b = <span class="built_in">double</span>.NaN;</span><br><span class="line">b = <span class="built_in">double</span>.NegativeInfinity;</span><br><span class="line">b = <span class="built_in">double</span>.PositiveInfinity;</span><br></pre></td></tr></table></figure>
<h4 id="parse-和-tryparse">Parse 和 TryParse</h4>
<ul>
<li>TryParse 不抛出异常</li>
</ul>
<p><img src="/2021/10/15/csharp/tds/05/image-20211016154953223.png" style="zoom:80%;"></p>
<ul>
<li>Parse 抛出异常</li>
</ul>
<p><img src="/2021/10/15/csharp/tds/05/image-20211016154753773.png" style="zoom:80%;"></p>
<h4 id="tostring">ToString()</h4>
<ul>
<li>更具体的查看<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.double.tostring?view=netframework-4.7.1">文档</a></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">W</span>(<span class="params"><span class="built_in">string</span> s</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> specifier;</span><br><span class="line">        CultureInfo culture;</span><br><span class="line">        <span class="built_in">double</span> a = <span class="number">314.15326</span>;</span><br><span class="line"></span><br><span class="line">        W(a.ToString());</span><br><span class="line">        <span class="comment">// 314.15326</span></span><br><span class="line"></span><br><span class="line">        specifier = <span class="string">&quot;G&quot;</span>;</span><br><span class="line">        culture = CultureInfo.CreateSpecificCulture(<span class="string">&quot;eu-ES&quot;</span>);</span><br><span class="line">        W(a.ToString(a.ToString(specifier, culture)));</span><br><span class="line">        <span class="comment">// 31415326</span></span><br><span class="line"></span><br><span class="line">        W(a.ToString(specifier, CultureInfo.InvariantCulture));</span><br><span class="line">        <span class="comment">// 314.15326</span></span><br><span class="line"></span><br><span class="line">        W(a.ToString(<span class="string">&quot;#0.00&quot;</span>));</span><br><span class="line">        <span class="comment">// 314.15</span></span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数学文字日期">3. 数学、文字、日期</h2>
<h3 id="math-类">Math 类</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Abs();</span><br><span class="line">Sin();</span><br><span class="line">Cos();</span><br><span class="line">Tan();</span><br><span class="line">Round();</span><br><span class="line">Exp();</span><br><span class="line">Log();</span><br><span class="line">Pow();</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="random-类">Random 类</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Next(<span class="number">100</span>); <span class="comment">// [0, 100)</span></span><br><span class="line">NextDouble(); <span class="comment">// [0, 1)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Random 得到的是伪随机数</li>
<li>如果要用更强的随机数，可以使用如下方法</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Security.Cryptography;</span><br><span class="line"></span><br><span class="line">RNGCryptoServiceProvider rdm = <span class="keyword">new</span> RNGCryptoServiceProvider();</span><br><span class="line"><span class="built_in">byte</span>[] a = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">100</span>];</span><br><span class="line">rdm.GetBytes(a);</span><br></pre></td></tr></table></figure>
<h3 id="datetime-类">DateTime 类</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line">W(DateTime.Now.ToString());</span><br><span class="line"><span class="comment">// 2021/10/16 16:25:45</span></span><br><span class="line"></span><br><span class="line">Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">W(DateTime.Now.ToString());</span><br><span class="line"><span class="comment">// 2021/10/16 16:25:46</span></span><br></pre></td></tr></table></figure>
<ul>
<li>DateTime 是<strong>值类型</strong></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> DateTime(y,m,d,h,m,s);</span><br><span class="line"><span class="comment">// 属性与方法</span></span><br><span class="line">Now;</span><br><span class="line">Year;</span><br><span class="line">Month;</span><br><span class="line">Day;</span><br><span class="line">Date;</span><br><span class="line"></span><br><span class="line">ToString(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); <span class="comment">// H(24小时),h(12小时),MM(月份),mm(分钟)</span></span><br><span class="line">AddMinutes(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>TimeSpan
<ul>
<li>两个日期相减，可以得到一个TimeSpan</li>
</ul></li>
</ul>
<h3 id="string-类">String 类</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">==;</span><br><span class="line">+;</span><br><span class="line">[];</span><br><span class="line"></span><br><span class="line">Length;</span><br><span class="line">IndexOf();</span><br><span class="line">LastIndexOf();</span><br><span class="line">StartsWith();</span><br><span class="line">EndsWith();</span><br><span class="line">Substring(idx, len); <span class="comment">// 注意第二个参数</span></span><br><span class="line">Trim();</span><br><span class="line">TrimEnd();</span><br><span class="line">PadLeft();</span><br><span class="line">Insert();</span><br><span class="line">Remove();</span><br><span class="line">Split(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line"><span class="built_in">string</span>.Join()</span><br></pre></td></tr></table></figure>
<h3 id="stringbuilder">StringBuilder</h3>
<ul>
<li>不可变的 String 与可变的 StringBuilder</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Append();</span><br><span class="line">Remove();</span><br><span class="line">Replace();</span><br><span class="line">Length();</span><br><span class="line">ToString();</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/05/TestStringStringBuilder.cs">性能测试</a>
<ul>
<li>在头部 Insert，StringBuilder 不一定会更快
<ul>
<li>可以设置初始容量</li>
</ul></li>
<li>尾部 append，StringBuilder 更快</li>
</ul></li>
</ul>
<h2 id="数组集合泛型">4. 数组、集合、泛型</h2>
<h3 id="数组">数组</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="type">int</span>[] a;  <span class="comment">// 一维数组</span></span><br><span class="line"><span class="type">int</span>[,] b; <span class="comment">// 二维数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配空间</span></span><br><span class="line">a = new <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">b = new <span class="type">int</span>[<span class="number">4</span>,<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<h3 id="集合类">集合类</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br></pre></td></tr></table></figure>
<ul>
<li>数组列表 ArrayList
<ul>
<li>相当于动态数组,实现 IList</li>
</ul></li>
<li>哈希表 Hashtable
<ul>
<li>相当于键/值的集合，实现 IDictionary</li>
<li>用 [] 进行访问，表示获取、增加、删除、修改</li>
<li>提示：用于查询时，比线性搜索的效率要高，可用于程序的优化</li>
</ul></li>
<li>栈和队列 Stack/Queue</li>
</ul>
<h4 id="foreach">foreach</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> a <span class="keyword">in</span> listA) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Console.WriteLine(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(类型 变量 <span class="keyword">in</span> xxxx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中 xxxx 必须是实现了实现 <code>IEnumerable</code> 接口或含有
<code>GetEnumerator()</code> 方法的类型</li>
<li>这个方法的原型是 <code>IEnumerator GetEnumerator();</code></li>
<li>返回的是一个接口 <code>IEnumerator</code>
<ul>
<li><code>Current</code> 属性</li>
<li><code>MoveNext()</code> 及 <code>Reset()</code> 方法</li>
</ul></li>
</ul>
<h3 id="二分查找">二分查找</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Array.BinarySearch();</span><br></pre></td></tr></table></figure>
<h3 id="泛型">泛型</h3>
<ul>
<li>泛型具有更好的类型检查及性能</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br></pre></td></tr></table></figure>
<ul>
<li>列表
<ul>
<li>List</li>
<li>LinkedList</li>
<li>SortedList</li>
</ul></li>
<li>字典
<ul>
<li>Dictionary</li>
<li>SortedDictionary</li>
</ul></li>
<li>集合
<ul>
<li>HashSet</li>
<li>SortedSet</li>
</ul></li>
<li>栈、队列
<ul>
<li>Stack, Queu</li>
</ul></li>
</ul>
<h3 id="一些代码">一些代码</h3>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/05/ListTest.cs">List
的遍历</a></li>
<li>foreach 的内部实现</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintValues2</span>(<span class="params">IList&lt;<span class="built_in">string</span>&gt; myList</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// foreach 遍历方式</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> item <span class="keyword">in</span> myList) &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;&#123;0&#125;\n&quot;</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintValues3</span>(<span class="params">IEnumerable&lt;<span class="built_in">string</span>&gt; myList</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// foreach 的内部实现</span></span><br><span class="line">    IEnumerator&lt;<span class="built_in">string</span>&gt; myEnumerator = myList.GetEnumerator();</span><br><span class="line">    <span class="keyword">while</span> (myEnumerator.MoveNext()) &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;&#123;0&#125;\n&quot;</span>, myEnumerator.Current);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/05/HashtableTest.cs">HashTable
的遍历</a></li>
</ul>
<h3 id="排序">排序</h3>
<ul>
<li>自己写排序程序</li>
<li>使用 SortedXXXX 类</li>
<li>使用 Array.Sort() 方法</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Array.Sort(arr, (a, b) =&gt; a.Length - b.Length);</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p><img src="/2021/10/15/csharp/tds/05/image-20211016194301153.png" style="zoom:120%;"></p>
<h2 id="常用算法">5. 常用算法</h2>
<h3 id="算法">算法</h3>
<ul>
<li>指令的有限序列</li>
<li>特点
<ul>
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
<li>输入、输出</li>
</ul></li>
</ul>
<h3 id="遍试算法">遍试算法</h3>
<ul>
<li>枚举、穷尽</li>
</ul>
<h4 id="例子">例子</h4>
<ul>
<li><p><strong><a href="/utils/show_code/index.html?csharp/tds/05/BuyChicken.cs">百鸡问题</a></strong>：100元钱买100只鸡，如何买？已知条件：鸡母每只3元，鸡公每只1元，鸡仔每3只1元。</p></li>
<li><p><strong>鸡兔同笼问题</strong>：鸡兔在同一笼子中，共有头30只，共有脚100只，问鸡兔又有几只？</p></li>
<li><p><strong>百分币问题</strong>：要给人100分币有多少种方案。已知分币的种类有1分、2分、5分、10分、50分共5种。</p></li>
<li><p><strong>佩尔方程</strong>：
某将领的军队有29个方阵（人数为平方），如果他也参与其中，则可以排成一个大方阵，请问他有多少军队？</p></li>
<li><p>韩信点兵</p></li>
<li><p>水仙花数：<span class="math inline">\(1^3+5^3+3^3=153\)</span></p></li>
<li><p>完全数：<span class="math inline">\(28=1+2+4+7+14\)</span>（因数）</p></li>
<li><p>相亲数</p></li>
<li><p>验证哥德巴赫猜想</p></li>
</ul>
<h3 id="迭代算法">迭代算法</h3>
<ul>
<li>求平方根（不动点迭代）
<ul>
<li>牛顿法</li>
</ul></li>
<li>数字平方和</li>
<li>Mandelbrot 集</li>
<li>Julia 集</li>
</ul>
<h4 id="倍边法求-pi">倍边法求 Pi</h4>
<ul>
<li>使用正多边形的周长 <span class="math inline">\(C_1\)</span>
近似圆周长 <span class="math inline">\(C_2\)</span>，令 <span class="math inline">\(r=1\)</span></li>
</ul>
<p><span class="math display">\[
\pi=\dfrac{C}{2r}=\dfrac{C_1}{2}
\]</span></p>
<ul>
<li><span class="math inline">\(a_n=b_{m},m=3\cdot{2^{n+1}}\)</span>
表示正 <span class="math inline">\(m\)</span> 边形的周长
<ul>
<li><span class="math inline">\(a_0=1\)</span>：正六边形</li>
<li><strong><span style="color:#ff7f27;">橙色线段</span></strong>：<span class="math inline">\(a_n\)</span></li>
<li><strong><span style="color:#ed1c24;">红色线段</span></strong>：<span class="math inline">\(a_{n+1}\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\sqrt{1-\left(\dfrac{a_n}{2}\right)^{2}}+\sqrt{\left(a_{n+1}\right)^2-\left(\dfrac{a_n}{2}\right)^2}=1
\]</span></p>
<p><span class="math display">\[
a_{n+1}=\sqrt{2-2\sqrt{1-\dfrac{a_n^4}{4}}}
\]</span></p>
<p><img src="/2021/10/15/csharp/tds/05/pi.png" style="zoom:80%;"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">TestDebugPi</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">double</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> n = <span class="number">1</span>; n &lt;= <span class="number">10</span>; n++) &#123;</span><br><span class="line">            a = Math.Sqrt(<span class="number">2</span> - Math.Sqrt(<span class="number">4</span> - a * a));</span><br><span class="line">            <span class="built_in">double</span> pi = a * <span class="number">3</span> * Math.Pow(<span class="number">2</span>, n);</span><br><span class="line">            Console.WriteLine(pi);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(Math.PI);</span><br><span class="line">        <span class="comment">// 如果n&lt;=100,如何?</span></span><br><span class="line">        <span class="comment">// 精度问题, 出错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归算法">递归算法</h3>
<ul>
<li>阶乘</li>
<li>走台阶问题（一步一级或两级）</li>
<li>斐波那契数列</li>
<li><a href="/utils/show_code/index.html?csharp/tds/05/DrawTree.cs">绘制树</a>
<ul>
<li><a href="/utils/show_code/index.html?csharp/tds/05/DrawTreeRdm.cs">加入随机因素</a></li>
</ul></li>
</ul>
<h2 id="程序的调试">6. 程序的调试</h2>
<h3 id="程序错误">程序错误</h3>
<ul>
<li>语法错误、运行错误、逻辑错误</li>
</ul>
<h3 id="语法错误">语法错误</h3>
<ul>
<li>常见的语法错误
<ul>
<li>如括号不配对、多了或少了分号</li>
<li>字母写错、变量未定义、控件命名写错</li>
<li>函数少传了一个参数</li>
</ul></li>
<li>语法错：编译器可以发现（在编辑、编译时）</li>
<li>对编程者：养成良好的编程习惯
<ul>
<li>命名、空行、注释</li>
</ul></li>
</ul>
<h3 id="运行时错误">运行时错误</h3>
<ul>
<li>运行时错误（Runtime Error）多数发生在不可预期的异常
<ul>
<li>文件打不开、网络打不开、内存不足</li>
<li>整数除法的除数为零，数组下标走越界、变量初始化为null</li>
</ul></li>
<li>解决办法
<ul>
<li>使用 <code>try&#123;&#125;catch&#123;&#125;</code></li>
<li>使用 <code>if</code> 语句进行判断处理</li>
</ul></li>
</ul>
<h3 id="逻辑错误">逻辑错误</h3>
<ul>
<li>逻辑错误（Logic Error）是指程序所完成的任务与预想的任务不匹配
<ul>
<li>小于s.Length写成&lt;=s.Length</li>
<li>1到加100,却只加到99</li>
<li>算法的错误</li>
</ul></li>
<li>解决逻辑错误
<ul>
<li>分析清楚需求、理清算法、在程序中进行调试</li>
<li>特别注意边界条件、特殊值</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>csharp.tds</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>PS 批量处理图片</title>
    <url>/2022/03/11/software/ps/01/</url>
    <content><![CDATA[<h1 id="批量处理图片">批量处理图片</h1>
<ul>
<li><a href="https://jingyan.baidu.com/article/6b97984d887ee25da3b0bf10.html">教程</a></li>
<li>其实用 opencv 更快</li>
</ul>
<h2 id="效果">效果</h2>
<ul>
<li>对相同大小的图片进行相同的剪裁效果</li>
<li><strong><span style="color:red">这里的操作是在原始图片上进行修改的，注意提前备份</span></strong></li>
</ul>
<h2 id="步骤">步骤</h2>
<h3 id="显示动作窗口">(1) 显示动作窗口</h3>
<ul>
<li>窗口 <code>-&gt;</code> 动作</li>
</ul>
<h3 id="新建动作记录">(2) 新建动作记录</h3>
<ul>
<li>可以新建一个组，把用户自定义的动作放到这个组里（区别于默认动作）</li>
</ul>
<p><img src="/2022/03/11/software/ps/01/image-20220311125451894.png"></p>
<ul>
<li>此时新建的动作下面会有录制播放等</li>
</ul>
<p><img src="/2022/03/11/software/ps/01/image-20220311130258284.png"></p>
<ul>
<li>可以先暂停</li>
</ul>
<h3 id="录制动作">(3) 录制动作</h3>
<ul>
<li>打开图片</li>
<li>开始录制，录制结束后停止</li>
<li>效果如下</li>
</ul>
<p><img src="/2022/03/11/software/ps/01/image-20220311130954116.png"></p>
<h3 id="组操作">(4) 组操作</h3>
<ul>
<li>文件 <code>-&gt;</code> 自动 <code>-&gt;</code> 批处理</li>
</ul>
<p><img src="/2022/03/11/software/ps/01/image-20220311131136986.png"></p>
<ul>
<li>配置</li>
</ul>
<p><img src="/2022/03/11/software/ps/01/image-20220311131953580.png"></p>
<ul>
<li>确定即可</li>
</ul>
<h2 id="其他">其他</h2>
<ul>
<li>如果不想覆盖原文件，而是另存为，最后一步操作如下
<ul>
<li>删除动作序列中的<strong>存储命令</strong></li>
<li>组操作中设置<strong>另存为</strong></li>
</ul></li>
</ul>
<p><img src="/2022/03/11/software/ps/01/image-20220311132616528.png"></p>
]]></content>
      <categories>
        <category>software.ps</category>
      </categories>
      <tags>
        <tag>ps</tag>
      </tags>
  </entry>
  <entry>
    <title>Maya 基础知识</title>
    <url>/2022/03/10/software/maya/01/</url>
    <content><![CDATA[<h1 id="maya-基础知识">Maya 基础知识</h1>
<ul>
<li>Maya2019</li>
<li><a href="http://docs.autodesk.com/MAYAUL/2015/CHS/GettingStarted/#!/url=./files/landing_page.htm">教程</a></li>
</ul>
<h2 id="基本认知">基本认知</h2>
<ul>
<li>创建多边形基本体的时候，不要双击，而是点右边的复选框，这样能够设置属性</li>
</ul>
<p><img src="/2022/03/10/software/maya/01/image-20220310112813533.png"></p>
<ul>
<li>选中具体的工具之后才能够进行变换操作（平移、旋转、放缩）</li>
</ul>
<p><img src="/2022/03/10/software/maya/01/image-20220310112325229.png"></p>
<ul>
<li>不同的视图模式
<ul>
<li><strong>空格键快速切换</strong></li>
</ul></li>
</ul>
<p><img src="/2022/03/10/software/maya/01/image-20220310112635230.png"></p>
<h2 id="变换操作">变换操作</h2>
<ul>
<li>选中物体，可以通过大纲视图中选中某个物体</li>
</ul>
<p><img src="/2022/03/10/software/maya/01/image-20220310114314840.png"></p>
<ul>
<li><strong>如果单击某个特定的控制柄，则表示移动将约束到这一特定轴方向</strong></li>
<li>移动也可以直接拖动，同时也可以通过顶部的 <code>X,Y,Z</code>
设置</li>
</ul>
<p><img src="/2022/03/10/software/maya/01/image-20220310113553183.png"></p>
<ul>
<li>也可以通过<strong>通道盒</strong>设置</li>
</ul>
<p><img src="/2022/03/10/software/maya/01/image-20220310113906961.png"></p>
<h2 id="通道盒">通道盒</h2>
<p><img src="/2022/03/10/software/maya/01/image-20220310113906961.png"></p>
<ul>
<li>设置变换</li>
<li>重命名
<ul>
<li>大纲视图中也可以重命名</li>
</ul></li>
</ul>
<h2 id="复制">复制</h2>
<ul>
<li>编辑 <code>-&gt;</code> 特殊复制
<ul>
<li>允许设置复制的属性</li>
</ul></li>
</ul>
<h2 id="摄像机工具">摄像机工具</h2>
<ul>
<li><strong>如下操作都是在移动相机，而不是物体</strong>
<ul>
<li><code>alt</code> + 鼠标右键：推拉工具(Dolly Tool)</li>
<li><code>alt</code> + 鼠标中键：平移工具(Track Tool)</li>
<li><code>alt</code> + 鼠标左键：翻滚工具(Tumble Tool)</li>
</ul></li>
</ul>
<h2 id="着色模式">着色模式</h2>
<ul>
<li>线框、平滑着色</li>
</ul>
<p><img src="/2022/03/10/software/maya/01/image-20220310125612523.png"></p>
<h2 id="分组对象">分组对象</h2>
<ul>
<li>按住 <code>shift</code> ，左键选择需要合并成一组的物体</li>
<li>编辑 <code>-&gt;</code> 分组</li>
</ul>
<h2 id="hypergraph">Hypergraph</h2>
<ul>
<li>显示层次结构</li>
</ul>
<p><img src="/2022/03/10/software/maya/01/image-20220310130525833.png"></p>
<p><img src="/2022/03/10/software/maya/01/image-20220310130642463.png"></p>
<ul>
<li>面板 <code>-&gt;</code> 布局
<ul>
<li>可以控制面板的布局</li>
</ul></li>
</ul>
<h2 id="选择模式和遮罩">选择模式和遮罩</h2>
<p><img src="/2022/03/10/software/maya/01/comp_SelectMasks1.png"></p>
<ul>
<li>例子
<ul>
<li>按层级和组合选择 + 按层次选择：根
<ul>
<li>选中一个物体的时候，会选中整个层级</li>
</ul></li>
<li>按层级和组合选择 + 按层次选择：叶
<ul>
<li>选中一个物体的时候，只会选中这个物体</li>
</ul></li>
</ul></li>
</ul>
<h2 id="枢轴点">枢轴点</h2>
<ul>
<li>变换的参考点</li>
<li>例子
<ul>
<li>旋转，90度，3副本</li>
</ul></li>
</ul>
<p><img src="/2022/03/10/software/maya/01/image-20220310132516940.png"></p>
<h2 id="模板显示">模板显示</h2>
<ul>
<li>当您的场景变得复杂时，通过为场景中某些对象的显示设置模板，可以更加轻松地仅选择所需的对象</li>
<li>在为对象显示设置模板时，其线框变为灰色。这些对象仍然可见，但不容易选择它们</li>
<li>这有助于防止您意外选择或修改它</li>
<li>方法
<ul>
<li>选中需要设置为模板的物体</li>
</ul></li>
</ul>
<p><img src="/2022/03/10/software/maya/01/image-20220310133333392.png"></p>
<ul>
<li>取消模板显示
<ul>
<li>按层次和组合选择</li>
<li>按层次选择：模板</li>
</ul></li>
</ul>
<h2 id="组件">组件</h2>
<ul>
<li>选择模式：按组件类型选择</li>
<li>右键</li>
</ul>
<p><img src="/2022/03/10/software/maya/01/image-20220310133923965.png"></p>
<h2 id="属性编辑器">属性编辑器</h2>
<p><img src="/2022/03/10/software/maya/01/image-20220310135216067.png"></p>
<h2 id="表面材质">表面材质</h2>
<ul>
<li>菜单选中为<strong>渲染</strong></li>
<li>选中对象</li>
<li>照明/着色 <code>-&gt;</code> 指定新材质</li>
</ul>
<p><img src="/2022/03/10/software/maya/01/image-20220310144315980.png"></p>
<p><img src="/2022/03/10/software/maya/01/image-20220310144747305.png"></p>
<ul>
<li>此时属性管理器中会出现 <code>blinn1</code></li>
</ul>
<p><img src="/2022/03/10/software/maya/01/image-20220310145102939.png"></p>
<h2 id="导出为-obj">导出为 OBJ</h2>
<ul>
<li>文件 <code>-&gt;</code> 导出全部</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Warning: skipping Nurbs Surface.</span><br></pre></td></tr></table></figure>
<ul>
<li>此时 Nurbs 表面无法导出</li>
<li>需要先将 <strong>Nurbs
基本体</strong>转化为<strong>多边形基本体</strong></li>
</ul>
<p><img src="/2022/03/10/software/maya/01/image-20220310150926609.png"></p>
<ul>
<li>会有瑕疵，不如一开始就使用多边形基本体</li>
</ul>
<p><img src="/2022/03/10/software/maya/01/image-20220310151445053.png"></p>
<ul>
<li>左边为 maya 预览效果，右边为 win10 自带的查看器</li>
</ul>
<p><img src="/2022/03/10/software/maya/01/image-20220310151558552.png"></p>
]]></content>
      <categories>
        <category>software.Maya</category>
      </categories>
      <tags>
        <tag>Maya</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 hexo 实现静态托管网页</title>
    <url>/2021/01/25/installation/website/static-website/</url>
    <content><![CDATA[<h1 id="静态托管网页搭建">静态托管网页搭建</h1>
<h2 id="一些说明">0. 一些说明</h2>
<ul>
<li>基于 Hexo 进行搭建
<ul>
<li>https://hexo.io/zh-cn/</li>
</ul></li>
<li>需要的组件
<ul>
<li><code>Git</code></li>
<li><code>node.js</code></li>
</ul></li>
<li>我的版本信息</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">部件</th>
<th style="text-align: center;">版本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">node.js</td>
<td style="text-align: center;">v16.18.0</td>
</tr>
<tr class="even">
<td style="text-align: center;">npm</td>
<td style="text-align: center;">8.19.2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Git</td>
<td style="text-align: center;">git version 2.38.1.windows.1</td>
</tr>
</tbody>
</table>
<h2 id="安装-hexo">1. 安装 Hexo</h2>
<ul>
<li>建议全局安装 <code>hexo</code>
<ul>
<li>其他的插件只需要安装在局部即可</li>
</ul></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<ul>
<li>如果下载不下来的话可以换源</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仅本次安装换源</span></span><br><span class="line">npm --registry https://registry.npm.taobao.org install hexo-cli -g</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久换源</span></span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<ul>
<li>需要将 hexo 所在的目录添加到环境变量
<ul>
<li>安装 npm 的时候应该会自动进行这一步</li>
</ul></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有配置信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm config <span class="built_in">ls</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 bin 目录</span></span><br><span class="line">npm config get prefix</span><br></pre></td></tr></table></figure>
<h2 id="开始我们的快乐">2. 开始我们的快乐</h2>
<ul>
<li>如果命令太慢的话可以直接对 npm 换源</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久换源</span></span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<ul>
<li>新建一个空白文件夹
<ul>
<li>之后的命令行操作均在该文件夹目录下进行</li>
</ul></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<ul>
<li>生成页面</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<ul>
<li>预览页面</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<ul>
<li>指定端口打开预览</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s -p 5000</span><br></pre></td></tr></table></figure>
<h2 id="部署-hexo-到-github-pages">3. 部署 Hexo 到 GitHub Pages</h2>
<ul>
<li>安装 <code>hexo-deployer-git</code>
<ul>
<li>这里是安装在局部</li>
</ul></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm install hexo-deployer-git</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>--save</code>
<ul>
<li><code>npm 5.0.0</code> 之前，有 <code>--save</code>
参数才会把模块写入到 <code>packages.json</code></li>
<li>现在不需要写了</li>
</ul></li>
<li>修改配置文件 <code>_config.yml</code> 的 <code>Deployment</code>
部分</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment"># Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:banbao991/banbao991.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将 "banbao991" 修改为你自己的用户名即可</li>
<li>上传</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<ul>
<li>没有权限上传
<ul>
<li>需要有 repo 的访问权限</li>
<li>需要配置本地 <code>git</code> 的 <code>ssh key</code>
<ul>
<li><a href="https://github.com/banbao990/Use/blob/master/md/Github.md">配置方法</a></li>
<li>这里配置好了之后，repo 之后可以使用 <code>git</code> 而不是
<code>http</code> 下载，不易被墙</li>
</ul></li>
</ul></li>
</ul>
<h2 id="其他">4. 其他</h2>
<h3 id="新建文件">4.1 新建文件</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new &quot;New.File&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后进入文件夹 <code>source/_posts</code> 编辑即可</li>
</ul>
<h3 id="修改主题">4.2 修改主题</h3>
<ul>
<li>例如 <code>NexT</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:next-theme/hexo-theme-next.git themes/nexT</span><br></pre></td></tr></table></figure>
<ul>
<li>修改配置文件 <code>_config.yml</code> 的 <code>Extensions</code>
部分</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">nexT</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>支持 <code>Latex</code></p>
<ul>
<li>修改 <code>nexT</code> 的主题的配置文件
<code>_config.yml</code></li>
</ul>
<p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Default (false) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to true, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>然后在需要进行渲染的 <code>markdown</code> 文件开头加上
<code>mathjax: true</code></li>
</ul></li>
</ul>
<h3 id="next-主题细节">4.3 nexT 主题细节</h3>
<h4 id="网页配置文件">(1) 网页配置文件</h4>
<ul>
<li><code>_config.yml</code></li>
</ul>
<h5 id="主题">[1] 主题</h5>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment"># scheme: Mist</span></span><br><span class="line"><span class="comment"># scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>
<h4 id="next-主题配置文件">(2) nexT 主题配置文件</h4>
<ul>
<li><code>themes/nexT/_config.yml</code></li>
</ul>
<h5 id="菜单">[1] 菜单</h5>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 格式: 目录 || 图标</span></span><br><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="comment"># about: /about/ || fa fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment"># sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment"># commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>
<h5 id="目录">[2] 目录</h5>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="comment"># 给标题添加标号</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h5 id="头像">[3] 头像</h5>
<ul>
<li>头像</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.jpg</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>顶部 icon</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.jpg</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.jpg</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.jpg</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment"># android_manifest: /manifest.json</span></span><br></pre></td></tr></table></figure>
<ul>
<li>每次执行 <code>hexo clean</code> 之后重新执行 <code>hexo g</code>
生成文件时会把这些图片文件删除</li>
<li>解决方案如下
<ul>
<li>将这些图片放置到 <code>themes/nexT/source/images</code>
文件夹下，这样便可以通过 <code>hexo g</code> 生成</li>
</ul></li>
</ul>
<h5 id="访问次数">[4] 访问次数</h5>
<ul>
<li>出现数字不对是本地的问题，在线就没事</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">far</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>
<h5 id="暗色系">[5] 暗色系</h5>
<ul>
<li>darkmode</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dark Mode</span></span><br><span class="line"><span class="attr">darkmode:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h5 id="点击图片放大">[6] 点击图片放大</h5>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h5 id="阅读进度条">[7] 阅读进度条</h5>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Available values: left | right</span></span><br><span class="line">  <span class="attr">start_at:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment"># Available values: top | bottom</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span></span><br><span class="line">  <span class="attr">reversed:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#37c6c0&quot;</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">3px</span></span><br></pre></td></tr></table></figure>
<h5 id="github_banner">[8] github_banner</h5>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/banbao990</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br></pre></td></tr></table></figure>
<h4 id="其他细节">(3) 其他细节</h4>
<h5 id="修改-p-的-margin">修改 p 的 margin</h5>
<ul>
<li>文件：<code>themes\nexT\source\css\_common\scaffolding\base.styl</code></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="mathjax-显示不完全"><strong>mathjax</strong> 显示不完全</h5>
<ul>
<li>打开文件
<code>\themes\nexT\source\css\_common\components\third-party\math.styl</code></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">mjx-container<span class="selector-attr">[jax=<span class="string">&quot;CHTML&quot;</span>]</span><span class="selector-attr">[display=<span class="string">&quot;true&quot;</span>]</span>, <span class="selector-class">.has-jax</span> &#123;</span><br><span class="line">  <span class="comment">/* overflow: auto hidden; */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mjx-container<span class="selector-attr">[display=<span class="string">&quot;true&quot;</span>]</span> + br &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="latex-换行问题">latex 换行问题</h5>
<ul>
<li>需要在 latex 中书写 <code>\\\\</code> 才表示
<strong>换行</strong></li>
<li>换个渲染引擎</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked</span><br><span class="line">npm install hexo-renderer-pandoc</span><br></pre></td></tr></table></figure>
<ul>
<li>发现渲染的时候还是会报错，奇奇怪怪的错误
<ul>
<li>windows 安装一个 <code>pandoc</code> 即可</li>
<li><a href="https://github.com/jgm/pandoc/releases/">下载链接</a></li>
</ul></li>
</ul>
<h3 id="添加分类模块">4.4 添加分类模块</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<ul>
<li>此时会在 <code>source/tags</code> 文件夹下生成一个
<code>index.md</code> 文件</li>
<li>打开这个文件，顶部加上一句</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>按照 <code>(2)-&gt;[1]</code> 设置显示 <code>tags</code>
标签即可</li>
<li>添加 <code>categories</code> 模块</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">type: &quot;categories&quot;</span><br></pre></td></tr></table></figure>
<h3 id="插入图片">4.5 插入图片</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image</span><br></pre></td></tr></table></figure>
<ul>
<li>根目录的配置文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>之后新建 md
文件的时候便会同时新建一个为同名文件夹，用于保存引用的图片</li>
<li>但是存在一个问题，<strong>图片路径不一致</strong></li>
<li>解决方案如下</li>
<li>打开文件 <code>node_modules/hexo-asset-image/index.js</code></li>
<li>修改如下</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="regexp">/.*\/index\.html$/</span>.<span class="title function_">test</span>(link)) &#123;</span><br><span class="line">    appendLink = <span class="string">&#x27;index/&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> endPos = link.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> endPos = link.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="regexp">/.*\/index\.html$/</span>.<span class="title function_">test</span>(link)) &#123;</span><br><span class="line">    appendLink = <span class="string">&#x27;index/&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> endPos = link.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> endPos = link.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="github-挂载和本地不一致">4.6 github 挂载和本地不一致</h3>
<ul>
<li><code>css/js</code> 等问题</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
<ul>
<li>注意头像文件等的保存</li>
</ul>
<h3 id="将文件的路径转变为数字">4.7 将文件的路径转变为数字</h3>
<ul>
<li>方便引用</li>
<li>https://github.com/Rozbo/hexo-abbrlink</li>
<li>安装插件 <code>hexo-abbrlink</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<ul>
<li>不使用，有点乱</li>
</ul>
<h3 id="配置-mermaid">4.8 配置 mermaid</h3>
<ul>
<li>下载安装插件 <code>hexo-filter-mermaid-diagrams</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure>
<ul>
<li>修改配置文件 <code>_config.yml</code>（根目录下的文件）
<ul>
<li>在最后添加（因为我的部分没有 <code>mermaid</code> 部分）</li>
</ul></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mermaid chart</span></span><br><span class="line"><span class="attr">mermaid:</span> <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># default true</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">&quot;7.1.2&quot;</span> <span class="comment"># default v7.1.2</span></span><br><span class="line">  <span class="attr">options:</span>  <span class="comment"># find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span></span><br><span class="line">    <span class="comment">#startOnload: true  // default true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改配置文件 <code>_config.yml</code>（主题目录下的文件）
<ul>
<li><code>themes/nexT/_config.yml</code></li>
<li>将 <code>mermaid</code> 模块下的 <code>enable</code> 修改为
<code>true</code></li>
</ul></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mermaid tag</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 从 false 修改为 true</span></span><br><span class="line">  <span class="comment"># Available themes: default | dark | forest | neutral</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">forest</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改 js 文件
<ul>
<li><code>themes/nexT/layout/_partials/footer.njk</code></li>
<li>在文件最后添加如下代码</li>
</ul></li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&#123;% if (theme.mermaid.enable)  %&#125;</span><br><span class="line">  &lt;script src=&#x27;https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    if (window.mermaid) &#123;</span><br><span class="line">      mermaid.initialize(&#123;theme: &#x27;forest&#x27;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="搜索功能">4.9 搜索功能</h3>
<ul>
<li>安装插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<ul>
<li>在全局配置文件 <code>_config.yml</code> 中增加如下项</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改主题文件的配置，我使用的是 <code>nexT</code></li>
<li><code>hexo</code> 主题配置文件
<code>\themes\nexT\config.yml</code>，修改 <code>local_search</code>
的<code>enable</code> 为 <code>true</code></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="某个文件夹下的-html-文件不渲染">4.10 某个文件夹下的 html
文件不渲染</h3>
<ul>
<li>根目录下的 <code>_config.yml</code> 文件，修改内容</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">utils/**/*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">resources/**/*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">libs/**/*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">kits/**/*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">use/**/*</span></span><br></pre></td></tr></table></figure>
<h3 id="忽略某些文件夹下文件">4.11 忽略某些文件夹下文件</h3>
<ul>
<li>根目录下的 <code>_config.yml</code> 文件，修改内容</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">exclude:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">kits/**/*.class</span></span><br></pre></td></tr></table></figure>
<h3 id="lf-替换为-crlf-刷屏">4.12 LF 替换为 CRLF 刷屏</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">warning: LF will be replaced by CRLF in page/3/index.html.</span><br><span class="line">The file will have its original line endings in your working directory</span><br></pre></td></tr></table></figure>
<ul>
<li>以上信息刷屏</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">5. 参考资料</h2>
<ul>
<li>https://zhuanlan.zhihu.com/p/60578464</li>
<li>https://hexo.io/zh-cn/docs/</li>
<li>https://www.cnblogs.com/thanksblog/p/12900165.html</li>
<li>http://theme-next.iissnan.com/getting-started.html</li>
<li>https://www.jianshu.com/p/3a05351a37dc</li>
<li>https://tyloafer.github.io/posts/7790/</li>
<li><a href="https://huangweicai.github.io/2019/01/12/Hexo%E5%A2%9E%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/">搜索功能</a></li>
<li><a href="https://gaomf.cn/2017/01/13/Hexo_Git_CRLF/">Hexo
Git部署警告"warning： LF will be replaced by CRLF"的去除方法</a></li>
</ul>
]]></content>
      <categories>
        <category>Kits</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>website</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode 添加预定义宏</title>
    <url>/2022/03/01/software/vscode/01/</url>
    <content><![CDATA[<h1 id="vscode-添加预定义宏">vscode 添加预定义宏</h1>
<h2 id="问题描述">问题描述</h2>
<ul>
<li><a href="https://blog.csdn.net/YxiaoqiR/article/details/113175871">参考</a></li>
<li>在使用 vscode
进行工程代码编辑的时候，有些宏是在<strong>编译</strong>的时候定义的，此时
vscode 无法识别，会报错，造成编写代码的时候的不便</li>
</ul>
<p><img src="/2022/03/01/software/vscode/01/image-20220301133933353.png"></p>
<ul>
<li>定义的地方</li>
</ul>
<p><img src="/2022/03/01/software/vscode/01/image-20220301134023695.png"></p>
<ul>
<li>使用上面的方法则显得很麻烦，每次编译都需要将其注释掉</li>
<li>解决方案是在 vscode 中添加预定义宏</li>
</ul>
<h2 id="添加预定义宏">添加预定义宏</h2>
<ul>
<li><code>ctrl+shift+p</code> 设置，找到当前工程的配置文件</li>
</ul>
<p><img src="/2022/03/01/software/vscode/01/image-20220301134233400.png"></p>
<ul>
<li>在 <code>defines</code> 项中添加即可</li>
</ul>
<p><img src="/2022/03/01/software/vscode/01/image-20220301134430748.png"></p>
<ul>
<li>效果如下</li>
</ul>
<p><img src="/2022/03/01/software/vscode/01/image-20220301134503547.png"></p>
]]></content>
      <categories>
        <category>software.vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode 插件</title>
    <url>/2022/03/30/software/vscode/02/</url>
    <content><![CDATA[<h1 id="vscode-插件">vscode 插件</h1>
<h2 id="代码格式化">1. 代码格式化</h2>
<h3 id="批量格式化代码">(1) 批量格式化代码</h3>
<ul>
<li><code>Format Files</code></li>
</ul>
<p><img src="/2022/03/30/software/vscode/02/image-20220330145503837.png"></p>
<ul>
<li>安装后右键选中文件夹</li>
</ul>
<p><img src="/2022/03/30/software/vscode/02/image-20220330145620181.png"></p>
<ul>
<li><code>Do it!</code></li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://blog.csdn.net/koukouwuwu/article/details/111879677">vscode批量格式化代码</a></li>
</ul>
<h2 id="画图">2. 画图</h2>
<h3 id="drawio">(1) drawio</h3>
<p><img src="/2022/03/30/software/vscode/02/drawio.png"></p>
<ul>
<li>能够画关系图</li>
</ul>
<p><img src="/2022/03/30/software/vscode/02/KQ.svg"></p>
]]></content>
      <categories>
        <category>software.vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>右键通过 VSCode 打开</title>
    <url>/2022/10/22/software/vscode/03/</url>
    <content><![CDATA[<h1 id="右键通过-vscode-打开">右键通过 VSCode 打开</h1>
<ul>
<li>右键添加<strong>通过 Code 打开</strong>功能</li>
</ul>
<p><img src="/2022/10/22/software/vscode/03/ex.png"></p>
<ul>
<li>最方便的方法就是重新安装一遍
<ul>
<li>注意<span style="color:red"><strong>不需要</strong></span>卸载重装，只需要重装（相当于修复）</li>
</ul></li>
</ul>
<p><img src="/2022/10/22/software/vscode/03/open-with-vscode.png"></p>
]]></content>
      <categories>
        <category>software.vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>(论文)[1997] Metropolis Light Transport</title>
    <url>/2021/07/08/CG/Papers/1997/MLT/</url>
    <content><![CDATA[<ul>
<li>VEACH E., GUIBAS L. J.: Metropolis light transport. In Annual
Conference Series (Proceedings of SIGGRAPH) (Aug. 1997), vol. 31, ACM
Press, pp. 65–76. <a href="https://dl.acm.org/doi/10.1145/258734.258775">doi:10/bkjqj4</a>.</li>
</ul>
<p><span style="color:red;font-weight:bold">TODO
找时间得继续看看</span></p>
<h1 id="metropolis-light-transport">Metropolis Light Transport</h1>
<h2 id="abstract">Abstract</h2>
<ul>
<li>We present a new Monte Carlo method for solving the <strong>light
transport</strong> problem, inspired by the <strong>Metropolis sampling
method</strong> in computational physics.</li>
<li>MLT 是无偏的
<ul>
<li>Our algorithm is <strong>unbiased</strong>, handles general
geometric and scattering models, uses little storage, and can be orders
of magnitude more efficient than previous unbiased approaches.</li>
</ul></li>
<li>优点
<ul>
<li>在复杂场景中表现很好
<ul>
<li>bright indirect light</li>
<li>small geometric holes</li>
<li>glossy surfaces.</li>
</ul></li>
<li>简单场景中和之前的方法相比也不错</li>
</ul></li>
<li>The key advantage of the Metropolis approach is that the
<strong>path space is explored locally</strong>, by <strong>favoring
mutations</strong> that make small changes to the current path
<ul>
<li>First, the <strong>average cost per sample is small</strong>
(typically only one or two rays).</li>
<li>Second, once an important path is found, <strong>the nearby paths
are explored as well</strong>, thus amortizing the expense of finding
such paths over many samples.</li>
<li>Third, <strong>the mutation set is easily extended</strong>. By
constructing mutations that preserve certain properties of the path
(e.g. which light source is used) while changing others, we can exploit
various kinds of coherence in the scene. <strong>It is often possible to
handle difficult lighting problems efficiently by designing a
specialized mutation in this way.</strong></li>
</ul></li>
</ul>
<h2 id="introduction">1 Introduction</h2>
<ul>
<li>current methods are optimized for a <strong>fairly narrow
class</strong> of input scenes.</li>
<li>Monte Carlo methods
<ul>
<li>generality and simplicity.</li>
<li>unbiased
<ul>
<li>For these algorithms, <strong>any error in the solution</strong> is
guaranteed to show up as <strong>random variations</strong> among the
samples (e.g., as image noise).</li>
</ul></li>
</ul></li>
<li>有偏算法带来的问题
<ul>
<li>Biased algorithms may produce results that are not noisy, but are
nevertheless <strong>incorrect.</strong></li>
<li>This error is often noticeable visually, in the form of
<strong>discontinuities</strong>, <strong>excessive blurring</strong>,
or <strong>objectionable surface shading</strong>.</li>
</ul></li>
<li>Monte Carlo 算法的问题
<ul>
<li>The problem is that for some environments, <strong>most paths do not
contribute significantly to the image</strong>, e.g. because they
<strong>strike surfaces with low reflectivity</strong>, or <strong>go
through solid objects</strong>.</li>
<li>出问题的场景
<ul>
<li>For example, imagine a brightly lit room next to a dark room
containing the camera, with a door slightly ajar between them.
<ul>
<li>两个房间，光源在一个房间中，相机在另一个房间中，两个房间之间有一扇半开的门</li>
</ul></li>
</ul></li>
<li>对如下现象都不太支持
<ul>
<li>glossy surfaces, caustics, strong indirect lighting</li>
</ul></li>
</ul></li>
<li>Several techniques have been proposed to sample these difficult
paths more efficiently.
<ul>
<li><strong>bidirectional path tracing</strong> (BDPT)</li>
<li>Another idea is to <strong>build an approximate representation of
the radiance in a scene</strong>, which is then used to <strong>modify
the directional sampling</strong> of the basic path tracing algorithm.
<ul>
<li>一些问题</li>
<li>inadequate directional resolution to handle concentrated indirect
lighting</li>
<li>substantial(大量) space requirements.</li>
</ul></li>
</ul></li>
<li>MLT
<ul>
<li>The algorithm samples paths according to the
<strong>contribution</strong> they make to the ideal image, by means of
a random walk through path space.</li>
</ul></li>
</ul>
<h2 id="overview-of-the-mlt-algorithm">2 Overview of the MLT
algorithm</h2>
<p><img src="/2021/07/08/CG/Papers/1997/MLT/image-20210711121721776.png" style="zoom: 80%;"></p>
<ul>
<li>sample the paths <strong>from the light sources to the
lens</strong></li>
<li>path <span class="math inline">\(\bar{x}=\mathrm{x}_0\mathrm{x}_1\cdots\mathrm{x}_k\)</span>
<ul>
<li><span class="math inline">\(\mathrm{x}_0\)</span> 是光源</li>
<li>长度 <span class="math inline">\(k\ge1\)</span></li>
</ul></li>
<li><strong>power (flux)</strong> that flows from the light sources to
the image plane along a set of paths <span class="math inline">\(D\)</span>.</li>
</ul>
<p><span class="math display">\[
\int_{D}f(\bar{x})\;d\mu(\mathrm{x})
\]</span></p>
<ul>
<li><span class="math inline">\(f\)</span>：<strong>image contribution
function</strong></li>
<li>Our overall strategy is to <strong>sample paths with probability
proportional</strong> to <span class="math inline">\(f\)</span>, and
r<strong>ecord the distribution of paths</strong> over the image
plane</li>
<li>We generate a sequence of paths <span class="math inline">\(\bar{X}_0,\bar{X}_1,\cdots,\bar{X}_N\)</span>,
where each <span class="math inline">\(\bar{X}_i\)</span> is obtained by
a <strong>random mutation</strong> to the path <span class="math inline">\(\bar{X}_{i-1}\)</span></li>
<li>The mutations can have almost any desired form
<ul>
<li><strong>adding</strong>, <strong>deleting</strong>, or
<strong>replacing</strong> a small number of vertices on the current
path</li>
</ul></li>
<li><strong>each mutation has a chance of being rejected</strong>,
depending on the relative contributions of the old and new paths.</li>
<li><strong>As each path is sampled, we update the current
image</strong></li>
<li>算法如下</li>
</ul>
<p><img src="/2021/07/08/CG/Papers/1997/MLT/image-20210711122845982.png" style="zoom:80%;"></p>
<h2 id="the-metropolis-sampling-algorithm">3 The Metropolis sampling
algorithm</h2>
<ul>
<li><p>In 1953, Metropolis, Rosenbluth, Rosenbluth, Teller, and Teller
introduced an algorithm for <strong>handling difficult sampling
problems</strong> in computational physics</p></li>
<li><p>前提</p>
<ul>
<li>We are given a <strong>state space</strong> <span class="math inline">\(\Omega\)</span>, and a <strong>non-negative
function</strong> <span class="math inline">\(f:\Omega\to
\mathbb{R}^+\)</span>.</li>
<li>We are also given some <strong>initial state</strong> <span class="math inline">\(\bar{X}_0\in\Omega\)</span></li>
</ul></li>
<li><p>目标</p>
<ul>
<li>generate a random walk <span class="math inline">\(\bar{X}_0,\bar{X}_1,\cdots,\bar{X}_N\)</span> such
that <span class="math inline">\(\bar{X}_i\)</span> is eventually
distributed proportionally to <span class="math inline">\(f\)</span>, no
matter which state <span class="math inline">\(\bar{X}_0\)</span> we
start with.</li>
</ul></li>
<li><p><strong>the Metropolis algorithm does not require that <span class="math inline">\(f\)</span> integrate to one</strong>.</p></li>
<li><p>Each sample <span class="math inline">\(\bar{X}_i\)</span> is
obtained by making a <strong>random change</strong> to <span class="math inline">\(\bar{X}_{i−1}\)</span></p>
<ul>
<li>in our case, these are the <strong>path mutations</strong></li>
</ul></li>
<li><p>马尔科夫链</p>
<ul>
<li>This type of random walk, where <span class="math inline">\(\bar{X}_i\)</span> depends only on <span class="math inline">\(X_{i−1}\)</span>, is called a <strong>Markov
chain</strong>.</li>
</ul></li>
<li><p>We let <span class="math inline">\(K(\bar{y}|\bar{x})\)</span>
denote the probability density of going to state <span class="math inline">\(\bar{y}\)</span>, given that we are currently in
state <span class="math inline">\(\bar{x}\)</span>.</p>
<ul>
<li><strong>transition function</strong></li>
<li>satisfies the condition</li>
</ul></li>
</ul>
<p><span class="math display">\[
\int_{\Omega}K(\bar{y}|\bar{x})\;d\mu(\bar{y})=1,\forall\bar{x}\in\Omega
\]</span></p>
<h3 id="the-stationary-distribution">The stationary distribution</h3>
<ul>
<li>平稳分布（状态不变）</li>
<li>Each <span class="math inline">\(\bar{X}_i\)</span> is a random
variable with some distribution <span class="math inline">\(p_i\)</span>, which is determined from <span class="math inline">\(p_{i−1}\)</span> by the equation (1) With mild
conditions on <span class="math inline">\(K\)</span></li>
</ul>
<p><span class="math display">\[
p_{i}(\bar{x})=\int_{G}K(\bar{x}|\bar{y})\;p_{i}(\bar{y})\;d\mu(\bar{y})\qquad(1)
\]</span></p>
<ul>
<li>the <span class="math inline">\(p_i\)</span> will converge to a
unique distribution <span class="math inline">\(p\)</span>, called the
<strong>stationary distribution</strong></li>
<li><strong>Note that p does not depend on the initial state <span class="math inline">\(\bar{X}_0\)</span></strong></li>
</ul>
<h3 id="detailed-balance">Detailed balance</h3>
<ul>
<li>细致平衡</li>
<li>在实际的物理系统中，<span class="math inline">\(K\)</span>
是由物理约束决定的，给定初始状态便会变化到平稳分布</li>
<li><strong>The Metropolis algorithm works in the opposite
direction.</strong>
<ul>
<li>The idea is to <strong>invent or construct a transition function
<span class="math inline">\(K\)</span></strong> whose resulting
stationary distribution will be proportional to the given <span class="math inline">\(f\)</span>, and which will converge to <span class="math inline">\(f\)</span> as quickly as possible.</li>
<li>找到转移函数 <span class="math inline">\(K\)</span>
，希望他能够快速收敛到 <span class="math inline">\(f\)</span></li>
</ul></li>
<li>The technique is simple, and has an intuitive physical
interpretation called <strong>detailed balance</strong>.</li>
<li>Given <span class="math inline">\(\bar{X}_{i-1}\)</span>, we obtain
<span class="math inline">\(\bar{X}_i\)</span> as follows.</li>
<li>First, we choose a tentative（试探性的） sample <span class="math inline">\(X_i&#39;\)</span></li>
<li>This is represented by the <strong>tentative transition
function</strong> <span class="math inline">\(T\)</span></li>
<li>where <span class="math inline">\(T(\bar{y}|\bar{x})\)</span> gives
the probability density that <span class="math inline">\(X_i&#39;=\bar{y}\)</span> given that <span class="math inline">\(X_i&#39;=\bar{x}\)</span></li>
<li>The tentative sample is then either accepted or rejected, according
to an acceptance probability <span class="math inline">\(a(\bar{y}|\bar{x})\)</span> which will be defined
below</li>
</ul>
<p><span class="math display">\[
X_i=
\begin{cases}
X_i&#39;    \qquad
\mathrm{with\;probability\;a(\overline{X}_i&#39;|\overline{X}_{i-1}})\\
X_{i=1} \quad \mathrm{otherwise}
\end{cases}
\]</span></p>
<ul>
<li>To see how to set <span class="math inline">\(a(\bar{y}|\bar{x})\)</span>, <strong>suppose that
we have already reached equilibrium</strong>, i.e. <span class="math inline">\(p_{i−1}\)</span> is proportional to <span class="math inline">\(f\)</span>.</li>
<li>From <span class="math inline">\(\bar{x}\)</span> to <span class="math inline">\(\bar{y}\)</span>, the transition density is
proportional to <span class="math inline">\(f(\bar{x})\;T(\bar{y}|\bar{x})\;a(\bar{y}|\bar{x})\)</span>,
and a similar statement holds for the transition density from <span class="math inline">\(\bar{y}\)</span> to <span class="math inline">\(\bar{x}\)</span>.</li>
<li><span id="eq3">细致平衡条件</span></li>
</ul>
<p><span class="math display">\[
f(\bar{x})\;T(\bar{y}|\bar{x})\;a(\bar{y}|\bar{x})=f(\bar{y})\;T(\bar{x}|\bar{y})\;a(\bar{x}|\bar{y}),\qquad
(3)
\]</span></p>
<ul>
<li><span id="eq4">细致平衡条件是平稳分布的充分条件</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
p_{i}(\bar{x})=&amp;\Big[1-\int_{\Omega}f(\bar{x})\;T(\bar{y}|\bar{x})\;a(\bar{y}|\bar{x})\;d\mu(\bar{y})\Big]p_{i-1}(\bar{x})\qquad(4)\\
&amp;+\int_{\Omega}f(\bar{x})\;p_{i-1}(\bar{y})T(\bar{x}|\bar{y})\;a(\bar{x}|\bar{y})\;d\mu(\bar{y})\\
&amp;=p_{i-1}(\bar{x})\\
\end{aligned}
\]</span></p>
<h3 id="the-acceptance-probability">The acceptance probability</h3>
<ul>
<li><p>接受概率</p></li>
<li><p>Recall that <span class="math inline">\(f\)</span> is given, and
<span class="math inline">\(T\)</span> was chosen arbitrarily. Thus,
equation <a href="#eq3">(3)</a> is a condition on the ratio <span class="math inline">\(a(\bar{y}|\bar{x})/a(\bar{x}|\bar{y})\)</span>.</p></li>
<li><p>In order to reach equilibrium as quickly as possible, the best
strategy is to make <span class="math inline">\(a(\bar{x}|\bar{y})\)</span> and <span class="math inline">\(a(\bar{y}|\bar{x})\)</span> <strong>as large as
possible</strong></p></li>
</ul>
<p><span class="math display">\[
a(\bar{y}|\bar{x})=\min\Big\{1,\dfrac{f(\bar{y})T(\bar{x}|\bar{y})}{f(\bar{x})T(\bar{y}|\bar{x})}\Big\}
\]</span></p>
<ul>
<li>According to this rule, transitions <strong>in one direction are
always accepted</strong>, while <strong>in the other direction they are
sometimes</strong> <strong>rejected</strong>, such that the expected
number of moves each way is the same.</li>
</ul>
<h3 id="comparison-with-genetic-algorithms">Comparison with genetic
algorithms</h3>
<ul>
<li>different purposes
<ul>
<li>genetic algorithms solve optimization problems</li>
<li>while the Metropolis method solves sampling problems</li>
</ul></li>
<li>Genetic algorithms work with <strong>a population of
individuals</strong>, while Metropolis <strong>stores only a single
current state</strong>.</li>
<li>Finally, genetic algorithms have much more freedom in choosing the
allowable mutations, since they do not need to compute the conditional
probability of their actions</li>
</ul>
<h2 id="the-path-integral-formulation-of-light-transport">4 The path
integral formulation of light transport</h2>
<ul>
<li>Often the light transport problem is written as an integral
equation, where we must solve for the equilibrium radiance function
L.</li>
<li>However, it can also be written as a <strong>pure integration
problem</strong>, <strong>over the domain of all transport
paths</strong>.
<ul>
<li><strong>The MLT algorithm is based on this
formulation.</strong></li>
</ul></li>
</ul>
<h3 id="the-light-transport-equation">The light transport equation</h3>
<ul>
<li>We assume a geometric optics model where light is emitted,
scattered, and absorbed only <strong>at surfaces</strong>, travels in
straight lines between surfaces, and is perfectly incoherent.</li>
<li><strong>light transport equation</strong>
<ul>
<li><span class="math inline">\(\mathcal{M}\)</span> is the union of all
scene surfaces</li>
<li><span class="math inline">\(A\)</span> is the area measure on <span class="math inline">\(\mathcal{M}\)</span></li>
<li>The function <span class="math inline">\(G\)</span> represents the
throughput of a differential beam between <span class="math inline">\(dA(\mathrm{x})\)</span> and <span class="math inline">\(dA(\mathrm{x&#39;})\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
L(\mathrm{x&#39;}\to\mathrm{x&#39;&#39;})=L_e(\mathrm{x&#39;}\to\mathrm{x&#39;&#39;})+\int_{\mathcal{M}}L(\mathrm{x}\to\mathrm{x&#39;})f_s(\mathrm{x}\to\mathrm{x&#39;}\to\mathrm{x&#39;&#39;}){\color{red}G(\mathrm{x}\leftrightarrow\mathrm{x&#39;})}\;dA(\mathrm{x})
\]</span></p>
<ul>
<li><span class="math inline">\(G\)</span> 如下
<ul>
<li>where <span class="math inline">\(\cos\theta_o\)</span> and <span class="math inline">\(\cos\theta_i&#39;\)</span> represent the angles
between the segment <span class="math inline">\(\mathrm{x}\leftrightarrow\mathrm{x&#39;}\)</span>
and the surface normals at <span class="math inline">\(\mathrm{x}\)</span> and <span class="math inline">\(\mathrm{x_0}\)</span> respectively</li>
<li><span class="math inline">\(V\)</span> 为可见性</li>
</ul></li>
</ul>
<p><span class="math display">\[
G(\mathrm{x}\leftrightarrow\mathrm{x&#39;})=V(\mathrm{x}\leftrightarrow\mathrm{x&#39;})\dfrac{|\cos\theta_o\cos\theta_i&#39;|}{\Vert\mathrm{x}-\mathrm{x&#39;}\Vert^2}
\]</span></p>
<h3 id="the-measurement-equation">The measurement equation</h3>
<ul>
<li>We consider only algorithms that compute an image directly, so that
the measurements consist of many pixel values <span class="math inline">\(m_1,\cdots,m_M\)</span>, where <strong>M is the
number of pixels in the image</strong>.</li>
<li>Each measurement has the form</li>
</ul>
<p><span class="math display">\[
m_j=\int_{\mathcal{M}\times\mathcal{M}}W_e^{(j)}(\mathrm{x}\to\mathrm{x}&#39;)L(\mathrm{x}\to\mathrm{x}&#39;)G(\mathrm{x}\leftrightarrow\mathrm{x}&#39;)\;dA(\mathrm{x})\;dA(\mathrm{x}&#39;)
\]</span></p>
<ul>
<li>where <span class="math inline">\(W_e^{(j)}(\mathrm{x}\to\mathrm{x&#39;})\)</span>
is a weight that indicates how much the light arriving at <span class="math inline">\(\mathrm{x&#39;}\)</span> from the direction of
<span class="math inline">\(\mathrm{x}\)</span> contributes to the value
of the measurement
<ul>
<li>For real sensors, <span class="math inline">\(W_e^{(j)}(\mathrm{x}\to\mathrm{x&#39;})\)</span>
is called the <strong>flux responsivity</strong> (with units of <span class="math inline">\([W^{-1}]\)</span>), but in graphics it is more
often called an <strong>importance function</strong></li>
</ul></li>
</ul>
<h3 id="the-path-integral-formulation">The path integral
formulation</h3>
<ul>
<li>By recursively expanding the transport equation (6), we can write
measurements in the form</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
m_j=&amp;\int_{\mathcal{M}^2}L(\mathrm{x}_0\to\mathrm{x}_1)G(\mathrm{x}_0\leftrightarrow\mathrm{x}_1)W_e^{(j)}(\mathrm{x}_0\to\mathrm{x}_1)\;dA(\mathrm{x}_0)\;dA(\mathrm{x}_1)\\
&amp;+\int_{\mathcal{M}^3}L(\mathrm{x}_0\to\mathrm{x}_1)G(\mathrm{x}_0\leftrightarrow\mathrm{x}_1)f_s(\mathrm{x}_0\leftrightarrow\mathrm{x}_1\leftrightarrow\mathrm{x}_2)G(\mathrm{x}_1\leftrightarrow\mathrm{x}_2)W_e^{(j)}(\mathrm{x}_1\to\mathrm{x}_2)\;dA(\mathrm{x}_0)\;dA(\mathrm{x}_1)\;dA(\mathrm{x}_2)\\
&amp;\cdots\\
\end{aligned}
\]</span></p>
<ul>
<li>The goal is to write this expression in the form, so that we can
handle it as a pure integration problem.</li>
</ul>
<p><span class="math display">\[
m_j=\int_{\Omega}f_j(\bar{x})\;d\mu(\bar{x})
\]</span></p>
<ul>
<li>let <span class="math inline">\(\Omega_k\)</span> be the set of all
paths of the form <span class="math inline">\(\bar{x}=\mathrm{x}_0\mathrm{x}_1\cdots\mathrm{x}_k\)</span>,
where <span class="math inline">\(k\ge1\)</span> and <span class="math inline">\(x_i\in\mathcal{M}\)</span> for each <span class="math inline">\(i\)</span>.</li>
</ul>
<p><span class="math display">\[
d\mu_k(\mathrm{x}_0\cdots\mathrm{x}_k)=dA(\mathrm{x}_0)\cdots\;dA(\mathrm{x}_k)
\]</span></p>
<ul>
<li>we let <span class="math inline">\(\Omega\)</span> be the union of
all the <span class="math inline">\(\Omega_k\)</span> and define a
measure <span class="math inline">\(\mu\)</span> on <span class="math inline">\(\Omega_k\)</span> by
<ul>
<li>感觉可以把 <span class="math inline">\(D\)</span>
理解为路径全空间</li>
</ul></li>
</ul>
<p><span class="math display">\[
\mu(D)=\sum_{k=1}^{\infty}\mu_k(D\;\cap\Omega_k)
\]</span></p>
<ul>
<li>We call <span class="math inline">\(f_j\)</span> the
<strong>measurement contribution function</strong></li>
<li>例子</li>
</ul>
<p><span class="math display">\[
f_j(\mathrm{x}_0\mathrm{x}_1)=L_e(\mathrm{x}_0\to\mathrm{x}_1)G(\mathrm{x}_0\leftrightarrow\mathrm{x}_1)W_e^{(j)}(\mathrm{x}_0\to\mathrm{x}_1)
\]</span></p>
<p><img src="/2021/07/08/CG/Papers/1997/MLT/image-20210711121721776.png" style="zoom: 80%;"></p>
<ul>
<li>上面转化的目的
<ul>
<li>The most significant aspect is that we <strong>have removed the sum
over different path lengths</strong>, and <strong>replaced it with a
single integral over an abstract measure space of paths</strong>.</li>
</ul></li>
</ul>
<h2 id="metropolis-light-transport-1">5 Metropolis light transport</h2>
<ul>
<li>一些准备工作
<ul>
<li>First, we must formulate the light transport problem so that it fits
the Metropolis framework.</li>
<li>Second, we must show how to avoid <strong>start-up bias</strong>, a
problem which affects many Metropolis applications.</li>
<li>Most importantly, we must design a suitable set of
<strong>mutations</strong> on paths, such that the Metropolis method
will work efficiently.</li>
</ul></li>
</ul>
<h3 id="reduction-to-the-metropolis-framework">5.1 Reduction to the
Metropolis framework</h3>
<ul>
<li>Observe that each integrand <span class="math inline">\(f_j\)</span>
has the form <span class="math inline">\(f_j(\bar{x})=w_j(\bar{x})f(\bar{x})\)</span>
<ul>
<li><span class="math inline">\(w_j\)</span> represents the filter
function for pixel <span class="math inline">\(j\)</span></li>
<li><span class="math inline">\(f\)</span> represents all the other
factors of <span class="math inline">\(f_j\)</span> (which are the same
for all pixels).</li>
</ul></li>
<li>In physical terms, <span class="math inline">\(\int_Df(\bar{x})\;d\mu(\bar{x})\)</span>
represents the <strong>radiant powe</strong>r received by the image area
of the image plane along <strong>a set <span class="math inline">\(D\)</span> of paths</strong>.</li>
<li>Note that <span class="math inline">\(w_j\)</span> depends only on
the last edge <span class="math inline">\(\mathrm{x}_{k-1}\mathrm{x}_k\)</span> of the path,
which we call the <strong>lens edge</strong>.</li>
<li>An image can now be computed by sampling <span class="math inline">\(N\)</span> paths <span class="math inline">\(\mathrm{X}_i\)</span> according to some
distribution <span class="math inline">\(p\)</span>, and using the
identity</li>
</ul>
<p><span class="math display">\[
m_j=E\Big[\dfrac{1}{N}\sum_{i=1}^{N}\dfrac{w_j(\bar{X}_i)f(\bar{X}_i)}{p(\bar{X}_i)}\Big]
\]</span></p>
<ul>
<li><span style="color:red">If we could</span> let <span class="math inline">\(p=\dfrac{1}{b}f\)</span> (where <span class="math inline">\(b\)</span> is the normalization constant <span class="math inline">\(\int_\Omega f(\bar{x})\;d\mu(\bar{x})\)</span>,
the estimate for each pixel would be</li>
</ul>
<p><span class="math display">\[
m_j=E\Big[\dfrac{1}{N}\sum_{i=1}^{N}b\;w_j(\bar{X}_i)\Big]
\]</span></p>
<ul>
<li><strong>This equation can be evaluated efficiently for all pixels at
once, since each path contributes to only a few pixel
values.</strong></li>
<li>问题：This idea requires the evaluation of <span class="math inline">\(b\)</span>, and the ability to sample from a
distribution proportional to <span class="math inline">\(f\)</span>.
<ul>
<li><strong>Both of these are hard problems.</strong></li>
<li>For the <strong>second</strong> part, the Metropolis algorithm will
help
<ul>
<li>however, the samples <span class="math inline">\(\bar{X}_i\)</span>
will have the desired distribution only in the limit as <span class="math inline">\(i\to\infty\)</span></li>
<li>Metropolis 应用中丢弃前 k 个 sample，直到结果大概收敛到 equilibrium
distribution
<ul>
<li>k 的预测也是个问题</li>
<li><strong>start-up bias</strong>：如果选取的 k
太小，结果将很大程度上受到 <span class="math inline">\(\bar{X}_0\)</span> 的影响</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="eliminating-start-up-bias">Eliminating start-up bias</h4>
<ul>
<li>The idea is to start the walk in a random initial state <span class="math inline">\(\bar{X}_0\)</span>, <strong>which is sampled from
some convenient path distribution <span class="math inline">\(p_0\)</span></strong>
<ul>
<li>we use bidirectional path tracing for this purpose</li>
<li>初始路径通过其他采样方式采出</li>
</ul></li>
<li>To compensate for the fact that <span class="math inline">\(p_0\)</span> is <strong>not the desired
distribution</strong> <span class="math inline">\(\dfrac{1}{b}f\)</span>, the sample <span class="math inline">\(\bar{X}_0\)</span> is assigned a weight: <span class="math inline">\(W_0=\dfrac{f(\bar{X}_0)}{p_0(\bar{X}_0)}\)</span></li>
<li>Thus <strong>after one sample</strong>, the estimate for pixel <span class="math inline">\(j\)</span> is <span class="math inline">\(W_0w_j(\bar{X}_0)\)</span>
<ul>
<li>N=1 代入即可</li>
<li><span class="math inline">\(\bar{X}_0\)</span>
已知的条件下，这些都是可以计算的</li>
</ul></li>
<li>接下来可以根据 Metropolis algorithm 进行采样得到 <span class="math inline">\(\bar{X}_1,\cdots,\bar{X}_N\)</span>
<ul>
<li>mutating <span class="math inline">\(\bar{X}_0\)</span></li>
<li>using <span class="math inline">\(f\)</span> as the target
density</li>
</ul></li>
<li>Each of the <span class="math inline">\(\bar{X}_i\)</span> has a
different distribution <span class="math inline">\(p_i\)</span>, which
only approaches <span class="math inline">\(\dfrac{1}{b}f\)</span> as
<span class="math inline">\(i\to\infty\)</span></li>
<li>To <strong>avoid bias</strong>, however, it is sufficient to assign
these samples the same weight <span class="math inline">\(W_i=W_0\)</span> as the original sample, where the
following estimate is used for pixel <span class="math inline">\(j\)</span></li>
</ul>
<p><span class="math display">\[
m_j=E\Big[\dfrac{1}{N}\sum_{i=1}^{N}w_j(\bar{X}_i){W_i}\Big]
\]</span></p>
<ul>
<li><strong>unbiased</strong>
<ul>
<li>如果 <span class="math inline">\(p_0=\dfrac{1}{b}f,W_0=b\)</span>，那么结果一定是
equilibrium.</li>
<li>对于一般的 <span class="math inline">\(p_0\)</span>
<ul>
<li><span class="math inline">\(W_0=\dfrac{f}{p_0}\)</span> leads to
exactly the same distribution of weighta mong the starting paths, and so
we should expect that these <strong>initial conditions are unbiased as
well</strong>.</li>
</ul></li>
</ul></li>
<li>unbiased 证明如下</li>
<li>首先证明如下等式在每一步中都成立</li>
</ul>
<p><span class="math display">\[
\int_{\mathbb{R}}w\;q_i(w,\bar{x})\;dw=f(\bar{x})
\]</span></p>
<ul>
<li>where <span class="math inline">\(q_i\)</span> is the joint
probability distribution of the i-th weighted sample <span class="math inline">\((W_i,\bar{X}i)\)</span></li>
<li><span class="math inline">\(q_0\)</span> 是成立的
<ul>
<li><span class="math inline">\(q_0(w,\bar{x})=\delta(w-\dfrac{f(\bar{x})}{p_0(\bar{x})})p_0(\bar{x})\)</span>
<ul>
<li><span class="math inline">\(\delta\)</span> denotes the Dirac delta
distribution</li>
</ul></li>
<li><span class="math inline">\(W_0=\dfrac{f(\bar{X}_0)}{p_0(\bar{X}_0)}\)</span></li>
</ul></li>
<li>由上面的等式 <a href="#eq4">(4)</a>
<ul>
<li>Next, observe that (4) is still true with <span class="math inline">\(p_j\)</span> replaced by <span class="math inline">\(q_i(w,\bar{x})\)</span> (since the mutations set
<span class="math inline">\(W_i=W_{i−1}\)</span>).</li>
<li><span class="math inline">\(\int_{\mathbb{R}}w\;q_i(w,\bar{x})\;dw=\int_{\mathbb{R}}w\;q_{i-1}(w,\bar{x})\;dw\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
E\Big[w_j(\bar{X}_i){W_i}\Big]&amp;=\int_{\Omega}\int_{\mathbb{R}}w\;w_j(\bar{x})\;q_i(w,\bar{x})\;dw\;d\mu(\bar{x})\\
&amp;=\int_{\Omega}\;w_j(\bar{x})\;f(\bar{x})\;d\mu(\bar{x})\\
&amp;=m_j\\
\end{aligned}
\]</span></p>
<ul>
<li>期望计算：<span class="math inline">\(E(XY)=\iint
xyf(x,y)dxdy\)</span></li>
</ul>
<h4 id="initialization">Initialization</h4>
<ul>
<li>In practice, <strong>initializing the MLT algorithm with a single
sample does not work well</strong></li>
<li>If we generate only one path <span class="math inline">\(\bar{X}_0\)</span> (e.g. using bidirectional path
tracing), <strong>it is quite likely that <span class="math inline">\(W_0=0\)</span></strong> (e.g. the path goes
through a wall).
<ul>
<li><strong>结果为全黑</strong></li>
</ul></li>
<li><strong>The strategy we have implemented is to sample a moderately
large number of paths <span class="math inline">\(\bar{X}_0^{(1)},\cdots,\bar{X}_0^{(n)}\)</span>,
with corresponding weights <span class="math inline">\(W_0^{(1)},\cdots,W_0^{(n)}\)</span></strong></li>
<li>We then resample the <span class="math inline">\(\bar{X}_0^{(i)}\)</span> to obtain a much smaller
number <span class="math inline">\(n&#39;\)</span> of equally-weighted
paths
<ul>
<li>chosen with equal spacing in the cumulative weight distribution of
the <span class="math inline">\(\bar{X}_0^{(i)}\)</span></li>
<li>These are used as <strong>independent seeds</strong> for the
<strong>Metropolis phase</strong> of the algorithm</li>
</ul></li>
<li>The value of n is determined indirectly, by generating a fixed
number of eye and light subpaths (e.g. 10000 pairs), and considering all
the ways to link the vertices of each pair.
<ul>
<li>Note that it is not necessary to save all of these paths for the
resampling step</li>
<li><strong>they can be regenerated by restarting the random number
generator with the same seed.</strong></li>
</ul></li>
<li>It is often reasonable to choose <strong><span class="math inline">\(n&#39;=1\)</span></strong> (a single Metropolis
seed).</li>
<li>实际测试中，初始化这一步的开销很小</li>
<li>two phase
<ul>
<li>The initialization phase <strong>estimates the overall image
brightness</strong></li>
<li>while the Metropolis phase determines <strong>the relative pixel
intensities across the image</strong></li>
</ul></li>
</ul>
<h4 id="convergence-tests">Convergence tests</h4>
<ul>
<li>Another reason to run several copies of the algorithm in parallel is
that it facilitates（促进） convergence testing.
<ul>
<li>We cannot apply the usual variance tests to samples generated by a
single run of the Metropolis algorithm, since consecutive samples are
<strong>highly correlated</strong>.</li>
</ul></li>
<li>To test for convergence, the Metropolis phase runs with <span class="math inline">\(n&#39;\)</span> independent seed paths, whose
contributions to the image are recorded separately (in the form of <span class="math inline">\(n&#39;\)</span> separate images).</li>
</ul>
<h4 id="spectral-sampling">Spectral sampling</h4>
<ul>
<li>Effectively, each color component <span class="math inline">\(h\)</span> is sampled with an estimator of the
form <span class="math inline">\(h/p\)</span>, where <span class="math inline">\(p\)</span> is proportional to the luminance.</li>
</ul>
<h3 id="designing-a-mutation-strategy">5.2 Designing a mutation
strategy</h3>
<ul>
<li>MLT 的问题
<ul>
<li><strong>consecutive samples are correlated</strong>, which leads to
<strong>higher variance</strong> than we would get with independent
samples.
<ul>
<li>连续被拒绝导致存在未收敛的相同样本，影响 variance</li>
</ul></li>
<li>This can happen either because <strong>the proposed mutations to the
path are very small</strong>, or because <strong>too many mutations are
rejected.</strong></li>
</ul></li>
<li>This problem can be minimized by choosing a suitable set of path
mutations.</li>
<li>一些 mutation 需要具备的特征</li>
<li><strong>High acceptance probability</strong>
<ul>
<li>acceptance probability is small <span class="math inline">\(\to\)</span> long path sequences <span class="math inline">\(\to\)</span> many samples at the same point on the
image plane <span class="math inline">\(\to\)</span> appears as
noise</li>
</ul></li>
<li><strong>Large changes to the path</strong>
<ul>
<li>small mutations 还是可能会导致 highly correlated</li>
</ul></li>
<li><strong>Ergodicity</strong>
<ul>
<li>If the allowable mutations are too restricted, it is possible for
the random walk to get " in some subregion of the path space.
<ul>
<li>比如下面的 figure 2</li>
</ul></li>
<li>To minimize correlation between the sample locations on the image
plane, <strong>it is desirable for mutations to change the lens edge
<span class="math inline">\(\mathrm{x}_{k-1}\mathrm{x}_{k}\)</span></strong></li>
</ul></li>
</ul>
<p><img src="/2021/07/08/CG/Papers/1997/MLT/image-20210711232730897.png" style="zoom:80%;"></p>
<ul>
<li><strong>Stratification</strong>
<ul>
<li>This is commonly known as the "balls in bins" effect:
<ul>
<li>if we randomly throw n balls into n bins, we cannot expect one ball
per bin.</li>
<li>Many bins may be empty, while the fullest bin is likely to contain
<span class="math inline">\(\Theta({n\log n})\)</span> balls</li>
<li>In an image, this unevenness in the distribution produces
noise.</li>
</ul></li>
<li>For some kinds of mutations, this effect is difficult to avoid.</li>
<li><strong>However, it is worthwhile to consider mutations for which
some form of stratification is possible.</strong></li>
</ul></li>
<li><strong>Low cost</strong>
<ul>
<li>Generally, this is measured by <strong>the number of rays
cast,</strong> since the other costs are relatively small</li>
</ul></li>
</ul>
<h3 id="good-mutation-strategies">5.3 Good mutation strategies</h3>
<h4 id="bidirectional-mutations">5.3.1 Bidirectional mutations</h4>
<ul>
<li></li>
</ul>
]]></content>
      <categories>
        <category>CG.Paper</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Paper</tag>
        <tag>MLT</tag>
        <tag>MCMC</tag>
      </tags>
  </entry>
  <entry>
    <title>(论文)[1991] Shaft Culling for Efficient Ray-Cast Radiosity</title>
    <url>/2021/08/11/CG/Papers/1991/ShaftCulling91/</url>
    <content><![CDATA[<h1 id="shaft-culling-for-efficient-ray-cast-radiosity">Shaft Culling
for Efficient Ray-Cast Radiosity</h1>
<h2 id="思路">思路</h2>
<ul>
<li>在 emitter 和 receiver
之间，我们可能会做多次光线投射的可见性测试，因此我们进行预处理</li>
<li>首先我们生成一个尽可能小的包围盒，将 emitter 和 receiver
包含进去</li>
<li>然后我们生成一个 list，list 里面包含可能和这个包围盒相交的
bv（可能对 emitter 和 receiver 之间的可见性又影响的 bv）</li>
<li>之后我们对每一条光线，只需要判断它和 list 中的光线是否有交即可</li>
</ul>
<h2 id="说明">说明</h2>
<ul>
<li>object：一个可渲染的图元</li>
<li>item：一个 object 或者多个 item</li>
<li>算法准备工作：根据给定的 object 建立 bvh（bounding volume
hierarchy）</li>
<li>reference items：the emitter and the receiver</li>
<li>candidate list：可能挡住 emitter 和 receiver 之间可见性的一组
item</li>
<li>每次需要判断两个采样点之间的可见性时，我们遍历整个 candidate
list，直至找到交点或者遍历结束</li>
<li>怎么生成 candidate list？如下是两种比较 trivial 的方法
<ul>
<li>可以使用整个场景所有 object 构成 candidate list</li>
<li>只使用 bvh 的根节点，遍历整棵树</li>
</ul></li>
<li>如果我们能够在空间上定义一个 volume，它能够包含整个空间中在
reference items 之间的所有点，这样便能够形成一个比较好的 candidate list
<ul>
<li>这样只需要判断 object 是否在 volume 之内即可</li>
</ul></li>
<li>时间花费：建立 candidate list 花费的时间和使用它节省的时间
<ul>
<li>可以估计允许我们使用多少时间生成 candidate list</li>
</ul></li>
<li>是否生成 candidate list
<ul>
<li>emitter 和 receiver 相隔很远，不生成</li>
</ul></li>
<li>预计算潜在的在 reference items 之间的光线，如果大于预设值则生成使用
candidate list，否则不生成使用
<ul>
<li><strong>简单</strong>的测试</li>
</ul></li>
</ul>
<h2 id="candidate-list-算法">candidate list 算法</h2>
<ul>
<li>candidate list 算法有 3 个步骤
<ul>
<li>forming the testing volume</li>
<li>creating the candidate list by using this volume</li>
<li>accessing the candidate list for visibility determination between
samples</li>
</ul></li>
</ul>
<h3 id="forming-the-testing-structure">(1) Forming the Testing
Structure</h3>
<ul>
<li>主要步骤如下
<ul>
<li>Obtain the <strong>bounding boxes</strong> for the reference
items.</li>
<li>Compute <strong>the extent bounding box</strong> containing both
reference items.</li>
<li>Create the <strong>plane set</strong> between the two reference
items' boxes.</li>
</ul></li>
</ul>
<p><img src="/2021/08/11/CG/Papers/1991/ShaftCulling91/image-20210809214236432.png" style="zoom:67%;"></p>
<ul>
<li><p>第一步</p>
<ul>
<li>我们使用 bvh，因此可以很容易得到 reference item 的包围盒，AABB
包围盒（axis aligned）</li>
<li><span class="math inline">\(lo.x,lo.y,lo.z,hi.x,hi.y,hi.z\)</span></li>
</ul></li>
<li><p>第二步</p>
<ul>
<li>直接对两个 reference item
的包围盒取边界值（大的取大，小的取小）</li>
<li>同时找出 culled edges（扩展包包围盒中不属于 reference item
的边）</li>
</ul></li>
<li><p>第三步</p>
<ul>
<li><p>找到一组平面，将两个 reference item 的包围盒连接在一起</p></li>
<li><p>形成 minimal bounding volume</p></li>
<li><p>我们削去包围盒中和 culled edges 相邻的一块空间</p>
<ul>
<li>我们将 volume 称为 shaft</li>
</ul></li>
<li><p>同时需要记录哪一个生成扩展包围盒的时候，哪一个包围盒的顶点成为了边界值（最大最小）</p>
<ul>
<li>称为 list</li>
<li>用于确定 culled edges</li>
</ul></li>
<li><p>两个 reference item 都需要有一个 list，每个 list 最多有 6 个
entry</p></li>
<li><p>每一个 entry 记录类型（minimum / maximum）和方向（X / Y / Z）</p>
<ul>
<li>例如 MIN_Z</li>
</ul></li>
<li><p>如果 reference item 的最小/大值相同，则两个列表都不会出现这个
entry</p></li>
</ul></li>
</ul>
<h4 id="运行过程">运行过程</h4>
<ul>
<li>构造 list
<ul>
<li>emitter list：MAX_Y</li>
<li>receiver list：MIN_X，MIN_Y，MAX_X</li>
</ul></li>
<li>第三步构造 planes，两个 list
中的元素两两组合（去除方向匹配的边），剩下的边就是 culled edge
<ul>
<li>MAX_Y——MIN_X</li>
<li>MAX_Y——MIN_Y（方向匹配上了，去除）</li>
<li>MAX_Y——MAX_X</li>
</ul></li>
</ul>
<p><img src="/2021/08/11/CG/Papers/1991/ShaftCulling91/image-20210809214236432.png" style="zoom:67%;"></p>
<ul>
<li>MAX_Y——MIN_X
<ul>
<li>切去边 ：<span class="math inline">\((lo.x,hi.y,lo.z)-(lo.x,hi.y,hi.z)\)</span>
关联的边（culled edge）</li>
<li>生成平面的法线（就和我们平时法线的定义一致），<strong>得归一化</strong>
<ul>
<li>未参与 <span class="math inline">\(Z.direction=0\)</span></li>
<li><span class="math inline">\(X.direction=Receiver.hi.y-Emitter.hi.y\)</span></li>
<li><span class="math inline">\(Y.direction=-Receiver.lo.x+Emitter.lo.x\)</span></li>
</ul></li>
<li>平面与原点的距离（原点指向平面，法线）
<ul>
<li><span class="math inline">\(P.distance=-(X.direction\ast
lo.x+Y.direction\ast hi.y)\)</span></li>
<li><span class="math inline">\(lo.x,hi,y\)</span> 使用任意 reference
item 的都行，是等价的（画图即可看出来）</li>
</ul></li>
</ul></li>
<li>形成的 plane 的集合保存在一个 list 中，称为 plane set</li>
<li>可能 plane set 为空
<ul>
<li>当一个 reference item 整个都在另一个 reference item 的里面时，plane
set 为空</li>
</ul></li>
<li>其他例子</li>
</ul>
<p><img src="/2021/08/11/CG/Papers/1991/ShaftCulling91/image-20210810152017775.png" style="zoom:67%;"></p>
<h3 id="creating-the-candidate-list">(2) Creating the Candidate
List</h3>
<ul>
<li><p>使用第一步建立的 shaft，和场景中的物体求交，生成 candidate
list，具体生成方法如下</p></li>
<li><p>首先使用 bvh 的根节点和 shaft 求交，可能出现如下的 3 种情况</p>
<ul>
<li>The item is entirely outside of the shaft.（在 shaft 外面）</li>
<li>The item is entirely inside the shaft. （在 shaft 里面）</li>
<li>Else, the item overlaps the shaft. （和 shaft 部分相交）</li>
</ul></li>
<li><p>如果在 shaft 外面，直接忽略</p></li>
<li><p>如果是在 shaft 里面或部分相交，则有多种策略</p>
<ul>
<li>always open
<ul>
<li>始终递归进行，直到叶子结点（不是 bounding volume）</li>
<li>candidate list 由所有不是 bv 的 object 组成</li>
</ul></li>
<li>非 always open 策略
<ul>
<li>如果是在 shaft 里面，则将其加入到 candidate list 中
<ul>
<li>如果光线 miss 则会加速（不需要和内部的 item 进行测试）</li>
</ul></li>
<li>如果是和 shaft 部分相交，则有多种策略</li>
</ul></li>
</ul></li>
<li><p>和 shaft 部分相交的多种非 always open 策略</p>
<ul>
<li>叶子结点的处理
<ul>
<li>如果是一个 object 而不是 bv，则加入 candidate list</li>
</ul></li>
<li>keep closed
<ul>
<li>直接将 bv 加入到 candidate list 中</li>
</ul></li>
<li>overlap open
<ul>
<li>和 always open 一样，递归展开至叶子结点</li>
<li>当 reference item 之间的 object 比较少的时候可以使用</li>
<li>但是可能这始终打开 bv 是一个比较耗时的操作（增加光线的测试）</li>
</ul></li>
<li>ratio open
<ul>
<li>设定一个 ratio 判定是否值得打开 bv
<ul>
<li>例如 0.4
<ul>
<li>如果 bv 中有超过 40% 的物体在 shaft 中或者与 shaft 相交，则不打开
bv，直接将其放入 candidate list</li>
</ul></li>
</ul></li>
<li>值得注意的是，即使是满足上面 ratio 的条件，bv 也有可能被展开，bv
被保留的条件是内部的 item 比 bv 测试难得多得多</li>
</ul></li>
<li>多种策略</li>
</ul>
<p><img src="/2021/08/11/CG/Papers/1991/ShaftCulling91/image-20210810171310519.png" style="zoom:67%;"></p></li>
</ul>
<h3 id="shaft-cull-testing">(3) Shaft Cull Testing</h3>
<ul>
<li>cull test：shaft 和 bv 求交</li>
<li>被测试的 bv 被称为 test volume</li>
<li>只考虑 sphere 包围盒和 axis aligned 包围盒</li>
<li>判断流程如下
<ul>
<li>判断 test volume 和 extent box
的位置关系：inside、outside、overlapping</li>
<li>如果是 outside ，测试结束；否则判断 test volume 是否和 reference
item 有重合部分（overlap）</li>
<li>如果有重合部分，测试结束；否则将 test volume 和 plane set
进行位置关系的测试</li>
<li>如果 test volume 是 outside
，测试结束；否则需要进一步测试（策略相关），判断 test volume 是否完全在
shaft 里面，或者是否展开 bv 等</li>
</ul></li>
</ul>
<h4 id="sphere-bv-测试">Sphere bv 测试</h4>
<ul>
<li>第一步：outside 测试
<ul>
<li><strong>Arvo's algorithm</strong> for <strong>box/sphere
comparison</strong> [Arvo, 90].
<ul>
<li>每个轴分开处理</li>
<li>如果在某个轴上，圆心在 box
内部，则求出圆心到这个轴对应的近一点的面的距离</li>
<li>对上面的距离求平方和，和半径的平方作比较</li>
<li>如果比平方和大，就是 outside</li>
</ul></li>
</ul></li>
<li>第二步：overlap 测试
<ul>
<li>和第一步相似，将 test volume 和 reference item 进行测试</li>
<li>如果相交，则一定和 shaft 相交</li>
</ul></li>
<li>第三步：plane set，outside 测试
<ul>
<li>T=dot_product(Plane.normal, Sphere.center) + Plane.distance
<ul>
<li>画图发现就是圆心到平面的距离</li>
</ul></li>
<li>如果 T&gt;Sphere.radius，说明相离（outside）
<ul>
<li>如果是内部的话，计算出来会的 T 是负数</li>
</ul></li>
<li>如果法线对于所有 plane set 中的 plane，都是 outside 的话，说明 bv 在
shaft 的外面</li>
<li>仍然有可能出现 bv 在 shaft 外面的情况（false positive）
<ul>
<li>这不会犯错，但是会增加计算量（误将其放入 candidate list）</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/08/11/CG/Papers/1991/ShaftCulling91/image-20210810220729169.png" style="zoom:67%;"></p>
<ul>
<li>第四步：inside 测试
<ul>
<li>如果对所有的 plane set 中的 plane，都满足 T &gt;
-Sphere.radius，则在 shaft 内部</li>
<li>否则就归类于 overlap</li>
</ul></li>
</ul>
<h4 id="aabb-测试">AABB 测试</h4>
<ul>
<li>boxes 的测试不需要对 plane set 中的法向进行归一化
<ul>
<li>sphere 需要和半径比较因此需要归一化，但是这里比较的都是和 0 比，因此
scale 无关紧要</li>
</ul></li>
<li>定义 the distance of a point from the plane 如下
<ul>
<li>T = dot_product( Plane.normal, Point) + Plane.distance</li>
</ul></li>
<li>平面定义了半空间（half space）
<ul>
<li>T&gt;0：outside</li>
<li>T=0：on</li>
<li>T&lt;0：inside</li>
</ul></li>
<li>认为距离有正负大小区分</li>
<li>给定一个平面，总有一个顶点到平面距离最大（farthest），有一个点到平面距离最小（nearest）
<ul>
<li>这个顶点是平面法线的函数
<ul>
<li>farthest：对于法线，如果某一个轴值为正，则使用 box 的 hi 值；0 使用
0；负使用 box 的 lo 值</li>
<li>nearest：正：lo；0：0；负：hi</li>
</ul></li>
<li>例如，法线：[-3, 8, 4]
<ul>
<li>farthest：[lo.x,hi.y,hi.z]</li>
<li>nearest：[hi.x,lo.y,lo.z]</li>
</ul></li>
</ul></li>
<li>因此测试过程和 sphere 一摸一样
<ul>
<li>extent box</li>
<li>reference item boxes</li>
<li>each plane in the plane set
<ul>
<li>使用 nearest_corner</li>
<li>If dot_product( Plane.normal, <strong>Box.near_corner</strong>) +
Plane.distance &gt; 0
<ul>
<li>box is outside the plane (and the shaft)</li>
</ul></li>
</ul></li>
</ul></li>
<li>如果通过了上述测试，说明 test volume 和 shaft 的位置只有
inside/overlap</li>
<li>overlap 测试（一个满足则是 overlap）
<ul>
<li>If dot_product( Plane.normal, Box.far_corner ) + Plane.distance &gt;
0
<ul>
<li>box overlaps shaft</li>
</ul></li>
</ul></li>
<li>以上的方法虽然快，但是可能会将 outside 的物体判定为 overlap
<ul>
<li>plane set
的测试，我们用的是整个平面，可能会误判的问题，但是这个只会增加计算量而不会导致错误</li>
</ul></li>
</ul>
<h3 id="candidate-list-access">(4) Candidate List Access</h3>
<ul>
<li>对于 receiver 和 emitter 上的两个采样点，我们形成一条光线，使用
candidate list 进行测试</li>
<li>使用栈实现，对于 bv，如果相交，则将其子结点压栈</li>
<li>最终要么相交（和一个不透明的物体相交），要么栈弹空结束</li>
</ul>
<h2 id="算法改进">算法改进</h2>
<ul>
<li>我们知道两个 reference item 之间的光线一定是起源于某个
box，终止与另外一个 box
<ul>
<li>因此如果 test volume 完全将某个 reference item
包含，则光线必定相交</li>
<li>因此可以在第一步的时候，做一下这个测试</li>
</ul></li>
<li>基于辐射度算法会出现如下情况：一个 emitter，对多个
receiver，如下预处理很有效
<ul>
<li>对 bv 进行预求交，判断它是否完全包含 emitter 的 reference
box，形成一个 candidate list
<ul>
<li>如果完全包含，直接展开为子节点</li>
</ul></li>
<li>这样的预计算可以减少重复计算</li>
<li>之后和上面一样，当然之后 reference item 的完全包含测试只需要测试
receiver 即可</li>
<li>同时在预处理的时候，可以在 candidate list 中保存 emitter 的
reference item 的位置关系，如果 emitter 是 overlap 的话，则后面算法中的
outside 测试就不需要了</li>
<li>相当这一部分的改进就是，将后面可能的重复计算提前预计算了</li>
</ul></li>
<li>从 emitter 的 bv 开始向上展开形成 candidate list
<ul>
<li>测试其父结点的所有子结点，然后重复向上（不需要测试父结点，一定相交）</li>
</ul></li>
<li>emitter 的出射方向有限的时候，可以将不可见的面直接剔除</li>
</ul>
]]></content>
      <categories>
        <category>CG.Paper</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Paper</tag>
        <tag>occlusion</tag>
        <tag>可见性</tag>
      </tags>
  </entry>
  <entry>
    <title>(论文)[2005] Energy redistribution path tracing</title>
    <url>/2021/07/08/CG/Papers/2005/ERPT/</url>
    <content><![CDATA[<h1 id="energy-redistribution-path-tracing">Energy redistribution path
tracing</h1>
<ul>
<li><strong><span style="color:red;">TODO</span></strong></li>
</ul>
]]></content>
      <categories>
        <category>CG.Paper</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>(论文)[2012] Light Transport Simulation with Vertex Connection and Merging</title>
    <url>/2021/04/13/CG/Papers/2012/VCM/</url>
    <content><![CDATA[<h1 id="light-transport-simulation-with-vertex-connection-and-merging">Light
Transport Simulation with Vertex Connection and Merging</h1>
<blockquote>
<p>SIGGRAPH Asia 2012</p>
</blockquote>
<h2 id="效果展示">效果展示</h2>
<p><img src="/2021/04/13/CG/Papers/2012/VCM/image-20210414155032668.png" style="zoom:50%;"></p>
<ul>
<li>BPT(Bidirectional Path Tracing)
<ul>
<li>不能很好的模拟 caustics 现象</li>
<li>例如 SDS 路径</li>
</ul></li>
<li>PPM(Stochastic Progressive Photon Mapping)
<ul>
<li>PPM has difficulties in handling the illumination coming from the
room seen in the mirror</li>
<li>TODO</li>
</ul></li>
<li>VCM = BPT + PPM
<ul>
<li>通过多重重要性采样的方法将这两种方法结合起来</li>
<li>MIS(Multiple Importance Sampling)</li>
</ul></li>
<li><a href="http://github.com/SmallVCM/SmallVCM">文章代码</a></li>
</ul>
<h2 id="introduction">1. Introduction</h2>
<ul>
<li>之前的方法基本存在的问题，不能在所有场景中都发挥得很好
<ul>
<li>在某些场景中不能表现得很好</li>
<li>忽略某些类型的光路</li>
</ul></li>
</ul>
<h3 id="bpt">BPT</h3>
<ul>
<li>能够处理大部分场景</li>
<li>MIS 的采样方法能够很好的将很多种光路组合起来</li>
<li>The true key to its robustness is the provably good combination of
various path sampling techniques using MIS.</li>
<li>不好处理 SDS 的光路
<ul>
<li>‘specular’ also includes sharp glossy interactions</li>
<li>原因是这样的光路被采样的概率很小，尤其是 point light sources +
pinhole cameras 场景的时候</li>
</ul></li>
</ul>
<h3 id="pm">PM</h3>
<ul>
<li>能够很好地处理 SDS 光路</li>
<li>Its inefficiency under diffuse lighting and its relatively low order
of convergence</li>
<li>存在的问题
<ul>
<li>收敛很慢</li>
<li>在 diffuse lighting 条件下，效果不太好</li>
</ul></li>
</ul>
<h3 id="bpt-pm">BPT + PM</h3>
<ul>
<li>之前有人将 BPT 和 PM 结合过，但是效果不太好
<ul>
<li>Combining BPT with PM via heuristic classification of paths into
caustic and non-caustic can be far from optimal</li>
<li>启发式的将路径分为焦散路径和其他路径</li>
</ul></li>
<li>我们使用 MIS 的技术将 BPT 和 PM 结合</li>
<li>之前大家把 BPT 和 PM
放置在两套数学框架下，下载我们提出新的思路，从而将这两个方法结合起来</li>
<li>通过 MIS 结合起来的方法能够很好的保留二者的优点
<ul>
<li>保有 BPT 的 MSE 收敛率 <span class="math inline">\(O(\dfrac{1}{N})\)</span></li>
<li>保有 PM 对于 SDS 路径的高效查找</li>
</ul></li>
</ul>
<h3 id="论文的贡献">论文的贡献</h3>
<ul>
<li>A novel reformulation of photon mapping compatible with the path
integral formulation of light transport (Section 4)
<ul>
<li>重新定义了 PM 算法的数学框架，使其和路径积分兼容</li>
</ul></li>
<li>A robust light transport simulation algorithm that combines BPT and
PM via multiple importance sampling (Section 5)
<ul>
<li>一个结合了 BRT/PM 长处的算法</li>
</ul></li>
<li>A progressive variant of the combined algorithm along with an
asymptotic analysis of its error convergence (Section 6)
<ul>
<li>方差的渐进分析</li>
</ul></li>
</ul>
<h2 id="previous-work">2. Previous Work</h2>
<h3 id="path-tracing">Path tracing</h3>
<ul>
<li>从相机出发
<ul>
<li>[Kajiya 1986]</li>
</ul></li>
<li>从光源出发
<ul>
<li>Dutr´e et al. [1993]</li>
</ul></li>
<li>双向：BPT
<ul>
<li>[Lafortune and Willems 1993; Veach and Guibas 1994]</li>
</ul></li>
<li>path integral framework
<ul>
<li>PT 的积分框架</li>
<li>Veach [1997]</li>
</ul></li>
<li>MIS，多条采样路径
<ul>
<li>[Veach and Guibas 1995]</li>
</ul></li>
</ul>
<h3 id="photon-mapping">Photon mapping</h3>
<ul>
<li><strong>有偏的</strong></li>
<li>density estimation：光子密度估计
<ul>
<li>[Jensen 2001]</li>
</ul></li>
<li>photon mapping has <strong>difficulties</strong> in scenes with
<strong>many glossy objects</strong>
<ul>
<li>Haˇsan et al. [2009] and Vorba [2011]</li>
</ul></li>
<li>利用 MIS，组合多条 eye sub-path
<ul>
<li>Vorba [2011]</li>
<li>对于 PM 的定义不能很好的利用 MIS 将 PM 和 BPT 结合</li>
</ul></li>
<li>MIS，让 PM 在 glossy 材质上的焦散表现得更好
<ul>
<li>Tokuyushi [2009]</li>
</ul></li>
<li>PPM
<ul>
<li>[Hachisuka et al. 2008]</li>
<li>因为 PM 是有偏的，PPM 通过减小半径的方式，试图减小 bias</li>
<li>相较于 BPT，更好的模拟 SDS 光路，但是渐进误差收敛速率更慢
<ul>
<li>asymptotic error convergence rate</li>
<li>Hachisuka et al. [2010] 给出估计</li>
</ul></li>
</ul></li>
</ul>
<h3 id="markov-chain-monte-carlo">Markov chain Monte Carlo</h3>
<ul>
<li>MCMC</li>
<li>MCMC 能够更多的采样具有贡献的 path（让我们接受的 path）
<ul>
<li>BPT [Veach and Guibas 1997]</li>
<li>PM/PPM [Fan et al. 2005;Hachisuka and Jensen 2011]</li>
</ul></li>
</ul>
<h3 id="many-light-methods">Many-light methods</h3>
<ul>
<li>[Keller 1997; Walter et al. 2006; Haˇsan et al. 2007; Ou and
Pellacini 2011]</li>
<li>[Kˇriv´anek et al. 2010]
<ul>
<li>能量损失、失真问题</li>
</ul></li>
<li>[Kollig and Keller 2004; Haˇsan et al. 2009; Davidoviˇc et al. 2010;
Walter et al. 2012]
<ul>
<li>减轻上面的问题</li>
</ul></li>
<li>都不能很好的处理 SDS 光路</li>
</ul>
<h2 id="background">3. Background</h2>
<h3 id="mis">MIS</h3>
<ul>
<li>Multiple importance sampling</li>
<li>[Veach and Guibas 1995]</li>
<li>我们要求积分 <span class="math inline">\(I\)</span>，其中<span class="math inline">\(f(x)\)</span> 为实值函数，<span class="math inline">\(\mu(x)\)</span> 是积分域 <span class="math inline">\(\Omega\)</span> 上的测度</li>
</ul>
<p><span class="math display">\[
I=\int_{\Omega}f(x)d\mu(x)
\]</span></p>
<ul>
<li>MIS 构造了一个对 <span class="math inline">\(I\)</span>
的无偏估计，这个无偏估计是通过组合 <span class="math inline">\(m\)</span>
个不同的分布（采样方法）得到的组合估计，每一种分布以 <span class="math inline">\(p_i\)</span> 给出它的 <span class="math inline">\(\mathrm{pdf}\)</span>
<ul>
<li><span class="math inline">\(X_{i,j}\)</span> 为满足分布 <span class="math inline">\(p_i\)</span> 的随机变量</li>
</ul></li>
</ul>
<p><span class="math display">\[
\langle
I\rangle_{MIS}=\sum_{i=1}^m\dfrac{1}{n_i}\sum_{j=1}^{n_i}w_i(X_{i,j})\dfrac{f(X_{i,j})}{p_i(X_{i,j})}
\]</span></p>
<ul>
<li>最小化估计的方差，权重设置</li>
</ul>
<p><span class="math display">\[
w_i(x)=\dfrac{\left[n_ip_i(x)\right]^\beta}{\sum_{k=1}^n\left[n_kp_k(x)\right]^\beta}
\]</span></p>
<ul>
<li><span class="math inline">\(\beta=1\)</span></li>
<li>具体分析看论文：<span style="color:red;font-weight:bold">TODO</span></li>
</ul>
<h3 id="path-integral-framework">Path Integral Framework</h3>
<ul>
<li>[Veach 1997]</li>
<li>积分框架</li>
</ul>
<p><span class="math display">\[
I=\int_{\Omega}f(\bar{\mathrm{x}})d\mu(\bar{\mathrm{x}})
\]</span></p>
<ul>
<li><span class="math inline">\(\bar{\mathrm{x}}\)</span>
表示一条可行的光路，<span class="math inline">\(\bar{\mathrm{x}}=\mathrm{x}_0\cdots
\mathrm{x}_k\)</span>，其中有 <span class="math inline">\(k(k&gt;0)\)</span> 条边，<span class="math inline">\(k-1\)</span> 个中间结点</li>
<li><span class="math inline">\(\mathrm{x}_0\)</span> 在光源处，<span class="math inline">\(\mathrm{x}_k\)</span> 在摄像机上</li>
<li><span class="math inline">\(\Omega\)</span> 表示任意长度的光路</li>
<li>面积测度：<span class="math inline">\(d\mu(\bar{\mathrm{x}})=dA(\mathrm{x}_0)\cdots
dA(\mathrm{x}_{k})\)</span></li>
<li>贡献测度：<span class="math inline">\(f(\mathrm{\bar{x}})\)</span></li>
</ul>
<p><span class="math display">\[
f(\bar{\mathrm{x}})=L_e(\mathrm{x}_0){\color{red}G(\mathrm{x}_0\leftrightarrow\mathrm{x}_1)\left[\prod_{i=1}^{k-1}\rho_{s}(\mathrm{x}_i)G(\mathrm{x}_i\leftrightarrow\mathrm{x}_{i+1})\right]}W_e(\mathrm{x}_k)
\]</span></p>
<ul>
<li>红色部分记作 <span class="math inline">\(T(\mathrm{\bar{x}})\;{\buildrel\rm
def\over=}\;\mathrm{path\ throughput}\)</span></li>
<li><span class="math inline">\(L_e(\mathrm{x}_0) =
L_e(\mathrm{x}_0\to\mathrm{x}_1)\)</span> 表示光源从 <span class="math inline">\(\mathrm{x}_0\)</span> 向 <span class="math inline">\(\mathrm{x}_1\)</span> 发射的 radiance</li>
<li><span class="math inline">\(W_e(\mathrm{x}_k) =
W_e(\mathrm{x}_{k-1}\to\mathrm{x}_k)\)</span> 表示摄像机在 <span class="math inline">\(\mathrm{x}_{k}\)</span> 点，对从 <span class="math inline">\(\mathrm{x}_{k-1}\)</span> 点入射到 <span class="math inline">\(\mathrm{x}_{k}\)</span> 的光的灵敏性</li>
<li><span class="math inline">\(\rho_{s}(\mathrm{x}_i)=\rho_{s}(\mathrm{x}_{i-1}\to\mathrm{x}_i\to\mathrm{x}_{i+1})\)</span>：在
<span class="math inline">\(\mathrm{x}_i\)</span> 点的 BSDF</li>
<li><span class="math inline">\(G(\mathrm{x}_i\to\mathrm{x}_j)=V(\mathrm{x}_i\to\mathrm{x}_j)\dfrac{|\cos\theta_{i,j}||\cos\theta_{j,i}|}{\Vert\mathrm{x}_i-\mathrm{x}_j\Vert^2}\)</span>：表示几何项
<ul>
<li><span class="math inline">\(V\)</span> 表示几何项</li>
</ul></li>
</ul>
<p><img src="/2021/04/13/CG/Papers/2012/VCM/image-20210414212315780.png" style="zoom:70%;"></p>
<ul>
<li>简单的可以把 <span class="math inline">\(f(\bar{\mathrm{x}})\)</span> 记作</li>
</ul>
<p><span class="math display">\[
f(\bar{\mathrm{x}})=L_e(\mathrm{x}_0)T(\bar{\mathrm{x}})W_e(\mathrm{x}_k)
\]</span></p>
<ul>
<li>上面的表达式能够让 MIS 方法生效</li>
</ul>
<p><span class="math display">\[
\dfrac{f(\bar{\mathrm{x}})}{p(\bar{\mathrm{x}})}
\]</span></p>
<h3 id="path-sampling-techniques">Path sampling techniques</h3>
<ul>
<li><span class="math inline">\(p(\bar{\mathrm{x}})\)</span>
是联合分布</li>
<li>每一步的采样都是独立的</li>
</ul>
<p><span class="math display">\[
p(\bar{\mathrm{x}})=p(\mathrm{x}_0,\cdots,\mathrm{x}_k)=p(\mathrm{x}_0)\cdots
p(\mathrm{x}_k)
\]</span></p>
<p><img src="/2021/04/13/CG/Papers/2012/VCM/image-20210414215352121.png" style="zoom:67%;"></p>
<ul>
<li><span class="math inline">\(p(\mathrm{x}_j)\)</span>
：方向采样的概率</li>
</ul>
<p><span class="math display">\[
p(\mathrm{x}_j)=
\left\{  
\begin{array}{**lr**}  
p(\mathrm{x}_{j-1}\to\mathrm{x}_{j}), &amp; \mathrm{if\ x_{j}\ is\ on\
a\ light\ subpath} \\
p(\mathrm{x}_{j}\to\mathrm{x}_{j-1}), &amp; \mathrm{if\ x_{j}\ is\ on\
a\ eye\ subpath} \\
\end{array}  
\right.
\]</span></p>
<ul>
<li>BPT 中一条长度为 <span class="math inline">\(k\)</span>
段的光路的产生可以有 <span class="math inline">\(k+2\)</span>
种方式</li>
<li>BPT 最早的实现
<ul>
<li>[Lafortune and Willems 1993; Veach and Guibas 1994]</li>
</ul></li>
<li>MIS，组合不同的采样路径，同时使用指数的形式
<ul>
<li>因为如果不加指数，会把出现概率很小的 SDS 路径直接剪掉
<ul>
<li>按照上面的采样方法，对于 SDS
路径只有两种方式（单项路径），而这样的光路采样概率很小，导致方差很大</li>
</ul></li>
<li>MIS automatically diminishes the weight of a sampling technique that
is inappropriate (i.e. has a low pdf value) for a given path</li>
<li>[Veach and Guibas 1995]</li>
</ul></li>
</ul>
<h3 id="photon-mapping-radiance-estimate">Photon mapping radiance
estimate</h3>
<ul>
<li>[Jensen 2001]</li>
</ul>
<p><span class="math display">\[
L_s(\mathrm{x},\omega)\approx\sum_jK_r(\Vert\mathrm{x}-\mathrm{x}_j\Vert)\rho_{s}(\omega_j,\mathrm{x},\omega)\Phi_j
\]</span></p>
<ul>
<li><span class="math inline">\(K_r\)</span>：2D 滤波核，半径 <span class="math inline">\(r\)</span></li>
<li><span class="math inline">\(j\)</span>：到 <span class="math inline">\(\mathrm{x}\)</span> 的距离小于 <span class="math inline">\(r\)</span> 的所有光子
<ul>
<li><span class="math inline">\(\omega_j\)</span>：光子的入射方向</li>
<li><span class="math inline">\(\mathrm{x}_j\)</span>：光子的位置</li>
<li><span class="math inline">\(\Phi_j\)</span>：光子的光通量 flux</li>
</ul></li>
<li><span class="math inline">\(\omega\)</span>：eye ray 的入射方向</li>
<li><span class="math inline">\(\rho_s\)</span>：BSDF</li>
<li>这样看来，PM 和 BPT 并不是定义在一套数学框架下的，PM
甚至与采样的路径无关，因此很难用 MIS 将他们结合起来</li>
</ul>
<h2 id="vertex-merging">4. Vertex Merging</h2>
<ul>
<li>首先我们需要将 PM 和 BPT 用一个数学框架描述</li>
<li>将 PM 用积分框架进行描述</li>
<li>我们接下来的讨论把 light path 长度规定为 <span class="math inline">\(k\)</span></li>
<li>PM radiance 的估计可以发生在第 <span class="math inline">\(s\)</span> 个结点上
<ul>
<li>这样就产生了单路径采样的方法</li>
<li>整套方法需要通过估计光路上的不同 <span class="math inline">\(s\)</span> 的值，<span class="math inline">\(s\in[1,\cdots,k-1]\)</span></li>
</ul></li>
</ul>
<h3 id="pm-as-a-sampling-technique-for-extended-paths">PM as a sampling
technique for extended paths</h3>
<p><img src="/2021/04/13/CG/Papers/2012/VCM/image-20210415000815521.png" style="zoom:70%;"></p>
<ul>
<li>把 PM 的光路当作单路径采样得到的结果</li>
<li>自然的想法，我们对一个光子产生的光路，只考虑光子在最终的位置 <span class="math inline">\(\mathrm{x}_s^\ast\)</span>
<ul>
<li>整条路径为 <span class="math inline">\(\mathrm{x}_0,\cdots,\mathrm{x}_s^\ast\)</span></li>
</ul></li>
<li>我们用于做密度估计的点 <span class="math inline">\(\mathrm{x}_s\)</span> 需要是一条从摄像机出发的
sub-path <span class="math inline">\(\mathrm{s}_0,\cdots,\mathrm{x}_k\)</span></li>
<li>这样最终组成一条路径 <span class="math inline">\(\mathrm{x}_0,\cdots,\mathrm{x}_s^\ast,\mathrm{x}_s,\cdots,\mathrm{x}_k\)</span>
<ul>
<li>记作 <code>extended path</code>，<span class="math inline">\(\bar{\mathrm{x}}^\ast=(\mathrm{x}_0,\cdots,\mathrm{x}_s^\ast,\mathrm{x}_s,\cdots,\mathrm{x}_k)\)</span></li>
<li>上面的左图</li>
</ul></li>
<li>整条路径的概率</li>
</ul>
<p><span class="math display">\[
p(\bar{\mathrm{x}}^\ast)=p(\mathrm{x}_0,\cdots,\mathrm{x}_s^\ast)p(\mathrm{x}_s,\cdots,\mathrm{x}_k)=p(\mathrm{x}_0)\cdots
p(\mathrm{x}_s^\ast)p(\mathrm{x}_s)\cdots p(\mathrm{x}_k)
\]</span></p>
<h3 id="discussion">Discussion</h3>
<ul>
<li>我们现在已经把 PM 当作是一种采样策略，生成一条extended
path，同时它有自己的 pdf
<ul>
<li>extended path 比正常的 path（BPT）多出一个点 <span class="math inline">\(\mathrm{x}_s^\ast\)</span> （光子的位置）</li>
<li>pdf 更高维，于是在权重估计上会出问题</li>
</ul></li>
<li>为了能够使用 MIS 将 BPT 和 PM 结合起来，需要将二者的长度修改为一致
<ul>
<li>两种都可以，这里采用 BPT 的长度（可以保证原来的积分形式不变）</li>
</ul></li>
</ul>
<h3 id="pm-as-a-sampling-technique-for-regular-paths">PM as a sampling
technique for regular paths</h3>
<ul>
<li>我们将 extended path 去掉点 <span class="math inline">\(\mathrm{x}_s^\ast\)</span>，形成一条长度为 <span class="math inline">\(k\)</span> 的 path
<ul>
<li>下面右图</li>
</ul></li>
</ul>
<p><img src="/2021/04/13/CG/Papers/2012/VCM/image-20210415000815521.png" style="zoom:70%;"></p>
<ul>
<li>我们对每一个 <span class="math inline">\(kernel\)</span>
范围内的光子都构造一条这样的路径 <span class="math inline">\(\bar{\mathrm{x}}=(\mathrm{x}_0,\cdots,\mathrm{x}_k)\)</span></li>
<li>结果
<ul>
<li>The radiance contribution of such a path now contains an extra area
integration that corresponds to <strong>blurring</strong> by the <span class="math inline">\(K_r\)</span> kernel to which the path integral is
oblivious, as we detail in Appendix A.</li>
</ul></li>
<li>光子前进的过程中，我们使用蒙特卡洛采样方法，同时使用
RR（俄罗斯轮盘赌）的方式，判断是否应该在这个点将光子停下来</li>
<li>我们形成这种 path，只考虑在 kernel 范围内的光子</li>
</ul>
<h3 id="path-pdf">Path pdf</h3>
<ul>
<li>由 VM 产生的路径 <span class="math inline">\(p_{VM}(\bar{\mathrm{x}})\)</span> 的 pdf 如下</li>
</ul>
<p><span class="math display">\[
p_{VM}(\bar{\mathrm{x}})=P_{acc}(\bar{\mathrm{x}})p_{VC}(\bar{\mathrm{x}})
\]</span></p>
<ul>
<li><span class="math inline">\(p_{VC}(\bar{\mathrm{x}})\)</span>
表示直接将两条 subpath 连接在一起的 pdf，连接端点 <span class="math inline">\({\mathrm{x}}_{s-1},{\mathrm{x}}_{s}\)</span>
<ul>
<li>表达形式见第 3 部分</li>
</ul></li>
<li><span class="math inline">\(P_{acc}(\bar{\mathrm{x}})\)</span>
表示这样一条路径可接受的概率
<ul>
<li><span class="math inline">\(P_{acc}(\bar{\mathrm{x}})\le1\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
P_{acc}(\bar{\mathrm{x}})\ &amp;=\
\mathrm{Pr}(\Vert\mathrm{x}_s-\mathrm{x}^\ast_{s}\Vert^2&lt;r)\\
&amp;=\
\int_{\mathcal{A}_\mathcal{M}}p(\mathrm{x}_{s-1}\to\mathrm{x})d\mathrm{x}\\
&amp;\approx|{\mathcal{A}}_{\mathcal{M}}|p(\mathrm{x}_{s-1}\to\mathrm{x}^\ast_s)\\
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\({\mathcal{A}}_{\mathcal{M}}=\left\{\mathrm{x}\in
\mathcal{M}|\Vert\mathrm{x}_s-\mathrm{x}\Vert^2&lt;r\right\}\)</span>：核半径之内</li>
<li>我们假设 <span class="math inline">\({\mathcal{A}}_{\mathcal{M}}\)</span> 内部的 pdf
是一个常数
<ul>
<li>PPM 也是这么假设的
<ul>
<li>[Hachisuka et al. 2008]</li>
</ul></li>
<li>渐进分析
<ul>
<li>[Knaus and Zwicker 2011].</li>
</ul></li>
</ul></li>
<li>我们假设 <span class="math inline">\({\mathcal{A}}_{\mathcal{M}}\)</span> 是一个半径为
<span class="math inline">\(r\)</span> 的圆</li>
<li>如果现实和我们假设不符，这样可能会导致估计不准确
<ul>
<li>areas of geometric variation and when p is far from constant</li>
<li><span class="math inline">\({\mathcal{A}}_{\mathcal{M}}\)</span>
内部的 pdf 不是常数，
<ul>
<li><span class="math inline">\(\mathrm{x}_{s-1}\)</span> 的 BSDF 是
glossy 的</li>
</ul></li>
<li>几何变异大</li>
</ul></li>
<li><span class="math inline">\(r\)</span> 趋向于 0
的时候就是准确的</li>
<li><span class="math inline">\(\mathrm{x}_{s-1}\)</span>
如果是镜面，而且恰好 <span class="math inline">\(\mathrm{x}_s^{\ast}\)</span> 落在区域内部，则
<span class="math inline">\(P_{acc}=1\)</span></li>
<li>最终估计如下</li>
</ul>
<p><span class="math display">\[
p_{VM}(\bar{\mathrm{x}})=\left[\pi r^2\
p(\mathrm{x}_{s-1}\to\mathrm{x}^\ast_s)\right](\bar{\mathrm{x}})p_{VC}(\bar{\mathrm{x}})
\]</span></p>
<h3 id="efficiency-of-different-path-sampling-techniques">4.1 Efficiency
of Different Path Sampling Techniques</h3>
<ul>
<li>启发式的指数因子的加入源于这样的一种观察，pdf
较大的区域，方差估计较小
<ul>
<li>a higher pdf most often results in a lower variance estimate</li>
</ul></li>
</ul>
<h4 id="sampling-densities">Sampling densities</h4>
<ul>
<li><span class="math inline">\(P_{acc}(\bar{\mathrm{x}})\le1\)</span>，说明 VM
的路径 pdf 最大不会超过 VC 的的 pdf</li>
<li>VM 的操作相当于在 <span class="math inline">\(\mathrm{x}_{s-1}\)</span> 的一个立体角中采样
<ul>
<li>如果 <span class="math inline">\(\mathrm{x}_{s-1}\)</span> 是
diffuse 材质的，那么结果应该和立体角中采样是一样的</li>
</ul></li>
<li>The resulting VM path pdf <span class="math inline">\(p_{VM}\)</span> can then be <strong>six or more
orders</strong> of magnitude lower than the corresponding VC pdf</li>
<li>当 <span class="math inline">\({\mathcal{A}}_{\mathcal{M}}\)</span>
区域和光源相近时，VM 的 pdf 和单项采样的 pdf 几乎相等
<ul>
<li>unidirectional sampling (US) and VM can have almost equal pdfs.</li>
<li>直观上的理解，击中光源的概率和击中 <span class="math inline">\({\mathcal{A}}_{\mathcal{M}}\)</span>
的概率一致</li>
</ul></li>
</ul>
<h4 id="path-reuse-efficiency">Path reuse efficiency</h4>
<ul>
<li>PM 在采样上效率可能并不是比 BPT 更高，但是计算上效率更高
<ul>
<li>the power of VM is its <code>computational efficiency</code></li>
</ul></li>
<li>PM 效率高的原因在于它能够用上很多之前不能使用的 light subpath
<ul>
<li>It performs conditional path concatenation, which is as cheap as
neighborhood checking. This enables the reuse of a large number of light
sub-paths at the cost of a single range search.</li>
<li>不搜索的话（只用一条路径），就找不到更多的路径</li>
</ul></li>
<li>没有 reuse 的话，PM 效果并不好</li>
</ul>
<p><img src="/2021/04/13/CG/Papers/2012/VCM/image-20210415115429711.png" style="zoom:60%;"></p>
<h2 id="a-combined-light-transport-algorithm">5. A Combined Light
Transport Algorithm</h2>
<ul>
<li>算法</li>
<li>我们已经将 PM 描述成一个一个采样过程，可以直接利用 MIS 将 PM 和 BPT
结合在一起</li>
<li>长度为 k 的路径，BPT 提供了 k+1 种采样途径，PM
<strong>额外</strong>提供了 k-1 种采样途径
<ul>
<li>实际操作中我们对端点不做连接处理</li>
<li>所以只会在中间的 k-1 个顶点处进行 PM</li>
</ul></li>
<li>这一部分我们使用一个固定大小的 <span class="math inline">\(r\)</span>，这样子的结果是有偏的</li>
</ul>
<h3 id="mathematical-formulation">5.1 Mathematical Formulation</h3>
<p><span class="math display">\[
I=\int_{\Omega}f(x)d\mu(x)
\]</span></p>
<ul>
<li>使用 MIS 结合 BPT（VC） 和 PM（VM）估计上述值</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\langle I\rangle_{MIS}&amp;=C_{VC}+C_{VM}\\
&amp;=\dfrac{1}{n_{VC}}\sum_{l=1}^{n_{VC}}\sum_{s\ge0,t\ge0}w_{VC,s,t}(\bar{\mathrm{x}}_l)\langle
I\rangle_{VC}(\bar{\mathrm{x}}_l)\\
&amp;+\dfrac{1}{n_{VM}}\sum_{l=1}^{n_{VC}}\sum_{s\ge2,t\ge2}w_{VM,s,t}(\bar{\mathrm{x}}_l)\langle
I\rangle_{VM}(\bar{\mathrm{x}}_l)
\end{aligned}
\]</span></p>
<ul>
<li>s：light subpath 的结点数</li>
<li>t：eye subpath 的结点数</li>
<li>权重设置如下（v can be VC or VM）</li>
</ul>
<p><span class="math display">\[
w_{v,s,t}(\bar{\mathrm{x}})=\dfrac{n_v^\beta
p_{v,s,t}^\beta(\bar{\mathrm{x}})}{n_{VC}^\beta\sum_{s&#39;\ge0,t&#39;\ge0}
p_{VC,s&#39;,t&#39;}^\beta(\bar{\mathrm{x}})+n_{VM}^\beta\sum_{s&#39;\ge2,t&#39;\ge2}
p_{VM,s&#39;,t&#39;}^\beta(\bar{\mathrm{x}})}
\]</span></p>
<h3 id="implementation">5.2 Implementation</h3>
<ul>
<li>采样的代价很大
<ul>
<li>The BPT implementation according to Veach [1997] reuses sub-paths by
connecting every eye sub-path vertex to every vertex on one light
sub-path.</li>
</ul></li>
<li>thanks to the low cost of range query, an eye sub-path vertex can be
potentially merged with vertices of <strong>a large number of</strong>
pre-generated light sub-paths.</li>
<li>为了提高复用率，我们把算法分为两个阶段
<ul>
<li>sampling of the light and eye sub-paths</li>
</ul></li>
<li>L：11-13
<ul>
<li>看当前结点是否自发光，如果自发光，则收集 radiance</li>
</ul></li>
<li>为了减少相关性，我们不保存 light subpath
的第一个顶点位置，修改为重新对它随机采样
<ul>
<li>To reduce correlation, we follow Veach [1997] and do not store the
first vertex of a light sub-path, instead connecting every eye vertex to
a new, randomly sampled point on a light source.</li>
</ul></li>
<li>评估权重的时候，把信息存储在节点上以提高效率
<ul>
<li>Most of the terms required to evaluate path contributions and pdfs
are stored with the sub-path vertices for improved efficiency.</li>
</ul></li>
<li>伪代码如下</li>
</ul>
<p><img src="/2021/04/13/CG/Papers/2012/VCM/image-20210415141636262.png" style="zoom:67%;"></p>
<h2 id="achieving-consistency">6. Achieving Consistency</h2>
<ul>
<li>我们的方法是有偏的（blur），但是是一致的</li>
<li>通过渐进的减小半径 r 、累计所有的结果实现</li>
<li>最终的结果通过前 N 次独立的采样渲染结果平均得到
<ul>
<li>每一轮的计算和上面提到的单次估计相同（5.1）</li>
</ul></li>
</ul>
<p><span class="math display">\[
\langle I\rangle_{VCM}=\dfrac{1}{N}\sum_{i=1}^N(C_{VC,i}+C_{VM,i})
\]</span></p>
<ul>
<li>每一轮新的迭代使用新的 eye subpath 以及 light subpath，减小半径
<ul>
<li><span class="math inline">\(r_i=r_1\sqrt{i^{\alpha-1}}\)</span>,
where <span class="math inline">\(\alpha\in(0,1)\)</span></li>
</ul></li>
</ul>
<h3 id="asymptotic-error-analysis">6.1 Asymptotic Error Analysis</h3>
<ul>
<li>方差渐进分析</li>
<li>MSE
<ul>
<li>BPT：<span class="math inline">\(O(\dfrac{1}{N})\)</span></li>
<li>PPM：<span class="math inline">\(O(\dfrac{1}{N^\frac{2}{3}}),\alpha=\dfrac23\)</span></li>
</ul></li>
<li>理论上我们的 MSE 应该介于上面两者之间</li>
<li>VC：无偏的</li>
</ul>
<p><span class="math display">\[
\mathrm{Var}[\langle I\rangle_{VC}]=O(1),\ \mathrm{Bias}[\langle
I\rangle_{VC}]=0
\]</span></p>
<ul>
<li>VM：借用 Knaus and Zwicker [2011] 的结论
<ul>
<li>半径缩减采用上面的方案</li>
</ul></li>
</ul>
<p><span class="math display">\[
\mathrm{Var}[\langle I\rangle_{VM}]=O(\dfrac{1}{r^2_i}),\
\mathrm{Bias}[\langle I\rangle_{VM}]=O(r_i^2)
\]</span></p>
<p><span class="math display">\[
\mathrm{Var}[\langle I\rangle_{VM}]=O(i^{1-\alpha}),\
\mathrm{Bias}[\langle I\rangle_{VM}]=O(i^{\alpha-1})
\]</span></p>
<ul>
<li>计算各种参数的量级</li>
<li><span class="math inline">\(p_{VC,s,t}(\mathrm{x})=O(1)\)</span></li>
<li><span class="math inline">\(p_{VM,s,t}(\mathrm{x})=O(r_i^2)=O(i^{\alpha-1})\)</span></li>
<li><span class="math inline">\(w_{VC,s,t}(\bar{\mathrm{x}})=\dfrac{O(1)}{O(1)+O(i^{\beta(\alpha-1)})}=O(1)\)</span>
<ul>
<li><span class="math inline">\(\alpha\in(0,1)\)</span></li>
</ul></li>
<li><span class="math inline">\(w_{VM,s,t}(\bar{\mathrm{x}})=\dfrac{O(i^{\beta(\alpha-1)})}{O(i^{\beta(\alpha-1)})+O(1)}=O(i^{\beta(\alpha-1)})\)</span>
<ul>
<li><span class="math inline">\(\alpha\in(0,1)\)</span></li>
</ul></li>
</ul>
<h4 id="variance">Variance</h4>
<ul>
<li>方差估计，由于每一步的采样都是独立的</li>
</ul>
<p><span class="math display">\[
\mathrm{Var}[\langle
I\rangle_{VCM}]=\dfrac{1}{N^2}\sum_{i=1}^N(\mathrm{Var}[C_{VC,i}]+\mathrm{Var}[C_{VM,i}])
\]</span></p>
<ul>
<li>VC，VM 认为是独立采样，所以能拆开</li>
<li>我们假定 <span class="math inline">\(2\beta(\alpha-1)-\alpha&lt;-1\)</span>
<ul>
<li>实际操作我们会让 <span class="math inline">\(\beta\ge1\)</span>，所以能保证</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\mathrm{Var}[\langle I\rangle_{VCM}]\\
=&amp;\dfrac{1}{N^2}\sum_{i=1}^N\left(O(1)O(1)+O(i^{2\beta(\alpha-1)})O(i^{1-\alpha})\right)\\
=&amp;O(N^{-1})+O(i^{2\beta(\alpha-1)-\alpha})\\
=&amp;O(N^{-1})\\
\end{aligned}
\]</span></p>
<h4 id="bias">Bias</h4>
<ul>
<li>类似的估计</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\mathrm{Bias}[\langle I\rangle_{VCM}]\\
=&amp;\dfrac{1}{N}\sum_{i=1}^N(\mathrm{Bias}[C_{VC,i}]+\mathrm{Bias}[C_{VC,i}])\\
=&amp;O(i^{(\beta+1)(\alpha-1)})\\
\end{aligned}
\]</span></p>
<h4 id="mse">MSE</h4>
<ul>
<li>假定 <span class="math inline">\(\alpha\le\dfrac{2\beta+1}{2\beta+2}\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\mathrm{MSE}[\langle I\rangle_{VCM}]\\
=&amp;\mathrm{Var}[\langle I\rangle_{VCM}]+\mathrm{Bias}^2[\langle
I\rangle_{VCM}]\\
=&amp;O(N^{-1})+O(N^{2(\beta+1)(\alpha-1)})\\
=&amp;O(N^{-1})\\
\end{aligned}
\]</span></p>
<ul>
<li>令 <span class="math inline">\(\beta=1\)</span>，此时对于任意的
<span class="math inline">\(\alpha\in(0,0.75)\)</span>
都满足上面的条件</li>
<li>比 PPM 更快</li>
<li>PPM 的估计如下</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\mathrm{MSE}[\langle I\rangle_{VCM}]\\
=&amp;\mathrm{Var}[\langle I\rangle_{VCM}]+\mathrm{Bias}^2[\langle
I\rangle_{VCM}]\\
=&amp;O(N^{-\alpha})+O(N^{2(\alpha-1)})\\
\le&amp;O(N^{-\frac{2}{3}})\\
\end{aligned}
\]</span></p>
<h4 id="discussion-1">Discussion</h4>
<p><img src="/2021/04/13/CG/Papers/2012/VCM/image-20210415170523674.png" style="zoom:50%;"></p>
<ul>
<li>收敛更快，直观上我们可以理解为 VM
随着跌打的增加贡献逐渐减小，几乎等同于 BPT</li>
<li>VM
初始方差更小，于是能够在有限的样本内很快得到一张可以接受的图片</li>
</ul>
<h2 id="result">7.Result</h2>
<ul>
<li>很多效果图</li>
</ul>
<h2 id="discussion-2">8.DIscussion</h2>
<ul>
<li>参数选择：<span class="math inline">\(r1\)</span>：0:01%-0:07% of
the scene’s bounding box，<span class="math inline">\(\alpha=\dfrac{2}{3}\)</span>
<ul>
<li>为了做对比实验</li>
</ul></li>
<li>实际使用的时候，建议参数
<ul>
<li>VCM we recommend setting <span class="math inline">\(r1\)</span>
smaller than for PPM and <span class="math inline">\(\alpha=0.75\)</span></li>
</ul></li>
<li>限制
<ul>
<li>不好处理点光源，不能采样</li>
<li>对于 PM 和 BPT 都不能很好处理的场景，VCM 也不能很好的处理
<ul>
<li>caustics falling on a highly glossy surface</li>
</ul></li>
</ul></li>
</ul>
<h2 id="a-additional-vertex-merging-derivations">A Additional Vertex
Merging Derivations</h2>
<h3 id="a.1-contribution-function-for-extended-paths">A.1 Contribution
Function for Extended Paths</h3>
<h4 id="pm-pixel-measurement-estimator.">PM pixel measurement
estimator.</h4>
<p><img src="/2021/04/13/CG/Papers/2012/VCM/image-20210415173036033.png" style="zoom: 80%;"></p>
<h4 id="path-integral-and-contribution-function">Path integral and
contribution function</h4>
<ul>
<li><span class="math inline">\(Q\)</span> 项中的 <span class="math inline">\(K\)</span> （kernel）会引发模糊现象</li>
</ul>
<p><img src="/2021/04/13/CG/Papers/2012/VCM/image-20210415174147620.png" style="zoom:80%;"></p>
<h3 id="a.2-reducing-the-path-integral-dimension">A.2 Reducing the Path
Integral Dimension</h3>
<ul>
<li>拆解为两部分，正常采样 + 贡献项
<ul>
<li>equation (20)</li>
</ul></li>
</ul>
<p><img src="/2021/04/13/CG/Papers/2012/VCM/image-20210415175052691.png" style="zoom:80%;"></p>
<ul>
<li>贡献项的计算
<ul>
<li>MC 估计即可</li>
</ul></li>
</ul>
<p><img src="/2021/04/13/CG/Papers/2012/VCM/image-20210415175403612.png" style="zoom:80%;"></p>
<ul>
<li>VM 的估计</li>
</ul>
<p><img src="/2021/04/13/CG/Papers/2012/VCM/image-20210415180739524.png" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>CG.Paper</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>(论文)[2011] RTSAH Traversal Order for Occlusion Rays</title>
    <url>/2021/09/13/CG/Papers/2011/rtsah/</url>
    <content><![CDATA[<h1 id="rtsah-traversal-order-for-occlusion-rays">RTSAH Traversal Order
for Occlusion Rays</h1>
<h2 id="简要说明">简要说明</h2>
<ul>
<li>在 SAH 的基础上，加上一个可见性函数 V，进行对于 occlusion rays
的判定优化</li>
</ul>
<h2 id="introduction">1. Introduction</h2>
<ul>
<li>RTSAH
<ul>
<li>ray termination surface area heuristic</li>
</ul></li>
<li>能够加速树结构中具体遮挡结点的寻找
<ul>
<li>启发式的展开某个子结点，而不是传统的先展开近的子结点</li>
<li>可以扩展到半透明的介质（避免了和半透明物体的再次求交）</li>
</ul></li>
<li>2x speedups</li>
<li>Unlike <strong>radiance rays</strong> where we are interested in
<strong>the closest hit object</strong>, for <strong>occlusion
rays</strong>, we are interested in <strong>whether any hit
occurs</strong>.</li>
<li>一些定义
<ul>
<li>occlusion rays：只返回可见性，而且不能改变方向</li>
<li>radiance rays：scattering, reflection, refraction, ...</li>
</ul></li>
<li>对于 occlusion rays
我们只关心是否相交，因此遍历子结点的顺序可以不从近到远</li>
</ul>
<h2 id="background">2. background</h2>
<h3 id="surface-area-heuristic">Surface area heuristic</h3>
<ul>
<li>表面积启发式算法
<ul>
<li><a href="https://www.cnblogs.com/lookof/p/3546320.html">关于 SAH
的介绍</a></li>
</ul></li>
<li>SAH 的基本假设
<ul>
<li>所有的光线在整个场景中均匀分布</li>
<li>光线不会被遮挡（击中一个物体后继续传播）</li>
</ul></li>
<li>有如下概率公式</li>
</ul>
<p><span class="math display">\[
P(\mathrm{child\ hit|parent\
hit})=\dfrac{\mathrm{SurfaceArea(child)}}{\mathrm{SurfaceArea(parent)}}
\]</span></p>
<ul>
<li>我们进行如下定义</li>
</ul>
<p><span class="math display">\[
P_x=P(\mathrm{node\ x\ hit|x&#39;parent\ hit})
\]</span></p>
<ul>
<li>我们假设每一次求交（intersection test）和结点遍历（node traversal
step）的代价是一个固定值，<span class="math inline">\(T_{\mathrm{intersection}},T_{\mathrm{step}}\)</span></li>
<li>结点遍历代价如下（递归定义）
<ul>
<li><span class="math inline">\(N_x\)</span> 表示结点 <span class="math inline">\(x\)</span> 中的 object 个数</li>
<li><span class="math inline">\(l,r\)</span> 表示左子树与右子树</li>
</ul></li>
</ul>
<p><span class="math display">\[
C_{\mathrm{node}}=\left\{  
\begin{array}{**ll**}
P_lC_l+P_rC_r+T_{\mathrm{step}} &amp; \mathrm{if\ an\ inner\ node,}\\
N_{\mathrm{parent}}T_{\mathrm{intersection}}+T_{\mathrm{step}} &amp;
\mathrm{if\ a\ leaf.} \\
\end{array}  
\right.
\]</span></p>
<ul>
<li>在实际进行估计的时候，计算 <span class="math inline">\(C_{\mathrm{cost}}\)</span> 的时候可以把 <span class="math inline">\(C_l,C_r\)</span> 当作叶子结点处理
<ul>
<li>WALD I., HAVRAN V.: On building fast kd-trees for ray tracing, and
on doing that in O(N logN). In Symposium on Interactive Ray Tracing
(2006), pp. 61–70.</li>
</ul></li>
<li>BSP vs BVH
<ul>
<li>BSP(binary space partitioning)、BVH(bounding volume hierarchy)</li>
<li>BSP：没有重叠，按照从近到远的顺序找到的第一个交点就是结果</li>
<li>BVH：可能有重叠，找到第一个交点之后可能还需要进一步判断
<ul>
<li>判断能否提前停止树上的查找就是一个比较强的优化（SAH
不考虑这个）</li>
<li>SAH 加入这个判断反而可能变慢
<ul>
<li>HAVRAN V.: Heuristic Ray Shooting Algorithms. PhD thesis, Faculty of
Electrical Engineering, Czech Technical University in Prague, 2001.
2</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="rtsah">3. RTSAH</h2>
<ul>
<li>我们扩展了 SAH 算法，认为每一个结点都有一个连续的可见性函数 <span class="math inline">\(V\)</span></li>
<li>简单化，我们认为非空的叶子结点（leaf）是完全不透明的（<span class="math inline">\(V=0\)</span>）,空的叶子结点是完全透明的（<span class="math inline">\(V=1\)</span>）
<ul>
<li>内部节点（interior node）由一些空的和非空的结点组成，<span class="math inline">\(V\)</span> 介于零一之间</li>
<li><a href="#define_v">具体定义在下面</a></li>
</ul></li>
<li><strong>在树中只要找到了一个结点相交，那么立即停止遍历</strong>
<ul>
<li>因此如果遍历的时候进入了其中一个子结点，那么一定不会进入另一个子结点</li>
</ul></li>
<li><span class="math inline">\(P_{lr}\)</span>
表示光线同时穿过左右两个子结点的概率
<ul>
<li><span class="math inline">\(P_{jl}=P_l-P_{lr}\)</span>：只穿过左子结点，不穿过右子结点的概率</li>
<li><span class="math inline">\(P_{jr}=P_r-P_{lr}\)</span>：只穿过左子结点，不穿过右子结点的概率</li>
<li><span class="math inline">\(P_e=1-(P_{jl}+P_{jr}+P_{lr})\)</span>：都未击中的概率</li>
</ul></li>
<li>步骤（packetized ranged traversal）
<ul>
<li>我们先进入左子结点，看看是否存在光线和这个结点相交</li>
<li>如果所有的光线都和这个结点相交，那么就不需要进行和另外一个结点的相交测试（intersection
test）</li>
<li>如果只有部分光线或者没有光线和这个结点相交，那么就需要继续对另外一个结点进行相交测试</li>
</ul></li>
<li>我们可以得到优先遍历左子结点的代价函数
<ul>
<li><span class="math inline">\(T_{\mathrm{step}}\)</span>：left
bounding box</li>
<li><span class="math inline">\(P_lC_l\)</span>：遍历左子结点的代价（概率 <span class="math inline">\(\times\)</span> 代价）</li>
<li><span class="math inline">\((P_{jr}+P_{lr}V_l+P_e)T_{\mathrm{step}}\)</span>：right
bounding box
<ul>
<li><span class="math inline">\(P_{jr}\)</span>：没有光线和左结点（的包围盒）相交</li>
<li><span class="math inline">\(P_{lr}V_l\)</span>：和左结点（的包围盒）相交，但是没有和左结点中的物体相交</li>
</ul></li>
<li><span class="math inline">\((P_{jr}+P_{lr}V_l)C_{r}\)</span>：遍历右子结点的代价</li>
</ul></li>
</ul>
<p><span class="math display">\[
leftFirst=T_{\mathrm{step}}+P_lC_l+(P_{jr}+P_{lr}V_l)(T_{\mathrm{step}}+C_r)+P_eT_{\mathrm{step}}
\]</span></p>
<ul>
<li>右子结点优先</li>
</ul>
<p><span class="math display">\[
rightFirst=T_{\mathrm{step}}+P_rC_r+(P_{jl}+P_{lr}V_r)(T_{\mathrm{step}}+C_l)+P_eT_{\mathrm{step}}
\]</span></p>
<ul>
<li>对于 radiance rays，我们希望优先进入距离光线起点比较近的子结点
<ul>
<li>我们假定光线是随机的、相互独立的</li>
<li>我们假定每次都优先遍历比较近的子结点，代价如下</li>
</ul></li>
</ul>
<p><span class="math display">\[
C_{\mathrm{node}}=\dfrac{1}{2}(leftFirst+rightFirst)
\]</span></p>
<ul>
<li>对于 occlusion
rays，我们希望优先进入的结点导致的结果是代价较小的（代价与光线无关）</li>
</ul>
<p><span class="math display">\[
C_{\mathrm{node}}=\min(leftFirst+rightFirst)
\]</span></p>
<ul>
<li>叶子节点的代价和上面相同</li>
</ul>
<p><span class="math display">\[
C_{\mathrm{leaf\
node}}=N_{\mathrm{parent}}T_{\mathrm{intersection}}+T_{\mathrm{step}}
\]</span></p>
<ul>
<li><span id="define_v">可见性函数 <span class="math inline">\(V\)</span> 的定义如下</span></li>
</ul>
<p><span class="math display">\[
V_{\mathrm{node}}=\left\{  
\begin{array}{**ll**}
P_{jl}V_l+P_{jr}V_r+P_{lr}V_lV_r+P_e &amp; \mathrm{if\ an\ inner\
node,}\\
0 &amp; \mathrm{if\ a\ nonempty\ leaf,} \\
1 &amp; \mathrm{if\ a\ empty\ leaf.} \\
\end{array}  
\right.
\]</span></p>
<ul>
<li><span class="math inline">\(\dfrac{P_{lr}}{P_{l}}\)</span>
可以看成是从左子结点离开到右子结点的一个 rays（energy）的一个辐射因子
<ul>
<li>我么可以通过 SAH 的方式计算 <span class="math inline">\(P_l,P_r\)</span>，因此只需要找到上面说的辐射因子，便能够计算出
<span class="math inline">\(P_{lr}\)</span></li>
<li>接着也能够计算出其他剩余的量：<span class="math inline">\(P_{jl}=P_l-P_{lr}\)</span> 等</li>
</ul></li>
<li>如何计算辐射因子？
<ul>
<li>论文：Practical applications of form factor computation in lighting
calculations</li>
<li>方法如下
<ul>
<li>decompose the node bounding boxes into their rectangular faces and
then analytically compute the form factors between all valid face pairs
and for the overlapped region (see [Cho02] for a good survey of the
relevant equations).</li>
<li><span style="color:red;font-weight:bold">TODO</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="bsp">BSP</h3>
<ul>
<li>对于 BSP 结构，代价函数是类似的</li>
<li><span class="math inline">\(P_e=0\)</span>，恰好把整个父节点的空间划分给了子结点</li>
<li><span class="math inline">\(P_{lr}\ne0\)</span>，可能出现光线斜穿的情况</li>
<li>BSP 不需要上面的辐射因子就能够计算 <span class="math inline">\(P_{lr}\)</span>：<span class="math inline">\(P_{lr}=P_l+P_r-1\)</span></li>
<li>occlusion rays
<ul>
<li><span class="math inline">\(P_e=0\)</span></li>
<li>我们不需要进行对另外一个子结点的包围盒求交测试（不和第一个相交，一定和第二个相交）</li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
leftFirst
&amp;=T_{\mathrm{step}}+P_lC_l+(P_{jr}+P_{lr}V_l)C_{r}\\
&amp;=T_{\mathrm{step}}+(P_{jl}C_l+P_{lr}C_l)+(P_{jr}C_r+P_{lr}V_lC_r)\\
&amp;=T_{\mathrm{step}}+P_{jl}C_l+P_{jr}C_r+P_{lr}(C_l+V_lC_r)\\
\end{aligned}
\]</span></p>
<p><span class="math display">\[
C_{\mathrm{cost}}=T_{\mathrm{step}}+P_{jl}C_l+P_{jr}C_r+P_{lr}\min\left\{C_l+V_lC_r,C_r+V_rC_l\right\}
\]</span></p>
<h3 id="approximate-bvh-rtsah">Approximate BVH RTSAH</h3>
<ul>
<li>The BVH preprocess cost can be lowered at the expense of rendering
performance by approximating the probabilities instead of finding them
by sampling.
<ul>
<li>感觉是在说辐射因子的估计</li>
</ul></li>
<li>在实时渲染中，我们可以假设 <span class="math inline">\(P_e=0\)</span>，可以起到一个加速的效果</li>
</ul>
<h2 id="choosing-traversal-order-of-occlusion-rays">4. Choosing
Traversal Order of Occlusion Rays</h2>
<ul>
<li>按照上面说的方式比较即可，对于 BSP 树，可以优化（上面提到了）</li>
</ul>
<h3 id="storage-overhead">Storage overhead</h3>
<ul>
<li>我们只需要知道优先遍历那一个结点即可，而不在意具体的代价值的大小，因此只需要使用一个布尔变量记录即可（可以压缩到其他变量的某一个
bit 中）</li>
</ul>
<h3 id="attenuated-occlusion-rays">Attenuated occlusion rays</h3>
<ul>
<li>半透明材质只是会使得光线有所衰减，而不会让它停止</li>
<li>我们在判断 occlusion rays 的时候，只需要将上面的定义的函数 <span class="math inline">\(V\)</span> 修改一下
<ul>
<li>如果叶子结点包含的所有物体都是透明材质的，我们让它的 <span class="math inline">\(V=1\)</span></li>
</ul></li>
<li>对于<strong>只报告可见性</strong>的 occlusion
rays，不按照从前往后的顺序去遍历，不会导致半透明物体的不正确渲染</li>
<li>一个标准的从前向后处理半透明物体的 ray
tracer，在加速结构中就应该处理好了半透明物体
<ul>
<li>击中半透明物体之后，应该投射出一条新的光线，继续和加速结构求交</li>
<li>这样我们就不需要对其进行特殊处理</li>
</ul></li>
<li>如果加速结构中没有实现，那么即使是从前向后遍历也可能会出现乱序的问题
<ul>
<li>一个结点内部的物体是没有顺序的，一个物体可能跨越多个结点</li>
<li>一个简单的解决方案可以是，记录所有的交点，直到找到新的交点之后再进行着色处理</li>
</ul></li>
</ul>
<h2 id="conclusion">8. conclusion</h2>
<ul>
<li>We presented <strong>an improved version of the SAH</strong>, which
we call the RTSAH, that takes into account <strong>ray
termination</strong> and gives the <strong>expected traversal cost of
radiance and occlusion rays through a tree</strong>. We then showed how
the RTSAH can be used to guide the traversal of occlusion rays through a
tree so that an intersection can be more efficiently located. The RTSAH
traversal can try to avoid attenuating materials for a further
improvement in traversal efficiency. The RTSAH can be computed faster
than the tree can be built and there is practically no storage or
rendering overhead for using it. For scenes that comprise mostly of
occluded rays, the RTSAH traversal can give a substantial performance
increase.</li>
</ul>
]]></content>
      <categories>
        <category>CG.Paper</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Paper</tag>
        <tag>occlusion</tag>
        <tag>可见性</tag>
        <tag>SAH</tag>
      </tags>
  </entry>
  <entry>
    <title>(论文)[2002] Exact From-Region Visibility Culling</title>
    <url>/2021/09/25/CG/Papers/2002/From-Region.Visibility/</url>
    <content><![CDATA[<h1 id="exact-from-region-visibility-culling">Exact From-Region
Visibility Culling</h1>
<ul>
<li>S. Nirenstein, E. Blake and J. Gain</li>
<li>Department of Computer Science, University of Cape Town, Cape-Town,
Rondebosch 7701, South Africa</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>对于两个多边形之间的可见性判断，我们将能够同时穿过这两个多边形的直线集合映射到普吕克空间中的一个点集
<span class="math inline">\(A\)</span> ，同时我们对每一个
occluder，将通过他的直线也映射到普吕克空间中的一个点集，在 <span class="math inline">\(A\)</span> 中减去这个点集，直至 <span class="math inline">\(A\)</span> 为空（不可见）或者处理完所有的
occluder（可见）</li>
</ul>
<h2 id="摘要">摘要</h2>
<ul>
<li>可以处理百万计的多边形</li>
<li>关键思想
<ul>
<li>The essence of our idea is to represent 3-D polygons and the
stabbing lines connecting them in a 5-D Euclidean space derived from
Plücker space and then to perform geometric subtractions of occluded
lines from the set of potential stabbing lines.</li>
<li>将 3 维的多边形和连接他们之间的 stabbing lines 用 5
维的欧几里得空间（派生自普吕克空间）表示，然后在潜在的 stabbing lines
的集合中做遮挡线的减法</li>
</ul></li>
<li>建立了 <strong>query architecture</strong></li>
</ul>
<h2 id="introduction">1. Introduction</h2>
<ul>
<li>一般有两种方式
<ul>
<li>run-time：一般是单点对于场景的可见性</li>
<li>pre-process：建立任何点（小区域）的可见几何体集合</li>
</ul></li>
</ul>
<h3 id="from-region-visibility">From-Region visibility</h3>
<ul>
<li>将视点空间（VPS：view-point
space）划分为<strong>有限个区域</strong>（region/cell）
<ul>
<li>而不是处理无限的可能的相机位置</li>
</ul></li>
<li>好处
<ul>
<li>能够将运行时的计算开销转移到预处理中</li>
</ul></li>
<li>问题
<ul>
<li>由于是预处理，只能够处理一些<strong>静态的场景</strong></li>
</ul></li>
</ul>
<h3 id="from-point-visibility">From-point visibility</h3>
<ul>
<li>计算成本相对较低，可以在逐帧渲染的时计算（run-time）
<ul>
<li>因此适合在动态场景中使用</li>
</ul></li>
</ul>
<h3 id="一个分类">一个分类</h3>
<p><img src="/2021/09/25/CG/Papers/2002/From-Region.Visibility/image-20211005164143617.png" alt="image-20211005164143617" style="zoom:67%;"></p>
<ul>
<li><strong>conservative</strong>：保守的
<ul>
<li>高估可见性，从而带来 false visibility 的问题</li>
<li>会将一些不可见的多边形带到渲染那一步</li>
</ul></li>
<li><strong>aggressive</strong>：激进的
<ul>
<li>低估可见性，带来 false invisibility 的问题</li>
<li>会导致最终结果图片<strong>错误</strong></li>
<li>只有在如下情况才可用
<ul>
<li>误差部分相对较小，可以接受</li>
<li>算法特别快</li>
<li>场景在使用保守方法的情况下先很难有效求解</li>
</ul></li>
</ul></li>
<li><strong>approximate</strong>：估计的
<ul>
<li>会出现 false visibility、false invisibility
的问题，一般只用于需要快速出结果的时候</li>
</ul></li>
<li><strong>exact</strong>：精确的
<ul>
<li>结果产生的图片是准确的，渲染的时候没有一个多边形是多余的</li>
<li>本质上也是保守的，因为把一个区域看成了一个整体（实际物体可能较小）</li>
</ul></li>
</ul>
<h3 id="精确渲染的优势">精确渲染的优势</h3>
<ul>
<li>不是场景依赖的，对所有的场景都能够用一样的方式解决
<ul>
<li>其他方式可能是场景依赖的</li>
</ul></li>
<li>可以提供一个 benchmark，用于评估其他的可见性提出算法
<ul>
<li>一个更准确的度量，可以有以下指标，而不是之前的知识粗糙的计算被剔除三角形的百分比
<ul>
<li>type(false visibility or false invisibility),</li>
<li>distribution(clustered or widespread)</li>
<li>exact magnitude</li>
<li>visibility error</li>
</ul></li>
</ul></li>
</ul>
<h3 id="本文">本文</h3>
<ul>
<li>第一次提出了一个针对现实场景的、精确的可见性剔除算法
<ul>
<li>1.5M 个三角形</li>
</ul></li>
<li>相较之前的方法有 3 个数量级的改进</li>
<li>虽然可以处理大型的场景，但是预处理成本很高</li>
</ul>
<h3 id="本文的贡献">本文的贡献</h3>
<ul>
<li><strong>Localised Exact Visibility</strong>
<ul>
<li>能够精确计算两个凸多边形之间的可见性</li>
</ul></li>
<li><strong>Query Driven Architecture</strong>
<ul>
<li>会保存之前计算的结果，用于之后的计算</li>
</ul></li>
</ul>
<h2 id="previous-work">2. previous work</h2>
<ul>
<li>From-Point Visibility 方面的 survey
<ul>
<li>D. Cohen-Or, Y. Chrysanthou, C. T. Silva, and F. Durand. A survey of
visibility for walkthrough applications. Course 30, SIGGRAPH, August
2001.</li>
<li>F. Durand. 3D Visibility, analysis and applications. PhD thesis, U.
Joseph Fourier, 1999. http://graphics.lcs.mit.edu/fredo.</li>
<li>H. Zhang. Effective Occlusion Culling for the Interactive Display of
Arbitrary Models. PhD thesis, University of North Carolina at Chapel
Hill, 1998</li>
</ul></li>
</ul>
<h3 id="保守策略准确的图片">保守策略（准确的图片）</h3>
<ul>
<li>Cell-portal rendering
<ul>
<li>试图建立所有 cell 之间的相对可见性，可见即在两个 cell
之间存在一条光线</li>
<li>Teller
提出了一个解析的方法解决这个问题，同时他将其扩展了，使其能够判断可见的
cell 的哪一部分才是可见的</li>
<li>对建筑场景很有效，但不是通用的解决方案</li>
<li>对组合复杂度比较低的场景有效</li>
</ul></li>
<li>Cohen-Or、Saona-Vásquez 等提出了一个更加通用但是保守的方案
<ul>
<li>对于一个物体和一个
view-cell，当且仅当被<strong>一个多边形</strong>挡住（所有 view-cell
中的点都看不见这个物体），这个物体才被认为是不可见的</li>
<li>过于保守了，因此只有在 view-cell
相对场景中的多边形很小的情况下才能得到比较好的效果</li>
<li>精细场景则需要大量的 view-cell，因此效率很低</li>
</ul></li>
<li>因此有必要将小的 occluder 进行聚合</li>
<li>Durand 提出一种通用方法，采用扩展投影算子（extended projection
operator）的方法</li>
<li>Law、Tan 提出遮挡简化（occlusion preserving
simplification）的方式生成更粗糙的细节、更大的多边形
occluder，同时保持了保守性
<ul>
<li>不考虑有这个粗糙表示产生的遮挡</li>
<li><strong><span style="color:red">没太明白</span></strong></li>
</ul></li>
<li>Koltun
等人利用<strong>分隔线</strong>构建更大更有效的<strong>虚拟遮挡器</strong>来代表许多较小的遮挡器
<ul>
<li>不需要保存每一个 view-cell 的可见集合</li>
</ul></li>
<li>Wonka 提出了一个保守的 2.5D 的方案，收缩
occluders，通过采样的方法求解可见性
<ul>
<li>采样数足够多则趋向于精确解</li>
</ul></li>
</ul>
<h3 id="激进策略">激进策略</h3>
<ul>
<li>基于 from-point 的策略，会产生 false invisibility
的错误，这些策略基于的想法是将那些对最终图像贡献很小的物体在渲染之前去除</li>
<li>Andújar 使用几乎不可见集合（hardly visible
sets），去除那些只有部分可见的物体集合</li>
<li>Klosowski and Silva 提出优先层投影算法（prioritised layer projection
algorithm），启发式的先绘制可见的物体，因此即使算法过早停止也能够保证渲染出来的结果还不错</li>
<li>Gotsman 提出基于采样的可见性算法
<ul>
<li>使用 5 个维度（3D 空间 + 2D 角度），每一个 5D 的 cell
对应三维空间中的一个 beam
<ul>
<li>2D 角度是为了加速剔除</li>
</ul></li>
<li>投射足够多的光线，在某个统计模型下，推断出物体可见、不可见、还是需要继续投射光线</li>
<li>trade-off：预处理需要花费的时间，准确率</li>
</ul></li>
</ul>
<h3 id="精确策略">精确策略</h3>
<ul>
<li>一般是以某种结构构建双线空间（dual line
space），直接暴露出可见性事件（visibility event）
<ul>
<li>A visibility event occurs when a topological change in visibility
occurs in the scene.</li>
</ul></li>
<li>一些结构
<ul>
<li>aspect graph</li>
<li>3D visibility complex</li>
<li>the visibility map</li>
</ul></li>
<li>Teller：Plücker parameterisation of line space.
<ul>
<li>算法有效性受到场景复杂度的限制</li>
</ul></li>
<li>Durand：直接计算可见性实体的低维元素（骨架），构建出可见性事件的表面
<ul>
<li>这样，由于简化导致的误差都是局部的，鲁棒性更强</li>
</ul></li>
<li>Koltun：使用 dual ray-space 重新表示了两个部分之间的光线
<ul>
<li>occlusion：遮挡光线的空间是否包含了所有在 view-cell
和物体之间的光线</li>
</ul></li>
</ul>
<h3 id="plücker-line-space">2.1 Plücker Line Space</h3>
<ul>
<li>普吕克线性空间</li>
<li>普吕克空间是格拉斯曼坐标系统（Grassmann coordinate
system）的特殊情况
<ul>
<li>Grassmann coordinates allow for the parameterisation of a
k-dimensional affine sub-space embedded in an n-dimensional space as a
point in a projective <span class="math inline">\({k+1\choose
n+1}-1\)</span> dimensional space.</li>
<li>什么玩意儿？</li>
</ul></li>
</ul>
<h4 id="普吕克空间">普吕克空间</h4>
<ul>
<li>其他补充可以查看<a href="/2021/10/07/Math/Plücker-Coordinates/">文章</a></li>
<li>lines（k=1），<span class="math inline">\(\mathbb{R}^3\)</span>（n=3），投影的 5 维空间
<span class="math inline">\(\mathbb{P}^5\)</span></li>
<li>三维空间中的有向直线 <span class="math inline">\(l\)</span>，经过两点 <span class="math inline">\(P(p_x,p_y,p_z),Q(q_x,q_y,q_z)\)</span></li>
<li>映射到普朗克空间中得到 <span class="math inline">\(\Pi(l)=(\pi_1,\pi_2,\pi_3,\pi_4,\pi_5,\pi_6)\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\pi_1&amp;=q_x-p_x\\
\pi_2&amp;=q_y-p_y\\
\pi_3&amp;=q_z-p_z\\
\pi_4&amp;=q_zp_y-q_yp_z\\
\pi_5&amp;=q_xp_z-q_zp_x\\
\pi_6&amp;=q_yp_x-q_xp_y\\
\end{aligned}
\]</span></p>
<h5 id="几何理解">几何理解</h5>
<ul>
<li>我们定义 <span class="math inline">\(d=p-q,m=p\times
q\)</span>，通过 <span class="math inline">\(d\)</span> 和 <span class="math inline">\(m\)</span> 能够唯一确定一条有向直线
<ul>
<li><span class="math inline">\(d\)</span> 确定直线方向</li>
<li><span class="math inline">\(m\)</span> 确定直线位置</li>
</ul></li>
<li>6 个维度对应普吕克坐标</li>
</ul>
<h5 id="代数理解">代数理解</h5>
<ul>
<li>P, Q 的齐次坐标表示为 <span class="math inline">\(P(p_x,p_y,p_z,1),Q(q_x,q_y,q_z,1)\)</span></li>
<li>定义普吕克坐标为 <span class="math inline">\(\pi_{ij}=p_iq_j-p_jq_i\)</span>
<ul>
<li><span class="math inline">\(\pi_{ii}=0,\pi_{ij}=-\pi_{ji}\)</span></li>
</ul></li>
<li>因此只有 6 个独立变量，对应普吕克坐标</li>
</ul>
<h5 id="二元映射">二元映射</h5>
<ul>
<li>定义二元映射：<span class="math inline">\(D_{\pi}(x)\)</span>，其中
<span class="math inline">\(\pi,x\in\mathbb{P}^{5}\)</span></li>
</ul>
<p><span class="math display">\[
D_{\pi}(x)=\pi_{0}x_{3}+\pi_{1}x_{4}+\pi_{2}x_{5}+\pi_{3}x_{0}+\pi_{4}x_{1}+\pi_{5}x_{2}
\]</span></p>
<ul>
<li><span class="math inline">\(D_{\pi}(x)=0\)</span> 的解被称为是 <span class="math inline">\(\pi\)</span> 在 <span class="math inline">\(\mathbb{P}^5\)</span> 中的双超平面</li>
<li>给定直线 <span class="math inline">\(l_1,l_2\)</span>，我们称他们是关联的（incident），当且仅当
<span class="math inline">\(D_{\pi_1}(\pi_2)=0\)</span>（同时成立 <span class="math inline">\(D_{\pi_2}(\pi_1)=0\)</span>）</li>
<li>直线的位置关系</li>
</ul>
<p><img src="/2021/09/25/CG/Papers/2002/From-Region.Visibility/image-20211007111659627.png" style="zoom: 67%;"></p>
<ul>
<li>并不是所有的 <span class="math inline">\(\mathbb{P}^5\)</span>
中的点都能够映射到 <span class="math inline">\(\mathbb{R}^3\)</span>
中</li>
<li><span class="math inline">\(\Pi\)</span> 是 <span class="math inline">\(\mathbb{R}^3\)</span> 到 <span class="math inline">\(\mathbb{P}^5\)</span>
子集的一个双射，这个子集被称为表示如下</li>
</ul>
<p><span class="math display">\[
G=\left\{D_{x}(x)=0,x\in\mathbb{P}^5\right\}\backslash \{\textbf{0}\}
\]</span></p>
<ul>
<li>这个子集的名称有多个
<ul>
<li>Grassmann manifold</li>
<li>the Klein quadric</li>
<li><span id="anchor1">the Plücker hypersurface</span></li>
</ul></li>
</ul>
<h2 id="visibility-query">3. visibility query</h2>
<h3 id="overview">3.1 overview</h3>
<ul>
<li>为了精确查询，我们需要对同时刺穿两个多边形的线建立起一个空间表示</li>
<li>实际处理的时候，我们简单地将所有多边形几何裁剪到由<strong>多边形对的顶点定义的凸包</strong>的内部，再处理这内部的线段即可</li>
<li>每一个 occluder 都会遮挡住一部分两个 query polygon
之间的线，如果所有的线都被挡住了，那么 query polygon 之间相互不可见</li>
<li>两个多边形之间的线被表示成<a href="#anchor1">普吕克超曲面</a> <span class="math inline">\(G\)</span> 上点的一个连通子集，同样每一个 occluder
挡住的线也被表示成 <span class="math inline">\(G\)</span>
上的一个点的连通子集</li>
<li>算法思想
<ul>
<li>首先将 un-obstructed volume
初始化为两个多边形之间的所有直线构成的点集</li>
<li>针对所有的 occluder，我们在 un-obstructed volume
中去除它遮挡的那部分点集
<ul>
<li>使用 5 维结构立体几何实现去除</li>
<li>CSG(constructive solid geometry) in five dimensions</li>
</ul></li>
<li>最终剩余的点集对应的直线就是未被挡住的直线
<ul>
<li>如果集合为空，则两个多边形之间互相不可见</li>
<li>如果非空，则互相可见，而且由他们之间可见直线的完整描述</li>
</ul></li>
</ul></li>
</ul>
<h3 id="多边形之间的线空间">3.2. 多边形之间的线空间</h3>
<ul>
<li>直接对普吕克超曲面进行操作比较困难，因为是曲面</li>
<li>我们构造了一个多面体，这个多面体和普吕克超曲面的交集便是结果</li>
</ul>
<h4 id="多面体构造过程">多面体构造过程</h4>
<ul>
<li>如果一条直线 <span class="math inline">\(s\)</span>
穿过了两个多边形，充要条件如下
<ul>
<li>s 和多边形的所有边的位置关系相同（左右手螺旋关系）</li>
</ul></li>
</ul>
<p><img src="/2021/09/25/CG/Papers/2002/From-Region.Visibility/image-20211007170331249.png" style="zoom:67%;"></p>
<ul>
<li>给定两个多边形的边集 <span class="math inline">\(e_1,\cdots,e_n\)</span>（<strong>appropriately
directed</strong>）,判断一个直线是否和两个多边形相交，就是判断如下式子是否成立
<ul>
<li><strong><span style="color:red">如何保证两个多边形边的方向一致？</span></strong></li>
</ul></li>
</ul>
<p><span class="math display">\[
D_{\pi}(\Pi(s))\ge0,\forall\pi\in\left\{\Pi(e_1),\cdots\Pi(e_n)\right\}
\]</span></p>
<ul>
<li>因为我们知道普吕克超平面上的点乘以一个常数因子之后，在三维空间终对应的点是不变的，因此我们可以将其除以某一项之后，将其归一化
<ul>
<li>这一项不能为 0</li>
<li>可以通过预旋转场景来实现</li>
<li><strong><span style="color:red">正负问题？</span></strong></li>
</ul></li>
<li>我们将第三项用于归一化（<span class="math inline">\(x_3=1\)</span>）
<ul>
<li><span class="math inline">\(\pi\)</span>
不一起归一化：正负号的问题，如果 <span class="math inline">\(\pi\)</span> 归一化，会出现正负号的问题</li>
<li><span class="math inline">\(-\Pi(e)\)</span> 和 <span class="math inline">\(\Pi(e)\)</span>
表示的是两条边，<strong>方向相反</strong></li>
</ul></li>
</ul>
<p><span class="math display">\[
D_{\pi}&#39;(x)=\pi_{0}+\pi_{1}x_{4}+\pi_{2}x_{5}+\pi_{3}x_{0}+\pi_{4}x_{1}+\pi_{5}x_{2}
\]</span></p>
<ul>
<li><strong><span style="color:red"><span class="math inline">\(G\)</span> 平面现在如何在 <span class="math inline">\(\mathbb{R}^5\)</span> 中表示？</span></strong>
<ul>
<li>如果是等于零的话，似乎都归一化也没啥关系，怎么和上面的表达式统一呢？</li>
</ul></li>
<li>于是我们现在使用一个定义在 <span class="math inline">\(\mathbb{R}^5\)</span> 中的几何体来表示 <span class="math inline">\(\mathbb{R}^3\)</span> 中的直线集合</li>
</ul>
<p><img src="/2021/09/25/CG/Papers/2002/From-Region.Visibility/image-20211007182433448.png" style="zoom:67%;"></p>
<ul>
<li>上面这样的多面体可能是无界的，但是多面体和普吕克超曲面的交点集是有界的，因此我们可以在不改变多面体和普吕克交点集的前提下对多面体增加限制，使其有界</li>
</ul>
<h3 id="普吕克空间中的-csg">3.3 普吕克空间中的 CSG</h3>
<ul>
<li>CSG：构造实体几何，全称 <strong>Constructive solid geometry</strong>
，是 3D 计算机图形学中构建模型的常用技术，可通过合并 Union、相减
Subtraction 和相交 Intersction
的三种取集的逻辑运算，将立方体、圆柱体和棱柱等简单的基础模型，嵌套组合成更复杂三维模型</li>
<li>针对一个 occluder
<ul>
<li>我们将它的所有边使用 <span class="math inline">\(\Pi,D&#39;\)</span>
表示成 <span class="math inline">\(\mathbb{R}^5\)</span> 中的超平面
<ul>
<li><span class="math inline">\(D&#39;_{\Pi(o_1)}(x),x\in{\mathbb{R}^5}\)</span>
表示和 <span class="math inline">\(o_1\)</span> 共面的所有直线</li>
</ul></li>
<li>这个超平面围成的区域就是穿过这个 occluder 的所有直线</li>
<li>我们维护一个<strong>有向超平面的</strong>集合 <span class="math inline">\(\mathcal{O}\)</span> 来表示上面的区域</li>
</ul></li>
<li>在五维空间中，如何在一个多面体中减去另外一个多面体是一个比较困难的任务（non-trivial）
<ul>
<li>我们给出一个算法，将所有的多面体进行一个拆分（拆分成若干部分），使得每一个部分对于任意一个超平面来说，都恰好落在他的一侧
<ul>
<li>这是可以实现的，因为对于一个多面体和一个超平面而言是 OK 的</li>
</ul></li>
<li>如果包围某一个部分的超平面集合中的元素全在 <span class="math inline">\(\mathcal{O}\)</span>
中，那么这个部分就是完全被遮挡的，我们可以移除这个部分</li>
<li>剩下的部分和<strong>普吕克超平面</strong>的交集就是没有被这个
occluder 挡住的直线集合了</li>
</ul></li>
<li>上面这个操作是迭代进行的
<ul>
<li>初始化一个区域，这个区域对应 query polygons
的有向超平面围成的部分，<span class="math inline">\(\mathcal{O}\)</span>
初始化为空集</li>
<li>对于每一个 occluder，将新的边加入 <span class="math inline">\(\mathcal{O}\)</span>，将上面的部分进行切分使得满足每一个部分都恰好在
<span class="math inline">\(\mathcal{O}\)</span>
中任意一个超平面的一侧，去除其中完全被 <span class="math inline">\(\mathcal{O}\)</span> 中的有向平面挡住的部分</li>
<li>直至这个区域为空（完全被遮挡），或者所有 occluder
都检测完这个区域还不为空（互相可见）</li>
</ul></li>
<li>如何切割一个部分？
<ul>
<li>遍历这个部分的 5 个维度，切割成为两个部分</li>
<li>有冗余，因为被拆分的面被重复记录了，但是这样更快</li>
</ul></li>
<li>如何判断超平面和一个部分相交？
<ul>
<li>首先使用一个 5D 的包围球去进行测试，如果不相交则不相交</li>
<li>如果相交则使用精确的顶点表示的超平面去测试
<ul>
<li>判断是否存在两个点位于超平面的两边，是则相交，否则则不相交</li>
</ul></li>
</ul></li>
</ul>
<h3 id="优化策略">3.3 优化策略</h3>
<ul>
<li>当我们考虑 occluder 的超平面集 <span class="math inline">\(\mathcal{O}\)</span>
对整个实体进行切割的时候，我们只考虑切割穿过切割那些穿过 <span class="math inline">\(\mathcal{O}\)</span> 边界的部分
<ul>
<li>如果切割新形成的部分 <span class="math inline">\(\mathcal{O}\)</span>
和普吕克超平面没有交集，那么我们直接丢掉着一个部分</li>
</ul></li>
<li>在算法开始之前，我们先尝试从一个多边形投射出若干条光线，如果存在一条光线能够打到另外一个多边形，那么就说明是可见的，只有不存在这样的光线的时候，我们才使用上面提到的算法</li>
<li>通过分析之前投射的光线，分析出使用最少的多边形就形成完全遮挡的效果，从而尽早终止算法
<ul>
<li>挡住光线最多的 occluder 先从原来的结构中被减去</li>
<li>这里的光线数量不包括之前已经减去的 occluder 挡住的光线
<ul>
<li><strong><span style="color:red">神奇？怎么实现？</span></strong></li>
</ul></li>
</ul></li>
</ul>
<h3 id="本文的贡献-1">3.4 本文的贡献</h3>
<ul>
<li>我们可以处理局部的可见性（两个多边形之间）</li>
<li>对于大部分场景，算法都能很快停止</li>
<li>一般场景而言，比全局的可见性算法快，近似复杂度 <span class="math inline">\(n^{2.4}\)</span></li>
</ul>
<h2 id="query-architecture">4. query architecture</h2>
<ul>
<li>我们希望能够对多边形进行分组，这样便能够对着一组多边形进行有效的查询</li>
<li>我们也想用到之前计算得到的结果</li>
</ul>
<h3 id="cluster-queries">4.1 Cluster Queries</h3>
<ul>
<li>我们使用简单的两层结构组织场景
<ul>
<li>场景由物体组成，物体由多边形组成</li>
<li>如果物体很大，我们将其拆解为多个小物体
<ul>
<li>物体体积、多边形个数</li>
</ul></li>
</ul></li>
<li><strong>source cell </strong>to <strong>object</strong> query
<ul>
<li>先对这个物体的包围盒进行一个可见性判断，6x6 个组合
<ul>
<li>全返回不可见则这个物体不可见</li>
<li>一个返回可见则物体有可能可见，对其中的多边形进行判断</li>
</ul></li>
</ul></li>
</ul>
<h3 id="parent-line-space-reuse">4.2 Parent Line-space Reuse</h3>
<ul>
<li>在进行 <strong>source cell </strong>to <strong>object</strong> query
的时候，我们获得了到包围盒上可见的直线集合，那么如果一个多边形想要可见，必然要和这个集合有相交的部分
<ul>
<li>这可以作为一个检测</li>
</ul></li>
</ul>
<h3 id="virtual-occluders">4.3 Virtual Occluders</h3>
<ul>
<li>virtual occluders are occluders that are not part of the geometry,
but still represent a set of blocked lines.</li>
<li>如果包围盒的一个面不可见的话，这可以被用来当作是之后物体的
occluder</li>
<li>如果在判定的时候，我们发现一个物体的包围盒<strong>不可见</strong>，那么我们可以用这个包围盒代替其中的物体作为一个
occluder</li>
<li>在处理场景的时候，我们大致使用从前向后的顺序去处理，因此可以用上上面的策略</li>
</ul>
]]></content>
      <categories>
        <category>CG.Paper</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Paper</tag>
        <tag>occlusion</tag>
        <tag>可见性</tag>
      </tags>
  </entry>
  <entry>
    <title>(论文)[2019] Combining Two-level Data Structures and Line Space Precomputations to Accelerate Indirect Illumination</title>
    <url>/2021/09/17/CG/Papers/2019/TwoLevelBVH/</url>
    <content><![CDATA[<h1 id="combining-two-level-data-structures-and-line-space-precomputations-to-accelerate-indirect-illumination">Combining
Two-level Data Structures and Line Space Precomputations to Accelerate
Indirect Illumination</h1>
<ul>
<li><strong><span style="color:red;">TODO</span></strong></li>
</ul>
]]></content>
      <categories>
        <category>CG.Paper</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Paper</tag>
        <tag>occlusion</tag>
        <tag>可见性</tag>
      </tags>
  </entry>
  <entry>
    <title>(论文)[2018] Geometry-Aware Metropolis Light Transport</title>
    <url>/2022/02/08/CG/Papers/2018/geomlt/</url>
    <content><![CDATA[<h1 id="geomlt">GeoMLT</h1>
<ul>
<li>Geometry-Aware Metropolis Light Transport</li>
<li>Hisanari Otsu, Johannes Hanika, Toshiya Hachisuka, and Carsten
Dachsbacher. 2018. Geometry-Aware Metropolis Light Transport. <em>ACM
Trans. Graph.</em> 37, 6, Article 278 (November 2018), 11 pages.
https://doi.org/10.1145/3272127.3275106</li>
</ul>
<h1 id="展示">0. 展示</h1>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220208092831418.png" style="zoom:80%;"></p>
<ul>
<li>30 分钟渲染的结果，光源在门外
<ul>
<li>reference 是通过 BDPT 渲染收敛得到</li>
</ul></li>
<li>传统的 MLT
在边界、间隙的时候由于可见性的改变，变异得到的路径常常会被拒绝，我们的方法根据几何信息控制变异的大小
<ul>
<li>adaptively controls the mutation size according to the geometry
information surrounding each path segment</li>
</ul></li>
<li>我们的方法能够很好的避免由于可见性导致的零贡献样本（不可见）</li>
<li>通过估计最大的可见的圆锥顶角来限制突变步长，从而避免可见性问题
<ul>
<li>在不降低采样质量的前提下，提高 MLT 突变的接受率</li>
</ul></li>
<li>直接估计代价较大，我们还提出了加速方式</li>
</ul>
<h1 id="introduction">1. INTRODUCTION</h1>
<ul>
<li>MCMC 渲染方式</li>
<li>高效的 MCMC 取决于如下因素
<ul>
<li>the design of the transition kernel (path mutation)
<ul>
<li>小步长的样本 <span class="math inline">\(\to\)</span>
和之前的样本比较像 <span class="math inline">\(\to\)</span>
较高的接受率</li>
</ul></li>
<li>the autocorrelation between states
<ul>
<li>自相关程度高 <span class="math inline">\(\to\)</span> 样本附加信息少
<span class="math inline">\(\to\)</span> 样本质量低</li>
<li>步长大 <span class="math inline">\(\to\)</span> 容易被拒绝</li>
</ul></li>
</ul></li>
<li>通过局部结构来控制变化的步长</li>
<li>我们着重考虑因为<strong>可见性问题</strong>（不可见）导致的被拒绝的路径</li>
<li>如下图，蓝色范围表示突变核 kernel
<ul>
<li>右边的 kernel
更好，左边可能会产生由于不可见而被拒绝的路径，右边不会</li>
</ul></li>
</ul>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220209102035507.png" style="zoom:80%;"></p>
<ul>
<li>现在的考虑可适应步长的方法没有考虑可见性问题
<ul>
<li>Wenzel Jakob and Stephen Marschner. 2012. Manifold exploration: a
Markov chain Monte Carlo technique for rendering scenes with difficult
specular transport. ACM Transactions on Graphics (Proc. SIGGRAPH) 31, 4,
Article 58 (2012).</li>
<li>Tzu-Mao Li, Jaakko Lehtinen, Ravi Ramamoorthi, Wenzel Jakob, and
Frédo Durand. 2015. Anisotropic Gaussian Mutations for Metropolis Light
Transport Through Hessian-Hamiltonian Dynamics. ACM Transactions on
Graphics (Proc. SIGGRAPH Asia) 34, 6 (2015), 209:1–209:13.</li>
</ul></li>
<li><strong>我们第一次在 MCMC 中考虑了可见性因素</strong></li>
<li>文章的贡献
<ul>
<li>第一次在 MCMC 中考虑了可见性因素</li>
<li>如上图所示，给出了一种快速估计最大的圆锥顶角的算法</li>
<li>很容易集成到现有的 MLT 算法中，我们给出了实现</li>
</ul></li>
</ul>
<h1 id="background-and-previous-work">2. BACKGROUND AND PREVIOUS
WORK</h1>
<h2 id="light-transport-simulation">2.1 Light Transport Simulation</h2>
<ul>
<li>intensity <span class="math inline">\(I_j\)</span> of the <span class="math inline">\(j\)</span>-th pixel
<ul>
<li><strong><span style="color:red">论文中之后把 <span class="math inline">\(f_j\)</span> 简写为 <span class="math inline">\(f\)</span></span></strong></li>
</ul></li>
</ul>
<p><span class="math display">\[
I_j=\int_{\Omega}f_j(\bar{x})\;\mathrm{d}\mu(\bar{x})
\]</span></p>
<ul>
<li><span class="math inline">\(\Omega\)</span>：任意长度、所有可能的路径空间</li>
</ul>
<p><span class="math display">\[
\Omega=\bigcup_{k=2}^{\infty}\Omega_{k}
\]</span></p>
<ul>
<li><span class="math inline">\(\Omega_{k}\)</span>：结点数为 <span class="math inline">\(k\)</span> 的路径空间</li>
<li><span class="math inline">\(\bar{x}\)</span>：路径
<ul>
<li><span class="math inline">\(\bar{x}=(\mathrm{x}_1,\cdots,\mathrm{x}_k)\in\Omega\)</span></li>
</ul></li>
<li><span class="math inline">\(\mathcal{M}\)</span>：场景表面集合
<ul>
<li><span class="math inline">\(\mathrm{x}_i\in\mathcal{M},\;i=1,\cdots,k\)</span></li>
</ul></li>
<li>采样算法
<ul>
<li>Path Tracing：Kajiya 1986</li>
<li>Light Tracing：Arvo 1986</li>
<li>BDPT：Lafortune and Willems 1993; Veach and Guibas 1994</li>
</ul></li>
</ul>
<h2 id="mcmc-rendering">2.2 MCMC Rendering</h2>
<ul>
<li><p>论文这一段是对 MLT 的介绍</p></li>
<li><p>MCMC：MLT</p>
<ul>
<li>Veach and Guibas 1997</li>
<li>把 <span class="math inline">\(f\)</span>
作为目标分布的时候，最终路径的分布会趋近于 <span class="math inline">\(f/b\)</span>（归一化后的分布）</li>
</ul>
<p><span class="math display">\[
  b=\int_{\Omega}f(\bar{x})\;\mathrm{d}\mu(\bar{x})
  \]</span></p></li>
<li><p>Metropolis-Hastings (MH) algorithm</p>
<ul>
<li>Hastings 1970; Metropolis et al. 1953</li>
</ul></li>
</ul>
<h3 id="算法">算法</h3>
<ul>
<li>生成一系列的路径样本，新样本 <span class="math inline">\(y\)</span>
的生成只依赖于上一个样本 <span class="math inline">\(x\)</span>，转移核
<span class="math inline">\(T\)</span></li>
</ul>
<p><span class="math display">\[
\bar{y}\sim T(\bar{x}\to\bar{y})
\]</span></p>
<ul>
<li>新样本以一定概率被接受</li>
</ul>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213085003715.png" style="zoom:80%;"></p>
<ul>
<li>最后一部分等式推导</li>
</ul>
<p><span class="math display">\[
R(\bar{x}_i\to\bar{y})\equiv f (\bar{y})/T(\bar{x}_i\to\bar{y})
\]</span></p>
<ul>
<li><span class="math inline">\(f^{\ast}\)</span>：the scalar
contribution function, which typically is the <strong>luminance</strong>
of <span class="math inline">\(f\)</span></li>
</ul>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213085323853.png" style="zoom:80%;"></p>
<h3 id="变异策略">变异策略</h3>
<ul>
<li>变异策略基于状态空间
<ul>
<li>PSSMLT：Kelemen et al. [2002]</li>
<li>MMLT：Hachisuka et al. [2014]
<ul>
<li>利用 MIS 将 PSSMLT 和 BDPT 结合在一起</li>
</ul></li>
<li>Three recent works by Pantaleoni [2017], Otsu et al. [2017], and
Bitterli et al. [2017] concurrently proposed techniques to combine the
different state spaces by using an <strong>inverse mapping</strong> from
the primary sample space to the path space.</li>
</ul></li>
</ul>
<h2 id="path-space-perturbations">2.3 Path Space Perturbations</h2>
<ul>
<li>Our geometry-aware mutation technique is based on the
<strong>lens</strong>, <strong>caustic</strong>, and <strong>multi-chain
perturbations operating</strong> in the path space [Veach and Guibas
1997].</li>
<li>对于一条
subpath，我们对其的扰动为改变它的出射方向（<strong>局部球面坐标系</strong>）
<ul>
<li>例如扰动从 lens 出发的
subpath，我们改变其出射方向，追踪这条光线，直到停在 diffuse 的表面</li>
</ul></li>
</ul>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213095748652.png" style="zoom:80%;"></p>
<ul>
<li>以出射方向为<strong>上方向</strong>，<span class="math inline">\(\theta\)</span> 指数分布，<span class="math inline">\(\phi\)</span> 均匀分布
<ul>
<li>Veach and Guibas [1997]</li>
</ul></li>
</ul>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213101711000.png" style="zoom:80%;"></p>
<ul>
<li>采样得到的 <span class="math inline">\(\theta\in[r_{\min},r_{\max}]\)</span></li>
<li><span class="math inline">\(U\)</span>：<span class="math inline">\([0,1]\)</span> 均匀分布</li>
<li>推导得到 pdf 如下</li>
</ul>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213102115165.png" style="zoom:80%;"></p>
<ul>
<li>如何设置步长（也就是设置 <span class="math inline">\(r_{\max},r_{\min}\)</span>）对于渲染结果影响很大
<ul>
<li>自相关性 vs 收敛速度</li>
</ul></li>
</ul>
<h2 id="adaptive-step-sizes">2.4 Adaptive Step Sizes</h2>
<ul>
<li>有些研究根据目标函数的某些特征实现可适应步长
<ul>
<li>Li et al. [2015] utilized local information obtained from
<strong>analytic derivatives</strong> to adaptively control the shape of
the transition kernels based the idea of <strong>Hamiltonian Monte
Carlo</strong> [Duane et al. 1987].</li>
<li>Jakob and Marschner [2012]
<ul>
<li>specular 表面，将路径空间限制在低维度中</li>
</ul></li>
<li>Kaplanyan et al. [2014] and Hanika et al. [2015]
<ul>
<li>泛化上面的方法，使用半角向量表示路径空间</li>
</ul></li>
</ul></li>
<li>之前的方法都没有考虑可见性的问题，因为可见性函数的微分包含狄拉克函数成分
<span class="math inline">\(Dirac\)</span></li>
</ul>
<h2 id="cones-in-rendering">2.5 Cones in Rendering</h2>
<ul>
<li>Cone tracing [Amanatides 1984]
<ul>
<li>使用 cone 代替了 ray 和场景求交</li>
<li>有效的实现了 AA</li>
</ul></li>
<li>Roger et al. [2007]
<ul>
<li><strong>使用 cone 表示一组
ray，从而实现了一组相关的光线和场景的快速求交</strong>
<ul>
<li><strong><span style="color:red">可能有用</span></strong></li>
</ul></li>
</ul></li>
<li>Mora [2011]
<ul>
<li>utilized <strong>cones as ray packets</strong> in the context of
<strong>divide-and-conquer ray tracing</strong>.</li>
</ul></li>
<li>Crassin et al. [2011]
<ul>
<li><strong>voxelized</strong> scene geometries</li>
</ul></li>
<li>我们在一条出射光线的周围放置一个 cone，找到最大的不和场景相交的
cone</li>
</ul>
<h1 id="overview">3 OVERVIEW</h1>
<ul>
<li>3 个问题
<ul>
<li>如何找到最大的张角？</li>
<li>如何加速？</li>
<li>如何集成到 MLT 中？</li>
</ul></li>
</ul>
<h2 id="例子">例子</h2>
<ul>
<li>引导性的例子 MLT vs GeoMLT（场景与测试结果）</li>
</ul>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213111443167.png" style="zoom:80%;"></p>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213112055131.png" style="zoom:80%;"></p>
<ul>
<li>如上，<strong>黑点</strong>表示被拒绝的样本，<strong>橙点</strong>表示接受的样本</li>
<li>限制路径长度为 1，<strong>被拒绝的原因只有可见性</strong></li>
<li>上面的图示表示 GeoMLT 的适应性步长有比较好的效果</li>
</ul>
<h1 id="geometry-aware-perturbation-size">4 GEOMETRY-AWARE PERTURBATION
SIZE</h1>
<ul>
<li>让变异范围内的光线都不会因为可见性原因而被拒绝</li>
<li>如何计算 cone 的最大张角 <span class="math inline">\(r_{\max}\)</span>
<ul>
<li>通过用户定义的一个参数 <span class="math inline">\(\alpha\)</span>
求得 <span class="math inline">\(r_{\min}=\alpha r_{\max}\)</span></li>
</ul></li>
<li>path segment：<span class="math inline">\(\mathrm{x}_1\mathrm{x}_2\)</span></li>
<li>点 <span class="math inline">\(\mathrm{x}_1\)</span>
不动，扰动出射方向</li>
</ul>
<h2 id="truncated-cone">truncated cone</h2>
<ul>
<li>引入 truncated cone 的概念</li>
</ul>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213114638556.png" style="zoom:80%;"></p>
<ul>
<li>两个截断平面
<ul>
<li>避免自相交、和点 <span class="math inline">\(\mathrm{x}_2\)</span>
比较近的几何体的相交</li>
<li>The truncation of the cone’s apex and the base is used to avoid
<strong>self-intersections close to <span class="math inline">\(\mathrm{x}_1\)</span></strong> and to avoid
<strong>unnecessary small cone angles due to geometry close to <span class="math inline">\(\mathrm{x}_2\)</span></strong></li>
</ul></li>
</ul>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213120522157.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(t_2\)</span>
截断平面不一定和圆锥的轴垂直
<ul>
<li>更好的考虑倾斜的几何体</li>
<li>使用交点 <span class="math inline">\(\mathrm{x}_2\)</span>
的法线作为平面的法线</li>
</ul></li>
<li><span class="math inline">\(t_1\)</span> 需要垂直</li>
<li><span class="math inline">\(\mathcal{C}(\theta)\)</span>：所有在上面的
truncated cone 之间的点的集合</li>
<li>场景表面集合：<span class="math inline">\(\mathcal{M}\)</span></li>
<li>则最大的张角如下</li>
</ul>
<p><span class="math display">\[
\theta_{\max}=\sup\{\theta\vert\mathcal{M}\cap\mathcal{C}(\theta)=\emptyset\}
\]</span></p>
<ul>
<li>准确计算十分耗时
<ul>
<li>一种方法是二分的进行 cone-scene intersection test</li>
</ul></li>
</ul>
<h1 id="approximate-cone-angle">5. APPROXIMATE CONE ANGLE</h1>
<ul>
<li>粗略估计</li>
<li>使用 AABB 包围盒代替几何体进行 <span class="math inline">\(\theta_{\max}\)</span> 的计算</li>
</ul>
<h2 id="estimating-the-cone-angle-for-a-single-aabb">5.1 Estimating the
Cone Angle for a Single AABB</h2>
<ul>
<li>计算一个 path segment 和一个 AABB 的 <span class="math inline">\(\theta_{\max}\)</span></li>
<li>求出相交的最小夹角，<strong>算法</strong>如下
<ul>
<li>如果某个顶点 <span class="math inline">\(\mathrm{p}_i\)</span> 在
<span class="math inline">\([t_1,t_2]\)</span> 之间，计算夹角 <span class="math inline">\(\langle
\mathrm{x}_1\mathrm{p}_i,\mathrm{x}_1\mathrm{x}_2\rangle\)</span></li>
<li>对于 AABB 的每一条边，我们求出到 <span class="math inline">\(\mathrm{x}_1\mathrm{x}_2\)</span>
最近的点，如果这个点落在 <span class="math inline">\([t_1,t_2]\)</span>
之间，用它更新夹角</li>
<li><span class="math inline">\(t_2\)</span> 平面和 AABB
求交（得到一个凸多边形），求这个凸多边形到 <span class="math inline">\(\mathrm{x}_1\mathrm{x}_2\)</span>
最近的点，更新夹角</li>
</ul></li>
<li>如下图
<ul>
<li><span class="math inline">\(\mathrm{p}_1,\mathrm{p}_2\)</span>
的投影在区间 <span class="math inline">\([t_1,t_2]\)</span>
内部，需要考虑</li>
<li><span class="math inline">\(\mathrm{p}_3,\mathrm{p}_4\)</span>
的投影在区间 <span class="math inline">\([t_1,t_2]\)</span>
外部，不需要考虑</li>
</ul></li>
</ul>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213142936290.png" style="zoom:80%;"></p>
<h2 id="cone-estimation-using-a-bvh-cut">5.2 Cone Estimation using a
BVH-Cut</h2>
<ul>
<li>首先计算 initial cut，里面包含如下的结点
<ul>
<li>他们的父结点和 <span class="math inline">\(\mathrm{x}_1\mathrm{x}_2\)</span>
相交，但是他自己没有和 <span class="math inline">\(\mathrm{x}_1\mathrm{x}_2\)</span> 相交</li>
<li>如下的红色结点</li>
</ul></li>
</ul>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213150615178.png" style="zoom:80%;"></p>
<ul>
<li>实现如下</li>
</ul>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213150741855.png" style="zoom:80%;"></p>
<ul>
<li>此时 initial cut 里面包含着一堆绕着 <span class="math inline">\(\mathrm{x}_1\mathrm{x}_2\)</span> 的
AABB，但是他们都不和 <span class="math inline">\(\mathrm{x}_1\mathrm{x}_2\)</span> 相交</li>
<li>这也可以避免角度变成 0（和空的 AABB 相交）
<ul>
<li>会被排除</li>
</ul></li>
<li>此时可以使用 5.1 的方法对每一个 AABB 进行求解
<ul>
<li>如此得到的 <span class="math inline">\(\theta_{\max}\)</span>
总是会偏小</li>
</ul></li>
</ul>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213151753388.png" style="zoom:80%;"></p>
<ul>
<li>优化策略：将所有的 AABB 展开，直到结点个数达到设定值 <span class="math inline">\(N_{\max}\)</span>
<ul>
<li>优先队列 <span class="math inline">\(Q\)</span>，夹角最小的在根结点</li>
</ul></li>
</ul>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213161002331.png" style="zoom:80%;"></p>
<ul>
<li>展开每个结点，直到限制夹角的结点为叶子结点（此时已经是最大）或者达到数量限制（考虑效率）</li>
</ul>
<h2 id="trading-accuracy-for-speed">5.3 Trading Accuracy for Speed</h2>
<ul>
<li>更快但是牺牲了准确率</li>
<li>一种策略：只进行 5.1
部分的第一个测试（<strong>顶点</strong>），而且不进行 cut
refinement</li>
</ul>
<h1 id="geometry-aware-metropolis-light-transport">6. GEOMETRY-AWARE
METROPOLIS LIGHT TRANSPORT</h1>
<ul>
<li>扰动策略
<ul>
<li>a geometry-aware extension of the <strong>multi-chain
perturbation</strong></li>
</ul></li>
<li>可以类似的迁移到其他的扰动策略上
<ul>
<li>lens or caustic perturbation</li>
</ul></li>
</ul>
<h2 id="变异策略-1">变异策略</h2>
<ul>
<li>当前路径：<span class="math inline">\(\bar{x}=\mathrm{x}_1\mathrm{x}_2\cdots\mathrm{x}_k\)</span></li>
<li>依次对这样的 path segment 进行扰动，直到遇见两个连续的非镜面顶点
<ul>
<li><span class="math inline">\(\mathrm{x}_i\mathrm{x}_{i+1}\)</span>：出发自非镜面，终止在镜面</li>
<li>突变从 <span class="math inline">\(\mathrm{x}_k\)</span>
（光圈）开始，突变策略就是上面讲的</li>
<li>保证结点的表面类型、结点数量不变</li>
<li>结果为 <span class="math inline">\(\bar{y}=\mathrm{x}_1\mathrm{x}_2\cdots\mathrm{x}_s\mathrm{y}_{s+1}\cdots\mathrm{y}_k\)</span></li>
</ul></li>
<li>优化
<ul>
<li>如果 <span class="math inline">\(\mathrm{x}_{i+1}\)</span>
是非镜面或者光圈，我们扰动原始的方向（<span class="math inline">\(\omega_0=\mathrm{x}_{i+1}\to\mathrm{x}_i\)</span>），此时下一个顶点
<span class="math inline">\(\mathrm{y}_i\)</span> 通过朝着新的方向 <span class="math inline">\(\omega\)</span> 射出一条光线计算得到，不使用方向
<span class="math inline">\(\mathrm{y}_{i+1}\to\mathrm{x}_i\)</span>，因为这样在计算接受率的时候需要额外对这段路径进行可见性测试</li>
<li>如果 <span class="math inline">\(\mathrm{x}_{i+1}\)</span>
是镜面，则根据确定的方向计算得到 <span class="math inline">\(\mathrm{y}_i\)</span></li>
</ul></li>
</ul>
<h2 id="计算接收率">计算接收率</h2>
<ul>
<li>化简，消去公共项（前面一段相同）</li>
</ul>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213190644235.png" style="zoom:80%;"></p>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213190723401.png" style="zoom:80%;"></p>
<ul>
<li>只需要计算不同的项</li>
</ul>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213191100768.png" style="zoom:80%;"></p>
<h1 id="results">7. RESULTS</h1>
<ul>
<li>MLT：<span class="math inline">\(r_{\max}=0.5,r_{\min}=0.05\)</span></li>
<li>GeoMLT：<span class="math inline">\(N_{\max}=10,\alpha=0.1\)</span></li>
<li>算法
<ul>
<li>the bidirectional mutation for global exploration</li>
<li>and the multi-chain perturbations for local exploration with equal
selection probability.</li>
</ul></li>
</ul>
<h2 id="实现">实现</h2>
<ul>
<li>Clamping the Estimated Cone Angle
<ul>
<li>如果光线掠过一个几何体的表面，可能会导致计算得到的 <span class="math inline">\(\theta\)</span> 很小（几乎为 0），我们将计算得到的
<span class="math inline">\(\theta\)</span> clamp
到用户指定的范围内</li>
<li>实验为 <span class="math inline">\([0.01,0.5]\)</span></li>
</ul></li>
<li>Avoiding Unnecessary Cone Angle Underestimation
<ul>
<li><span class="math inline">\(t_2\)</span> 设置得距离 <span class="math inline">\(\mathrm{x}_2\)</span> 不能太近</li>
<li>实验：<span class="math inline">\(t_1=10^{-4},t_2=0.99\Vert\mathrm{x}_1-\mathrm{x_2}\Vert\)</span></li>
</ul></li>
<li>Equal-Time Comparisons
<ul>
<li>我们的方法不对出发于镜面的顶点进行估计，因此在这种情况下会有问题</li>
</ul></li>
<li>Accuracy of the BVHCut Approximation
<ul>
<li>BVHcut 估计的顶角范围基本准确</li>
<li>算法能够适应不同场景（场景旋转不同角度，AABB 改变）</li>
</ul></li>
<li>Quality of Exploration
<ul>
<li>评估：<span class="math inline">\(\text{MCMC-SE}=\sqrt{\dfrac{\text{Var}}{\text{ESS}}}\)</span></li>
</ul></li>
</ul>
<p><img src="/2022/02/08/CG/Papers/2018/geomlt/image-20220213194431214.png" style="zoom:80%;"></p>
<ul>
<li>Differently-Sized Geometry
<ul>
<li>场景中同时有不同尺度的几何体</li>
<li>树干和树枝</li>
<li>背景中含有一个很大的 diffuse reflector 时，我们看到 GeoMLT 增益不大
<ul>
<li>因为可以跳过这个遮挡的树枝，从另外的一个间隙中过来，因此 <span class="math inline">\(\theta\)</span> 之外其实也还有很多可行的光路</li>
</ul></li>
</ul></li>
</ul>
<h1 id="discussion">8. DISCUSSION</h1>
<ul>
<li>Parameters
<ul>
<li>有些人为设置的参数，会影响渲染结果</li>
</ul></li>
<li>Cone Angle Estimation
<ul>
<li>BVHCut：相对精确</li>
<li>FastApprox：很宽松</li>
<li>更好的方法：TODO</li>
</ul></li>
<li>Limitations
<ul>
<li>两个顶点都是镜面材质</li>
<li>不连续结构</li>
<li>最大张角很大（大于等于人为设置的最大值），此时 BVHCut 白做了</li>
</ul></li>
<li>Reusing Acceleration Structure
<ul>
<li>同时进行，方便</li>
</ul></li>
<li>Future work
<ul>
<li>各向异性的 cone</li>
<li>现在只支持表面渲染，推广到参与介质的渲染（participating media）</li>
<li>designing geometry-aware mutations in primary sample space</li>
</ul></li>
</ul>
<h1 id="conclusion">9. CONCLUSION</h1>
<ul>
<li>We presented a mutation strategy which adaptively changes the
mutation step size according to the geometry of the scene. Our method
restricts perturbations of path segments such that nearby geometry is
not intersected, as this would always result in rejected proposals. We
introduced fast, approximate algorithms to estimate the maximum
perturbation angle, which reuse the very same acceleration structure
which is already present for ray casting.We demonstrated that our
approach can greatly improve the exploration performance of a Markov
chain. Our perturbation strategy has been designed with small geometric
features in mind, such as door slits or keyholes where the light shines
through. However, as our results show, it also reduces noise near
geometric edges, such as the one between the floor and the back wall in
the Ajar door scene. We believe that using information about geometric
visibility has great potential and can be used to ameliorate many other
cases of inefficient mutations due to geometric constraints.</li>
</ul>
]]></content>
      <categories>
        <category>CG.Paper</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Paper</tag>
        <tag>occlusion</tag>
      </tags>
  </entry>
  <entry>
    <title>(论文)[2020] Path Cuts, Efficient Rendering of Pure Specular Light Transport</title>
    <url>/2021/03/20/CG/Papers/2020/PathCuts/</url>
    <content><![CDATA[<h1 id="path-cuts-efficient-rendering-of-pure-specular-light-transport">Path
Cuts: Efficient Rendering of Pure Specular Light Transport</h1>
<h2 id="key-words">Key Words</h2>
<ul>
<li>点光源，针孔摄像机，pure specular，multi-bounce，path-space</li>
<li>reflections and refractions
<ul>
<li>反射和折射</li>
</ul></li>
</ul>
<h2 id="introduction">1. Introduction</h2>
<ul>
<li>传统的渲染方法，<strong>蒙特卡洛方法</strong>找到一条从光源到相机的路径</li>
<li>none of them are able to find multi-bounce pure specular light paths
from a point light to a pinhole camera</li>
<li>之前的方法
<ul>
<li>初始化为一条不可接受的的路径（可能是不太正确的路径，但是很接近最终解）</li>
<li>根据求解器求解出一条正确的路径（牛顿法）</li>
<li>可以解决，但是有<strong>局部性问题</strong></li>
</ul></li>
<li>Walter’s method：全局的方法
<ul>
<li>using a hierarchical data structure on top of meshes with
interpolated normals, but only works for <strong>a single
refraction</strong>.</li>
</ul></li>
<li>论文的方法
<ul>
<li>we enumerate the discrete set of admissible pure specular paths of
<strong>a given length</strong> and <strong>type</strong> connecting the
light and the camera. We <strong>globally</strong> slice the path space
into small regions</li>
<li>within a region we solve the <strong>local</strong> problem of
refining the path to become admissible</li>
</ul></li>
<li>解决的问题
<ul>
<li>We use a path space hierarchy combined with interval arithmetic
bounds to efficiently prune non-contributing regions of path space, and
to slice the path space into regions small enough that local refinement
becomes feasible.
<ul>
<li>路径空间划分，剪枝，每个小区域求局部解</li>
</ul></li>
<li>We use an automatic differentiation tool and a Newton-based solver
to find an admissible specular path within a given path space region,
and splat its contribution onto the image plane.
<ul>
<li>自动微分工具，基于牛顿法的求解器</li>
<li>给定一个区域内的求解，然后在全局上加入它的贡献</li>
</ul></li>
<li>We show that our purely specular solution can be used to initialize
paths for other algorithms, such as an MCMC-based approach to render
with small but non-zero roughness.
<ul>
<li>论文算法的到的路径可以用于其他算法初始值的设定</li>
</ul></li>
</ul></li>
<li>评价
<ul>
<li>ours is the <strong>first</strong> approach to directly focus on
multi-bounce purely specular paths on <strong>complex geometric surfaces
given by triangle meshes</strong> with interpolated normals.</li>
</ul></li>
</ul>
<h2 id="相关工作">2. 相关工作</h2>
<ul>
<li>费马原理，牛顿法求解中间结点
<ul>
<li>优化问题，最大化/最小化长度</li>
</ul></li>
<li>Walter
<ul>
<li>费马定理在现实场景中不太使用（图元的不同法线、几何）</li>
<li>the admissible paths are simply the ones whose vertices align the
normal vector with the (refractive) half vector.</li>
<li>limited to a <strong>single</strong> refractive surface event
<ul>
<li>不容易扩展到 k-bounce</li>
</ul></li>
</ul></li>
<li>Markov chain Monte Carlo
<ul>
<li>this method does not work for pure specular paths</li>
<li>and requires the Markov chain light transport setting to be
applicable.</li>
</ul></li>
<li>Manifold next event estimation (MNEE)
<ul>
<li>the method can connect any shading point on a non-specular surface,
through one or more refractions, to a light source sample.</li>
<li>没有全局搜索</li>
<li>存在局部性问题，多解则不能很好工作</li>
</ul></li>
<li>half vector space light transport (HSLT)
<ul>
<li>a path is represented by its start and end point constraints and a
sequence of generalized half vectors</li>
<li>HSLT does not require a specular/non-specular classification of the
path vertices</li>
</ul></li>
<li>最近的工作
<ul>
<li>Recently, concurrent work by Zeltner et al. [2020] presented a
specular manifold sampling technique, which is able to handle
<strong>glints</strong>, <strong>reflective/refractive
caustics</strong>, and <strong>specular-diffuse-specular light
transport</strong></li>
<li>解决闪烁，焦散问题</li>
</ul></li>
<li><strong>Interval arithmetic</strong></li>
<li><strong>Glint rendering methods</strong></li>
<li><strong>Lightcuts</strong>
<ul>
<li>虚拟光源</li>
<li>层次结构</li>
</ul></li>
<li>Inspired by the idea of lightcuts, we propose path cuts to organize
all the triangles, <strong>whether geometric or tessellated from
bump/normal maps</strong>, into a <strong>hierarchy</strong>.</li>
<li>We use the path cuts to efficiently prune non-contributing areas of
the path space; i.e. regions where the alignment of the normal and half
vectors is guaranteed to be impossible.</li>
</ul>
<h2 id="path-space-traversal-using-path-cuts">3. PATH SPACE TRAVERSAL
USING PATH CUTS</h2>
<ul>
<li>For each number of <strong>bounces k</strong> the problem needs to
be solved independently</li>
<li>different <strong>path types</strong> of a given length are
themselves independent.</li>
</ul>
<h3 id="基本量">基本量</h3>
<ul>
<li>k-bounces
<ul>
<li>path vertices：k+2
<ul>
<li>light（L），k-bounces，pinhole camera（E）</li>
</ul></li>
<li>k+1 segments</li>
</ul></li>
<li>bounce point：<span class="math inline">\(x_i\)</span></li>
<li>场景由 n 个带有插值法线的<strong>三角形</strong>组成 <span class="math inline">\(T_i\)</span></li>
<li>scene surface：<span class="math inline">\(\mathcal{M}\)</span></li>
</ul>
<h3 id="思路">思路</h3>
<ul>
<li>Our idea is to first isolate all k-tuples of triangles that could
give rise to an admissible path, then find those paths within the
k-tuple using a root solver. In this section, we focus on the first
part, finding potentially contributing k-tuples of triangles.</li>
<li>then find those paths within the k-tuple using a root solver.</li>
<li>In this section, we focus on the first part, finding potentially
contributing k-tuples of triangles.</li>
</ul>
<h3 id="path-cuts-for-hierarchical-pruning">3.1 Path cuts for
hierarchical pruning</h3>
<ul>
<li>brute-force：暴搜
<ul>
<li><span class="math inline">\(O(n^k)\)</span></li>
</ul></li>
<li>树层次结构 tree hierarchy <span class="math inline">\(\mathcal{H}\)</span>
<ul>
<li>Each node <span class="math inline">\(S_i\in\mathcal{H}\)</span>
represents a surface <strong>patch</strong> on <span class="math inline">\(\mathcal{M}\)</span>, and records the 3D interval
(bounding box) <span class="math inline">\(N_i\)</span> of all surface
normals and the 3D interval (bounding box) <span class="math inline">\(P_i\)</span> of all surface positions in this
patch.</li>
<li><strong>Note that this "root" path cut is for the entire image, as
our method is independent of pixels.</strong></li>
</ul></li>
<li>找路径时考虑 <span class="math inline">\(\mathcal{H^k}=\mathcal{H}\times\mathcal{H}\times\cdots\times\mathcal{H}\)</span></li>
<li>假使我们选中了 <span class="math inline">\((S_{j_1},\cdots,S_{j_K})\in\mathcal{H^k}\)</span></li>
<li>“thick path”
<ul>
<li>the set of all paths from the light to the camera whose vertices are
within the corresponding nodes</li>
<li>恰好在上面的结点中</li>
</ul></li>
</ul>
<p><span class="math display">\[
L\to(x_1\in S_{j_1})\to(x_2\in S_{j_2})\to\cdots\to(x_k\in S_{j_k})\to E
\]</span></p>
<ul>
<li><strong>We denote such a “thick path” as a path cut, in analogy to
multidimensional lightcuts.</strong></li>
</ul>
<h4 id="insight">Insight</h4>
<ul>
<li>if we can quickly determine whether a path cut potentially contains
an admissible specular path, we can use this information to prune the
path space to quickly converge to contributing paths.</li>
<li>怎么判断 path cut 是否含有一个可接受的结果（specular path）？</li>
<li>conservative（保守）
<ul>
<li>existence of one or more admissible paths has to be always correctly
detected.</li>
<li>The reverse need not be true: if we cannot prove non-existence, we
can always subdivide the path cut.</li>
</ul></li>
</ul>
<h3 id="validating-a-path-cut">3.2 Validating a path cut</h3>
<ul>
<li>a pure specular path is admissible
<ul>
<li>at each surface bounce, the normal vector is aligned with the
(reflective or refractive) half vector.</li>
</ul></li>
<li>test locally</li>
</ul>
<p><img src="/2021/03/20/CG/Papers/2020/PathCuts/1616258430770.png" style="zoom: 80%;"></p>
<ul>
<li><strong>interval arithmetic</strong>：区间算术</li>
<li>对于层次结构中的结点 <span class="math inline">\(S_i\)</span>
做<strong>包围盒</strong>（AABB）
<ul>
<li><span class="math inline">\(P_i\)</span> ：<span class="math inline">\(S_i\)</span> 中点的位置</li>
<li><span class="math inline">\(N_i\)</span>：<span class="math inline">\(S_i\)</span> 中法线的位置</li>
</ul></li>
<li>所有可能的从 <span class="math inline">\(S_{i-1}\)</span> 到 <span class="math inline">\(S_i\)</span> 的入射方向、出射方向
<ul>
<li><span class="math inline">\(D_{in}^i=normalize(P_{i-1}
−P_i)\)</span></li>
<li><span class="math inline">\(D_{out}^i=-D_{in}^{i+1}=normalize(P_{i+1}−P_i)\)</span></li>
</ul></li>
<li>half vector
<ul>
<li><span class="math inline">\(H_i=normalize(D_{out}^i+D_{in}^i)\)</span></li>
</ul></li>
<li>判断 <span class="math inline">\(H_i\bigcap N_i\)</span>
是否为空，即可判断是否存在法线和半角矢量对齐（相等）</li>
<li>对每一次 bounce 做上面的判断，如果存在一个 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(H_i\bigcap N_i\)</span>
为空，那么不可能产生一条可行的光路
<ul>
<li>剪枝 prun</li>
</ul></li>
</ul>
<h3 id="subdividing-a-path-cut">3.3 Subdividing a path cut</h3>
<ul>
<li>Once we know that a path cut has potential to contribute a pure
specular path, we subdivide this path cut.
<ul>
<li>如果一条 path cut 有可能产生纯反射光路，则对其进行细分</li>
</ul></li>
</ul>
<h4 id="细分方式">细分方式</h4>
<p>（1）简单的细分</p>
<ul>
<li>把所有的非叶子结点都展开</li>
<li>复杂度变回去了，很高</li>
</ul>
<p>（2）随机选择一个非叶子结点进行展开</p>
<p>（3）展开最大的结点</p>
<ul>
<li>largest bounding box</li>
<li><strong>确实很直观</strong></li>
</ul>
<p>（4）展开 <span class="math inline">\(H_i\bigcap N_i\)</span>
区间最大的结点</p>
<ul>
<li>实验验证效果不好，能够看见比方法（3）更多的结点</li>
</ul>
<h4 id="细分结束">细分结束</h4>
<ul>
<li>As we repeat the subdivision process, finally we will end up with
path cuts that consist of <strong>only leaf nodes</strong>, i.e.
<strong>one triangle per bounce</strong>.</li>
</ul>
<h4 id="一个细分的问题">一个细分的问题</h4>
<ul>
<li><span style="color:red;font-weight:bold">怎么处理细分，结点数变化怎么处理，分成两条
path cut 吗？</span>
<ul>
<li>感觉确实没问题，复杂度也不高，只需要检查当前展开的结点和两边结点的连接关系即可</li>
</ul></li>
</ul>
<h2 id="solving-for-a-specular-light-path">4. SOLVING FOR A SPECULAR
LIGHT PATH</h2>
<ul>
<li>现在的结果是找到了一条 path cut，每个结点都是三角形</li>
</ul>
<p><span class="math display">\[
L\to(x_1\in T_1)\to(x_2\in T_2)\to\cdots\to(x_k\in T_k)\to E
\]</span></p>
<ul>
<li>现在的问题
<ul>
<li>find its <strong>contribution</strong> to the image plane</li>
<li>也就是说找到光路</li>
</ul></li>
</ul>
<h3 id="finding-an-admissible-path">4.1 Finding an admissible path</h3>
<ul>
<li>Finding such a light path is trivial <strong>if the triangles are
flat mirrors</strong> (i.e. they <strong>do not have interpolated
shading normals</strong> distinct from the geometric normal).
<ul>
<li>We just need to repeatedly take the virtual image of the point light
across the plane containing <span class="math inline">\(T_i\)</span> and
finally connect it to the camera.</li>
<li>把光源 <span class="math inline">\(L\)</span> 做 <span class="math inline">\(T_1\)</span> 的虚像得到 <span class="math inline">\(I_1\)</span>，然后把 <span class="math inline">\(I_1\)</span> 做 <span class="math inline">\(T_2\)</span> 的虚像得到 <span class="math inline">\(I_2\)</span>，重复这个过程得到 <span class="math inline">\(I_K\)</span>，连接 <span class="math inline">\(I_K\)</span> 和 <span class="math inline">\(E\)</span> 即可得到光路</li>
<li><strong>平面镜成像原理</strong></li>
</ul></li>
<li>However, this does not cover common situations with
<strong>refractions</strong> and <strong>normal interpolation</strong>
(curvature).
<ul>
<li>curvature：曲率</li>
</ul></li>
<li>In the general case, we need to find the vertex locations using a
<strong>root solver</strong>.</li>
<li>使用重心坐标系 <span class="math inline">\(\alpha_i,\beta_i,\gamma_i\)</span>
<ul>
<li><span class="math inline">\(\alpha_i+\beta_i+\gamma_i=1\)</span></li>
</ul></li>
<li>知道了 <span class="math inline">\(\alpha_i,\beta_i\)</span>
可以通过三个顶点插值出法线 <span class="math inline">\(n_i(\alpha_i,\beta_i)\)</span> 和顶点的位置 <span class="math inline">\(x_i(\alpha_i,\beta_i)\)</span></li>
<li>继而可以求出入射光线的方向 <span class="math inline">\(normalize(x_{i-1}-x_i)\)</span>，入射光线的方向
<span class="math inline">\(normalize(x_{i+1}-x_i)\)</span></li>
<li>接着求出半角矢量 <span class="math inline">\(h_i(\alpha_i,\beta_i)\)</span>
<ul>
<li><span style="color:red;font-weight:bold">感觉不太对，应该是下面这个，但是不影响</span>
<ul>
<li><span class="math inline">\({\color{red}h_i(\alpha_i,\beta_i,\alpha_{i-1},\beta_{i-1},\alpha_{i+1},\beta_{i+1})}\)</span></li>
</ul></li>
<li>半角矢量可以应用在<strong>反射</strong>和<strong>折射</strong>上面</li>
</ul></li>
<li>按照惯例，我们假设法线和半角矢量指向折射率较低的介质（一般但不一定是空气）</li>
<li>约束条件：逐渐缩小如下值（希望相等）
<ul>
<li><span class="math inline">\(C_i(\alpha_i,\beta_i)=\mathrm{n}_i(\alpha_i,\beta_i)-\mathrm{h}_i(\alpha_i,\beta_i)\)</span></li>
</ul></li>
<li>在三角形内部
<ul>
<li><span class="math inline">\(\alpha_i\ge0,\beta_i\ge0,\alpha_i+\beta_i\le1\)</span></li>
</ul></li>
<li>整条路径的限制条件</li>
</ul>
<p><span class="math display">\[
C(\alpha_1,\beta_1,\cdots,\alpha_k,\beta_k)=(C_1,C_2,\cdots,C_k)
\]</span></p>
<ul>
<li>the constraint function has 2k variables and 3k output values.
<ul>
<li>An alternative with 2k output values can be defined by projecting
the normals and half vectors into the local geometric space, and
dropping their 𝑧 coordinates. We found this alternative formulation
gives equivalent results and is slightly slower due to the extra vector
transformations.</li>
</ul></li>
<li><strong>Newton iteration</strong>
<ul>
<li>This requires solving a 3k × 2k linear system, in the least-squares
sense, at each iteration.</li>
<li>限制迭代次数
<ul>
<li>We bound the maximum number of iterations to 5.</li>
<li>If after reaching the maximum terations, the resulting vertices are
not all within their respective triangles, we assume there is no
solution.</li>
</ul></li>
<li>求解出来之后，我们对相邻的两个三角形做<strong>可见性测试</strong>
<ul>
<li>The visibility test can be skipped for objects known to be
convex.</li>
<li><span style="color:red;font-weight:bold">为什么不需要</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="the-contribution-of-an-admissible-path">4.2 The contribution of
an admissible path</h3>
<ul>
<li>影响强度的因素
<ul>
<li>The contribution of the path to the image consists of the product of
several terms:
<ul>
<li>visibility (already handled above)</li>
<li>light intensity</li>
<li>the product of Fresnel terms along the path</li>
<li>volumetric absorption</li>
<li><strong>the generalized geometry term</strong></li>
<li><strong>and the pixel importance function value</strong></li>
</ul></li>
</ul></li>
<li>这里只考虑最后两个因素（其他不需要在这里讨论）</li>
<li>precisely define our camera model as a <strong>pinhole
camera</strong>, with <strong>a sensor plane</strong> at a distance of
<strong>1 world unit</strong> from the camera position (pinhole)</li>
<li><strong>For the purposes of the explanation below, the camera
endpoint P of the path is thus on the sensor, not on the pinhole C
itself.</strong></li>
</ul>
<h4 id="pixel-importance-function-value">Pixel importance function
value</h4>
<ul>
<li>Consider a ray <span class="math inline">\((P,\omega)\)</span>
leaving the sensor point <span class="math inline">\(P\)</span> in
direction <span class="math inline">\(\omega =
normalize(C-P)\)</span></li>
<li><span class="math inline">\(W_{ij}(P,\omega)\)</span></li>
<li>We will need to include the corresponding <span class="math inline">\(W_{ij}\)</span> in the path contribution</li>
<li><span class="math inline">\(W_{ij}\)</span> 对谁归一化（和为1）
<ul>
<li>These units <strong>cannot</strong> be <strong>pixels</strong>,
otherwise the brightness of specular contributions would change with
image resolution.</li>
<li>Instead, we find that the normalization has to be with respect to
real world units, on the image sensor <strong>at a distance of 1 unit
from C</strong>.</li>
</ul></li>
<li>if the horizontal field-of- view is <span class="math inline">\(\theta\)</span> and the aspect ratio
(height/width) is <span class="math inline">\(r\)</span> , the area of
the image plane in world units is <span class="math inline">\(A\)</span>
<ul>
<li><span class="math inline">\(A=4r\tan^2(\dfrac{\theta}{2})\)</span></li>
</ul></li>
<li>归一化
<ul>
<li><span class="math inline">\(W_{ij}(P,\omega)=\dfrac{K_{ij}mn}{A}\)</span>
<ul>
<li>像素分辨率 <span class="math inline">\(m\times n\)</span></li>
</ul></li>
<li>Here we first define <span class="math inline">\(K_{ij}\)</span> to
be the pixel reconstruction filter normalized in pixel units,</li>
<li>and then include the additional factor of <span class="math inline">\(\dfrac{mn}{A}\)</span> to make <span class="math inline">\(W_{ij}\)</span> normalized in world units.</li>
</ul></li>
<li>图形学渲染：radiance meter
<ul>
<li>brightness to change with image resolution</li>
</ul></li>
<li>实际的摄像机：photon counter
<ul>
<li>brightness to change with image resolution</li>
</ul></li>
</ul>
<h4 id="generalized-geometry-termggt">Generalized geometry
term(GGT)</h4>
<ul>
<li><span style="color:red;font-weight:bold">这部分暂时没啥看懂</span></li>
<li>"intensity" or "distance correction factor"</li>
<li>Consider the ray propagation function <span class="math inline">\(F:\mathbb{R^2}\to\mathbb{R^2}\)</span> that maps a
neighborhood of the camera sensor point <span class="math inline">\(P\)</span> through the admissible specular path
<span class="math inline">\(\bar{x}\)</span> to the imaginary plane
crossing the point light position, orthogonal to the last path segment.
The GGT is the value</li>
</ul>
<p><span class="math display">\[
G(\bar{x})=\dfrac{1}{|\det J_F(P)|}
\]</span></p>
<ul>
<li>We initialize position differentials <span class="math inline">\(P_x\)</span> and <span class="math inline">\(P_y\)</span> of unit length on the camera sensor
plane, and trace them along the specular path to the imaginary plane
crossing the point light position, orthogonal to the last path segment,
finding the final position differentials <span class="math inline">\(L_x\)</span> and <span class="math inline">\(L_y\)</span>. Finally, we can compute the GGT
as</li>
</ul>
<p><span class="math display">\[
G(\bar{x})=\dfrac{1}{|L_x\times L_y|}
\]</span></p>
<ul>
<li><span class="math inline">\(|L_x\times L_y|\)</span>
很小，结果不真实
<ul>
<li><span class="math inline">\(|L_x\times
L_y|\approx||L_x||\cdot||L_y||\cdot\max\{\epsilon,|normalize(L_y)\times
normalize(L_y)|),\}\)</span></li>
<li>A value of <span class="math inline">\(\epsilon = 0.01\)</span>
works well in general.</li>
<li>We observe that this regularization solves the issue of occasional
very bright glints, while not affecting the remaining glints.</li>
</ul></li>
</ul>
<h3 id="multiple-solutions">4.3 Multiple solutions</h3>
<ul>
<li>解可能不止一个
<ul>
<li>虽然我们实验上都是得到一个解，但是这不一定理论正确</li>
</ul></li>
</ul>
<h4 id="finding-all-discrete-solutions">Finding all discrete
solutions</h4>
<ul>
<li>问题
<ul>
<li>Even if a single solution exists, standard Newton’s method still
does not theoretically guarantee that the solution will be found.
<ul>
<li>一个解但是没找到</li>
</ul></li>
<li>Furthermore, there is a possibility of multiple discrete solutions
<ul>
<li>多个解</li>
</ul></li>
</ul></li>
<li>Both of these issues can be theoretically handled with the interval
version of Newton’s method, as suggested by Mitchell and Hanrahan [1992]
and Walter [2009].</li>
<li>我们实验发现差不多
<ul>
<li>可能的解释</li>
<li>our meshes already subdivided to small enough triangles, so multiple
solutions within a single triangle do not frequently occur in
practice</li>
</ul></li>
</ul>
<h4 id="infinite-solution-regions">Infinite solution regions</h4>
<ul>
<li>圆柱体，内部纯反射，光源和针孔摄像机放置在两头，中间的圆给出无穷多个解
<ul>
<li>无法求解</li>
<li>法线并非插值得到</li>
</ul></li>
<li>只能求解三角形，而且内部的法线是由插值得到的图形</li>
</ul>
<h2 id="conclusion-and-future-work">7. CONCLUSION AND FUTURE WORK</h2>
<ul>
<li>We use a path space hierarchy combined with interval arithmetic
bounds to efficiently prune non-contributing regions of path space, and
to slice the path space into small region where the search problem
becomes local. Finally, we isolate admissible specular paths by a Newton
solver applied to a constraint function, whose gradients are computed by
automatic differentiation.We discuss in detail how such discovered paths
should contribute to the image plane.</li>
</ul>
<h1 id="作者报告">作者报告</h1>
<ul>
<li>视频：https://www.bilibili.com/video/BV1Mi4y1N7Np</li>
<li>南京理工大学 王贝贝</li>
<li>GAMES 链接：http://games-cn.org/games-webinar-20210401-177/</li>
<li>代码：https://github.com/wangningbei/mbglints</li>
</ul>
<h2 id="notes">notes</h2>
<ul>
<li><p>现有的方法解决不能解决问题</p>
<ul>
<li>BDPT：很难在交汇处实现完美的镜面反射。折射</li>
<li>MLT：思路是在一开始的种子路径上，使用小的偏移找到新的路径
<ul>
<li>一开始的种子路径很难找到</li>
</ul></li>
</ul></li>
<li><p>论文的方法是确定性的结果，是没有噪声的</p></li>
<li><p>我们的方法可以作为 MLT 的种子路径</p></li>
<li><p>只能支持点光源</p></li>
<li><p>展示是基于 CPU</p></li>
</ul>
<h3 id="问题">问题</h3>
<ul>
<li>bounce 比较多的时候，搜索代价变大
<ul>
<li>论文最多 4-bounces</li>
</ul></li>
<li>牛顿法不能求出所有解
<ul>
<li>区间牛顿法可以，但是代价大</li>
<li>划分区间，用一个条件判断使得否只有唯一解，如果只有唯一解，利用牛顿法求解，否则继续细分</li>
</ul></li>
<li>AABB
包围盒比较松，在做法线和半角矢量是否有交判断中比较松（不能提前排除无解可能性）</li>
</ul>
]]></content>
      <categories>
        <category>CG.Paper</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>(论文)[2020] Specular Manifold Sampling for Rendering High-Frequency Caustics and Glints</title>
    <url>/2021/06/26/CG/Papers/2020/Glints/</url>
    <content><![CDATA[<h1 id="specular-manifold-sampling-for-rendering-high-frequency-caustics-and-glints">Specular
Manifold Sampling for Rendering High-Frequency Caustics and Glints</h1>
<ul>
<li>Tizian Zeltner, Iliyan Georgiev, and Wenzel Jakob. 2020. Specular
Manifold Sampling for Rendering High-Frequency Caustics and Glints. ACM
Trans. Graph. 39, 4, Article 149 (July 2020), 15 pages. <a href="https://doi.org/10.1145/3386569.3392408">https://doi.org/10.1145/3386569.3392408</a></li>
<li>效果图
<ul>
<li>ordinary unidirectional path tracer</li>
<li>我们新提出的 specular manifold sampling 策略</li>
</ul></li>
</ul>
<p><img src="/2021/06/26/CG/Papers/2020/Glints/image-20210701170858478.png"></p>
<ul>
<li>our method supports
<ul>
<li>high-frequency <strong>normal- or displacement-mapped
geometry</strong>,</li>
<li>samples specular-diffuse-specular (“<strong>SDS</strong>”)
paths,</li>
<li>and is compatible with standard <strong>Monte Carlo methods</strong>
including unidirectional path tracing</li>
</ul></li>
<li>Both <strong>unbiased</strong> and <strong>biased</strong> variants
of our approach can be constructed</li>
</ul>
<h2 id="introduction">1 INTRODUCTION</h2>
<ul>
<li>specular path
<ul>
<li><strong>difficult to find</strong></li>
</ul></li>
<li>论文的方法
<ul>
<li><strong>glints</strong> and <strong>SDS</strong> paths—in an
<strong>unbiased</strong> manner</li>
</ul></li>
<li>论文的贡献
<ul>
<li><ol type="1">
<li>A <strong>unified</strong> manifold sampling strategy for rendering
<strong>reflective and refractive caustics.</strong>**</li>
</ol></li>
<li><ol start="2" type="1">
<li>A specialized variant for rendering glints, which reduces memory
usage hundred-fold compared to prior work.</li>
</ol></li>
<li><ol start="3" type="1">
<li>A biased variant of the method with reduced variance.</li>
</ol></li>
<li><ol start="4" type="1">
<li>A <strong>two-pass</strong> sampling strategy for normal-mapped
surfaces.</li>
</ol></li>
<li><ol start="5" type="1">
<li>Changes to the specular manifold constraints of Jakob and Marschner
[2012] that <strong>improve robustness and convergence.</strong></li>
</ol></li>
</ul></li>
<li>问题
<ul>
<li>variance increases significantly for longer specular chains, hence
our experiments mainly focus on <strong>short chains with 1 or 2
vertices.</strong></li>
</ul></li>
</ul>
<h2 id="prior-work">2 PRIOR WORK</h2>
<ul>
<li>path tracing</li>
<li>photon mapping</li>
<li>Newton-Raphson iteration</li>
<li>tree structure</li>
<li>论文的参考算法
<ul>
<li>Our algorithm is closely related to Jakob and Marschner’s manifold
exploration (ME) method [2012], which is a Markov chain Monte Carlo
(MCMC) <strong>perturbation</strong> strategy that analyzes the
differential geometry of the manifold of valid specular paths to make
proposals in the framework of Metropolis Light Transport [Veach
1998].</li>
</ul></li>
<li>MNEE
<ul>
<li>Starting with an <strong>incorrect initial specular path</strong>,
MNEE <strong>iteratively</strong> attempts to walk towards a valid
solution via projection and tangential steps on the specular
manifold.</li>
<li>最多找到一个解</li>
</ul></li>
<li>论文算法
<ul>
<li>The proposed method, named <strong>specular manifold sampling
(SMS)</strong>, is a generalization of the MNEE approach: using a
<strong>stochastic initialization</strong> and <strong>an unbiased
sampling weight estimator</strong>, we are able to find solutions on
complex geometry where manifold-based techniques were previously
inapplicable.
<ul>
<li>论文的算法是 MNEE
的泛化，能够解决复杂几何形体表面的路径采样问题</li>
</ul></li>
<li>We also propose a simple 2-stage stochastic initialization for
normal-mapped surfaces and demonstrate that SMS straightforwardly
generalizes to the related problem of glint rendering.We provide a brief
review</li>
</ul></li>
</ul>
<h2 id="background">3 BACKGROUND</h2>
<ul>
<li>light transport path
<ul>
<li><span class="math inline">\(\bar{\mathrm{x}}=\mathrm{x}_0,...,\mathrm{x}_n\)</span></li>
<li>端点 <span class="math inline">\(\mathrm{x}_1,\mathrm{x}_n\)</span>
non-specular</li>
<li>中间路径是 specular 的</li>
<li>下图是一个例子：<span class="math inline">\(\mathrm{x_n}\)</span>
是光源</li>
</ul></li>
</ul>
<p><img src="/2021/06/26/CG/Papers/2020/Glints/image-20210704003429567.png" style="zoom: 50%;"></p>
<ul>
<li>Snell' law：折射定律</li>
<li><span id="eq1">上述路径的约束条件</span>
<ul>
<li><span class="math inline">\(T(x_i)\)</span> is a 3 × 2 matrix of
tangent vectors</li>
<li>向量都归一化了</li>
</ul></li>
</ul>
<p><span class="math display">\[
\mathrm{c}_i(\mathrm{x}_{i-1},\mathrm{x}_i,\mathrm{x}_{i+1})=\mathrm{T}(\mathrm{x}_i)^T\mathrm{h}(\mathrm{x}_i,\overrightarrow{\mathrm{x}_i\mathrm{x}_{i-1}},\overrightarrow{\mathrm{x}_i\mathrm{x}_{i+1}})\;\;\;(1)
\]</span></p>
<ul>
<li>联立
<ul>
<li><span class="math inline">\(\mathrm{C}(\bar{x})=[\mathrm{c}_2,...,\mathrm{c}_{n−1}]^T\)</span></li>
<li>The function is normally parameterized via the UV coordinates <span class="math inline">\(\mathrm{uv}_i\)</span> of specular vertices,</li>
</ul></li>
<li>求解
<ul>
<li><span class="math inline">\(\mathrm{C}(\mathrm{\overline{uv}})=0\)</span></li>
<li>牛顿迭代法求解：<span class="math inline">\(\mathrm{\overline{uv}}_{i+1}=(\nabla\mathrm{C}(\mathrm{\overline{uv}}_i))^{-1}\cdot\mathrm{C}(\mathrm{\overline{uv}}_i)\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/06/26/CG/Papers/2020/Glints/image-20210704154651129.png" style="zoom: 67%;"></p>
<h3 id="manifold-next-event-estimationmnee">3.1 Manifold next-event
estimation(MNEE)</h3>
<ul>
<li>问题
<ul>
<li>简单形体有效
<ul>
<li>spheres or cylinders</li>
<li>where a single solution indeed suffices to render most specular
paths.</li>
</ul></li>
<li>不知道怎么初始化
<ul>
<li>refractive caustics 可以（Hanika et
al.），但是不知道怎么推广到折射</li>
</ul></li>
<li>Finally, MNEE does not support paths that give rise to specular
glints.</li>
</ul></li>
<li>算法</li>
</ul>
<p><img src="/2021/06/26/CG/Papers/2020/Glints/image-20210705135529611.png" style="zoom: 80%;"></p>
<h2 id="method">4 METHOD</h2>
<ul>
<li>pecular manifold sampling (SMS)
<ul>
<li><strong>initially</strong> focusing on <strong>a simple unbiased
algorithm</strong> that generalizes to cases where <strong>multiple
specular paths</strong> connect two given endpoints.</li>
</ul></li>
<li>几种扩展算法（模块化、可随意组装的）
<ul>
<li>the first reduces variance at the cost of nonzero bias</li>
<li>the second replaces Jakob and Marschner’s specular manifold
constraints with improved variants,</li>
<li>the third samples paths in two stages to improve performance on
normal-mapped surfaces, and the last streamlines the algorithm for glint
rendering.</li>
</ul></li>
<li>组装例子</li>
</ul>
<p><img src="/2021/06/26/CG/Papers/2020/Glints/image-20210704162403713.png" style="zoom:67%;"></p>
<h3 id="finding-all-solutions">4.1 Finding all solutions</h3>
<ul>
<li>初始化
<ul>
<li>We initially restrict ourselves to specular chains with a single
smooth reflection or refraction.</li>
</ul></li>
<li>思路
<ul>
<li>whereas MNEE performs manifold walks using a fixed initialization,
SMS <strong>randomly samples the initial guess</strong> from a
<strong>probability distribution</strong> <span class="math inline">\(p(\overline{\mathrm{x}}_0)\)</span>.</li>
<li>Newton’s method exhibits quadratic convergence when the starting
point is sufficiently close to a root, hence all solutions will be found
with a nonzero probability—however, the probability of successful
convergence is unknown.</li>
</ul></li>
<li>初始化选择的自由度很高
<ul>
<li>we assume that the implementation of this sampling strategy takes
two uniformly distributed random numbers <span class="math inline">\(\xi
(\xi_1,\xi_2)\in [0,1)^2 =:\mathcal{U}\)</span> as input and warps them
to the desired distribution.</li>
<li>目标是使得初始的采样路径 <span class="math inline">\(\xi\)</span>
离正确的结果比较近，这样牛顿法才有效</li>
</ul></li>
<li>When inspecting the convergence behavior of these manifold walks on
the primary sample space <span class="math inline">\(\mathcal{U}\)</span>, we generally observe
multiple basins of convergence <span class="math inline">\(\mathcal{B}_k\subseteq \mathcal{U}\)</span>, each
containing a point <span class="math inline">\(\xi^{k}\)</span>
identified with a corresponding solution vertex <span class="math inline">\(x_2^{(k)}\)</span>.</li>
<li>Fig. 4.
<ul>
<li>(a): Multiple solutions of the specular path constraint form a
superposition of caustics in the Ring scene.</li>
<li>(b): Color map showing the number of solutions at each shading
point.</li>
<li>(c): The three solution paths at a particular point.</li>
<li>(d): The basins of convergence (in primary sample space)
corresponding to those solution paths. All manifold walks started at a
point (black dot) inside a region converge to the associated solution
(colored dot).</li>
</ul></li>
</ul>
<p><img src="/2021/06/26/CG/Papers/2020/Glints/image-20210704171907849.png" style="zoom:67%;"></p>
<ul>
<li>Newton’s method is known to produce convergence basins that
potentially have an extremely <strong>complex geometric
structure</strong> [Hubbard et al. 2001] and can even be
<strong>fractal</strong>.</li>
<li>An unbiased estimator is then given by a standard MC ratio <span class="math inline">\(\dfrac{f(\overline{x})}{p(\overline{x})}\)</span></li>
<li>Since the samples <span class="math inline">\(\xi\)</span> are
<strong>uniformly distributed</strong>, this probability is simply the
area of the associated convergence basin on <span class="math inline">\(\mathcal{U}\)</span></li>
</ul>
<p><span class="math display">\[
p_k=\int_{\mathcal{U}}\mathbb{1}_{\mathcal{B}_k}(\xi)\;\mathrm{d}\xi
\]</span></p>
<ul>
<li>但是这个是不可行的，<span class="math inline">\(\mathcal{B}_k\)</span> 可能有复杂的几何结构</li>
<li>简单的无偏估计如下</li>
</ul>
<p><span class="math display">\[
\langle
p_k\rangle=\dfrac{1}{N}\sum_{i=1}^N\mathbb{1}_{\mathcal{B}_k}(\xi)
\]</span></p>
<ul>
<li>这个估计存在一些问题 <span class="math inline">\(\mathbb{E}[\dfrac{1}{X}]\ne\dfrac{1}{\mathbb{E}[X]}\)</span>
<ul>
<li>引入 bias</li>
<li>for example, <span class="math inline">\(\langle p_k\rangle\)</span>
can equal zero if all N tries fail to converge to the basin <span class="math inline">\(\mathcal{B}_k\)</span>
<ul>
<li><span class="math inline">\(\langle
\dfrac{1}{p_k}\rangle\to\infty\)</span></li>
</ul></li>
</ul></li>
<li>Fortunately, an unbiased estimator for the inverse ⟨1/pk ⟩ can be
created using a simple <strong>iterative approach</strong>.</li>
</ul>
<h3 id="unbiased-sms">4.2 Unbiased SMS</h3>
<ul>
<li>turning the inverse into a geometric series(几何级数) moves the
problematic integral from the denominator(分母) to the
numerator(分子)</li>
</ul>
<p><span class="math display">\[
\dfrac{1}{p_k}=\dfrac{1}{\int_{\mathcal{U}}\mathbb{1}_{\mathcal{B}_k}(\xi)\;\mathrm{d}\xi}=\dfrac{1}{1-a}=\sum_{i=0}^{\infty}a^i
\]</span></p>
<p><span class="math display">\[
a=1-\int_{\mathcal{U}}\mathbb{1}_{\mathcal{B}_k}(\xi)\;\mathrm{d}\xi,\;|a|&lt;1
\]</span></p>
<ul>
<li>那么就会有</li>
</ul>
<p><span class="math display">\[
\langle\dfrac{1}{p_k}\rangle=1+\sum_{i=1}^{\infty}\prod_{j=1}^{i}\langle
a\rangle_j
\]</span></p>
<ul>
<li><span class="math inline">\(\langle a\rangle_j=0\)</span> when
manifold walk <span class="math inline">\(j\)</span> has converged to
root <span class="math inline">\(\xi_k\)</span></li>
<li><span class="math inline">\(\langle a\rangle_j=1\)</span> if it has
found another root or diverged</li>
<li><strong>Unbiased SMS is trivially added to any existing
implementation of MNEE.</strong></li>
<li>算法如下</li>
</ul>
<p><img src="/2021/06/26/CG/Papers/2020/Glints/image-20210705134445300.png" style="zoom: 80%;"></p>
<ul>
<li>复杂度和几何形体相关
<ul>
<li>when the geometry is complex, many solutions may exist, and their
convergence basins also occupy smaller area in primary sample
space.</li>
</ul></li>
<li>方差
<ul>
<li>Furthermore, the variance of such an estimator for a specific
solution pk based on a geometric distribution is equal to <span class="math inline">\(\dfrac{1-p_k}{p_k^2}\)</span> , which can become
very large when <span class="math inline">\(p_k\approx 0\)</span>.</li>
</ul></li>
</ul>
<h3 id="biased-sms">4.3 Biased SMS</h3>
<ul>
<li>引入 bias，但是同时降低了 variance，减小了运行时间</li>
<li>The biased variant of our method (Alg. 3) replaces the unbounded
number of trial iterations by a fixed budget of M samples.</li>
<li>we simply cluster the M samples into a set of unique solutions <span class="math inline">\(\mathrm{x}_2^{(l)}(l = 1,\cdots, L)\)</span>.</li>
<li>A biased estimate of the reciprocal is then given by the
<strong>relative number of occurrences nl of each solution</strong>,
which also avoids the potential issues with a <strong>division by
zero</strong> discussed earlier.</li>
</ul>
<p><span class="math display">\[
\dfrac{1}{M}\sum_{l=1}^{L}n_l\dfrac{f(\mathrm{x}_2^{(l)})}{p(\mathrm{x}_2^{(l)})}\approx\dfrac{1}{M}\sum_{l=1}^{L}n_lf(\mathrm{x}_2^{(l)})\dfrac{M}{n_l}=\sum_{l=1}^{L}f(\mathrm{x}_2^{(l)})
\]</span></p>
<ul>
<li>Compared to the original unbiased approach, this variant has a
<strong>fixed iteration count</strong>, and it <strong>exploits the
information provided by all samples</strong>.</li>
<li>有偏但是是一致的
<ul>
<li>Note that it is <strong>consistent</strong> and will converge to the
true solution as <span class="math inline">\(M\to\infty\)</span></li>
</ul></li>
<li>论文中 bias 体现为能量损失
<ul>
<li>In our experiments, we observe that the resulting bias is manifested
as energy loss</li>
<li>焦散很暗</li>
</ul></li>
<li>算法如下</li>
</ul>
<p><img src="C:/Users/神秘嘉宾990/AppData/Roaming/Typora/typora-user-images/image-20210705145554518.png" style="zoom: 80%;"></p>
<ul>
<li>MNEE 和 biased SMS
<ul>
<li>When setting <span class="math inline">\(M=1\)</span>, biased SMS is
closely related to a biased version of MNEE where no MIS is applied to
account for paths that cannot be sampled using the manifold walk.</li>
<li><strong>但是是不等价的</strong></li>
<li>Consider a situation where only one valid solution exists but the
straight-line initialization doesn’t converge to it.
<ul>
<li>In this case, <strong>MNEE</strong> can produce <strong>arbitrarily
high variance</strong>—or in case of point lights will miss the
contribution entirely.</li>
<li><strong>SMS</strong> however will still find the solution with
<strong>non-zero probability</strong>.</li>
</ul></li>
</ul></li>
<li>向量化并行
<ul>
<li>modern SIMD instruction sets, such as AVX512.</li>
</ul></li>
</ul>
<h3 id="improved-specular-manifold-constraints">4.4 Improved specular
manifold constraints</h3>
<ul>
<li>One significant difference of our method compared to all previous
applications of manifold walks is that we require the Newton solver to
take <strong>very large steps</strong> starting from an
<strong>invalid</strong> state.
<ul>
<li><strong>MNEE</strong> renders <strong>refractive caustics</strong>
with a straight-line initialization that is generally <strong>already
very close to the final solution</strong>.</li>
<li>applications of manifold walks to MCMC rendering [Jakob and
Marschner 2012; Lehtinen et al. 2013] <strong>only make small
perturbations to existing valid paths</strong></li>
</ul></li>
<li>因此上述的两种方法收敛很快</li>
<li>我们的方法到现在为止，随机的初始化导致收敛很慢（即使是在简单的集合外形上也出现问题）
<ul>
<li>manifold walks would often converge surprisingly poorly when
initialized randomly</li>
</ul></li>
<li>导致收敛出现问题的原因
<ul>
<li>when <strong>taking large steps</strong>, Newton iterations based on
the <strong>original specular manifold constraint</strong>s often
produce <strong>invalid back-facing solutions</strong> that impede
convergence.</li>
<li>back-facing：下图中的 invalid
路径，光照从内部反射，这是不可能的</li>
</ul></li>
<li>The main issue here is how the specular manifold constraint in <a href="#eq1">Eq. (1)</a> encodes specular configurations via
<strong>half-vector projections</strong>.</li>
<li>While this term conveniently subsumes both reflective and refractive
cases with one equation, the formulation <strong>does not
distinguish</strong> between front- and back-facing solutions</li>
</ul>
<p><img src="/2021/06/26/CG/Papers/2020/Glints/image-20210705202223912.png" style="zoom:80%;"></p>
<ul>
<li>我们提出了一个新的约束条件，区分折射和反射
<ul>
<li>scattered direction <span class="math inline">\(S(\omega,\mathrm{n},\eta)\)</span></li>
<li>incident direction <span class="math inline">\(\omega\)</span></li>
<li>surface normal <span class="math inline">\(\mathrm{n}\)</span></li>
</ul></li>
</ul>
<p><img src="/2021/06/26/CG/Papers/2020/Glints/image-20210705204937896.png" style="zoom:80%;"></p>
<ul>
<li>度量条件：<span class="math inline">\(\mathrm{\omega}_o=S(\omega_i,\mathrm{n},\eta)\)</span>
<ul>
<li>具体我们使用 <span class="math inline">\(2\mathrm{D}\)</span>
度量方式（实验发现效果比较好）</li>
<li>we therefore measure a difference in the spherical coordinates of
both vectors</li>
</ul></li>
</ul>
<p><img src="/2021/06/26/CG/Papers/2020/Glints/image-20210705205329933.png" style="zoom:80%;"></p>
<ul>
<li><span class="math inline">\(\theta(\omega) =
\cos^{−1}(\omega_z)\)</span></li>
<li><span class="math inline">\(\phi(\omega)=\mathrm{atan}\;2(\omega_y,\omega_x)\)</span></li>
<li>一个其他问题
<ul>
<li>Note that the scattering operation <span class="math inline">\(\mathrm{S}(\cdot)\)</span> can fail in
configurations with <strong>total internal reflection</strong>.</li>
<li>In such cases we are still able to evaluate the constraint for the
opposite light direction by taking the difference between <span class="math inline">\(\mathrm{\omega}_o\)</span> and <span class="math inline">\(S(\omega_i,\mathrm{n},\eta)\)</span></li>
</ul></li>
</ul>
<h3 id="two-stage-manifold-walks">4.5 Two-stage manifold walks</h3>
<ul>
<li>we observe that <strong>the more complex caustic</strong> is a
<strong>superposition</strong>(叠加) of <strong>many different
solutions</strong> with <strong>a fairly localized
effect</strong>(局部效应)</li>
<li>The space <span class="math inline">\(\mathcal{U}\)</span> is
<strong>largely empty,</strong> containing only <strong>a few small
convergence basins</strong> that are clustered together. The probability
of finding a valid solution is therefore low.
<ul>
<li>采样概率小</li>
</ul></li>
</ul>
<p><img src="/2021/06/26/CG/Papers/2020/Glints/image-20210706132923125.png" style="zoom:80%;"></p>
<ul>
<li>Furthermore, estimating the reciprocal probability depends on our
ability to <strong>find the same solution once more</strong>, which is
even less likely.</li>
<li>Unbiased SMS estimates therefore tend be slow and noisy, while
biased SMS loses a considerable amount of energy.
<ul>
<li>采样概率小导致的问题</li>
</ul></li>
<li>为了解决上述问题，我们提出一种利用先验知识找初始路径的方法。</li>
<li>consider a <strong>caustic</strong> generated by a smooth planar
surface(光滑平面产生的焦散)
<ul>
<li>我们观察到，当表面的几何结构不太复杂时，焦散都是有一个比较大的收敛域产生的</li>
<li>当表面几何结构变得复杂的时候，大的收敛域分割为多个小的收敛域</li>
</ul></li>
<li>Our <strong>two-stage</strong> sampling approach performs
<strong>two manifold walks</strong>
<ul>
<li>the first stage <strong>ignores the specified normal map</strong>
and finds specular paths on the original smooth surface.
<ul>
<li>Such a smooth manifold walk will converge to a point that roughly
lies at the center of the cluster of solutions</li>
<li>具体使用的策略：<strong>offset manifold walk</strong> [Jakob and
Marschner 2012]</li>
</ul></li>
<li>a second manifold walk, on the bumpy surface, started from there
takes us all the way to a solution.</li>
</ul></li>
</ul>
<h3 id="glints">4.6 Glints</h3>
<ul>
<li>Our method generalizes straightforwardly to the problem of rendering
glints, which are miniscule subpixel reflections of a light source with
<strong>narrow angular support</strong> (e.g. the sun) on
<strong>high-frequency specular microgeometry</strong>.</li>
<li>标准的 MC 方法开销太大
<ul>
<li><strong>millions of samples per pixel</strong> may be needed to
obtain an acceptable result</li>
</ul></li>
<li>Our method <strong>generates random starting points</strong> within
the <strong>pixel</strong> and then runs <strong>unbiased or biased
SMS</strong> to find solutions</li>
<li>之前的方法
<ul>
<li>introduced a small amount of <strong>intrinsic roughness</strong> to
relax the problem</li>
</ul></li>
<li>we solve the unmodified problem with a discrete set of solutions to
find a path <span class="math inline">\(\mathrm{\bar{x}}=\mathrm{x}
_0,\mathrm{x}_1,\mathrm{x}_2\)</span> connecting the camera to a sampled
emitter position <strong>via a single specular reflection</strong>.
<ul>
<li>单次反射</li>
</ul></li>
<li>一些和之前一样的假设
<ul>
<li>Like prior work, we assume that the endpoints <span class="math inline">\(\mathrm{x} _0\)</span> and <span class="math inline">\(\mathrm{x} _2\)</span> are
<strong>distant</strong>, in which case changes in the half-vector
across the parallelogram are minimal.</li>
</ul></li>
<li>这些假设简化搜索
<ul>
<li>in particular, the specular manifold constraint can be simplified to
a function that attempts to <strong>equate this fixed
half-vector</strong> and <strong>the local shading normal</strong>, both
expressed in 2D slope space.</li>
</ul></li>
<li>泛化与鲁棒性
<ul>
<li>To robustly apply our glint rendering technique in scenes with
<strong>complex lighting</strong> (e.g. <strong>high-frequency
environment maps</strong>), we further combine our SMS strategy with
<strong>standard BSDF sampling</strong> in a multiple importance
sampling (<strong>MIS</strong>) framework.</li>
<li>效果很好</li>
</ul></li>
</ul>
<p><img src="/2021/06/26/CG/Papers/2020/Glints/image-20210706141100580.png" style="zoom:80%;"></p>
<h3 id="integration-into-rendering-algorithms">4.7 Integration into
rendering algorithms</h3>
<h2 id="results">5 RESULTS</h2>
<ul>
<li>详见论文</li>
</ul>
<h2 id="conclusion">6 CONCLUSION</h2>
<ul>
<li><strong>Our article focuses mainly on the generation of subpaths
with a single specular vertex</strong>.</li>
<li>While our method in principle also generalizes to more complex path
classes with multiple specular reflection, performance using our current
strategy for choosing starting points remains suboptimal and could be an
interesting topic for future work.</li>
</ul>
]]></content>
      <categories>
        <category>CG.Paper</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Paper</tag>
        <tag>Glints</tag>
      </tags>
  </entry>
  <entry>
    <title>(论文)[2020] Path Differential-Informed Stratified MCMC and Adaptive Forward Path Sampling</title>
    <url>/2021/07/06/CG/Papers/2020/pathdifferential-mcmc/</url>
    <content><![CDATA[<ul>
<li><p>Tobias Zirr and Carsten Dachsbacher. 2020. Path
Differential-Informed Stratified MCMC and Adaptive Forward Path
Sampling. ACM Trans. Graph. 39,6, Article 246 (December 2020), 19 pages.
https://doi.org/10.1145/3414685.3417856</p></li>
<li><p>结果图</p></li>
</ul>
<p><img src="/2021/07/06/CG/Papers/2020/pathdifferential-mcmc/image-20210706183728776.png" style="zoom:80%;"></p>
<p><span style="color:red;font-weight:bold">没看懂 emmmm,
TODO</span></p>
<h1 id="path-differential-informed-stratified-mcmc-and-adaptive-forward-path-sampling">Path
Differential-Informed Stratified MCMC and Adaptive Forward Path
Sampling</h1>
<ul>
<li>we apply <strong>our theoretical framework</strong> to
<strong>optimize</strong> an <strong>adaptive MCMC algorithm</strong>
that only uses <strong>forward path construction</strong>.</li>
</ul>
<h2 id="introduction">1 INTRODUCTION</h2>
<ul>
<li>MLT：Markov Chain Monte Carlo (MCMC) light transport</li>
<li>MCMC 在工业界用的比较少
<ul>
<li>The <strong>quality</strong> of results is oftentimes <strong>hard
to control and nonuniform</strong>.</li>
</ul></li>
<li>对给出路径的方差估计
<ul>
<li>We derive a novel analytic function that <strong>conservatively
estimates variance</strong> caused by <strong>a given path
sample</strong>.</li>
</ul></li>
<li>As a proof of concept, we apply the gained insights to both
stratification and optimal adaptive sampling in the context of MCMC:
<ul>
<li>We <strong>stratify</strong> the <strong>target function</strong> of
the Markov Chain (akin to Hoberock et al. [2010]) using our analytic
variance bounds.</li>
<li>We <strong>optimize</strong> the shape of proposal distributions in
path space MCMC and by this push the capabilities of forward path
tracing, to compete with other <strong>bi-directional</strong>
methods.</li>
<li>We complement the resulting small step based on forward path
construction by embedding a full path tracer with minimal changes,
importing established MC variance reduction and sample reuse, such as
multiple importance sampling (MIS), next event estimation (NEE), and
shared path prefixes.</li>
</ul></li>
<li>Our MCMC renderer effectively becomes an <strong>adaptive path
tracer</strong>, with the usual benefits of reduced <strong>algorithmic
complexity</strong>, avoiding efforts to ensure reciprocity (e.g. for
shading normals), and focussed sampling efforts due to tracing from the
camera.</li>
</ul>
<h2 id="background">2 BACKGROUND</h2>
<ul>
<li>The goal of MC and MCMC rendering methods is to compute the light
transported on all possible paths <span class="math inline">\(X=(\mathrm{x}_1,\cdots,\mathrm{x}_k\)</span>) (for
all vertex counts <span class="math inline">\(k\ge2\)</span>) in a path
space <span class="math inline">\(\Omega\)</span> to the individual
pixels of a sensor.</li>
<li>light trasport</li>
<li>For a given path <span class="math inline">\(X\)</span> the
measurement contribution <span class="math inline">\(f(X)\)</span>
[Veach 1998] (w.r.t. the area measure <span class="math inline">\(\mathrm{d}A\)</span> on all scene surfaces M) is
evaluated and the measurement for the j-th pixel with sensitivity <span class="math inline">\(h_j(X)\)</span> is computed by a path integral in
the rendering equation</li>
</ul>
<p><span class="math display">\[
I_j=\int_{\Omega}h_j(X)f(X)\;\mathrm{dX},\;\;
\mathrm{dX}=\prod_{i=1}^k\mathrm{dA_i}
\]</span></p>
<h3 id="integration-by-stochastic-sampling">Integration by Stochastic
Sampling</h3>
<ul>
<li>随机抽样积分法</li>
<li>MC（蒙特卡洛积分）
<ul>
<li>stochastic path sampling</li>
<li>good importance sampling
<ul>
<li>in order to <strong>sample high-throughput paths frequently</strong>
and to <strong>reduce variance of the result</strong></li>
</ul></li>
<li>Multiple Importance Sampling (MIS) [Veach and Guibas 1995]</li>
</ul></li>
<li>MCMC
<ul>
<li>MCMC rendering algorithms, introduced as <strong>Metropolis Light
Transport</strong> (MLT) [Veach and Guibas 1997], make use of the
Metropolis-Hastings algorithm resp. the generalizing Reversible Jump
(RJ) framework [Geyer 2003; Green 1995, 2003] to enable correlated path
sampling while maintaining a controlled distribution that allows MC
integration.</li>
<li>MCMC + MIS（减小方差）</li>
<li>Primary Sample Space MLT (PSSMLT) [Kelemen et al. 2002]</li>
</ul></li>
</ul>
<h3 id="generalizations-and-mixed-proposals-in-mcmc">Generalizations and
Mixed Proposals in MCMC</h3>
<h3 id="multiple-proposals-in-mcmc">Multiple Proposals in MCMC</h3>
<ul>
<li>Multiple Try Framework [Liu et al. 2000] (MT)</li>
</ul>
<h3 id="stratification-in-mcmc">Stratification in MCMC</h3>
<ul>
<li>Stratification, the targeted distribution of samples across pixels
and into regions (strata) with potential relevance to the image, is an
important feature of MC estimators to accelerate the convergence of MC
estimates.</li>
</ul>
<h3 id="stratification-of-markov-chain-initiation">Stratification of
Markov Chain Initiation</h3>
<ul>
<li>ERPT framework</li>
</ul>
<h3 id="short-term-stratification-and-step-sizes">Short-term
Stratification and Step Sizes</h3>
<ul>
<li>Zsolnai and Szirmay-Kalos [2013] propose scene-wide automatic
parameter tuning, which by its nature has limited local adaptivity.</li>
</ul>
<h3 id="path-differentials-in-light-transport">Path Differentials in
Light Transport</h3>
<h3 id="path-guiding">Path Guiding</h3>
<h2 id="overview-of-our-method">3 OVERVIEW OF OUR METHOD</h2>
]]></content>
      <categories>
        <category>CG.Paper</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Paper</tag>
        <tag>MCMC</tag>
      </tags>
  </entry>
  <entry>
    <title>(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(3)</title>
    <url>/2022/04/11/CG/Papers/2021/bvh-survey-2/</url>
    <content><![CDATA[<h1 id="bvh-survey">BVH Survey</h1>
<ul>
<li><a href="/2022/04/06/CG/Papers/2021/bvh-survey-home/">目录</a></li>
</ul>
<h1 id="construct-bvh">4. construct bvh</h1>
<h2 id="incremental-construction">4.3. Incremental Construction</h2>
<ul>
<li>论文：Automatic Creation of Object Hierarchies for Ray Tracing</li>
<li>在插入的时候增量更新</li>
<li>初始的时候为一个人空的
BVH，当插入新物体的时候，找到一个合适的叶子节点进行插入，如果插入之后节点过大则进行分裂</li>
<li>在初始的时候不知道场景中所有物体的时候很有用
<ul>
<li>e.g., streaming the data through the network</li>
</ul></li>
<li>质量通常不是很高</li>
<li>在另一篇论文中改进了
<ul>
<li>Incremental BVH Construction for Ray Tracing
<ul>
<li>以优先队列的方式选择插入场景中的原体，同时贪心的最小化每次插入的代价，结合下面这篇论文的方法，防止插入的时候达到局部最小化</li>
</ul></li>
<li>Fast Insertion-Based Optimization of Bounding Volume
Hierarchies</li>
</ul></li>
</ul>
<h2 id="lbvh">4.4 LBVH</h2>
<ul>
<li>BVH 构建上的并行不是很直观</li>
<li>归约：BVH 的构建能够被归约为对场景原体在 Morton Curve
上的排序，顺序由定长（32/64bit）的 Morton codes 决定
<ul>
<li>排序则有很多并行算法</li>
<li>定长：可以使用基数排序的方式 <span class="math inline">\(O(n)\)</span> 实现</li>
</ul></li>
<li>Morton curve：space-filling curve subdividing space into a uniform
grid
<ul>
<li>每一个小的 grid 都会被分配一个唯一的 morton 码（容易计算）</li>
</ul></li>
</ul>
<p><img src="/2022/04/11/CG/Papers/2021/bvh-survey-2/image-20220412112634150.png"></p>
<h3 id="lbvh-1">LBVH</h3>
<ul>
<li>linear BVH (LBVH)
<ul>
<li>使用 Morton Curve 构建 BVH，GPU-based</li>
<li>top-down</li>
<li>每一个 level 调用一次 kernel</li>
<li>lower level 的时候使用 SAH binning 算法</li>
</ul></li>
<li>论文：Fast BVH Construction on GPUs</li>
<li>算法整体思路
<ul>
<li>linearizing：将输入的原体转化为一个长度为 <span class="math inline">\(n\)</span> 的定长序列</li>
<li>然后我们对所有区间进行递归划分，从而构建起
BVH，每一个节点都对应一段区间
<ul>
<li>root：<span class="math inline">\([0,n)\)</span></li>
</ul></li>
<li>每一个 BVH 上的几点就对应 <span class="math inline">\([l_i.r_i)\)</span> 内的原体</li>
</ul></li>
<li>Morton curve：<em>space filling</em> curve
<ul>
<li>又被称为 Lebesgue curve / z-order curve</li>
</ul></li>
<li>假设
<ul>
<li>使用 AABB 包围盒</li>
<li>每个原体的包围盒都是已知的</li>
<li>整个场景的包围盒是已知的</li>
</ul></li>
<li>使用每个原体的重心表示这个原体</li>
<li>将整个场景的包围盒划分为 <span class="math inline">\(2^k\times2^k\times2^k\)</span>
个格子，于是每一个格子能够使用 3 个 k bit 的整数来表示</li>
<li>morton code 例子如下图所示
<ul>
<li>拼接，然后构成一个顺序</li>
</ul></li>
</ul>
<p><img src="/2022/04/11/CG/Papers/2021/bvh-survey-2/Z-curve.svg"></p>
<ul>
<li>然后根据每一个原体重心的位置为其分配一个 Morton
code，根据这个码进行排序</li>
<li>按照 Morton code
进行排序得到的结果，能够让相邻的原体在空间位置上也是相邻的</li>
<li>一个例子</li>
</ul>
<p><img src="/2022/04/11/CG/Papers/2021/bvh-survey-2/image-20220412144306083.png"></p>
<ul>
<li>构建 BVH
<ul>
<li>从最高位开始，将为 0/1 的原体分别划分到两棵子树内
<ul>
<li>如果全部相同，则看下一位</li>
</ul></li>
<li>递归处理子树，直到所有位都处理完毕</li>
</ul></li>
<li>构造过程等价于 MSD 的 2-基数排序（most-significant-bit radix-2
sort）
<ul>
<li>泛化到 most-significant-bit radix-<span class="math inline">\(2^b\)</span> sort（每次比较 <span class="math inline">\(2^b\)</span> 位），则可以构造出 <span class="math inline">\(2^b\)</span> 叉树</li>
<li>radix-8：octree</li>
</ul></li>
<li>并行算法
<ul>
<li>先排序（并行算法），然后从排好序的序列中构建出 BVH</li>
</ul></li>
<li>排序
<ul>
<li>排序过程中由于高位可能全 0，使用 LSD 效果更好</li>
</ul></li>
</ul>
<h4 id="构建">构建</h4>
<ul>
<li>每一个 morton code
都表示了一个从根节点到这个原体的唯一路径，他们的包围盒就是最近的公共祖先节点
<ul>
<li>例如：<code>0000,0001,0011</code> <span class="math inline">\(\Longrightarrow\)</span> <code>00</code></li>
</ul></li>
<li>对每一组相邻的原体 <span class="math inline">\((i,i+1)\)</span>
做如下处理
<ul>
<li>如果这两个原体，从高位到低数，第 <span class="math inline">\(h\)</span> 位开始不一样，则它们在第 <span class="math inline">\(h,h+1,\cdots,3k\)</span> 层将被隔开（处于不同的
BVH）节点中，因此我们记录如下的 pair</li>
</ul></li>
</ul>
<p><span class="math display">\[
\Big[(i,h),(i,h+1),\cdots,(i,3k)\Big]
\]</span></p>
<ul>
<li>我们将所有的 pair
合在一起，并将它们按照第二个关键字排序，则得到了在某一层的分裂信息</li>
<li>根据这个分裂信息，进行构建</li>
<li>勾结按结果可能存在只有一个儿子的父节点，需要收缩，对每个子结点都向上收缩一遍路径</li>
</ul>
<h4 id="构建例子">构建例子</h4>
<p><img src="/2022/04/11/CG/Papers/2021/bvh-survey-2/image-20220412144306083.png"></p>
<ul>
<li>所有的 Morton code 如下</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">0: 0000</span><br><span class="line">1: 0001</span><br><span class="line">2: 0011</span><br><span class="line">3: 0100</span><br><span class="line">4: 0101</span><br><span class="line">5: 0111</span><br><span class="line">6: 1100</span><br><span class="line">7: 1110</span><br></pre></td></tr></table></figure>
<ul>
<li>得到的的 pair 如下</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(0, 4)</span><br><span class="line">(1, 3), (1, 4)</span><br><span class="line">(2, 2), (2, 3), (2, 4)</span><br><span class="line">(3, 4)</span><br><span class="line">(4, 3), (4, 4)</span><br><span class="line">(5, 1), (5, 2), (5, 3), (5, 4)</span><br><span class="line">(6, 3), (6, 4)</span><br></pre></td></tr></table></figure>
<ul>
<li>排序</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(5, 1)</span><br><span class="line">(2, 2), (5, 2)</span><br><span class="line">(1, 3), (2, 3), (4, 3), (5, 3), (6, 3)</span><br><span class="line">(0, 4), (1, 4), (2, 4), (3, 4), (4, 4), (5, 4), (6, 4)</span><br></pre></td></tr></table></figure>
<ul>
<li>构建顺序的示意图如下
<ul>
<li>最后一行划分为单原体的包围盒没有画出来</li>
</ul></li>
</ul>
<p><img src="/2022/04/11/CG/Papers/2021/bvh-survey-2/image-20220412160221156.png"></p>
<h3 id="hlbvh">HLBVH</h3>
<ul>
<li>hierarchical LBVH
<ul>
<li>combine LBVH with <em>SAH sweeping</em> for the <em>upper
levels</em></li>
</ul></li>
<li>将 sweeping 改进为使用 binning
<ul>
<li>使用 morton code 的前缀作为 bin 的下标</li>
<li>引入和很多同步（并行不友好）</li>
</ul></li>
</ul>
<h3 id="加速构建1">加速构建1</h3>
<ul>
<li>论文
<ul>
<li>Maximizing Parallelism in the Construction of BVHs, Octrees, and k-d
Trees</li>
</ul></li>
<li>一次 kernel 的调用便构建好整棵 BVH
<ul>
<li>之前 LBVH 的构建 level 与 level
之间有相互依赖，这里消除这个依赖</li>
</ul></li>
<li>idea：内部节点和叶子节点放在两个数组里面
<ul>
<li>内部节点的位置和属于该区间的某个端点原体相一致（分裂时的端点）</li>
</ul></li>
</ul>
<p><img src="/2022/04/11/CG/Papers/2021/bvh-survey-2/image-20220412163005057.png"></p>
<ul>
<li>加速从排好序的原体中构建出 BVH
<ul>
<li>我们知道一定会有 <span class="math inline">\(n-1\)</span>
个内部节点</li>
</ul></li>
<li><span class="math inline">\(I,L\)</span>：内部节点、叶子节点</li>
<li>根节点 <span class="math inline">\(I_0:[0,n-1]\)</span>
<ul>
<li>左子节点 <span class="math inline">\([0,\gamma]\)</span>，右子节点
<span class="math inline">\([\gamma+1,n-1]\)</span></li>
<li>如何确定 <span class="math inline">\(\gamma\)</span> ？</li>
</ul></li>
<li><span class="math inline">\(\delta(i,j)\)</span>：表示 <span class="math inline">\(k_i,k_j\)</span> 的最长公共前缀的长度
<ul>
<li>如果 <span class="math inline">\(j\notin[0,n-1]\)</span> 等于 <span class="math inline">\(-1\)</span></li>
</ul></li>
<li>算法：确定节点 <span class="math inline">\(I_i\)</span>
的左右端点（至少含有两个原体）
<ul>
<li>其中一个端点是确定的，<span class="math inline">\(k_i\in
I_i\)</span>
<ul>
<li>直观的理解，<strong>每一对相邻的节点只会被分裂一次</strong>，因此可以有这种规定</li>
</ul></li>
<li>确定方向，左还是右（那一边公共前缀的长度更长）
<ul>
<li>不存在 <span class="math inline">\(a&lt;b&lt;c\)</span>
的公共前缀长度相同（二进制表示），否则则有 <span class="math inline">\(\text{x1,x2,x3}\)</span>（<span class="math inline">\(\text{x}\)</span> 表示前缀）</li>
</ul></li>
<li><span class="math inline">\(I_i\)</span>
内部的最长公共前缀一定要大于 <span class="math inline">\(\delta(k_i,k_{i-d})\)</span>，否则不是分裂点
<ul>
<li>根据这个性质去找另外一个端点</li>
</ul></li>
<li>找端点，找端点只是为了更新 <span class="math inline">\(\delta_{node}\)</span> 的值
<ul>
<li>6-8 行，先确定另外一个端点的最大返回
<ul>
<li>倍增尝试</li>
</ul></li>
<li>10-14 行，找到端点之后，使用二分进行结果的查找
<ul>
<li>原理：<span class="math inline">\(\delta(a,b)\ge\delta(a,c),a&lt;b&lt;c\)</span></li>
</ul></li>
</ul></li>
<li>接下来确定分裂点（左右子节点）
<ul>
<li>二分查找（分裂点左右两段内部的 <span class="math inline">\(\delta&gt;\delta_{node}\)</span>）</li>
</ul></li>
</ul></li>
<li>结果图</li>
</ul>
<p><img src="/2022/04/11/CG/Papers/2021/bvh-survey-2/image-20220412164651792.png"></p>
<ul>
<li>伪代码如下</li>
</ul>
<p><img src="/2022/04/11/CG/Papers/2021/bvh-survey-2/image-20220412164248380.png"></p>
<ul>
<li><a href="/utils/show_code/index.html?CG/Paper/2021/bvh-survey/LBVH-one-kernel-lauch.cpp">c++
代码</a></li>
<li>这里的问题是，这个 pass 只是构建好了 BVH 的拓扑结构，实际上 BVH 中
AABB 包围盒的计算并没有算出来</li>
<li>计算 AABB 包围盒
<ul>
<li>每一个叶子节点一个线程，从叶子节点出发向根节点移动计算 AABB
包围盒</li>
<li>使用全局的原子计数，记录到达每一个内部节点的线程数，当下一个线程处理到这个节点时，前一个处理过这个节点的线程马上终止</li>
<li>每一个节点只会被一个线程同时处理，时间复杂度是 <span class="math inline">\(O(n)\)</span> 的，<strong>同步问题</strong></li>
</ul></li>
</ul>
<h3 id="加速构建2">加速构建2</h3>
<ul>
<li>论文
<ul>
<li>Fast and Simple Agglomerative LBVH Construction</li>
</ul></li>
<li>在加速构建1的基础上进行优化</li>
<li>一次 kernel 调用便同时构建好拓扑结构和 AABB 包围盒
<ul>
<li>必须是 <strong>bottom-up fashion</strong></li>
</ul></li>
<li>使用了另外一种分布方式</li>
</ul>
<p><img src="/2022/04/11/CG/Papers/2021/bvh-survey-2/image-20220413160043840.png"></p>
<ul>
<li>如果某一个节点覆盖了范围 <span class="math inline">\([a,b]\)</span>
之间的 keys，那么下标为 <span class="math inline">\(a-1,b\)</span>
的两个节点都是当前节点的祖先节点，其中有一个为当前节点的父节点</li>
<li>定义函数 <span class="math inline">\(\delta(i)\)</span>，表示内部节点 <span class="math inline">\(i\)</span> 覆盖的 keys 的最不同位的下标
<ul>
<li>例如节点 <span class="math inline">\(i\)</span> 包含的 keys 为
<code>0010,0011,0100,0101</code>，<span class="math inline">\(\delta(i)=2\)</span></li>
<li>于是如果 x 节点是 y 节点的祖先节点的话，就有 <span class="math inline">\(\delta(x)&gt;\delta(y)\)</span>
<ul>
<li>根据这个性质，我们可以判断 <span class="math inline">\(\delta(a-1),\delta(b)\)</span>
的大小关系，来选择父节点</li>
</ul></li>
<li>实际实现可以使用两端点的 key 异或实现（偏序关系是一致的）</li>
</ul></li>
<li>如何计算 <span class="math inline">\(\delta(i)\)</span>
<ul>
<li><a href="https://github.com/shinjiogaki/bvh/blob/master/bvh_binary.cpp">一个实现</a></li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// delta function in sec3 of the paper</span></span><br><span class="line"><span class="comment">// &quot;Fast and Simple Agglomerative LBVH Construction&quot;</span></span><br><span class="line"><span class="function">__forceinline <span class="type">uint32_t</span> <span class="title">Delta</span><span class="params">(<span class="type">const</span> std::vector&lt;glm::uvec3&gt; &amp;leaves, <span class="type">const</span> <span class="type">uint32_t</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> leaves[id + <span class="number">1</span>].z ^ leaves[id].z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为什么可以这么做呢？
<ul>
<li>上面的红线其实就表示了这两个节点在哪一层会被连接</li>
<li><span class="math inline">\(i\)</span> 号内部节点一定包含叶子节点
<span class="math inline">\(i\)</span></li>
<li>因此这就成了判断：是 <span class="math inline">\(i\)</span>
号节点会先被加进来合并还是 <span class="math inline">\(j\)</span>
号节点会先被加进来合并
<ul>
<li>同时一个内部节点必然包含至少两个 key</li>
<li>上面的计算其实就是算出了红线的位置</li>
</ul></li>
</ul></li>
<li>可以这么理解，内部节点 <span class="math inline">\(i\)</span>
的子节点必然是 <span class="math inline">\([x,i),[i,y)\)</span>
<ul>
<li>这样就可以理解上面的计算了
<ul>
<li>哪边差异小，哪边就会先被连接</li>
</ul></li>
<li>这么理解的话，内部节点的标号也就是肯定的了（不会有冲突），因为每一个相邻的位置只会被分裂一次</li>
</ul></li>
<li>构建包围盒的算法和<strong>加速构建1</strong>一致</li>
<li>感觉这里的优化似乎是省掉了<strong>加速构建1</strong>中的拓扑结构生成部分，把拓扑结构生成直接集成到构建包围盒中</li>
</ul>
<p><img src="/2022/04/11/CG/Papers/2021/bvh-survey-2/image-20220413164630620.png"></p>
<h3 id="其他优化1">其他优化1</h3>
<ul>
<li><strong>内存优化</strong>，紧凑表示，无冗余表达（指针）</li>
<li>This algorithm is the fastest construction algorithm to date.</li>
<li>pipeline</li>
</ul>
<p><img src="/2022/04/11/CG/Papers/2021/bvh-survey-2/image-20220414113910521.png"></p>
<ul>
<li>ostensibly-implicit layout
<ul>
<li>能够快速检测得到二叉树中的缺失部分，能让排布更紧凑</li>
<li>只需要保存包围盒的信息，其他信息都能够推断出来（不需要保存）</li>
</ul></li>
</ul>
<h4 id="ostensibly-implicit-layout">ostensibly-implicit layout</h4>
<p><img src="/2022/04/11/CG/Papers/2021/bvh-survey-2/image-20220414114539385.png"></p>
<ul>
<li>数据结构
<ul>
<li>完全二叉树：需要引入虚拟节点</li>
<li>堆结构：需要预处理，需要存储指针数据</li>
<li>ostensibly-implicit
layout：不需要存储指针（多余的数据），同时不需要预处理</li>
</ul></li>
<li>idea：构造一棵隐式的完全二叉树，把虚拟节点都放在<strong>最右边</strong>，然后编码一系列的小的完全二叉树</li>
<li>物体个数为 <span class="math inline">\(t\)</span></li>
<li><strong>最深的一层</strong>需要引入的虚拟节点的个数 <span class="math inline">\(L_v=2^{\lceil \log_2t\rceil}-t\)</span></li>
<li><strong>最深的一层</strong>总共的叶子结点数 <span class="math inline">\(L_c=t+L_v=2^{\lceil \log_2t\rceil}\)</span></li>
<li>因此树上总结点数 <span class="math inline">\(N_c=2L_c-1\)</span></li>
<li><span class="math inline">\(N_c=N_r+N_v\)</span>
<ul>
<li><span class="math inline">\(N_v\)</span>：virtual
node（树上的虚拟节点总数）</li>
<li><span class="math inline">\(N_r\)</span>：real
node（树上真实的节点的总数）</li>
</ul></li>
<li><span class="math inline">\(L_v\)</span> 可以表示成 2
的幂次方的和，定义如下集合
<ul>
<li><span class="math inline">\(N\)</span> 应该和二进制表示中 <span class="math inline">\(1\)</span> 的个数相等</li>
</ul></li>
</ul>
<p><img src="/2022/04/11/CG/Papers/2021/bvh-survey-2/image-20220414133504567.png"></p>
<p><img src="/2022/04/11/CG/Papers/2021/bvh-survey-2/image-20220414133521419.png"></p>
<ul>
<li><span class="math inline">\(N_v\)</span> 和 <span class="math inline">\(L_v\)</span> 有如下关系
<ul>
<li>叶子数为 <span class="math inline">\(x_k=2^{y_k}\)</span>
构成的完全二叉树的总结点数为 <span class="math inline">\(2x_k-1\)</span></li>
<li>参考上图中的紫色部分，从右往左
<ul>
<li>4（27,28,29,30）向上形成一棵完全二叉树</li>
<li>1（26）又向上形成一棵完全二叉树</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/04/11/CG/Papers/2021/bvh-survey-2/image-20220414140957300.png"></p>
<ul>
<li><span class="math inline">\(count\_set\underline\_bits(X)\)</span>
表示计数 <span class="math inline">\(X\)</span> 的二进制表示中 <span class="math inline">\(1\)</span> 的个数</li>
<li>上面的式子 (5) 表示如下</li>
</ul>
<p><span class="math display">\[
N_v=2L_v-count\_set\_bits(L_v)
\]</span></p>
<ul>
<li>更新</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
N_r
&amp;=N_c-N_v\\
&amp;=(2L_c-1)-(2L_v-count\_set\_bits(L_v))\\
&amp;=2t-1-count\_set\_bits(L_v)
\end{aligned}
\]</span></p>
<h4 id="建立映射">建立映射</h4>
<ul>
<li>一个真实的节点，假设它对应的虚拟节点下标为 <span class="math inline">\(i\)</span></li>
<li>虚拟节点深度 <span class="math inline">\(l_i=\log_2(i+1)\)</span>，<span class="math inline">\(0\le l_i\le
\bar{l}=\lceil{\log_2t}\rceil\)</span></li>
<li>位于深度 <span class="math inline">\(l\)</span>
的虚拟节点个数如下</li>
</ul>
<p><span class="math display">\[
L_{vl}=\left\lfloor{\dfrac{L_v}{2^{\bar{l}-l}}}\right\rfloor=L_v\gg(\bar{l}-l)
\]</span></p>
<ul>
<li>因此这个节点在内存中的位置 <span class="math inline">\(i_m\)</span></li>
</ul>
<p><img src="/2022/04/11/CG/Papers/2021/bvh-survey-2/image-20220414144444748.png"></p>
<ul>
<li><span class="math inline">\(N_{vl}\)</span>
的计算如上面提到的一样</li>
</ul>
<p><span class="math display">\[
N_{vl}=2L_{vl}-count\_set\_bits(L_{vl})
\]</span></p>
<h4 id="建立-bvh-算法">建立 BVH 算法</h4>
<ul>
<li>我们获取到的是按照 Morton code 排序之后的原体序列</li>
<li>内部节点和叶子节点分开存储
<ul>
<li>叶子节点的包围盒可以提前知道，之前已经算出来了</li>
</ul></li>
<li>[3] tNode：上面提到的 <span class="math inline">\(j\)</span>
<ul>
<li>需要通过上面 <span class="math inline">\(eq(9)\)</span>
的计算，得到真实的内存地址</li>
</ul></li>
<li>[23,24]
为了同步，第一个到达当前结点的线程不操作（和之前的优化方法类似）</li>
</ul>
<p><img src="/2022/04/11/CG/Papers/2021/bvh-survey-2/image-20220414144306542.png"></p>
<ul>
<li><a href="https://github.com/Arieys/MonteCarloPathTracing/blob/main/MTPC/BVH.cpp">一个别人代码的实现</a></li>
<li>评价：质量可能不是很高，但是 BVH
构建很快，而且内存占用少（指针隐式表示）</li>
</ul>
<h3 id="其他优化2">其他优化2</h3>
<ul>
<li>扩展了 Morton code，同时将场景中原体的大小编码进去了，能够提升 BVH
的质量</li>
</ul>
]]></content>
      <tags>
        <tag>CG</tag>
        <tag>Paper</tag>
        <tag>occlusion</tag>
        <tag>BVH</tag>
      </tags>
  </entry>
  <entry>
    <title>(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(4)</title>
    <url>/2022/04/14/CG/Papers/2021/bvh-survey-3/</url>
    <content><![CDATA[<h1 id="bvh-survey">BVH Survey</h1>
<ul>
<li><a href="/2022/04/06/CG/Papers/2021/bvh-survey-home/">目录</a></li>
</ul>
<h1 id="construct-bvh">4. construct bvh</h1>
<h2 id="topology-optimization">4.5. Topology Optimization</h2>
<ul>
<li>我们在构建 BVH
的过程中，无法知道子结点的代价函数值，因此都是做的局部优化（简化）
<ul>
<li>例如将子节点的内部节点都当作叶子节点来考虑</li>
</ul></li>
<li>因此结构优化就是先建立好一个 BVH，然后对其进调整优化</li>
<li>这一部分的优化目标基于 SAH（内部节点的 BVH 表面积之和最小）</li>
</ul>
<h3 id="tree-rotation">tree rotation</h3>
<ul>
<li>树结点的旋转操作（二分查找树的旋转操作）</li>
<li>一共有 4 种旋转方式</li>
<li>论文提出了两种方法
<ul>
<li>Hill Climbing</li>
<li>Simulated Annealing：避免陷入局部极值</li>
</ul></li>
</ul>
<h4 id="hill-climbing">Hill Climbing</h4>
<ul>
<li>按照<strong>中序遍历</strong>的方式一次检测每一个节点
<ul>
<li>对每一个节点做如下操作</li>
<li>计算当前点的代价函数</li>
<li>应用上面的 4 种旋转（不行则不旋转），记录代价函数减小最多的旋转
<ul>
<li>如果有减小，使用这个旋转更新，同时更新当前点的代价函数值</li>
<li>如果没有减小，则检测下一个节点</li>
</ul></li>
</ul></li>
<li>问题：可能会陷入局部极值（很多情况下）</li>
</ul>
<h4 id="simulated-annealing">Simulated Annealing</h4>
<ul>
<li>模拟退火</li>
<li>基本思想是，对于可能增加 SAH
的旋转，也有一定概率接受（可能会走向全局最优）</li>
</ul>
<h4 id="结果">结果</h4>
<p><img src="/2022/04/14/CG/Papers/2021/bvh-survey-3/image-20220414163629274.png"></p>
<h3 id="remove-and-reinsert">remove and reinsert</h3>
<ul>
<li>Fast Insertion-Based Optimization of Bounding Volume Hierarchies.
<ul>
<li>移除一棵子树，然后把这棵子树中的节点重新插入</li>
<li>查找空间很大，因此需要确定处理子树的顺序
<ul>
<li>一个直观的顺序：按照 SAH 的代价函数值的大小（下图）</li>
</ul></li>
<li>查找新位置
<ul>
<li>带剪枝的搜索算法（分支限界算法）</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/04/14/CG/Papers/2021/bvh-survey-3/image-20220414171135623.png"></p>
<ul>
<li>T-SAH: Animation Optimized Bounding Volume Hierarchies
<ul>
<li>使用 Metropolis-Hastings sampling 的方式优化先移除哪一棵子树</li>
</ul></li>
</ul>
<h3 id="prbvh">PRBVH</h3>
<ul>
<li>一个很重要的假设：<strong><span style="color:red">每个叶子节点只包含一个三角形</span></strong></li>
<li>论文：Parallel Reinsertion for Bounding Volume Hierarchy
Optimization</li>
<li>并行化，把上面的问题重新形式化成一个可以并行的问题
<ul>
<li>最终结果：类似质量下，<strong>比原来串行化快两个数量级</strong></li>
</ul></li>
<li>The key insight：我们在计算 SA
缩减的时候不需要真正去移除子树，找到最优位置之后再进行移除</li>
<li>给很多个 node 并行的找最优的插入位置（SAH cost 减少最多）</li>
<li>思路：<span id="prbvh_alg">迭代算法</span>
<ul>
<li>输入为一个任意的 BVH，然后迭代优化，每一轮迭代并行执行一组
reinsertion 操作</li>
<li>each node searches for its best output node in parallel</li>
<li>the conflicts between nodes are resolved using the <em>locking
scheme</em></li>
<li>The nodes with successful locks can be reinserted</li>
<li>After the reinsertion, we recompute the bounding boxes and the SAH
cost</li>
</ul></li>
<li>SAH cost</li>
</ul>
<p><span class="math display">\[
c(N)=\dfrac{1}{SA(N)}\left[c_T\sum_{N_i}SA(N_i)+c_I\sum_{N_l}SA(N_l)\vert{N_l}\vert\right]
\]</span></p>
<h4 id="reinsertion-operation">Reinsertion Operation</h4>
<ul>
<li>对每一个节点</li>
<li>将其所在的子树（绿色）连同它的父节点（蓝色）一起移除，然后将其兄弟节点（淡黄色）放到父节点原来的位置</li>
<li>将移除部分插入到找到的最优位置（红色），将这个位置原来的节点挂在兄弟节点的位置</li>
</ul>
<p><img src="/2022/04/14/CG/Papers/2021/bvh-survey-3/image-20220418132910246.png"></p>
<h4 id="parallel-search">Parallel Search</h4>
<ul>
<li><strong>每一个叶子节点都只包含一个三角形</strong></li>
<li>此时优化 SAH cost，就等价于优化这个部分（其他都变为常数）</li>
</ul>
<p><span class="math display">\[
\sum_{N_i}SA(N_i)
\]</span></p>
<ul>
<li>形式化优化问题：maximization of the surface area decrease
<ul>
<li>等价于最大化受影响的 BVH 的 SA 减小</li>
</ul></li>
<li>受影响的 BVH 只有<strong>输入、输出节点之间的路径</strong>
<ul>
<li>上图中的 <code>in-pivot-out</code></li>
<li>pivot：最近公共祖先节点</li>
<li>移除：<span class="math inline">\((pivot,in]\)</span> 中的节点的 SA
的减小的非负的（一定减小或不变）</li>
<li>插入：<span class="math inline">\((pivot,out]\)</span> 中的节点的 SA
的减小是非正的（一定增加或不变）</li>
</ul></li>
<li>可以按照 SA 是增加还是减小，将这些路径上的节点划分为几类
<ul>
<li>路径不包括 in 节点、in 节点的父节点、output 节点</li>
</ul></li>
</ul>
<p><img src="/2022/04/14/CG/Papers/2021/bvh-survey-3/image-20220419111023646.png"></p>
<ul>
<li>对一个输入节点 in，如何寻找输出节点 out？
<ul>
<li>查找所有树上的节点（除了以 in 节点为根的子树内的节点）</li>
<li>利用 <em>parent</em> 指针可以不使用辅助的栈结构实现
<ul>
<li>利用一个 bool 记录是上行还是下行，利用指针进行上下游走</li>
<li><a href="/utils/show_code/index.html?CG/Paper/2021/bvh-survey/preorder.py">python
代码</a></li>
</ul></li>
</ul></li>
<li>总的来说就是一个带剪枝的找最优 output 位置的算法</li>
<li>对于所有的节点，可以并行地找出最佳位置</li>
</ul>
<h5 id="算法细节">算法细节</h5>
<ul>
<li><a href="https://meistdan.github.io/publications/prbvh/slides.pdf">demo</a></li>
<li>初始化的最优 out 节点就是 in 节点的兄弟节点
<ul>
<li>decrease=0</li>
</ul></li>
<li><span class="math inline">\(d_{bound}\)</span>：整条路径的 SA
减小的上界
<ul>
<li><strong>就是对 <span class="math inline">\(d_{direct}\)</span>
上界的估计</strong></li>
</ul></li>
<li><span class="math inline">\(\mathbf{b}_{pivot}\)</span>：去掉 in
节点之后的 pivot 的包围盒
<ul>
<li><span class="math inline">\(\mathbf{b}_{pivot}\)</span>
的计算：pivot 的右子节点的包围盒和 <span class="math inline">\(\mathbf{b}_{pivot}\)</span> 的并集</li>
<li>用于累计计算路径上 SA 的减小</li>
</ul></li>
<li>有些在算法运行过程中不变的量
<ul>
<li><span class="math inline">\(\mathbf{b}_{parent},d_{bound}\)</span></li>
</ul></li>
<li>整体是一个前序遍历的算法</li>
<li><span class="math inline">\(d\)</span>
是进入到新的节点之后才被更新</li>
</ul>
<p><img src="/2022/04/14/CG/Papers/2021/bvh-survey-3/image-20220419133042474.png"></p>
<h6 id="downtrue">down=True</h6>
<ul>
<li><p>down=True</p></li>
<li><p><span class="math inline">\(d\)</span>：搜索到当前 out
节点为止，路径上的 SA <strong>减少值</strong></p>
<ul>
<li>粉红色路径的 SA 减小值</li>
<li>这里的更新是更新粉红色路径最后的节点的
SA，相当于在原来的子树内插入了 in 节点
<ul>
<li>减少值就是 <span class="math inline">\(SA(\mathbf{b}_{out})-SA(\mathbf{b}_{merge})\)</span></li>
</ul></li>
</ul></li>
<li><p><span class="math inline">\(d_{direct}\)</span>：紫色路径（蓝色节点）的 SA
减小值（原来是 in 的父节点）</p>
<ul>
<li>因此这里的更新使用 <span class="math inline">\(SA(\mathbf{b}_{parent})-SA(\mathbf{b}_{merge})\)</span></li>
</ul></li>
<li><p>剪枝：由于 <span class="math inline">\(d\)</span> 在 down=True
的遍历过程中是不增的</p>
<ul>
<li><span class="math inline">\(d_{max}\le d\)</span>（<span class="math inline">\(d\)</span> 表示当前计算得到的 <span class="math inline">\(d\)</span>）</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
d_{may\_be\_best}
&amp;=d_{max}+d_{direct}\\
&amp;\le d+d_{direct}\\
&amp;= d+SA(\mathbf{b}_{parent})-SA(\mathbf{b}_{merged})\\
&amp;\le d+d_{bound}
\end{aligned}
\]</span></p></li>
<li><p>down 的更新</p>
<ul>
<li>剪枝向上回溯</li>
<li>如果没有左子节点，则向上回溯</li>
</ul></li>
</ul>
<p><img src="/2022/04/14/CG/Papers/2021/bvh-survey-3/alg_1.png"></p>
<h6 id="downfalse">down=False</h6>
<ul>
<li>首先更新 <span class="math inline">\(d\)</span>：去除最后一个结点的减小值</li>
<li>两种情况分类讨论：子树的前序遍历完成、还处于前序遍历的 up-phase</li>
<li>遍历完成
<ul>
<li>更新 pivot 的包围盒值
<ul>
<li>原来的 pivot 的包围盒记录的是 pivot 左子树的包围盒
<ul>
<li>因为 in 插入到 pivot 子树中时，pivot 的 SA 变化为 0，不影响 <span class="math inline">\(d\)</span> 的计算</li>
</ul></li>
<li>不包含 in 节点</li>
</ul></li>
<li>27-29：out=pivot</li>
<li>33-36：in 节点不能插入到父节点位置，除了父节点，都需要进行尝试</li>
<li>更新 <span class="math inline">\(d\)</span>：pivot 减去 in 节点 SA
减小了多少</li>
<li>42-44：对兄弟子树进行遍历</li>
</ul></li>
<li>up-phase
<ul>
<li>从左子节点上来，则继续遍历右子节点</li>
<li>从右子节点上来，则继续向上</li>
</ul></li>
</ul>
<h4 id="parallel-reinsertion">Parallel Reinsertion</h4>
<ul>
<li>解决可能存在的冲突问题</li>
<li>两种冲突
<ul>
<li>topological conflicts</li>
<li>path conflicts</li>
</ul></li>
</ul>
<p><img src="/2022/04/14/CG/Papers/2021/bvh-survey-3/image-20220419160520122.png"></p>
<ul>
<li>当发生冲突的时候，丢弃优先级小的</li>
<li>topological conflicts：同时修改树结构
<ul>
<li>并发操作加锁，SA 减小更多的优先操作</li>
<li>锁定影响到的节点</li>
</ul></li>
<li>path conflicts：同时修改 BVH
<ul>
<li>锁定路径上的所有节点</li>
</ul></li>
</ul>
<h5 id="locking-strategy">Locking Strategy</h5>
<ul>
<li>保守的：path+topological 都加锁
<ul>
<li>一定能够保证 SA 减少的总量和所有成功加锁的 path 的 SA
减少之和相等</li>
</ul></li>
<li>激进的：topological 加锁
<ul>
<li>不能保证总量和分量之和想的相等（可能多、少、相等）</li>
<li>实验表明，收敛更快</li>
</ul></li>
</ul>
<h5 id="激进策略分析">激进策略分析</h5>
<ul>
<li>对于一个 AABB 包围盒来说，决定这个包围盒的内部包围盒最多只有 6
个（一个面一个）
<ul>
<li>如果有两个包围盒决定了同一个面，选择一个即可</li>
</ul></li>
</ul>
<h6 id="移除">移除</h6>
<ul>
<li>不同节点的内部节点移除
<ul>
<li>只有决定了包围盒的面的节点移除才会有 positive SA decrease</li>
<li>如果和其它节点共同决定一个面，那么移除这个节点对这个面，SA
无变化</li>
<li>不决定面，则 SA 无变化</li>
</ul></li>
<li>同时对有 positive SA decrease
的节点进行移除，可能会导致总的减少比部分减少之和要小
<ul>
<li>例如移除决定相邻的面的两个节点
<ul>
<li>下图中的 1、2、3，虚线方框部分的在总的减少中只会被计算一次</li>
</ul></li>
</ul></li>
<li>同时移除也可能导致总的减少比部分减少要大
<ul>
<li>决定面的节点的移除，使得本身不决定 bvh 面的节点决定面
<ul>
<li>下图中的 4、5，本身不决定 bvh 面的节点变成决定面</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/04/14/CG/Papers/2021/bvh-survey-3/image-20220420111238432.png"></p>
<h6 id="插入">插入</h6>
<ul>
<li>插入的时候也有类似的问题，本身所有的节点插入，都会有 negative SA
decrease</li>
<li>总的增加 &lt; 分量增加之和
<ul>
<li>1、2、3：图 3 的右下角虚线黑框只会被总的计算一次</li>
<li>5：内部有些红色节点的插入本身会导致 SA 增加，但是现在不会了</li>
</ul></li>
<li>总的增加 &gt; 分量增加之和
<ul>
<li>3、4：一开始最左边红色块的插入不需要计算图 4
的两个黑色虚线黑框内的部分</li>
</ul></li>
</ul>
<p><img src="/2022/04/14/CG/Papers/2021/bvh-survey-3/image-20220420112359213.png"></p>
<h5 id="最好最坏情况分析">最好最坏情况分析</h5>
<ul>
<li>two path analysis</li>
<li>移除（下图中的绿色节点移除）
<ul>
<li>最好：单个移除不影响 bvh，两个一起移除 SA <span class="math inline">\(\to\)</span> 0</li>
<li>最差：单个移除 SA <span class="math inline">\(\to\)</span> 0</li>
</ul></li>
<li>插入（下图中的红色节点插入）
<ul>
<li>最好：单个插入 SA 的增加和两个插入一样</li>
<li>最差：单个插入 SA 的增加都为 0，但是两个插入让其变大
<ul>
<li>红色为点（退化的 bvh）</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/04/14/CG/Papers/2021/bvh-survey-3/image-20220420115022463.png"></p>
<ul>
<li>为什么激进策略更好呢？
<ul>
<li>锁住的节点少，在一次迭代能够有更多操作同时进行（throughput）</li>
<li>一开始的时候，positive SA decrease 比 negative SA decrease
更多，因此总的效果来说是更好的</li>
<li>大量移除的节点都是不决定原来的 bvh 的
<ul>
<li>可能会有更多的 SA decrease，在移除其他节点之后决定了 bvh</li>
</ul></li>
<li>大量插入的节点都是不决定最终的 bvh 的（不会导致 SA increase）</li>
</ul></li>
</ul>
<h4 id="完整算法">完整算法</h4>
<ul>
<li><a href="#prbvh_alg">迭代算法</a></li>
</ul>
<p><img src="/2022/04/14/CG/Papers/2021/bvh-survey-3/image-20220420124655823.png"></p>
<ul>
<li>sparse search
<ul>
<li>算法瓶颈是在查找 search phase</li>
<li>相邻的节点搜索得到的路径引起冲突的可能性比较大，因此同一轮的搜索中，相邻的几个节点我们尽量只搜索少量几个</li>
<li>只有满足如下式子的 <span class="math inline">\(i\)</span>
才进行搜索，<span class="math inline">\(I\)</span> 表示迭代轮数，<span class="math inline">\(\mu\in\{4,\cdots,9\}\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
I(\mod\mu)\equiv i(\mod\mu)
\]</span></p>
<ul>
<li>终止条件
<ul>
<li>两次迭代的 SA cost 差异小于 <span class="math inline">\(\epsilon\)</span></li>
<li>实验值：<span class="math inline">\(\epsilon=0.1\)</span></li>
</ul></li>
<li><a href="https://dcgi.fel.cvut.cz/projects/prbvh/">GPU 实现</a>
<ul>
<li>Find the best node</li>
<li>Lock nodes</li>
<li>Check locks</li>
<li>Reinsert</li>
<li>Recompute bounding boxes</li>
<li>Compute the SAH cost</li>
</ul></li>
</ul>
<h3 id="trbvh">TRBVH</h3>
<ul>
<li>treelet restructuring
<ul>
<li>treelet：small subtrees of a fixed size</li>
</ul></li>
<li>基本思想是重构树形结构
<ul>
<li>每次使用动态规划的方式重构一个 treelet</li>
<li>bottom-up</li>
</ul></li>
<li>改进
<ul>
<li>使用 agglomerative
clustering（聚集方法）代替动态规划，能够处理更大的 treelet</li>
</ul></li>
</ul>
]]></content>
      <tags>
        <tag>CG</tag>
        <tag>Paper</tag>
        <tag>occlusion</tag>
        <tag>BVH</tag>
      </tags>
  </entry>
  <entry>
    <title>(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(2)</title>
    <url>/2022/04/08/CG/Papers/2021/bvh-survey-1/</url>
    <content><![CDATA[<h1 id="bvh-survey">BVH Survey</h1>
<ul>
<li><a href="/2022/04/06/CG/Papers/2021/bvh-survey-home/">目录</a></li>
</ul>
<h1 id="construct-bvh">4. construct bvh</h1>
<h2 id="top-down-construction">4.1 Top-Down Construction</h2>
<ul>
<li>借鉴 KD-tree 的建立过程
<ul>
<li>On Fast Construction of SAH-based Bounding Volume Hierarchies.</li>
</ul></li>
<li>算法
<ul>
<li>根节点包含场景中所有的原体</li>
<li>从根节点开始，将包含的原体划分为两个不相交的子集（对应两个子节点）</li>
<li>对子节点做递归的操作，直到遇到终止条件</li>
</ul></li>
<li>终止条件
<ul>
<li>节点中包含的最大原体数目（叶子节点）</li>
<li>最大树深度</li>
<li>最大使用内存</li>
</ul></li>
<li>问题：划分为两个子集的方式很多，是<strong>指数级别</strong>的（NPC）
<ul>
<li>Object partitioning considered harmful: space subdivision for BVHs
<ul>
<li>AABB 包围盒 <span class="math inline">\(O(n^6)\)</span> 的方法</li>
<li>进一步可以利用 grid approximation 控制时间复杂度，同时受限于 grid
的分辨率，可能只是个局部最优</li>
</ul></li>
</ul></li>
<li>BVH 中，每一个原体只会被引用一次
<ul>
<li>引入空间划分放宽这个限制（section 5.1）</li>
</ul></li>
<li>实际操作中，每一次的划分我们都使用一个轴对齐的平面（axis-aligned
plane）
<ul>
<li>对于场景的原体，我们使用一个点来代替
<ul>
<li>可以是包围盒的中心</li>
</ul></li>
<li>这个点只会在选择平面的一侧</li>
</ul></li>
<li><strong>划分轴</strong>
<ul>
<li>首先我们选择一个轴（xyz）
<ul>
<li>测试 3 个轴，选出最好的</li>
<li>启发式算法：round-robin，最长的轴
<ul>
<li>rr：根据轴的长度依概率选择划分轴</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>划分平面</strong>
<ul>
<li>选择划分平面的 3 种基本方式
<ul>
<li>恰好把包围盒空间划分为两半：spatial median split</li>
<li>恰好把原体数目换分为两半：object median split
<ul>
<li><strong>实用</strong></li>
</ul></li>
<li>损失函数：split based on a cost model
<ul>
<li>试图求得代价函数的局部最优解</li>
<li>因为我们在划分之前无法准确的知道子结点的代价（cost）</li>
<li>我们将子节点都当作叶子节点进行估计</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/04/08/CG/Papers/2021/bvh-survey-1/image-20220410134940328.png"></p>
<ul>
<li>推导</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
c(N)
&amp;=c(N)^{SAH}\\
&amp;=c_T+\sum_{N_c}\dfrac{SA(N_c)}{SA(N)}c(N_c)\\
&amp;\approx\hat{c}(N)^{SAH}\\
&amp;=c_T+c_I\sum_{N_c}\dfrac{SA(N_c)}{SA(N)}\vert N_c\vert\\
\end{aligned}
\]</span></p>
<ul>
<li>我们也可以把这个当作终止条件的判断标准，如果 <span class="math inline">\(c_I\vert N\vert\le \hat{c}(N)\)</span> 则停止划分
<ul>
<li>也就是说，如果把当前节点当作叶子节点的代价比继续划分更小，则停止划分</li>
</ul></li>
<li>损失函数加上一项，希望子节点的 BVH 重合更少
<ul>
<li><span class="math inline">\(V(N)\)</span>：节点 <span class="math inline">\(N\)</span> 的包围盒的体积</li>
<li><span class="math inline">\(c_O\)</span>：常数</li>
<li>很直观，就是重合的比例越小越好</li>
</ul></li>
</ul>
<p><img src="/2022/04/08/CG/Papers/2021/bvh-survey-1/image-20220410135710171.png"></p>
<ul>
<li>这样的损失函数比 EPO 更容易实现，与渲染相关性小，在 BVH
构建的时候便很容易计算</li>
<li><strong>以下介绍一些寻找划分平面的算法</strong></li>
</ul>
<h3 id="sweeping">sweeping</h3>
<ul>
<li>选择划分平面的时候，依次测试所有的可能平面
<ul>
<li><span class="math inline">\(N-1\)</span> 个在原体之间的平面</li>
</ul></li>
<li><strong>计算代价很大</strong>，尤其是在算法开始的时候，节点包含的原体数目很多</li>
</ul>
<h3 id="binning">binning</h3>
<ul>
<li>将待划分的轴空间平均的划分为 <span class="math inline">\(b\)</span>
个区间</li>
<li>将所有原体映射到 <span class="math inline">\(b\)</span>
个区间内部</li>
<li>现在我们只需要在这 <span class="math inline">\(b-1\)</span>
个平面上测试损失函数即可</li>
<li>实验表明，一个较小的 <span class="math inline">\(b(16/32)\)</span>
效果也不错
<ul>
<li>加速了 bvh 的构建</li>
<li>求交的加速效果和 sweeping 方式差不多</li>
</ul></li>
<li>随着深度变深，可以使用更少数量的 bin</li>
</ul>
<h3 id="binning-并行">binning 并行</h3>
<ul>
<li><p>两种并行方式：horizontal parallelization <span class="math inline">\(\to\)</span> vertical parallelization</p></li>
<li><p>深度较小：horizontal
parallelization（<strong>感觉本质上就是并行的桶排序</strong>）</p>
<ul>
<li><p>少量的内部节点，但是都包含大量的原体</p></li>
<li><p>场景的原体被均等分配给不同的线程（<span class="math inline">\(0\sim T-1\)</span>）</p></li>
<li><p>对于每一个线程，将自己的原体映射到 bin 中（<span class="math inline">\(0\sim B-1\)</span>）</p>
<ul>
<li>可能存在不同的线程中的原体映射到相同的
bin，因此我们让每个线程新包含一个私有的 bin set，最后做完之后在进行合并
<ul>
<li>合并过程如下</li>
</ul></li>
<li>同时每一个线程 <span class="math inline">\(t\)</span> 计算 <span class="math inline">\(N_{L,i,t},N_{R,i,t}\)</span>
<ul>
<li><span class="math inline">\(N_{L,i,t}\)</span> 表示对于线程 <span class="math inline">\(t\)</span> 分到的原体，位于第 <span class="math inline">\(i\)</span> 个 bin 左边（包含 <span class="math inline">\(i\)</span> ）的原体数目</li>
</ul></li>
</ul></li>
<li><p>做完之后，计算得到 <span class="math inline">\(t\)</span>
个前缀和 <span class="math inline">\(N_{L,i}^{t}\)</span>（对所有线程
<span class="math inline">\(1\sim t\)</span> 求和）</p></li>
<li><p>此时每一个线程再扫描一遍它的所有原体，将原体对应的 ID
写到原始的三角形列表中</p>
<ul>
<li>offset 可以从前缀中得到，例如线程 <span class="math inline">\(t\)</span> 中有 <span class="math inline">\(a\)</span> 个落在第 <span class="math inline">\(m\)</span> 个 bin 中，那么这 <span class="math inline">\(a\)</span>
个原体对应的在三角形列表中的偏移就是如下</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\Big[N_{L,m-1,T-1}+N_{L,m,t-1}, N_{L,m-1,T-1}+N_{L,m,t-1}+a\Big)\\
=&amp;\Big[N_{L,m-1,T-1}+N_{L,m,t-1},N_{L,m-1,T-1}+N_{L,m,t}\Big)
\end{aligned}
\]</span></p></li>
<li><p>遍历所有的平面，计算最佳划分平面</p></li>
</ul></li>
<li><p>深度较大：vertical parallelization</p>
<ul>
<li>子树数量和线程数目相当</li>
<li>每一棵子树分配给一个线程</li>
</ul></li>
</ul>
<h3 id="bonsai-算法">Bonsai 算法</h3>
<ul>
<li>Bonsai: Rapid Bounding Volume Hierarchy Generation using Mini
Trees</li>
<li>算法
<ul>
<li>首先利用 spatial median split
的方式，将所有的三角形划分为若干个相邻的区域（cluster）</li>
<li>对于每一个区域建立一个 mini-tree，mini-tree 使用 sweeping
的方式建立</li>
<li>之后，将这些区域都看成叶子节点，建立上层的 BVH
<ul>
<li>论文还提出了剪枝优化</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/04/08/CG/Papers/2021/bvh-survey-1/image-20220410155941425.png"></p>
<h3 id="phr-算法">PHR 算法</h3>
<ul>
<li>progressive hierarchical refinement (PHR)
<ul>
<li>Parallel BVH Construction Using Progressive Hierarchical
Refinement</li>
</ul></li>
</ul>
<p><img src="/2022/04/08/CG/Papers/2021/bvh-survey-1/image-20220410162650568.png"></p>
<ul>
<li>算法
<ul>
<li>首先按照某种方式建立起 BVH（论文是 LBVH）</li>
<li>找到一个
cut（一组节点，这组节点能够将根节点和所有叶子节点分开）</li>
<li>要求这个 cut 满足如下性质
<ul>
<li>包含的树上的节点数量最少</li>
<li>表面积之和小于一个设定的阈值</li>
</ul></li>
<li>对这个 cut，将其划分为两个集合
<ul>
<li>遍历 3 个轴，使用 sweeping 算法得到最好的划分平面</li>
<li>算的很快，因为节点数目和场景中的原体数目相比很小</li>
</ul></li>
<li>此时我们得到两个新的 cut（此时我们建立起了一个两层的 bvh）</li>
<li>对这两个 cut 构建子树（把 cut
内部节点的所有子节点都挂到这个节点上形成一棵树），重复上面的算法（找
cut）
<ul>
<li>阈值会根据细分的次数进行更新</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2022/04/08/CG/Papers/2021/bvh-survey-1/image-20220410161837153.png"></p>
<h3 id="其他算法">其他算法</h3>
<ul>
<li>更好的近似 EPO 代价函数</li>
<li>a parallel on-demand construction on the GPU
<ul>
<li>只构建在遍历过程中可能经过的部分</li>
</ul></li>
<li>随机采样划分平面
<ul>
<li>Automatic Bounding Volume Hierarchy Generation Using Stochastic
Search Methods</li>
</ul></li>
<li>GPU-based
<ul>
<li><strong>binning</strong></li>
<li><strong>uniform grids of various resolutions</strong> to accelerate
binning on GPUs</li>
</ul></li>
<li>其他的 binning 算法
<ul>
<li>根据节点的大小进行分类（而不是位置）</li>
</ul></li>
<li>利用 k-means 的方式构造 BVH，形成 k-分叉的 BVH，然后再聚合</li>
</ul>
<p><img src="/2022/04/08/CG/Papers/2021/bvh-survey-1/image-20220410163941431.png"></p>
<h2 id="bottom-up-construction">4.2. Bottom-Up Construction</h2>
<ul>
<li>聚合算法
<ul>
<li>最早提出：Fast Agglomerative Clustering for Rendering</li>
</ul></li>
<li>基本思路
<ul>
<li>初始的时候，所有的原体都被当做是 clusters</li>
<li>每轮迭代的时候，最近的两个 cluster 会被合并
<ul>
<li>距离函数：将两个 cluster 都包含的包围盒的表面积</li>
</ul></li>
<li>反复迭代，直至只剩下一个 cluster</li>
</ul></li>
<li>一般而言效果好，但是时间开销极大</li>
<li>从算法来看，很容易看出这里的优化主要集中在 bottom 的部分
<ul>
<li>可能导致 top 部分的优化很差</li>
</ul></li>
<li>优化的难点：每次迭代都需要对每一个点找最近邻
<ul>
<li>the <strong>nearest neighbor search</strong> has to be performed for
<strong>each cluster</strong> to determine the closest cluster pair in
<strong>each iteration</strong></li>
</ul></li>
</ul>
<h3 id="堆与-kd-tree">堆与 kd-tree</h3>
<ul>
<li>论文：Fast Agglomerative Clustering for Rendering</li>
<li>数据结构
<ul>
<li>堆：以距离为优先级函数保存最近邻</li>
<li>辅助的 kd-tree：加速最近邻的查找</li>
</ul></li>
<li>伪代码如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">KDTree kd = <span class="keyword">new</span> <span class="built_in">KDTree</span>(InputPoints);</span><br><span class="line">MinHeap heap = <span class="keyword">new</span> <span class="built_in">MinHeap</span>();</span><br><span class="line">foreach A in InputPoints <span class="keyword">do</span> &#123;</span><br><span class="line">    Cluster B = kd.<span class="built_in">findBestMatch</span>(A);</span><br><span class="line">    heap.<span class="built_in">add</span>(<span class="built_in">d</span>(A,B), <span class="keyword">new</span> <span class="built_in">Pair</span>(A,B));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( kd.<span class="built_in">size</span>() &gt; <span class="number">1</span> ) &#123;</span><br><span class="line">    Pair &lt;A,B&gt; = heap.<span class="built_in">removeMinPair</span>();</span><br><span class="line">    <span class="keyword">if</span> (! kd.<span class="built_in">contains</span>(A) ) &#123;</span><br><span class="line">        <span class="comment">// A was already clustered with somebody</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! kd.<span class="built_in">contains</span>(B) ) &#123;</span><br><span class="line">        <span class="comment">// B is invalid, find new best match for A</span></span><br><span class="line">        B = kd.<span class="built_in">findBestMatch</span>(A);</span><br><span class="line">        heap.<span class="built_in">add</span>(<span class="built_in">d</span>(A,B), <span class="keyword">new</span> <span class="built_in">Pair</span>(A,B));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        kd.<span class="built_in">remove</span>(A);</span><br><span class="line">        kd.<span class="built_in">remove</span>(B);</span><br><span class="line">        Cluster C = <span class="keyword">new</span> <span class="built_in">Cluster</span>(A,B);</span><br><span class="line">        kd.<span class="built_in">add</span>(C);</span><br><span class="line">        Cluster D = kd.<span class="built_in">findBestMatch</span>(C);</span><br><span class="line">        heap.<span class="built_in">add</span>(<span class="built_in">d</span>(C,D), <span class="keyword">new</span> <span class="built_in">Pair</span>(C,D));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>不太容易并行</strong>，kd-tree 在合并的过程中会被更新</li>
</ul>
<h3 id="aac">AAC</h3>
<ul>
<li>approximate agglomerative clustering (AAC)
<ul>
<li>Efficient BVH Construction via Approximate Agglomerative
Clustering</li>
</ul></li>
<li>idea：利用 Morton curve 来限制最近邻搜索的区域
<ul>
<li>Morton curve，section 4.4</li>
</ul></li>
<li>首先，场景中的原体按照 <em>spatial median splits</em> based on
<em>Morton codes</em> 的分割方式进行分割，直到每一棵子树包含的 cluster
数目都小于预先设定的一个值</li>
<li>在每一棵子树中对 cluster 进行合并
<ul>
<li>利用聚合算法进行合并，直到数量比较小（可以不是 1）</li>
</ul></li>
<li>此时对还没有合并的 cluster 进行合并
<ul>
<li>不是所有的 cluster 都放到一起合并，cluster
数目都小于预先设定的一个值，会先分成多个</li>
</ul></li>
<li>反复合并，直到树构建完成</li>
</ul>
<p><img src="/2022/04/08/CG/Papers/2021/bvh-survey-1/image-20220410174645839.png"></p>
<ul>
<li>每一次合并，为了加速最近邻的查找，使用一个距离矩阵（<span class="math inline">\(n^2\)</span>）进行 cache
<ul>
<li>因为每次合并只有少量的距离会被影响</li>
</ul></li>
</ul>
<h3 id="ploc">PLOC</h3>
<ul>
<li>AAC 一开始划分的时候，栈深度较大（导致距离矩阵大）， GPU 不友好</li>
<li>parallel locally-ordered clustering(PLOC)
<ul>
<li>GPU-based</li>
</ul></li>
<li>idea：距离函数是非减的
<ul>
<li>如果两个 cluster 的最近邻是相互对应的，那么就可以马上合并</li>
<li>这带来了并行的可能，一次合并所有互相对应的 cluster pair</li>
</ul></li>
<li>cluster 保持在 Morton curve
上的有序性，每次查找最近邻，只查找旁边指定数量的邻居（不需要其他的数据结构，例如距离矩阵）</li>
<li>算法
<ul>
<li>使用 Morton curve 找到每一个 cluster 的最近邻</li>
<li>合并所有的互相是最近邻的节点
<ul>
<li>移除这些节点，并且将合并后的新节点放到第一个节点原来的位置</li>
</ul></li>
<li>使用 parallel prefix scan 的方式移除缺失的部分</li>
</ul></li>
<li>一般而言，少量几次迭代便能构建出 BVH</li>
</ul>
]]></content>
      <tags>
        <tag>CG</tag>
        <tag>Paper</tag>
        <tag>occlusion</tag>
        <tag>BVH</tag>
      </tags>
  </entry>
  <entry>
    <title>(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(目录)</title>
    <url>/2022/04/06/CG/Papers/2021/bvh-survey-home/</url>
    <content><![CDATA[<h1 id="bvh-survey">BVH Survey</h1>
<ul>
<li>A Survey on Bounding Volume Hierarchies for Ray Tracing</li>
<li>EuroGraphics 2021</li>
<li><a href="https://meistdan.github.io/publications/bvh_star/paper.pdf">链接</a></li>
</ul>
<h2 id="目录">目录</h2>
<ul>
<li><a href="/2022/04/06/CG/Papers/2021/bvh-survey/">part1</a>
<ul>
<li>层次包围盒介绍、代价函数</li>
</ul></li>
<li><a href="/2022/04/08/CG/Papers/2021/bvh-survey-1/">part2</a>
<ul>
<li>层次包围盒的建立方式、top-down、bottom-up</li>
</ul></li>
<li><a href="/2022/04/11/CG/Papers/2021/bvh-survey-2/">part3</a>
<ul>
<li>BVH 的构建、增量更新、LBVH 的构建</li>
</ul></li>
<li><a href="/2022/04/14/CG/Papers/2021/bvh-survey-3/">part4</a>
<ul>
<li>拓扑结构优化，在建立好一颗 BVH
之后如何做优化，结构旋转，删除与插入，PRBVH，TRBVH</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CG.Paper</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Paper</tag>
        <tag>occlusion</tag>
        <tag>BVH</tag>
      </tags>
  </entry>
  <entry>
    <title>(论文)[2021] A Survey on Bounding Volume Hierarchies for Ray Tracing(1)</title>
    <url>/2022/04/06/CG/Papers/2021/bvh-survey/</url>
    <content><![CDATA[<h1 id="bvh-survey">BVH Survey</h1>
<ul>
<li><a href="/2022/04/06/CG/Papers/2021/bvh-survey-home/">目录</a></li>
</ul>
<h2 id="banner">banner</h2>
<p><img src="/2022/04/06/CG/Papers/2021/bvh-survey/a.jpg"></p>
<h2 id="introduction">1. introduction</h2>
<ul>
<li>加速光追方式
<ul>
<li>efficient sampling techniques</li>
<li>denoising methods</li>
<li>an efficient spatial data structure</li>
</ul></li>
<li>BVH
<ul>
<li>Bounding Volume Hierarchy</li>
<li>层次包围盒</li>
</ul></li>
<li>问题：给定一条光线，找到它和场景原体最近的交点</li>
<li>光在均匀介质中沿<strong>直线</strong>传播</li>
</ul>
<h2 id="preliminaries">2. preliminaries</h2>
<ul>
<li>前置知识</li>
<li>问题：给定一条光线，找到它和场景原体最近的交点
<ul>
<li>光线：<span class="math inline">\(\mathbf{o}+t\mathbf{d}\)</span></li>
</ul></li>
<li><strong>暴力方法</strong>：求出光线和场景中所有原体的交点，取最近的
<ul>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span></li>
</ul></li>
</ul>
<h3 id="bvh">BVH</h3>
<ul>
<li><strong>k叉有根树</strong>
<ul>
<li>叶子节点指向场景中的原体，是包含的原体的包围盒</li>
<li>父节点是子结点的包围盒</li>
<li>根节点是场景中所有原体的包围盒</li>
</ul></li>
<li>基于这样一个事实
<ul>
<li><strong>光线和父节点不相交，那么一定和子节点不相交</strong></li>
</ul></li>
<li>包围盒
<ul>
<li><strong>AABB</strong>：axis-aligned bounding boxes</li>
<li><strong>OBB</strong>：oriented bounding boxes</li>
<li>bounding spheres</li>
</ul></li>
<li>渲染中，场景几何原体一般是 3D 的</li>
</ul>
<h4 id="bvh-的优点">BVH 的优点</h4>
<h5 id="predictable-memory-footprint">Predictable memory footprint</h5>
<ul>
<li>空间复杂度近似是叶子节点数目的 <span class="math inline">\(2\)</span> 倍</li>
<li>满 <span class="math inline">\(k\)</span> 叉树总节点 <span class="math inline">\(N\)</span> 和叶子节点数 <span class="math inline">\(n\)</span> 有如下关系</li>
</ul>
<p><span class="math display">\[
N=n+\dfrac{n-1}{k-1}\le 2n-1
\]</span></p>
<h5 id="robust-and-efficient-query">Robust and efficient query</h5>
<ul>
<li>平均时间复杂度是在 <span class="math inline">\(\log(N)\)</span>
级别的</li>
<li>大多数情况下性能能够和 KD-tree 差不多
<ul>
<li>VINKLER M., HAVRAN V., BITTNER J.: Performance Comparison of
Bounding Volume Hierarchies and Kd-Trees for GPU Ray Tracing. Computer
Graphics Forum (2016)</li>
</ul></li>
</ul>
<h5 id="scalable-construction">Scalable construction</h5>
<ul>
<li>有很多现成的方法</li>
<li>快速建立 <span class="math inline">\(\longrightarrow\)</span>
高度优化：trade-off
<ul>
<li><em>construction speed</em></li>
<li><em>BVH quality</em>
<ul>
<li>MRays/s</li>
</ul></li>
</ul></li>
<li>实时渲染中，由于时间的限制，只允许投射少量的光线，只能够建立中等质量的
BVH（够了）</li>
<li>离线渲染倾向于建立高度优化的 BVH</li>
<li>如下图
<ul>
<li>斜率表示质量，截距表示建立的时间开销</li>
</ul></li>
</ul>
<p><img src="/2022/04/06/CG/Papers/2021/bvh-survey/image-20220406143600980.png"></p>
<h5 id="dynamic-geometry">Dynamic geometry</h5>
<ul>
<li>通过动态调整 BVH 节点实现，传统的 KD-tree 是实现不了的
<ul>
<li>使用 fast BVH construction methods（质量？）</li>
</ul></li>
</ul>
<h4 id="建立-bvh">建立 BVH</h4>
<ul>
<li>自顶向下建立 BVH 的伪代码如下</li>
</ul>
<p><img src="/2022/04/06/CG/Papers/2021/bvh-survey/image-20220406144244562.png"></p>
<h4 id="求交">求交</h4>
<ul>
<li>一般来说有两种需求
<ul>
<li>求出交点：radiance ray</li>
<li>判断某一个点是否被遮挡：occlusion ray
<ul>
<li>occlusion test</li>
</ul></li>
</ul></li>
<li>使用栈来保存可能有交点的树节点</li>
<li><strong>光线和父节点不相交，那么一定和子节点不相交</strong></li>
<li>记录当前已经求出来的最近节点位置，用于剪枝
<ul>
<li>记录 <span class="math inline">\(t\)</span></li>
<li>如果一个包围盒的交点已经比记录的距离远，直接剪枝</li>
<li>这个位置必须是和几何原体求交得到的距离（不能是包围盒，可能不和几何原体相交）</li>
</ul></li>
<li>对于 occlusion test 而言，找到一个交点之后便可以提前停下了（early
exit）</li>
<li>伪代码如下</li>
</ul>
<p><img src="/2022/04/06/CG/Papers/2021/bvh-survey/image-20220406145541667.png"></p>
<ul>
<li>一次求交的过程</li>
</ul>
<p><img src="/2022/04/06/CG/Papers/2021/bvh-survey/image-20220406150012040.png"></p>
<h2 id="cost-function">3. cost function</h2>
<ul>
<li>对于 BVH 质量的评估，可以使用如下的量表示
<ul>
<li><strong>光线一次求交的平均操作次数</strong></li>
</ul></li>
<li>根节点的代价函数（递归定义）</li>
</ul>
<p><img src="/2022/04/06/CG/Papers/2021/bvh-survey/image-20220406150419248.png"></p>
<ul>
<li><span class="math inline">\(\vert
N\vert\)</span>：以当前节点为根节点的子树包含的几何原体数目</li>
<li><span class="math inline">\(P(N_c\vert
N)\)</span>：光线和父节点相交的前提下，子结点 <span class="math inline">\(N_c\)</span> 和光线相交的概率</li>
<li><span class="math inline">\(c_{T}\)</span>：和一个 bvh
节点求交的平均代价</li>
<li><span class="math inline">\(c_I\)</span>：和一个几何原体求交的平均代价</li>
<li><span class="math inline">\(c_I,c_T\)</span>
通常是粗略的估计，而不是汇编级的精确值指令数目
<ul>
<li>实际操作很有用</li>
<li><span class="math inline">\(c_T\)</span> 代价很大 <span class="math inline">\(\Longrightarrow\)</span> 使用更大的 <span class="math inline">\(k\)</span>（更多分叉，更小深度）</li>
</ul></li>
</ul>
<h3 id="sah">SAH</h3>
<ul>
<li>Surface Area Heuristic</li>
<li>将上面的条件概率转化为几何概率（可计算）</li>
</ul>
<p><span class="math display">\[
P(N_c\vert N)^{SAH}=\dfrac{SA(N_c)}{SA(N)}
\]</span></p>
<ul>
<li><span class="math inline">\(SA(\cdot)\)</span> 表示 bvh
节点的表面积</li>
</ul>
<p><img src="/2022/04/06/CG/Papers/2021/bvh-survey/image-20220406152831817.png"></p>
<ul>
<li><span class="math inline">\(N_i\)</span>：以当前节点为根节点的子树的<strong>内部节点</strong>数目</li>
<li><span class="math inline">\(N_l\)</span>：以当前节点为根节点的子树的<strong>叶子节点</strong>数目</li>
<li>SAH 的假设（理想的假设，unrealistic）
<ul>
<li>光线的起点在场景包围盒外部均匀分布</li>
<li>光线的方向均匀分布</li>
<li>光线不会被遮挡</li>
</ul></li>
</ul>
<h3 id="rdh">RDH</h3>
<ul>
<li>ray distribution heuristics</li>
<li>对 SAH 不现实的假设的修正，考虑实际光线的分布</li>
</ul>
<p><span class="math display">\[
P(N_c\vert N)^{RDH}=\dfrac{R(N_c)}{R(N)}
\]</span></p>
<ul>
<li><span class="math inline">\(R(\cdot)\)</span>：击中 bvh
节点的光线数目</li>
<li>最早是在 KD-tree 中提出的</li>
</ul>
<h3 id="oh">OH</h3>
<ul>
<li>occlusion heuristic</li>
<li>在高遮挡条件下，能过够有一个更好的性能</li>
</ul>
<p><span class="math display">\[
P(N_c\vert N)^{OH}=\dfrac{OC(N_c)}{OC(N)}
\]</span></p>
<ul>
<li><span class="math inline">\(O(\cdot)\)</span>：以当前节点为根节点的子树包含的<strong>可见的</strong>几何原体的数目
<ul>
<li><span class="math inline">\(O(N)\)</span> is the number of visible
scene primitives in a subtree with root <span class="math inline">\(N\)</span>.</li>
</ul></li>
<li>这种方法试图将可见的原体和不可见的原体分在不同的 bvh 中
<ul>
<li>如果一个 bvh 中只有（不）可见的原体，则使用 SAH 构建</li>
<li>细节见论文</li>
</ul></li>
<li>单独使用 RDH/OH 可能为导致<strong>不稳定</strong>
<ul>
<li>由于欠采样、过采样导致的</li>
<li>论文中采用和 SAH 进行混合的方法</li>
</ul></li>
</ul>
<h3 id="光源在内部">光源在内部</h3>
<ul>
<li>考虑光源在场景包围盒内部
<ul>
<li>例如发反射光的起点便是在内部</li>
</ul></li>
<li>论文假设：Ray origins are uniformly distributed in space
<strong>inside</strong> S</li>
</ul>
<p><img src="/2022/04/06/CG/Papers/2021/bvh-survey/image-20220406164645979.png"></p>
<ul>
<li><span class="math inline">\(V(\cdot)\)</span>：包围盒的体积</li>
<li><span class="math inline">\(\alpha_{\mathrm{x}}\)</span>：对于 <span class="math inline">\(S\backslash N\)</span> 内部的点 <span class="math inline">\(\mathrm{x}\)</span>，bvh 节点 <span class="math inline">\(N\)</span> 所占的立体角</li>
</ul>
<p><img src="/2022/04/06/CG/Papers/2021/bvh-survey/image-20220406170215330.png"></p>
<ul>
<li>公式解释
<ul>
<li>对于光源起点在 <span class="math inline">\(N\)</span>
内部的光线</li>
<li>对于光源起点 <span class="math inline">\(\mathrm{x}\)</span> 在
<span class="math inline">\(N\)</span> 外部的光线，可见性的比例就是
<span class="math inline">\(\alpha_{\mathrm{x}}\)</span>
<ul>
<li>我们假设方向也是均匀分布的</li>
</ul></li>
</ul></li>
</ul>
<h3 id="epo">EPO</h3>
<ul>
<li>end-point overlap heuristic</li>
<li>动机：几乎大部分光线都是起源于场景中的某个原体
<ul>
<li>多 bounce 情况下的散射</li>
</ul></li>
<li>如果光源的起点处在多个分支的包围盒中，那么我们需要全部遍历他们
<ul>
<li>If a ray origin (or hit point) is inside multiple branches, we have
to visit all of them.</li>
</ul></li>
<li>惩罚这样的表面，他的位置处于某个 bvh
节点中，但是它本身没有被划分在这个节点中</li>
<li>假设三角形可以被拆分（被划分到两个 bvh 中的时候拆分为多个）</li>
<li>理想情况下，我们期望没有重叠发生
<ul>
<li>例如一棵所有三角形都被拆分到叶结点的八叉树（octree）</li>
</ul></li>
</ul>
<p><img src="/2022/04/06/CG/Papers/2021/bvh-survey/image-20220406171835829.png"></p>
<ul>
<li><span class="math inline">\(S\)</span>：场景中所有几何原体的集合</li>
<li><span class="math inline">\(S_{N}=N\cap S\)</span>：在 bvh 节点 N
内部的原体</li>
<li>分解惩罚
<ul>
<li><span class="math inline">\(S^{\ast}_{N}\)</span>：位置在当前 bvh
节点内部，而且属于当前节点的原体</li>
<li><span class="math inline">\(S_{N}\backslash
S^{\ast}_{N}\)</span>：位置在当前 bvh
节点内部，但是不属于当前节点的原体</li>
</ul></li>
</ul>
<p><img src="/2022/04/06/CG/Papers/2021/bvh-survey/image-20220406174325229.png"></p>
<ul>
<li>实现的时候和 SAH 进行混合</li>
<li>如何将其直接用于 bvh 的构建，这个不是很直观</li>
</ul>
]]></content>
      <tags>
        <tag>CG</tag>
        <tag>Paper</tag>
        <tag>occlusion</tag>
        <tag>BVH</tag>
      </tags>
  </entry>
  <entry>
    <title>(论文)[2022] Unbiased Caustics Rendering Guided by Representative Specular Paths</title>
    <url>/2022/10/23/CG/Papers/2022/pathcut-caustic/</url>
    <content><![CDATA[<h1 id="pathcut-caustic">pathcut caustic</h1>
<ul>
<li><strong><em>Unbiased Caustics Rendering Guided by Representative
Specular Paths</em></strong></li>
<li>Sig Asia ’22 Conference Papers</li>
<li><a href="https://wangningbei.github.io/2022/PathcutGuiding.html">主页</a></li>
<li><a href="https://github.com/Lihns/caustics-pathcut">代码</a></li>
</ul>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/theme-snail.png"></p>
<h1 id="abstract">ABSTRACT</h1>
<ul>
<li>首先<strong>快速</strong>搜索得到纯镜面的路径，然后利用链式的球面高斯将其扩展，之后用于
path guiding</li>
</ul>
<h1 id="introduction">1 INTRODUCTION</h1>
<h2 id="之前方法的问题">之前方法的问题</h2>
<ul>
<li>path tracing 的问题：盲目采样</li>
<li>path guiding 的问题：在线学习还不足以捕获高频信息</li>
<li>MLT 的问题：时间一致性问题，连续帧可能不一致</li>
<li>Zeltner 的问题：只能处理镜面</li>
</ul>
<h2 id="主要贡献">主要贡献</h2>
<ul>
<li>a path guiding approach via <strong>representative specular
paths</strong>,</li>
<li>a relaxed path cut approach to represent light transport among
<strong>glossy</strong> surfaces,</li>
<li>an <strong>SG-based representation</strong> to approximate the
contribution from a representative specular path, and</li>
<li>a <strong>spatial reuse strategy</strong> combined with <strong>a
parallax-aware representation</strong> to improve the performance.</li>
</ul>
<h1 id="relatedwork">2 RELATEDWORK</h1>
<ul>
<li>bidirectional Monte Carlo sampling
<ul>
<li>BDPT</li>
<li>Photon Mapping：通常是有偏的</li>
</ul></li>
<li>path guiding
<ul>
<li>学习的分布 + BRDF（利用 MIS）
<ul>
<li>高斯混合模型：GMM（Gaussian Mixture Model）</li>
<li>空间结构划分：spatial-directional tree</li>
</ul></li>
<li>学习的分布 + BRDF（利用乘积）</li>
<li>学习的分布
<ul>
<li>deep neural network model</li>
<li>offline, scene-independent deep-learning approach</li>
</ul></li>
<li>评价
<ul>
<li>Pros：consistent and temporally coherent</li>
<li>Cons：由于算法框架问题，不能处理 difficult paths、high-frequency
effects</li>
</ul></li>
</ul></li>
<li>specular manifold sampling（<span style="color:red"><strong>TO
LEARN</strong></span>）
<ul>
<li>Manifold exploration
<ul>
<li>作为 MLT 的插件被提出，适用于 caustic</li>
<li>不支持 glossy，需要把 specular 和 diffuse 严格硬性划分开（rigid
separation）才能计算</li>
<li>改进：Half vector space 使得划分更自然</li>
<li>改进：适应复杂几何，解决 Jacobian 求解问题</li>
<li>评价：基于 MLT，时序不稳定</li>
</ul></li>
<li>manifold next event estimation（MNEE）：基于 MC 框架
<ul>
<li>改进：扩展到 BDPT</li>
<li>改进：同时处理 caustic 和 glints，提高了鲁棒性和收敛率
<ul>
<li>问题：large-roughness reflectors</li>
</ul></li>
</ul></li>
<li>analytic expressions
<ul>
<li>Slope-Space Integrals for Specular Next Event Estimation</li>
</ul></li>
</ul></li>
</ul>
<h1 id="our-approach">3 OUR APPROACH</h1>
<h2 id="problem-analysis-and-motivation">3.1 Problem analysis and
motivation</h2>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/reflectors-and-receiver.png"></p>
<h3 id="定义">定义</h3>
<ul>
<li>reflectors：the surfaces that are <strong>closer to the light
source</strong> and are <strong>casting caustics</strong></li>
<li>receiver：the surface that <strong>shows the caustics</strong></li>
</ul>
<h3 id="pathcut-流程">pathcut 流程</h3>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/pathcut.png"></p>
<ul>
<li>问题
<ul>
<li>find <strong>a representative path</strong> for each <strong>glossy
path region</strong></li>
<li>compute the <strong>radiance distribution</strong>, once we have a
representative path</li>
</ul></li>
</ul>
<h2 id="solution-overview">3.2 Solution Overview</h2>
<ul>
<li>总体思想
<ul>
<li>对于每一个 glossy
的路径区域，找到一条代表性的<strong>纯镜面光路</strong>（使用 relaxed
path cut 算法）</li>
<li>使用 SG 积分去近似这条光路上的 radiance
分布，保存在一系列缓存点上（空间复用）</li>
<li>渲染的时候，补偿视差，实现精确的 guiding</li>
</ul></li>
<li>适用范围：caustic
<ul>
<li><strong>point</strong> light sources and <strong>small area</strong>
light sources</li>
<li>只实现了 reflective，（refractive 实现类似）</li>
<li>constant roughness（不支持 roughness 贴图）</li>
</ul></li>
</ul>
<h2 id="relaxed-path-cuts-for-glossy-materials">3.3 Relaxed path cuts
for glossy materials</h2>
<h3 id="搜索阶段">搜索阶段</h3>
<ul>
<li>我们对区间求交的条件进行一个 relaxed</li>
<li>法线区间 <span class="math inline">\(n\)</span>，半角向量区间 <span class="math inline">\(v\)</span>，求他们的点积最大值，如果大于给定值
<span class="math inline">\(\cos\theta\)</span>
，则认为相交（这条路径可行，可以保留）
<ul>
<li><span id="eq1" style="color:red"><strong>Spherical Gaussian
compact-<span class="math inline">\(\epsilon\)</span>
support</strong></span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\theta=\arccos\left(\dfrac{\ln(\epsilon\pi\alpha^2)\alpha^2}{2}+1\right)
\]</span></p>
<ul>
<li><span class="math inline">\(\epsilon\)</span> 是阈值，通常设置为
0.01</li>
<li><span class="math inline">\(\alpha\)</span>
表示粗糙程度（roughness）</li>
</ul>
<h3 id="求解阶段">求解阶段</h3>
<ul>
<li>现在我们得到了 leaf path cut</li>
<li>使用 Newton solver 进行求解 <span class="math inline">\(l\)</span>
到 <span class="math inline">\(x\)</span> 的光路
<ul>
<li>端点 <span class="math inline">\(l\)</span>：光源上的点</li>
<li>端点 <span class="math inline">\(x\)</span>：receiver
上的点（焦散显示的点）</li>
</ul></li>
</ul>
<h4 id="一个问题">一个问题</h4>
<ul>
<li>被当作纯镜面的光路求解的时候，求解得到的点可能落在三角形外面，但是对于
glossy 的反射叶来说，仍然和三角形相交</li>
<li>此时我们在三角形内部找一个点，使得误差最小</li>
<li>找到点之后，我们使用的上面的 SG compact-<span class="math inline">\(\epsilon\)</span> <a href="#eq1">公式</a>进行判断是否合理（保留 or 拒绝）</li>
</ul>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/specular-cannot-glossy-can.png"></p>
<ul>
<li>此时我们得到了 representative path</li>
</ul>
<h3 id="讨论">讨论</h3>
<ul>
<li>当三角形表面法线起伏很大时（bumpy），一个 leaf path cut
可能会有多个解，但是牛顿法只能找到一个解
<ul>
<li>Interval Newton 能够找到所有解，但是计算代价很大</li>
</ul></li>
<li>我们这里直接假设三角形表面的法线起伏小（smooth），因此只存在一个解</li>
<li>如果表面材质变得十分粗糙（large roughness），此时 pathcut
的剪枝效率很低，建议用其他方法求解</li>
</ul>
<h2 id="approximating-incident-illumination-with-sgs">3.4 Approximating
incident illumination with SGs</h2>
<ul>
<li>对于上面找到的每一条 representative path，我们需要估计 glossy path
region 的贡献</li>
<li>之前的方法
<ul>
<li>Loubet[Sig20]：slope space
<ul>
<li><span style="color:red"><strong>TO LEARN</strong></span></li>
<li>限制：one intermediate glossy interaction</li>
</ul></li>
</ul></li>
<li>我们使用基于 SG 的方法，能够扩展到<strong>多跳</strong></li>
</ul>
<h3 id="sg">SG</h3>
<ul>
<li>Spherical Gaussian（SG）
<ul>
<li><span class="math inline">\(\mathbf{p}\)</span>：中心方向</li>
<li><span class="math inline">\(\lambda\)</span>：sharpnes（集中程度）</li>
<li><span class="math inline">\(A\)</span>：amplitude（强度）</li>
</ul></li>
</ul>
<p><span class="math display">\[
G(\mathbf{v};\mathbf{p},\lambda,A)=Ae^{\lambda(\mathbf{p}\cdot\mathbf{v})-1}
\]</span></p>
<h3 id="近似-brdf-lobeslice">近似 BRDF lobe/slice</h3>
<ul>
<li>一个 BRDF lobe 能被一个 SG 近似
<ul>
<li><span class="math inline">\(\mathbf{p_{\rho}}=2(\mathbf{n}\cdot\mathbf{o})\mathbf{n}-\mathbf{o}\)</span></li>
<li><span class="math inline">\(\lambda_{\rho}=\dfrac{\lambda_{\text{NDF}}}{4\vert{\mathbf{n}\cdot\mathbf{o}}\vert}\)</span></li>
<li><span class="math inline">\(C_{\rho}=C_{\text{NDF}}\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\rho(\mathbf{i},\mathbf{o})\approx
G_{\rho}(\mathbf{i};\mathbf{p_{\rho}},\lambda_{\rho},C_{\rho})
\]</span></p>
<ul>
<li>其中
<ul>
<li><span class="math inline">\(\mathbf{o}\)</span>：view direction</li>
<li><span class="math inline">\(\mathbf{n}\)</span>：normal</li>
<li><span class="math inline">\(\lambda_{\text{NDF}}=\dfrac{2}{\alpha^2}\)</span></li>
<li><span class="math inline">\(C_{\text{NDF}}=\dfrac{1}{\pi\alpha^2}\)</span></li>
</ul></li>
<li>NDF：normal distribution function
<ul>
<li><span class="math inline">\(\alpha\)</span>：表示材质的粗糙程度</li>
</ul></li>
</ul>
<h3 id="radiance-估计">radiance 估计</h3>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/radiance-approx.png"></p>
<ul>
<li><span class="math inline">\(\mathbf{y}\)</span>：reflector
point</li>
<li>point light or a small spherical light at position <span class="math inline">\(\mathbf{l}\)</span> with radius <span class="math inline">\(r\)</span> and intensity <span class="math inline">\(I\)</span></li>
<li><span style="color:red"><strong>TO LEARN</strong></span></li>
</ul>
<h3 id="sg-乘积">SG 乘积</h3>
<ul>
<li><strong>The product integral of two SGs</strong> can be approximated
as another <strong>SG</strong></li>
</ul>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/SG-dot-SG-is-SG.png"></p>
<ul>
<li><span class="math inline">\(\theta\)</span>：<span class="math inline">\(\langle\mathbf{n},\mathbf{i}\rangle\)</span></li>
<li>Since the variation of <span class="math inline">\(\cos\theta\)</span> over varying <span class="math inline">\(i\)</span> is subtle, we use <span class="math inline">\(\mathbf{n}\cdot\mathbf{p}_l\)</span> to
approximate it</li>
<li>这个式子能够很容易扩展到多个 bounces</li>
</ul>
<h3 id="shading">shading</h3>
<ul>
<li>对于一个着色点（shading point） <span class="math inline">\(\mathbf{x}\)</span> 来说，来自一个 <strong>glossy
path region</strong> 的入射 <strong>radiance</strong> 分布被使用一个 SG
来近似</li>
</ul>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/SG-approx-from-glossy-path-region.png"></p>
<ul>
<li>如图，上面的结果都是使用 SG 来近似
<ul>
<li><span class="math inline">\(G_{\rho}(\mathbf{i})\)</span>：the
radiance at the emitter（SG）</li>
<li><span class="math inline">\(G_{l}(\mathbf{i})\)</span>：a BRDF slice
with outgoing direction <span class="math inline">\(\mathbf{o}\)</span>（SG）</li>
<li><span class="math inline">\(G_{r}(\mathbf{o})\)</span>：对于每一个
representative specular path，对于从这段 glossy path region 到 <span class="math inline">\(\mathbf{x}\)</span> 点的入射 radiance 分布被近似为
<span class="math inline">\(G_{r}(\mathbf{o})\)</span>
<ul>
<li>上面有两个：蓝色、红色</li>
</ul></li>
</ul></li>
<li>使用 GMM 来表示多条 representative specular path 的结果
<ul>
<li>GMM：<span style="color:red"><strong>TO LEARN</strong></span></li>
</ul></li>
<li>实际过程中发现，相邻的三角形可能会有相同的 reflector
point，因此我们计算不同的 representative paths 上的 reflector
points，如果它们之间的距离小于设定阈值，则认为似乎同一个 reflector point
<ul>
<li>只保留一条 representative path</li>
</ul></li>
<li>实测发现这样的近似效果很好（更多看补充材料）</li>
</ul>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/ex.png"></p>
<h2 id="spatial-reusing-of-representative-specular-path">3.5 Spatial
reusing of representative specular path</h2>
<ul>
<li>预计算
<ul>
<li>对每一个着色点都在线运行牛顿法求解是很耗时的</li>
<li>观察发现相邻的着色点的入射 radiance 分布类似</li>
<li>因此可以离线预计算一部分点（cached points）的入射 radiance
分布（GMMs），然后用这些分布去近似每一个新的 着色点</li>
</ul></li>
<li>shading
<ul>
<li>先找到最近的 cached point 的 GMMs，然后根据视差修正</li>
<li>如下图，着色点 <span class="math inline">\(x\)</span>，右边绿色的点是离 <span class="math inline">\(x\)</span> 最近的 cached point <span class="math inline">\(y\)</span></li>
<li>此时橙色的是 <span class="math inline">\(y\)</span> 的入射 radiance
分布 SG1，紫色的是应该近似成的入射 radiance 分布 SG2</li>
<li>此时我们将 SG1 进行旋转，实现由于视差导致的补偿</li>
</ul></li>
</ul>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/parallax-adaption.png"></p>
<ul>
<li>如何旋转？
<ul>
<li>计算 emitter 关于 reflector 的像，然后把镜像和着色点 <span class="math inline">\(x\)</span> 连线，计算得到正确的方向 <span class="math inline">\(\hat{\mathbf{o}}\)</span>
<ul>
<li>这里的 reflector 指的是 representative specular path 中到达 cached
point 之前的最后一个 reflector</li>
</ul></li>
<li>将 SG1 的中心方向 <span class="math inline">\(\mathbf{o}\)</span>
旋转为 <span class="math inline">\(\hat{\mathbf{o}}\)</span></li>
</ul></li>
</ul>
<h3 id="如何旋转">如何旋转</h3>
<ul>
<li>Ruppert et al. 2020
<ul>
<li>the parallax-aware representation for <strong>planar
reflection</strong></li>
<li><span style="color:red"><strong>TO LEARN</strong></span></li>
</ul></li>
<li>受这个启发，我们通过将曲面拆分为两个具有不同主方向（principal
directions）的 reflectors，从而能够纠正任意曲线的 reflector 的视差</li>
</ul>
<h4 id="spherical-reflector">Spherical reflector</h4>
<ul>
<li>示意图如上图的右子图</li>
<li>两个主轴
<ul>
<li>the focal axis（normal）</li>
<li>the sphere’s tangent axis（tangent）</li>
</ul></li>
<li>计算像点（<strong>凸面镜成像公式</strong>）</li>
</ul>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/spherical-reflector-images-eq.png"></p>
<ul>
<li>focal length <span class="math inline">\(f\)</span>
<ul>
<li>concave mirror（凹面镜）：positive</li>
<li>convex mirror（凸面镜）：negative</li>
</ul></li>
<li>计算得到像点之后，连接得到修正的 SG 的主方向 <span class="math inline">\(\hat{\mathbf{o}}\)</span></li>
</ul>
<h4 id="arbitrary-curved-reflector">Arbitrary-curved reflector</h4>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/arbitrary-curved-reflector-images-eq.png"></p>
<ul>
<li>对于任意曲面的 reflector 来说，不存在视角无关的像的位置</li>
<li>对于任意曲面，可以找到两个主曲率方向（principal curvature
directions），可以把这个曲面使用 focal axis 为主曲率方向的两个 spherical
reflector 来近似
<ul>
<li><a href="https://www.cs.otago.ac.nz/postgrads/alexis/DiffGeom/node24.html">主曲率方向</a>（<span style="color:red"><strong>TO LEARN</strong></span>）
<ul>
<li>这两个方向是正交的，可通过<a href="https://zhuanlan.zhihu.com/p/149584374">高斯曲率和平均曲率</a>计算</li>
</ul></li>
<li>如上图，就是蓝色和红色的方向</li>
</ul></li>
</ul>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/delta.png"></p>
<ul>
<li>对于每一个方向求解一个像点
<ul>
<li>这个时候我们会得到一个偏移量（上图中的 <span class="math inline">\(\Delta\)</span> ）</li>
</ul></li>
</ul>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/delta-total.png"></p>
<ul>
<li>对两个方向的偏移量进行叠加，得到总的偏移量，总的偏移量定位了像的位置
<ul>
<li><span class="math inline">\(\mathbf{s},\mathbf{t}\)</span>
是两个主曲率方向，两个 <span class="math inline">\(\Delta\)</span>
对应各自的偏移量</li>
</ul></li>
<li>修正的 SG 的方向为 <span class="math inline">\(\mathbf{xy&#39;}\)</span></li>
<li><span style="color:red"><strong>这样的视差补偿只适用于 one-bounce
的反射</strong></span>，对于 multi-bounces 的情况，我们将之前的
reflector 都当作 spherical reflector
<ul>
<li>具体的见补充资料</li>
</ul></li>
</ul>
<h3 id="讨论-1">讨论</h3>
<ul>
<li>缓存点的建立
<ul>
<li>我们的三角形大小都是相似的，为每一个 receiver
上的三角形生成一个缓存点，然后构建一个 pont cloud</li>
<li>如果三角形的大小是任意的，建议在三角形内部采样</li>
</ul></li>
<li>缓存点数据
<ul>
<li>GMM</li>
<li>用于视差补偿的信息
<ul>
<li><span class="math inline">\(d_v,h_v\)</span></li>
<li>reflector point <span class="math inline">\(\mathbf{y}\)</span></li>
<li>tangent frame at <span class="math inline">\(\mathbf{y}\)</span></li>
</ul></li>
</ul></li>
</ul>
<h2 id="rendering">3.6 Rendering</h2>
<ul>
<li>相机发射光线，光线和某个三角形相交</li>
<li>找到这个三角形上关联的缓存点，得到 GMM</li>
<li>对 GMM 内部的所有 SG 进行视差补偿，构建新的 GMM</li>
<li>使用 MIS 对 BRDF 采样和对 GMM 联合采样，采样一个出射方向，递归进行
<ul>
<li>constant probability（0.5）</li>
</ul></li>
<li>对每一个 bounce 都使用 NEE（next event estimation）</li>
</ul>
<h3 id="讨论-2">讨论</h3>
<ul>
<li>我们对每一个 GMM 添加了一个保护性的 smooth
lobe（覆盖整个半球），这样保证所有可能方向都被采样到</li>
<li><strong>无偏的</strong>（证明作为后续工作）</li>
</ul>
<h1 id="results">4 RESULTS</h1>
<ul>
<li>利用 mitsuba 实现
<ul>
<li>支持材质：<strong>rough conductor</strong> as
<strong>reflector</strong> olny</li>
</ul></li>
<li>对比算法
<ul>
<li>PT、BDPT、PPG、SMS（specular manifold sampling）、SNEE（specular
next event estimation）</li>
<li>reference：65536spp with BDPT</li>
<li>equal time
<ul>
<li>the precomputation and the rendering</li>
</ul></li>
</ul></li>
<li>测试环境
<ul>
<li>4.20GHz Intel i7 (8 cores) with 16 GB of main memory</li>
</ul></li>
<li>RMSE（Root Mean Square Error）</li>
<li>我们的算法支持
<ul>
<li>point light</li>
<li>small sphere lights with less than 0.01 radian
(radius/distance)</li>
<li>环境光留给 PT</li>
</ul></li>
<li>场景设置
<ul>
<li>突出 one-bounce or multi-bounce reflective caustics</li>
</ul></li>
</ul>
<h1 id="discussion-and-limitations">5 DISCUSSION AND LIMITATIONS</h1>
<h2 id="对比其他方法">对比其他方法</h2>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/theme-snail.png"></p>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/musa.png"></p>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/reflective-surface.png"></p>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/three-bumpy-cylinder-scene.png"></p>
<h2 id="视差校准">视差校准</h2>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/ring-scene.png"></p>
<h2 id="牛顿法求解">牛顿法求解</h2>
<ul>
<li>不使用牛顿法求解，则直接使用三角形中心来表示 representative specular
path 中的节点</li>
</ul>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/sphere-scene.png"></p>
<h1 id="conclusion">6 CONCLUSION</h1>
<h2 id="limitation">limitation</h2>
<ul>
<li>Performance：跳数多跑得慢
<ul>
<li>我们的实现最多支持两跳</li>
<li>small roughness 效果好</li>
</ul></li>
<li>Extremely low-roughness materials：SG 近似和视差修正不够准确</li>
</ul>
<p><img src="/2022/10/23/CG/Papers/2022/pathcut-caustic/failure-case.png"></p>
<ul>
<li>Subdivision of the meshes：网格需要足够细分，才能够有效找到路径
<ul>
<li>densely tessellated</li>
<li></li>
</ul></li>
</ul>
]]></content>
      <tags>
        <tag>CG</tag>
        <tag>Paper</tag>
        <tag>path guiding</tag>
      </tags>
  </entry>
</search>
